"3:33:35 PM, Friday, January 22, 2016: Compressing sources...."!

Object comment:
'Object is the abstract root of the standard Smalltalk class hierarchy. It has no instance variables (indeed it must not have any), but provides behavior common to all objects.

Instance Variables:
	<MUST BE NONE>

Class Variables:
	_AssertionFailureSignal 	<Signal> raised when assertion failures occur (see #assert:)
	_DependentsRegister	<WeakIdentityDictionary> containing DependentsCollections for instances
	_EventsRegister 		<WeakIdentityDictionary> containing EventsCollections for instances
	_PropertyRegister 		<PropertyManager> Register of instance specific information not stored in instance variables

The following Instance specific behaviour mask constants are held in the PoolConstantsDictionary _InstanceBehaviorMasks in order that they may be readily shared into user defined root classes.
	_FinalizeMask 		<Integer> bit mask to set/reset the finalize mark of instances
	_GetSpecialMask 		<Integer> bit mask to retrieve special behavior flags of instances
	_WeakMask 		<Integer> bit mask to use to set/reset the weak mark of instances. Includes pointer bit.

Note: All class variables beginning with $_ are private to the implementation. This convention is adopted to avoid potential name clashes with user defined classes, and is a requirement for ANSI compliance.

Object implements the ANSI protocol <Object> (browse the protocols-Object category).

The following messages defined in Object have optimized implementations inlined by the Compiler and cannot be overridden:
	#==
	#basicAt:			(overridable if subclass not indexable)
	#basicAt:put:		(ditto)
	#basicSize
	#basicClass
	#isNil
	#notNil
	#yourself
In addition any selector in Object with a ''basic'' prefix may be subject to inlining in future releases, so these should not be overridden.
'!
!Object class methodsFor!

_eventsRegister
	"Private - Answer the register of events"

	^_EventsRegister!

binaryReadFrom: aStream
	"Answers an object read from its binary representation on aStream.
	This must have been saved using Object>>binaryStoreOn:"

	^self binaryReadFrom: aStream context: nil

!

binaryReadFrom: aStream context: anObject
	"Answers an object read from its binary representation on aStream.
	This must have been saved using Object>>binaryStoreOn:"

	^(STBInFiler on: aStream) context: anObject; next.!

fromBinaryStoreBytes: aByteArray
	"Answers an object read from its binary representation in aByteArray.
	This must have been created using Object>>binaryStoreBytes"

	| stream |
	stream := aByteArray readStream.
	^self binaryReadFrom: stream.


!

fromBinaryStoreBytes: aByteArray context: anObject
	"Answers an object read from its binary representation in aByteArray.
	This must have been created using Object>>binaryStoreBytes"

	| stream |
	stream := aByteArray readStream.
	^self binaryReadFrom: stream context: anObject


!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

initialize
	"Initialise the receiver's class variables

	_PropertyRegister	-	Register of properties (instance specific information not stored
						in instance variables) of objects
	_AlreadyPrinted		-	Set of objects used to detect recursive printing (which would
						otherwise cause a stack overflow).
	_AssertionFailureSignal-	Signalled on #assert: argument evaluting to false."

	_DependentsRegister isNil ifTrue: [self initializeDependencyMechanism].
	_PropertyRegister isNil ifTrue: [self initializePropertyRegister].
	_EventsRegister isNil ifTrue: [self initializeEventsRegister].
	_AssertionFailureSignal isNil ifTrue: [
		_AssertionFailureSignal := Signal resumableDescription: 'assertion failure']!

initializeDependencyMechanism
	"Private - Initialize the dependency register provided for all objects
	which do not have their own dependency register.
	It is not advisable to send this message after booting, as it may make
	the system perform unpredictably."

	_DependentsRegister := WeakIdentityDictionary newWithWeakKeys: 2!

initializeEventsRegister
	"Private - Initialize the events register provided for all objects which don't
	override #getEvents and #setEvents:.
	It is not advisable to send this message after booting, as it may make
	the system perform unpredictably."

	_EventsRegister := WeakIdentityDictionary newWithWeakKeys: 2!

initializePropertyRegister
	"Private - Initialize the property register provided for all objects.
	It is not advisable to send this message after booting, as it may make
	the system perform unpredictably."

	_PropertyRegister := PropertyManager new!

resourcesLocator
	"Answer a default file locator that can be used to locate resource files for this class.
	In a development environment it is assumed that resources will be relative to the package directory for the class. In a runtime
	environment it is assumed that all resources will be in a Resources subdirectory relative to the installation directory"

	^SessionManager current resourcesLocatorForClass: self! !

!Object methodsFor!

_deepCopy: copiesDictionary 
	"Private - Answer a 'deep copy' of the receiver, cloning only those parts not already included
	in the IdentityDictionary argument, copiesDictionary. This method implements the
	body of #deepCopy, and is sufficient for all objects except those holding external 
	resources (where that resource should probably be cloned too), and those where there 
	are circular references from an object to a child and vice versa, and that reference must be
	correctly maintained. In general you should override #deepenShallowCopies:trail: as that
	is easier."

	^copiesDictionary at: self
		ifAbsent: 
			[| clone |
			clone := self shallowCopy postCopy.
			copiesDictionary at: self put: clone.
			(clone == self or: [self class isBytes]) 
				ifTrue: [clone	"no further copying required"]
				ifFalse: 
					[copiesDictionary at: clone put: clone.	"#2198"
					self _deepenShallowCopy: clone trail: copiesDictionary]]!

_deepenShallowCopy: clone trail: copiesDictionary
	"Private - Deepen the argument, clone, which is a shallow copy of the receiver.
	Answer the deepened shallow copy (or another object to represent the deep copy
	if you so desire - though if you do this you must update the copiesDictionary).
	Generally speaking, this is the method which you should override if you need to
	implement deep copy functionality, as this leaves all the boilerplate to the 
	default implementation in Object."

	1 to: self class instSize + self basicSize do: [:i |
		clone instVarAt: i put: ((clone instVarAt: i) _deepCopy: copiesDictionary)].
	^clone!

~~ comparand
	"Answer whether the <Object>, comparand,  is NOT identical to the receiver.
	Implementation Note: This is faster than the obvious '^(self == anObject) not'
	because of Compiler optimisation of #==."

	^(self == comparand) == false!

~= comparand
	"Answer whether the <Object>, comparand, is NOT equivalent to the receiver.
	Implementation Note: This is faster than '^(self = anObject) not' because
	of Compiler optimisation of #==."

	^(self = comparand) == false!

= comparand
	"Answer whether the receiver and the <Object>, comparand, 
	are considered equivalent (in whatever respect is appropriate for 
	the class of the receiver).

	By default two objects are equal if they are identical. This is the
	standard Smalltalk definition, though a better one is:
		Two objects are equal if they are of the same species and
		their contents are equal.
	but this is a recursive definition, and is quite slow to implement in
	general.

	The identity primitive should NOT fail (so there are no primitive failure
	results).
	
	N.B. Equivalent objects (i.e. those that answer true for #=) MUST
	answer the same hash value, in order that they can be stored and
	retrieved successfully from hashed collections. Therefore, classes 
	which reimplement either #= or #hash, will probably need to 
	reimplement both."

	<primitive: 110> 
	^self primitiveFailed!

== comparand
	"Answer whether the <Object>, comparand, is the same, identical, 
	object as the receiver. 
	
	The primitive should NOT fail.
	
	N.B. This implementation cannot be overridden, and is never, in fact, received 
	(unless #perform'd), because #== is inlined by the Compiler."

	<primitive: 110>
	^self primitiveFailed!

-> anObject 
	"Answer an Association with the receiver as the key, and anObject as the value"

	^Association key: self value: anObject!

addDependent: anObject 
	"Include anObject as one of the dependents of the receiver. anObject will subsequently
	receive update messages when the receiver changes (see change and update).
	Uses the private dependents accessing methods #[get|set]Dependents.
	Note that the reference is weak, and will not prevent anObject being GC'd."

	| dependents |
	(dependents := self getDependents) isNil 
		ifTrue: 
			[dependents := WeakArray new.
			self setDependents: dependents].
	^dependents add: anObject!

allReferences
	"Answer an Array containing all objects which reference the receiver.
	The primitive should not fail."

	<primitive: 153>
	^self primitiveFailed!

asParameter
	"Answer the receiver in a form suitable for passing to an external function
	primitive method (see ExternalLibrary and subclasses). The default is self."

	^self!

assert: aBlock
	"Evaluates aBlock and signals an error if the result is not true. The default action is to bring up a
	resumable walkback."

	aBlock value ifFalse: [_AssertionFailureSignal signal]!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^self!

at: index
	"Answer the receiver's indexed instance variable at the argument index.
	As basicAt:, but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size)."

	<primitive: 60>
	^self errorAt: index!

at: index put: value
	"Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value.
	As basicAt:put: but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's mutable size) 
		2	- the argument, value, is not of a class which can be stored in the receiver
			(e.g. its a non-SmallInteger and the receiver is a ByteArray)."

	<primitive: 61>
	^self errorAt: index put: value!

basicAt: aSmallInteger
	"Private - Answer the receiver's indexed instance variable at the argument index.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size) 

	MUST not be reimplemented (except by classes whose instances have immediate representations
	such as SmallInteger).

	Implementation Note: This message is inlined by the compiler, and is never sent 
	unless directly performed, or unless the inlined code detects an error (such as
	an out-of-bounds index). It is not possible to override this message successfully."

	<primitive: 49>
	^self errorAt: aSmallInteger!

basicAt: aSmallInteger put: value
	"Private - Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value. 

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's mutable size) 
		2	- the argument, value, is not of a class which can be stored in the receiver
			(e.g. its a non-SmallInteger and the receiver is a ByteArray).

	MUST not be reimplemented (except by classes whose instances have immediate representations
	such as SmallInteger).

	Implementation Note: This message is inlined by the compiler, and is never sent 
	unless directly performed, or unless the inlined code detects an error (such as
	an out-of-bounds index). It is not possible to override this message successfully."

	<primitive: 50>
	^self errorAt: aSmallInteger put: value!

basicClass
	"Answer a <classDescription> which is the class of the receiver.
	The primitive should not fail."

	"Implementation Note: This message cannot be overridden and always 
	answers the actual class of the receiver, unlike #class which might answer 
	the class of a different object (e.g. in the case of proxies).,"

	<primitive: 111>
	^self primitiveFailed!

basicDoesNotUnderstand: failedMessage
	"A message sent to the receiver was not implemented by the receiver or its superclasses 
	(i.e. it has no appropriate behaviour). This message is useful for by-passing a superclass'
	implementation of #doesNotUnderstand:, as it must not be overridden by subclasses.
	Signal a <MessageNotUnderstood> exception corresponding to the <failedMessage> argument,
	message."

	^MessageNotUnderstood receiver: self message: failedMessage!

basicIdentityIndexOf: anElement from: start to: stop
	"Private - Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	This is intended to assist in the private implementation of some indexable Classes (esp. those which 
	are Weak)	by providing a very fast means of serially searching them, but it requires knowledge of the 
	internal implementation of those Classes to be used correctly, and is therefore private. It can be 
	used directly for instances of classes like Array.

	Primitive fail reasons:

		0 -	start is not a SmallInteger
		1 -	stop is not a SmallInteger
		2 -	start and/or stop is/are outside the indexable bounds of the receiver (1..indexable size)

	The primitive does not fail if the indices are out of bounds but do not specify a valid range - this 
	behavior can be useful when repetitively searching through an object as it simplifies the termination 
	condition (e.g. See WeakArray>>corpsesDo:)."

	| index |
	<primitive: 59>
	index := start.
	[index > stop] whileFalse: [
		(self basicAt: index) == anElement ifTrue: [^index].
		index := index + 1].
	^0!

basicPrintOn: aStream
	"Append a short developer's description of the receiver to aStream. 
	Should not be overridden by subclasses."

	| name |
	name := self basicClass name.
	aStream 
		nextPutAll: (name first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: name!

basicPrintString
	"Answer a short developer's String description of the receiver. 
	Should not be overridden by subclasses"

	| aStream |
	aStream := String writeStream: 16.
	self basicPrintOn: aStream.
	^aStream contents!

basicResize: anInteger
	"Private - Resize the receiver to accomodate anInteger indexable instance variables. 
	As #resize:, but not to be overridden.

	Primitive failure reason:
		0 -	anInteger is not a positive SmallInteger
		1 -	the receiver is not of an indexable (variable sized) class."

	| answer |
	<primitive: 101>
	answer := self class new: anInteger.
	1 to: anInteger do: [ :i | answer basicAt: i put: (self basicAt: i) ].
	self become: answer!

basicShallowCopy
	"Private - Answer a copy of the receiver which shares the receiver's instance 
	variables. This implementation suffices for most objects.
	The primitive does not fail."

	| class copy size |
	<primitive: 155>

	class := self basicClass.
	size := self basicSize.
	copy := class isVariable 
		ifTrue: [class basicNew: size]
		ifFalse: [class basicNew].
	size := size + class instSize.
	1 to: size do: [:i | copy instVarAt: i put: (self instVarAt: i)].
	^copy!

basicSize
	"Private - Sames as #size, but should not be overridden by subclasses (except by subclasses
	whose instances have an immediate representation - e.g. SmallInteger).

	The primitive should not fail. It must be overridden for immediate objects."

	<primitive: 62>
	^self primitiveFailed!

basicYourAddress
	"Private - See #yourAddress. Must not be reimplemented (except by subclasses whose
	instances have immediate representations, e.g. SmallInteger)."

	<primitive: 103>
	^self primitiveFailed!

become: anObject
	"Swap the instance pointers of the receiver and the argument, anObject. All variables 
	in the entire system that pointed to the receiver will now point to the argument, and 
	vice versa.

	Primitive failure reasons:
		0	-	receiver or argument an object with an immediate representation (e.g. 
				a SmallInteger), or either is a 'permanent' objects (nil, true, false, etc).

	This method should be used with extreme care, as it has side effects for others referring
	to the receiver and anObject. In particular never attempt to pass nil, true, false, etc,
	as the argument, as this will almost certainly cause system failure.

	N.B. Though Dolphin is faithful to the original Smalltalk-80 specification for 
	this method, and provides a two way switch as described, this is not universally true 
	for all Smalltalks, so portable code should assume only a one way switch. To better
	guarantee portability you should use #swappingBecome: which, hopefully, will start
	to become prevalent on other platforms."

	<primitive: 72>
	^self primitiveFailed!

becomeA: aClass
	"Change the class of the receiver to aClass, iff they are of the same 'shape' - 
	e.g. pointer objects cannot be converted to byte objects and vice versa.
	
	SmallIntegers	can be mutated to new byte objects which are always of length 4.
	
	Primitive failure reasons:
		0	-	argument, aClass, is not a Behavior
		1	-	receiver's class and aClass are not the same shape.
		
	Consider carefully before using this method as although it may improve performance, 
	it has potential side effects similar to those of #become:. As a rule of thumb, send 
	#becomeA: only to objects of known ownership (e.g. temporaries). Changing the class of 
	objects passed as parameters could well confuse the other objects referencing those 
	parameters. 

	It is always safe to change the class of a SmallInteger, since a new object is created 
	of the specified variable byte class to hold the value of the SmallInteger."

	<primitive: 102>
	^self class instanceSpec = aClass instanceSpec 
		ifTrue: [ self primitiveFailed ]
		ifFalse: [ self error: 'Incompatible class instance shapes' ].
!

becomeAn: aClass
	"Sigh, just to keep Russ (aka The Grammar Pedant) happy."

	^self becomeA: aClass!

beFinalizable
	"Mark the receiver as an object requiring finalization.
	Answers the previous value of the special behavior mask."

	^self setSpecialBehavior: ##(_GetSpecialMask bitOr: _FinalizeMask)!

beStrong
	"Revoke the receiver's status as an object whose indexable pointer variables hold
	only weak references to their contents. Has no effect on objects which are already strong.
	Answers the previous value of the special behavior mask."

	^self setSpecialBehavior: ##(_GetSpecialMask bitXor: (_WeakMask bitShift: 8))!

beUnfinalizable
	"Mark the receiver as an object that does not require finalization. This is the default
	so sending this message is only necessary to reverse a previous #beFinalizable message.
	Answers the previous value of the special behavior mask."

	^self setSpecialBehavior: ##(_GetSpecialMask bitXor: (_FinalizeMask bitShift: 8))!

beWeak
	"Mark the receiver as an object whose indexable variables hold only weak references to
	their contents: that is those variables contents could be garbage collected and replaced
	with the corpse object. When this happens, the receiver will subsequently receive an
	#elementsExpired: message informing of the number of losses it suffered. It is up to the 
	receiver to take appropriate action to locate the corpses and act accordingly, e.g. by 
	turning them into nils, or just updating a tally. 
	Any object of any pointer class may be made weak, but there will be no useful effect 
	for those instances without indexable variables, and this will increase garbage collection 
	overhead. Classes which wish all their instances to be weak, should invoke this method 
	against all newly created instances."

	^self class isPointers
		ifTrue: [self setSpecialBehavior: ##(_GetSpecialMask bitOr: _WeakMask)]
		ifFalse: [self error: 'byte objects cannot be weak']!

binaryStoreBytes
	"Answers a ByteArray representation of the receiver stored in a binary form.
	This can be reconstituted using Object class>>fromBinaryStoreBytes:"

	| stream |
	stream := ByteArray writeStream: 128.
	self binaryStoreOn: stream.
	^stream contents!

binaryStoreOn: aStream
	"Stores the receiver in a binary form on aStream that can be reconstituted using Object class>>binaryReadFrom:.
	Uses the STB filing mechanism to achieve this. This implementation is sufficient for all objects
	that do not need to isolate themselves from their surroundings. Sub-classes may override this
	method to perform such isolation"

	(STBOutFiler on: aStream) nextPut: self.
!

breakDependents
	"Break the connection with all objects which have registered a dependency on the reciever."

	self setDependents: nil!

broadcast: aSymbol
	"Send the argument aSymbol as a unary message to all of the receiver's dependents"

	self dependents nonCorpsesDo: [:dependent | 
		dependent perform: aSymbol]!

broadcast: aSymbol with: aParameter
	"Send the argument aSymbol as a keyword message with argument aParameter
	 to all of the receiver's dependents"

	self dependents nonCorpsesDo: [:dependent | 
		dependent perform: aSymbol with: aParameter]!

changed
	"The receiver changed in some general way; inform all the dependents by sending 
	each of them an #update: message with nil as an argument."

	self changed: nil!

changed: anAspect
	"The receiver changed; the change is denoted by the argument, anAspect. 
	Usually the argument is a Symbol that is part of the dependent's change 
	protocol, but it may be any object which gives a hint as to the type of change"

	self changed: anAspect with: nil!

changed: anAspect with: aParameter
	"The receiver changed; the change is denoted by the argument, anAspect and an 
	argument in aParameter."

	self dependents nonCorpsesDo: [ :dependent | 
		dependent update: anAspect with: aParameter from: self]!

class
	"Answer a <classDescription> which is the class of the receiver.
	The primitive should not fail."

	<primitive: 111>
	^self primitiveFailed!

copy
	"Answer an <Object> which is a copy of the receiver (by default a copy which shares the receiver's 
	instance variables). This may be reimplemented to return a deep copy, or some other 
	form of copy (e.g. a 2-level copy, or, for an identify object, the same object), whatever
	is appropriate for the receiver."

	#todo "This is a fragile implementation of an ANSI method (breakable by subclasses), and hence the selectors need _ prefixes".
	^self shallowCopy postCopy.!

deepCopy
	"Answer a 'deep copy' of the receiver. The 'deep copy' is a clone of the receiver,
	sharing only those parts which cannot be copied (e.g. classes, nil, true, false, 
	SmallIntegers, Symbols, Characters, etc).
	This is sufficient for all objects except those holding external resources (where a 
	true deepCopy will clone that resource too), and those where there are circular
	references from an object to a child and vice versa, and that reference must be
	correctly maintained. In these circumstances it is appropriate to override
	#_deepCopy:, which implements the body of the method. You should generally not override
	#deepCopy."

	^self _deepCopy: IdentityDictionary new!

dependents
	"Answer a Collection of the receiver's dependents. Portable code should make no assumptions
	about the ordering of the Collection (or its type), and must not modify it."

	| dependents |
	^(dependents := self getDependents) isNil
		ifTrue: [WeakArray new]
		ifFalse: [dependents]!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	self printOn: aStream
!

displayString
	"Answer a String whose characters are a representation of the receiver as a user
	would want to see it.
	N.B. Subclasses should override #displayOn: to provide suitable implementations. 
	You may also want to override #displayString for performance reasons in certain 
	situations, because using a Stream can be a significant overhead where one 
	simply wants the display string of a single object. However, if you override
	#displayString you should also override #displayOn: to provide the same
	representation."

	| stream |
	stream := String writeStream: 32.
	self displayOn: stream.
	^stream contents
!

doesNotUnderstand: failedMessage
	"Sent to the receiver by the VM when a message sent to the receiver was not implemented
	by the receiver or its superclasses (i.e. it has no appropriate behaviour).
	Signal a <MessageNotUnderstood> exception corresponding to the <failedMessage> argument,
	message."

	^MessageNotUnderstood receiver: self message: failedMessage
!

error: signalerText
	"Raise an <Error> exception reporting the error message contained in the
	<readableString> argument, signalerText."

	^Error signal: signalerText!

errorAt: index
	"An at: operation on the receiver failed. Determine the cause of the error, and 
	raise an appropriate error."

	^self isIndexable 
		ifTrue: [ 
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [Error nonIntegerIndex: index]]
		ifFalse: [Error notIndexable: self]
!

errorAt: index put: value
	"An at:put: operation on the receiver failed. Determine the cause of the error, and 
	raise an appropriate error."

	^self isIndexable
		ifTrue: 
			[index isInteger 
				ifTrue: 
					[(index between: 1 and: self size) 
						ifTrue: 
							[self isImmutable 
								ifTrue: [Processor constWriteSignal signalWith: self]
								ifFalse: [self errorCantHold: value]]
						ifFalse: [self errorSubscriptBounds: index]]
				ifFalse: [Error nonIntegerIndex: index]]
		ifFalse: [Error notIndexable: self]!

errorCantHold: anObject
	"Raise an error that the receiver cannot hold anObject (as it is of the wrong type)"

	^self error: 'Can''t hold ', anObject printString!

errorInstVarAt: anInteger put: anObject 
	^anInteger isInteger 
		ifTrue: 
			[(anInteger between: 1 and: self class instSize + self basicSize) 
				ifTrue: 
					[self isImmutable 
						ifTrue: [Processor constWriteSignal signalWith: self]
						ifFalse: [self errorCantHold: anObject]]
				ifFalse: [self errorSubscriptBounds: anInteger]]
		ifFalse: [Error nonIntegerIndex: anInteger]!

errorNotFound: anObject
	"Raise a NotFoundError indicating that anObject was not found 
	in the receiver"

	^NotFoundError new
		receiver: self;
		signalWith: anObject!

errorSubscriptBounds: anInteger
	"Raise a BoundsError because anInteger is outside the subscript bounds of the receiver."

	^BoundsError new
		receiver: self;
		signalWith: anInteger!

events
	"Answer a Collection of the receiver's events"

	| events |
	^(events := self getEvents) isNil
		ifTrue: [NullEventsCollection current]
		ifFalse: [events]!

finalize
	"Perform any death-bed operations as the receiver is about to expire. The default is to
	do nothing.

	It is not necessary to remove an objects finalization mark, since this has already been
	done by the garbage collector. Should you wish an object to be finalized again, you must
	send it #beFinalizable again (this can be done from the #finalize message, but be careful
	as this may leave the object in an endless loop of finalizations, consuming system resources).

	The receiver will cease to exist at some time after its finalize method has completed (at
	the very latest at the next GC), unless that method causes additional references to be 
	taken to the receiver.

	Note that this method is only sent to objects which are marked as requiring
	finalization (see #beFinalizable) when their last strong reference is removed. The
	object will not receive the message immediately, but only on the next run of the 
	Finalizer process (which runs at a low priority), and if the object has outstanding 
	weak references, only then after a run of the full garbage collector (which is necessarily 
	a relatively infrequent occurrence)."

	self free!

free
	"Free any external resources associated with the receiver. Implementations should only
	perform the free operation if valid - i.e. multiple-free's are permissible, it is the
	responsibility of the implementor of free to guard against this, not the callers'. See the
	Object Liberation Strategy pattern for further details."

	!

getDependents
	"Private - Answer the DependentsCollection belonging to the receiver, or nil if the receiver
	has no dependents. Subclasses may override this if they wish to provide their own storage
	for dependents (which is more efficient)."

	^_DependentsRegister at: self ifAbsent: []!

getEvents
	"Private - Answer the EventsCollection belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^_EventsRegister at: self ifAbsent: []!

getSpecialBehavior
	"Private - Answer the receiver's complete special behavior mask,
	useful for transferring to copies, etc."

	^self setSpecialBehavior: _GetSpecialMask!

hash
	"Answer the <integer> hash value for the receiver. By default use the identity hash
	assigned at object creation time, which is temporally invariant.

	Equivalent objects (i.e. those that answer true for #=) MUST
	answer the same hash value, in order that they can be stored and
	retrieved successfully from hashed collections. Therefore, classes 
	which reimplement either #= or #hash, will probably need to 
	reimplement both.

	N.B. The primitive does not fail, but will raise an invalid memory access 
	exception if called for immediate subclasses such as SmallInteger."
	
	<primitive: 75>
	^self primitiveFailed!

icon
	"Answer an Icon representing the receiver."

	^self class icon!

iconImageIndex
	^self icon imageIndex!

identityHash
	"Answer the <integer> identity hash value for the receiver. This is
	currently a 16-bit SmallInteger value, which is always positive (although
	note that SmallInteger's override this implementation to answer 
	themselves and hence an arbitrary object's identity hash is only 
	guaranteed to be an integer). The value is a pseudo-random number 
	assigned when the object is created, and it never changes (i.e. it is temporally 
	invariant). Because the range is limited to 16-bits, very large collections 
	hashed by identity using this value alone are likely to be slow. One could 
	consider including the identityHash of the objects class e.g. 
		^((self class identityHash bitAnd: 16r3FFFFFFF) bitShift: 16) 
			bitOr: self identityHash
		or: <primitive: 147> which is similar.
	However, this would not be safe in general, because #become: and #becomeA:
	might change an object's class, (an object's class is an attribute of the object
	not it's identity).

	Although this implementation is temporally invariant while an object remains
	in memory, a binary filed object is re-incarnated with a different identity,
	and so identity hash collections must be rebuilt or rehashed on load (the 
	standard Collections do this already).

	This need not be reimplemented (except by immediate subclasses), because 
	it is not possible to override #==, indeed reimplementation is jolly unwise.
	
	N.B. The primitive does not fail, but will raise a benign invalid memory access 
	exception if called for immediate subclasses such as SmallInteger."
	
	<primitive: 75>
	^self primitiveFailed!

ifNil: aBlock
	"If the receiver is the nil object, then answer the result of evaluating
	the <niladicValuable>, aBlock, otherwise answer the receiver."

	"Implementation Note: This message is normally inlined by the compiler and so
	is never sent unless #perform'd. The inline form of the bytecodes is:

			dup
			jmp ifNotNil @notNil
			pop
			[...]
		@notNil
	"

	^self!

ifNil: nilBlock ifNotNil: notNilBlock 
	"If the receiver is the nil object, then answer the result of evaluating the
	<niladicValuable>, nilBlock, otherwise answer the result of evaluating the <valuable>,
	notNilBlock. notNilBlock can be a <niladicValuable> or a <monadicValuable>, in which case it
	is evaluated with the receiver as its argument, "

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd. The inline form of the bytecodes in the normal case where the notNilBlock
	is monadic is:

			dup
			jmp ifNotNil @notNil
			pop
			[...]
			jmp @exit
		@notNil
			pop'n'store 'value'
			[:value | ...]
		@exit	
	"

	^notNilBlock argumentCount = 1 ifTrue: [notNilBlock value: self] ifFalse: [notNilBlock value]!

ifNotNil: aBlock 
	"If the receiver is not the nil object, then answer the result of evaluating the valuable
	argument, aBlock, otherwise answer nil. aBlock can be a <niladicValuable> or a
	<monadicValuable>, in which case it is evaluated with the receiver as its argument, "

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd. The inline form of the bytecodes is:

			dup
			jmp ifNil @nil
			pop'n'store 'value'
			[:value | ...]
		@nil
	"

	^aBlock argumentCount = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value]!

ifNotNil: notNilBlock ifNil: nilBlock 
	"If the receiver is the nil object, then answer the result of evaluating the
	<niladicValuable>, nilBlock, otherwise answer the result of evaluating the <valuable>,
	notNilBlock. notNilBlock can be a <niladicValuable> or a <monadicValuable>, in which case it
	is evaluated with the receiver as its argument, "

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd."

	^notNilBlock argumentCount = 1 ifTrue: [notNilBlock value: self] ifFalse: [notNilBlock value]!

initialize
	"Initialise the receiver following instantiation. The default is to do nothing.
	Answer the receiver."

	^self!

instVarAt: index
	"Private - Answer a variable in the receiver. The numbering of the variables begins with 
	named instance variables, and corresponds to the order in which the instance variables
	were defined. Indexed variables have indices following those of the named instance
	variables.

	Primitive failure reasons:
		0	-	aSmallInteger is not a SmallInteger.
		1	-	aSmallInteger is out of bounds (not in the range 1..recieiver's size)."

	<primitive: 73>
	^index isInteger
		ifTrue: [self errorSubscriptBounds: index]
		ifFalse: [Error nonIntegerIndex: index]!

instVarAt: index put: value 
	"Private - Store the argument, value, into a named variable in the receiver. The numbering 
	of the variables begines with named instance variables, and corresponds to the 
	order in which the instance variables were defined. Indexed variables have indices 
	following those of the named instance variables.

	Primitive failure reasons:
		0	-	aSmallInteger is not a SmallInteger.
		1	-	aSmallInteger is out of bounds (not in the range 1..receiver's mutable size)
		2	-	the argument, value, is a type of object which cannot be stored in
				the receiver."

	<primitive: 74>
	^self errorInstVarAt: index put: value!

instVarNamed: aString
	"Answer the value of the named instance variable of the receiver.
	Note that this is a slow and inelegant way to access instance variables,
	and so its should be reserved mainly for testing, debugging, and tools."

	^self instVarAt: (self class indexOfInstVar: aString)!

isFinalizable
	"Answer whether the receiver is marked as requiring finalization.
	Finalizable objects will receive a #finalize message after the garbage
	collector has determined that there are no outstanding references
	to the object, however the delivery of the message is asynchronous
	and an arbitrary interval may elapse before it is delivered."

	^self getSpecialBehavior allMask: _FinalizeMask!

isImmediate
	"Private - Answer whether the receiver has an immediate representation (that is it is entirely
	encoded in an object pointer, e.g. SmallIntegers. Most objects are not immediate."

	^false
!

isImmutable
	"Answer whether the receiver is a constant object, for example a compiled literal."

	<primitive: 177>
	^self primitiveFailed!

isImmutable: aBoolean 
	"Set whether the receiver is a constant object. Any attempt to write to either named or
	indexable instance variables of a constant object will result in an exception. The primitive
	will fail if the receiver is a permanently immutable object such as a <SmallInteger> arnd
	the argument is not 'true'."

	<primitive: 178>
	^self primitiveFailed!

isIndexable
	"Answer whether or not the receiver has indexable instance variables (in addition
	to any named instance variables), and can be accessed using #at:/#at:put:"

	^self class isVariable!

isInteger
	"Answer whether the receiver is a kind of Integer"

	^false
!

isKindOf: candidateClass
	"Answer whether the receiver is an instance of the argument, candidateClass,
	or one of its subclasses.
	The primitive never fails, so the Smalltalk back up code is present for illustrative
	purposes only. The primitive is very fast, so there is no particular reason to
	implement isXXXXXX methods instead, BUT in any case is-kind-of tests are not
	good practice. Tests should be made to see if an object provides a particular
	protocol (if necessary) rather than testing for a particular class."

	<primitive: 57>
	^self class includesBehavior: candidateClass!

isLiteral
	"Private - Answer whether or not the receiver has a literal representation (probably its
	printString) which is directly recognised by the Compiler"

	^false!

isMemberOf: candidateClass
	"Answer whether the receiver is an instance of the argument, 
	candidateClass."

	^self class == candidateClass!

isNil
	"Answer whether the receiver is THE undefined (nil) object.
	N.B. This message is inlined by the compiler and cannot be overridden."

	^false!

isNumber
	"Coerces numbers to true and everything else to false. Number 
	overrides with ^true"

	^false!

isString
	"Answer whether the receiver is a <String>."

	^false!

isSymbol
	"Dolphin doesn't usually include these dubious type tests, but they are used by a number of
	add-on libraries, so we have begrudgingly accepted them into the base."

	^false!

isWeak
	"Answer whether the receiver is an object whose indexable pointer variables hold only weak references
	to their contents."

	^self getSpecialBehavior allMask: _WeakMask!

mustBeBoolean
	"Private - Sent to the receiver by the VM when an attempt was made to test it for its
	boolean status by a CompiledMethod, e.g:

			[1] whileTrue: [ ... ].

	By default an error is raised, but this can be overridden if appropriate, however overrides
	must return true or false to avoid causing an infinite loop. The conditional test which
	raised the error is repeated if #mustBeBoolean returns (i.e. the instruction pointer is not
	advanced over the conditional test that failed), and this may generate a further
	#mustBeBoolean messages if the return value is not itself a <Boolean>."

	^(self error: 'Must be boolean') == true!

noEventsDo: aBlock
	"Evaluate aBlock while ensuring that the receiver will not trigger any events.
	Answers the result of evaluating aBlock"

	| events |
	events := self getEvents.
	^
	[self setEvents: nil.
	aBlock value] ensure: [self setEvents: events]!

notNil
	"Answer whether the receiver is not the undefined (<nil>) object.
	N.B. This message is inlined by the compiler and cannot be overridden."

	^true!

oneWayBecome: anObject
	"Make all references to the receiver be references to the argument (i.e. anObject replaces
	all uses of the receiver, and the receiver's identity and contents are lost). This is the 
	only form of #become: available in some Smalltalk systems. Can follow a two
	way #become: for even more mind boggling fun (to maintain one objects identity, but
	anothers value).

	Primitive failure reasons:
		0	-	receiver or argument an object with an immediate representation (e.g. 
				a SmallInteger), or either is a 'permanent' objects (nil, true, false, etc).

	This method should be used with care, but is some what less dangerous than #become:,
	as it does not affect existing users of anObject. Currently the implementation is not
	as efficient as #become:."

	<primitive: 154>
	^self primitiveFailed!

perform: selector
	"Send the receiver the unary message indicated by the <selector> argument,
	answering the result. 

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not zero."

	<primitive: 83>
	^Error perform: selector failedFor: self withArgs: Array new!

perform: selector with: argument1
	"Send the receiver the keyword message indicated by the arguments, answering the result. 
	The first argument selector is the <selector> of the message. The second <Object> argument, 
	argument1, is the argument of the message to be sent. 

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not one."

	<primitive: 83>
	^Error perform: selector failedFor: self withArgs: (Array with: argument1)!

perform: selector with: argument1 with: argument2
	"Send the receiver the keyword message indicated by the arguments, answering the result. 
	The first argument <selector> is the selector of the message. The other arguments <argument1>
	and <argument2>, are the argument of the message to be sent.

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not two."

	<primitive: 83>
	^Error perform: selector failedFor: self withArgs: (Array with: argument1 with: argument2)!

perform: selector with: argument1 with: argument2 with: argument3
	"Send the receiver the keyword message indicated by the arguments, answering the result. 
	The first argument selector is the <selector> of the message. The other <Object> arguments
	argument1, argument2 and argument3 are the arguments of the message to be sent. 

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not three."

	<primitive: 83>
	^Error perform: selector failedFor: self withArgs: (Array with: argument1 with: argument2 with: argument3)!

perform: selector with: argument1 with: argument2 with: argument3 with: argument4
	"Send the receiver the keyword message indicated by the arguments, answering the result. 
	The first argument selector is the <selector> of the message. The other <Object> arguments
	argument1, argument2, argument3, and argument4 are the arguments of the message to be sent. 

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not four."

	<primitive: 83>
	^Error perform: selector failedFor: self 
		withArgs: (Array with: argument1 with: argument2 with: argument3 with: argument4)!

perform: selector withArguments: arguments
	"Send the receiver the keyword message indicated by the arguments, answering the result. 
	The first argument, selector, is the <selector> of the message. The arguments of the message 
	are the elements of the <Array>, arguments. 

	Primitive failure reasons:
		0 -	The number of arguments expected with the selector is not the number supplied.
		1 -	arguments is not an <Array>."

	<primitive: 84> 
	^Error perform: selector failedFor: self withArgs: arguments!

perform: aSymbol withArgumentsAt: anAddress descriptor: anExternalDescriptor 
	"Private - Send message with selector, aSymbol, to anObject,
	with arguments instantiated from memory at anAddress using the 
	the external arguments types from the typinfo in anExternalDescriptor.
	Implementation Note: For performance and consistency (with outbound external calls) 
	reasons, we use a VM supplied primitive to instantiate and push the arguments and 
	perform the message, but there is no reason that this cannot be done in Smalltalk 
	if different argument conversions are required. The standard conversions are the 
	same as those performed for return types by the external call primitive (see
	the ExternalLibrary class).

	Primitive Failure reasons:
		0	-	anExternalDescriptor is invalid.
		1	-	anAddress is not a valid address object (SmallInteger/byte indirection)
		2	-	the selector, aSymbol, is an immediate object (e.g. a SmallInteger)."

	<primitive: 114>
	^self primitiveFailed!

postCopy
	"Apply any final flourish to the copy that may be required. This should be overridden by
	subclasses which provide their own storage (i.e. in instance variable(s)) for
	events/dependents in order to release those (otherwise the copy will inherit them).

	This selector should have an underscore prefix to avoid the fragile base class problem in
	this ANSI standard class which must be subclassable by compliant programs."

	^self!

primitiveFailed
	"Generate an error to the effect that a primitive has failed, including the failure code
	specified by the primitive."

	| proc |
	proc := Processor activeProcess.
	^self error: 'Primitive ', proc topFrame sender method printString, ' failed (', 
					proc primitiveFailureCode displayString, ')'!

printOn: target
	"Append, to the <puttableStream>, target, a string whose characters are a 
	the same as those which would result from sending a #printString
	message to the receiver.
	N.B. This is really intended for development use. #displayOn: and #displayString
	are complementary methods for generating strings for presentation to an
	end-user."

	| name |
	name := self class name.
	target 
		nextPutAll: (name first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: name!

printString
	"Answer a <readableString> whose characters are a description of the receiver 
	as a developer would want to see it."

	| stream |
	stream := String writeStream: 32.
	self printOn: stream.
	^stream contents!

propertyAt: aSymbol
	"Answers a property value of the receiver whose name matches aSymbol."

	^self propertyManager propertyOf: self at: aSymbol.!

propertyAt: aSymbol ifAbsent: aBlock
	"Answers a property value of the receiver whose name matches aSymbol. If the object
	does not have such a property then aBlock is evaluated."

	^self propertyManager propertyOf: self at: aSymbol ifAbsent: aBlock.!

propertyAt: aSymbol put: valueObject
	"Sets a property value of the receiver whose name matches aSymbol."

	^self propertyManager propertyOf: self at: aSymbol put: valueObject.!

propertyManager
	"Private - Answers the default PropertyManager to use."

	^_PropertyRegister!

refersToLiteral: anObject
	"Private - Answer whether the receiver is a reference to the literal argument.
	This assumes that the receiver is in the role of a literal."

	^self class == anObject class and: [self = anObject]!

release
	"Remove references to objects that may refer back to the receiver. Note that although 
	we remove references to objects that depend on the receiver or receive triggers from it; 
	we don't perform the opposite removal. This means that an object is responsible for 
	deregistering these explictly."

	self breakDependents.
	self removeAllEventsTriggered!

removeAllEventsTriggered
	"Remove all events triggers by the receiver"

	self setEvents: nil!

removeAllProperties
	"Remove all the properties of the receiver."
	
	self propertyManager removeAllPropertiesOf: self!

removeDependent: anObject
	"Remove the argument, anObject, as one of the receiver's dependents. If anObject is not 
	a dependent, do nothing. Answer anObject."

	| dependents |
	(dependents := self getDependents) isNil
		ifFalse: [
			dependents
				remove: anObject ifAbsent: [];
				isEmpty ifTrue: [self setDependents: nil]].
	^anObject!

removeEventsTriggeredFor: anObject
	"Removes all events of the receiver destined for anObject."

	| events |
	(events := self getEvents) notNil ifTrue: [ 
		self setEvents: (events removeEventsTriggeredFor: anObject)]!

removePropertyAt: aSymbol
	"Removes a property of the receiver whose name matches aSymbol."

	^self propertyManager removePropertyOf: self at: aSymbol!

removePropertyAt: aSymbol ifAbsent: aBlock
	"Removes a property of the receiver whose name matches aSymbol. If the object
	does not have such a property then aBlock is evaluated."

	^self propertyManager removePropertyOf: self at: aSymbol ifAbsent: aBlock.!

resize: anInteger
	"Resize the receiver to accomodate anInteger indexable instance variables. If anInteger 
	is greater than the current size of the receiver, then new, safely initialized, elements are 
	added to the end of the receiver. If anInteger is less that the current size of the receiver, 
	then elements are removed from the end of the receiver.

	This is one of the relatively rare Dolphin methods that 'internally' modifies its receiver, 
	not a copy of it, so all objects referencing the receiver will see the change - i.e. it has 
	potential side effects.

	Note also that this implementation is too simple for many objects (e.g. Sets) which will need
	to override it.

	Primitive failure reason:
		0 -	anInteger is not a positive SmallInteger
		1 -	the receiver is not of an indexable (variable sized) class."

	| answer |
	<primitive: 101>
	answer := self class new: anInteger.
	1 to: anInteger do: [:i | answer at: i put: (self at: i)].
	self become: answer!

respondsTo: selector
	"Answer whether the receiver has behaviour defined for the <selector> argument. 
	N.B. Even if an object is able to respond to selector, an error may still result 
	when that selector is sent if, for example, the receiver implements the message with
	#subclassReponsibility."

	^self class canUnderstand: selector!

setDependents: aDependentsCollectionOrNil
	"Private - Set the DependentsCollection of the receiver to be aDependentsCollectionOrNil.
	Answer the receiver."

	aDependentsCollectionOrNil isNil
		ifTrue: [_DependentsRegister removeKey: self ifAbsent: []]
		ifFalse: [_DependentsRegister at: self put: aDependentsCollectionOrNil]!

setEvents: anEventsCollectionOrNil 
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	(anEventsCollectionOrNil isNil or: [anEventsCollectionOrNil isEmpty]) 
		ifTrue: [_EventsRegister removeKey: self ifAbsent: []]
		ifFalse: [_EventsRegister at: self put: anEventsCollectionOrNil]!

setSpecialBehavior: anInteger
	"Private - Set the special behavior bits of the receiver according to the
	low order word of the argument, anInteger. The high order byte of that word
	specifies the AND (or 'keep') mask, used to specify what bits to leave as they
	are, and the low order byte of that word specifies the OR (or 'add') mask, used
	to specify what bits to set. To query the current value, use the mask 16rFF00.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	the receiver is an immediate object."

	<primitive: 69>
	^self primitiveFailed!

shallowCopy
	"Answer a copy of the receiver which shares the receiver's instance 
	variables. This implementation suffices for most objects. The
	primitive does not fail, but #basicShallowCopy provides a Smalltalk
	implementation for documentation purposes."

	<primitive: 155>
	^self basicShallowCopy!

shouldNotImplement
	"The class of the receiver is unable to provide an implementation of a message in 
	the protocol of one of its superclasses. Generate an exception to this effect.

	This error will be experienced when an attempt is made to use inappropriate
	superclass protocol against a subclass which is not a true sub-type (e.g.
	SortedCollection is not a true sub-type of OrderedCollection, as it does
	not support the indexed access method #at:put:."

	| method |
	method := Processor activeProcess topFrame sender method.
	^self error: self class name, ' should not implement ', method selector printString!

size
	"Answer the number of indexed variables in the receiver (0 for non-indexable objects,
	as the named instance variables are not included). The primitive should not fail."

	<primitive: 62>
	^self primitiveFailed!

species
	"Answer the preferred class of the receiver - not always the same as the
	answer to #class (although this implementation uses the class primitive, which
	should not fail). Used, for example, by Collections to determine what type of Collection
	should result from the enumeration messages #collect:, #select:, and #reject:"

	<primitive: 111>
	^self primitiveFailed!

stbFixup: anSTBInFiler at: newObjectIndex
	"Answer the true object that must be used to represent the receiver when read from anSTBInFiler.
	Typically this is overridden by subclasses of STBProxy to answer the proxied object. Other classes
	may also override this method to effectively 'one way become' the receiver to some other object"

	^self!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler.
	The options are:
	1.	to let the filer output the receiver as normal using
			STBOutFiler>>#saveObject: self.
				or
			STBOutFiler>>#saveObject: self as: 0.

	2.	to output nil instead of the receiver using
			STBOutFiler>>#saveObject: self as: nil.

	3.	to output a proxy in place of the receiver using
			STBOutFiler>>#saveObject: self as: anSTBProxy.
		The proxy will be sent a #fixup:at: message at load time (see STB classes) and should then
		answer the object it represents.

	By default, objects are happy to be saved and loaded just as they are (option 1)."

	anSTBOutFiler saveObject: self!

storeOn: aStream
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	self printOn: aStream!

storeString
	"Answer a <readableString> which, when compiled and evaluated, results in
	an object similar to the receiver."

	| stream |
	stream := String writeStream: 32.
	self storeOn: stream.
	^stream contents!

subclassResponsibility
	"Generate an error to the effect that a message was receiver which should have been 
	implemented by a subclass. Useful for completely defining abstract classes.

	This error will be experienced when either, an abstract class has been incorrectly instantiated, or
	a subclass of an abstract class is not completely defined."

	| method |
	method := Processor activeProcess topFrame sender method.
	^Error subclassResponsibility: method selector!

swappingBecome: anObject
	"Swap the instance pointers of the receiver and the argument, anObject. All variables 
	in the entire system that pointed to the receiver will now point to the argument, and 
	vice versa. A synonym for #become:. To better allow for code portablity you should
	use #swappingBecome: and #oneWayBecome: rather than #become:. They are more
	explicit since the behaviour of the latter is not standard across all Smalltalk
	implementations."

	<primitive: 72>
	^self primitiveFailed
!

trigger: anEventSymbol
	"Evaluate the sequence of MessageSends registered for the receiver and the event, 
	anEventSymbol. Also signal a change for any dependents with the 
	trigger name as the aspect. Answer the result returned by the last respondent (for :-})."

	^self events triggerEvent: anEventSymbol!

trigger: anEventSymbol with: aParameter
	"Evaluate the sequence of MessageSends registered for the receiver and the event, 
	anEventSymbol. Passes aParameter along to each MessageSend. Also signal a change for 
	any dependents with the trigger name as the aspect. Answer the value returned
	by the last respondent."

	^self events triggerEvent: anEventSymbol with: aParameter.
!

trigger: anEventSymbol with: aParameter with: anotherParameter
	"Evaluate the sequence of MessageSends registered for the receiver and the event, 
	anEventSymbol. Passes aParameter and anotherParameter along to each MessageSend. 
	Also signal a change for any dependents with the trigger name as the aspect.
	Answer the value returned by the last respondent."

	^self events triggerEvent: anEventSymbol with: aParameter with: anotherParameter.
!

trigger: anEventSymbol withArguments: args
	"Evaluate the sequence of MessageSends registered for the receiver and the event, 
	anEventSymbol. Passes the array of parameters to each message send.
	Answer the value returned by the last respondent."

	^self events triggerEvent: anEventSymbol withArguments: args!

understandsArithmetic
	"Answer whether the receiver understands basic arithmetic (and can therefore
	be operated on like Numbers)."

	^false
!

update: aParameter
	"An object on whom the receiver is dependent has chnanged. The receiver updates its 
	status accordingly. The argument is the argument to the #changed: message. 
	The default is to do nothing."

	^self
!

update: anAspect with: argument
	"An object on whom the receiver is dependent has changed. The receiver updates its 
	status accordingly. anAspect usually identifies the kind of change, and argument gives 
	additional information.	The default is to try the simpler #update: method dropping 
	the argument."

	self update: anAspect!

update: anAspect with: argument from: originator
	"An object on whom the receiver is dependent has changed. The receiver updates its 
	status accordingly. anAspect usually identifies the kind of change, and argument gives 
	additional information. The object that triggered this update was originator.
	The default is to try the simpler #update:with: method dropping the originator."

	self update: anAspect with: argument.!

when: aSymbol perform: aValuable 
	"Adds aValuable to the event list for the event named by aSymbol 
	in the receiver"

	self getEvents 
		ifNil: 
			[| events |
			events := EventsCollection new.
			events addEvent: aSymbol action: aValuable.
			self setEvents: events]
		ifNotNil: [:events | events addEvent: aSymbol action: aValuable]!

when: anEventSymbol send: aSelector to: anObject
	"Register an event handler such that when the receiver triggers the event
	anEventSymbol, the unary selector, aSelector, is sent to anObject."

	self when: anEventSymbol
		perform: (EventMessageSend receiver: anObject selector: aSelector)!

when: anEventSymbol send: aSelector to: anObject with: anArgument
	"Register an event handler such that when the receiver triggers the event
	anEventSymbol, the keyword selector, aSelector, is sent to anObject with the
	single argument, anArgument."

	self when: anEventSymbol
		perform: (EventMessageSend 
				receiver: anObject
				selector: aSelector
				argument: anArgument)!

when: anEventSymbol send: aSelector to: anObject withArguments: anArray
	"Register an event handler such that when the receiver triggers the event
	anEventSymbol, the multi-keyword selector aSelector is sent to anObject with arguments 
	from anArray."

	self when: anEventSymbol
		perform: (EventMessageSend 
				receiver: anObject
				selector: aSelector
				arguments: anArray)!

when: anEventSymbol sendTo: anObject
	"Register an event handler such that when the receiver triggers the event
	anEventSymbol, it is sent as a unary selector to anObject."

	self 
		when: anEventSymbol
		send: anEventSymbol
		to: anObject!

whileMutableDo: aNiladicBlock 
	"Evaluate and answer the result of the <niladicBlock> argument while the receiver is 
	temporarily made mutable."

	^self isImmutable 
		ifTrue: 
			[self isImmutable: false.
			aNiladicBlock ensure: [self isImmutable: true]]
		ifFalse: [aNiladicBlock value]!

yourAddress
	"Answer the address of the body of the receiver. The primitive does not fail.

	The answer (an Integer) can be passed to external procedures as a pointer
	or stored into another byte object representing a structure as a member pointer,
	and call also be mutated (using #becomeA(n):) into a byte object such as ExternalAddress.

	Although the primitive does not fail for non-byte objects, it is potentially unsafe
	to access these indirectly, almost certainly an error to pass their address to
	external procedures, and very likely to cause unexpected behaviour if used to modify
	the contents of the object.

	When taking the address of an object, you are entering the unprotected realms 
	of pointer manipulation, and need to be aware of object lifetime issues. In particular
	be careful not to pass the address of a temporary object to a third party which is
	intending to keep hold of that address, as the address will become invalid if the
	object is garbage collected. In addition, if the third party writes off the front or end
	of the object, it may corrupt the Smalltalk image, and cause unexpected behavior.
	It is often better to use an external buffer, outside the Smalltalk object space, and
	manage its lifetime yourself."

	<primitive: 103>
	^self primitiveFailed!

yourself
	"Answer the receiver (useful for returning the receiver from a cascaded message)."

	^self
! !

ProtoObject comment:
'ProtoObject is an abstract class that can be used as a basis for creating a variety of "stub" subclasses.  It supplies the minimum protocol that might be useful for any such stub in order that inspection and debugging may successfully take place.'!
!ProtoObject methodsFor!

~~ comparand
	"Answer whether the <Object>, comparand,  is NOT identical to the receiver.
	Implementation Note: This is faster than the obvious '^(self == anObject) not'
	because of Compiler optimisation of #==."

	^(self == comparand) == false!

== comparand
	"Answer whether the <Object>, comparand, is the same, identical, 
	object as the receiver. 
	
	The primitive should NOT fail.
	
	N.B. This implementation cannot be overridden, and is never, in fact, received 
	(unless #perform'd), because #== is inlined by the Compiler."

	<primitive: 110>
	^self primitiveFailed!

allReferences
	"Answer an Array containing all objects which reference the receiver.
	The primitive should not fail."

	<primitive: 153>
	^self primitiveFailed!

basicClass
	"Answer the class of the receiver. The primitive should not fail."

	<primitive: 111>
	^self primitiveFailed!

basicPrintOn: aStream
	"Append a short developer's description of the receiver to aStream. 
	Should not be overridden by subclasses."

	| name |
	name := self basicClass name.
	aStream 
		nextPutAll: (name first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: name!

basicPrintString
	"Answer a short developer's String description of the receiver. 
	Should not be overridden by subclasses"

	| aStream |
	aStream := String writeStream: 16.
	self basicPrintOn: aStream.
	^aStream contents!

basicSize
	"Private - Sames as #size, but should not be overridden by subclasses (except by subclasses
	whose instances have an immediate representation - e.g. SmallInteger).

	The primitive should not fail. It must be overridden for immediate objects."

	<primitive: 62>
	^self primitiveFailed!

become: anObject
	"Swap the instance pointers of the receiver and the argument, anObject. All variables 
	in the entire system that pointed to the receiver will now point to the argument, and 
	vice versa.

	Primitive failure reasons:
		0	-	receiver or argument an object with an immediate representation (e.g. 
				a SmallInteger), or either is a 'permanent' objects (nil, true, false, etc).

	This method should be used with extreme care, as it has side effects for others referring
	to the receiver and anObject. In particular never attempt to pass nil, true, false, etc,
	as the argument, as this will almost certainly cause system failure.

	N.B. Though Dolphin is faithful to the original Smalltalk-80 specification for 
	this method, and provides a two way switch as described, this is not universally true 
	for all Smalltalks, so portable code should assume only a one way switch. To better
	guarantee portability you should use #swappingBecome: which, hopefully, will start
	to become prevalent on other platforms."

	<primitive: 72>
	^self primitiveFailed!

doesNotUnderstand: failedMessage
	"Sent to the receiver by the VM when a message sent to the receiver was not implemented
	by the receiver or its superclasses (i.e. it has no appropriate behaviour).
	Signal a <MessageNotUnderstood> exception corresponding to the <failedMessage> argument,
	message."

	^MessageNotUnderstood receiver: self message: failedMessage
!

error: signalerText
	"Raise an <Error> exception reporting the error message contained in the
	<readableString> argument, signalerText."

	^Error signal: signalerText!

identityHash
	"Answer the <integer> identity hash value for the receiver. This is
	currently a 16-bit SmallInteger value, which may be negative.
	This value is assigned when the object is created, and never changes
	(i.e. it is temporally invariant). Because the range is limited
	to 16-bits, very large collections hashed by identity using this value
	alone are likely to be slow (consider including the identityHash of
	the objects class e.g. 
		^((self class identityHash bitAnd: 16r3FFFFFFF) bitShift: 16) 
			bitOr: self identityHash
		or: <primitive: 147> which is similar.
	However, this would not be safe in general, because #become: and #becomeA:
	might change an object's class, because it is not associated with the
	identity, but the object itself.

	Although this implementation is temporally invariant while an object remains
	in memory, a binary filed object is re-incarnated with a different identity,
	and so identity hash collections must be rebuilt or rehashed on load (the 
	standard Collections do this already).

	This need not be reimplemented (except by immediate subclasses), because 
	it is not possible to override #==, indeed reimplementation is jolly unwise.
	
	N.B. The primitive does not fail, but will raise a benign invalid memory access 
	exception if called for immediate subclasses such as SmallInteger."
	
	<primitive: 75>
	^self primitiveFailed!

instVarAt: index
	"Private - Answer a variable in the receiver. The numbering of the variables begins with 
	named instance variables, and corresponds to the order in which the instance variables
	were defined. Indexed variables have indices following those of the named instance
	variables.

	Primitive failure reasons:
		0	-	aSmallInteger is not a SmallInteger.
		1	-	aSmallInteger is out of bounds (not in the range 1..recieiver's size)."

	<primitive: 73>
	^index isInteger 
		ifTrue: 
			[(BoundsError new)
				receiver: self;
				signalWith: index]
		ifFalse: [Error nonIntegerIndex: index]!

isKindOf: candidateClass
	"Answer whether the receiver is an instance of the argument, candidateClass,
	or one of its subclasses.
	The primitive never fails, so the Smalltalk back up code is present for illustrative
	purposes only. The primitive is very fast, so there is no particular reason to
	implement isXXXXXX methods instead, BUT in any case is-kind-of tests are not
	good practice. Tests should be made to see if an object provides a particular
	protocol (if necessary) rather than testing for a particular class."

	<primitive: 57>
	^self class includesBehavior: candidateClass!

oneWayBecome: anObject
	"Make all references to the receiver be references to the argument (i.e. anObject replaces
	all uses of the receiver, and the receiver's identity and contents are lost). This is the 
	only form of #become: available in some Smalltalk systems. Can follow a two
	way #become: for even more mind boggling fun (to maintain one objects identity, but
	anothers value).

	Primitive failure reasons:
		0	-	receiver or argument an object with an immediate representation (e.g. 
				a SmallInteger), or either is a 'permanent' objects (nil, true, false, etc).

	This method should be used with care, but is some what less dangerous than #become:,
	as it does not affect existing users of anObject. Currently the implementation is not
	as efficient as #become:."

	<primitive: 154>
	^self primitiveFailed!

primitiveFailed
	"Generate an error to the effect that a primitive has failed, including the failure code
	specified by the primitive."

	| proc |
	proc := Processor activeProcess.
	^self error: 'Primitive ', proc topFrame sender method printString, ' failed (', 
					proc primitiveFailureCode displayString, ')'! !

AttributeDescriptor comment:
'AttributeDescriptor is an abstract class of meta-objects that be used to describe the shape of other objects. It has a subclass, Aspect, instances of which describe how to access object''s published ''aspects'' (e.g. instance variables) through getter and setter methods, and a subclass, ExternalField, instances of which describe the fields of C style structures. Note that these objects are all descriptors, and need to be combined with a subject object in order to become "closed".'!
!AttributeDescriptor class methodsFor!

inaccessible
	"Private - Answer an instance of the receiver which describes an attribute
	which is neither writable nor readable."

	^self new beInaccessible
!

new
	"Answer an instance of the receiver which describes an attribute
	which can be both read from and written to."

	^super new initialize!

readOnly
	"Answer an instance of the receiver which describes an attribute
	which cannot be set."

	^self new beReadOnly!

uncompiled
	"Answer an instance of the receiver which describes a field which will not be compiled."

	^self new beUncompiled!

writeOnly
	"Answer an instance of the receiver which describes an attribute
	which cannot be read, only written."

	^self new beWriteOnly! !

!AttributeDescriptor methodsFor!

beCompiled
	"Set the receiver's flags to specify it as an compiled attribute
	(i.e. one with compiled accessors to retrieve/set its value).
	Answer the receiver."

	flags := flags maskSet: ##(AccessorMask | MutatorMask)!

beImmutable
	flags := flags maskClear: MutableMask!

beInaccessible
	"Set the receiver's flag to specify that it is inaccessible.
	ie. being neither readable nor writeable.
	Answer the receiver."

	flags := flags maskClear: ##(WriteableMask | ReadableMask)!

beMutable
	"Set this aspect to be mutable, i.e. it can be modified in-place."

	flags := flags maskSet: MutableMask!

beOverride
	"Set the receiver's flags to specify it as an override attribute
	(i.e. one for which compiled accessors will be generated, even if defined
	in the superclass). The default behaviour for an attribute is not to compile
	accessors where they are already defined in the superclass."

	flags := flags maskSet: OverrideMask!

beReadOnly
	"Set the receiver's flags to specify it as a 'read only' attribute.
	Answer the receiver."

	flags := (flags maskClear: WriteableMask) maskSet: ReadableMask!

beUncompiled
	"Set the receiver's flags to specify it as an uncompiled attribute
	(i.e. one without any compiled accessors which will use the #doesNotUnderstand:
	mechanism to retrieve/set its value when sent accessor messages).
	Answer the receiver."

	flags := flags maskClear: ##(AccessorMask | MutatorMask)!

beWriteOnly
	"Set the receiver's flags to specify it as a 'write-only' attribute.
	Answer the receiver."

	flags := (flags maskClear: ReadableMask) maskSet: WriteableMask!

canGenerateAccessor
	"Private - Answer whether it is possible to generate a read accessor method
	for the receiver."

	^self canGenerateAccessors
		and: [self isReadable
			and: [flags anyMask: AccessorMask]]
!

canGenerateAccessors
	"Private - Answer whether accessors can be compiled for the receiver."

	^true!

canGenerateMutator
	"Private - Answer whether it is possible to generate a write accessor method
	for the receiver."

	^self canGenerateAccessors 
		and: [self isWriteable
			and: [flags anyMask: MutatorMask]]!

defaultFlags
	^##(WriteableMask | ReadableMask | AccessorMask | MutatorMask | NullableMask)!

initialize
	"Private - Initialize the receiver.
	By default attributes support read/write and compiled accessors."

	flags := self defaultFlags!

isInaccessible
	"Answer whether the receiver is an inaccessible attribute."

	^(flags anyMask: WriteableMask | ReadableMask) not!

isMutable
	"Answer true if this aspect is mutable, i.e. it can be modified in-place.
	If not then a copy of the aspect will be made when its value is taken"

	^flags allMask: MutableMask
	!

isNullable
	"Answer true if this aspect is nullable, i.e. it can be set to nil.
	In order to be nullable, an aspect must be writeable."

	^flags allMask: ##(WriteableMask | NullableMask)!

isNullable: aBoolean 
	flags := flags mask: NullableMask set: aBoolean!

isOverride
	"Answer whether the receiver is an attribute which overrides
	one in the superclass (i.e. accessors will be generated for it regardless
	of whether they already exist in the superclass)."

	^flags anyMask: OverrideMask!

isReadable
	"Answer whether the receiver is a readable attribute."

	^flags anyMask: ReadableMask!

isWriteable
	"Answer whether the receiver is a writeable attribute."

	^flags anyMask: WriteableMask!

readFrom: anObject
	"Private - Answer the attribute of anObject represented by the receiver."

	^self subclassResponsibility!

writeInto: subjectObject value: valueObject
	"Private - Set the attribute of subjectObject described by the receiver 
	to valueObject."

	^self subclassResponsibility! !

Behavior comment:
'Class Behavior is the abstract class which defines the minimum state necessary for objects that have instances, providing the basic information about those instances to the Compiler and the VM.

Instance Variables:

	superclass	<Behavior> object of the instance''''s superclass
	subclasses	<Array> of Behavior''s which are the subclasses of the instance
	methodDictionary	<MethodDictionary> mapping selector Symbols to CompiledMethods
	instanceSpec	<integer> containg flags which describe the "shape" of the instance (e.g. oops vs bytes)

Behavior defines a number of bit masks which are used to describe objects. These flags are stored in the pool dictionary,
_BehaviorMasks, for ease of sharing with the ClassBuilder and other tools::
	_BasicSpecMask 		<integer> bit mask to extract the basic inst. spec (excludes extra spec word).
	_BytesSubMask 		<integer> bit mask to extract inst. spec. bits relating exclusively to byte objects
	_FundamentalShapeMask 	<integer> bit mask to extract the fundamental shape of instances from instance spec.
	_IndirectMask 		<integer> bit mask to extract indirection (i.e. memory pointer) flag from inst. spec. flags
				The indirection bit marks classes whose instances are indirect references to 
				other objects/memory - e.g. ExternalAddresses. Such objects are automatically
				dereferenced when passed to appropriate VM primitives.
	_MournerMask 		<integer> bit mask to extract mourner flag from inst. spec. flags
				The mourner bit marks classes who actively grieve for the loss of their constituents. 
				Weak instances of such classes will be notified by the Undertaker process when 
				they suffer bereavements during a GC. This notification is ''''off'''' by default because the
				receipt of such a notifications will delay the death of its receiver, which may result in
				significantly extended life for hierarchies of incestuously referencing weak objects.
	_NullTermMask 		<integer> bit mask to extract null terminated flag from inst. spec. (byte objects only)
				The null term. bit can be used to mark byte classes as having an implicit null terminator
				(e.g. to represent C-style strings).
	_PointersMask 		<integer> bit mask to extract the pointers/bytes flag from inst. spec.
				The pointer bit marks classes whose instances contain pointers (as opposed to bytes).
	_ShapeMask 		<integer> bit mask to extract the shape flags from inst. spec.
	_SizeMask 			<Integer> bit mask to extract the number of named inst. vars. from inst. spec.
				The size bits specify the number of named instance variables (0..255) in instances
				of the receiver.
	_VariableMask		<integer> bit mask to extract the fixed/variable size flag from inst. spec.
				The variable bit marks classes whose instances include indexable (unnamed) 
				instance variables.

Behavior implements the ANSI protocols <Object>, <classDescription>, <instantiator>, and <Object class>.'!
!Behavior class methodsFor!

icon
	"Answers an Icon that can be used to represent this class."

	^Class icon! !

!Behavior methodsFor!

addSelector: aSymbol withMethod: aCompiledMethod 
	"Private - Add the message selector, aSymbol, with the corresponding
	CompiledMethod, to the receiver's method dictionary.
	Implementation Note: Clears down the VM method cache in case a previous 
	version of the method is cached, or it overrides a superclass method."

	| selector |
	selector := aSymbol asSymbol.
	aCompiledMethod
		methodClass: self;
		selector: selector.
	methodDictionary at: selector put: aCompiledMethod.

	"One might expect to be able to trigger a #methodAdded: event here,
	 to be symetrical with Behavior>>removeSelector:. However, the 
	 method source is not yet set up (logged) so in fact we have to do
	 this later."
	self flushMethodCache!

addSubclass: aClass
	"Private - Include the argument, aClass, as a subclass of the receiver."

	| subs |
	aClass superclass == self
		ifFalse: [ ^self error: 'I am not ', aClass printString, 's superclass' ].
	subs := self subclasses.
	(subs identityIndexOf: aClass) == 0 ifTrue: [
		"Maintain the array in sorted order as saves sorting on access"
		subclasses := (subs asSortedCollection add: aClass; yourself) asArray]!

addToSuper
	"Private - Add the receiver to its superclasses' subclass collection.
	Root classes will have a superclass of nil - we do not put such
	classes into a subclass collection."

	superclass notNil
		ifTrue: [superclass addSubclass: self]!

allClassVarNames
	"Answer a <Set> of the <readableString> names of the receiver's and the 
	receiver's superclasses' class variables."

	| answer |
	answer := Set new.
	self withAllSuperclassesDo: [:c | answer addAll: c classVarNames].
	^answer!

allInstances
	"Answer an <Array> of all direct instances of the receiver."

	MemoryManager current collectGarbage.
	^self primAllInstances!

allInstVarNames
	"Answer an <Array> of the <readableString> names of the receiver's instance variables, 
	those specified in the receiver and in all of its superclasses. The array ordering is the order 
	in which the variables are stored and accessed by the interpreter."

	^(self superclass ifNil: [#()] ifNotNil: [:parent | parent allInstVarNames]) , self instVarNames!

allSelectors
	"Answer a <Set> of <Symbol>s, being all the message selectors to which the receiver 
	is able to respond (this includes messages understood by superclasses)."

	| answer |
	answer := IdentitySet new.
	self withAllSuperclassesDo: [:each | answer addAll: each selectors].
	^answer!

allSharedPoolNames
	"Answer a Set of the names of the pools (dictionaries) that are specified in the receiver 
	in the receiver and each of its superclasses"

	| answer |
	answer := Set new.
	self withAllSuperclassesDo: [ :c | answer addAll: c sharedPoolNames ].
	^answer!

allSharedPools
	"Answer a Set of the pools (dictionaries) that are specified in the receiver in the receiver 
	and each of its superclasses"

	| answer |
	answer := Set new.
	self withAllSuperclassesDo: [:c | answer addAll: c sharedPools].
	^answer!

allSubclasses
	"Answer a <collection> of the receiver's subclasses in 
	breadth-first order, with the immediate subclasses first. 
	Breadth-first traversal is slightly less efficient, but results 
	in a more useful ordering (the standard does not specify the order). 

	N.B. The original Smalltalk-80 definition specified that this 
	method should answer a Set, and the draft ANSI standard specifies
	only <collection>. The defacto standard (e.g. See IBM 
	Common Base) is now an OrderedCollection, and we follow suit as this
	maintains the ordering, which is often useful."

	| answer |
	answer := OrderedCollection new.
	self allSubclassesBreadthFirstDo: [:each | answer add: each].
	^answer!

allSubclassesBreadthFirstDo: aMonadicValuable 
	"Evaluate the monadic valuable argument with each of the receiver's 
	subclasses in breadth-first order. The standard #allSubclassesDo: method 
	performs a depth-first traversal (which is quicker)."

	self subclasses ifNotNil: 
			[:classes | 
			classes do: [:each | aMonadicValuable value: each].
			classes do: [:each | each allSubclassesBreadthFirstDo: aMonadicValuable]]!

allSubclassesDo: aMonadicValuable
	"Private - Evaluate the monadic valuable argument for each of the 
	receiver's subclasses using a pre-order depth first traversal."

	self allSubclassesPreOrderDo: aMonadicValuable!

allSubclassesEndOrderDo: aMonadicValuable
	"Private - Evaluate the monadic valuable argument for each 
	of the receiver's subclasses, visiting the receiver AFTER its
	subclasses (i.e. an end-order traversal)."

	subclasses isNil 
		ifFalse: 
			[subclasses do: 
					[:each | 
					each allSubclassesEndOrderDo: aMonadicValuable.
					aMonadicValuable value: each]]!

allSubclassesPreOrderDo: aMonadicValuable
	"Private - Evaluate the monadic valuable argument for each 
	of the receiver's subclasses, visiting the receiver before its
	subclasses (i.e. a pre-order traversal)."

	subclasses isNil 
		ifFalse: 
			[subclasses do: 
					[:each | 
					aMonadicValuable value: each.
					each allSubclassesPreOrderDo: aMonadicValuable]]!

allSubinstances
	"Answer an <Array> containing all instances of the receiver and its subclasses."

	MemoryManager current collectGarbage.
	^self primAllSubinstances!

allSuperclasses
	"Answer a <collection> of the receiver's superclass and the receiver's ancestor's 
	superclasses. The first element is the receiver's immediate superclass, followed by its
	superclass, and so on; the last element is always Object.

	Note that we actually return a <sequencedReadableCollection> but that sequenceability
	cannot be relied upon in portable code because the ANSI standard specifies
	only <collection>."

	| answer |
	answer := OrderedCollection new.
	self allSuperclassesDo: [:each | answer addLast: each].
	^answer!

allSuperclassesDo: aMonadicValuable
	"Private - Evaluate the monadic valuable argument for each of the receiver's 
	superclasses."

	| class current |
	class := self.
	
	[current := class superclass.
	class := current.
	current isNil] 
			whileFalse: [aMonadicValuable value: current]!

basicCompile: aString 
	"Private - Compile the argument, code, and enter the result in the receiver's method dictionary. 
	If a compile error occurs a CompilerNotification is signalled. Answers a new method or nil.
	Note that this method doesn't generate a #methodAdded: trigger, and doesn't do anything
	with categories."

	^self basicCompile: aString flags: self defaultCompilationFlags!

basicCompile: aString flags: anInteger 
	| error result stubMethod |
	result := error := stubMethod := nil.
	
	[result := self compilerClass 
				compile: aString
				in: self
				flags: anInteger] 
			on: self compilerClass errorClass
			do: 
				[:n | 
				error := n.
				stubMethod := (MethodCompileFailed with: n) signal: n description.
				n pass].
	error notNil ifTrue: [result := stubMethod].
	result notNil 
		ifTrue: 
			[| selector method oldMethod |
			method := result method.
			selector := method selector asSymbol.
			oldMethod := methodDictionary at: selector ifAbsent: [].
			result oldMethod: oldMethod.
			oldMethod ifNotNil: [method isPrivate: oldMethod isPrivate].
			self addSelector: selector withMethod: method.
			method
				storeSourceString: aString asString;
				isImmutable: true].
	^result!

basicNew
	"Private - As #new, but must not be overridden by subclasses."

	<primitive: 70>
	self isVariable ifTrue: [^self basicNew: 0].
	^self primitiveFailed!

basicNew: aSmallInteger
	"Private - As #new:, but must not be overridden by subclasses."

	<primitive: 71>
	self isFixed ifTrue: [^Error notIndexable: self].
	^self primitiveFailed!

bindingFor: aString 
	"Answer a variable binding for the named variable in the scope of this class. 
	If there is no such variable, then answer nil."

	^superclass bindingFor: aString!

canUnderstand: aSymbol
	"Answer whether the receiver can respond to the message whose selector is the argument, aSymbol.
	The selector can be in the method dictionary of the receiver's class or any of its superclasses."

	^(self lookupMethod: aSymbol) notNil!

changedMethods
	"Private - Answer a <collection> of all the changed methods in the receiver."

	^self methodDictionary select: [:method | method hasChanged]!

classVarNames
	"Answer a <Set> of <String>s, being the class variable names of the receiver."

	^self subclassResponsibility!

compile: code
	"Compile the argument, code, and enter the result in the receiver's method dictionary. 
	If a compile error occurs a CompilerNotification is signalled. Answers a new method or nil.
	If the method is successfully compiled, then trigger a #methodAdded: event."

	| method result |
	result := self basicCompile: code.
	result notNil 
		ifTrue: 
			[method := result method.
			self storeCategoriesOfMethod: method.
			result fireSystemUpdateEvent].
	^method!

compileAll
	"Compile all the methods for which the receiver has selectors. We install stub methods for all
	compilation failures"

	[self selectors do: [:each | self recompile: each]] 
		on: MethodCompileFailed
		do: 
			[:ex | 
			"If we get a method compilation error then we install 
			a stub method so we'll be able to see the source."

			ex
				beep;
				resumeWithStubMethod]!

compileAllSubclasses
	"Compile all the methods in the receiver's subclasses' method dictionaries."

	self allSubclassesDo: [:each | each compileAll]!

compiledMethodAt: aSymbol
	"Answer the compiled method associated with the selector argument, aSymbol, in 
	the receiver's local method dictionary. Report an error if the selector cannot be found."

	^methodDictionary at: aSymbol!

compiledMethodAt: aSymbol ifAbsent: aNiladicValuable
	"Answer the compiled method associated with the selector argument, aSymbol, in 
	the receiver's local method dictionary, or the result of evaluating the niladic
	valuable argument if the selector can not be found."

	^methodDictionary at: aSymbol ifAbsent: aNiladicValuable!

compilerClass
	"Answer the default Compiler class to use for compiling methods, etc, of the
	receiver."

	^Compiler!

decompile: aSymbol
	"Find the compiled code associated with the selector argument, aSymbol, and decompile it. 
	Answer the resulting source code as a <readableString>. If the selector is not in the method 
	dictionary, report an error."

	| method source |
	method := self compiledMethodAt: aSymbol.
	source := method getSource.
	source isNil 
		ifTrue: 
			[^self error: 'decompiler can''t decompile methods without source (yet)']
		ifFalse: [^source]!

defaultCompilationFlags
	^self compilerClass defaultFlags!

definitionOf: aSymbol
	"Answer the compiled method associated with the selector argument, aSymbol, in 
	the receiver's method dictionary, or that of its superclass, etc. Report an error if the 
	selector is not understood by the receiver."

	self withAllSuperclassesDo: 
			[:each | 
			(each includesSelector: aSymbol) ifTrue: [^each compiledMethodAt: aSymbol]].
	^self errorNotFound: aSymbol!

environment
	"Answer the receiver's name space."

	^Smalltalk!

extraInstanceSpec
	"Private - Answer the user class instance specification of the receiver (a 16-Bit Integer)."

	<primitive: 151>
	^(self instanceSpec bitShift: -15) bitAnd: 16rFFFF!

extraInstanceSpec: aSmallInteger
	"Private - Set the user class instance specification of the receiver to the <SmallInteger> argument."

	self instanceSpec: ((aSmallInteger lowWord bitShift: 15) 
				maskSet: (self instanceSpec bitAnd: _BasicSpecMask))!

flushMethodCache
	"Private - Ask the VM to completely flush its method cache. The primitive should not fail."

	<primitive: 89>
	^self primitiveFailed!

fullBindingFor: aString 
	"Answer a variable binding for the named variable in the scope of this class, and
	failing that in the receiver's environment. If there is no such variable, then answer nil."

	(aString identityIncludes: $.) 
		ifTrue: 
			[| parts env |
			parts := aString subStrings: $..
			"Fully qualified name always starts in Smalltalk"
			env := Smalltalk.
			parts 
				from: 1
				to: parts size - 1
				do: 
					[:each | 
					env := env at: each ifAbsent: [].
					env isNil ifTrue: [^nil]].
			^env bindingFor: parts last].
	^(self bindingFor: aString) ifNil: [self environment bindingFor: aString]!

hasCompilationFailures
	"Answer whether any of the methods in the receiver or any of its subclasses have previously failed to compile."

	^(self methodDictionary anySatisfy: [:each | each isCompilationFailure])
		or: [self subclasses anySatisfy: [:each | each hasCompilationFailures]]!

hasImmediateInstances
	"Answer whether the receiver's instances are immutable objects encoded entirely 
	in an Oop (e.g. SmallIntegers).
	Implementation Note: Included for compatibility with VisualWorks."

	^false!

hasMethods
	"Answer whether the receiver has any methods in its local method dictionary."

	^methodDictionary size ~= 0
!

includesBehavior: aBehavior
	"Answer whether the receiver includes the behavior, aBehavior
	(i.e. is aBehavior the receiver or a superclass of the receiver)."

	^self == aBehavior or: [superclass includesBehavior: aBehavior]
!

includesSelector: aSymbol
	"Answer whether the local method dictionary contains a method whose
	selector is the argument, aSymbol."

	^methodDictionary includesKey: aSymbol!

inheritsFrom: aClass
	"Answer whether the receiver is a subclass of aClass.
	This is the same as #includesBehavior:, but starts from the
	superclass of the receiver."

	^superclass includesBehavior: aClass!

instanceCount
	"Answer the number of instances of the receiver that currently exist.
	This is a rather expensive method, but it is an original Smalltalk-80 method
	and thus remains. Don't use it in application code though!!"

	^self allInstances size!

instanceSpec
	"Private - Answer the instance specification (shape of instances) of the receiver.
	This may also contain various 'user' specific bits which do not necessarily relate
	to the immediate shape of the class' instances."

	^instanceSpec!

instanceSpec: anInteger
	"Private - Set the instance specification of the receiver to anInteger. 
	WARNING: Improper use of this method may cause the VM to behave unexpectedly"

	instanceSpec := anInteger!

instSize
	"Answer the number of fixed fields (named instance variables) in instances of the receiver."

	^self instanceSpec bitAnd: _SizeMask!

instVarNames
	"Answer a <sequencedReadableCollection> of the receiver's instance variable 
	names."

	^#()!

isBits
	"Answer whether the variables of instances of the receiver contain bits (i.e. not object pointers)."

	^self isPointers not!

isBytes
	"Answer whether the variables of instances of the receiver are stored as bytes (8-bit integers)."

	^self isPointers not!

isFixed
	"Answer whether instances of the receiver are NOT indexable (i.e. they contain only a 
	specified set of named instance variables)."

	^self isVariable not!

isIndirection
	"Answer true if the instances of the receiver are actually indirect references to other 
	objects. In the case of Byte objects this means that they contain the address of an external 
	or internal object. Objects of indirection classes, such as ExternalAddress, behave differently 
	when passed to certain system primitives (e.g. byte replacement primitives)."

	^self instanceSpec anyMask: _IndirectMask!

isIndirection: aBoolean
	"Set/reset the receivers status as an indirect reference (i.e. an
	address/pointer) to some other object (internal or external)."

	self setShapeFlags: _IndirectMask to: aBoolean!

isMeta
	"Answer whether the receiver is a <Metaclass>."

	^false!

isMetaclass
	"Answer whether the receiver is a <Metaclass>."

	^self isMeta!

isMourner
	"Answer whether instances of the receiver like to grieve 
	for the loss of their constituents."

	^self instanceSpec anyMask: _MournerMask!

isNullTerminated
	"Answer true if the instances of the receiver are Null Terminated (that is they include 
	an extra byte with the value zero at their end, which is not included in the reported size). 
	Only meaningful for variable byte classes (e.g. String)."

	^self instanceSpec allMask: _NullTermMask!

isNullTerminated: aBoolean
	"Set the receivers status as a class of Null Terminated objects
	(i.e. its instances have an additional byte, not included in the reported size, 
	which is always zero). Only meaningful for variable byte classes"

	self setSpecialBehavior: _NullTermMask to: aBoolean!

isPointers
	"Answer whether the variables of instances of the receiver contain object pointers (as
	opposed to uninterpreted bytes)."

	^self instanceSpec anyMask: _PointersMask!

isVariable
	"Answer whether instances of the receiver can have indexed instance variables."

	^self instanceSpec anyMask: _VariableMask!

isWords
	"Answer whether the variables of instances of the receiver are stored as words."

	"OBSOLETE"

	^false!

kindOfSubclass
	"Private - Answer a string describing the kind of subclassing method used to create the receiver 
	(part of its definition)."

	^self isVariable 
		ifTrue: [self isBytes ifTrue: ['variableByteSubclass:'] ifFalse: ['variableSubclass:']]
		ifFalse: ['subclass:']!

lookupMethod: aSymbol
	"Answer the method of the receiver, or inherited by the receiver, corresponding
	to the selector, aSymbol."

	<primitive: 148>
	^self primitiveFailed!

makeMourner
	"Private - Set the receivers status as an mourner. This only affects the
	weak instances of such classes, which will receive a #elementsExpired:
	message from the Undertaker process soon after they have suffered the loss
	of an object they are weakly referencing. This gives the mourner the opportunity
	to put its house in order. By default this behaviour is disabled, as its use
	can extend the life of an object (a weak object which would otherwise be
	garbage collected has to be rescued in order that it can perform its
	mourning process, as the mourning process may be important for releasing
	external resources, etc."

	self setShapeFlags: _MournerMask to: true!

methodDictionary
	"Private - Answer the receiver's <MethodDictionary>."

	^methodDictionary!

methodDictionary: aMethodDictionary
	"Private - Store the <MethodDictionary> argument as the method dictionary of the receiver.
	Incorrect use of this method (e.g. with an argument which is not a <MethodDictionary>)
	can cause unexpected behavior of the VM)."

	methodDictionary := aMethodDictionary!

name
	"Answer a <readableString> that is the name of the receiver."

	^self subclassResponsibility!

new
	"Answer an instance of the receiver with no indexed variables. Send the receiver the 
	message {new: 0} if the receiver is indexable.

	This is the fundamental method by which new class instances are created. It is inherited
	by class objects (Metaclass instance instances) through the route:
		MyClass class -> MyClass class superclass -> ... 
			-> Object class -> Class -> ClassDescription -> Behavior

	Primitive failure reasons:
		0 -	The receiver is an indexable class, and requires a size."

	<primitive: 70>
	self isVariable ifTrue: [^self new: 0].
	^self primitiveFailed!

new: aSmallInteger
	"Answer an instance of the receiver with the specified number of indexed instance variables.
	Report an error if the receiver is not indexable, or the argument is invalid.

	This is the fundamental method by which new instances of indexable classes are are created.
	It is inherited by class objects (Metaclass instance instances) through the route:
		MyClass class -> MyClass class superclass -> ... 
			-> Object class -> Class -> ClassDescription -> Behavior

	Primitive failure reasons:
		0 - the argument is not a <SmallInteger>.
		1 - the argument is negative
		2 - the receiver's instances are not indexable."

	<primitive: 71>
	self isFixed ifTrue: [^Error notIndexable: self].
	^self primitiveFailed!

new: numSmallInteger max: maxSmallInteger
	"Private - Answer an instance of the receiver with numSmallInteger indexed instance variables, 
	which can grow to accommodate maxSmallInteger. Report an error if the receiver is not indexable
	or the arguments are invalid.

	Primitive failure reasons:
		0 -	numSmallInteger is not a <SmallInteger> or is negative.
		1 -	maxSmallInteger is not <SmallInteger> or is negative.
		2 -	the receiver's instances are not indexable."

	<primitive: 90>
	self isFixed ifTrue: [^Error notIndexable: self].
	^self primitiveFailed!

newFixed: aSmallInteger
	"Answer an instance of the receiver of size aSmallInteger bytes (this method is 
	only valid for byte objects). The object is allocated from the fixed memory heap
	and will not move in memory (objects allocated with primitive 71 are free to 
	move to assist garbage collection, whereas those allocated with primitive 76 
	are in a traditional fixed heap)."

	<primitive: 76>
	^self primitiveFailed!

primAllInstances
	"Private - Answer an <Array> of all the instances of the receiver which currently exist in the system. 
	This may include currently unreferenced objects, unless a full garbage collection has just been 
	performed - for this reason use #allInstances in preference if speed is not an issue.
	The primitive should not fail."

	<primitive: 77>
	^self primitiveFailed!

primAllSubinstances
	"Private - Answer an <Array> of all the instances of the receiver and its subclasses
	which currently exist in the system. This may include currently unreferenced objects, 
	unless a full garbage collection has just been performed - for this reason use 
	#allSubinstances in preference if speed is not an issue.
	The primitive should not fail."

	<primitive: 58>
	^self primitiveFailed!

recompile: aSelector 
	"Compile the method associated with the message selector, selector.
	The method is not logged to the change log but the source is re-used
	from the original"

	| oldMethod method stubMethod result |
	oldMethod := self compiledMethodAt: aSelector.
	oldMethod isNil ifTrue: [^self].
	
	[result := self compilerClass 
				compile: oldMethod getSource
				in: self
				flags: self defaultCompilationFlags] 
			on: self compilerClass errorClass
			do: 
				[:ex | 
				stubMethod := (MethodCompileFailed with: ex) signal: ex description.
				ex pass].

	"Was a stub method installed?"
	stubMethod notNil ifTrue: [result := stubMethod].
	^(result notNil and: [(method := result method) notNil]) 
		ifTrue: 
			["Add the selector and copy across the old source descriptor and privacy, as we haven't don't want to change either"
			method selector: aSelector.
			self addSelector: aSelector withMethod: method.
			method
				sourceDescriptor: oldMethod sourceDescriptor;
				isPrivate: oldMethod isPrivate;
				isImmutable: true.
			"The method has not actually changed, so it is inappropriate to issue a #methodUpdated: event"
			method]!

recompileAll
	"Recompile this class and all its subclasses. The methods are not logged to the change log,
	but the sources are re-used from the originals. N.B. In order to recompile all methods in
	the system it is necessary to avoid the process being interrupted or the system may crash.
	To achieve this evaluate an expression such as:

	[Object recompileAll] forkAt: Processor userInterruptPriority "

	self withAllSubclassesDo: 
			[:each | 
			each class compileAll.
			each compileAll]!

removeFromSuper
	"Private - Remove the receiver from its superclasses' subclass collection.
	Root classes will have a superclass of nil - we do not put such
	classes into any subclass collection."

	superclass notNil ifTrue: [superclass removeSubclass: self]!

removeFromSystem
	"Private - Remove the receiver from the system (completely remove a class)."

	ClassBuilder removeClass: self!

removeSelector: selector
	"Remove the argument, selector (which is a Symbol representing a message selector), 
	from the receiver's message dictionary."

	^self removeSelector: selector ifAbsent: [self errorNotFound: selector]!

removeSelector: aSymbol ifAbsent: aNiladicValuable
	"Remove the the method with the selector specified by the argument, aSymbol, 
	from the receiver's message dictionary. Answer the <CompiledMethod> that
	as removed, or, if the selector is not in the method dictionary, the result of evaluating 
	the niladic valuable argument.
	Implementation Note: Flush the VM method cache in case the method is cached. 
	The #methodRemoved: event is triggered to inform interested parties."

	| method |
	method := methodDictionary removeKey: aSymbol
				ifAbsent: [^aNiladicValuable value].
	self flushMethodCache.
	self environment trigger: #methodRemoved: with: method.
	^method!

removeSelectors: aCollection
	"Remove each of the <Symbol> selectors in the <collection> argument from the 
	receiver's message dictionary. If any of the selectors are not present, they are 
	simply ignored. Answer a <collection> of the <CompiledMethod>s which were actually
	removed."

	| methods env |

	"Take advantage of the fact that Sets ignores requests to add nil"
	methods := aCollection asSet 
				collect: [:each | methodDictionary removeKey: each ifAbsent: []].
	self flushMethodCache.
	env := self environment.
	methods do: [:each | env trigger: #methodRemoved: with: each].
	^methods!

removeSubclass: aClass
	"Private - Remove the argument, aClass, from the subclasses of the receiver.
	WARNING: This method does not completely remove a class from the system."

	subclasses isNil ifFalse: [
		(subclasses := subclasses copyWithout: aClass) isEmpty
			ifTrue: [ subclasses := nil ]]!

requiresInstallation
	"Answer whether the receiver requires 'installing' into its environment."

	^false!

scopeHas: name ifTrue: operation
	"Answer whether name is in scope in the receiver.
	Compiler support. Not yet implemented."

	^Error notYetImplemented
!

selectMethods: aMonadicValuable
	"Private - Answer a <Set> of the <CompiledMethod>s of the receiver 
	for which the monadic valuable, discriminator, evaluates to true."

	| answer |
	answer := IdentitySet new: 25.
	self methodDictionary 
		do: [:each | (aMonadicValuable value: each) ifTrue: [answer add: each]].
	^answer!

selectors
	"Answer a <Set> of <Symbol>s, being all the selectors of all the methods
	in the receiver."

	^methodDictionary keys
!

setShapeFlags: anIntegerMask to: aBoolean
	"Private - Set/Reset the receivers shape/structure flags (as defined by anIntegerMask)
	according to the argument aBoolean."

	instanceSpec := instanceSpec mask: anIntegerMask set: aBoolean!

setSpecialBehavior: anIntegerMask to: aBoolean
	"Private - Set/Reset the receivers special behavior (as defined by anIntegerMask)
	according to the argument aBoolean. Only meaningful for variable byte classes"

	self isBytes 
		ifTrue: [self setShapeFlags: anIntegerMask to: aBoolean]
		ifFalse: [self error: 'Must be byte class']!

setSuperclass: aClass
	"Private - Set the superclass of the receiver to aClass, maintaining the hierarchy
	as necessary. This is the correct way to set the superclass of a Behavior"

	self superclass == aClass ifTrue: [^self].
	self
		removeFromSuper;
		superclass: aClass;
		addToSuper!

shallowCopy
	"Answer a copy of the receiver which shares the receiver's instance 
	variables. 
	Implementation Note: Behaviors are unique and cannot be copied."

	^self!

sharedPools
	"Answer a <Set> of <Symbol>s, being the names of the pools (dictionaries) that are
	specified locally in the receiver."

	^self subclassResponsibility!

sharedStaticPools
	"Private - Answer an <Array> of all the shared pools for the receiver (including those
	inherited from superclasses). Used by compiler, but may be removed in future."

	^self subclassResponsibility
!

sourceCodeAt: aSymbol
	"Answer a <String> that is the source code of the receiver's method with selector, aSymbol.
	Report an error if the selector cannot be found."

	^(self compiledMethodAt: aSymbol) getSource!

storeCategoriesOfMethod: aCompiledMethod
	"Do nothing - method categories are not supported at this level"

	!

subclasses
	"Answer a <collection> containing the receiver's immediate subclasses.

	Note that the answer is actually a <sequencedReadableCollection>, but that
	sequenceability should not be relied upon in portable code because the draft ANSI
	standard specifies only <collection>."

	^subclasses ifNil: [Array new]!

subclasses: aCollection
	"Set the receivers subclasses to the specified collection.
	The subclasses are maintained as a sorted array, but leaf classes store nil to save space."

	subclasses := (aCollection notNil and: [aCollection notEmpty]) 
				ifTrue: [aCollection asSortedCollection asArray]!

subclassInstVarNames
	"Answer a <Set> of the instance variable names specified in the receiver's subclasses"

	| answer |
	answer := Set new.
	self allSubclassesDo: [:each | answer addAll: each instVarNames].
	^answer!

superclass
	"Answer a <classDescription> which is the receiver's immediate 
	superclass (or <nil> if none)."

	^superclass!

superclass: aClass
	"Set the superclass of the receiver to be the argument, aClass"

	(aClass isNil or: [aClass isKindOf: Behavior]) 
		ifFalse: [self error: 'superclass must be a kind of Behavior'].
	superclass := aClass!

understoodSelectors
	"Answer a <Set> of all message selectors understood by the receiver, not including those understood because
	they are implemented in superclasses. This should however include those that are not in the method dictionary
	but will be understood as a result of #doesNotUnderstand: processing, if that is possible."

	^self selectors!

whichClassDefinesClassVar: aString
	"Answer which <Class> in the receiver's inheritance chain, including the receiver,
	defines the named class variable."

	^self whichClassSatisfies: [:each | each classVarNames includes: aString]!

whichClassIncludesSelector: selector
	"Answer the first class on the receiver's superclass chain (including the receiver) where 
	the argument, selector, can be founds as a message selector. Answer nil if no class includes
	the selector."

	^(self includesSelector: selector) 
		ifTrue: [self]
		ifFalse: 
			[superclass notNil 
				ifTrue: [superclass whichClassIncludesSelector: selector]]!

whichClassSatisfies: aBlock
	"Private - Recurse up through the receiver's inheritance chain, starting with the receiver,
	until the <monadicValuable> argument answers true when evaluated against the receiver."

	(aBlock value: self) ifTrue: [^self].
	^superclass isNil ifFalse: [superclass whichClassSatisfies: aBlock]!

whichMethodsAccess: aString
	"Answer a <Set> of methods from the receiver's local method dictionary whose methods access 
	the instance variable of the receiver named by the argument."

	^self whichMethodsAccess: aString
		at: (self allInstVarNames indexOf: aString)!

whichMethodsAccess: aString at: anInteger
	"Private - Answer a <Set> of selectors from the receiver's local method dictionary whose 
	methods access the instance variable with the specified index."

	^self 
		selectMethods: [:method | method accessesInstVar: aString at: anInteger]!

whichMethodsAssign: aString
	"Answer a <collection> of <CompiledMethod>s that write to the instance variable
	named by the <readableString> argument."

	^self whichMethodsAssign: aString
		at: (self allInstVarNames indexOf: aString)!

whichMethodsAssign: aString at: anInteger
	^self 
		selectMethods: [:method | method writesInstVar: aString at: anInteger]!

whichMethodsContainSource: aString
	"Answer a <Set> of methods from the receiver's local method dictionary whose methods contain
	the specified source string."

	^self selectMethods: [:method | method containsSource: aString]!

whichMethodsRead: aString
	"Answer a <collection> of <CompiledMethod>s that read the instance variable
	named by the <readableString> argument."

	^self whichMethodsRead: aString at: (self allInstVarNames indexOf: aString)!

whichMethodsRead: aString at: anInteger
	^self 
		selectMethods: [:method | method readsInstVar: aString at: anInteger]!

whichMethodsReferTo: anObject 
	"Answer a <Set> of methods in the receiver whose literal frames include the argument, anObject."

	| index |
	anObject isSymbol 
		ifTrue: 
			[index := VMLibrary default indexOfSpecialSelector: anObject ifAbsent: [0].
			index ~= 0 ifTrue: [^self selectMethods: [:each | (each refersToLiteral: anObject) or: [each sendsSpecialSelector: index]]]]
		ifFalse: 
			[((anObject isKindOf: VariableBinding) and: [anObject isImmutable]) 
				ifTrue: 
					[| value |
					value := anObject value.
					^self selectMethods: [:each | (each refersToLiteral: value) or: [each refersToLiteral: anObject]]]].
	^self selectMethods: [:each | each refersToLiteral: anObject]!

whichSelectorsAccess: aString
	"Answer a <collection> of <Symbol>s, being the selectors of methods of the receiver
	that access the instance variable named by the <readableString> argument.
	N.B. Primarily present for Blue Book compatibility, and used by the Refactoring Browser.."

	^(self whichMethodsAccess: aString) collect: [:each | each selector]!

whichSelectorsAssign: aString
	"Answer a <collection> of <Symbol>s, being the selectors of methods of the receiver
	that assign to the instance variable named by the <readableString> argument."

	^(self whichMethodsAssign: aString) collect: [:each | each selector]!

whichSelectorsRead: aString
	"Answer a <collection> of <Symbol>s, being the selectors of methods of the receiver
	that read the instance variable named by the <readableString> argument."

	^(self whichMethodsRead: aString) collect: [:each | each selector]!

whichSelectorsReferTo: anObject
	"Answer a Set of selectors whose methods access the argument, anObject.
	This is really only included for Blue Book compatibility."

	^(self whichMethodsReferTo: anObject) collect: [:each | each selector]!

whichSelectorsWrite: aString
	"Answer a <Set> of selectors whose methods write to the instance variable
	named by the <readableString> argument."

	| index |
	index := self allInstVarNames indexOf: aString.
	^(self selectMethods: [:each | each writesInstVar: aString at: index]) 
		collect: [:each | each selector]!

withAllSubclasses
	"Answer an <OrderedCollection> containing the receiver, and all of the receiver''s 
	subclasses in breadth-first order, with the immediate subclasses first."

	^(self allSubclasses)
		addFirst: self;
		yourself!

withAllSubclassesDo: aMonadicValuable
	"Evaluate the monadic valuable argument for the receiver and each 
	of its subclasses using a depth-first traversal."

	aMonadicValuable value: self.
	self allSubclassesDo: aMonadicValuable!

withAllSuperclasses
	"Answer an <OrderedCollection> containing the receiver, and all of the receiver''s 
	superclasses in breadth-first order."

	^(self allSuperclasses)
		addFirst: self;
		yourself!

withAllSuperclassesDo: aMonadicValuable
	"Evaluate the monadic valuable argument for the receiver and each 
	of its superclasses in reverse order of hierarchy."

	aMonadicValuable value: self.
	self allSuperclassesDo: aMonadicValuable! !

BlockClosure comment:
'BlockClosure is the class of objects that represent "blocks" in Smalltalk. Blocks encapsulate a sequence of statements to be performed at a later time. Blocks may capture (or "close over") runtime state, such as the values of temporary variables, from the enclosing lexical scope at the point where they are created. When evaluated a block executes as if in the lexical scope in which it was defined, except that blocks may have arguments that are bound at the time of evaluation. Blocks may be passed as arguments with messages to other objects and evaluated by those objects when appropriate, and thus form a very powerful and generic "pluggability" mechanism that is a core feature which provides much of the power of Smalltalk. 

BlockClosures in Dolphin 6.0 and later are substantially revised from in earlier versions of Dolphin. Dolphin 6.0 now supports true lexical closures, and implements all advanced optimizations. Block arguments now always reside on the stack, and their lifetime is limited to the duration of the activation of the block. This means that blocks can be used recursively, and even shared between processes (e.g. a sort block can now safely be shared). It also means that blocks no longer retain a reference to their last arguments, and so previous problems with blocks in (for example) MVP views keeping object trees from being garbage collected are no longer an issue. Furthermore block activation is now exactly the same as method activation, and can be no more expensive.

Blocks are now categorized into five basic types:
	1) Inlined
	2) Clean
	3) Copying
	4) Hybrid
	5) Full

Inlined blocks are those literal blocks which the compiler "optimizes" away by replacing them with an equivalent set of instructions that execute directly in the context of the enclosing  scope. BlockClosure instances are never created for inlined blocks. The most common type of inlined blocks are the operands of the #ifTrue:ifFalse: family of messages, but the literal block arguments and/or receivers of a number of other messages are also inlined. The complete set of inlined messages at the time of writing is as follows:
	#and:
	#or:
	#ifTrue:[ifFalse:]
	#ifFalse:[ifTrue:]
	#ifNil:[ifNotNil:]
	#ifNotNil:[#ifNil:]
	#repeat
	#timesRepeat:
	#to:[by:]do:
	#whileTrue[:]
	#whileFalse[:]

The receiver/operands to these, if literal blocks, are usually inlined. Though in the case of #timesRepeat: and #to:by:do:, the compiler may not inline the messages if the receiver/operands are not literals meeting certain criteria. Where this is the case the compiler emits a warning that it is not able to optimize the message. One can also suppress all the inlined forms by first assigning the literal block to a temporary, and then referencing that as the operand. For example:
	i := 0.
	b := [i <= 10].
	b whileTrue: [i := i + 1]. i

The categorization of the other types of blocks is dependent upon the references they make to variables. In order to understand the differences between the other types of blocks, it is necessary to first understand the different types of variables that the Dolphin compiler now distinguishes.

	1) Static variables.
	2) Arguments.
	3) Stack Temps.
	4) Copied Values. 
	5) Shared (aka Environment) Temps

Static variables, are variables such as globals, class variables, and pool variables. A block''s references to these has no bearing on its status.

Arguments are temporary variables held on the stack which are read-only [Note that earlier versions of Dolphin permitted assignment to block arguments, but this will now cause a compilation error]. The arguments to a method or block are pushed on the stack, and remain there, in the same locations, until the method or block returns.

Stack temporaries are local temporary variables that are referenced only in the declaring scope. These are allocated as stack slots, and their lifetime is thus limited to the duration of the method or block activation.

Copied values are block temporaries whose value can be copied from an enclosing scope. They can be regarded as additional implicit arguments to a block that are bound at block creation time by copying them into the indexed slots of the block object itself from the enclosing scope. On block activation any copied values are pushed back on the stack, and subsequently the block''s code accesses them using the same instructions as for its arguments and other stack temporaries. In order for a variable to be copyable it must not be assigned to after the point at which the block is created, as otherwise scopes which may reference that variable would not see the same value. This implies that all copied values are, like arguments, read-only temporaries from the point of view of the block which has copied them. The receiver is a special case of copied value, because it is not legal in Smalltalk to assign to ''self''.

Shared temporaries are those which are referenced from scopes other than that in which they are declared, and which are either written to by an enclosed scope, or written to by the declaring scope after a block has been created which references the variable. Any variable which is shared in this way must be allocated a slot which is visible to, and shared between, all the referencing scopes.

Clean blocks are limited to those which do not perform any non-local returns (^-returns), and which refer only to their arguments, locally declared temporaries which are not shared with any nested blocks, or static variables such as globals and pool variables. Blocks which refer to any other variables in the enclosing scope, including the receiver (i.e. ''self''), cannot be treated as clean. Essentially a clean block does not "close over" any state at the time it is created, and hence they can be created at compile time rather than at run time. Clean blocks are the most efficient form  because they do not require any objects to be created when they are referenced or activated, making their activation cost essentially the same as a normal method. The default sort block used by SortedCollection is an example of a clean block.
	
The empty block, [], is a special case of clean block which is folded to a single instance by the compiler to save space. 

Copying blocks are those which may also reference variables, including the receiver, in the lexically enclosing scope, where those variables are not written to after the block has been created. Any block which references the receiver, or arguments of an enclosing scope is automatically at least a copying block. Copying blocks require that the BlockClosure object be created at run-time, since the correct values to copy are not available until that point. If a copying block references the receiver current at the time it was created, or any instance variables, then the blocks receiver instance variable will be set to that receiver (i.e. the receiver will also have been copied). If the receiver is not needed, then it is not copied in order to avoid creating an unecessary reference. Here are a couple of simple examples of the use of copying blocks: 

	blocks := 1 to: 10 collect: [:i | [i]].	"Note that the captured value of ''i'' in each block will be different"
	blocks inject: 0 into: [:sum :each | sum + each value].

	| factorial | 
	factorial := [:x | x < 2 ifTrue: [1] ifFalse: [(factorial value: x - 1) * x].
	factorial value: 6.

Copying blocks are still a relatively efficient form in that they do not require the allocation of additional heap objects when either their enclosing method or when they themselves are activated. However in order to copy the values from enclosing scopes when the block is created, the compiler must emit additional instructions to push the copied values onto the stack, and there is then the very small overhead of the VM copying the values into the block. At activation time the overhead is the very small overhead of the VM pushing the copied values back onto the stack. The overhead of copying ''self'' is negligible as it does not need to be pushed onto the stack on block creation or activation.

We have mentioned that whether or not a block contains a ^-return has a bearing on its category. Since ^ returns from the lexically enclosing scope, not the block or its caller, its implementation requires a mechanism to locate the return destination, and which allows us to detect the error of attempting to ^-return from a method activation which has itself already returned. For example:

	block := [^1].
	block value.

If we evaluate this as a single expression, it is valid, but if we evaluate it as two separate expressions then the second will give an error since the first (in which the block was captured) has already returned.

In order to implement non-local returns we make use of the ''outer'' pointers in the BlockClosures themselves, and in <Contexts>. A Context in Dolphin is not the same object as a Context in the Smalltalk-80 sense, in that is not the reified representation of a method or block activation, but rather it is little more than a vector to hold shared temps, and to chain out to Contexts associated with enclosing scopes should that be needed. Any block with a ^-return must have a non-nil ''outer'' which refers to a Context object. That Context object, if it is not the Context for a method, may itself refer to a further outer Context through its own ''outer'' instance variable. 

A hybrid type of block between copying and full block status is the otherwise clean or copying block which either incorporates a ^-return, or which references shared temporaries from outer scopes, but which does not itself define any shared temporaries. Such a block will still have an outer pointer (and so may force its enclosing method to require a Context be allocated when it is activated), but will not itself have a Context. In this case the ''outer'' pointer of the block will point to the Context of the nearest enclosing scope with shared temporaries, or the method Context if none of the enclosing scopes has any shared temporaries. Note that any method containing a ^-return in any of the non-inlined blocks that it contains will always have a Context allocated when it is activated, regardless of whether it declares and shared temporaries.

Full blocks are those that require a context to hold temporaries they define that are shared with nested blocks. Full blocks are the most inefficient form because they require the creation of a heap object when the block itself is created, and (more importantly), a Context object every time the block is activated. Obviously this can be a significant cost in a loop. However, if one is careful in ones coding, and in particular if one uses small methods that define temporaries at the innermost possible scope, then full blocks are very rarely needed. For example, consider these statistics from a sample image:

	Total Methods: 		34390 
	Methods needing Context:	665	(either define shared temps, or blocks with ^-returns)
	Methods with Shared Temps: 	340 	(implying (665-340) = 325 contexts required just for ^-returns)
	Static Blocks:		1812	(clean blocks, created at compile time and stored in methods'' literal frames)
	Dynamic Blocks:		5001	(created at runtime, and may need Context: copying, hybrid, or full)
	Copying Blocks:		3895	(pure copying, no ^-return or access to any shared temps, so no Context needed for block or method)
	Hybrid Blocks: 		1075	(reference outer context for ^-return, or outer shared temps, requires that method have a Context)
	Full Blocks:			31		(as above, plus defines own shared temps, both method and block require a Context when activated)

As you can see Full Blocks are very rare indeed. Hybrid blocks are much more common, and these cause their own outer scope(s) to require a context due to a ^-return, or by assigning to an outer temporary.

Instance Variables:
	outer		<Context>|nil
	method		<CompiledCode>
	initialIP		<SmallInteger>
	info			<SmallInteger>
	receiver		<Object> that was ''self'' when the block was created, or nil if the block does not reference ''self'' or any instance variables.

The indexable fields of a BlockClosure are used to hold any copied values.

Info word usage:

	Bits:	Use:
	0		SmallInteger flag (not visible in Smalltalk)
	1..7		Unused
	8..15	argument count
	16..23	stack temp count
	24..31	env temp count (Context size, 0 if no Context needed).
'!
!BlockClosure class methodsFor!

attemptToRecompile: aBlockClosure 
	| oldMethod result newBlock newMethod receiver |
	oldMethod := aBlockClosure method.
	Notification signal: 'Recompilng block: ' , aBlockClosure printString.
	oldMethod class ~~ CompiledExpression 
		ifTrue: 
			[Notification signal: 'Unable to recompile block because it was created by a method '.
			^aBlockClosure].
	receiver := aBlockClosure receiver.
	result := Compiler 
				compileForEvaluation: oldMethod getSource
				in: (receiver isNil ifTrue: [UndefinedObject] ifFalse: [oldMethod methodClass])
				evaluationPools: oldMethod evaluationPools
				logged: false
				flags: 0.
	newMethod := result method.
	newMethod isNil 
		ifTrue: 
			[Notification signal: 'Error recompiling block'.
			^aBlockClosure].
	newBlock := [newMethod value: receiver withArguments: #()] on: Error
				do: 
					[:ex | 
					Notification signal: 'Error creating block: ', ex printString.
					nil].
	^newBlock ifNil: [aBlockClosure]!

attemptToUpgradeBlock: aBlockClosure data: data 
	| recompiledBlock newMethod |
	recompiledBlock := self attemptToRecompile: aBlockClosure.
	recompiledBlock isClean ifFalse: [^recompiledBlock].

	"Danger Will Robinson: If the new block is clean, then it will be referenced from the literal frame of its home method.
	When the STBInFiler #become:s the array with the answer to swap the refs, the array of old vars will end up
	stored in the literal frame as useless junk that we don't want, therefore we pre-emptively replace the ref from
	the literal frame with the array so that it is all correct when swapped [my brain exploded before I understood that, Ed]"
	newMethod := recompiledBlock method.
	newMethod whileMutableDo: 
			[1 to: newMethod literalCount
				do: [:i | (newMethod at: i) == recompiledBlock ifTrue: [newMethod at: i put: data]]].
	^recompiledBlock!

convertBlockToClosure: anArray 
	"Private - Convert an old-format block to a new format closure. The bytecodes are rewritten
	to be compatible with the BlockClosure VM, but the result will be very inefficient since it
	is assumed that all temps need to be shared, and arguments have to be copied into shared
	temps. Ideally all old blocks (such as those in View resources) should be recompiled at the
	earliest opportunity, certainly before application deployment as this upgrade will not be
	available at runtime."

	| answer method rewriter newMethod originalIP methodContext receiver |
	answer := self basicNew.
	method := anArray at: 4.
	rewriter := self rewriterClass new.
	newMethod := rewriter rewriteMethod: method.
	"We must swap old and new methods so that any other ref. to the old method is also updated"
	method become: newMethod.
	originalIP := anArray at: 3.
	methodContext := anArray at: 1.
	receiver := methodContext receiver.
	answer
		outer: (self convertMethodContext: methodContext);
		method: method;
		receiver: receiver.
	answer info: 0.
	answer
		argumentCount: (anArray at: 2);
		initialIP: (rewriter blockMap at: originalIP).
	^answer!

convertMethodContext: aMethodContext 
	"Private - Convert an old-format MethodContext to a new format Context."

	| context size |
	size := aMethodContext size.
	context := Context basicNew: size.
	context outer: 0.
	1 to: size do: [:i | context at: i put: (aMethodContext at: i)].
	^context!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

rewriterClass
	^BytecodeRewriter!

stbConvertFrom: anSTBClassFormat 
	"Convert from earlier binary filed versions."

	"Note: It is assumed that all blocks will be upgraded before application deployment, so this
	conversion is deliberately placed in the 'development' category, and will not be available
	at runtime."

	| ver upgrading |
	ver := anSTBClassFormat version.
	upgrading := anSTBClassFormat isUpgrading.
	^
	[:data | 
	| newBlock |
	ver < 1 
		ifTrue: [newBlock := self convertBlockToClosure: data]
		ifFalse: 
			[ver < 2 
				ifTrue: [self error: 'Unable to convert interim block format']
				ifFalse: 
					[Sound bell.
					newBlock := self basicNew: data size - self instSize.
					1 to: data size do: [:i | newBlock instVarAt: i put: (data at: i)]]].
	upgrading ifTrue: [newBlock := self attemptToUpgradeBlock: newBlock data: data].
	newBlock]!

stbVersion
	"Answer the current binary filer version number for instances of the receiver.
		0 	- Original Smalltalk-80 style blocks (pre Dolphin 6.0)
		1..2	- Interim formats used during development of proper closures.
		3	- Dolphin 6.0 closures.
	"

	^3! !

!BlockClosure methodsFor!

= aBlockClosure 
	^aBlockClosure class == self class and: 
			[method = aBlockClosure method and: 
					[outer = aBlockClosure outer and: 
							[self size = aBlockClosure size 
								and: [(1 to: self size) allSatisfy: [:i | (self at: i) = (aBlockClosure at: i)]]]]]!

argumentCount
	"Answer the <integer> number of arguments expected by the receiver."

	^(info bitShift: -7) bitAnd: 16rFF!

argumentCount: anInteger 
	info := (info bitAnd: ##((16rFF << 7) bitInvert)) 
				bitOr: ((anInteger bitAnd: 16rFF) bitShift: 7)!

at: index
	"Answer the receiver's indexed instance variable at the argument index.
	As basicAt:, but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size)."

	<primitive: 49>
	^self errorAt: index!

at: index put: value
	"Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value.
	As basicAt:put: but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size) 
		2	- the argument, value, is not of a class which can be stored in the receiver
			(e.g. its a non-SmallInteger and the receiver is a ByteArray)."

	<primitive: 50>
	^self errorAt: index put: value!

atPriority: anInteger
	"Evaluate the receiver at the specified priority. On completion or curtailment the active process' 
	priority is returned to its previous value."

	| activePriority proc |
	proc := Processor activeProcess.
	activePriority := proc priority: anInteger.
	^self ensure: [proc priority: activePriority]!

critical
	"Private - Evaluate the receiver as a Critical Section with asynchronous process switching disabled.
	When asynchronous process switching is disabled, process pre-emption cannot occur because
	all interrupts and asynchronous Semaphore signals remain pending. If synchronous process
	synchronisation primitives are attempted (e.g. sending #signal or #wait to a Semaphore)
	then asynchronous process switching is automatically re-enabled, and any pending interrupts/
	asynchronous signals will get delivered."

	"Use this VERY sparingly, and for very short durations, as this is a very broadbrush (though
	very high performance) approach to process synchronisation. It is an easy and high performance
	way to protect, for example, a shared data structure from being accessed by other processes
	while it is being modified, but it will prevent any other processes from executing unrelated
	code too. Also, it may not be available in a future multi-threaded VM.
	Synchronisation of access to shared data structures is best done by including a 
	mutual exclusion Semaphore or Mutex with the data structure (i.e. in the Object which manages the 
	data structure), and then using the #critical: method as here. 
	
	See the SharedQueue class for an example of the use of mutual exlusion semaphores, or SharedSet for
	and example of the use of a Mutex to guarantee mutually exclusive access."

	"Implementation Note: We must use an #ensure: block to guarantee re-enabling of aysnc events, 
	because the receiver may perform a ^-return (should an exception occur then they will be 
	re-enabled anyway). This does mean it may be quicker to send #enableAsyncEvents: directly
	in some circumstances."

	| oldState |
	oldState := Processor enableAsyncEvents: false.
	[self value] ensure: [Processor enableAsyncEvents: oldState]!

deferredValue
	"Answer a <niladicValuable> that begins evaluating the receiver asynchronously,
	and which when evaluated will synchronously supply the result."

	^self deferredValueAt: Processor activePriority!

deferredValueAt: priority
	"Answer a <niladicValuable> that begins evaluating the receiver asynchronously
	at the specified <Process> priority, and which when evaluated will synchronously 
	supply the result."

	^DeferredValue evaluate: self at: priority!

ensure: terminationBlock
	"Evaluate the receiver, and regardless of the means by which it exits, 
	be it by normal or non-local (^) return, or by raising an exception, evaluate
	the <niladicBlock> argument, terminationBlock.
	Answers the result of evaluating the receiver, unless <terminationBlock>
	contains a non-local return, in which case the result of <terminationBlock> will be
	answered to its home contexts sender, e.g.:

		[^1. 2] ensure2: [Sound bell]		answers 1, but also woofs
		[^1. 2] ensure2: [Sound bell. 3]	woofs and answers 3.
		[1. 2] ensure2: [Sound bell. ^3]	ditto
		[1. 2] ensure2: [Sound bell. 3]	woofs and answers 2

	See also #ifCurtailed:"

	| answer |
	answer := self ifCurtailed: terminationBlock.
	terminationBlock value.
	^answer!

envTempCount
	"Private - Answer the <integer> number of environment (shared) temps required
	by the receiver. If this value is greater than zero, then this is a full block, and requires
	that a heap-based environment be allocated each time it is activated. The heap-based
	environment will hold all the shared temps declared in the block, and also a link
	to any outer environments from which shared outer temps are accessed."

	^(info bitShift: -23) bitAnd: 16rFF!

envTempCount: anInteger
	info := (info bitAnd: ##((16rFF << 23) bitInvert)) 
				bitOr: ((anInteger bitAnd: 16rFF) bitShift: 23)!

fork
	"Create and schedule a new Process at the same priority as the current active process.
	The new Process will be placed on the end of the queue of processes of the same priority in 
	the Ready state (i.e. the current active process continues to run). Answer the new Process.
	The new Process will run when it gets its turn (i.e. when there are no higher
	priority processes in the Ready state, and the receiver is at the front of the
	queue of Ready Processes at its priority)."

	^self newProcess resume!

forkAt: anInteger
	"Evaluate the receiver in a new process at the priority specified by the argument, anInteger. 
	If the new process is of a higher priority than the current active process then it will
	start running immediately. If of a lower priority, then it must wait until there are no
	higher priority processes Ready to run. If of the same priority, then it does not preempt
	the current active process. N.B. Do not rely on the latter behaviour, as it may change in
	a future release. Answer the new process."

	^(self newProcess) 
		priority: anInteger;
		resume!

frameClass
	"Private - Answer the class of <StackFrame> to represent activations of the
	receiver."

	^BlockFrame!

home
	"Private - Answer the home context of the context. In the case of a BlockClosure,
	this is the <Context> active for the method which created the block. 
	N.B. The home context (which is always a Context) may have already returned, and 
	only exists in order to provide a 'home'. A BlockClosure uses its home purely execute
	non-local returns. If the block does not contain any non-local returns, then the home
	may be nil."

	^outer isNil ifFalse: [outer home]!

ifCurtailed: terminationBlock
	"Evaluate the receiver, and should it exit via a non-local (^) return, or by raising an 
	exception, evaluate the <niladicBlock>, terminationBlock.
	Answers the result of evaluating the receiver, unless curtailed and the terminationBlock 
	contains a non-local return of its own, in which case the result of that block 
	will be answered to its home context's sender, e.g.:

		[^1] ifCurtailed: [Sound beep]			answers 1, but also woofs
		[^1] ifCurtailed: [Sound beep. ^2]		woofs and answers 2.
		[1] ifCurtailed: [Sound beep. ^2]		answers 1

	Be warned: The system may become unstable if this method is modified. The receiver is
	not the original receiver of the message after #valueOnUnwind: has been sent, but is
	valid inside the unwind block. In addition, #valueOnUnwind: leaves additional objects
	on the stack.

	See also #ensure:"

	^self valueOnUnwind: [:retValue :retFrame |
		terminationBlock value.
		Processor returnValue: retValue toFrame: retFrame]!

info
	^info!

info: aSmallInteger 
	info := aSmallInteger!

initialIP
	"Answer the initial instruction pointer index into the home method, 
	used when the block receives a #value* message"

	^initialIP!

initialIP: anInteger 
	"Private - Set the initial instruction pointer index into the receiver's
	compiled byte codes (used when the block receives a #value* message)."

	initialIP := anInteger!

isClean
	"Answer whether the receiver is a clean block, i.e. a block that refers only to its arguments, and which does
	not contain any ^-returns. This makes it a shareable object."

	^receiver isNil and: [outer isNil and: [self size = 0 and: [self envTempCount = 0]]]!

localCount
	"Private - Answer the <integer> number of stack temps (including any arguments and
	copied values) used by the receiver. This number of stack slots is used every 
	time the receiver is activated, in addition to the fixed slots for the stack frame."

	^self argumentCount + self stackTempCount + self size!

method
	"Private - Answer the home method for which the context represents execution state"

	^method!

method: aCompiledMethod
	"Private - Set the home method for which the context represents execution state."

	method := aCompiledMethod!

millisecondsToRepeat: anInteger
	"Answer the time taken to execute the receiver anInteger times"

	^Time millisecondsToRun: [ anInteger timesRepeat: [self value]]!

newProcess
	"Answer a new, suspended, <Process> which will evaluate the receiver, and terminate 
	when and if the code in the receiver returns. The default 'name' given to the process 
	is the home method - this is useful for debugging because it allows one to locate the source 
	(e.g. Process name getSource) to determine what the process is doing."

	^(Process forContext: [ 
			self on: ProcessTermination do: [:e | e return].
			"^-return catches attempt to drop off bottom of process stack (which would cause a GPF)"
			^Processor activeProcess shutdown]
		priority: Processor activePriority)
		name: self method;
		yourself
!

newProcessWithArguments: anArray
	"Answer a new process which will evaluate the receiver with arguments
	from anArray, then terminate"

	^[self valueWithArguments: anArray] newProcess!

on: selector do: action
	"Try to evaluate the receiver, and should an exception occur which is matched
	by the <exceptionSelector>, selector, normally a class object which is a subclass 
	of Exception), evaluate the <monadicBlock>, action, passing it the exception 
	instance as its argument."

	^(ExceptionHandler on: selector do: action) try: self!

on: selector1 do: action1 on: selector2 do: action2
	"Try to evaluate the receiver, and should an exception occur which is matched
	by any of the <exceptionSelector>s, selector1..selector2, then evaluate the 
	corresponding <monadicBlock>, actionN, passing it the exception instance as 
	its argument."

	^self onDo: ((ExceptionHandlerSet new)
				on: selector1 do: action1;
				on: selector2 do: action2)!

on: selector1 do: action1 on: selector2 do: action2 on: selector3 do: action3
	"Try to evaluate the receiver, and should an exception occur which is matched
	by any of the <exceptionSelector>s, selector1..selector3, then evaluate the 
	corresponding <monadicBlock>, actionN, passing it the exception instance as 
	its argument."

	^self onDo: ((ExceptionHandlerSet new)
				on: selector1 do: action1;
				on: selector2 do: action2;
				on: selector3 do: action3)!

on: selector1 do: action1 on: selector2 do: action2 on: selector3 do: action3 on: selector4 do: action4
	"Try to evaluate the receiver, and should an exception occur which is matched
	by any of the <exceptionSelector>s, selector1..selector4, then evaluate the 
	corresponding <monadicBlock>, actionN, passing it the exception instance as 
	its argument."

	^self onDo: ((ExceptionHandlerSet new)
				on: selector1 do: action1;
				on: selector2 do: action2;
				on: selector3 do: action3;
				on: selector4 do: action4)!

on: selector1 do: action1 on: selector2 do: action2 on: selector3 do: action3 on: selector4 do: action4 on: selector5 do: action5
	"Try to evaluate the receiver, and should an exception occur which is matched
	by any of the <exceptionSelector>s, selector1..selector5, then evaluate the 
	corresponding <monadicBlock>, actionN, passing it the exception instance as 
	its argument."

	^self onDo: ((ExceptionHandlerSet new)
				on: selector1 do: action1;
				on: selector2 do: action2;
				on: selector3 do: action3;
				on: selector4 do: action4;
				on: selector5 do: action5)!

on: selector1 do: action1 on: selector2 do: action2 on: selector3 do: action3 on: selector4 do: action4 on: selector5 do: action5 on: selector6 do: action6
	"Try to evaluate the receiver, and should an exception occur which is matched
	by any of the <exceptionSelector>s, selector1..selector6, then evaluate the 
	corresponding <monadicBlock>, actionN, passing it the exception instance as 
	its argument."

	^self onDo: ((ExceptionHandlerSet new)
				on: selector1 do: action1;
				on: selector2 do: action2;
				on: selector3 do: action3;
				on: selector4 do: action4;
				on: selector5 do: action5;
				on: selector6 do: action6)!

onDo: exceptionHandler
	"Try to evaluate the receiver under the protection of the <ExceptionHandler>
	argument, exceptionHandler."

	^exceptionHandler try: self!

outer
	"Private - Answer the receiver's outer context, which may be nil."

	^outer!

outer: anObject
	"Private - Set the outer context of the receiver to anObject (a Context or nil).
	Answer the receiver."

	outer := anObject!

postToInputQueue
	"Queue the receiver as a deferred action to be evaluated by the main UI process
	when the Windows message queue is empty."

	SessionManager inputState queueDeferredAction: self!

postToMessageQueue
	"Queue the receiver as a deferred action to be evaluated by the main UI process in
	synchronisation with the Windows message queue (this posts a message to the queue so the
	action will be processed after any messages currently in the queue, but before any windows
	messages that may get posted there subsequently. Note the subtle difference from
	#postToInputQueue, which will defer an action until the message queue is empty - i.e. any
	deferred actions are treated as a lower priority than any Windows messages. Also it will
	work even when a modal message loop (such as the menu processing loop) is active."

	SessionManager inputState postAction: self!

printOn: aStream 
	"Append, to aStream, a <String> whose characters are a description of the receiver."

	| m |
	m := self method.
	(m notNil and: [m isExpression]) 
		ifTrue: 
			["We can print the source"
			aStream nextPutAll: m getSource]
		ifFalse: 
			["We can just show where the source is"
			aStream
				nextPutAll: '[] in ';
				print: m]!

receiver
	"Private - Answer the 'self' of the context. May be nil if the block does not reference 'self'
	or any instance variables."

	^receiver!

receiver: newReceiver
	"Private - Set the 'self' of the context"

	receiver := newReceiver!

repeat
	"Evaluate the receiver repeatedly, ending only if the block throws some exception or 
	explicity returns"

	"Note that this message is inlined by the Compiler for literal block receivers."

	
	[self value.
	true] whileTrue!

stackTempCount
	"Private - Answer the <integer> number of extra stack temps (in addition to the arguments)
	used by the receiver. This number of stack slots is reserved and nilled every time
	the receiver is activated."

	^(info bitShift: -15) bitAnd: 16rFF!

stackTempCount: anInteger 
	info := (info bitAnd: ##((16rFF << 15) bitInvert)) 
				bitOr: ((anInteger bitAnd: 16rFF) bitShift: 15)!

tempCount
	"Answer the total <integer> number of temps used by the receiver. 
	This includes all arguments, stack temps, copied values, and environment 
	(shared) temps used by the receiver."

	^self localCount + self envTempCount!

value
	"Answer the result of evaluating the receiver. Fail if the receiver is not 
	a niladic (zero argument) block.
	
	Primitive failure reasons:
		0 -	the receiver does not expect 0 arguments."

	"Implementation Note: This method is present to handle failures and as a 
	target for #performs, as invocations of #value are performed directly for 
	zero argument blocks."

	<primitive: 81>
	^self valueFailed: 0!

value: arg1 
	"Answer the result of evaluating the receiver. Fail if the receiver is not 
	a monadic (one argument) block.
	
	Primitive failure reasons:
		0 -	the receiver does not expect 1 argument."

	"Implementation Note: This method is present to handle failures and as a 
	target for #performs, as invocations of #value are performed directly for one 
	argument blocks."

	<primitive: 81>
	^self valueFailed: 1!

value: arg1 value: arg2 
	"Answer the result of evaluating the receiver. Fail if the receiver is not 
	a dyadic (two argument) block.

	Primitive failure reasons:
		0 -	the receiver does not expect 2 arguments."

	"Implementation Note: This method is present to handle failures and as a 
	target for #performs, as invocations of #value are performed directly for two
	argument blocks."

	<primitive: 81>
	^self valueFailed: 2!

value: arg1 value: arg2 value: arg3
	"Answer the result of evaluating the receiver. Fail if the receiver is not 
	a three argument block.

	Primitive failure reasons:
		0 -	the receiver does not expect 3 arguments."

	<primitive: 81>
	^self valueFailed: 3!

value: arg1 value: arg2 value: arg3 value: arg4
	"Answer the result of evaluating the receiver. Fail if the receiver is not 
	a four argument block.

	Primitive failure reasons:
		0 -	the receiver does not expect 4 arguments."

	<primitive: 81>
	^self valueFailed: 4!

valueFailed: anInteger
	"Private - A primitive value call failed, generate an appropriate error"

	^self argumentCount == anInteger
		ifTrue: [super primitiveFailed]
		ifFalse: [self error: 'Block expects ', self argumentCount printString, ' argument(s)']!

valueOnUnwind: aTwoArgBlock 
	"Private - Evaluate the receiver, and should it exit by a non-local return to its home method's sender
	(i.e. via a ^-return) then evaluate aTwoArgBlock, passing it the receiver's home context's sender (i.e.
	the return destination), and the return value. aTwoArgBlock must include an explicit return of its
	own, either via ProcessorScheduler>>returnValue:toFrame: to return the argument value to the 
	unwind destination, or via a further ^-return, which will override the result and return destinations.

	Primitive failure reasons:
		0 -	the receiver does not expect 0 arguments."

	"Implementation Note: Be warned: The primitive marks the caller's stack frame as having an unwind 
	block, by changing it's receiver to be a special magic block. The VM looks for this object when performing 
	^-returns from blocks, and, on detecting such, locates and evaluates the unwind block. The current 
	implementation of  this unwind mechanism leaves its unwind block argument on the stack before 
	evaluating the receiver in the normal way. 
	It is recommended that user code should not send this message directly, as it is possible that the system
	may become unstable if this is not done correctly. User code should use one of the two methods, #ensure: 
	and #ifCurtailed: to record unwind blocks that are performed regardless of whether the block evalutes 
	and returns normally or is curtailed by a non-local return or an exception, or only if curtailed (respectively)."

	<primitive: 79>
	^self primitiveFailed!

valueWithArguments: argumentArray 
	"Answer the result of evaluating the receiver with arguments from
	the <Array>, argumentArray. Fail if the argument is not an <Array>, 
	or if the receiver does not take the same number of arguments as are 
	present in the <Array>.

	Primitive failure reasons:
		0 -	the receiver does not expect the number of arguments in argumentArray.
		1 -	argumentArray is not an <Array>."

	"Implementation Note: A block can have a maximum of 256 arguments, however 
	this range is shared with other stack temporaries (including copied values), so the 
	effective limit is typically somewhat less. Be aware than many Smalltalks have lower 
	limits, and for complete portability it is recommended to use no more than two. 
	Stack overflow is also a possibility when the arguments are transferred to the stack."

	<primitive: 82>
	^self valueFailed: argumentArray size!

valueWithArgumentsAt: anAddress descriptor: anExternalFunctionDescriptor 
	"Private - Answer the result of evaluating the receiver with arguments
	instantiated from memory at anAddress using the the external argument 
	types from, anExternalFunctionDescriptor.

	Primitive Failure reasons:
		0	-	anExternalFunctionDescriptor is not a byte object.
		1	-	anAddress is not a valid address object (SmallInteger/byte indirection)
		2	-	the number of arguments whose types are specified by anExternalFunctionDescriptor
				does not match the number of arguments expected by the receiver."

	"Implementation Note: For performance and consistency (with outbound external calls) 
	reasons, we use a VM supplied primitive to instantiate and push the arguments and 
	perform the message, but there is no reason that this cannot be done in Smalltalk 
	if different argument conversions are required. The standard conversions are the 
	same as those performed for return types by the external call primitive (see
	the ExternalLibrary class)."

	<primitive: 117>
	^self valueFailed: anExternalFunctionDescriptor argumentCount!

whileFalse
	"Repeatedly evaluate the receiver until it evaluates to true. Answer nil."

	"Implementation Note: This message is inlined by the compiler if the
	receiver is a zero-argument literal block, i.e. it will inline the definition
	below, so this method is not actually recursive."

	^[self value] whileFalse!

whileFalse: iterationBlock 
	"Repeatedly evaluate the receiver until it evaluates to true, and
	on each iteration evaluate the <niladicValuable> argument, iterationBlock. 
	Answer nil."

	"Implementation Note: This message is inlined by the compiler if the
	receiver and argument are zero-argument literal block, i.e. it will inline 
	the definition below, so this method is not actually recursive."

	^[self value] whileFalse: [iterationBlock value]!

whileTrue
	"Repeatedly evaluate the receiver until it evaluates to false. Answer nil."

	"Implementation Note: This message is inlined by the compiler if the
	receiver is a zero-argument literal block, i.e. it will inline the definition
	below, so this method is not actually recursive."

	^[self value] whileTrue!

whileTrue: iterationBlock 
	"Repeatedly evaluate the receiver until it evaluates to false, and
	on each iteration evaluate the <niladicValuable> argument, iterationBlock. 
	Answer nil."

	"Implementation Note: This message is inlined by the compiler if the
	receiver and argument are zero-argument literal block, i.e. it will inline 
	the definition below, so this method is not actually recursive."

	^[self value] whileTrue: [iterationBlock value]! !

Boolean comment:
'Boolean is the class which provides the protocol for logical values. The actual logical values, true and false, are represented by Boolean''s subclasses True and False. Boolean itself is abstract.

In Smalltalk many control structures, such as conditional evaluations, are implemented by sending messages to Booleans, rather than by incorporating control flow mechanisms into the syntax of the language. The compiler does, however, inline certain commonly used messages such as #ifTrue:ifFalse: for reasons of performance. For this reason some methods of Boolean are not normally executed unless #perform:''d.

Booleans implement the ANSI protocols <Object> (by inheritance) and <boolean>.'!
!Boolean class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"It is not necessary to instantiate Booleans - use the literals 'true' 
	and 'false'."

	^self shouldNotImplement! !

!Boolean methodsFor!

& operand
	"Answer whether the receiver and the <boolean> argument, operand,
	are both true. Note that this is the evaluating conjunction, use #and: instead for 
	non-evaluating expressions.
	Implementation Note: The #ifTrue:ifFalse: is present in order to have the 
	VM check that the operand is actually a <Boolean>. The compiler will
	actually optimize a lot of this away and generate quite efficient code (try
	Ctrl+I to inspect the method and view the disassembly listing)."

	^(operand ifTrue: [true] ifFalse: [false]) and: [self]!

| operand
	"Answer whether either the receiver OR the <boolean> argument, operand,
	is true. Note that a logical expression using #| will evaluate both receiver
	and argument - use #or: instead for non-evaluating expressions, which
	are generally more efficient.
	Implementation Note: The #ifTrue:ifFalse: is present in order to have the 
	VM check that the operand is actually a <Boolean>. The compiler will
	actually optimize a lot of this away and generate quite efficient code (try
	Ctrl+I to inspect the method and view the disassembly listing)."

	^(operand ifTrue: [true] ifFalse: [false]) or: [self]!

and: operand 
	"Answer whether the receiver and the result of evaluating the <niladicValuable>,
	 operand, are both true. The argument is only evaluated if the receiver is true."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

asBoolean
	"Answer the receiver as a Boolean value (true OR false)."

	^self!

asDword
	"Answer the receiver in a form suitable for passing/returning as a
	32-bit integer value."

	^self subclassResponsibility
!

asParameter
	"Answer the value of the receiver in a form suitable for
	passing to an external function call."

	^self subclassResponsibility!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^self subclassResponsibility!

deepCopy
	"Answer the receiver as Booleans are immutable"

	^self!

eqv: operand
	"Answer whether the receiver and <boolean> argument, operand,
	are the same."

	^self == operand!

ifFalse: operand 
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is false, otherwise answer nil."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

ifFalse: falseOperand ifTrue: trueOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

ifTrue: operand
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is true, otherwise answer nil."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

ifTrue: trueOperand ifFalse: falseOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

isLiteral
	"Answer whether or not the receiver has a literal representation (probably its
	printString) which is directly recognised by the Compiler."

	^true!

not
	"Answer the logical inverse of the receiver"

	^self subclassResponsibility!

or: operand 
	"Answer whether either the receiver or the result of evaluating the
	<niladicValuable> argument, operand, is true. The argument is only
	evaluated if the receiver is false."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self subclassResponsibility!

shallowCopy
	"Answer the receiver as there are only two Booleans, the manifest constants
	true and false."

	^self!

xor: operand
	"Answer whether either the receiver or the <boolean> argument, operand,
	is true, but not both.
	N.B. Note that this a logical operation, like #eqv:, rather than a controlling
	operation, like and:, #or:, and expects a boolean argument, not a niladic
	valuable.
	This method was incorrectly defined in Dolphin versions pre-dating beta 2f."

	^(self == operand) == false! !

Bytecode comment:
'BytecodeRewrite is a private system utility class that supports the <BytecodeRewriter>.'!
!Bytecode class methodsFor!

instruction: bytecodeInteger arguments: anArray ip: aSmallInteger 
	^self new 
		setInstruction: bytecodeInteger
		arguments: anArray
		ip: aSmallInteger! !

!Bytecode methodsFor!

args
	^args!

instruction
	^instruction!

instruction: anObject
	instruction := anObject!

ip
	^ip!

ip: anObject
	ip := anObject!

jumpOffset: anInteger 
	| jumpSize |
	self assert: 
			[(args size = 1 and: [anInteger between: -128 and: 127]) 
				or: [args size >= 2 and: [anInteger between: -32768 and: 32767]]].
	jumpSize := args size min: 2.
	args := args 
				replaceFrom: args size - jumpSize + 1
				to: args size
				with: ((1 to: jumpSize) collect: [:each | anInteger digitAt: each])
				startingAt: 1!

jumpTarget
	^jumpTarget!

jumpTarget: anObject
	jumpTarget := anObject!

setInstruction: aSymbol arguments: anArray ip: aSmallInteger 
	instruction := aSymbol.
	args := anArray.
	ip := aSmallInteger.
! !

ByteCodeDispatcher comment:
'ByteCodeDispatchers decode bytecodes in <CompiledMethod>s and dispatches them to a plug-in <bytecodeInterpreter> client.

Instance Variables:
	byteCodes			<ByteArray>
	method				<CompiledCode>
	ip					<integer>
	interpreter			<bytecodeInterpreter>
	instructionLength	<integer>
	byteCode			<integer>

Class Variables:
	Instructions		<sequencedReadableCollection>
	RunStarts		<IdentityDictionary>

'!
!ByteCodeDispatcher class methodsFor!

byteCodeSegments: aCompiledMethod
	"Private - Answer an Array of segment arrays. Each segment is an Array with one
	or more elements. The first element being the bytecode, followed
	by any 'arguments' of the code."

	^(self on: aCompiledMethod) byteCodeSegments!

decodeLongJump: byte1 byte2: byte2 
	^(byte2 >= 128 ifTrue: [byte2 - 256] ifFalse: [byte2]) * 256 + byte1!

indexOfIP: anInteger in: aCompiledMethod
	"Private - Answer the index of the instruction line in a disassembly listing for
	the specified ip (which might be a data byte)."

	^(self on: aCompiledMethod) 
		indexOfIP: anInteger!

initialize
	"
		self initialize
	"

	| instructions runStarts |
	instructions := OrderedCollection new.
	runStarts := IdentityDictionary new.
	#(#(1 #break) #(16 #shortPushInstVar:) #(8 #shortPushTemp:) #(2 #pushContextTemp:) #(2 #shortPushOuterTemp:) #(16 #shortPushConst:) #(12 #shortPushStatic:) #(1 #pushSelf) #(3 #pushPseudo:) #(4 #shortPushImmediate:) #(4 #shortPushSelfAndTemp:) #(4 #shortStoreTemp:) #(2 #shortPopPushTemp:) #(1 #popPushSelf) #(1 #popDup) #(2 #popContextTemp:) #(2 #shortPopOuterTemp:) #(8 #shortPopInstVar:) #(8 #shortPopTemp:) #(1 #popStackTop) #(1 #incrementStackTop) #(1 #decrementStackTop) #(1 #duplicateStackTop) #(1 #returnSelf) #(3 #returnPseudo:) #(1 #returnFromMessage) #(1 #returnFromBlock) #(1 #returnFromBlockHome) #(1 #popReturnSelf) #(1 #nop) #(8 #shortJump:) #(8 #shortJumpIfFalse:) #(32 #shortSpecialSend:) #(13 #shortSendZeroArgs:) #(5 #shortSendSelfZeroArgs:) #(14 #shortSendOneArg:) #(8 #shortSendTwoArgs:) #(1 #isZero) #(1 #pushActiveFrame) #(4 #unused) #(1 #pushInstVar:) #(1 #pushTemp:) #(1 #pushConst:) #(1 #pushStatic:) #(1 #storeInstVar:) #(1 #storeTemp:) #(1 #storeStatic:) #(1 #popInstVar:) #(1 #popTemp:) #(1 #popStatic:) #(1 #pushImmediate:) #(1 #pushChar:) #(1 #send:) #(1 #supersend:) #(1 #specialSend:) #(1 #nearJump:) #(1 #nearJumpIfTrue:) #(1 #nearJumpIfFalse:) #(1 #nearJumpIfNil:) #(1 #nearJumpIfNotNil:) #(2 #unused:) #(1 #sendTempZeroArgs:) #(1 #pushSelfAndTemp:) #(1 #pushOuterTemp:) #(1 #storeOuterTemp:) #(1 #popOuterTemp:) #(1 #sendSelfZeroArgs:) #(1 #unused:) #(1 #pushTempPair:) #(1 #longPushConst:with:) #(1 #longPushStatic:with:) #(1 #longStoreStatic:with:) #(1 #longPopStoreStatic:with:) #(1 #longPushImmediate:with:) #(1 #longSend:with:) #(1 #longSupersend:with:) #(1 #longJump:with:) #(1 #longJumpIfTrue:with:) #(1 #longJumpIfFalse:with:) #(1 #longJumpIfNil:with:) #(1 #longJumpIfNotNil:with:) #(1 #pushOuter:temp:) #(1 #storeOuter:temp:) #(1 #incTemp:temp:) #(1 #incPushTemp:temp:) #(1 #decTemp:temp:) #(1 #decPushTemp:temp:) #(1 #blockCopy:stack:env:copy:offset1:offset2:) #(1 #exLongSend:with:with:) #(1 #exLongSupersend:with:with:) #(1 #unusedWithArguments:)) 
		do: 
			[:each | 
			| instruction runLength |
			instruction := each last.
			runLength := each first.
			runLength > 1 ifTrue: [runStarts at: instruction put: instructions size].
			runLength timesRepeat: [instructions add: instruction]].
	Instructions := instructions asArray.
	RunStarts := runStarts.
	self assert: [Instructions size = 256]!

instructions
	^Instructions!

lengthOfInstruction: anInteger 
	"Private - Answer the number of bytes for the bytecode identified by the <integer> argument."

	anInteger < FirstDoubleByte ifTrue: [^1].
	anInteger < FirstTripleByte ifTrue: [^2].
	anInteger < FirstMultiByte ifTrue: [^3].
	"At the moment the only multi-byte instruction with more than 4 bytes is Block Copy, needing 7 bytes"
	^anInteger == BlockCopy ifTrue: [7] ifFalse: [4]!

on: aCompiledMethod 
	"Answer a new instance of the receiver to interpret the <CompiledCode> argument."

	^self on: aCompiledMethod for: nil!

on: aCompiledCode for: anInstructionInterpreter 
	"Answer a new instance of the receiver to interpret, aMethod, which will dispatch
	instructions to the specified <bytecodeInterpreter> client."

	^(self new)
		method: aCompiledCode;
		interpreter: anInstructionInterpreter! !

!ByteCodeDispatcher methodsFor!

accessesInstVarAt: anInteger 
	"Answer whether the method which the receiver is interpreting accesses the
	instance variable with the index, anInteger."

	| offset |
	offset := anInteger - 1.	"instructions use 0 based offsets, not 1 based indices"
	self reset.
	[self atEnd] 
		whileFalse: [(self indexOfInstVarAccess: self fetch) == offset ifTrue: [^true]].
	^false!

accessesInstVarAtAnyOf: indices 
	"Answer whether the method which the receiver is interpreting accesses any
	of the instance variables with indices in the <Array> of <integer>, indices."

	self reset.
	[self atEnd] whileFalse: 
			[(self indexOfInstVarAccess: self fetch) 
				ifNotNil: [:offset | (indices identityIncludes: offset + 1) ifTrue: [^true]]].
	^false!

accessToInstVarAt: anInteger 
	"Answer a <Symbol> indicating the type of access that method which the receiver is
	interpreting makes to the instance variable with the index, anInteger:
		nil			The method does not access the instance variable 
		#read		The method reads, but does not write, the instance variable 
		#write		The method writes, but does not read, the instance variable 
		#readWrite 	The method reads and writes the instance variable"

	| offset access |
	offset := anInteger - 1.	"instructions use 0 based offsets, not 1 based indices"
	self reset.
	access := nil.
	[self atEnd] whileFalse: 
			[| byte |
			byte := self fetch.
			access == #read 
				ifTrue: [(self indexOfInstVarWrite: byte) == offset ifTrue: [^#readWrite]]
				ifFalse: 
					[(self indexOfInstVarRead: byte) == offset 
						ifTrue: [access ifNil: [access := #read] ifNotNil: [^#readWrite]]]].
	^access!

atEnd
	"Private - Answer whether the receiver is at the end of the method it is disassembling."

	^ip > byteCodes basicSize!

byteCodes
	"Answer the byte codes of the method being disassembled by the receiver."

	^byteCodes!

byteCodeSegments
	"Answer an Array of segment arrays. Each segment is an Array with one
	or more elements. The first element being the opcode, followed
	by any extension bytes."

	| answer |
	answer := OrderedCollection new: (byteCodes basicSize bitShift: -1).
	ip := 1.
	[self atEnd] whileFalse: 
			[| start |
			start := ip.
			self next.
			answer add: (byteCodes copyFrom: start to: ip - 1)].
	^answer!

containsInstruction: discriminator 
	"Answer whether the dyadic valuable, discriminator, evaluates to true for
	any instruction/parameter pair in the receiver."

	self reset.
	[self atEnd] whileFalse: [(self nextInstructionDo: discriminator) ifTrue: [^true]].
	^false!

dispatchAll
	"Private - Interpret the receiver's method sending messages for each instruction to the client."

	self reset.
	[self atEnd] whileFalse: [self dispatchNext]!

dispatchNext
	"Private - Dispatch the next instruction in the receiver's method to the interpreter."

	"Implementation Note: For performance reasons this effectively duplicates the code in #instruction:do:"

	| aSymbol |
	aSymbol := self fetch.
	instructionLength == 1 
		ifTrue: 
			[aSymbol last == $: 
				ifTrue: [interpreter perform: aSymbol with: byteCode - (RunStarts at: aSymbol)]
				ifFalse: [interpreter perform: aSymbol]]
		ifFalse: 
			[instructionLength == 2 
				ifTrue: [interpreter perform: aSymbol with: (byteCodes at: ip - 1)]
				ifFalse: 
					[instructionLength == 3 
						ifTrue: 
							[interpreter 
								perform: aSymbol
								with: (byteCodes at: ip - 2)
								with: (byteCodes at: ip - 1)]
						ifFalse: 
							[instructionLength == 4 
								ifTrue: 
									[interpreter 
										perform: aSymbol
										with: (byteCodes at: ip - 3)
										with: (byteCodes at: ip - 2)
										with: (byteCodes at: ip - 1)]
								ifFalse: 
									[| args argc |
									argc := instructionLength - 1.
									args := Array new: argc.
									1 to: argc do: [:i | args at: argc - i + 1 put: (byteCodes at: ip - i)].
									interpreter perform: aSymbol withArguments: args]]]]!

fetch
	^Instructions at: self next + 1!

indexOfInstVarAccess: aSymbol 
	^(self indexOfInstVarRead: aSymbol) ifNil: [self indexOfInstVarWrite: aSymbol]!

indexOfInstVarRead: aSymbol 
	aSymbol == #shortPushInstVar: ifTrue: [^byteCode - ShortPushInstVar].
	aSymbol == #pushInstVar: ifTrue: [^byteCodes at: ip - 1].
	^nil!

indexOfInstVarWrite: aSymbol 
	aSymbol == #shortPopInstVar: ifTrue: [^byteCode - ShortPopInstVar].
	(aSymbol == #storeInstVar: or: [aSymbol == #popInstVar:]) ifTrue: [^byteCodes at: ip - 1].
	^nil!

indexOfIP: anInteger
	"Private - Answer the index of the instruction line in a disassembly listing for
	the specified ip (which might be a data byte)."

	| i |
	i := 1.
	[ip < anInteger] whileTrue: [i := i + 1. self next].
	^i!

instruction: aSymbol do: aDyadicValuable 
	instructionLength == 1 
		ifTrue: 
			[^aDyadicValuable value: aSymbol
				value: (aSymbol last == $: 
						ifTrue: [Array with: byteCode - (RunStarts at: aSymbol)]
						ifFalse: [#()])].
	instructionLength == 2 
		ifTrue: [^aDyadicValuable value: aSymbol value: (Array with: (byteCodes at: ip - 1))].
	instructionLength == 3 
		ifTrue: 
			[^aDyadicValuable value: aSymbol
				value: (Array with: (byteCodes at: ip - 2) with: (byteCodes at: ip - 1))].
	^instructionLength == 4 
		ifTrue: 
			[aDyadicValuable value: aSymbol
				value: (Array 
						with: (byteCodes at: ip - 3)
						with: (byteCodes at: ip - 2)
						with: (byteCodes at: ip - 1))]
		ifFalse: 
			[| args argc |
			argc := instructionLength - 1.
			args := Array new: argc.
			1 to: argc do: [:i | args at: argc - i + 1 put: (byteCodes at: ip - i)].
			aDyadicValuable value: aSymbol value: args]!

instructions
	"Answer a sequenceable collection of associations between symbolic instruction names and argument
	in the receiver."

	| answer |
	answer := OrderedCollection new.
	self instructionsDo: [:selector :args | answer add: (selector -> args)].
	^answer!

instructionsDo: operation 
	"Evaluate the dyadic valuable, operation, for each instruction in the receiver, passing 
	the instruction symbolic name (a keyword selector) and an array of arguments (which should not be
	modified)."

	self reset.
	[self atEnd] whileFalse: [self nextInstructionDo: operation]!

interpreter: anInstructionInterpreter 
	"Private - Set the receiver's interpreter client. The client is sent messages (the
	selectors for which it can supply) for each of the instructions in the the receivers
	method."

	interpreter := anInstructionInterpreter!

ip
	"Answer the current instruction pointer."

	^ip!

ip: newIP
	"Set the current instruction pointer to the <integer> argument.
	N.B. This should be used with care, since it needs to be the index of the start
	of a byte code."

	ip := newIP!

method
	"Answer the method to being decoded by the receiver."

	^method!

method: aCompiledMethod 
	"Set the method to be decoded by the receiver to aCompiledMethod. Also reset the
	instruction pointer and cache the methods byte codes (which may have to be generated from "

	ip := 1.
	method := aCompiledMethod.
	byteCodes := method byteCodes!

next
	"Answer the next instruction byte code of the receiver, advancing ip appropriately."

	byteCode := byteCodes at: ip.
	instructionLength := self class lengthOfInstruction: byteCode.
	ip := ip + instructionLength.
	^byteCode!

nextInstructionDo: operation 
	"Private - Answer the result of evaluating the dyadic valuable, operation, for the next 
	instruction in receiver's stream, passing the instruction symbolic name (a keyword selector) 
	and an array of argument bytes (N.B. not a ByteArray, but an Array of bytes)."

	^self instruction: self fetch do: operation!

peekForSelector
	"Answer the message selector of the next byte code, or nil if it is not a message
	send instruction. The instruction pointer is advanced.
	Note that this method used to be a private method #selectorOfNextIfSend, but has been
	renamed for VW compatibility."

	^self selectorOfMessageSend: self fetch!

prevIP: anInteger
	"Answer the ip of the instruction immediately preceding that with IP, anInteger."

	| prevIP |
	prevIP := 0.
	ip := 1.
	[ip < anInteger] whileTrue: [prevIP := ip. self next].
	^prevIP
!

readsInstVarAt: anInteger 
	"Answer whether the method which the receiver is interpreting reads the
	instance variable with the index, anInteger."

	| offset |
	offset := anInteger - 1.	"instructions use 0 based offsets, not 1 based indices"
	self reset.
	[self atEnd] 
		whileFalse: [(self indexOfInstVarRead: self fetch) == offset ifTrue: [^true]].
	^false!

readsStatic: anAssociation
	"Answer whether the method which the receiver is interpreting reads the
	static variable argument."

	| offset |
	offset := (method literals identityIndexOf: anAssociation) - 1.
	^offset >= 0 and: 
			[self containsInstruction: 
					[:selector :args | 
					((#(#shortPushStatic: #pushStatic:) identityIncludes: selector) and: [args first == offset]) 
						or: [selector == #longPushStatic:with: and: [offset == (args first + (args last * 256))]]]]!

reset
	ip := 1!

selectorOfMessageSend: aSymbol 
	aSymbol == #shortSendZeroArgs: 
		ifTrue: [^method literalAt: byteCode - ShortSendZeroArgs + 1].
	aSymbol == #shortSendSelfZeroArgs: 
		ifTrue: [^method literalAt: byteCode - ShortSendSelfZeroArgs + 1].
	aSymbol == #shortSpecialSend: 
		ifTrue: [^self selectorOfSpecialSend: byteCode - ShortSpecialSend].
	aSymbol == #shortSendOneArg: ifTrue: [^method literalAt: byteCode - ShortSendOneArg + 1].
	aSymbol == #shortSendTwoArgs: 
		ifTrue: [^method literalAt: byteCode - ShortSendTwoArgs + 1].
	(aSymbol == #send: or: [aSymbol == #supersend:]) 
		ifTrue: [^method literalAt: ((byteCodes at: ip - 1) bitAnd: 31) + 1].
	(aSymbol == #sendSelfZeroArgs: 
		or: [aSymbol == #longSend:with: or: [aSymbol == #longSupersend:with:]]) 
			ifTrue: [^method literalAt: (byteCodes at: ip - 1) + 1].
	^nil!

selectorOfSpecialSend: anInteger 
	"Answer the selector which corresponds to the special send with the specified offset from the start
	of the special send instructions."

	^VMLibrary default specialSelectors at: anInteger + 1!

sendsSpecialSelector: anInteger
	"Answer whether the method which the receiver is interpreting sends the special
	selector with the specified index (one based)."

	| offset |
	offset := anInteger - 1.	"instructions use 0 based offsets, not 1 based indices"
	^self containsInstruction: [:selector :args |
		(selector == #shortSpecialSend:) and: [args first == offset]]!

specialMessages
	"Private - Answer the set of special message sends in the byte code stream."

	| answer specials |
	answer := IdentitySet new.
	specials := VMLibrary default specialSelectors.
	self instructionsDo: 
			[:op :args | 
			op == #shortSpecialSend: ifTrue: [answer add: (specials at: args first + 1)]].
	^answer!

writesInstVarAt: anInteger 
	"Answer whether the method which the receiver is streaming over writes to the
	instance variable with the index, anInteger."

	| offset |
	offset := anInteger - 1.	"instructions use 0 based offsets, not 1 based indices"
	self reset.
	[self atEnd] 
		whileFalse: [(self indexOfInstVarWrite: self fetch) == offset ifTrue: [^true]].
	^false!

writesStatic: anAssociation 
	"Answer whether the method interpreted by the receiver writes to the specified 
	static variable."

	| offset |
	offset := (method literals identityIndexOf: anAssociation) - 1.
	^offset >= 0 and: 
			[self containsInstruction: 
					[:selector :args | 
					((#(#popStatic: #storeStatic:) identityIncludes: selector) and: [args first == offset]) 
						or: 
							[(#(#longPopStoreStatic:with: #longStoreStatic:with:) identityIncludes: selector) 
								and: [offset == (args first + (args last * 256))]]]]! !

BytecodeRewriter comment:
'BytecodeRewrite is a private system utility class for upgrading Dolphin 5 methods stored in STB files to be compatible with Dolphin 6. Note that the translation is not optimal, and where possible methods (blocks) saved in resources should be recompiled.'!
!BytecodeRewriter class methodsFor!

initialize
	"
		self initialize

		PLEASE DO NOT REFORMAT ME
	"

	| instructions |
	instructions := OrderedCollection new.
	#(
		#(1 #singleByte)		"break"
		#(16 #singleByte)		"short push inst var"
		#(12 #shortPushTemp)
		#(16 #singleByte)		"short push const"
		#(12 #singleByte)		"short push static"
		#(4 #singleByte)		"push pseudo var"
		#(4 #singleByte)		"short push immediate"
		#(16 #singleByte)		"unused"
		#(8 #singleByte)		"pop store inst var"
		#(8 #shortPopStoreTemp)
		#(1 #singleByte) 		"pop"
		#(1 #singleByte) 		"inc"
		#(1 #singleByte) 		"dec"
		#(1 #singleByte) 		"dup"
		#(4 #returnPseudo)
		#(1 #returnFromMessage)
		#(1 #returnFromBlock)
		#(1 #returnFromBlockHome)
		#(1 #pushActiveFrame)
		#(1 #singleByte)		"nop"
		#(8 #shortJump)
		#(8 #shortJumpIfFalse)
		#(32 #singleByte)		"short special send"
		#(16 #shortSendNoArgs)
		#(16 #shortSendOneArg)
		#(8 #shortSendTwoArgs)
		#(1 #testIsZero)
		#(5 #singleByte)		"unused"
		#(1 #doubleByte)		"push inst var"
		#(1 #pushTemp)
		#(1 #doubleByte)		"push const"
		#(1 #doubleByte)		"push static"
		#(1 #doubleByte)		"store inst var"
		#(1 #storeTemp)
		#(1 #doubleByte)		"store static"
		#(1 #doubleByte)		"pop store inst var"
		#(1 #popStoreTemp)
		#(1 #doubleByte)		"pop store static"
		#(1 #doubleByte)		"push immediate"
		#(1 #doubleByte)		"push char"
		#(1 #doubleByte)		"send"
		#(1 #doubleByte)		"supersend"
		#(1 #doubleByte)		"special send (reserved)"
		#(1 #nearJump)
		#(1 #nearJumpIfTrue)
		#(1 #nearJumpIfFalse)
		#(1 #nearJumpIfNil)
		#(1 #nearJumpIfNotNil)
		#(3 #unusedDoubleByte)
		#(1 #pushSelfAndTemp)
		#(6 #unusedDoubleByte)
		#(7 #trebleByte)		"long pushes and stores, pop store static, send and supersend"
		#(3 #longJump)
		#(7 #unusedTrebleByte)
		#(1 #blockCopy)
		#(1 #exLongSend)
		#(1 #exLongSupersend)
		#(2 #unusedQuadByte)) do: [:each | each first timesRepeat: [instructions add: each last]].
	self assert: [instructions size = 256].
	DispatchMap := instructions asArray. 
!

rewriteMethod: aCompiledMethod 
	^self new rewriteMethod: aCompiledMethod! !

!BytecodeRewriter methodsFor!

assemble
	| bytestream |
	bytestream := ByteArray writeStream: instructions size * 3.
	instructions do: [:each | 
		bytestream nextPut: each instruction; nextPutAll: each args].
	^bytestream contents!

atEnd
	^ip >= bytecodes size!

blockCopy
	| args argc byte1 byte2 instruction originalIP |
	self assert: [needsContext].
	argc := self fetch.
	byte1 := self fetch.
	byte2 := self fetch.
	originalIP := ip.
	"BlockCopy is now a much more complex instruction reflecting the multiple types of temps that are supported"
	args := ByteArray new: 6.
	args
		at: 1 put: argc;
		at: 2 put: 0;
		at: 3 put: 1;
		at: 4 put: 1.	"No extra stack temps will be used, as we store all in home context"	"7 bits for env slots, and bottom bit for outer ref required flag"	"7 bits for copied value count, and bottom bit for requires receiver flag"
	instruction := Bytecode 
				instruction: BlockCopy
				arguments: args
				ip: ip - 4.
	instruction jumpTarget: (ByteCodeDispatcher decodeLongJump: byte1 byte2: byte2) + ip.
	self assert: 
			[| ret |
			ret := bytecodes at: instruction jumpTarget.
			ret == ReturnFromBlock 
				or: [ret == ReturnFromMessage or: [ret between: ReturnSelf and: ReturnNil]]].
	blockStack addLast: instruction jumpTarget - 1.
	self emitInstruction: instruction.
	blockMap at: originalIP + 1 put: newIP + 1.
	self pushBlockArgs: argc!

blockDepth
	^blockStack size!

blockMap
	^blockMap!

convertHeader: aSmallInteger 
	| privacy |
	privacy := aSmallInteger >> 4 & 1.
	^aSmallInteger & ##(16rFFFF << 15) | (needsContext 
				ifTrue: 
					["On conversion the temp count of the old method's that need contexts
					becomes the env temp count of the new since all args/temps have a slot
					allocated there, with args copied over into those slots off the stack."

					| tempCount |
					tempCount := aSmallInteger >> 7 & 255.
					tempCount > 63 ifTrue: [self error: 'too many temporaries'].
					tempCount + 1 << 1]
				ifFalse: [aSmallInteger & ##(16rFFFFFF << 7)]) 
		| privacy!

copyMethodArgs: aCompiledMethod 
	| argc |
	argc := aCompiledMethod argumentCount.
	0 to: (argc - 1 min: 11)
		do: 
			[:i | 
			self emitInstruction: (Bytecode 
						instruction: ShortPushTemp + i
						arguments: #[]
						ip: nil).
			self emitInstruction: (Bytecode 
						instruction: PopOuterTemp
						arguments: (ByteArray with: i)
						ip: nil)].
	12 to: argc - 1
		do: 
			[:i | 
			self emitInstruction: (Bytecode 
						instruction: PushTemp
						arguments: (ByteArray with: i)
						ip: nil).
			self emitInstruction: (Bytecode 
						instruction: PopOuterTemp
						arguments: (ByteArray with: i)
						ip: nil)]!

doubleByte
	| byte2 |
	byte2 := self fetch.
	self emitInstruction: (Bytecode 
				instruction: bytecode
				arguments: (Array with: byte2)
				ip: ip - 2)!

emitInstruction: aBytecode 
	aBytecode ip ifNotNil: [:oldIP | ipMap at: oldIP put: aBytecode].
	aBytecode ip: newIP.
	newIP := newIP + 1 + aBytecode args size.
	instructions addLast: aBytecode!

emitJumpOnNil: aBoolean 
	| offset instruction |
	offset := self fetchNearJumpOffset.
	instruction := offset abs > 64 
				ifTrue: 
					[self emitInstruction: (Bytecode 
								instruction: (aBoolean ifTrue: [ShortSendIsNil] ifFalse: [ShortSendNotNil])
								arguments: #[]
								ip: ip - 2).
					Bytecode 
						instruction: LongJumpIfTrue
						arguments: (ByteArray with: 0 with: 0)
						ip: nil]
				ifFalse: 
					[Bytecode 
						instruction: bytecode
						arguments: (ByteArray with: 0)
						ip: ip - 2].
	instruction jumpTarget: offset + ip.
	self emitInstruction: instruction!

emitNearJump: offsetInteger asLongJump: jumpInteger 
	| instruction |
	#todo.	"Determine whether near or long needed in a more intelligent way"
	instruction := offsetInteger abs > 64 
				ifTrue: 
					[Bytecode 
						instruction: jumpInteger
						arguments: (ByteArray with: 0 with: 0)
						ip: ip - 2]
				ifFalse: 
					[Bytecode 
						instruction: bytecode
						arguments: (ByteArray with: 0)
						ip: ip - 2].
	instruction jumpTarget: offsetInteger + ip.
	self emitInstruction: instruction!

emitNearJumpAsLongJump: anInteger 
	"Determine whether near or long needed in a more intelligent way"

	self emitNearJump: self fetchNearJumpOffset asLongJump: anInteger!

emitShortJump: offsetInteger asNearJump: instructionInteger 
	| instruction |
	instruction := Bytecode 
				instruction: instructionInteger
				arguments: (ByteArray with: 0)
				ip: ip - 1.
	"Min short jump is +2, so add 1"
	instruction jumpTarget: offsetInteger + 1 + ip.
	self emitInstruction: instruction!

exLongSend
	"Private - This instruction has been remapped to a different code. It
	is very unlikely to appear anyway since it is only used for extremely
	large methods (such as auto-generated ones)."

	| args |
	args := ByteArray 
				with: self fetch
				with: self fetch
				with: self fetch.
	self emitInstruction: (Bytecode 
				instruction: ExLongSend
				arguments: args
				ip: ip - 4)!

exLongSupersend
	"Private - This instruction has been remapped to a different code. It
	is very unlikely to appear anyway since it is only used for extremely
	large methods (such as auto-generated ones)"

	| args |
	args := ByteArray 
				with: self fetch
				with: self fetch
				with: self fetch.
	self emitInstruction: (Bytecode 
				instruction: ExLongSupersend
				arguments: args
				ip: ip - 4)!

fetch
	ip := ip + 1.
	^bytecodes at: ip!

fetchNearJumpOffset
	| byte |
	byte := self fetch.
	^byte >= 128 ifTrue: [byte - 256] ifFalse: [byte]!

isInBlock
	^blockStack notEmpty!

longJump
	| byte1 byte2 instruction |
	byte1 := self fetch.
	byte2 := self fetch.
	instruction := Bytecode 
				instruction: bytecode
				arguments: (ByteArray with: byte1 with: byte2)
				ip: ip - 3.
	instruction jumpTarget: (ByteCodeDispatcher decodeLongJump: byte1 byte2: byte2) + ip.
	self emitInstruction: instruction!

nearJump
	self emitNearJumpAsLongJump: LongJump!

nearJumpIfFalse
	self emitNearJumpAsLongJump: LongJumpIfFalse!

nearJumpIfNil
	self emitJumpOnNil: true!

nearJumpIfNotNil
	self emitJumpOnNil: false!

nearJumpIfTrue
	self emitNearJumpAsLongJump: LongJumpIfTrue!

popStoreTemp
	| temp outer |
	temp := self fetch.
	self assert: [temp < 31].
	outer := blockStack size.
	self assert: [outer < 8].
	self emitInstruction: (Bytecode 
				instruction: PopOuterTemp
				arguments: (ByteArray with: (outer << 5 bitOr: temp))
				ip: ip - 2)!

pushActiveFrame
	self emitInstruction: (Bytecode 
				instruction: PushActiveFrame
				arguments: #[]
				ip: ip - 1)!

pushBlockArgs: anInteger 
	self assert: [needsContext].
	0 to: (anInteger - 1 min: 11)
		do: 
			[:i | 
			self emitInstruction: (Bytecode 
						instruction: ShortPushTemp + i
						arguments: #[]
						ip: nil)].
	12 to: anInteger - 1
		do: 
			[:i | 
			self emitInstruction: (Bytecode 
						instruction: PushTemp
						arguments: (ByteArray with: i)
						ip: nil)]!

pushSelfAndTemp
	self emitInstruction: (Bytecode 
				instruction: PushSelf
				arguments: #()
				ip: ip - 1).
	self 
		tempInstr: PushTemp
		outerInstr: PushOuterTemp
		ip: nil!

pushTemp
	self 
		tempInstr: PushTemp
		outerInstr: PushOuterTemp
		ip: ip - 1!

quadByte
	| args |
	args := ByteArray 
				with: self fetch
				with: self fetch
				with: self fetch.
	self emitInstruction: (Bytecode 
				instruction: bytecode
				arguments: args
				ip: ip - 4)!

returnFromBlock
	| blocks |
	self assert: [needsContext].
	blocks := blockStack size.
	self assert: [blocks > 0 and: [ip-1 <= blockStack last]].
	self singleByte!

returnFromMessage
	blockStack notEmpty ifTrue: [bytecode := ReturnFromBlockHome].
	self singleByte!

returnPseudo
	self isInBlock 
		ifTrue: 
			[| which |
			self assert: [needsContext].
			which := bytecode - 16r65.
			bytecode := PushSelf + which.
			self singleByte.
			self emitInstruction: (Bytecode 
						instruction: ReturnFromBlockHome
						arguments: #()
						ip: nil)]
		ifFalse: [self singleByte]!

rewriteBytecodesOf: aCompiledMethod 
	bytecodes := aCompiledMethod byteCodes.
	blockStack := OrderedCollection new.
	instructions := OrderedCollection new.
	ipMap := IdentityDictionary new.
	blockMap := IdentityDictionary new.
	ip := 0.
	newIP := 0.
	needsContext := aCompiledMethod header allMask: 16r40.
	needsContext ifTrue: [self copyMethodArgs: aCompiledMethod].
	[self atEnd] whileFalse: 
			[[blockStack notEmpty and: [ip > blockStack last]] whileTrue: [blockStack removeLast].
			bytecode := self fetch.
			self perform: (DispatchMap at: bytecode + 1)].
	self assert: [blockStack isEmpty].
	self updateJumps.
	^self assemble!

rewriteMethod: aCompiledMethod 
	^(aCompiledMethod copy)
		byteCodes: (self rewriteBytecodesOf: aCompiledMethod);
		header: (self convertHeader: aCompiledMethod header);
		yourself!

shortJump
	| offset |
	offset := bytecode - ShortJump.
	self emitShortJump: offset asNearJump: NearJump!

shortJumpIfFalse
	| offset |
	offset := bytecode - ShortJumpIfFalse.
	self emitShortJump: offset asNearJump: NearJumpIfFalse!

shortPopStoreTemp
	self shortTempInstr: ShortPopTemp outerInstr: PopOuterTemp!

shortPushTemp
	self shortTempInstr: 17 outerInstr: PushOuterTemp!

shortSendNoArgs
	"New instruction set has fewer sends with 0 args, because some are now used
	for sends to self with zero args, therefore we may need to emit a longer instruction"

	| index code args |
	index := bytecode - 158.
	index < 12 
		ifTrue: 
			[code := ShortSendZeroArgs + index.
			args := #[]]
		ifFalse: 
			[self assert: [index < 32].
			code := Send.
			args := ByteArray with: index	"0 << 5 | "].
	self emitInstruction: (Bytecode 
				instruction: code
				arguments: args
				ip: ip - 1)!

shortSendOneArg
	| index code args |
	index := bytecode - 174.
	index < 13
		ifTrue: 
			[code := ShortSendOneArg + index.
			args := #[]]
		ifFalse: 
			[self assert: [index < 32].
			code := Send.
			args := ByteArray with: 1 << 5 | index].
	self emitInstruction: (Bytecode 
				instruction: code
				arguments: args
				ip: ip - 1)!

shortSendTwoArgs
	| index code args |
	index := bytecode - 190.
	index < 8 
		ifTrue: 
			[code := ShortSendTwoArgs + index.
			args := #[]]
		ifFalse: 
			[self assert: [index < 32].
			code := Send.
			args := ByteArray with: 2 << 5 | index].
	self emitInstruction: (Bytecode 
				instruction: code
				arguments: args
				ip: ip - 1)!

shortTempInstr: shortInteger outerInstr: outerInteger 
	"Note: New instruction set has only twelve short push temps, used to be 16, with the remainder being 
	used for short pushes of context temps"

	| args temp byte |
	temp := bytecode - shortInteger.
	#todo.	"Handle conversion of more than 12 temps"
	self assert: [temp < 12].
	byte := needsContext 
				ifTrue: 
					[| outer |
					outer := blockStack size.
					self assert: [outer < 8].
					args := ByteArray with: (outer << 5 bitOr: temp).
					outerInteger]
				ifFalse: 
					[args := #[].
					bytecode].
	self emitInstruction: (Bytecode 
				instruction: byte
				arguments: args
				ip: ip - 1)!

singleByte
	self emitInstruction: (Bytecode 
				instruction: bytecode
				arguments: #[]
				ip: ip - 1)!

storeTemp
	self 
		tempInstr: StoreTemp
		outerInstr: StoreOuterTemp
		ip: ip - 1!

tempInstr: codeInteger outerInstr: outerInteger ip: ipInteger 
	| pushTemp temp |
	temp := self fetch.
	pushTemp := needsContext 
				ifTrue: 
					[| outer |
					self assert: [temp < 32].
					outer := blockStack size.
					self assert: [outer < 8].
					temp := outer << 5 bitOr: temp.
					outerInteger]
				ifFalse: [codeInteger].
	self emitInstruction: (Bytecode 
				instruction: pushTemp
				arguments: (ByteArray with: temp)
				ip: ipInteger)!

testIsZero
	self emitInstruction: (Bytecode 
				instruction: IsZero
				arguments: #[]
				ip: ip - 1)
!

trebleByte
	| args |
	args := ByteArray with: self fetch with: self fetch.
	self emitInstruction: (Bytecode 
				instruction: bytecode
				arguments: args
				ip: ip - 3)!

unusedDoubleByte
	self error: 'Invalid double byte instruction: ' , bytecode printString!

unusedQuadByte
	self error: 'Invalid quad byte instruction: ' , bytecode printString!

unusedSingleByte
	self error: 'Invalid single byte instruction: ' , bytecode printString!

unusedTrebleByte
	self error: 'Invalid treble byte instruction: ' , bytecode printString!

updateJumps
	instructions do: 
			[:each | 
			each jumpTarget notNil 
				ifTrue: [each jumpOffset: (ipMap at: each jumpTarget) ip - (each ip + 1 + each args size)]]! !

Category comment:
'The abstract Category class is used to organize <Class> and <CompiledMethod> objects into subgroupings independent of the implementation hierarchy. This structuring is for the benefit of the user navigating through thousands of classes and methods in the Dolphin Smalltalk development system, and has no run-time significance.

Instance Variables:
	name	<String> name of the receiver, unique in the system.
	comment	<String> description of the category, for documentary purposes.

Class Variables:
	PermanentCategories		<Set> of all categories which are always available, even if empty
	'!
!Category class methodsFor!

categoryIcon
	"Answer an Icon representing the Category objects which the receiver collects." 

	^self icon!

initialize
	"Private - Initialize the receiver's class variables."

	PermanentCategories := IdentitySet new!

name: categoryName
	"Answer the subinstance of the receiver with the 
	<readableString> name, categoryName."

	^self subclassResponsibility!

new
	"Categories must be unique for any particular name, and must be instantiated with the #name:
	method."

	^self shouldNotImplement!

newNamed: categoryName
	"Private - Answer a new subinstance of the receiver with the 
	<readableString> name, categoryName."

	^self basicNew
		setName: categoryName asString;
		yourself!

separator
	"Private - Answer a Character used to split the individual names in a
	complete category."

	^ $-!

unclassified
	"Answer a Category used to mark an unclassified object."

	^self name: self unclassifiedName!

unclassifiedName
	"Private - Answer the String name used to mark a none existing category."

	^self subclassResponsibility!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	PermanentCategories := nil.! !

!Category methodsFor!

<= comperand
	"Answer whether the receiver is less than or equal to the <Category>,
	comperand."

	^self name <= comperand name!

= comperand
	"Answer whether the receiver is considered equal to the <Object>, comperand."

	^self species == comperand species and: [self name equals: comperand name]!

acceptsAdditions
	"Answer whether new members can be added to the receiver.
	Generally speaking pseudo categories do not accept additions, and
	ordinary categories do. Some types of non-pseudo virtual categories
	can have methods added to them."

	^self isPseud not!

addClass: class
	"Add the <Class>, class, to the collection of classes associated with the receiver."

	^self subclassResponsibility!

asString
	"Answer the string representation for the receiver."

	^self name!

contents
	"Answer all the objects held by the receiver."

	^self subclassResponsibility!

displayOn: aStream
	"Append the receiver to aStream in a format that a user would want to see"

	aStream nextPutAll: self name!

hash
	"Answer the <integer> hash value for the receiver."

	^self name hash!

isEmpty
	"Answer whether the receiver is an empty category (with no members)"

	^self contents isEmpty!

isIntermediate
	"Private - Answer whether the receiver is a temporary category used only as a 
	branch node in a category tree."

	^false!

isPermanent
	"Answer whether the receiver should be not removed from a CategoryManager
	when there are no references to it."

	^PermanentCategories includes: self!

isPermanent: aBoolean
	"Set whether the receiver should not be removed when there are
	no references to it."

	aBoolean
		ifTrue: [PermanentCategories add: self]
		ifFalse: [PermanentCategories remove: self ifAbsent: []]!

isPseud
	"Answer whether the receiver is a pseudo (i.e. not a 'real') category.
	Pseudo categories have dynamically calculated contents, and may not accept 
	additions."

	^self isVirtual!

isVirtual
	"Answer whether the receiver is a virtual category, i.e. one that
	has calculated contents. All pseudo-categories are virtual, but not vice versa."

	^false!

localName
	"Answer the local name of the receiver unique only within the parent category"

	^name copyFrom: (name lastIndexOf: self class separator)+1 to: name size!

name
	"Answer a unique, amongst Category objects, <readableString> name for the receiver."

	^name!

printOn: aStream
	"Append a representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		nextPut: $(;
		print: name;
		nextPut: $)!

removeClass: class
	"Remove the <ClassDescription>, class, from the classes 'held' by the receiver."

	^self subclassResponsibility!

setName: aName
	"Private - Set the name of the receiver to aName.

	Restrict access because name has to be unique amongst all Categories and
	so we have to ensure that the Category categoryNames dictionary is kept
	up to date."

	name := aName!

subNames
	"Answer an OrderedCollection of the receivers name split
	on category separator."

	^self name subStrings: self class separator! !

ChunkReader comment:
'
	The source reader is delegated the task of reading chunks
	from the input stream, and so can impose its own format.'!
!ChunkReader class methodsFor!

do: operation 
	"Answer a new instance of the reciever which will evaluate
	the monadic valuable, operation, for every chunk string read
	via the source manager, aSourceManager."

	^self do: operation atEnd: []!

do: operation atEnd: finalOperation 
	"Answer a new instance of the reciever which will evaluate
	the <monadicValuable>, operation, for every chunk string read
	via the source manager, aSourceManager. At the end
	of the batch of chunks (i.e. when an empty chunk is reach),
	the <niladicValuable>, finalOperation, is evaluated."

	^self 
		do: operation
		inContext: nil
		atEnd: finalOperation!

do: operation inContext: contextObject atEnd: finalOperation 
	"Answer a new instance of the reciever which will evaluate
	the <monadicValuable>, operation, for every chunk string read
	via the source manager, aSourceManager. At the end
	of the batch of chunks (i.e. when an empty chunk is reach),
	the <niladicValuable>, finalOperation, is evaluated."

	^(self new)
		setChunkBlock: operation
			context: contextObject
			endAction: finalOperation;
		yourself!

null
	"Answer a null instance of the receiver which consumes and discards input without
	processing it in any way."

	Null isNil ifTrue: [Null := self do: [:chunk |]].
	^Null!

onPreStripImage
	"Private - The image is about to be deployed as an executable/DLL. Clean away
	any lazily initialized class variables in order to assist the stripping process."

	Null := nil! !

!ChunkReader methodsFor!

chunk: chunkString
	"Private - Evaluate the receivers chunkBlock with chunkString."

	self chunkBlock value: chunkString!

chunkBlock
	"Answer the receivers chunkBlock. This is a <monadicValuable> 
	which is evaluated for each chunk of text read from a stream."

	^chunkBlock!

context
	"Answer the context <Object> associated with the receiver when it was created (usually the class
	into which methods are to be compiled)."

	^context!

fileInFrom: aSourceFiler
	"Private - File in the next chunk from the <ChunkSourceFiler> argument, 
	aChunkSourceFiler. Continue reading chunks until the end of the file or an 
	empty chunk is reached, at which point the final action is evaluated. Answer 
	the result of the final action."

	| chunk |
	[aSourceFiler atEnd or: [(chunk := aSourceFiler nextChunk) isEmpty]]
		whileFalse: [self chunk: chunk].
	^endAction value!

setChunkBlock: perChunk context: contextObject endAction: finalOperation 
	"Private - Initialize the receiver's instance variables."

	chunkBlock := perChunk.
	endAction := finalOperation.
	context := contextObject! !

ClassBuilder comment:
''!
!ClassBuilder class methodsFor!

allClassVarNamesOf: aClass
	"Private - Answer an array of the class var names of aClass.
	The Array will be empty if aClass is nil."

	^aClass isNil
		ifTrue: [Array new]
		ifFalse: [aClass allClassVarNames]!

allInstVarNamesOf: aClass
	"Private - Answer an array of the inst var names of aClass.
	The Array will be empty if aClass is nil."

	^aClass isNil
		ifTrue: [Array new]
		ifFalse: [aClass allInstVarNames]!

classOf: aClass
	"Private - Answer the class of aClass or Class if it is nil."

	^aClass notNil
		ifTrue: [aClass class]
		ifFalse: [Class]!

forModifying: aClass 
	"Answer a new instance of the receiver set up to modify the <Class>, aClass.
	The instance is initialized with all the current attributes of the class, so obviously
	one or more of these must be modified if any modification is actually to take place."

	^(self new)
		class: aClass;
		superclass: aClass superclass;
		instanceVariables: aClass instVarNames;
		classVariables: aClass classVarNames;
		sharedPools: aClass sharedPoolNames;
		yourself!

fundamentalTypeOf: anInstanceSpec
	"Private - Answer the combined settings of the isVariable and isPointers flags of anInstanceSpec."

	^anInstanceSpec bitAnd: _VariableMask + _PointersMask!

initialize
	"Initialize the receiver's class variables.
		ClassBuilder initialize
	"

	Unsubclassable := (Set new)
				add: Character;
				add: SmallInteger;
				shrink;
				isImmutable: true;
				yourself.
	FixedLayout := (Set new)
				add: true class;
				add: false class;
				add: Array;
				add: VariableBinding;
				add: Character;
				add: SmallInteger;
				add: BlockClosure;
				add: Context;
				add: ExternalMethod;
				add: ExternalAddress;
				add: Message;
				add: MethodDictionary;
				add: UndefinedObject;
				add: Object;
				shrink;
				isImmutable: true;
				yourself.
	"add: ProtoObject;"
	FixedInitialLayout := (Set new)
				add: Class;
				add: Metaclass;
				add: PositionableStream;
				add: Semaphore;
				add: Process;
				add: ProcessorScheduler;
				shrink;
				isImmutable: true;
				yourself.
	RecompileMask := 1.
	IgnoreInstsMask := 2!

instanceSpecIsBytes: anInstanceSpec
	"Private - Answer whether anInstanceSpec represents a byte subclass."

	^(anInstanceSpec anyMask: _PointersMask) not!

instanceSpecWithFixedPointers: anInteger
	"Private - Answer an instance spec based on anInteger but adjusted to represent instances
	containing named instance vars only."

	^_PointersMask bitOr: (anInteger bitAnd: _SizeMask)!

instanceSpecWithIndirectBytes
	"Private - Answer an instance spec to represent instances with no named instances variables,
	made of indexable bytes and interpreted by certain system primitives as an indirection to
	other data."

	^_VariableMask + _IndirectMask!

instanceSpecWithNullTerminatedBytes
	"Private - Answer an instance spec to represent instances with no named instances variables,
	made of indexable bytes and terminated by an extra byte initialized to null."

	^_VariableMask + _NullTermMask!

instanceSpecWithVariableBytes: anInteger
	"Private - Answer an instance spec based on anInteger but adjusted to represent instances
	with no named instances variables and made of indexable bytes."

	^_VariableMask
		bitOr: (anInteger bitAnd: _NullTermMask + _IndirectMask)!

instanceSpecWithVariablePointers: anInteger
	"Private - Answer an instance spec based on anInteger but adjusted to represent instances
	containing indexable pointers with or without named instance vars."

	^_VariableMask + _PointersMask
		bitOr: (anInteger bitAnd: _SizeMask)!

instSizeOf: aClass
	"Private - Answer the fixed size of aClass or zero if it is nil."

	^aClass isNil
		ifTrue: [0]
		ifFalse: [aClass instSize]!

invalidRemoveError
	"Answer the <exceptionSelector> that can be used to catch <Exception>s raised by the receiver
	when some error occurs removing a class, for example as a result of errors occuring while
	uninitializing the class or because it has extant instances or subclasses. The exceptions are resumable 
	(i.e. #resume: is a valid handler response, and allows the handler to ignore the exception and 
	forcibly remove the class)."

	^ClassRemovalError!

isFixedLayout: aClass 
	"Answer whether the <Class> argument is of fixed layout (i.e. its
	collection of instance variables cannot be changed in any way)."

	^aClass isBytes or: 
			[(FixedLayout anySatisfy: [:cls | cls includesBehavior: aClass]) 
				or: [FixedInitialLayout anySatisfy: [:cls | cls inheritsFrom: aClass]]]!

isValidClassName: aString 
	"Private - Answer whether aString is a valid class name."

	^(self isValidIdentifier: aString) and: [aString first == $_ or: [aString first isUppercase]]!

isValidIdentifier: aString 
	(aString isEmpty or: [self isValidInitialIdentifierChar: aString first]) ifFalse: [^false].
	2 to: aString size do: [:i | (self isValidIdentifierChar: (aString at: i)) ifFalse: [^false]].
	^(##(Set withAll: #('self' 'super' 'nil' 'true' 'false' 'thisContext' '_')) includes: aString) not!

isValidIdentifierChar: aCharacter 
	^(self isValidInitialIdentifierChar: aCharacter) or: [aCharacter isDigit]!

isValidInitialIdentifierChar: aCharacter 
	^aCharacter == $_ or: [aCharacter isLetter]!

moveClass: aClass toSuperclass: aSuperclass
	"Move aClass to be subclassed from aSuperclass."

	self new
		class: aClass;
		superclass: aSuperclass;
		modifyExistingClass
!

new
	"Answer a new initialized instance."

	^super new initialize!

parser
	"Private - Answer the parser to use for identifier validation."

	^Compiler!

removeClass: aClass 
	"Remove aClass."

	self removeClass: aClass ignoreInstances: false!

removeClass: aClass ignoreInstances: aBoolean 
	(self new)
		class: aClass;
		ignoreInstances: aBoolean;
		remove!

renameClass: aClass to: aString
	"Rename aClass to aString."

	self new
		class: aClass;
		className: aString;
		rename
!

validateClassVarName: aString using: aCollection 
	"Private - Ensure that the proposed class variable name is not a
	reserved word and does not duplicate a name defined in aCollecton."

	(self isValidIdentifier: aString) 
		ifFalse: [self error: 'Proposed class variable ''' , aString , ''' is invalid as a local identifier.'].
	(aCollection includes: aString) 
		ifTrue: [self error: 'Proposed class variable ''' , aString , ''' is multiply defined.'].
	aString first isUppercase 
		ifFalse: 
			[aString first == $_ 
				ifTrue: 
					[^Smalltalk at: #SmalltalkSystem
						ifPresent: 
							[:c | 
							c current isOAD 
								ifFalse: 
									[Warning signal: 'Identifiers beginning with an underscore, such as ' , aString 
												, ', are reserved for system use']]].
			Warning 
				signal: 'Proposed class variable ''' , aString , ''' should start with an uppercase letter.']!

validateClassVars: classVarsArray againstSuperclass: aClass
	"Private - Ensure that the proposed class variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass chain.
	Answer a Set of the existing and proposed class vars of the class and its
	superclasses."

	| classVarSet |
	classVarSet := (self allClassVarNamesOf: aClass) asSet.
	classVarsArray do: [:classVar |
		self validateClassVarName: classVar using: classVarSet.
		classVarSet add: classVar].
	^classVarSet
!

validateInstanceSpec: anInstanceSpec size: anInteger superclass: proposedSuperclass
	"Private - Validate the proposed instance spec, fixed size and superclass
	and answer a completed instance spec."

	| spec fundamentalType fixedSize |
	spec := anInstanceSpec bitAnd: _SizeMask bitInvert.
	fundamentalType := self fundamentalTypeOf: spec.
	fundamentalType = _VariableMask
		ifTrue: [spec := self validateSpecAsVariableBytes: spec size: anInteger superclass: proposedSuperclass].
	fundamentalType = _PointersMask
		ifTrue: [spec := self validateSpecAsFixedPointers: spec size: anInteger superclass: proposedSuperclass].
	fundamentalType = (_VariableMask + _PointersMask)
		ifTrue: [spec := self validateSpecAsVariablePointers: spec size: anInteger superclass: proposedSuperclass].
	fixedSize := anInteger + (self instSizeOf: proposedSuperclass).
	fixedSize > _SizeMask
		ifTrue: [	self error: 'Classes are allowed a maximum of ', _SizeMask displayString, ' instance variables.'].
	^spec bitOr: fixedSize!

validateInstanceVars: instVarsArray againstSuperclass: aClass
	"Private - Ensure that the proposed instance variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass chain.
	Answer a Set of the existing and proposed inst vars of the class and its
	superclasses."

	| instVarSet |
	instVarSet := (self allInstVarNamesOf: aClass) asSet.
	instVarsArray do: [:instVar |
		self validateInstVarName: instVar using: instVarSet.
		instVarSet add: instVar].
	^instVarSet
!

validateInstVarName: aString using: aCollection 
	"Private - Ensure that the proposed instance variable name is not a
	reserved word and does not duplicate a name defined in aColecton."

	(self isValidIdentifier: aString) 
		ifFalse: 
			[self error: 'Proposed instance variable ''' , aString , ''' is invalid as a local identifier.'].
	(aCollection includes: aString) 
		ifTrue: [self error: 'Proposed instance variable ''' , aString , ''' is multiply defined.']!

validateSpecAsFixedPointers: spec size: anInteger superclass: proposedSuperclass
	"Private - Answer a validated instance spec. Signal an exception if spec is
	invalid as a fixed size pointer subclass of proposedSuperclass."

	proposedSuperclass notNil
		ifTrue: [
			proposedSuperclass isBytes
				ifTrue: [self validateSpecAsVariablePointers: spec size: anInteger superclass: proposedSuperclass].
			proposedSuperclass isVariable
				ifTrue: [self error: 'Subclasses of an indexed class must also be indexed.']].
	^spec
!

validateSpecAsVariableBytes: spec size: anInteger superclass: proposedSuperclass
	"Private - Answer a validated instance spec possibly containing indirect or
	nullTerminated bits inherited from the proposedSuperclass. Signal an exception
	if spec is invalid as a variable byte subclass of proposedSuperclass."

	| inheritedFlags validatedSpec |
	inheritedFlags := _IndirectMask + _NullTermMask.
	validatedSpec := spec.
	proposedSuperclass notNil
		ifTrue: [
			proposedSuperclass instSize > 0
				ifTrue: [self error: 'A byte subclass may not derive from a class containing named instance variables'].
			(proposedSuperclass isPointers and: [proposedSuperclass isVariable])
				ifTrue: [self error: 'A byte subclass may not derive from a class containing indexed instance variables'].
			validatedSpec := validatedSpec bitOr: (inheritedFlags bitAnd: proposedSuperclass instanceSpec)].

	(validatedSpec allMask: inheritedFlags)
		ifTrue: [self error: 'A byte subclass may not be both indirect and null-terminated.'].
	anInteger > 0
		ifTrue: [self error: 'A byte subclass may not contain named instance variables.'].
	^validatedSpec!

validateSpecAsVariablePointers: spec size: anInteger superclass: proposedSuperclass
	"Private - Answer a validated instance spec. Signal an exception if spec is
	invalid as a variable subclass of proposedSuperclass."

	(proposedSuperclass notNil and: [proposedSuperclass isBytes])
		ifTrue: [self error: 'A subclass containing pointers may not derive from a class containing bytes.'].
	(spec anyMask: _IndirectMask)
		ifTrue: [self error: 'Indirect subclasses must contain bytes.'].
	(spec anyMask: _NullTermMask)
		ifTrue: [self error: 'Null-terminated subclasses must contain bytes.'].
	^spec! !

!ClassBuilder methodsFor!

beBytes
	"Private - Set the class type to variable bytes."

	instanceSpec := self class instanceSpecWithVariableBytes: instanceSpec!

beFixed
	"Private - Set the class type to pointers containing named instance vars only."

	instanceSpec := self class instanceSpecWithFixedPointers: instanceSpec!

beIndirectBytes
	"Private - Set the class type to indirect bytes."

	instanceSpec := self class instanceSpecWithIndirectBytes!

beNullTerminatedBytes
	"Private - Set the class type to null-terminated variable bytes."

	instanceSpec := self class instanceSpecWithNullTerminatedBytes!

beVariable
	"Private - Set the class type to indexable pointers and named instance vars."

	instanceSpec := self class instanceSpecWithVariablePointers: instanceSpec!

canMutateInSitu
	"Private - Answer whether the class being modified can be changed without
	mutating its instances. Class only mutation is possible providing that the
	following remain unchanged:
		the instance spec,
		the instance variable layout and
		the class instance variable layout."

	self instanceShapeIsBeingChanged
		ifTrue: [^false].
	self superclassIsBeingChanged
		ifFalse: [^self instanceVariablesAreBeingChanged not].

	"The class is being moved."
	(self class allInstVarNamesOf: superclass),instanceVariables = currentClass allInstVarNames
		ifFalse: [^false].
	(self class classOf: superclass) allInstVarNames = currentClass class superclass allInstVarNames
		ifFalse: [^false].

	^true.

	!

categories
	categories isNil ifTrue: [self categoryNames: #('')].
	^categories!

categories: aCollectionOfClassCategories
	categories := aCollectionOfClassCategories!

categoryNames: aCollectionOfStrings
	self categories: (self classCategoryClass isNil 
				ifTrue: [#()]
				ifFalse: 
					[aCollectionOfStrings collect: [:each | self classCategoryClass name: each]])!

checkNoInstances
	| instCount |
	self ignoreInstances ifTrue: [^self].
	"Try first without a full GC to avoid hit if we can"
	instCount := currentClass primAllInstances size.
	instCount > 0 
		ifTrue: 
			["Seem to be a few hangers on, so try with a GC"
			instCount := currentClass instanceCount].
	instCount > 0 
		ifTrue: 
			["Oh dear still extant instances - raise an error"
			self errorInvalidRemove: ((String writeStream)
						print: self currentClass;
						nextPutAll: ' has ';
						display: instCount;
						nextPutAll: ' instances';
						contents)]!

checkNoSubclasses
	| subs |
	subs := currentClass subclasses.
	subs notEmpty 
		ifTrue: 
			[self errorInvalidRemove: ((String writeStream)
						print: self currentClass;
						nextPutAll: ' has ';
						display: subs size;
						nextPutAll: ' subclasses';
						contents)]!

class: aClass
	"Private - Set the currentClass inst var to the class to be modified, aClass."

	currentClass := aClass.
	self instanceSpec: aClass instanceSpec.!

classCategoryClass
	^(superclass ifNil: [superclass class]) classCategoryClass!

className: aString
	"Private - Set the className inst var to aString."

	className := aString!

classVariables
	"Private - Answer an Array of proposed class variable names."

	^classVariables ifNil: [Array new]!

classVariables: aClassVarNamesArray
	"Set the receiver's classVariables inst var to aClassVarNamesArray."

	classVariables := aClassVarNamesArray asArray!

classVariableString: aClassVarNamesString
	"Set the receiver's proposed class variable list from aString."

	self classVariables: aClassVarNamesString subStrings!

comment: aString
	"Private - Set the comment to apply to the class being modified."

	comment := aString!

createNewClass
	"Private - Create, install and answer a new class from the
	details contained in the receiver."

	self
		validateForCreate;
		createProper;
		install: currentClass;
		setNewClassCategories;
		generateGUID;
		notifyClassCreated.
	^currentClass!

createPrivate
	"Private - Create and answer a new class from the details contained
	in the receiver. The class is not included in its superclasses'
	subclasses collection nor is its name installed as a global."

	self
		validateForCreatePrivate;
		createProper.
	currentClass removeFromSuper.
	^currentClass!

createProper
	"Private - Create a new class from the details contained in the receiver.
	First, create an instance of Metaclass then send this new instance a #new
	message to create its single instance class. Save the answer in the
	receiver's currentClass inst var."

	| metaSuperclass newMetaclass |
	metaSuperclass := self class classOf: superclass.
	(newMetaclass := Metaclass new)
		methodDictionary: MethodDictionary new;
		instanceSpec: metaSuperclass instanceSpec;
		superclass: metaSuperclass.

	(currentClass := newMetaclass new)
		methodDictionary: MethodDictionary new;
		instanceSpec: instanceSpec;
		setName: className asSymbol;
		setSuperclass: superclass.
	
	"In order to sort the metaclass subclasses, we need the instance class name, so we
	leave addition to the superclass subclasses list until the instance class has been created."
	newMetaclass addToSuper.

	self
		setInstanceVariablesOf: currentClass;
		setClassVariablesOf: currentClass;
		setSharedPoolsOf: currentClass;
		setCommentOf: currentClass!

currentClass
	"Answer the currentClass inst var."

	^currentClass!

environment
	"Private - Answer the namespace environment for the class being modified."

	^self class environment!

errorInvalidRemove: messageText
	"Private - An error has occurred removing the receiver's current class. Raise an 
	appropriate exception."

	^self class invalidRemoveError
		signal: messageText
		with: self currentClass!

fundamentalTypeIsBeingChanged
	"Private - Answer whether the fundamental class type (ie. Pointers/Bytes, Indexed/Fixed)
	is being changed."

	^(self class fundamentalTypeOf: instanceSpec) ~~ (self class fundamentalTypeOf: currentClass instanceSpec)			!

generateGUID
	"Private - Generate a GUID for a new class and assign it to that class."

	currentClass setGuid: GUID newUnique!

generateInstanceSpecFor: aClass superclass: aSuperclass
	"Private - Answer an instance spec based on aClass, the information in the receiver
	and the proposed superclass aSuperclass."

	^aClass == currentClass
		ifTrue: [
			self class
				validateInstanceSpec: instanceSpec
				size: self instanceVariables size
				superclass: aSuperclass]
		ifFalse: [
			self class
				validateInstanceSpec: aClass instanceSpec
				size: aClass instVarNames size 
				superclass: aSuperclass].!

generateMapFrom: oldClass to: newClass
	"Private - Answer an array with an element corresponding to each named
	instance variables in newClass. The elements contain the index of the
	instance variable index of instances of oldClass that have the same
	name in newClass. If there is no match the element will be zero."

	| oldInstVarNamesArray |
	oldInstVarNamesArray := oldClass allInstVarNames.
	^newClass allInstVarNames collect: [:name | oldInstVarNamesArray indexOf: name]!

ignoreInstances
	"Private - Answer whether extant instances of a class should be ignored when validating it
	for removal."

	^flags allMask: IgnoreInstsMask!

ignoreInstances: aBoolean 
	"Private - Set whether extant instances of a class should be ignored when validating it
	for removal."

	flags := flags mask: IgnoreInstsMask set: aBoolean!

initialize
	"Private - Initialize the instance."

	instanceSpec := 0.
	self beFixed.
	flags := 0!

initializeCopy: aClassDescriptionCopy fromClass: aClass superclass: aSuperclass
	"Private - Adjust the invalid inst vars of aClassDescription. Its method
	dictionary should be a copy of that in aClass, its instanceSpec may
	require reconstruction, it should have no subclasses, it should be made
	a subclass of aSuperclass, it may require its instanceVariables inst var
	to be adjusted and should then be recompiled to correct any invalid
	references in the copied method dictionary.
	Answer the adjusted ClassDescription."

	| instSpec |
	instSpec := self generateInstanceSpecFor: aClass superclass: aSuperclass.
	aClassDescriptionCopy
		methodDictionary: aClass methodDictionary copy;
		instanceSpec: instSpec;
		subclasses: nil;
		superclass: aSuperclass;
		addToSuper.
	aClass == currentClass
		ifTrue: [self setInstanceVariablesOf: aClassDescriptionCopy].

	aClassDescriptionCopy compileAll.
	^aClassDescriptionCopy!

install: aClassDescription 
	"Private - Install aClassDescription into its environment."

	| binding env |
	aClassDescription requiresInstallation ifFalse: [^self].
	env := self environment.
	binding := env bindingFor: aClassDescription name.
	binding 
		ifNil: 
			[env at: aClassDescription name put: aClassDescription.
			binding := env bindingFor: aClassDescription name]
		ifNotNil: 
			[binding isImmutable: false.
			binding value: aClassDescription].
	binding isImmutable: true!

instanceShapeIsBeingChanged
	"Private - Answer whether the instance spec is being changed."

	^(instanceSpec bitAnd: _ShapeMask) ~= (currentClass instanceSpec bitAnd: _ShapeMask)
			!

instanceSpec: anInteger
	"Private - Set the instance specification flags of the receiver to anInteger."

	instanceSpec := anInteger!

instanceVariables
	"Private - Answer an Array of proposed instance variable names."

	^instanceVariables notNil
		ifTrue: [instanceVariables]
		ifFalse: [
			currentClass isNil
				ifTrue: [Array new]
				ifFalse: [currentClass instVarNames]]!

instanceVariables: anInstVarNamesArray
	"Set the receiver's instanceVariables inst var to anInstVarNamesArray."

	instanceVariables := anInstVarNamesArray!

instanceVariablesAreBeingChanged
	"Private - Answer whether the instance variable layout is changing."

	^instanceVariables notNil and: [instanceVariables ~= currentClass instVarNames]!

instanceVariableString
	"Private - Answer the receiver's proposed instance variable list as
	a space separated String."

	^self instanceVariables isEmpty
		ifTrue: [nil]
		ifFalse: [ | aStream |
			aStream := String writeStream: 32.
			instanceVariables 
					do: [:instVarName | aStream nextPutAll: instVarName]
					separatedBy: [aStream space].
			aStream contents]!

instanceVariableString: anInstVarNamesString
	"Set the receiver's proposed instance variable list from aString."

	self instanceVariables: anInstVarNamesString subStrings!

isFixedInitialLayout
	"Answer whether the class being modified has a fixed initial layout."

	^FixedInitialLayout includes: currentClass!

isFixedLayout
	"Answer whether the class being modified is of fixed layout."

	^self class isFixedLayout: currentClass!

isFixedType
	"Answer whether the class being modified can be changed to be
	different type of subclass."

	^self isFixedLayout or: [self isFixedInitialLayout]!

isModifyAction
	"Private - Answer true if the combination of information provided to
	the receiver suggests that this is a class modification operation."

	currentClass isNil
		ifTrue: [
			currentClass := self environment at: className ifAbsent: [^false].
			(currentClass isKindOf: Behavior)
				ifFalse: [
					currentClass := nil.
					^false]].
	^true!

modifyExistingClass
	"Private - Modify and answer an existing class using the details
	contained in the receiver.
	Implementation Note: If the receiver is attempting to modify itself, then
	any direct accesses to instance variables following mutation may fail (if
	the instance variable set is changed, the compiled methods in the stack
	will still be referring to the old inst. var offsets), therefore we must use 
	inst. var accessors."

	self
		validateForModify;
		modifyProper;
		notifyClassUpdated.
	^self currentClass!

modifyOrCreate
	"Ascertain and execute the appropriate action depending on which pieces
	of information have been provided.
	If this is a class modify action we take this opportunity to maintain
	its NullTerm and Indirect flags as these are not specified in the
	standard class definition methods and would otherwise be lost."

	^self isModifyAction
		ifFalse: [self createNewClass]
		ifTrue: [
			instanceSpec := instanceSpec maskSet: (currentClass instanceSpec 
											maskClear: _FundamentalShapeMask).
			(self class instanceSpecIsBytes: instanceSpec)
				ifFalse: [instanceSpec := instanceSpec maskClear: _BytesSubMask].
			self modifyExistingClass]!

modifyPrivate
	"Private - Modify and answer an existing class using the details
	in the receiver. The class is excluded from its superclasses'
	subclasses collection."

	self
		validateForModify;
		modifyProper.
	^self currentClass removeFromSuper; yourself!

modifyProper
	"Private - Modify an existing class using the details contained in the receiver.
	Implementation Note: If the receiver is attempting to modify itself, then
	any direct accesses to instance variables following mutation may fail (if
	the instance variable set is changed, the compiled methods in the stack
	will still be referring to the old inst. var offsets), therefore we must use 
	inst. var accessors."

	| current |
	self requiresMutation ifTrue: [
		self canMutateInSitu
			ifTrue: [self mutateInSitu]
			ifFalse: [self mutateToNewClass]].

	"After this point, must not access inst vars directly in case mutated the receiver."
	current := self currentClass.
	current isMeta ifFalse: [
		self
			setClassVariablesOf: current;
			setSharedPoolsOf: current;
			setCommentOf: current].

	self recompilationRequired ifTrue: [current recompileAll].

	self superclassIsBeingChanged ifTrue: [self removeUnimplementedProtocols]
!

mutateAllInstancesOf: oldClass toBeInstancesOf: newClass 
	"Private - Mutate all instances of oldClass to instances of newClass."

	| mappingArray |
	mappingArray := self generateMapFrom: oldClass to: newClass.
	oldClass primAllInstances do: 
			[:oldInst | 
			| newInst |
			newInst := self 
						translateInstance: oldInst
						intoANewInstanceOf: newClass
						via: mappingArray.
			"We need to manually move the special behavior as #become: does not"
			newInst setSpecialBehavior: (oldInst setSpecialBehavior: 0).
			oldInst become: newInst]!

mutateClass: oldClass toBeASubclassOf: newSuperclass 
	"Private - Create a new class with the appropriate features and mutate
	all instances of oldClass to new instances of the new class and then 
	recursively make the same change to the subclasses of aClass. Finally,
	remove the oldClass and if appropriate its metaclass from their
	respective superclasses and do a #oneWayBeome: on oldClass to newClass.
	Implementation Note: We must not access any instance variables after mutation, in case
	the receiver is being mutated and the inst. var offsets change."

	oldClass isMeta 
		ifTrue: 
			[| newClass |
			newClass := self newMetaclassLike: oldClass superclass: newSuperclass.
			self mutateAllInstancesOf: oldClass toBeInstancesOf: newClass.	"Mutate the instance class."
			self updateVMRegistryWith: newClass instanceClass.
			oldClass subclasses do: [:cls | self mutateClass: cls toBeASubclassOf: newClass].
			oldClass removeFromSuper.
			oldClass become: newClass.
			newClass oneWayBecome: oldClass]
		ifFalse: 
			[| newClass |
			newClass := self newClassLike: oldClass superclass: newSuperclass.
			self install: newClass.
			self mutateAllInstancesOf: oldClass toBeInstancesOf: newClass.
			oldClass subclasses do: [:cls | self mutateClass: cls toBeASubclassOf: newClass].
			oldClass class removeFromSuper.
			oldClass removeFromSuper.
			oldClass become: newClass.
			newClass oneWayBecome: oldClass.
			self updateVMRegistryWith: newClass]!

mutateInSitu
	"Private - Mutate the class being modified without mutating its instances.
	In fact, we only need to change the superclass."

	self superclassIsBeingChanged 
		ifTrue: 
			[currentClass class setSuperclass: (self class classOf: superclass).
			currentClass setSuperclass: superclass.
			self recompilationRequired: true]!

mutateToNewClass
	"Private - Set currentClass to a mutation of itself based on the information
	in the receiver. The instances of the new currentClass are mutations of the
	instances of the old currentClass."

	self mutateClass: currentClass toBeASubclassOf: superclass!

newClassLike: aClass superclass: aSuperclass
	"Private - Answer a new class based on aClass with superclass aSuperclass.
	First, create a new metaclass and it to create its new instance class
	(there can be only one). The data from the old metaclass and class is
	mapped across to the new ones."

	| newMeta mappingArray newInstanceClass |
	newMeta := self
		newMetaclassLike: aClass class
		superclass: (self class classOf: aSuperclass).
	mappingArray := self generateMapFrom: aClass class to: newMeta.
	newInstanceClass := self
		translateInstance: aClass
		intoANewInstanceOf: newMeta
		via: mappingArray.
	newMeta instanceClass: newInstanceClass.

	^self
		initializeCopy: newInstanceClass
		fromClass: aClass
		superclass: aSuperclass!

newMetaclassLike: aMetaclass superclass: metaSuperclass
	"Private - Answer a new metaclass based on aMetaclass with superclass metaSuperclass."

	^self
		initializeCopy: aMetaclass basicShallowCopy
		fromClass: aMetaclass
		superclass: metaSuperclass!

notifyClassCreated
	"Use the trigger mechanism to notify interested parties that a class has been added."

	self environment classAdded: currentClass!

notifyClassRenamed
	self notifyClassUpdated!

notifyClassUpdated
	"Private - Use the trigger mechanism to notify interested parties that a class has been renamed, 
	and mark all its immediate subclasses as changed since these will need to be filed
	out to record the change in their source definition."

	self environment classUpdated: self currentClass.
	self currentClass subclasses do: [:each | each isChanged: true]!

recompilationRequired
	"Private - Answer whether recompilation of a modified class is required."

	^flags allMask: RecompileMask!

recompilationRequired: aBoolean 
	flags := flags mask: RecompileMask set: aBoolean!

remove
	"Private - Remove currentClass completely from the system."

	"Unitialize the class if necessary"

	[currentClass uninitializeBeforeRemove] 
		on: self class invalidRemoveError
		do: [:x | x outer]
		on: Error
		do: 
			[:x | 
			"Here we take advantage of Smallalk's powerful  exception system to resignal 
			 any errors that occur as special resumable errors that can be resumed by the 
			 enclosing scope to go on and remove the class regardless."
			x resignalAs: ((self class invalidRemoveError new)
						originalError: x;
						messageText: 'Error uninitializing ' , currentClass name , ': ' , x description;
						tag: currentClass)].
	self validateForRemove.
	self environment removeClass: currentClass!

removeUnimplementedProtocols
	"Private - Remove any protocols of the modified class which are no longer fully implemented.
	This should only occur if the class has been moved in the hierarchy."

	| current |
	current := self currentClass.
	current protocols copy do: [:p |
		(current canUnderstandProtocol: p)
			ifFalse: [current removeProtocol: p]]!

rename
	"Private - Rename currentClass to className."

	self validateForRename.
	currentClass rename: className.
	self notifyClassRenamed!

requiresMutation
	"Private - Answer whether the class being modified needs to have its instances mutated.
	Mutation is required if any of the following aspects of the class are being changed:
		its superclass,
		its instance spec or
		its instance variables."

	^self superclassIsBeingChanged
		or: [self instanceShapeIsBeingChanged
		or: [self instanceVariablesAreBeingChanged]]!

setClassVariablesOf: aClass 
	"Private - Set class variables of aClass to those described by
	the receiver's classVariables inst var."

	(classVariables notNil and: [aClass setClassVarNames: self classVariables]) 
		ifTrue: [self recompilationRequired: true]!

setCommentOf: aClass
	"Private - Set the comment of aClass to the receiver's comment inst var unless it
	is nil in which case make no change."

	comment notNil
		ifTrue: [aClass comment: comment]!

setInstanceVariablesOf: aClass
	"Private - Set the instance variable layout of aClass to those described by
	the receiver's instanceVariables inst var."

	instanceVariables notNil
		ifTrue: [aClass instanceVariables: self instanceVariableString]!

setNewClassCategories
	currentClass classCategories: self categories!

setSharedPoolsOf: aClass 
	"Private - Set the shared pools of aClass to those described by
	the receiver's sharedPools inst var."

	sharedPools notNil 
		ifTrue: 
			[| oldPoolNameSet newPoolNameSet |
			oldPoolNameSet := aClass sharedPoolNames.
			aClass setSharedPoolNames: self sharedPools.
			newPoolNameSet := aClass sharedPoolNames.
			(oldPoolNameSet intersection: newPoolNameSet) size = oldPoolNameSet size 
				ifFalse: [self recompilationRequired: true]]!

sharedPools
	"Private - Answer an Array of proposed pool dictionary names."

	^sharedPools ifNil: [Array new]!

sharedPools: anArray
	"Set the receiver's sharedPools inst var to anArray."

	sharedPools := anArray asArray!

sharedPoolString: aString
	"Set the receiver's sharedPools from the pool name list aString.
	Silently drop names duplicated within the list."

	self sharedPools: aString subStrings asSet!

superclass: aClass
	"Private - Set the target superclass."

	superclass := aClass!

superclassIsBeingChanged
	"Private - Answer whether the a new superclass has been specified."

	^superclass ~= currentClass superclass
			!

translateInstance: oldInstance intoANewInstanceOf: newClass via: mappingArray 
	"Private - Answer a new instance of newClass initialised from the data
	in oldInstance via the mapping specified by mappingArray. The array
	contains as many elements as there are named instance variables in
	newClass and gives the instance variable index in oldInstance from
	which to copy the old inst var. If the element contains zero then
	the corresponding inst var in the new object should be left as nil."

	| newInstance |
	newClass isVariable 
		ifFalse: [newInstance := newClass basicNew]
		ifTrue: 
			[newInstance := newClass basicNew: oldInstance basicSize.
			1 to: oldInstance basicSize
				do: [:i | newInstance basicAt: i put: (oldInstance basicAt: i)]].
	1 to: newClass instSize
		do: 
			[:i | 
			| index |
			(index := mappingArray at: i) ~~ 0 
				ifTrue: [newInstance instVarAt: i put: (oldInstance instVarAt: index)]].
	^newInstance!

updateVMRegistryWith: aClass
	"Private - Ensure that if aClass is a VM registered class then the VM's
	entry is updated to the new class."

	| name |
	name := aClass name asSymbol.
	(VMLibrary registryKeys includesKey: name)
		ifTrue: [VMLibrary default registryAt: name put: aClass]!

validateClass
	"Private - Ensure that currentClass is a valid Behavior."

	currentClass isNil
		ifTrue: [self error: 'Class not found.'].
	(currentClass isKindOf: Behavior)
		ifFalse: [self error: 'Class must be a kind of Behavior.']
!

validateClassForRename
	"Private - Ensure that we are permitted to rename the class."

	self validateClass.
	((FixedLayout includes: currentClass) or: [FixedInitialLayout includes: currentClass])
		ifTrue: [self error: currentClass name, ' must not be renamed.'].!

validateClassInstanceVars
	"Private - Ensure that the proposed changes do not result in a duplicate name
	anywhere in the meta-superclass or meta-subclass chain."

	| instVarSet |
	instVarSet := self class
		validateInstanceVars: currentClass class instVarNames
		againstSuperclass: (self class classOf: superclass).
	currentClass class allSubclasses do: [:cls |
		cls instVarNames do: [:name | self class validateInstVarName: name using: instVarSet]]!

validateClassName
	"Private - Ensure that the proposed class name is valid."

	(self class isValidClassName: className)
		ifFalse: [self error: 'Invalid class name ', className]!

validateClassVarsForCreate
	"Private - Ensure that the proposed class variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass chain."

	classVariables notNil
		ifTrue: [
			self class
				validateClassVars: self classVariables
				againstSuperclass: superclass]!

validateClassVarsForModify
	"Private - Ensure that the proposed class variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass or subclass chain."

	| classVarSet |
	classVarSet := self class
		validateClassVars: self classVariables
		againstSuperclass: superclass.
	currentClass allSubclasses do: [:cls |
		cls classVarNames do: [:name | self class validateClassVarName: name using: classVarSet]]!

validateForCreate
	"Private - Ensure that the proposed class creation would result in a valid new class."

	self
		validateClassName;
		validateForCreatePrivate!

validateForCreatePrivate
	"Private - Ensure that the proposed class creation would result in a valid new class."

	self
		validateSuperclassIsSubclassable;
		validateSuperclassChainForCreate;
		validateInstanceSpec;
		validateInstanceVarsForCreate;
		validateClassVarsForCreate;
		validatePoolNames!

validateForModify
	"Private - Ensure that the proposed class modification would result in a valid class."

	self
		validateClass;
		validateSuperclassForModify;
		validateSuperclassChainForModify;
		validateInstanceSpecForModify;
		validateInstanceVarsForModify;
		validateSubclassInstanceSpecs.
	currentClass isMeta ifFalse: [
		self
			validateClassInstanceVars;
			validateClassVarsForModify;
			validatePoolNames]!

validateForRemove
	"Private - Ensure that the proposed class removal is valid. Invalid class removal errors may
	be raised, but these are resumable and the enclosing scope is permitted to catch and resume
	these errors if it wishes to attempt to remove the class regardless."

	self validateClass.
	self checkNoInstances.
	self checkNoSubclasses!

validateForRename
	"Private - Ensure that the proposed class rename is valid."

	self
		validateClassForRename;
		validateClassName.

	(self environment includesKey: className)
		ifTrue: [self error: className, ' already exists.']!

validateInstanceSpec
	"Private - Validate and complete the instanceSpec inst var."

	instanceSpec := self class
		validateInstanceSpec: instanceSpec
		size: self instanceVariables size
		superclass: superclass.!

validateInstanceSpecForModify
	"Private - Validate the instanceSpec for a class modification."

	self validateInstanceSpec.
	(self fundamentalTypeIsBeingChanged and: [currentClass isMeta not and: [self isFixedType]])
		ifTrue: [self error: 'You may not change the subclass type of ', currentClass name]
	!

validateInstanceVarsForCreate
	"Private - Ensure that the proposed instance variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass chain."

	self class
		validateInstanceVars: self instanceVariables
		againstSuperclass: superclass!

validateInstanceVarsForModify
	"Private - Ensure that the proposed instance variable name list does not
	contain a reserved word or a duplicate name defined either in the list
	itself or anywhere in the proposed superclass or subclass chain."

	| instVarSet proposedInstVarArray |
	proposedInstVarArray := self instanceVariables.
	instVarSet := self class validateInstanceVars: proposedInstVarArray againstSuperclass: superclass.
	currentClass isMeta 
		ifFalse: 
			[(self isFixedLayout and: [currentClass instVarNames ~= proposedInstVarArray]) 
				ifTrue: [self error: 'You must not change the instance variable layout of ' , currentClass name].
			(self isFixedInitialLayout and: [(proposedInstVarArray indexOfSubCollection: currentClass instVarNames) ~~ 1]) 
				ifTrue: [self error: 'New inst vars must come after those already in ' , currentClass name]].
	currentClass allSubclasses 
		do: [:cls | cls instVarNames do: [:name | self class validateInstVarName: name using: instVarSet]]!

validatePoolNames
	"Private - Ensure that the proposed pool dictionary names exists in the environment
	and warn if they don't start with an uppercase letter."

	self sharedPools do: 
			[:poolName | 
			| firstChar |
			self environment at: poolName
				ifAbsentPut: 
					[Warning 
						signal: ('Pool dictionary <1p> does not exist.<n>Proceed to create it as an empty constants pool.' 
								expandMacrosWith: poolName).
					PoolConstantsDictionary named: poolName].
			firstChar := poolName first.
			(firstChar isUppercase or: [firstChar == $_]) 
				ifFalse: 
					[Warning 
						signal: ('Pool dictionary <1p> should start with an uppercase letter.' expandMacrosWith: poolName)]]!

validateSubclassesOf: aClass againstInstanceSpec: instSpec 
	"Private - Ensure that if the proposed change to the instance spec of aClass
	is acceptable to all subclasses."

	| dummyClass |
	(dummyClass := Behavior new) instanceSpec: instSpec.
	aClass subclasses do: 
			[:cls | 
			| validatedInstSpec |
			validatedInstSpec := self class 
						validateInstanceSpec: cls instanceSpec
						size: cls instVarNames size
						superclass: dummyClass.
			(self class fundamentalTypeOf: validatedInstSpec) 
				= (self class fundamentalTypeOf: cls instanceSpec) 
					ifFalse: [self validateSubclassesOf: cls againstInstanceSpec: validatedInstSpec]]!

validateSubclassInstanceSpecs
	"Private - Ensure that the proposed class modification would not result in
	any of the subclasses becoming invalid."

	self validateSubclassesOf: currentClass againstInstanceSpec: instanceSpec!

validateSuperclassChainForCreate
	"Private - Ensure that the proposed superclass chain doesn't already include
	a class of the same name as the proposed class."

	superclass isNil ifTrue: [^self].
	(superclass withAllSuperclasses anySatisfy: [:each | each name = className]) 
		ifTrue: [self error: 'Class cannot be a subclass of itself']!

validateSuperclassChainForModify
	"Private - Ensure that the proposed superclass chain doesn't already include
	the current class"

	superclass isNil ifTrue: [^self].
	(superclass withAllSuperclasses anySatisfy: [:each | each == currentClass]) 
		ifTrue: [self error: 'Class cannot be a subclass of itself']!

validateSuperclassForModify
	"Private - Ensure that no circularity is introduced into the hierarchy and
	that the superclass of a metaclass is not changed directly."

	self superclassIsBeingChanged
		ifTrue: [
			currentClass isMeta
				ifTrue: [self error: 'It is invalid to directly change the superclass of a metaclass.'].
			self validateSuperclassIsSubclassable.
			(superclass notNil and: [superclass isKindOf: currentClass])
				ifTrue: [self error: superclass name, ' is a subclass of the class being changed.']].!

validateSuperclassIsSubclassable
	"Private - Ensure that the superclass is a subclassable object."

	superclass notNil
		ifTrue: [
			((superclass isKindOf: Class) not or: [Unsubclassable includes: superclass])
				ifTrue: [self error: 'Proposed superclass is not subclassable.']].! !

Collection comment:
''!
!Collection class methodsFor!

defaultSortAlgorithmClass
	"Answer the class of <PluggableSortAlgorithm> to be used by default in conjunction with a
	user-defined sort block."

	^DefaultSortAlgorithm!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables."

	AbsentCookie := Object new
!

with: element1
	"Answer an instance of the receiver containing the <Object>, element1.
	Implementation Note: The #yourself is definitely required here."

	^self new
		add: element1; 
		yourself!

with: element1 with: element2
	"Answer an instance of the receiver containing each of the <Object>
	arguments as its elements"

	^(self new: 2)
		add: element1; 
		add: element2; 
		yourself!

with: element1 with: element2 with: element3
	"Answer an instance of the receiver containing each of the <Object>
	arguments as its elements."

	^(self new: 3)
		add: element1; 
		add: element2; 
		add: element3; 
		yourself!

with: element1 with: element2 with: element3 with: element4
	"Answer an instance of the receiver containing each of the <Object>
	arguments as its elements."

	^(self new: 4)
		add: element1; 
		add: element2; 
		add: element3; 
		add: element4; 
		yourself!

with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject
	"Answer an instance of the receiver containing the arguments as its elements"

	^self new
		add: firstObject; 
		add: secondObject; 
		add: thirdObject;
		add: fourthObject; 
		add: fifthObject; 
		yourself
!

withAll: newElements
	"Answer a new instance of the receiver containing all of the 
	elements of the <collection>, newElements."

	^(self new: newElements size)
		addAll: newElements;
		yourself! !

!Collection methodsFor!

_beginsString: aString
	^aString basicBeginsWith: self!

add: newElement
	"Include the <Object> argument, newElement, as one of the receiver's 
	elements. Answer newElement."

	^self subclassResponsibility!

addAll: newElements
	"Include all the elements of the <collection> argument, newElements, as the receiver's elements. 
	Answer newElements. 
	Note that this modifies the and answers the receiver, not a copy.
	newElements can actually be any object which understands #do:."

	newElements do: [:each | self add: each].
	^newElements!

allSatisfy: discriminator
	"Answer whether the <monadicValuable>, discriminator, evaluates to true for
	every element of the receiver.
	Implementation Note: The argument is evaluated for every element
	of the receiver iff it is satisfied for every element."

	self do: [:e | (discriminator value: e) ifFalse: [^false]].
	^true!

anyOne
	"Answer an arbitrary element of the collection. Raise an error if the collection is empty."

	self do: [:each | ^each].
	^self error: 'collection is empty'!

anySatisfy: discriminator
	"Answer whether the <monadicValuable>, discriminator, evaluates to true for
	any element of the receiver.
	Implementation Note: The argument is evaluated for every element of the
	receiver iff it evaluates to false for every element."

	self do: [:e | (discriminator value: e) ifTrue: [^true]].
	^false!

appendToStream: puttableStream
	"Private - Append the receiver's elements to the argument, puttableStream.
	Answer the receiver.
	Implementation note: Double dispatched from puttableStream>>nextPutAll:."

	self do: [ :element | puttableStream nextPut: element ]!

approxSize
	"Private - Answer the approximate size of the receiver.
	Implementation Note: This does not have to be accurate, but it should be fast
	(i.e. don't calculate it by counting the receiver's elements).
	The default is to guess at 2. Subclasses which can give a more
	accurate size quickly will get better conversion performance."

	^2!

asArray
	"Answer an <Array> whose elements are those of the receiver.
	The ordering is that of the #do: operation as implemented by the receiver,
	and the answer will normally be the same size as the receiver."

	| answer i |
	answer := Array new: self size.
	i := 1.
	self do: 
			[:each | 
			answer at: i put: each.
			i := i + 1].
	^answer!

asBag
	"Answer a <Bag> containing the same elements as the receiver
	Note: As Bags identify multiple occurrences with the equality relationship
	the enumerated elements of the result may not be identical to those of
	the receiver, although there will be the same number.
	Implementation Note: It is an error if the receiver contains nil elements,
	but this is not currently trapped."

	^(Bag new: self approxSize) 
		addAll: self; 
		yourself!

asByteArray
	"Answer a <ByteArray> whose elements are those of the receiver.
	The ordering is that of the #do: operation as implemented by the receiver,
	and the answer will normally be the same size as the receiver.
	This will fail if the receiver contains elements which are not Integers
	in the range 0..255."

	| anArray i |
	anArray := ByteArray new: self size.
	i := 1.
	self do: 
			[:each | 
			anArray basicAt: i put: each.
			i := i + 1].
	^anArray!

asIdentitySet
	"Answer a new <IdentitySet> whose elements are those stored in the receiver.
	Any duplicates are eliminated, so the result may be smaller than
	the receiver. Any nil elements of the receiver are also eliminated."

	^(IdentitySet new: self approxSize) 
		addAll: self; 
		yourself!

asOrderedCollection
	"Answer an <OrderedCollection> whose elements are those of the receiver
	The ordering is that of the #do: operation as implemented by the receiver,
	and the answer will normally be the same size as the receiver.
	Implementation Note: Although we might be able to perform this operation 
	faster for collections which keep a tally of their size (or can otherwise 
	access it without calculation) we must be careful NOT to provide a default 
	implementation which will cause a double enumeration for collections which must
	count their elements to determine their size, which may be very slow."

	| answer |
	answer := OrderedCollection new: self approxSize.
	self do: [:elem | answer addLast: elem].
	^answer!

asSet
	"Answer a <Set> whose elements are those stored in the receiver.
	Any duplicates are eliminated, so the result may be smaller than
	the receiver. Any nil elements of the receiver are also eliminated,
	but this behaviour may differ between implementations, and so
	should not be relied upon in portable code."

	^(Set new: self approxSize) 
		addAll: self; 
		yourself!

asSortedCollection
	"Answer a <SortedCollection> of the same size as the receiver
	whose elements are those of the receiver, with the order of the result
	being determined by the default sort block (see SortedCollection).
	Exceptions may occur if any of the elements of the receiver are not
	appropriate parameters for the default sort block."

	^(SortedCollection new: self approxSize)
		addAll: self; 
		yourself!

asSortedCollection: aDyadicValuable 
	"Answer a <SortedCollection> whose elements are those of the receiver, sorted according to 
	the <dynadicValuable> argument, sortBlock.
	Exceptions may occur if any of the elements of the receiver are not
	appropriate parameters for sortBlock.
	Note: The argument does not need to be a BlockClosure, it must simply
	understand the #value:value: message from the dyadic valuable protocol."

	^self asSortedCollectionUsing: (self class defaultSortAlgorithmClass sortBlock: aDyadicValuable)!

asSortedCollectionUsing: aSortAlgorithm 
	"Answer a <SortedCollection> whose elements are those of the receiver, sorted using the
	<SortAlgorithm> argument. Exceptions may occur if any of the elements of the receiver are
	not appropriate parameters for the aSortAlgorithm's sortBlock."

	^(SortedCollection new: self approxSize)
		setSortAlgorithm: aSortAlgorithm;
		addAll: self;
		yourself!

collect: transformer
	"Evaluate the <monadicValuable> argument, transformer, for each of the 
	receiver's elements in the order defined by the receiver's implementation of #do:.
	Answer a new collection like the receiver (i.e. of the same #species but not 
	necessarily the exact same class - since the collection may hold a different objects,
	it may need to be of a different type, hence the #species /#copyLike mechanism) 
	containing the values returned by transformer on each evaluation."

	| answer |
	answer := self copyLike.
	self do: [:each | answer add: (transformer value: each)].
	^answer!

copyEmpty
	"Answer an empty copy of the receiver (which must be of the exact same class
	not just the same #species), with enough capacity for the same number of elements.
	#copyEmpty can be useful when you wish to take a copy of a collection that
	preserves all of the collections attributes (including the capacity) apart from its 
	elements."

	^self copyEmpty: self copySize!

copyEmpty: anInteger
	"Private - Answer an empty copy of the receiver (which should be of the exact same class
	not just the same #species), with sufficient capacity for anInteger number of elements."

	"N.B. Must be reimplemented by subclasses that need to copy additional instance 
	variables (e.g. the sortBlock of SortedCollection)."

	^self class new: anInteger!

copyLike
	"Private - Answer an empty collection of the same species as the receiver with 
	sufficient capacity for anInteger number of elements."

	^self copyLike: self copySize!

copyLike: anInteger
	"Private - Answer an empty collection of the same species of the receiver with 
	sufficient capacity for anInteger number of elements."

	^self species new: anInteger!

copySize
	"Private - Answer the size of empty copy to create when performing various
	copying/collecting transformations against the receiver. Can be overridden
	by subclasses for which #size is a slow operation."

	^self size!

copyWithoutDuplicates
	"Answers a copy of the receiver that contains no duplicate objects. 
	Uses equality for comparison."

	| newCollection |
	newCollection := self copyEmpty.
	self asSet do: [ :each | newCollection add: each ].
	^newCollection!

countElements
	"Private - Count, and answer, the number of elements in the receiver.
	Implementation Note: Could be implemented more elegantly with #inject:into:, but
	this implementation is about twice as fast."

	| tally |
	tally := 0.
	self do: [ :each | tally := tally + 1].
	^tally!

detect: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements
	in the order defined by the receiver's implementation of #do:.
	Answer the first element for which discriminator evaluates to true. If none evaluates to true,
	report an error."

	^self detect: discriminator ifNone: [self errorNotFound: discriminator]!

detect: discriminator ifNone: exceptionHandler
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's 
	elements.  Answer the first element (in the #do: order) for which discriminator evaluates 
	to true. If none evaluates to true answer the result of evaluating the <niladicValuable> 
	argument, exceptionHandler.
	Implementation Note: It is important for Shared subclasses that the exceptionHandler is 
	not evaluated inside the enumeration in case it is a niladic block containing an explicit 
	return (we try to avoid explicit returns from critical sections, as these require an unwind)."

	self do: [:each | (discriminator value: each) ifTrue: [^each]].
	^exceptionHandler value!

difference: comperand
	"Answer a <collection> like the receiver containing the Set theroetic 
	difference between the receiver and the <collection>, comperand. 
	i.e. Answer the set of all objects that are elements of the receiver 
	but not the argument."

	^self reject: [:e | comperand includes: e]!

do: operation
	"Evaluate the <monadicValuable> argument, operation, for each of the 
	receiver's elements.
	The exact visit ordering is unspecified at this level, but this message must be
	implemented by subclasses (as it provides much of the enumeration behaviour 
	of Collections), and those implementations are free to define any appropriate
	ordering."

	^self subclassResponsibility!

do: operation separatedBy: separator 
	"Evaluate the <monadicValuable> argument, operation, for each of the 
	receiver's elements, interspersed with evaluations of the <niladicValuable>
	argument, separator. The separator is first evaluated after the first
	element, and is not evaluated after the last element (i.e. it is not evaluated
	at all if there are less than two elements)."

	| sep |
	sep := [sep := separator].	"Switch to the real separator after first eval."
	self do: 
			[:each | 
			sep value.
			operation value: each]!

errorEmptyCollection
	^self error: 'empty collection'!

errorNotKeyed
	"Private - Generate an error to the effect that the receiver is not a keyed Collection"

	^self error: self class name, 's do not respond to keyed accessing messages'
!

fold: aDyadicValuable 
	"Evaluate the <dyadicValuable> argument, operation, across the elements of the receiver
	starting with the first two elements. For subsequent evaluations the first argument to the
	block is the result of the previous evaluation, and the second argument is the next element.
	The order of the elements is as defined by the #do: operation. Answer the result of the
	final evaluation. It is an error for the collection to be empty. Should the collection
	contain only one element, then answer that element."

	| answer operation |
	answer := nil.
	operation := 
			[:a :first | 
			operation := aDyadicValuable.
			first].
	self do: [:each | answer := operation value: answer value: each].
	^operation == aDyadicValuable ifTrue: [answer] ifFalse: [self errorEmptyCollection]!

growSize
	"Private - Answer the number of elements by which the receiver should grow, when growing!!
	(at least 2, in case the receiver is currently empty)"

	^self size max: 2!

identityIncludes: anObject 
	"Answer whether the argument, anObject, is one of the receiver's elements."

	self do: [:each | anObject == each ifTrue: [^true]].
	^false!

includes: target
	"Answer whether the <Object> argument, target, is one of the elements of the receiver.
	Implementation Note: The default is to use equality for comparison."

	self do: [:each | target = each ifTrue: [^true]].
	^false!

inject: initialValue into: operation
	"Evaluate the <dyadicValuable> argument, operation, once for each element in the receiver, with
	that element as the second argument; and with the first argument as the value of the previous 
	evaluation, starting with the <Object> argument, initialValue. The operation must answer the value
	it wishes to have passed as its first argument the next time it is evaluated. The traversal is in the #do: 
	order. Answer the final value of the operation.
	This enumeration is particularly useful for performing summations and other statistical operations."

	| nextValue |
	nextValue := initialValue.
	self do: [:each | nextValue := operation value: nextValue value: each].
	^nextValue!

intersection: comperand
	"Answer a new <collection>, like the receiver, that is the intersection of the 
	receiver and the <collection>, comperand, i.e. answer the set of all objects
	which are elements of both the receiver and the argument."

	^self select: [ :element | comperand includes: element ]!

isEmpty
	"Answer whether the receiver contains no elements."

	^self size == 0
!

maxPrint
	"Private - Answer the maximum number of characters to be printed onto a stream as 
	the string representation of the receiver."

	^3000
!

newSelection
	"Private - Answer a new empty collection like the receiver to 
	contain a selection of the receiver's elements."

	^self species new!

noDifference: aCollection 
	"Answer whether the receiver contains the same elements as the <collection> argument
	(i.e. the symmetric difference is empty)."

	aCollection == self ifTrue: [^true].
	aCollection size = self size ifFalse: [^false].
	^(self symmetricDifference: aCollection) isEmpty!

notEmpty
	"Answer whether the receiver contains any elements."

	^self isEmpty not!

occurrencesOf: target
	"Answer the <integer> number of the receiver's elements which are 
	equal to the <Object> argument, target."

	| count |
	count := 0.
	self do: [:each | target = each ifTrue: [count := count + 1]].
	^count!

printCyclicRefOn: aStream
	"Private - Append to the argument, aStream, a String whose characters describe
	a cyclic (or recursive) reference to the receiver. Used by some
	printOn: methods (e.g. see Collection) to prevent an infinite recursion."

	aStream nextPutAll: '... a cyclic ref to '.
	self basicPrintOn: aStream.
	aStream nextPutAll: '...'!

printOn: aStream
	"Print a string representation of self on aStream. This method suffices for 
	most collections, and is able to handle cyclic references."

	| printed |
	printed := Processor activeProcess _alreadyPrinted.
	(printed includes: self) ifTrue: [^self printCyclicRefOn: aStream].
	printed add: self.
	
	[| tooMany |
	tooMany := aStream position + self maxPrint.
	self printPrefixOn: aStream.
	self do: 
			[:each | 
			aStream position > tooMany 
				ifTrue: 
					[aStream nextPutAll: '... etc ...'.
					^self].
			each printOn: aStream]
		separatedBy: [aStream space].
	self printSuffixOn: aStream] 
			ensure: [printed remove: self ifAbsent: []]!

printPrefixOn: aStream
	"Private - Print a prefix string for the debug representation of the receiver on aStream."

	aStream
		basicPrint: self;
		nextPut: $(!

printSuffixOn: aStream
	"Private - Print a suffix string for the debug representation of the receiver on aStream."

	aStream nextPut: $)!

rehash
	"Rehash the receiver to re-establish hash invariants, if any.
	The default is to do nothing, but this selector is present at this level, as any
	subclass could potentially be implemented as a hashed collection." !

reject: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements.
	Answer a new <collection> like the receiver containing only those elements for which 
	the discriminator evaluates to false."

	^self select: [:elem | (discriminator value: elem) == false]!

remove: oldElement 
	"Remove the <Object> argument, oldElement, from the receiver's elements.
	Answer oldElement unless it is not an element of the receiver, in which 
	case, raise a suitable exception."

	| removed |
	removed := self remove: oldElement ifAbsent: [AbsentCookie].
	^removed == AbsentCookie ifTrue: [self errorNotFound: oldElement] ifFalse: [removed]!

remove: oldElement ifAbsent: exceptionHandler
	"Remove the <Object> argument, oldElement, from the receiver's elements.  
	If several of the elements are equal to anObject, only one is removed (precisely 
	which is determined by the the subclass).
	If no element is equal to oldElement, answer the result of evaluating the <niladicValuable>
	exceptionHandler. Otherwise, answer oldElement. 
	Must be implemented by subclasses which comply with <extensibleCollection>."

	^self subclassResponsibility!

removeAll: oldElements
	"Remove each element of the <collection>, oldElements, from the receiver, raising
	an Exception if any are not elements of the receiver. Answer oldElements."

	oldElements do: [:each | self remove: each].
	^oldElements!

select: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements.
	Answer a new <collection> like the receiver containing only those elements for which 
	the discriminator evaluates to true."

	| newCollection |
	newCollection := self newSelection.
	self 
		do: [:each | (discriminator value: each) ifTrue: [newCollection add: each]].
	^newCollection!

select: discriminator thenCollect: transformer
	"Answer a new <collection> like the receiver containing the values returned by 
	the <monadicValuable>, transformer, when evaluated for each of the receiver's 
	elements for which the <monadicValuable>, discriminator, evaluates to true."

	^(self select: discriminator) collect: transformer!

size
	"Answer the <integer> number of elements in the receiver.
	Implementation Note: This implementation is rather inefficient, 
	and subclasses will probably want to override it."

	^self countElements!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	| first |
	aStream nextPutAll: '(('.
	self class storeOn: aStream.
	aStream nextPutAll: ' new)'.
	first := true.
	self do: [:value |
		first
			ifTrue: [first := false]
			ifFalse: [aStream nextPut: $;].
		aStream nextPutAll: ' add: '.
		value storeOn: aStream].
	first ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)!

symmetricDifference: comperand
	"Answer a <collection> like the receiver containing the symmetric
	difference of the receiver and the <collection>, comperand. 
	i.e. Answer the set of all objects that are elements of the receiver 
	or the argument, but not both."

	^(self union: comperand) difference: (self intersection: comperand)!

union: comperand
	"Answer a <Set> that is the union of the elements of receiver and 
	the <collection>, comperand. i.e. Answer the set of all objects that
	are elements of the receiver or the argument, or both."

	^(Set withAll: self)
		addAll: comperand;
		yourself
! !

CompilationResult comment:
''!
!CompilationResult methodsFor!

buildTempsMap
	tempsMap := OrderedCollection new: rawTempsMap size.
	rawTempsMap do: 
			[:each | 
			| startIP stopIP temps |
			startIP := each at: 1.
			stopIP := each at: 2.
			temps := each at: 3.
			tempsMap addLast: (startIP to: stopIP) -> temps].
	"Discard the raw temps map built by the compiler to save space"
	rawTempsMap := nil!

buildTextMap
	| sz |
	sz := rawTextMap basicSize.
	textMap := OrderedCollection new: sz // 3.
	1 to: sz
		by: 3
		do: [:i | textMap add: (rawTextMap at: i) -> ((rawTextMap at: i + 1) to: (rawTextMap at: i + 2))].
	"Discard the raw text map built by the compiler to save space"
	rawTextMap := nil!

fireSystemUpdateEvent
	self method methodClass environment 
		trigger: (self isNew ifTrue: [#methodAdded:] ifFalse: [#methodUpdated:])
		with: self!

isNew
	^oldMethod isNil!

method
	"Answer the method resulting from a compilation, or nil if the compilation failed
	or the compilation was for the purpose of syntax checking only."

	^method!

method: aCompiledMethod
	"Private - Set the method."

	method := aCompiledMethod!

oldMethod
	^oldMethod!

oldMethod: aCompiledMethod
	oldMethod := aCompiledMethod!

package
	^package!

package: aPackage
	package := aPackage!

rawTempsMap: anObject
	rawTempsMap := anObject!

rawTextMap: anObject
	rawTextMap := anObject!

tempsAtIp: ip 
	| found |
	self tempsMap keysAndValuesDo: 
			[:i :each | 
			| range |
			range := each key.
			(range includes: ip) ifTrue: [found := each value]].
	^found ifNil: [Array new]!

tempsMap
	"Answer the map of ip ranges to temporaries if such was requested (if not, then nil).
	The map is an array of associations between IP positions and the temporaries which
	are in scope at that point up to the next entry in the map."

	tempsMap isNil ifTrue: [self buildTempsMap].
	^tempsMap!

textMap
	"Answer the map of ip's to source code ranges if such was requested (if not, then nil)."

	textMap isNil ifTrue: [self buildTextMap].
	^textMap! !

CompiledCode comment:
'CompiledCode is the class of executable objects containing an array of instructions (bytecodes) and an array of literals (the literal frame).

The method header of the receiver is a SmallInteger containing a set of flags containing information such as the number of arguments, the number of temporaries, etc, is layed out as follows (subject to change):

	Bits:	Use:
	0	SmallInteger flag (not visible in Smalltalk)
	1	Private flag
	2..7	0 for no context, otherwise context Temp count + 1, so up to 63 context temps supported. 
	8..15	Stack Temp count	(i.e. maximum of 256 temps)
	16..23	Arg count		(i.e. maximum of 256 args)
	24..31	Primitive index

Primitive indices 0 thru 8 describe the method type as follows:
	0	Normal method requiring activation
	1	Return self
	2	Return true
	3	Return false
	4	Return nil
	5	Return literal zero
	6	Return an instance variable (see the bytecodes to determine which)
	7	Set an instance variable
	8	Reserved for future use.

Note: These are implementation details, and should not be relied upon as they may be changed in future versions.'!
!CompiledCode class methodsFor!

elementsExpired: anInteger of: infoCacheKeys
	"Private - Some instances of the receiver with entries in the debug info cache were
	GC'd, so clean out any corresponding debug info from the cache."

	InfoCacheKeys nilCorpsesAndDo: [:i | InfoCacheValues at: i put: nil]!

initialize
	"Private - Initialize the class variables of the receiver.

		CompiledCode initialize
	"

	PrivateMask := 16r1.
	self initializeInfoCache!

initializeInfoCache
	"Private - Initialize the cache of method information used for debugging.
		CompiledCode initializeInfoCache
	"

	self initializeInfoCache: 100!

initializeInfoCache: capacity 
	"Private - Initialize the cache of method information used for debugging to the
	specified capacity."

	| primeSize |
	InfoCacheKeys isNil ifFalse: [InfoCacheKeys pathologist: nil].
	primeSize := Set sizeFor: capacity.
	InfoCacheKeys := MourningWeakArray new: primeSize.
	InfoCacheKeys pathologist: self.
	InfoCacheValues := Array new: primeSize!

onPreStripImage
	"Private - Clear away the cache of method information used for debugging."

	InfoCacheKeys pathologist: nil.
	InfoCacheKeys := InfoCacheValues := nil! !

!CompiledCode methodsFor!

= aMethod 
	"Answer whether the argument, aMethod, is considered exactly equivalent to 
	the receiver.
	Two CompiledMethods are considered equal iff they are of the same class
	(we can't compare non-CompiledMethods), they have the same selector, and
	the same byte codes and literal frame."

	| count |
	self == aMethod ifTrue: [^true].
	(self class == aMethod class and: 
			[self methodClass == aMethod methodClass 
				and: [self selector = aMethod selector and: [self byteCodes = aMethod byteCodes]]]) 
		ifFalse: [^false].
	count := self literalCount.
	aMethod literalCount = count ifFalse: [^false].
	"We need to special case static blocks in the literal frame to avoid infinite recursion"
	1 to: count
		do: 
			[:i | 
			| a b |
			a := self at: i.
			b := aMethod at: i.
			"The static blocks must be equal if they are implemented by this method and
			the bytecodes and all other literals are identical"
			(a class == BlockClosure and: [a method == self]) 
				ifTrue: [(b class == BlockClosure and: [b method == aMethod]) ifFalse: [^false]]
				ifFalse: [a = b ifFalse: [^false]]].
	^true!

accessesInstVar: instVarName
	"Answer whether the receiver accesses the named instance variable in its method class."

	^self accessesInstVar: instVarName at: (self methodClass indexOfInstVar: instVarName)!

accessesInstVar: aString at: anInteger 
	"Answer whether the receiver accesses the instance variable named, aString, which
	is the instance variable of its method class with the specified <integer> index."

	^(self extraIndex between: 1 and: 5) not 
		and: [self byteCodeDispatcher accessesInstVarAt: anInteger]!

allLiteralsDo: operation 
	"Answer an array of the literals in the receiver."

	"Implementation Note: As Dolphin does not have separate methods for blocks (to save space), this is the
	same as #literalsDo:, but we inline it for speed"

	1 to: self literalCount do: [:i | operation value: (self at: i)]!

allSymbolLiterals
	"Answer a  <collection> of all the symbols referred to from the literal
	frame of this method, either directly or embedded in arrays. Special
	selectors (i.e. those encoded in the bytecodes) are also included."

	| messages |
	messages := IdentitySet new: 6.
	self allSymbolLiteralsDo: [:symbol | messages add: symbol].
	^messages addAll: self specialMessages; yourself!

allSymbolLiteralsDo: operation 
	"Private - Evaluate the <monadicValuable>, operation, for each of the literal symbols 
	in the receiver's literal frame, including those embedded in arrays."

	self literalReferencesDo: [:each | each class == Symbol ifTrue: [operation value: each]]!

argumentCount
	"Answer the number of arguments expected by the receiver.
	This method is part of the ANSI <valuable> protocol, but CompiledCode
	does not conform to the whole protocol."

	^(header bitShift: -15) bitAnd: 255!

argumentCount: anInteger 
	"Private - Set the number of arguments expected by the receiver."

	header := (header bitAnd: ##((255 << 15) bitInvert)) 
				bitOr: ((anInteger bitAnd: 255) bitShift: 15)!

byteCodeDispatcher
	"Private - Answer a <ByteCodeDispatcher> on the receiver."

	^self byteCodeDispatcherClass on: self!

byteCodeDispatcherClass
	"Private - Answer the class to be used for dispatching the receiver's bytecodes."

	^ByteCodeDispatcher!

byteCodes
	"Private - Answer the byte codes (a ByteArray) for the receiver"

	| bytes remaining size firstByte |
	self isPacked ifFalse: [^byteCodes].
	"This code is slightly more complex than needed, but avoids LargeInteger arithmetic for
	speed. It assumes there is at least one bytecode (which there must be)."
	firstByte := ((byteCodes bitAnd: 16r7F) bitShift: 1) bitOr: 1.
	remaining := byteCodes bitShift: -7.
	remaining == 0 ifTrue: [^ByteArray with: firstByte].
	size := remaining digitLength + 1.
	bytes := ByteArray new: size.
	bytes at: 1 put: firstByte.
	2 to: size
		do: 
			[:i | 
			bytes at: i put: (remaining bitAnd: 16rFF).
			remaining := remaining bitShift: -8].
	^bytes!

byteCodes: anObject 
	"Private - Set the value of the receiver's ''byteCodes'' instance variable to the argument,
	anObject. anObject must be either a ByteArray, or a SmallInteger containing the packed
	representation of the bytecodes. If a ByteArray is passed that is suitable for packing (it
	must be for 4 bytecodes or fewer and the first must be odd) then it is stored in the packed
	format."

	| codes |
	codes := (anObject isInteger or: [anObject size > 4 or: [anObject first even]]) 
				ifTrue: [anObject]
				ifFalse: 
					[| packed |
					codes := (anObject size == 4 
								ifTrue: [anObject sdwordAtOffset: 0]
								ifFalse: 
									[packed := 0.
									anObject reverseDo: [:each | packed := (packed bitShift: 8) + each].
									packed]) 
									bitShift: -1.
					self assert: [codes class == SmallInteger].
					codes].
	codes isImmutable: true.
	byteCodes := codes!

byteCodeSegments
	^self byteCodeDispatcher byteCodeSegments!

clear
	"Private - Clear down temporary information cached in the receiver.
	The default is to do nothing."!

compilerClass
	"Private - Answer the class of compiler to be used for compiling instances of the receiver."

	^methodClass compilerClass!

containsSource: aString 
	"Answer whether the receiver contains the specified source string."

	| src |
	src := self getSource.
	^src notNil and: [(src findString: aString) ~~ 0]!

debugInfo
	"Private - Answer a compilation result containing a recompilation of the receiver, a
	map between IP ranges and expressions in the source, and a map between IP ranges
	and an OrderedCollection of Associations between IP positions and temporaries 
	up to that position in the receiver, ordered by IP."

	| i method |
	i := self identityHash \\ InfoCacheKeys size + 1.
	method := InfoCacheKeys at: i.
	(method isNil or: [method == DeadObject current or: [method ~~ self]]) 
		ifTrue: 
			[| info |
			info := self getDebugInfo.
			"			method := info method.
			method isNil 
				ifFalse: 
					[method
						selector: self selector;
						sourceDescriptor: self sourceDescriptor]."
			info method: nil.
			InfoCacheKeys at: i put: self.
			InfoCacheValues at: i put: info].
	^InfoCacheValues at: i!

envInfo
	^(header bitShift: -1) bitAnd: 63!

envTempCount
	"Answer the number of environment temporaries used by the receiver."

	| info |
	info := self envInfo.
	^info == 0 ifTrue: [0] ifFalse: [info - 1]!

evaluationPools
	"Answer the evaluation pools used when compiling the receiver."

	^#()!

extraIndex
	"Private - Answer the 'extra' index of the receiver. This is the primitive index
	See class comment for further details."

	^(header bitShift: -23) bitAnd: 255!

getDebugInfo
	"Private - Invoke the compiler to answer a compilation result containing a 
	recompilation of the receiver, a map between IP ranges and expressions 
	in the source, and a map between IP ranges and an <OrderedCollection> of 
	<Association>s between IP positions and temporaries up to that position in 
	the receiver, ordered by IP."

	^self subclassResponsibility!

getSource
	"Answer the source of the receiver.
	This task is delegated to the SourceManager."

	^self subclassResponsibility!

hash
	"Answer the <SmallInteger> hash value for the receiver. We use only the selector at the moment."

	^(selector hash bitShift: 4) bitXor: methodClass hash!

header
	^header!

header: aSmallInteger 
	header := aSmallInteger!

isCompilationFailure
	^false!

isDebugMethod
	"Private - Answer whether the receiver is a debug method."

	"Implementation Note: There is no longer a header flag for this, so we must search for break bytecodes."

	| size i |
	self isPacked ifTrue: [^false].
	size := byteCodes size.
	i := 1.
	[i > size] whileFalse: 
			[(byteCodes at: i) == Break ifTrue: [^true].
			i := i + (ByteCodeDispatcher lengthOfInstruction: (byteCodes at: i))].
	^false!

isExpression
	"Private - Answer whether the receiver is a standalone (unbound) expression as opposed to 
	a method."

	^self subclassResponsibility!

isOverride
	"Answer whether the receiver is overriding a method in a superclass."

	^false!

isPacked
	"Private - Answer whether the receiver's byte codes are packed into SmallIntegers
	rather than being stored in a separate Byte Array"
	
	^byteCodes class == SmallInteger!

isPrimitive
	^self primitiveIndex ~= 0!

isPrivate
	"Private - Answer whether the receiver is a debug method."

	^header anyMask: PrivateMask!

isPrivate: aBoolean 
	"Private - Set whether the receiver is a private method."

	self whileMutableDo: [header := header mask: PrivateMask set: aBoolean]!

isPublic
	"Private - Answer whether the receiver is a public method."

	^self isPrivate not!

isUnbound
	"Answer whether the receiver is unbound (i.e. not linked into a class' method dictionary).
	Only CompiledMethod subinstances can be bound."

	^true!

literalArray: literalArray do: operation 
	"Private - Evaluate the <monadicValuable>, operation, for each of the elements of
	the <Array>, literalArray, recursively drilling down into any embedded arrays too.
	Note that it is a pre-order traversal."

	literalArray do: 
			[:literal | 
			operation value: literal.
			(literal class == Array and: [literal isImmutable]) 
				ifTrue: [self literalArray: literal do: operation]]!

literalAt: anInteger 
	"Private - Answer the literal at the specified one-based <integer> index."

	"Implementation Note: Compiled methods are standard pointer objects in Dolphin, with the
	literal frame stored in the indexable part, therefore #at: and #literalAt: are synonms."

	^self at: anInteger!

literalAt: anInteger put: aValue
	"Private - Replace the literal of the receiver at index, anInteger, with aValue."

	self at: anInteger put: aValue!

literalCount
	"Private - Answer the number of literals contained in the literal frame of the receiver (0..255)"

	^self size!

literalReferencesDo: operation 
	"Private - Evaluate the <monadicValuable>, operation, for each of the literals of the
	receiver, and each of the elements of any Array literals recursing down through any
	intermediate literal arrays."

	1 to: self literalCount
		do: 
			[:i | 
			| each |
			each := self at: i.
			operation value: each.
			(each class == Array and: [each isImmutable]) ifTrue: [self literalArray: each do: operation]]!

literals
	"Private - Answer an array of the literals in the receiver."

	| count |
	count := self literalCount.
	^(Array new: count)
		replaceFrom: 1 to: count with: self startingAt: 1!

literalsDetect: discriminator ifNone: exceptionHandler
	"Evaluate the <monadicValuable> argument, discriminator, for each of the 
	objects in the receiver's literal frame. If the literal is an <Array>, then 
	the discriminator is also evaluated for each of its elements. The first matching
	element, at the top level or embedded in an array, is answered. If no matching
	element is found, then the result of evaluating the <niladicValuable>, exceptionHandler,
	is answered."

	self literalsDo: [:literal | 
		(discriminator value: literal) ifTrue: [^literal].
		literal class == Array ifTrue: [literal do: [:e | (discriminator value: e) ifTrue: [^e]]]].
	^exceptionHandler value!

literalsDo: operation 
	"Private - Evaluate the monadic valuable, operation, for each of the receivers
	literals."

	1 to: self literalCount do: [:i | operation value: (self at: i)]!

localCount
	"Private - Answer the total number of stack temporaries (including arguments) used by the receiver."

	^self argumentCount + self stackTempCount!

messages
	"Answer the set of messages sent by the receiver."

	| answer |
	answer := IdentitySet new: 10.
	self messagesDo: [:sel | answer add: sel].
	^answer!

messagesDo: aBlock 
	"Evaluate the <monadicValuable> argument, aBlock, for each of the messages 
	actually sent by the receiver, including any special selectors."

	(MessageSendCollector dispatcher: self byteCodeDispatcher) messagesDo: aBlock!

methodClass
	"Answer the Class to which this method belongs (as opposed to the class of CompiledMethods)"

	^methodClass
!

methodClass: aClass
	"Private - Set the class to which the method belongs (i.e. that class for which it 
	implements part of the protocol) to aClass"

	(aClass isKindOf: Behavior) ifFalse: [ ^self error: 'Must be class' ].
	methodClass := aClass!

needsContext
	"Private - Answer whether the receiver needs a context to be allocated for it when it
	is activated. The context is needed to hold shared, closed-over, variables, and/or to
	support ^-returns from blocks. 
	Note that if a method answers true to #needsContext, but its #envTempCount is zero,
	then that implies that it contains a far return in a nested block. To eliminate the
	requirement for a context (perhaps for efficient reasons), it will be necessary to
	refactor the method to remove the far return, perhaps. by relocating it so that it is
	ouside a block. For example:
		(aCollection at: aKey ifAbsent: [^self]) blahBlah
	Could be written without the far return as:
		(aCollection at: aKey ifAbsent: []) ifNotNil: [:aValue | aValue blah blah]"

	^self envInfo - 1 >= 0!

owningPackage
	^self subclassResponsibility!

primitiveIndex
	"Private - Answer the primitive index of the method, or zero if none"

	| idx |
	^(idx := self extraIndex) > 8
		ifTrue: [idx]
		ifFalse: [0]!

readsInstVar: instVarName
	"Answer whether the receiver reads the named instance variable in its method class."

	^self readsInstVar: instVarName
		at: (self methodClass indexOfInstVar: instVarName)!

readsInstVar: aString at: anInteger 
	"Answer whether the receiver accesses the instance variable named, aString, which
	is the instance variable of its method class with the specified <integer> index."

	| extra |
	extra := self extraIndex.
	^((extra between: 1 and: 5) or: [extra == 7]) not 
		and: [self byteCodeDispatcher readsInstVarAt: anInteger]!

refersToLiteral: anObject 
	"Private - Answer whether the receiver refers directly from its literal frame (or indirectly as an 
	element of an array in the literal frame) to the argument, anObject. Named for compatibility 
	with VisualWorks."

	"Implementation Note: This deliberately does not take account of special selectors and is open
	coded for speed."

	1 to: self literalCount
		do: [:i | ((self at: i) refersToLiteral: anObject) ifTrue: [^true]].
	^false!

selector
	"Answer the message selector under which the receiver is entered in its class' method
	dictionary."

	^selector
!

selector: aSymbol
	"Private - Set the message selector under which the receiver is entered in its class' method
	dictionary."

	selector := aSymbol asSymbol!

sendsSelector: aSymbol 
	"Answer whether the receiver sends the specified selector. This is done by enumerating
	the byte codes, so simple references to the same symbol will not be counted."

	self messagesDo: [:sel | sel == aSymbol ifTrue: [^true]].
	^false!

sendsSpecialSelector: anInteger 
	"Answer whether the method which the receiver is interpreting sends the special
	selector with the specified index (one based)."

	^self byteCodeDispatcher sendsSpecialSelector: anInteger!

setByteCodes: anObject 
	byteCodes := anObject!

sourceDescriptor
	"Private - Answer the receiver's sourceDescriptor (an object, usually an Integer which
	describes the location of the receiver's source, but may be a String). The source descriptor
	is managed by the receiver's source manager, and is opaque to the receiver."

	^sourceDescriptor!

sourceDescriptor: anObject
	"Private - Set the receiver's source descriptor to anObject. This should normally only be
	sent by the receiver's source manager."

	self whileMutableDo: [sourceDescriptor := anObject]!

specialMessages
	"Private - Answer a Collection of all the special message selectors which
	the receiver sends."

	^self byteCodeDispatcher specialMessages!

stackTempCount
	"Private - Answer the number of stack temporaries (excluding arguments) used by the receiver."

	^(header bitShift: -7) bitAnd: 255!

stackTempCount: anInteger 
	"Private - Set the number of stack temporaries (excluding arguments) used by the receiver."

	header := (header bitAnd: ##((255 << 7) bitInvert)) 
				bitOr: ((anInteger bitAnd: 255) bitShift: 7)!

superMessages
	"Answer a <Set> of all the message selectors super-sent by this method."

	| answer |
	answer := IdentitySet new.
	(MessageSendCollector dispatcher: self byteCodeDispatcher) 
		superMessagesDo: [:each | answer add: each].
	^answer!

tempCount
	"Private - Answer the number of temporaries (local variables and arguments) of the receiver.
	This is the total number of temps, regardless of where allocated."

	^self localCount + self envTempCount!

tempsMap
	"Private - Answer a map between IP's and source ranges in the receiver."

	^self debugInfo tempsMap!

textMap
	"Private - Answer a map between IP's and source ranges in the receiver."

	^self debugInfo textMap!

value: anObject withArguments: anArray 
	"Evaluate the receiver with the argument, anObject, as its receiver, and with the argument,
	anArray, as the arguments to the message.

	Primitive failure reasons:
		0 -	anArray is not an Array
		1 -	anArray contains the wrong number of arguments
		2 -	anObject is not a subinstance of the method class of the receiver."

	<primitive: 116>
	^self primitiveFailed!

writesInstVar: instVarName
	"Answer whether the receiver assigns to the named instance variable in its method class."

	^self writesInstVar: instVarName
		at: (self methodClass indexOfInstVar: instVarName)!

writesInstVar: aString at: anInteger 
	"Answer whether the receiver accesses the instance variable named, aString, which
	is the instance variable of its method class with the specified <integer> index."

	^(self extraIndex between: 1 and: 6) not 
		and: [self byteCodeDispatcher writesInstVarAt: anInteger]! !

Compiler comment:
'The Compiler class is responsible for compiling new methods and evaluating expressions.'!
!Compiler class methodsFor!

compile: aString in: aClass 
	"Compile the String conversion of the argument code as a method of aClass.
	Answer the new method (which is not added to the method dictionary of
	aClass) if there are no syntax errors, otherwise signal a CompilerNotification."

	^(self 
		compile: aString
		in: aClass
		flags: aClass defaultCompilationFlags) method!

compile: aString in: aClass flags: anInteger 
	"Private - Compiler the method source, aString, in the context of the class, aClass,
	parameterized by the flags, anInteger, notifying, notifier, of any errors or warnings 
	which are detected. The flags can be combinations of the following:

	0	Default compilation to code. Method is first element of array
		if successful. If some syntax error occurs, then it will be nil.
	1	Reserved.
	2	Syntax Check only.
	4	Reserved.
	8	Turn off optimization
	16	Generate a textmap from ip to a text range as the third element of
		the array. The text map is an Array of Integers.
		Every three elements define one map. The first element in a map is the
		ip of the bytecode (1 based), and the two following elements define
		the start and stop of the text range (1 based) associated with the
		action of the bytecode.	
	32	Generate a temporaries map as the fourth element of the array
		The temporaries map is itself an Array. Every two elements of the 
		array refer to one mapping. A mapping has two elements, an ip and a
		String of temporaries that are valid at the ip. A mapping occurs for
		every time the temporaries list changes in the method. So the start of
		a Block with at least one argument will have an entry, the ending of
		it will also have an entry. Temporaries generated by the optimizer that
		may be ignore have an underscore as their first character. Optimizer
		temporaries are ignore when deciding that the temporaries list has
		changed. Mappings are not necessarily ordered by their ip. Two mappings
		may have the same ip in this case of an optimized empty block.
	64	Generate a debug version of the method which includes break points after
		every expression. Any text/temporaries map generated at the same time will
		account for the extra byte codes in the IP offsets.
	512	Interactive compile (compiler can prompt to define globals etc)
	1024	SendYourself. Don't optimize out #yourself
	"

	| results |
	results := CompilerLibrary default 
				compile: self
				source: aString asString
				in: aClass
				flags: anInteger
				notifying: self.
	^(CompilationResult new)
		method: results first;
		rawTextMap: results second;
		rawTempsMap: results third;
		yourself!

compileDebugExpression: aString in: aClass evaluationPools: anArray 
	"Compile the source text, aString, as if it were method of aClass inserting additional
	breakpoint bytecodes, etc, to make a debuggable method."

	^(self 
		compileForEvaluation: aString
		in: aClass
		evaluationPools: anArray
		logged: false
		flags: DebugMethod) method!

compileDebugMethod: aString in: aClass 
	"Compile the source text, aString, as if it were method of aClass inserting additional
	breakpoint bytecodes, etc, to make a debuggable method."

	^(self 
		compile: aString
		in: aClass
		flags: aClass defaultCompilationFlags | DebugMethod) method!

compileExpression: aString in: aClass 
	^self 
		compileExpression: aString
		in: aClass
		flags: aClass defaultCompilationFlags!

compileExpression: aString in: aClass flags: anInteger 
	^self 
		compileForEvaluation: aString
		in: aClass
		evaluationPools: nil
		logged: false
		flags: anInteger!

compileForEvaluation: aString in: aBehavior evaluationPools: anArray logged: aBoolean flags: anInteger 
	"Private - Compile the expression source, aString, in the context of the class, aBehavior,
	parameterized by the flags, anInteger, notifying, notifier, of any errors or warnings 
	which are detected. Additional shared variables are looked up in the <Array> of <PoolDictionary>,
	anArray. Answers an appropriately instantiated CompilationResult.

	The flags can be combinations of the following:

	0	Default compilation to code. Method is first element of array
		if successful. If some syntax error occurs, then it will be nil.
	1	Reserved.
	2	Syntax Check only. Does not generate a method.
	4	Reserved
	8	Turn off optimization
	16	Generate a textmap from ip to a text range as the third element of
		the array. The text map is an Array of Integers.
		Every three elements define one map. The first element in a map is the
		ip of the bytecode (1 based), and the two following elements define
		the start and stop of the text range (1 based) associated with the
		action of the bytecode.	
	32	Generate a temporaries map as the fourth element of the array
		The temporaries map is itself an Array. Every two elements of the 
		array refer to one mapping. A mapping has two elements, an ip and a
		String of temporaries that are valid at the ip. A mapping occurs for
		every time the temporaries list changes in the method. So the start of
		a Block with at least one argument will have an entry, the ending of
		it will also have an entry. Temporaries generated by the optimizer that
		may be ignore have an underscore as their first character. Optimizer
		temporaries are ignore when deciding that the temporaries list has
		changed. Mappings are not necessarily ordered by their ip. Two mappings
		may have the same ip in this case of an optimized empty block.
	64	Generate a debug version of the method which includes break points after
		every expression. Any text/temporaries map generated at the same time will
		account for the extra byte codes in the IP offsets."

	| results expression |
	results := CompilerLibrary default 
				compileForEvaluation: self
				source: aString
				in: aBehavior
				evaluationPools: anArray
				flags: anInteger
				notifying: self.
	results := (CompilationResult new)
				method: results first;
				rawTextMap: results second;
				rawTempsMap: results third;
				yourself.
	expression := results method.
	expression notNil 
		ifTrue: 
			[expression
				methodClass: aBehavior;
				storeSourceString: aString
					evaluationPools: anArray
					logged: aBoolean;
				isImmutable: true].
	^results!

compilerNotification: aCompilerNotification 
	"Private - Inform user of Compiler error/warning as detailed in the 
	<CompilerNotification> argument."

	^aCompilerNotification signal!

debugInfoFlags: aBoolean 
	^TextMap | TempsMap | (aBoolean ifTrue: [DebugMethod] ifFalse: [0])!

debugInfoFor: aString in: aClass debug: aBoolean 
	"Answers a CompilationResult with all the information necessary for debugging a method
	in aClass whose sources is aString."

	^self 
		compile: aString
		in: aClass
		flags: aClass defaultCompilationFlags | (self debugInfoFlags: aBoolean)!

debugInfoForExpression: aString in: aClass evaluationPools: pools debug: aBoolean 
	"Answers a CompilationResult with all the information necessary for debugging a method
	in aClass whose sources is aString."

	^self 
		compileForEvaluation: aString
		in: aClass
		evaluationPools: pools
		logged: false
		flags: (self debugInfoFlags: aBoolean)!

defaultFlags
	^DefaultFlags!

defaultFlags: anInteger 
	DefaultFlags := anInteger!

disableWarning: anInteger 
	"Disable the compiler warning with the specified code."

	DisabledWarnings add: anInteger!

enableWarning: anInteger 
	"Enable the compiler warning with the specified code."

	DisabledWarnings remove: anInteger ifAbsent: []!

errorClass
	^CompilerErrorNotification!

evaluate: aString
	"Compile and evaluate the expression, aString, in the context of
	UndefinedObject.  If the expression compiles, answer the result of 
	evaluating the expression with nil as the receiver.
	If the compilation fails, signal a CompilerNotification and answer nil. 
	The expression is not written to the change log."

	^self evaluate: aString logged: false!

evaluate: aString for: anObject evaluationPools: anArray logged: aBoolean 
	"Compile and evaluate the expression, aString, with anObject as the 
	receiver.  If the expression compiles, answer the result of evaluating 
	the expression. If the compilation fails, signal a CompilerNotification
	and answer nil. Log the expression to the change log as requested by 
	the argument aBoolean."

	^self 
		evaluate: aString
		for: anObject
		evaluationPools: anArray
		logged: aBoolean
		ifFail: []!

evaluate: aString for: anObject evaluationPools: anArray logged: aBoolean ifFail: failBlock 
	"Compile and evaluate the expression, aString, with anObject as the 
	receiver.  If the expression compiles, answer the result of evaluating 
	the expression. If the compilation fails, signal a CompilerNotification
	and answer nil. Log the expression to the change log as requested by 
	the argument aBoolean."

	| results expr |
	results := self 
				compileForEvaluation: aString
				in: anObject class
				evaluationPools: anArray
				logged: aBoolean
				flags: 0.
	expr := results method.
	^expr notNil 
		ifTrue: [expr value: anObject withArguments: Array new]
		ifFalse: [failBlock value]!

evaluate: aString for: anObject logged: aBoolean
	"Compile and evaluate the expression, aString, with anObject as the 
	receiver.  If the expression compiles, answer the result of evaluating 
	the expression. If the compilation fails, signal a CompilerNotification
	 and answer nil. Log the expression to the change log as requested by 
	the argument aBoolean."

	^self evaluate: aString for: anObject evaluationPools: nil logged: aBoolean!

evaluate: aString logged: aBoolean
	"Compile and evaluate the expression, aString, in the context of
	UndefinedObject, with nil as the receiver.  If the expression compiles,
	answer the result of evaluating the expression with nil as the receiver.
	If the compilation fails, signal a CompilerNotification and answer nil. 
	Log the expression to the change log as requested by the argument aBoolean."

	^self evaluate: aString for: nil logged: aBoolean!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

identifierFrom: aString
	"Answer a String which is an initial suggestion for a Smalltalk identifier based on aString.
	The answer is not guaranteed to be a valid identifier as it could be an empty String.

	Invalid characters are removed, the letter following a removed character is made uppercase
	unless it forms the first character of the identifier when it is made lowercase, all other
	letters are made lowercase."

	| identifier startNewWord i |
	identifier := String new: aString size.
	startNewWord := false.
	i := 1.
	aString do: [:c |
		((i == 1 and: [self isAValidInitialIdentifierChar: c]) or: [self isAValidIdentifierChar: c])
			ifFalse: [startNewWord := i > 1]
			ifTrue: [
				identifier at: i put: (startNewWord
					ifTrue: [c asUppercase]
					ifFalse: [c asLowercase]).
				startNewWord := false.
 				i := i+1]].
	^identifier trimNulls!

initialize
	"Private - Initialize the class variables of the receiver.

		Compiler initialize
	"

	DefaultFlags := 0.
	DisabledWarnings := Set new!

isAReservedWord: aString
	"Private - Answer whether aString is a reserved word."

	^self reservedWords includes: aString!

isAValidIdentifierChar: aCharacter
	"Private - Answer whether aCharacter is valid as the non-initial character in an identifier."

	^CRTLibrary default __iscsym: aCharacter!

isAValidInitialIdentifierChar: aCharacter
	"Private - Answer whether aCharacter is valid as the first character in an identifier."

	^CRTLibrary default __iscsymf: aCharacter!

isAValidLocalIdentifier: aString
	"Private - Answer whether aString is a valid local identifier."

	^(aString allSatisfy: [:c | self isAValidIdentifierChar: c]) and: [
		(self isAValidInitialIdentifierChar: aString first) and: [
			(self isAReservedWord: aString) not]]!

isValidSelector: aSymbol
	"Answer whether the <Symbol> argument is a valid selector (unary, binary or keyword)."

	^(Symbol isLiteralSymbol: aSymbol) and: [
		(self isAReservedWord: aSymbol asString) not]!

isWarningDisabled: anInteger 
	^anInteger >= CWarnFirst and: [DisabledWarnings includes: anInteger]!

notificationCallback: anArray 
	"Private - The receiver has generated an error while compiling, inform notifier of this.
	N.B. This is a callback from the Compiler, and should not be removed."

	"Array layout:
		1) <integer> Error code
		2) <integer> Line number
		3) <integer> Start of erroneous interval
		4) <integer> End of erroneous interval
		5) <integer> Offset of the start of the source code in the original source (0 unless compiling a static expression)
		6) <String> Source code
		7) <string> selector
		8) <behavior> Class in the context of which the compilation is taking place.
		9) The object to be notified.
		10) <Array> of <Object> representing extra information about the error."

	| errorCode offset sourceText lineNumber errorStart errorStop selector methodClass extras notified |
	errorCode := anArray first.
	(self isWarningDisabled: errorCode) ifTrue: [^true].
	lineNumber := anArray at: 2.
	errorStart := anArray at: 3.
	errorStop := anArray at: 4.
	"The offset must be added to the error range to get the actual interval in the source text"
	offset := anArray at: 5.
	sourceText := anArray at: 6.
	selector := anArray at: 7.
	methodClass := anArray at: 8.
	notified := anArray at: 9.
	extras := anArray at: 10 ifAbsent: [#()].
	^notified compilerNotification: ((self notificationClass 
				code: errorCode
				in: sourceText
				for: methodClass
				selector: selector
				position: errorStart + 1
				line: lineNumber
				range: (errorStart to: errorStop) + 1
				extras: extras)
				offset: offset;
				yourself)!

notificationClass
	^CompilerNotification!

reservedWords
	"Private - Answer the Set of reserved words."

	^##(Set withAll: #('self' 'super' 'nil' 'true' 'false' 'thisContext'))!

temporariesMapOf: aString in: aClass 
	"Answers a temporariesMap Array for aString when compiled
	as a method to be installed in aClass. The method is not installed
	into aClass or logged to the change log"

	^(self 
		compile: aString
		in: aClass
		flags: aClass defaultCompilationFlags | TempsMap) tempsMap!

textMapOf: aString in: aClass 
	"Answers a textMap Array for aString when compiled
	as a method to be installed in aClass. The method is not installed
	into aClass or logged to the change log"

	^(self 
		compile: aString
		in: aClass
		flags: aClass defaultCompilationFlags | TextMap) textMap!

uninitialize
	"Clean up VM references that are only required if the compiler is present."

	#(#notificationCallback: #sharedStaticPools #allInstVarNames #evaluate:for:evaluationPools: #bindingFor:) 
		do: [:each | VMLibrary default unregisterObject: each]!

warningClass
	^CompilerWarningNotification! !

Context comment:
''!
!Context methodsFor!

at: index
	"Answer the receiver's indexed instance variable at the argument index.
	As basicAt:, but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size)."

	<primitive: 49>
	^self errorAt: index!

at: index put: value
	"Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value.
	As basicAt:put: but may be reimplemented.

	Primitive Failure Reasons:
		0	- aSmallInteger is not a SmallInteger
		1	- aSmallInteger out of bounds (not in the range 1..receiver's indexable size) 
		2	- the argument, value, is not of a class which can be stored in the receiver
			(e.g. its a non-SmallInteger and the receiver is a ByteArray)."

	<primitive: 50>
	^self errorAt: index put: value!

block
	^block!

frameClass
	^block isNil ifTrue: [StackFrame] ifFalse: [BlockFrame]!

home
	^block isNil ifTrue: [self] ifFalse: [block home]!

outer
	^outer!

outer: anObject
	outer := anObject!

printOn: aStream 
	outer isInteger 
		ifTrue: 
			[outer isZero 
				ifTrue: [aStream nextPutAll: 'an expired ']
				ifFalse: [aStream nextPutAll: 'a method '].
			aStream display: self class name]
		ifFalse: 
			[aStream
				basicPrint: self;
				nextPutAll: ' for ';
				print: block]! !

DeadObject comment:
'DeadObject is a singleton whose sole instance is used to mark the slots previously occuppied by dead objects in objects with weak references. This class serves no other purpose than to provide a unique ''Corpse'' object which prints in a recognisable form.

N.B. It is not a good idea to create a new current DeadObject as this may break existing weak collection and/or confuse the VM.

Class Variables:
	Current	<DeadObject>. Singleton instance.


'!
!DeadObject class methodsFor!

current
	"Answer the singleton DeadObject."

	^Current!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables."

	Current isNil ifTrue: [Current := self new]!

removeFromSystem
	"Private - Remove the receiver completely from the system.
	This class is critical to system operation and must not be removed."

	^self shouldNotImplement! !

DeafObject comment:
'DeafObject is a singleton class whose sole instance is deaf to all requests - i.e. it appears to understand all messages, but takes no action except to answer itself. This ensures that the results of all message sends to the DeafObject are also deaf. DeafObject can be useful for avoiding a proliferation of #isNil tests.

N.B. DeafObject cannot be used to substitute for any object which has special significance to either the Compiler or the VM, a good example being <Boolean>s. The following expression will raise a ''Must be boolean'' error because it is not a true message send:

DeafObject current ifTrue: []

Class Variables:
	Current		<DeafObject>. Singleton instance.


'!
!DeafObject class methodsFor!

current
	"Answer the singleton <DeafObject>."

	^Current!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables."

	Current isNil ifTrue: [Current := self new]! !

!DeafObject methodsFor!

= comparand
	"Answer whether the receiver and the <Object>, comparand, 
	are considered equivalent (in whatever respect is appropriate for 
	the class of the receiver). All DeafObjects are considered equal."

	^self class = comparand class!

doesNotUnderstand: aMessage
	"The receiver is deaf to all requests. Answer self to ensure that
	our answers are also deaf."

	^self!

mustBeBoolean
	"Private - Sent to the receiver by the VM when an attempt was made to test it
	for its boolean status by a CompiledMethod.
	Note that it is normally necessary for implementors of #mustBeBoolean to return a
	boolean value, or not return at all. If a non-boolean value is returned, then it
	in turn will be sent a #mustBeBoolean message too. This could potentially continue 
	indefinitely, causing an unbreakable loop."

	^true! !

DeferredValue comment:
'A DeferredValue is a <niladicValuable> which is evaluated asynchronously in a background process, but which supplies its value synchronously on request, i.e. it blocks any sender of #value until the value is available.

Instances of DeferredValue are typically created by sending the #deferredValue (calculate in background process forked at same priority as active process) and #deferredValueAt: (calculate in a background process at the specified priority) messages, but there is a class side instance creation protocol (#evaluate:[|with|#with:with:|withArguments:]at: which can be used to defer the calculation of other valuables.

Note that if an exception occurs in the deferred operation it is raised in both the asynchronous process calculating the deferred value, AND any client processes (senders of #value). This is the default behaviour because the deferred value may never be requested, in which case the error would go undetected.

To suppress exceptions in the asynchronous process wrap the deferred operation in an exception trap which catches any <Error>s and answers them as the value of the operation. Any such suppressed <Error> will still be raised in the client process(es) requesting the deferred value, and of course these can be handled (or ignored) as normal. For example:

	[["...operation which might raise an error..."]
		on: Error do: [:e | e]] deferredValue

Alternatively create a subclass which overrides #_evaluate:withArguments: which includes such a generic error trap.'!
!DeferredValue class methodsFor!

evaluate: operation at: priority
	"Answer a <niladicValuable> that begins evaluating the <niladicValuable>, operation,
	asynchronously at the specified <integer> priority, and which when evaluated will 
	synchronously supply the result."

	^self	evaluate: operation withArguments: #() at: priority!

evaluate: operation with: arg1 at: priority
	"Answer a <niladicValuable> that begins evaluating the <monadicValuable>, operation,
	asynchronously at the specified <integer> priority, and which when evaluated will 
	synchronously supply the result."

	^self	
		evaluate: operation 
		withArguments: (Array with: arg1)
		at: priority!

evaluate: operation with: arg1 with: arg2 at: priority
	"Answer a <niladicValuable> that begins evaluating the <dyadicValuable>, operation,
	asynchronously at the specified <integer> priority, and which when evaluated will 
	synchronously supply the result."

	^self	
		evaluate: operation 
		withArguments: (Array with: arg1 with: arg2) 
		at: priority!

evaluate: operation withArguments: args at: priority
	"Answer a <niladicValuable> that begins evaluating the <valuable>, operation,
	asynchronously at the specified <integer> priority, and which when evaluated will 
	synchronously supply the result."

	^super new
		evaluate: operation withArguments: args at: priority!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	ValuePending := Object new!

new
	"Answer a instance of the receiver."

	^self shouldNotImplement! !

!DeferredValue methodsFor!

_evaluate: operation withArguments: args
	"Private - Evaluate the <valuable>, operation with the <Array> of arguments, args.
	The receiver becomes signalled when either the calculation completes, is terminated,
	or an exception occurs. This method can be overridden by subclasses if desired."
	
	^operation valueWithArguments: args!

deferredValue
	"Answer a <niladicValuable> that is evaluated asynchronously (i.e. the receiver)."

	^self!

deferredValueAt: priority
	"Answer a <niladicValuable> that is evaluated asynchronously at the specified priority.
	Implementation Note: The priority argument is ignored."

	^self!

evaluate: operation withArguments: args at: priority
	"Private - Answer a <niladicValuable> that begins evaluating the <valuable>, 
	operation with the <Array> of arguments, args, asynchronously at the specified 
	<integer> priority, and which when evaluated will synchronously supply the result. 
	This message must only be sent when the deferred value is first created."

	self initialize.
	[
		[self setValue: (self _evaluate: operation withArguments: args)]
			on: Error do: [ :e | self exception: e. e pass]
			on: ProcessTermination do: [:e |
				self exception: 
					(Error new 
						tag: self;
						messageText: 'DeferredValue terminated prematurely')]
	] forkAt: priority
!

exception: anError
	"Private - Record the <Error>, anError, as the unhandled exception which
	occurred when attempting to calculate the value of the receiver, but only
	if an exception has not already been recorded. This message must not be
	sent if #setValue: has been sent."

	exception isNil ifTrue: [
		self assert: [value == ValuePending].
		exception := anError. 
		value := nil.
		valueAvailable signal]!

hasValue
	"Answer whether the deferred value has been calculated yet."

	^value ~~ ValuePending!

initialize
	"Private - Initialize the receiver's instance variables."

	value := ValuePending.
	valueAvailable := Semaphore new!

setValue: result
	"Private - Set the deferred value, releasing any processes which are waiting
	for it.
	Implementation Note: An #isKindOf: test allows the deferred value block to 
	trap an exception to prevent  it being raised in the async. process, if desired, 
	and return it as the value so that it can be re-raised in client processes. We
	store the exception in a separate instance variable to avoid the necessity for
	an isKindOf test on every access to the value."

	(result isKindOf: Error) 
		ifTrue: [
			exception := result. 
			value := nil]
		ifFalse: [
			value := result].

	valueAvailable signal!

value
	"Answer the deferred value, blocking until it is available if necessary.
	If an exception occurred during the calculation of the value, or if it
	resulted in an <Error>, then that exception is re-raised now in the context
	of the calling process."

	valueAvailable wait; signal.
	exception == nil ifFalse: [exception copy signal].
	^value! !

Delay comment:
'<Delay>s are used to introduce timed pauses in the execution of a <Process>.  Delays can be constructed that specify a duration using the instance creation messages #forMilliseconds: and #forSeconds:, or an absolute time based on the millisecond clock value (#untilMilliseconds:). Once constructed a Delay responds to the #wait message by suspending the active process for the desired duration, or until the desired absolute time is reached. 

Delays are "one-shot" in that once they have expired further attempts to #wait on them will return immediately. This applies even if the Delay was originally constructed to wait for a time interval rather than an absolute time. Therefore if one wishes to delay a process in a loop, new Delay instances should be created as required inside the loop. It is often more convenient to use the ProcessorScheduler>>sleep: message, which wraps up the creation and wait operations inside a convenience message.

Delays are not hard real time, in that the requested delay is the minimum time period that will elapse before the process is restarted. The VM will make a best effort to reschedule the process after the desired delay by using the high-resolution multimedia clock (accurate to 1 millisecond) and high priority threads, but there may still be an arbitrary additional delay before the Process actually restarts depending on the load on the host machine and the relative priority of the Dolphin thread in relation to other OS threads, and the waiting Process in relation to other Processes. There is also some context switching and other processing overhead that will increase the average minimum Delay to a period greater than 1mS, though (depending on machine speed) it should be quite close. 

Example usage:
	5 timesRepeat: [(Delay forMilliseconds: 500) wait. Sound bell]

Instance Variables:
	duration		<integer> number of milliseconds to delay Process
	resumptionTime	<integer> value of millisecond clock at which to resume
	waitSemaphore	<Semaphore> on which to delay Process

Class Variables:
	AccessProtect	<Semaphore> protects the class variables in critical regions
	Current		<Delay> the next scheduled Delay (or nil if none)
	ImageClock	<integer> millisecond clock value on last image save - used to reschedule delays on image restart
	Pending		<SortedCollection> of waiting <Delay>s in ascending order of resumptionTime.
	Resolution	<integer> resolution of millisecond clock, minimum 1
	TimerMax		<integer> maximum delay recordable with the timing device.  Longer delays are achieved by repeatedly rescheduling until the desired period has elapsed.
	TimingProcess	<Process> responsible for waking up delayed processes on expiry of Delay
	TimingSemaphore	<Semaphore> Signalled by the VM at requested times, governing the operation of the TimingProcess.
'!
!Delay class methodsFor!

aboutToIdle
	"Private - The system is about to go idle.
	Answer the current millisecond clock value."

	self keepAlive!

cancelTimer
	"Private - Cancel any previously registered timer."

	Processor signal: nil afterMilliseconds: 0.
!

forkTimingProcess
	"Private - Start the timing process which manages instances of the receiver. The timing 
	Process runs at the highest, Timing, priority, to ensure that the signal gets through, regardless 
	of the priority of its waiting Process relative to the active Process when it fires.
	A separate timing Process is used with a single semaphore because the VM can maintain 
	only a single timer, and because this allows for better management of Delays."

	AccessProtect critical: [	
		self cancelTimer.
		TimingSemaphore isNil ifTrue: [self initializeTimingSemaphore].
		TimingProcess isNil ifFalse: [TimingProcess terminate].
		Current isNil ifFalse: [Current snooze].		"put current back into Pending"
		self scheduleNext.
	].
	TimingProcess := ([
		[
			TimingSemaphore wait.		"Wait for a timeout to be signalled by VM" 
			AccessProtect critical: [
				Current isNil ifFalse: [Current riseAndShine].
				self scheduleNext]] repeat.
	] forkAt: Processor timingPriority) name: 'Timing'; yourself!

forMilliseconds: millisecondCount
	"Answer a new instance of the receiver with a duration of millisecondCount seconds.
	The new instance has no effect on the progress of a Process until sent the 
	message #wait. 
	ou can now set a delay down to 1mS - e.g. try 
		[Processor sleep: 1] speed.
	However, if you sleep for such a short period in a tight loop, then you'll not leave
	much CPU time for other processes to run.
	"

	^self new duration: millisecondCount!

forSeconds: secondCount
	"Answer a new instance of the receiver with a duration of secondCount seconds.
	The new instance has no effect on the progress of a Process until sent the 
	message #wait. A Delay instantiated for a particular duration (as opposed to one
	instantiated for an absolute millisecond time) can be used repeatedly (i.e. the 
	#wait message can be sent to it more than once, though at any one time only one 
	Process can be waiting for a Delay)."

	^self forMilliseconds: secondCount*1000!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

initialize
	"Initialize the Class Variables of the receiver:
		Delay initialize
	"

	ImageClock := 0.
	Resolution := 1.
	TimerMax := 65535.
	AccessProtect isNil ifTrue: [AccessProtect := Semaphore forMutualExclusion].
	AccessProtect critical: 
			[Pending := SortedCollection 
						sortBlock: [:delay1 :delay2 | delay1 resumptionTime <= delay2 resumptionTime].
			Current := nil].
	TimingSemaphore isNil ifTrue: [self initializeTimingSemaphore]!

initializeTimingSemaphore
	"Private - Create the timing semaphore used for communication with the VM's
	timer services."

	TimingSemaphore := Semaphore new!

keepAlive
	"Private - Ensure that there is a timing process, and that it is in a runnable state."

	(TimingProcess isNil or: [TimingProcess suspendingList isNil])
		ifTrue: [
			Notification signal: 'Starting new timing process'.
			self forkTimingProcess]!

millisecondClockValue
	"Private - Answer the current millisecond clock value."

	<primitive: 174>
	^self primitiveFailed!

new
	"Answer a new, valid, Delay, but one which will fire immediately it receives #wait.
	See #forMilliseconds:, #forSeconds:, and #untilMilliseconds:"

	^super new initialize!

onExit
	"The system is closing down, release timer related resources."

	self cancelTimer!

onPreSaveImage
	"Private - The image is about to be saved. Store down the millisecond clock
	value so that we can reschedule Delays on restart."

	ImageClock := self millisecondClockValue!

onStartup
	"The system has just started. Initialize the timing system."

	| devCaps |
	"We don't bother detecting errors reported by the call, because it's too early to report them anyway"
	devCaps := ByteArray new: 8.
	WinMMLibrary default timeGetDevCaps: devCaps cbtc: devCaps size.
	Resolution := devCaps dwordAtOffset: 0.

	"Don't use the full range as its a bit unreliable on Windows 95.
	On NT4.0 this is fairly long duration anyway."
	TimerMax := (devCaps dwordAtOffset: 4) // 2.
	self keepAlive.
	self reschedule!

prod
	"Private - Give the timing process a poke to wake in case its time to rise and shine.
	You can send this message if Delays stop firing to see if they'll restart."

	TimingSemaphore signal!

reschedule
	"Private - Ensure that the next pending Delay, or the Current one, is correctly scheduled with 
	the VM. Called during startup to reschedule Delays based on the difference between the current
	millisecond clock, and that in place when the Delay was originally scheduled."

	AccessProtect critical: 
			[| delta |
			delta := self millisecondClockValue - ImageClock.
			Current isNil ifFalse: [Current snooze].	"put current back into Pending"
			Pending do: [:each | each delta: delta].
			self scheduleNext]!

resolution
	"Answer the resolution of Delays. This is the underlying resolution of the timing
	device. Dolphin will try to service delays of this period, but it may not be possible."

	^Resolution!

scheduleNext
	"Private - Schedule the next Pending Delay (if any). MUST be called from within
	a critical section managed by AccessProtect."

	Pending isEmpty 
		ifTrue: [Current := nil]
		ifFalse: [Pending removeFirst schedule]!

timingProcess
	"Private - Answer the <Process> which is used to manage the list of pending Delays."

	^TimingProcess!

untilMilliseconds: millisecondTime
	"Answer a new instance of the receiver that will make the active Process
	wait until the millisecond clock reaches the value millisecondTime."

	^self new resumptionTime: millisecondTime! !

!Delay methodsFor!

calcResumptionTime
	"Private - Calculate and answer the value of the millisecond clock after which any 
	Process waiting on the receiver will be rescheduled. We could lazily evaluate this
	from the normal accessor, but we want to ensure that scheduling Delays is as fast 
	as possible, and we also want to be able to control when the calculation is made, 
	as for relative durations (the most common case) we really want to calculate off 
	the clock just before the receiver is scheduled, certainly not before that."

	resumptionTime isNil ifTrue: [resumptionTime := self class millisecondClockValue + duration].
	^resumptionTime!

cancel
	"Cancel the receiver. Any Process waiting on the receiver, remains waiting (but see #resume),
	the receiver is simply removed from the collection of Delays managed by the TimingProcess."

	AccessProtect critical: [
		self == Current
			ifTrue: [
				self class
					cancelTimer;
					scheduleNext]
			ifFalse: [
				Pending remove: self ifAbsent: []]]
!

delta: anInteger
	"Private - Adjust the delay provided by the receiver by the specified delta (e.g. on
	image reload to base off a new millisecond clock relative to the old)."

	resumptionTime := resumptionTime + anInteger!

duration: millisecs
	"Private - Initialize the receiver to be a Delay for the Number of milliseconds specified by
	the argument, millisecs. The resumptionTime is calculated when a #wait is sent.
	Answer the receiver."

	duration := millisecs truncated
!

getDuration
	"Private - Answer the remaining duration of the receiver based off the current millisecond
	clock value and requested resumption time. We avoid requesting a delay which is larger than
	that which the system can provide, which means we may wake up before time and have to
	reschedule. If the resumptionTime has already passed, then answer 0 (i.e. duration is always
	positive)."

	^(resumptionTime - self class millisecondClockValue min: TimerMax) max: 0!

hasExpired
	"Private - Answer whether the receiver represents a Delay which should have
	fired by now."

	^(resumptionTime - self class millisecondClockValue) < Resolution.

	#todo "This, and other Delay methods, do not correctly account for the millisecond clock
		wrapping round. Fix this, and perhaps allow scheduling of Delays for absolute DateTimes"!

initialize
	"Private - Initialize the receiver to be a valid Delay, but one which will fire immediately.
	Answer the receiver."

	duration := 0.
	waitSemaphore := Semaphore new!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: resumptionTime;
		space;
		print: waitSemaphore;
		nextPut: $)!

resumptionTime
	"Answer the value of the millisecond clock after which any Process waiting on the receiver 
	will be rescheduled."

	^resumptionTime!

resumptionTime: millisecondTime
	"Private - Initialize the receiver to be a Delay until millisecondTime. The duration remains
	nil as this is a delay until an absolute time, and cannot be rescheduled.
	Answer the receiver."

	resumptionTime := millisecondTime truncated!

riseAndShine
	"Private - The receiver's alarm has gone off. Decide whether to get up yet, or
	press the snooze button. This is necessary because we cannot always set a Delay
	for the maximum duration required.
	Implementation Note: This expects to be called inside the critical section."

	self hasExpired 
		ifTrue: [self wakeup]
		ifFalse: [self snooze]!

schedule
	"Private - Schedule the receiver as the next wake up signal.
	Implementation Note: This expects to be called inside the critical section."

	TimingSemaphore reset.

	"This may fire immediately, causing a Process switch to the timing process
	(if it's not the scheduler of the Delay), however it will almost immediately
	be forced to wait for the AccessProtect mutual exclusion Semaphore (which
	we own) to be signalled, which will mean that the assignment to Current
	must happen before the timing process accesses it. The timing Process
	will not restart until we exit our critical section."
	Processor signal: TimingSemaphore afterMilliseconds: self getDuration.

	Current := self!

signal
	"Immediately resume the Process waiting on the receiver."

	self cancel.
	self wakeup
!

snooze
	"Private - The receiver wants a few more moments in bed, press the snooze button on 
	the alarm clock. This is necessary because we sometimes cannot set an alarm duration as
	long as we require, and because we can only set one alarm at a time. 
	Implementation Note: This expects to be called inside the critical section."

	Pending add: self

	

	!

terminateProcess
	"Terminate any process waiting on the receiver"

	waitSemaphore terminateProcess.
	self cancel!

wait
	"Delay the active Process until the receiver's resumption time. The processes priority 
	is temporarily raised to prevent it holding up the timing process when its critical 
	section - if we did not do this and the current active process has a low priority, then 
	it might be preempted in its critical section, which will prevent the TimingProcess
	from operating correctly. The resumption time is calculated outside the critical section 
	so that it is based, as near as possible, on the millisecondClockValue at the time the 
	#wait message is sent. If it were calculated inside, then it would incorrectly include 
	the time taken to acquire the AccessProtect Semaphore."

	| resumingAt |
	resumingAt := self calcResumptionTime.
	AccessProtect critical: [
		"If the new Delay will be the first to wakeup, schedule it"
		Current isNil 
			ifTrue: [self schedule]
			ifFalse: [
				resumingAt < Current resumptionTime
					ifTrue: [ 
						Current snooze.
						self schedule]
					ifFalse: [self snooze]]] atPriority: TimingProcess priority-1.
	"Now make the active Process wait"
	waitSemaphore wait!

wakeup
	"Private - The receiver has fired, resume the Process suspended on the receiver (if any)."

	waitSemaphore signal! !

DiskVolumeInformation comment:
'DiskVolumeInformation can be used to access various statistics and various other items of information available through the Win32 API about disk volumes, for example the disk volumne label and serial number of the disk in a particular drive.

Example Usage:
	DiskVolumeInformation forPath: ''c:\'''!
!DiskVolumeInformation class methodsFor!

forPath: rootPath
	"Answer a new instance of the receiver for the <readableString> rootPath of a particular disk
		self forPath: 'C:\'
	"

	^self new
		setPath: rootPath;
		yourself!

forSystemPath
	"Answer a new instance of the receiver for the system disk
		self forSystemPath
	"

	^self forPath: SessionManager current systemDirectory! !

!DiskVolumeInformation methodsFor!

bytesPerSector
	"Answer the value of the receiver's ''bytesPerSector'' instance variable."

	bytesPerSector isNil ifTrue: [self getDiskFreeSpace].
	^bytesPerSector!

calcDiskSpace
	"Private - Call the Win32 GetDiskFreeSpaceEx() API to retrieve the free bytes etc, 
	or if that is not available use the old GetDiskFreeSpace() API (e.g. on Win95 
	prior to OSR2)."

	[self getDiskFreeSpaceEx] on: Win32Error do: [:e | | bytesPerCluster |
		bytesPerCluster := self bytesPerSector * self sectorsPerCluster.
		totalBytes := self freeClusters * bytesPerCluster.
		totalFreeBytes := freeBytes := self totalClusters * bytesPerCluster].!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self explorerName;
		nextPutAll: ', Serial No. '.
	self displaySerialNumberOn: aStream.
!

displaySerialNumberOn: aStream
	"Private - Display the volume serial number on aStream as a <readableString>"

	| serial |
	serial := self serialNumber.
	aStream nextPutAll: ('%04X-%04X' sprintfWith: serial highWord with: serial lowWord)!

driveLetter
	"Answer the <readableString> drive letter to which this volume information relates (if any)."

	^self rootPath leftString: 1
!

explorerName
	"Answer the <readableString> name that the Windows Explorer would display for this volume
	in the folder tree."

	| vol |
	vol := self label.
	^(String writeStream: 40)
		nextPutAll: (vol isEmpty ifTrue: ['Local Disk'] ifFalse: [vol]);
		nextPutAll: ' (';
		nextPutAll: self driveLetter;
		nextPutAll: ':)';
		contents!

fileSystemFlags
	"Answer the <integer> flags associated with the file system (see the FS_XXX enumeration)."

	fileSystemFlags isNil ifTrue: [self getVolumeInformation].
	^fileSystemFlags!

fileSystemName
	"Answer the <readableString> name of the file-system, e.g. NTFS or FAT."

	fileSystemFlags isNil ifTrue: [self getVolumeInformation].
	^fileSystemName!

freeBytes
	"Answer the value of the receiver's ''freeBytes'' instance variable.
	N.B. On Win95 this value may not be accurate for large volumes (>2Gb)."

	freeBytes isNil ifTrue: [self calcDiskSpace].
	^freeBytes!

freeClusters
	"Answer the value of the receiver's ''freeClusters'' instance variable.
	N.B. This value may not be accurate for large volumes (>2Gb)."

	freeClusters isNil ifTrue: [self getDiskFreeSpace].
	^freeClusters!

getDiskFreeSpace
	"Private - Call the Win32 GetDiskFreeSpace() API to retrieve the cluster sizes, etc."

	| sectorsPerClusterBuf bytesPerSectorBuf numberOfFreeClustersBuf totalNumberOfClustersBuf |

	sectorsPerClusterBuf := DWORD new.
	bytesPerSectorBuf := DWORD new.
	numberOfFreeClustersBuf := DWORD new.
	totalNumberOfClustersBuf := DWORD new.

	(KernelLibrary default
		getDiskFreeSpace: self rootPath
		lpSectorsPerCluster: sectorsPerClusterBuf
		lpBytesPerSector: bytesPerSectorBuf
		lpNumberOfFreeClusters: numberOfFreeClustersBuf
		lpTotalNumberOfClusters: totalNumberOfClustersBuf)
			ifFalse: [KernelLibrary default systemError].

	sectorsPerCluster := sectorsPerClusterBuf value.
	bytesPerSector := bytesPerSectorBuf value.
	freeClusters := freeBytes isNil
		ifTrue: [
			"Likely to be wrong, but the best we can do..."
			freeClusters := numberOfFreeClustersBuf value]
		ifFalse: [freeBytes / (bytesPerSector*sectorsPerCluster)].
	totalClusters := totalBytes isNil
		ifTrue: [
			"Again likely to be wrong, ..."
			totalNumberOfClustersBuf value.]
		ifFalse: [totalBytes / (bytesPerSector*sectorsPerCluster)].
	
!

getDiskFreeSpaceEx
	"Private - Call the Win32 GetDiskFreeSpace() API to retrieve the free space etc, etc."

	| freeBytesAvailableBuf  totalNumberOfBytesBuf totalNumberOfFreeBytesBuf |

	freeBytesAvailableBuf := ULARGE_INTEGER new.
	totalNumberOfBytesBuf := ULARGE_INTEGER new.
	totalNumberOfFreeBytesBuf := ULARGE_INTEGER new.

	(KernelLibrary default
		getDiskFreeSpaceEx: path
		lpFreeBytesAvailable: freeBytesAvailableBuf
		lpTotalNumberOfBytes: totalNumberOfBytesBuf
		lpTotalNumberOfFreeBytes: totalNumberOfFreeBytesBuf)
			ifFalse: [KernelLibrary default systemError].

	freeBytes := freeBytesAvailableBuf value.
	totalFreeBytes := totalNumberOfFreeBytesBuf value.
	totalBytes :=  totalNumberOfBytesBuf value.
!

getDiskStats
	"Private - Call the Win32 GetDiskFreeSpaceEx() API to retrieve the free bytes etc, 
	and then calculate other stats, or if that is not available use the old GetDiskFreeSpace() 
	API (e.g. on Win95 prior to OSR2) and calculate from there."

	[self getDiskFreeSpaceEx] on: Win32Error do: [:e | | bytesPerCluster |
		bytesPerCluster := self bytesPerSector * self sectorsPerCluster.
		totalBytes := self freeClusters * bytesPerCluster.
		totalFreeBytes := freeBytes := self totalClusters * bytesPerCluster].!

getVolumeInformation
	"Private - Call the Win32 GetVolumeInformation() API to retrieve the label, etc."

	| volumeNameBuffer volumeSerialNumber maximumComponentLengthBuffer
		fileSystemFlagsBuffer fileSystemNameBuffer |

	volumeNameBuffer := File pathBuffer.
	volumeSerialNumber := DWORD new.
	maximumComponentLengthBuffer := DWORD new.
	fileSystemFlagsBuffer := DWORD new.
	fileSystemNameBuffer := String new: 32.

	(KernelLibrary default
		getVolumeInformation: self rootPath
		lpVolumeNameBuffer: volumeNameBuffer
		nVolumeNameSize: volumeNameBuffer size
		lpVolumeSerialNumber: volumeSerialNumber
		lpMaximumComponentLength: maximumComponentLengthBuffer
		lpFileSystemFlags: fileSystemFlags
		lpFileSystemNameBuffer: fileSystemNameBuffer
		nFileSystemNameSize: fileSystemNameBuffer size) 
			ifFalse: [KernelLibrary default systemError].

	label := volumeNameBuffer trimNulls.
	serialNumber := volumeSerialNumber value.
	maxComponentLength := maximumComponentLengthBuffer value.
	fileSystemFlags := fileSystemFlagsBuffer value.
	fileSystemName := fileSystemNameBuffer trimNulls.!

label
	"Answer the <readableString> disk volume label. If the disk is not labelled 
	this will be an empty <String>."

	label isNil ifTrue: [self getVolumeInformation].
	^label!

label: newLabelString
	"Set the label of this disk volume."

	(KernelLibrary default
		setVolumeLabel: self rootPath
		lpVolumeName: newLabelString)
			ifFalse: [KernelLibrary default systemError].

	label := newLabelString!

maxComponentLength
	"Answer the <integer> maximum length of a file system path component part (e.g. 
	the maximum length of a directory name)."

	maxComponentLength isNil ifTrue: [self getVolumeInformation].
	^maxComponentLength!

printOn: target
	"Append, to the <puttableStream>, target, a string whose characters are a 
	the same as those which would result from sending a #printString
	message to the receiver."

	target
		basicPrint: self;
		nextPut: $(;
		display: self;
		nextPut: $)!

rootPath
	"Answer the value of the receiver's ''rootPath'' instance variable."

	rootPath isNil ifTrue: [rootPath :=  (File splitPath: path) first asUppercase copyWith: File pathDelimiter].
	^rootPath!

sectorsPerCluster
	"Answer the value of the receiver's ''sectorsPerCluster'' instance variable."

	sectorsPerCluster isNil ifTrue: [self getDiskFreeSpace].
	^sectorsPerCluster!

serialNumber
	"Answer the 32-bit <integer> disk serial number. Normally displayed by Windows/Dos
	as two 16-bit hex values, being the high and low words of this 32-bit value."

	serialNumber isNil ifTrue: [self getVolumeInformation].
	^serialNumber!

setPath: pathString
	"Private - Initialize the receiver to retrieve disk volume information for the volume on which
	the specified path resides."

	path := pathString!

totalBytes
	"Answer the value of the receiver's ''totalBytes'' instance variable."

	totalBytes isNil ifTrue: [self calcDiskSpace].
	^totalBytes!

totalClusters
	"Answer the value of the receiver's ''totalClusters'' instance variable."

	totalClusters isNil ifTrue: [self getDiskFreeSpace].
	^totalClusters!

totalFreeBytes
	"Answer the value of the receiver's ''totalFreeBytes'' instance variable."

	totalFreeBytes isNil ifTrue: [self calcDiskSpace].
	^totalFreeBytes! !

Exception comment:
''!
!Exception class methodsFor!

, anotherException
	"Answer a new <exceptionSet> containing the receiver and the <exceptionSelector> 
	argument, anotherException. Note that the 'set' is a bit of a misnomer, as the result 
	does not conform to that protocol."

	^ExceptionSet with: self with: anotherException!

beep
	"Sound an appropriate beep to draw the users attention."

	"Implementation Note: Use the MessageBeep() API directly to avoid creating a dependency on the Sound class."

	UserLibrary default messageBeep: self mbIconId!

handles: exception
	"Answer whether the receiver matches the <exceptionDescription>, exception, and 
	any handler at this scope should be invoked.

	Implementation Note: The default is to handle exceptions which are instances or 
	subinstances of the receiver. This provides for an elegant type-based mechanism 
	for handling exceptions, similar to that of C++."

	^exception isKindOf: self!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

mbIconId
	^0!

new
	"Answer a new initialized instance of the receiver, conforming to 
	the <Exception> protocol."

	^super new initialize!

signal
	"Raise a new instance of the receiver conforming to <signaledException> with all <exceptionDescription>
	attributes set to default values. A search is initiated for an exception handler prepared to handle 
	instances of the receiver. This method will not return to its sender, unless the new instance is 
	resumable, and the handler which catches it directs that it should be resumed."

	^self new signal!

signal: signalerText
	"Raise a new instance of the receiver, with the <readableString> message text,
	signalerText, initiating a search for an <ExceptionHandler> prepared to handle 
	instances of the receiver. This method will not return to its sender, unless the new 
	instance is resumable, and the handler which catches it directs that it should 
	be resumed."

	^self new
		signal: signalerText!

signal: signallerText with: signallerTag
	"Raise a new instance of the receiver, with the error tag <Object>, signallerTag, 
	and the <readableString> message text, signallerText,  initiating a search for 
	an <ExceptionHandler> prepared to handle instances of the receiver. 
	his method will not return to its sender, unless the new instance is 
	resumable, and the handler which catches it directs that it should be resumed."

	^self new 
		signal: signallerText with: signallerTag!

signalWith: signallerTag
	"Raise a new instance of the receiver, with the error tag <Object>, signallerTag, 
	initiating a search for an <ExceptionHandler> prepared to handle instances of 
	the receiver. This method will not return to its sender, unless the new instance is 
	resumable, and the handler which catches it directs that it should be resumed."

	^self signal: nil with: signallerTag! !

!Exception methodsFor!

_descriptionArguments
	"Answer a <sequencedReadableCollection> of the  arguments to be substitued 
	into the receiver's Win32 description format string when constructing the receivers 
	#description.
	By default the arguments to the message formatting are the message text and 
	the tag supplied by the exception signaller, but if additional fields are available,
	then this should be overridden.

	N.B. This is part of the implementation of the ANSI standard message 
	#description and therefore it requires an underscore prefix in order
	to avoid the fragile base class problem where subclasses may 
	inadvertantly override a superclass method."

	^Array 
		with: self messageText displayString 	"...just in case the messageText is not a String"
		with: self tag displayString!

_descriptionFormat
	"Answer a <readableString> whose contents are a Win32 format string to be used 
	to construct the #description for the receiver.
	By default the format will display only the message text supplied by the signaller,
	but this can (and should) be overridden by subclasses to display something more specific.

	N.B. This is part of the implementation of the ANSI standard message 
	#description and therefore it requires an underscore prefix in order
	to avoid the fragile base class problem where subclasses may 
	inadvertantly override a superclass method."

	^'%1'!

_evaluateHandler: handlerBlock in: anExceptionHandler 
	"Private - The receiver has been identified as a handler for the argument exception. 
	Handle the exception by evaluating the exception handling block, handlerBlock, 
	establishing the continue block so that a non-local return to our sender is possible. 
	When the continue block is evaluated it causes a non-local return of its argument value 
	to the context from which the receiver was signalled, having the effect of ignoring the 
	signalling of the receiver."

	| myEnv procEnv answer myContinueBlock activeProc |
	activeProc := Processor activeProcess.
	procEnv := activeProc exceptionEnvironment.
	myEnv := _activeHandler.
	myContinueBlock := _continueBlock.
	answer := 
			["Handle the exception within the environment of its enclosing handlers (a 
			 handler can't handle its own exceptions!!)"

			activeProc exceptionEnvironment: anExceptionHandler outer.
			"Record the active handler so that we can use it to act on responses from 
			 handler block"
			_activeHandler := anExceptionHandler.
			"Create the continue block for use with #resume:"
			_continueBlock := [:continueWith | ^continueWith].
			handlerBlock value: self] 
					ensure: 
						["Be sure to restore the previous exception environment"

						_activeHandler := myEnv.
						_continueBlock := myContinueBlock.
						activeProc exceptionEnvironment: procEnv].

	"If the user supplied exception handling block terminates by dropping off its end,
	without specifying a particular action, then we default to continuing execution
	immediately after the try block, even if the exception is resumable. This change
	for compatibility with latest X3J20 proposal, Sept. 96, BSM."
	^anExceptionHandler return: answer.
	#todo	"I am increasingly of the view that the continueBlock should be held in the handler
		since it would not then be necessary to save and restore it, and it relates to the
		handling of an Exception, not the Exception itself. Move it."!

_propagate
	"Private - Propagate the receiver up through the originating process' stack of
	ExceptionHandlers starting from the current one."

	| answer |
	answer := self _propagateFrom: Processor activeProcess exceptionEnvironment.
	^answer == _resignalBlock
		ifFalse: [answer]
		ifTrue: [_resignalException signal]!

_propagateFrom: anExceptionEnvironmentOrNil 
	"Private - Propagate the receiver up through the chain of handlers starting at anExceptionHandlerOrNil,
	looking for one willing to handle the receiver. Should their be no such handler, then the default
	action associated with the receiver is performed."

	"The resignal block answers itself to provide a unique mark to identify retry attempts to the #handle method"

	| env oldEnv answer activeProc |
	_resignalBlock isNil ifTrue: [_resignalBlock := [^_resignalBlock]].
	env := anExceptionEnvironmentOrNil.

	"Exceptions can only be raised and handled in the context of the current active process."
	activeProc := Processor activeProcess.

	"We must prevent any exceptions generated during the search for a handler from
	causing an infinitely recursive search, so we temporarily trick the process
	into thinking it hasn't got a chain of exception handlers"
	oldEnv := activeProc exceptionEnvironment.
	activeProc exceptionEnvironment: nil.
	[env isNil] whileFalse: 
			[| handlerBlock |
			(handlerBlock := env actionFor: self) isNil 
				ifFalse: 
					[activeProc exceptionEnvironment: oldEnv.
					^self _evaluateHandler: handlerBlock in: env].
			env := env outer].

	"No handler was found, perform the default action in the same exception environment as that in place
	when the receiver was raised"
	activeProc exceptionEnvironment: _environmentWhenRaised.
	answer := self defaultAction.
	activeProc exceptionEnvironment: oldEnv.
	^answer.
	#todo	"Wouldn't it be neater if the invocation of #defaultAction was performed within a handler block so that
		the handler responses could be used from within #defaultAction (they cannot at the moment). We could
		also have a bit less special case code."!

abort
	"Terminate the process in which the receiver was raised."

	Processor activeProcess terminate!

abortRetryIgnore
	"Throw up an Abort/Retry/Ignore Warning message box with the receiver's message: If the 
	user presses Ignore, then resume (continue execution as if the warning had not been raised), 
	if the user presses Abort, then return (continue execution after the handler), the answer is nil 
	in either case. Example usage:

	[ Warning signal: 'Aha!! Continue?'. Transcript show: 'Inside the try block'; cr ] 
		on: Warning do: [ :e |
			e abortRetryIgnore ]. Transcript show: 'After the try block'; cr.
	"

	self perform: self abortRetryOrIgnore
!

abortRetryOrIgnore
	"Throw up an Abort/Retry/Ignore Warning message box with the receiver's message and answer
	the symbolic name of the user's response."

	self beep.
	^#(#abort #retry #ignore) 
		at: (self showMessage: self description
				style: ##(MB_ICONWARNING | MB_ABORTRETRYIGNORE | MB_DEFBUTTON3)) - IDABORT 
				+ 1
		ifAbsent: [#abort]!

beep
	"Sound an appropriate beep to draw the users attention."

	self class beep!

defaultAction
	"Perform the default action for the receiver if it is not handled

	This is an ANSI standard message, but the action to be taken is implementation
	defined. In the Dolphin development environment the default actions are
	as follows:
		Error		- Causes a walkback from the signal origin.
		Warning		- Displays an Abort/Retry/Ignore message box. 
		Notification	- Writes the description to the Transcript, and resumes.
	See those subclasses for further details."

	^self subclassResponsibility!

description
	"Answer a <readableString> describing the exception which the receiver represents. Note that
	if 'an explicit message text was provided by the signaler of the exception, that text should
	be incorporated into the description.' We don't enforce this (because we take the view that
	it is more important that exceptions carry all necessary details from the signalling point
	that will enable them to be handled correctly, and that presentation to the user is the
	exceptional case).

	N.B. This is an ANSI standard message in a class which is explicitly specified to be
	subclassable, and therefore it must not send any messages to self other than other ANSI
	standard messages, or those prefixed with an underscore. This is to avoid the fragile base
	class problem where subclasses may inadvertantly override a superclass method."

	| desc format |
	format := self _descriptionFormat.
	"An optimisation to speed up notifications - also avoids problem of limited string lengths
	supported by FormatMessage API"
	desc := format = '%1' 
				ifTrue: [self _descriptionArguments first]
				ifFalse: [format formatWithArguments: self _descriptionArguments].
	^desc isEmpty ifTrue: ['An unknown <1p> has occurred' expandMacrosWith: self class] ifFalse: [desc]!

displayOn: aStream
	"Append a user-friendly textual representation of the receiver to the 
	<puttableStream>, target."

	| signallerText |
	aStream nextPutAll: (
		(signallerText := self messageText) notNil
			ifTrue: [signallerText]
			ifFalse: [self description])!

exit: anObject
	"Answer the argument as the value of the handler block, as if it were the value of the last 
	expression in the try block. For non-resumable exceptions, this is 
	equivalent to #return:, for resumable #resume:. This is no longer part of the ANSI
	standard set of handler responses."

	^self isResumable
		ifTrue: [self resume: anObject]
		ifFalse: [self return: anObject]!

hasTag
	"Answer whether a tag value with additional error details was supplied 
	when the receiver was signalled."

	^tag notNil!

hresult
	"Answer the <HRESULT> error code associated with the receiver.
	Overridden by subclasses to answer more specified HRESULT codes."

	^HRESULT fail!

ignore
	"Perform the receiver's #resume action."

	self resume!

isNested
	"Answer whether the current exception currently being handled is within the scope of another
	handler for the same exception (i.e. if passed will be caught)."

	| env |
	env := Processor activeProcess exceptionEnvironment.
	[env isNil] whileFalse: [
		(env actionFor: self) isNil ifFalse: [^true].
		env := env outer].
	^false!

isResumable
	"Answer whether the receiver represents a resumable error. 
	Exceptions are, by default, NOT resumable."

	^false!

isUserResumable
	"Answer whether the user should be given the option of resuming when
	prompted with regard to this exception."

	^self isResumable!

messageText
	"Answer the <readableString> message text supplied when the receiver was signalled,
	or <nil> if none was provided."

	^messageText!

messageText: signalerText
	"Set the exceptions message text to the readableString argument, <signalerText>."

	messageText := signalerText!

okCancel
	"Throw up an OK/Cancel Warning message box with the receiver's message: If the user presses Ok, then resume
	(continue execution as if the warning had not been raised), if the user presses Cancel, then return (continue 
	execution after the handler), the answer is nil in either case. Example usage:

	[Warning signal: 'Aha!! Continue?'. Transcript show: 'Inside the try block'; cr ] on: Warning do: [ :e |
		e okCancel]. Transcript show: 'After the try block'; cr.
	"

	self okToContinue
		ifTrue: [self resume]
		ifFalse: [self return]!

okToContinue
	"Throw up an OK[Cancel] message box with the receiver's message, answering true if 
	it is ok to continue (the user pressed OK and the receiver is resumable)."

	^(self showMessage: self description
		style: (self isUserResumable 
				ifTrue: [##(MB_OKCANCEL | MB_ICONWARNING)]
				ifFalse: [##(MB_OK | MB_ICONERROR)])) 
			== IDOK and: [self isUserResumable]!

outer
	"Answer the result of evaluating the next outermost exception handler for the 
	receiver, or the default action if none. The semantics of this handler response
	are quite subtle: Whether execution actually continues _in this message_ depends 
	on whether the receiver is resumable, and on the handler response invoked by the 
	outer handler, or the default action if there is no outer handler. If the exception
	is resumable, and the outer handler resumes then the answer from this 
	message will be the resumption value specified by that outer handler (or nil
	if non was specified), i.e. #resume(:) in the outer handler will resume in the
	handler which sent this message, not from the original point where the	
	exception was raised.  If the receiver is not a resumable exception, or if the
	outer handler does not resume, then control is not returned to this point and this
	message will not return. For exceptions that are not resumable, #outer is equivalent 
	to #pass."

	^self _propagate!

pass
	"Propagate the receiver to any enclosing handlers. The exact behavior depends on 
	whether the receiver is resumable or not.

	This selector is not particularly well chosen (it is an ANSI selector) so it may not be
	clear that this is the way one resignals a caught exception from inside a handler
	in order to propagate it to any enclosing handlers, i.e. it is the way one says,
	'There is nothing further I can do with this exception, you have it.'"

	^self exit: self _propagate!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver. In
	the case of an Exception we assume it is being copied so that it may be re-raised, and
	therefore we nil the state associated with the context in which the original was raised."

	super postCopy.
	_environmentWhenRaised := _signalFrame := 
		_continueBlock := _resignalBlock := nil.
	^self
!

printOn: aStream
	"Append a debug description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; print: self description; nextPut: $)
!

printTraceOn: puttableStream
	"Write the receiver's description, and a stack trace from the point
	where the receiver was raised to puttableStream. This is intended for logging 
	error details.
	N.B. This only works where the receiver was signalled within the active process, 
	because Exceptions do not record the process in which they are signalled."

	puttableStream
			print: self;
			cr; cr;
			nextPutAll: (self stackTrace: 20);
			cr!

raisingFrame
	"Private - Answer the StackFrame from which the receiver was raised (approximate
	and for debugging purposes only)."

	| frame |
	frame := self signalFrame sender.
	"Skip the exception handling frames - a bit crap!!"
	
	[| receiver |
	receiver := frame receiver.
	(receiver isKindOf: Exception) or: [receiver isKindOf: Exception class]] 
			whileTrue: [frame := frame sender].
	^frame!

resignalAs: anException
	"Signal the argument, anException, as if it had originally been raised in place of the
	receiver. The process state at the time the receiver was raised is restored by using
	the resignal block. This is powerful, but should be used with care!!"

	_resignalException := anException.
	_resignalBlock value!

resume
	"Answer <nil> as the value of the message that signaled this exception, 
	from whence execution continues, unless the current handler was activated
	as the result of a #outer action from an inner handler, in which case nil
	is returned to that handler, and execution continues there.
	Note that this message never returns to its sender.
	An error is signalled if the receiver is not resumable."

	self resume: nil!

resume: resumptionValue
	"Answer the <Object> resumptionValue as the result of the expression which 
	signalled this exception, from whence execution continues, unless the current 
	handler was activated as the result of a #outer action from an inner handler, 
	in which case resumptionValue is returned to that handler, and execution 
	continues there. Note that this message never returns to its sender.
	An error is signalled if the receiver is not resumable."

	self isResumable 
		ifTrue: [_continueBlock value: resumptionValue]
		ifFalse: [self error: 'non-continuable exception']!

retry
	"Abort the current exception handler and reattempt the evaluation of the try block.
	Note that this message does not return to its sender. Please use with care as it is
	easy to create an infinite loop by retrying a block indefinitely."

	_activeHandler retry!

retryUsing: alternativeBlock
	"Using the <niladicBlock>, alternativeBlock, in place of the try block from which the 
	receiver was raised, ignore the exception and retry in that context. This message does 
	not return to its sender.
	This should be used with particular care, as this is undoubtedly a most excellent 
	mechanism for the construction of excessively convoluted programs."

	_activeHandler retryUsing: alternativeBlock!

return
	"Answer <nil> as the value of the block guarded by the active exception handler.
	This message does not return to its sender."

	self return: nil!

return: returnValue
	"Answer the <Object> argument, returnValue, as the value of the block guarded by the 
	active exception handler. This message does not return to its sender."

	_activeHandler return: returnValue!

severityClass
	"Answer an exception class describing the severity of the notification."

	^self class severityClass!

showMessage: aString style: anInteger 
	"Implementation Note: Avoid creating a dependency on MessageBox, as this class will always
	be required in an application even if MessageBox is not."

	^UserLibrary default 
		messageBox: nil
		text: aString
		caption: SessionManager current applicationName
		style: (Processor isActiveMain 
				ifTrue: [anInteger maskSet: ##(MB_TASKMODAL | MB_SETFOREGROUND)]
				ifFalse: [anInteger])
		icon: nil
		instance: nil!

signal
	"Raise (or re-raise) the receiver in the context of the current active process, causing its propagation 
	up through the handler chain."

	_environmentWhenRaised isNil ifTrue: [
		"Save info about the raising environment in case we want to resignal."
		_environmentWhenRaised := Processor activeProcess exceptionEnvironment.
		"If the signaller did not specify the context where the error was raised, make it this one"
		_signalFrame := thisContext].
	^self _propagate!

signal: signalText
	"Raise the receiver with the <readableString> error message text,
	signalText."

	self messageText: signalText.
	^self signal!

signal: signalText with: arg
	"Raise the receiver with the <readableString> error message text,
	signalText and the <Object> tag, arg."

	self messageText: signalText.
	self tag: arg.
	^self signal!

signalFrame
	"Private - Answer the StackFrame from which the receiver was signalled. This may be several 
	levels below the actual error detection frame on the stack."

	^Processor activeProcess frameAtAddress: _signalFrame!

signalType
	"Private - Answer the type of signal for which the receiver is representing
	an exceptional event."

	^self class!

signalWith: anObject
	"Raise the receiver with the <Object> tag."

	^self signal: nil with: anObject!

stackTrace: anInteger
	"Private - Answer a <readableString> containing a stack trace to the depth specified by the <integer>
	argument. Assumes that the receiver is a signalled exception in the active process."
	
	| frame |
	frame := self raisingFrame.	"N.B. Assumes in active process"
	^frame process stackTraceFrom: self raisingFrame depth: anInteger!

tag
	"Answer the <Object> tag value with additional error details supplied 
	when the receiver was signalled. If the signaller has not provided a tag
	then answer the #messageText. 
	N.B. The tag should be used when examining exceptions, rather than the 
	message text, since the latter is intended only for human consumption, 
	and might, for example, vary between locales."

	^tag ifNil: [self messageText]!

tag: signalTag
	"Private - Set the receiver's tag object to be the <Object> argument, signalTag.
	Answer the receiver."

	tag := signalTag!

toTrace
	"Print details of the Exception to the session managers debug output device."
	
	self toTrace: 0!

toTrace: frames
	"Print details of the Exception to the session managers debug output device,
	along with a stack track of depth as specified by the <integer>, frames."
	
	| sesh |
	sesh := SessionManager current.
	sesh trace: self description, String lineDelimiter.
	frames > 0 ifTrue: [ | proc |
		proc := Processor activeProcess.
		sesh trace: (proc stackTraceFrom: proc topFrame sender depth: frames), String lineDelimiter].! !

ExceptionHandlerAbstract comment:
''!
!ExceptionHandlerAbstract class methodsFor!

initialize
	"Initialize the receiver's class instance variable."

	RetryCookie := Object new!

on: selector do: action
	"Private - Answer a new instance of the receiver with the <exceptionSelector>, 
	selector, and <monadicBlock> exception handler, action."

	^self new on: selector do: action! !

!ExceptionHandlerAbstract methodsFor!

actionFor: exception
	"Private - Answer a <monadicBlock> handler for the <exceptionDescription> 
	argument, exception or nil if the receiver has no appropriate handler."

	^self subclassResponsibility!

markAndTry
	"Private - Evaluate the receiver's tryBlock, having first created the block used to return 
	to the context which originated the receiver (i.e. the sender of #on:do:). The returnBlock, 
	when evaluated, will cause a non-local return to the context where the receiver was instantiated, 
	and is used to implement returning from (or dropping off the end of) exception handlers."

	returnContinuation := [:answer | ^answer].
	^protectedBlock value!

on: exceptionSelector do: monadicBlock 
	"Private - Record the <exceptionSelector> and <monadicBlock> to be
	used as the receivers exception selector and handler block respectively."

	^self subclassResponsibility!

outer
	"Private - Answer the receiver's outer handler."
	
	^outer!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: protectedBlock;
		nextPut: $)!

retry
	"Private - Attempt the receiver's try block again. The user supplied handler block could 
	have modified the try block, so this may not mean re-evaluating the same block. If not, 
	then the user-supplied handler block should have taken some other remedial action so that 
	the same exception is not regenerated, as otherwise an infinite loop may result. Use with care.
	Implementation Note: Return the unique Retry cookie which to distinguish from any other
	return value."

	self return: RetryCookie!

retryUsing: newProtectedBlock
	"Private - Restart the expression (#on:do:) from which the receiver originated, but 
	with the different try Block, newProtectedBlock. Use sparingly, and with care as the 
	results may be difficult to predict."

	protectedBlock := newProtectedBlock.
	self retry!

return: anObject
	"Private - Answer the argument as the value of the receiver's try block (which must have generated an exception caught
	by the receiver). The returnBlock contains a non-local return, so it will unwind the stack back to the
	context which was trying to evaluate the guarded block."

	returnContinuation value: anObject!

try: niladicBlock
	"Private - Answer the result of evaluating niladicBlock within an exception environment
	established by pushing the receiver onto the active processes exception environment.
	Should an exception be generated, directly or indirectly, by niladicBlock, which is 
	caught by the receiver, then the corresponding handler block in the receiver will be 
	will be evaluated to handle it. If the receiver does not handle a raised exception then 
	that exception will propagate up the handler chain in the process' exception environment."

	| old answer process |
	protectedBlock := niladicBlock.
	process := Processor activeProcess.
	outer := old := process exceptionEnvironment.
	
	[process exceptionEnvironment: self.
	[(answer := self markAndTry) == RetryCookie] whileTrue] 
			ensure: [process exceptionEnvironment: old].
	returnContinuation := nil.
	^answer! !

ExceptionSet comment:
'ExceptionSet is a system class forming part of the Dolphin exception handling system''s implementation. It is used to collect together multiple <exceptionSelector>s specified in a comma separated list as the first argument to a #on:do: message to a <niladicBlock>.'!
!ExceptionSet class methodsFor!

new
	"Answer a new instance of the receiver."

	^super new initialize!

with: selector1 with: selector2
	"Private - Answer a new instance of the receiver containing 
	the <exceptionSelector> arguments, selector1 and selector2"

	^super new
		selectors: (OrderedCollection with: selector1 with: selector2)! !

!ExceptionSet methodsFor!

, anotherException
	"Add the <exceptionSelector>, anotherException, to the group of 
	<exceptionSelectors> recognised by the receiver.
	The ANSI standard does not specify whether the answer is a new
	exceptionSet, or the receiver - we answer the receiver."

	selectors add: anotherException!

handles: exception
	"Answer whether the receiver contains an <exceptionSelector> which
	matches the <exceptionDescription>, exception."

	^selectors anySatisfy: [:es | es handles: exception]!

initialize
	"Initialize the receiver."

	selectors := OrderedCollection new!

selectors
	"Answer the value of the receiver's instance variable 'selectors'.
	This method was automatically generated, but may be modified."

	^selectors!

selectors: anObject
	"Set the value of the receiver's instance variable 'selectors' to anObject.
	This method was automatically generated, but may be modified."

	selectors := anObject! !

ExternalCallback comment:
''!
!ExternalCallback class methodsFor!

allocateThunks
	"Private - Allocate and populate a block of memory with callback thunks. Note that the
	memory is executable to avoid issues with Data Execution Protection. on XP SP2 and 2K3.

	self allocateThunks "

	| procAddress |
	self deallocateThunks.
	ThunkBase := KernelLibrary default 
				virtualAlloc: 0
				dwSize: MaxThunks * ThunkSize
				flAllocationType: MEM_COMMIT
				flProtect: PAGE_EXECUTE_READWRITE.
	procAddress := VMLibrary default getGenericCallback.
	1 to: MaxThunks
		do: 
			[:i | 
			| offset |
			offset := ThunkSize * (i - 1) - 1.
			"push esp - value of esp saved is that before push"
			ThunkBase byteAtOffset: (offset := offset + 1) put: 16r54.
			"push <callback id>"
			ThunkBase
				byteAtOffset: (offset := offset + 1) put: 16r68;
				dwordAtOffset: (offset := offset + 1) put: i.
			"Calls normally have a relative displacement (unless far) so call through a
			register with 'mov eax GenericCallback; call eax' sequence"
			ThunkBase
				byteAtOffset: (offset := offset + 4) put: 16rB8;
				dwordAtOffset: (offset := offset + 1) put: procAddress.
			ThunkBase
				byteAtOffset: (offset := offset + 4) put: 16rFF;
				byteAtOffset: (offset := offset + 1) put: 16rD0.
			"ret <argsSize>; argument size will be substituted when thunk allocated to
			particular callback"
			ThunkBase
				byteAtOffset: (offset := offset + 1) put: 16rC2;
				wordAtOffset: (offset := offset + 1) put: 0]!

block: aBlockClosure argumentTypes: aString
	"Answer a new subinstance of the receiver appropriate for dispatching callbacks
	to the block, aBlockClosure, with the specified argument types."

	^(BlockCallback new)
		block: aBlockClosure;
		descriptor: (self descriptorClass argumentTypes: aString);
		yourself!

block: aBlockClosure descriptor: anExternalDescriptor
	"Answer a new subinstance of the receiver appropriate for dispatching callbacks
	to the block, aBlockClosure, with the specified descriptor."

	^(BlockCallback new)
		block: aBlockClosure;
		descriptor: anExternalDescriptor;
		yourself!

callback: anInteger withArgumentsAt: anAddress
	"Private - Ask the receiver's instance with the cookie, anInteger, to evaluate itself
	with arguments constructed from the raw data at anAddress (in the stack)"

	^(self fromCookie: anInteger) valueWithArgumentsAt: anAddress!

callbackPrimitive
	"Private - Answer the index of the callback method primitive (which is only a marker)."

	^0!

clear
	"Private - Clear down the registry of outstanding instances of the receiver.

	WARNING: THIS IS LIKELY TO REDUCE THE EFFECTIVENESS OF A RUNNING IMAGE!!"

	Registry := WeakRegistry new!

deallocateThunks
	ThunkBase isNil ifTrue: [^self].
	KernelLibrary default 
		virtualFree: ThunkBase
		dwSize: 0
		dwFreeType: MEM_RELEASE.
	ThunkBase := nil!

descriptorClass
	"Private - Answer the class used to build and represent function descriptors."

	^ExternalDescriptor!

fromCookie: anInteger
	"Answer the receiver's registered instance with the cookie, anInteger. If there is no such
	instance, raise a NotFoundError/BoundsError."

	| inst |
	inst := Registry at: anInteger.
	^inst isNil 
		ifTrue: [self errorNotFound: anInteger]
		ifFalse: [inst]
!

initialize
	"Private - Initialize the receiver's class variables.
		ExternalCallback initialize
	"

	ThunkSize := 16.
	self assert: [(4096 rem: ThunkSize) = 0].
	"The maximum number of callback that can be allocated at any one time is limited by
	MaxThunks. If insufficient, increase by a multiple of 256 and restart."
	MaxThunks := 256.
	self assert: [(ThunkSize * MaxThunks rem: 4096) = 0].
	Registry isNil ifTrue: [self clear].
	ArgSizeOffset := ThunkSize - 2!

new
	"Answer a new registered instance of the receiver with a unique magic cookie."

	| answer |
	answer := self basicNew.
	answer cookie: (self register: answer).
	^answer!

onStartup
	"Private - The system is starting. Perform necessary initialization.
	We clear down old callbacks as these can no longer be valid. We must
	also re-establish the VM entry point proc. address, as this may change."

	ThunkBase := nil.
	self allocateThunks.
	self clear!

receiver: anObject selector: aSymbol descriptor: anExternalDescriptor
	"Answer a new instance of the receiver configured to send the <selector>, aSymbol,
	to the <Object>, anObject, when invoked as a callback with descriptor, anExternalDescriptor."

	^(MessageCallback new)
		receiver: anObject;
		selector: aSymbol;
		descriptor: anExternalDescriptor;
		yourself!

register: instance
	"Private - Register the subinstance of the receiver, instance, answering its
	unique integer cookie."

	^Registry addAnsweringIndex: instance! !

!ExternalCallback methodsFor!

argumentCount
	"Private - Answer the number of arguments expected by the receiver."

	^descriptor argumentCount!

argumentsSize
	"Private - Answer the total size of the receiver's arguments (when
	pushed on the stack)."

	^descriptor argumentsSize!

argumentTypes
	"Private - Answer a collection of the argument types expected by the receiver."

	^descriptor argumentTypes!

asParameter
	"Answer the receiver in a form suitable for passing as a callback function."

	^self thunk!

callingConvention
	"Private - Answer the number of arguments expected by the receiver."

	^descriptor callingConvention!

cookie
	"Answer the callbacks unique (among callbacks) magic cookie (actually an index 
	into the callback registry). This is not private, as it may be useful for some
	user code."

	^cookie!

cookie: anInteger 
	"Private - Set the callbacks magic cookie. Answer the receiver."

	anInteger > MaxThunks 
		ifTrue: [self error: 'Insufficient callback thunks; increase ExternalCallback.MaxThunks and restart'].
	cookie := anInteger!

descriptor
	"Private - Answer the external function descriptor of the callback function which the receiver
	represents. See ExternalMethod for further details of argument types etc."

	^descriptor!

descriptor: anExternalFunctionDescriptor
	"Private - Set the external function descriptor of the callback function which the receiver
	represents. See ExternalMethod for further details of argument types etc."

	descriptor := anExternalFunctionDescriptor!

free
	"Explicitly free any resources consumed by the receiver as it is no longer required.
	Sending this message reduces the load on the MemoryManager, but it is not 
	strictly necessary. Do not free a callback that is still use!!"

	"There is no process sync problem here because the receiver cannot be GC'd while
	in this method, and therefore it cannot be replaced in the registry by another
	callback"

	(Registry at: cookie ifAbsent: []) == self
		ifTrue: [Registry removeAtIndex: cookie].
	thunk := nil!

makeProcInstance
	"Private - Allocate a callback thunk for the receiver from the block in fixed, executable,
	memory."

	thunk := (ThunkBase asInteger + ((cookie - 1) * ThunkSize)) asExternalAddress.
	descriptor calleeCleans ifTrue: [thunk wordAtOffset: ArgSizeOffset put: self argumentsSize]!

thunk
	"Private - Answer the receiver's assembler thunk."

	thunk isNil ifTrue: [self makeProcInstance].
	^thunk!

valueWithArgumentsAt: anAddress
	"Private - Evaluate the receiver with arguments instantiated from the raw data at anAddress.
	For performance and consistency (with outbound external calls) reasons, we use a VM supplied
	primitive to instantiate and push the arguments and perform the message, but there is no reason
	that this cannot be done in Smalltalk if different argument conversions are required. The standard
	conversions are the same as those performed for return types by the external call primitive (see
	the ExternalLibrary class)."

	^self subclassResponsibility! !

ExternalDescriptor comment:
'The argument/return types supported by the primitive DLL call function are:

	void 	Only valid as a return type - the method answers self
	lpvoid 	General pointer type, accepts byte objects e.g. Strings (pointer to contents 
		passed), nil (null pointer), integers (passes as address), or ExternalAddresses
		(the contained address is passed, not a pointer to the ExternalAddress object). 
		When used as a return type, the method answers an instance of ExternalAddress.
	lppvoid	Pointer to pointer. Used for functions which take a parameter into which they write
		an address. The corresponding argument must be an ExternalAddress (or other indirection
		object), or an object whose first instance variable is such (e.g. an ExternalStructure).
		The address of the ExternalAddress itself is passed, so that on return it contains the
		address written back by the external function. nil is not a valid argument value.
		As a return type answers a pointer instance of LPVOID (i.e. LPVOID* = void**).
	char	Signed character. Accepts Characters only.
	byte	Unsigned byte. Accepts SmallIntegers only. Passes a 32-bit value
		generated by zero extending the least significant byte. Fails if  not in the
		range 0..255. Zero extends into a positive SmallInteger when a return value.
	sbyte	Signed byte. Accepts SmallIntegers only. Passes a 32-bit value generated
		by sign extending the least significant byte. Fails if not in range -128..127.
		Sign extends into a positive or negative SmallInteger when a return value.
	word 	Unsigned word. As #byte, but 16-bit, acceptable range 0..65535.
		Also accepts a byte object of size 2, which is zero extended to 32-bits.
	sword 	Signed word. As #sbyte, but 16-bit, acceptable range -32768..32767.
		Also accepts a byte object of size 2, which is sign extended to 32-bits.
	dword	Unsigned double word (32-bits), accepts 32-bit Integers. Positive integers
		are passed as unsigned, and negative integers in their two''s complement
		representation.  The largest negative LargeInteger which can be passsed
		is -16r80000000 (or -2147483648) because this is the largest negative number 
		which can be represented in 32-bits in two''s complement notation.
		Also accepts byte objects of length 4, assumed to be in an unsigned bit representation.
		nil is passed as 0. As a return type, answers a SmallInteger, or a LargeInteger if the
		result cannot be represented as a positive SmallInteger (i.e. in 30 bits).
	sdword	Signed double word, accepts any Integer in the range -16r80000000..16r7FFFFFFF
		(i.e. Integer''s with a 32-bit two''s complement representation - all SmallIntegers and
		4-byte LargeIntegers). May also be other byte objects of length 4, which are 
		assumed to contain a 2''s complement 32-bit number.
		As a return type answers a SmallInteger, or, if more than 31-bits are required 
		to represent the two''s complement result, a LargeInteger. Also accepts nil (passed as 0).
	qword	Unsigned quad word. Similar to dword, but 64-bit (i.e. the range is -16r8000000000000000,
		the largest 64-bit two''s complement negative integer, up to 16rFFFFFFFFFFFFFFF the largest positive 
		unsigned 64-bit integer). 8-byte objects are acceptable and assumed to contain the correct unsigned
		bit representation. nil is passed as 0.
	sqword	Signed quad word. Accepts any Integer in the range which can be represented as a
		two''s complement number in 64 bits (i.e. -16r8000000000000000 to 16r7FFFFFFFFFFFFFFF).
		Also accepts 8 byte objects, which are assumed to contain 64-bit two''s complement numbers. 
		nil is passed as 0. As a return type answers the smallest Integer form which can contain 
		the 64-bit two''s complement integer.
	bool	Boolean. As an argument type, accepts true (translated to 1) or false
		(translated to 0). Also accepts SmallInteger values, pushing their host
		machine representation. As a return type, if the result is 0 answers false,
		if the result is non-zero, answers true.
	handle	32-bit handle. Accepts 32-bit integers, nil, or a byte object of size 4. 
		As a return type, answers an ExternalHandle, unless the
		returned handle is NULL, in which case answers ''nil''.
	double	64-bit floating point. Accepts instances of class Float (which contains
		a host machine representation of a double precision floating point number). 
		SmallIntegers may also be passed (they are promoted to the double precision
		floating point representation of their integral value). As a return type,
		answers an instance of class Float.
	lpstr	Pointer to C (null-terminated) ASCII string type. Accepts null terminated byte 
		objects (e.g. Strings, Symbols) or nil (null pointer). When used as a return type, 
		answers a String containing the characters of the C string up to the null terminator. 
		Unlike lpvoid, does not accept integer values as pointers, or ExternalAddress 
		(indirection) objects. If the validation is too tight for your requirements, then 
		use lpvoid. Do not use this return type where an external function is called which 
		expects the caller to assume ownership of the returned string, and to delete it when 
		it is no longer required, as a memory leak will result (use lpvoid instead).
	oop	Object identifier. Any non-SmallInteger can be passed. This parameter type
		is intended for use with the forthcoming User Primitive Kit. The value should
		be treated as an opaque Handle, and should not be stored for later use (it
		may change during a GC). As a return type, answers the object whose Oop is 
		the result. At present it is recommended that you do not use this type.
	float	32-bit floating point. Accepts instances of class Float, or SmallIntegers
		(as #double). The conversion of Floats (64-bit double precision) to #float 
		(32-bit single precision) may result in silent loss of precision. As a return
		type answers an instance of class Float (i.e. promotes to double precision).
	hresult	32-bit signed integer value. Validation as #sdword. As a return type, if less than
		0 (i.e. severity is error), causes the external call primitives to fail with a negative 
		failure reason which is the HRESULT value. This is convenient because it means an
		exception is automatically generated when an external function returns an HRESULT error.
	<struct>	Where <struct> is an ExternalStructure class name. Structure passed by value. Accepts 
		only the exact matching structure class. Again, the ExternalStructure arguments may be
		reference/pointer instances. When used as a return value, an instance of the 
		ExternalStructure class is answered, with the bytes of the returned structure as its contents
		(copied into a ByteArray).
	<struct>*	Where <struct> is an ExternalStructure class name. When used as a return type, a pointer
		instance of the ExternalStructure is answered, with an ExternalAddress pointing at the
		externally stored value as its first instance variable.
	<struct>**Equivalent to lppvoid.
	
Note that in general, the UndefinedObject, nil, is interchangeable with 0, or NULL, when interfacing with external library functions. Nullness can be tested with the #isNull message, with the UndefinedObject and SmallInteger zero answering true.'!
!ExternalDescriptor class methodsFor!

argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which is a String
	specifying a list of argument types in the standard Dolphin format. The return type is
	defaulted to 'uintptr' (i.e. UINT_PTR) and the calling convention to 'stdcall:'."

	^self
		returnType: 'uintptr'
		argumentTypes: argString!

callingConvention: convString returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the arguments
	specifying, respectively, the calling convention, return type, and argument
	types as parseable strings."

	^self fromString: convString, ' ', retString, ' ', argString!

conventionFromName: aString
	"Answer the type name for the specified integer type, or -1 if not recognised."

	^(CallingConventions indexOf: aString)-1!

descriptor: aByteArray literals: aSequenceableCollection
	"Private - Answer an instance of the receiver instantiated from the arguments."

	^(self new: aSequenceableCollection size)
		descriptor: aByteArray;
		literals: aSequenceableCollection;
		yourself!

fromString: aString
	"Answer an instance of the receiver instantiated from the argument, which
	is a Dolphin format external function descriptor, e.g:

		ExternalDescriptor fromString: 'stdcall: hresult Blah GUID* lppvoid'

	Implementation Note: As ExternalDescriptors are immutable, they can be shared
	in order to save space. This facility can be turned off by setting the Shared
	lookup table (which is weak by default) to nil. Bear in mind, however, that
	quite a lot of space might otherwise be occupied by descriptors if there
	are a large number of callback functions in the image."

	Shared isNil ifTrue: [^self newFromString: aString].	
	^Shared at: aString 
		ifAbsentPut: [self newFromString: aString]!

initialize
	"Private - Initialize the class variables of the receiver.
		self initialize
	"

	"Maximum arg type value is currently 63"

	RetTypeMask := ExtCallArgMax.
	self initializeExternalTypes.
	self initializeExternalRefTypes.

	"Remember that bytes and words are still pushed as 32-bit values"
	TypeSizes := #[0 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4 4 4 8 8 4 4 16 8 4 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 4 4 4 0 0 0 0 0 0 0 0].
	TypeSizes whileMutableDo: 
			[TypeSizes
				at: ExtCallArgINTPTR + 1 put: VMConstants.IntPtrSize;
				at: ExtCallArgUINTPTR + 1 put: VMConstants.IntPtrSize].
	self assert: [ExternalValueTypes asSortedCollection last < TypeSizes size].
	self initializeCallingConventions.
	RetClassIndex := 4.
	Shared isNil ifTrue: [Shared := WeakLookupTable new]!

initializeCallingConventions
	"Private - All possible calling conventions (not all are supported)"

	CallingConventions := #('stdcall:' 'cdecl:' 'fastcall:' 'thiscall:')!

initializeExternalRefTypes
	"Private - Reference types are the types to be used for the value type with one level of indirection, where the name
	of a struct class appears, this is assumed to be associated with an ExtCallArgLP argument type."

	ExternalReferenceTypes := Array new: ExtCallArgMax + 1.
	ExternalReferenceTypes
		at: ExtCallArgVOID + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgLPPVOID + 1 put: nil;
		at: ExtCallArgCHAR + 1 put: ExtCallArgLPSTR;
		at: ExtCallArgBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgSBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgWORD + 1 put: #WORD;
		at: ExtCallArgSWORD + 1 put: #SWORD;
		at: ExtCallArgDWORD + 1 put: #DWORD;
		at: ExtCallArgSDWORD + 1 put: #SDWORD;
		at: ExtCallArgUINTPTR + 1 put: #UINT_PTR;
		at: ExtCallArgINTPTR + 1 put: #INT_PTR;
		at: ExtCallArgBOOL + 1 put: #DWORD;
		at: ExtCallArgHANDLE + 1 put: #DWORD;
		at: ExtCallArgDOUBLE + 1 put: #DOUBLE;
		at: ExtCallArgLPSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgOOP + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgFLOAT + 1 put: #FLOAT;
		at: ExtCallArgLPVOID + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgHRESULT + 1 put: #HRESULT;
		at: ExtCallArgLPWSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgQWORD + 1 put: #ULARGE_INTEGER;
		at: ExtCallArgSQWORD + 1 put: #LARGE_INTEGER;
		at: ExtCallArgOTE + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgBSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgVARIANT + 1 put: #VARIANT;
		at: ExtCallArgDATE + 1 put: #DATE;
		at: ExtCallArgVARBOOL + 1 put: #VARIANT_BOOL;
		at: ExtCallArgGUID + 1 put: #REFGUID;
		at: ExtCallArgSTRUCT + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT4 + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT8 + 1 put: ExtCallArgLP!

initializeExternalTypes
	ExternalValueTypes := LookupTable new.
	ExternalValueTypes
		at: 'sdword' put: ExtCallArgSDWORD;
		at: 'dword' put: ExtCallArgDWORD;
		at: 'uintptr' put: ExtCallArgUINTPTR;
		at: 'intptr' put: ExtCallArgINTPTR;
		at: 'lpvoid' put: ExtCallArgLPVOID;
		at: 'handle' put: ExtCallArgHANDLE;
		at: 'lppvoid' put: ExtCallArgLPPVOID;
		at: 'lpstr' put: ExtCallArgLPSTR;
		at: 'bool' put: ExtCallArgBOOL;
		at: 'double' put: ExtCallArgDOUBLE;
		at: 'float' put: ExtCallArgFLOAT;
		at: 'hresult' put: ExtCallArgHRESULT;
		at: 'char' put: ExtCallArgCHAR;
		at: 'byte' put: ExtCallArgBYTE;
		at: 'sbyte' put: ExtCallArgSBYTE;
		at: 'word' put: ExtCallArgWORD;
		at: 'sword' put: ExtCallArgSWORD;
		at: 'oop' put: ExtCallArgOOP;
		at: 'lpwstr' put: ExtCallArgLPWSTR;
		at: 'bstr' put: ExtCallArgBSTR;
		at: 'qword' put: ExtCallArgQWORD;
		at: 'sqword' put: ExtCallArgSQWORD;
		at: 'ote' put: ExtCallArgOTE;
		at: 'variant' put: ExtCallArgVARIANT;
		at: 'varbool' put: ExtCallArgVARBOOL;
		at: 'guid' put: ExtCallArgGUID;
		at: 'date' put: ExtCallArgDATE.
	"void is only valid as a return type, not an argument type."
	ExternalValueTypes at: 'void' put: ExtCallArgVOID.

	"Init the reverse mapping of the type enumeration to string names"
	TypeNames := Array new: ExtCallArgMax + 1.
	ExternalValueTypes 
		keysAndValuesDo: [:eachKey :eachValue | TypeNames at: eachValue + 1 put: eachKey].

	"Convert a few class types to the special types to save space and time"
	ExternalValueTypes
		at: 'ExternalAddress' put: ExtCallArgLPVOID;
		at: 'ExternalHandle' put: ExtCallArgHANDLE;
		at: 'BSTR' put: ExtCallArgBSTR;
		at: 'VARIANT' put: ExtCallArgVARIANT;
		at: 'SDWORD' put: ExtCallArgSDWORD;
		at: 'DWORD' put: ExtCallArgDWORD;
		at: 'INT_PTR' put: ExtCallArgINTPTR;
		at: 'UINT_PTR' put: ExtCallArgUINTPTR;
		at: 'LPVOID' put: ExtCallArgLPVOID;
		at: 'DOUBLE' put: ExtCallArgDOUBLE;
		at: 'FLOAT' put: ExtCallArgFLOAT;
		at: 'HRESULT' put: ExtCallArgHRESULT;
		at: 'BYTE' put: ExtCallArgBYTE;
		at: 'SBYTE' put: ExtCallArgSBYTE;
		at: 'WORD' put: ExtCallArgWORD;
		at: 'SWORD' put: ExtCallArgSWORD;
		at: 'LPWSTR' put: ExtCallArgLPWSTR;
		at: 'QWORD' put: ExtCallArgQWORD;
		at: 'ULARGE_INTEGER' put: ExtCallArgQWORD;
		at: 'SQWORD' put: ExtCallArgSQWORD;
		at: 'LARGE_INTEGER' put: ExtCallArgSQWORD;
		at: 'GUID' put: ExtCallArgGUID;
		at: 'IID' put: ExtCallArgGUID;
		at: 'CLSID' put: ExtCallArgGUID;
		at: 'VARIANT_BOOL' put: ExtCallArgVARBOOL;
		at: 'DATE' put: ExtCallArgDATE;
		shrink!

isPointerToStruct: anInteger 
	^anInteger == ExtCallArgLP or: [anInteger == ExtCallArgCOMPTR]!

nameOf: typeOrdinal type: aClass 
	"Answer the type name for the specified type."

	^(self typeHasArgument: typeOrdinal) 
		ifTrue: 
			[aClass name , (((self isPointerToStruct: typeOrdinal) and: [aClass isIndirection not]) 
						ifTrue: ['*']
						ifFalse: [''])]
		ifFalse: [TypeNames at: typeOrdinal + 1]!

nameOfConvention: anInteger
	"Answer the calling convention name for the specified convention type ordinal."

	^CallingConventions at: anInteger + 1!

newFromString: aString 
	"Private - Answer a new, unshared, instance of the receiver instantiated from 
	the argument, which is a Dolphin format external function descriptor, e.g:

		ExternalDescriptor fromString: 'stdcall: hresult GUID* lppvoid'
	"

	| array |
	array := self parseDescriptor: aString.
	^self descriptor: array first literals: array second!

parseArgDesc: aString 
	"Private - Parse the next argument type from the input stream argument, aStream, answering
	an association between the type number and an optional argument (a subclass of ExternalStructure)."

	| qualifier typeName assoc |
	typeName := aString upTo: $*.
	qualifier := aString rightString: aString size - typeName size.

	"Get an association between a type code for the name and the associated indirection type code or class name"
	assoc := (self typeFromName: typeName ifAbsent: []) 
				ifNil: 
					["Not a built-in type, so try as a class..."
					ExtCallArgSTRUCT -> typeName asSymbol]
				ifNotNil: [:code | code -> (self referenceTypeFor: code)].
	qualifier = '**' ifTrue: [^self parseDoubleIndirection: assoc typeName: typeName].
	qualifier = '*' ifTrue: [^self parseSingleIndirection: assoc].
	^self parseValueType: assoc!

parseCallingConvention: aStream
	"Private - Answer the calling convention number specified by the input stream."

	^self conventionFromName: aStream nextWord!

parseDescriptor: aString 
	"Parse a literal string which describes an external function in the standard
	Dolphin format. This is very simplistic pending Smalltalk compiler support."

	| descriptor literals stream argCount returnType |
	stream := aString readStream.
	descriptor := OrderedCollection new: 10.
	descriptor add: (self parseCallingConvention: stream).
	descriptor add: nil.	"Reserve slot for argument count"
	returnType := self parseArgDesc: stream nextWord.
	descriptor add: returnType key.
	descriptor add: 0.
	literals := OrderedCollection new.
	returnType value notNil ifTrue: [literals add: returnType value].
	argCount := 0.
	stream skipSeparators.
	[stream atEnd] whileFalse: 
			[| argType |
			argType := self parseArgDesc: stream nextWord.
			argCount := argCount + 1.
			descriptor add: argType key.
			argType value notNil 
				ifTrue: 
					[descriptor add: literals size.
					literals add: argType value]].
	descriptor at: 2 put: argCount.
	^Array with: descriptor with: literals!

parseDoubleIndirection: assoc typeName: typeName 
	| pointerType |
	pointerType := assoc value.
	"If indirection type is #lppvoid or an indirection class, then cannot doubly indirect it"
	(pointerType = ExtCallArgLPPVOID or: 
			[pointerType isInteger not and: 
					[assoc key == ExtCallArgSTRUCT 
						and: [(self class environment at: pointerType) isIndirection]]]) 
		ifTrue: 
			[^self error: typeName 
						, ': Only one further level of indirection to an indirection type is possible'].
	^ExtCallArgLPPVOID -> nil!

parsePointerToStruct: anAssociation 
	| structClass |
	structClass := self class environment at: anAssociation value.
	^(structClass isIndirection and: [anAssociation key == ExtCallArgSTRUCT]) 
		ifTrue: [ExtCallArgLPPVOID -> nil]
		ifFalse: 
			[((self class environment at: #IUnknown ifAbsent: []) 
				ifNil: [ExtCallArgLP]
				ifNotNil: 
					[:unkClass | 
					(structClass includesBehavior: unkClass) 
						ifTrue: [ExtCallArgCOMPTR]
						ifFalse: [ExtCallArgLP]]) 
					-> structClass]!

parseSingleIndirection: anAssociation 
	| pointerType |
	pointerType := anAssociation value.
	pointerType isNil 
		ifTrue: 
			[^self error: (self nameOf: anAssociation key type: anAssociation value) 
						, ' cannot be further indirected'].
	^pointerType isInteger not 
		ifTrue: [self parsePointerToStruct: anAssociation]
		ifFalse: [pointerType -> nil]!

parseStructArg: assoc 
	| structClass |
	structClass := self environment at: assoc value.
	^(structClass isIndirection 
		ifTrue: [ExtCallArgLP]
		ifFalse: 
			[| bytes |
			bytes := structClass byteSize.
			bytes <= 4 
				ifTrue: [ExtCallArgSTRUCT4]
				ifFalse: [bytes <= 8 ifTrue: [ExtCallArgSTRUCT8] ifFalse: [ExtCallArgSTRUCT]]]) 
			-> structClass!

parseValueType: assoc 
	assoc key == ExtCallArgSTRUCT ifTrue: [^self parseStructArg: assoc].
	^assoc key -> nil!

referenceTypeFor: valueType 
	^ExternalReferenceTypes at: valueType + 1!

returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which
	is a String specifying a list of argument types in the standard Dolphin
	format. The return type is defaulted to 'dword' and the calling convention
	to 'stdcall:'."

	^self
		callingConvention: 'stdcall:'
		returnType: retString
		argumentTypes: argString!

sizeOf: anInteger type: aClass 
	"Private - Answer the size of the specified type."

	^anInteger == ExtCallArgSTRUCT 
		ifTrue: [aClass byteSize]
		ifFalse: [TypeSizes at: anInteger + 1]!

structTypeForSize: anInteger 
	"Private - Answer the structure type to use for structures of the
	specified byte size."

	^anInteger <= 8 
		ifTrue: 
			[anInteger <= 4 ifTrue: [ExtCallArgSTRUCT4] ifFalse: [ExtCallArgSTRUCT8]]
		ifFalse: [ExtCallArgSTRUCT]!

typeFromName: typeName
	"Answer the type code for the specified <readableString> type name."

	^self typeFromName: typeName ifAbsent: [self errorNotFound: typeName]!

typeFromName: typeName ifAbsent: exceptionHandler 
	"Answer the type code for the specified <readableString> type name, 
	or the result of executing the niladic valuable, exceptionHandler, if the
	type is not recognised."

	^ExternalValueTypes at: typeName ifAbsent: [^exceptionHandler value]!

typeHasArgument: ordinalType
	"Private - Answer whether the specified type (identified by ordinal) has an argument
	accompanying it."

	^ordinalType >= ExtCallArgSTRUCT! !

!ExternalDescriptor methodsFor!

argumentCount
	"Private - Answer the argument count of the external function described by the receiver.
	N.B. This may be one less than the actual number of arguments if the receiver is describing
	a virtual function with implicit 'this' pointer."

	^descriptor at: 2!

argumentIndexFromOffset: anInteger 
	"Private - Convert a zero-based offset into the descriptor array (as used by the VM when marshalling
	the objects onto the stack for an external call) into the index of the corresponding argument. We have
	to take account of the literal indices that are embedded in the descriptor."

	| i offset stop |
	offset := RetClassIndex + 1.
	stop := offset + anInteger.
	i := 0.
	[offset > stop] whileFalse: 
			[| type |
			i := i + 1.
			type := descriptor at: offset.
			offset := offset + 1.
			(self class typeHasArgument: type) ifTrue: [offset := offset + 1]].
	^i!

argumentsDo: operation 
	"Private - Evaluate the dyadic valuable argument, operation, for each of the argument
	types of the receiver, passing the argument type and optional literal parameter#
	as the arguments."

	| i size |
	i := RetClassIndex + 1.
	size := descriptor size.
	[i > size] whileFalse: 
			[| type |
			type := descriptor at: i.
			i := i + 1.
			operation value: type
				value: ((self class typeHasArgument: type) 
						ifTrue: 
							[i := i + 1.
							self at: (descriptor at: i - 1) + 1])]!

argumentsSize
	"Private - Answer the total size, in bytes, that would be occupied by the arguments described 
	by the receiver when pushed onto the machine stack."

	| sum |
	sum := 0.
	self argumentsDo: [:type :class | sum := sum + (self class sizeOf: type type: class)].
	^sum!

argumentTypes
	"Private - Answer a sequenceable collection containing the argument type 
	descriptions for the receiver."

	| types |
	types := OrderedCollection new: self argumentCount.
	self argumentsDo: [:n :type |
		types add: (self class nameOf: n type: type)].
	^types!

calleeCleans
	"Answer whether the receiver describes a function which pops its own arguments
	before returning (e.g. stdcall)."

	^self convention ~= 1	"cdecl is 1"!

callingConvention
	"Private - Answer the calling convention name of the external function described by the receiver.
	This is an integer enumeration."

	^self class nameOfConvention: self convention!

convention
	"Private - Answer the calling convention type (a small integer)."

	^descriptor first!

description
	"Private - Answer the descriptor string for the external function described by the receiver."

	| stream types |
	stream := String writeStream: 60.
	stream
		nextPutAll: self callingConvention;
		space;
		nextPutAll: self returnType.
	types := self argumentTypes.
	"types notEmpty ifTrue: [stream nextPut: $,]."
	types do: 
			[:each | 
			stream
				space;
				nextPutAll: each].
	^stream contents!

descriptor: aCollectionOfBytes
	"Private - Set the descriptor byte array for the external function described by the receiver."

	descriptor := aCollectionOfBytes asByteArray!

literals: args
	"Set the literal argument parameters to those in the SequenceableCollection argument, args.
	Answer the receiver."

	args keysAndValuesDo: [:i :e | self at: i put: e]
	!

name
	"Answer the 'name' of the external function described by the receiver."

	^'_'
	!

name: aString 
	"Set the 'name' of the external function described by the receiver to the argument.
	At the moment we discard this."

	^self!

printOn: aStream
	"Append a debug description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: self description;
		nextPut: $)!

returnType
	"Private - Answer the return type name of the external function described by the receiver.
	This is an integer enumeration."

	| type class |
	type := (descriptor at: 3) bitAnd: RetTypeMask.
	class := (self class typeHasArgument: type) 
				ifTrue: [self at: (descriptor at: RetClassIndex) + 1].
	^self class nameOf: type type: class! !

ExternalLibrary comment:
'ExternalLibrary is the class of objects which represent shared, external, function libraries (i.e. DLLs). Each DLL is represented by a separate subclass, with the methods of that subclass corresponding to functions exported from the DLL. The functions are a special form of primitive method (actually instances of <ExternalMethod>) containing the additional type information needed to interface to statically typed functions. The functions are invoked by sending Smalltalk messages int the normal way, with these being translated by the VM external call primitive to the actual function invocations. The VM coerces the Smalltalk objects passed as arguments to appropriate native types following certain rules (see below). The external call primitive will fail if a type mismatch occurs, and normally this will result in an InvalidExternalCall exception being raised (assuming the #invalidCall method has not been overridden).

External library classes are typically singletons, with the instances representing an "open" (usable) instance of the DLL. The singleton instances are accessible through the class #default method. The libraries are loaded lazily, on demand (but see <PermanentLibrary>).

The external call primitive supports the two most commonly used calling conventions:

	__declspec(cdecl)	- #stdcall
	__declspec(stdcall)	- #cdecl

The "fastcall" calling convention is not currently supported, but this is rarely (if ever) used for exported functions. The C++ "thiscall" calling convention (which passes the ''this'' pointer in the ECX register) is not supported either, but invoking virtual methods of C++ objects (and therefore COM interface methods) is possible - see IUnknown and its subclasses in the "OLE COM" package.

Apart from scalar types, the primitive also supports the passing and returning of structures by value, up to a maximum of 64Kb per structure (though passing such large structures by value is not recommended).

The argument/return types (and coercions) supported are:

	void 	Only valid as a return type - the method answers self
	lpvoid 	General pointer type, accepts byte objects e.g. Strings (pointer to contents 
		passed), nil (null pointer), integers (passes as address), or ExternalAddresses
		(the contained address is passed, not a pointer to the ExternalAddress object). 
		When used as a return type, the method answers an instance of ExternalAddress.
	lppvoid	Pointer to pointer. Used for functions which take a parameter into which they write
		an address. The corresponding argument must be an ExternalAddress (or other indirection
		object), or an object whose first instance variable is such (e.g. an ExternalStructure).
		The address of the ExternalAddress itself is passed, so that on return it contains the
		address written back by the external function. nil is not a valid argument value.
		As a return type answers a pointer instance of LPVOID (i.e. LPVOID* = void**).
	char	Signed character. Accepts Characters only.
	byte	Unsigned byte. Accepts SmallIntegers only. Passes a 32-bit value
		generated by zero extending the least significant byte. Fails if  not in the
		range 0..255. Zero extends into a positive SmallInteger when a return value.
	sbyte	Signed byte. Accepts SmallIntegers only. Passes a 32-bit value generated
		by sign extending the least significant byte. Fails if not in range -128..127.
		Sign extends into a positive or negative SmallInteger when a return value.
	word 	Unsigned word. As #byte, but 16-bit, acceptable range 0..65535.
		Also accepts a byte object of size 2, which is zero extended to 32-bits.
	sword 	Signed word. As #sbyte, but 16-bit, acceptable range -32768..32767.
		Also accepts a byte object of size 2, which is sign extended to 32-bits.
	dword	Unsigned double word (32-bits), accepts 32-bit Integers. Positive integers
		are passed as unsigned, and negative integers in their two''s complement
		representation.  The largest LargeNegativeInteger which can be passsed
		is -16r80000000 (or -2147483648) because this is the largest negative number 
		which can be represented in 32-bits in two''s complement notation.
		Also accepts byte objects of length 4, assumed to be in an unsigned bit representation.
		nil is passed as 0. As a return type, answers a SmallInteger, or a LargePositiveInteger if the
		result cannot be represented as a positive SmallInteger (i.e. in 30 bits).
	sdword	Signed double word, accepts any Integer in the range -16r80000000..16r7FFFFFFF
		(i.e. Integer''s with a 32-bit two''s complement representation - all SmallIntegers, 
		some 4-byte LargePositiveIntegers and LargeNegativeIntegers). May also be other
		byte objects of length 4, which are assumed to contain a 2''s complement 32-bit number.
		As a return type answers a SmallInteger, or if more than 31-bits are required 
		to represent the two''s complement result, a LargePositiveInteger or LargeNegativeInteger 
		depending on sign. Also accepts nil (passed as 0).
	qword	Unsigned quad word. Similar to dword, but 64-bit (i.e. the range is -16r8000000000000000,
		the largest 64-bit two''s complement negative integer, up to 16rFFFFFFFFFFFFFFF the largest positive 
		unsigned 64-bit integer). 8-byte objects are acceptable and assumed to contain the correct unsigned
		bit representation. nil is passed as 0.
	sqword	Signed quad word. Accepts any Integer in the range which can be represented as a
		two''s complement number in 64 bits (i.e. -16r8000000000000000 to 16r7FFFFFFFFFFFFFFF).
		Also accepts 8 byte objects, which are assumed to contain 64-bit two''s complement numbers. 
		nil is passed as 0. As a return type answers the smallest Integer form which can contain 
		the 64-bit two''s complement integer.
	bool	Boolean. As an argument type, accepts true (translated to 1) or false
		(translated to 0). Also accepts SmallInteger values, pushing their host
		machine representation. As a return type, if the result is 0 answers false,
		if the result is non-zero, answers true.
	handle	32-bit handle. Accepts 32-bit integers, nil, or a byte object of size 4. 
		As a return type, answers an ExternalHandle, unless the
		returned handle is NULL, in which case answers ''nil''.
	double	64-bit floating point. Accepts instances of class Float (which contains
		a host machine representation of a double precision floating point number). 
		SmallIntegers may also be passed (they are promoted to the double precision
		floating point representation of their integral value). As a return type,
		answers an instance of class Float.
	lpstr	Pointer to C (null-terminated) ASCII string type. Accepts null terminated byte 
		objects (e.g. Strings, Symbols) or nil (null pointer). When used as a return type, 
		answers a String containing the characters of the C string up to the null terminator. 
		Unlike lpvoid, does not accept integer values as pointers, or ExternalAddress 
		(indirection) objects. If the validation is too tight for your requirements, then 
		use lpvoid. Do not use this return type where an external function is called which 
		expects the caller to assume ownership of the returned string, and to delete it when 
		it is no longer required, as a memory leak will result (use lpvoid instead).
	oop	Object identifier. Any non-SmallInteger can be passed. The value should
		be treated as an opaque Handle, and should not be stored for later use (it
		may change during a GC). As a return type, answers the object whose Oop is 
		the result. At present it is recommended that you do not use this type.
	float	32-bit floating point. Accepts instances of class Float, or SmallIntegers
		(as #double). The conversion of Floats (64-bit double precision) to #float 
		(32-bit single precision) may result in silent loss of precision. As a return
		type answers an instance of class Float (i.e. promotes to double precision).
	hresult	32-bit signed integer value. Validation as #sdword. As a return type, if less than
		0 (i.e. severity is error), causes the external call primitives to fail with a negative 
		failure reason which is the HRESULT value. This is convenient because it means an
		exception is automatically generated when an external function returns an HRESULT error.
	<N>	Where N is the byte size of a pass-by-value structure of unspecified type. Accepts either
		byte objects (of the correct size) or ExternalStructure instances with the correct byteSize
		(or other classes with the same shape as ExternalStructures). ExternalStructures passed
		to such arguments can be reference instances (i.e. ones containing a pointer to the actual
		structure bytes, rather than the structure bytes themselves). As a return type, the result
		is a ByteArray of the specified size.
	<struct>	Where <struct> is an ExternalStructure class name. Structure passed by value. Accepts 
		only the exact matching structure class. Again, the ExternalStructure arguments may be
		reference/pointer instances. When used as a return value, an instance of the 
		ExternalStructure class is answered, with the bytes of the returned structure as its contents
		(copied into a ByteArray).
	<struct>*	Where <struct> is an ExternalStructure class name. When used as a return type, a pointer
		instance of the ExternalStructure is answered, with an ExternalAddress pointing at the
		externally stored value as its first instance variable.
	
Note that in general, the UndefinedObject, nil, is interchangeable with 0, or NULL, when interfacing with external library functions. Nullness can be tested with the #isNull message, with the UndefinedObject and SmallInteger zero answering true.'!
!ExternalLibrary class methodsFor!

clear
	"Private - Clear down cached external function addresses from previous runs. 
	The default instances will be lazily re-opened because their handles will be null
	on image re-start (ExternalHandles are automatically nulled by the VM on image load).
	Similary function addresses will be lazily requeried as required."

	default notNil ifTrue: [default handle: nil].
	self clearMethodDictionary: self methodDictionary.!

clearMethodDictionary: aMethodDictionary
	"Private - Clear down cached proc addresses in the argument, aMethodDictionary."

	aMethodDictionary do: [ :m | m clear ]!

closeAllDefaults
	"Private - Close all open default libraries."
	
	self allSubclasses do: [ :c | c closeDefault ]
!

closeDefault
	"Private - Close the default instance of the receiver (if there is one).
	Having closed it, clear down the default inst var so that any subsequent accesses
	will cause the library to be reopened."

	(default notNil and: [default handle notNull]) 
		ifTrue: 
			[default close.
			default := nil]!

default
	"Answer the default, opened, instance of the receiver."

	default isNil 
		ifTrue: [self openDefault]
		ifFalse: [default asParameter].
	^default!

default: anExternalLibrary
	"Set the default instance of the receiver."

	default := anExternalLibrary!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^self subclassResponsibility!

fromHandle: aHandle
	"Answers an instance of ExternalLibrary attached to aHandle."

	^self new handle: aHandle!

initializeAfterBinaryLoad
	"Private - Perform any post-binary load initialisation for the class. "

	self clear!

load: aString flags: anInteger 
	"Private - Open the external library with the external file name, aString,
	and answer the handle."

	| hLibrary klib flags |
	flags := OSVERSIONINFO current isNT ifTrue: [anInteger] ifFalse: [0].
	klib := KernelLibrary default.
	hLibrary := klib 
				loadLibraryEx: aString
				hFile: nil
				dwFlags: flags.
	^hLibrary ifNil: [Win32Error signal: aString printString]!

moduleFileName: aLibOrHandle
	"Private - Answer the file name of the receiver's loaded module."

	| buf size |
	buf := File pathBuffer.
	size := KernelLibrary default 
			getModuleFileName: aLibOrHandle asParameter 
			lpFilename: buf 
			nSize: buf basicSize.
	^buf resize: size!

onExit
	"Private - Perform shut down processing."

	self closeAllDefaults!

onPreStripImage
	"Private - The image is about to be stripped, close down defaults to allow unused
	subclasses to be stripped."

	self closeAllDefaults!

onStartup
	"Private - Perform session startup processing for the receiver and its subclasses."

	self allSubclasses do: [:c | c clear].
	"If we don't have a handle for the Kernel32.DLL then we can't open any other libraries"
	KernelLibrary openDefault.
	PermanentLibrary onStartup2.
	self onStartup2!

onStartup2
	"Private - Perform session startup processing for the receiver and its subclasses.
	We open the permanent libraries first to make the startup more robust in case of
	errors opening other libraries."

	self subclasses do: [:c | c == PermanentLibrary ifFalse: [c onStartup2]]!

open
	"Answer a new instance of the receiver to represent the receiver's ExternalLibrary. The 
	instance can be used to invoke the functions of the external library specified as instance
	methods"

	^self open: self fileName!

open: aString
	"Answer an instance of the receiver which references the external
	library with the external file name, aString. The library is
	initialized (most libraries don't need any initializing, but you
	get the option)."

	^self new open: aString!

openDefault
	"Private - Open and record the default instance of the receiver.
	Answer the new instance."

	^default := self open!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self default.
	anSTBInFiler register: singleton.
	^singleton!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self closeDefault!

uninitializeBeforeRemove
	"Perform any pre-removal uninitialisation for the class. This includes any specific #uninitialize
	implementation (but note that #uninitialize is only sent to classes which directly implement
	#uninitialize, otherwise we'd probably end up damaging superclasses which are not being
	removed).
	Implementation Note: This is one of those cases where we want subclasses to inherit the
	uninitialize, so override to always call it."

	self uninitialize!

versionInfo
	"Answer a <VersionInfo> containing the version details from the receiver."

	^VersionInfo forPath: self fileName! !

!ExternalLibrary methodsFor!

asParameter
	"Answer the receiver in a form appropriate for passing to an external
	library procedure."

	handle isNull ifTrue: [self open].
	^handle!

basicOpen: aString
	"Private - Open the external library with the external file name, aString,
	as the library referenced by the receiver. Answer the receiver.
	The library is NOT initialized."

	handle := nil.
	self handle: (self class load: aString flags: self loadFlags)!

close
	"Release the reference the receiver has to the External Library it represents. This may
	not cause the library to be unloaded, so it may still function. Answer whether the
	library was successfully closed."

	| success |
	success := handle notNull and: [KernelLibrary default freeLibrary: handle].
	handle := nil.
	^success!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^handle isNull
		ifTrue: [self class fileName]
		ifFalse: [self moduleFileName]!

formatMessage: anIntegerId with: arguments
	"Answer a message formatted from the Win32 format string with the specified
	id in the receiver, with substitutions from the collection, arguments."


	^String formatMessage: anIntegerId in: self asParameter withArguments: arguments!

getProcAddress: aStringOrWord
	"Private - Answer the address of the receiver's procedure named aString."

	^self getProcAddress: aStringOrWord ifAbsent: [self systemError]!

getProcAddress: nameOrOrdinal ifAbsent: exceptionHandler
	"Private - Answer the address of the receiver's procedure named by the <readableString>
	or <integer> ordinal, nameOrOrdinal. If the receiver does not contain a matching
	procedure, then answer the result of evaluation the <niladicValuable> exceptionHandler.."

	| address |
	address := KernelLibrary default getProcAddress: self asParameter lpProcName: nameOrOrdinal.
	^address = 0
		ifTrue: [exceptionHandler value]
		ifFalse: [address]!

handle
	^handle!

handle: aHandle
	"Private - Set the handle of the external library which the receiver represents.
	Answer the receiver."

	handle := aHandle isNil ifFalse: [aHandle asExternalHandle]!

invalidArgErrorClass
	"Private - Answer the class of Error to be signalled when an invalid argument is passed to one of 
	the receiver external functions."

	^InvalidExternalCall!

invalidCall
	"An invalid external call was attempted through one of the receiver's methods.
	Generate an appropriate error from the following categories:
		-	Argument type error. At least one argument was either out of range or of invalid type.
			Only the first such error is reported. The primitive failure result will be >= 16
			if an argument is invalid, the invalid argument number (from 1) being (failure result - 16)+1.
`		-	Invalid receiver (failure result = 0)
		-	Procedure not found (failure result = 1)
		-	System error.
		-	Unknown primitive failure. An uncategorised primitive failure occurred. Seek assistance."

	| error failureCode proc |
	proc := Processor activeProcess.
	failureCode := proc primitiveFailureCode.
	failureCode < 0 ifTrue: [^HRESULTError signalWith: proc primitiveFailureData].
	failureCode >= 16 
		ifTrue: 
			["An invalid argument was passed"

			| frame arg i descriptor |
			frame := proc topFrame sender.
			descriptor := frame method descriptor.
			i := descriptor argumentIndexFromOffset: failureCode - 16.
			arg := frame method isVirtualFunction ifTrue: [i - 1] ifFalse: [i].
			self invalidArgErrorClass 
				invalidArgument: arg
				got: (frame arguments at: arg)
				expected: (descriptor argumentTypes at: i)]
		ifFalse: 
			[failureCode == 0 ifTrue: [^self error: 'invalid receiver'].
			failureCode == 1 
				ifTrue: 
					["Function name not found in the DLL, i.e. failure of GetProcAddress().
					Often caused by omitting the A (for ASCII) or W (for Wide = Unicode) 
					function name suffix. Note that this may be required even if the function
					has no string arguments."

					^Win32Error signalWith: ERROR_PROC_NOT_FOUND]].

	"All arguments were apparently valid (assuming the Smalltalk validation matches the VM's),
	it must have been some system or unknown error."
	error := KernelLibrary default getLastError.
	^error == 0 ifTrue: [self primitiveFailed] ifFalse: [self systemError: error]!

isOpen
	"Answer whether the external library represented by the receiver is open."

	^handle notNull!

loadFlags
	^0!

loadString: anIntegerId
	"Answer the string with the specified id from the receiver's resources."

	^String fromId: anIntegerId in: self!

moduleFileName
	"Private - Answer the file name of the receiver's loaded module."

	^self class moduleFileName: self!

open
	"Private - Open the external library referenced by the receiver. 
	Answer the receiver. The library is NOT initialized."

	self open: self fileName!

open: aString
	"Private - Open the external library with the external file name, aString,
	as the library referenced by the receiver. Answer the receiver.
	The library is initialized."

	(self basicOpen: aString) initialize!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream 
		basicPrint: self; 
		nextPut: $(;
		nextPutAll: (handle isNil ifTrue: ['NULL'] ifFalse: [handle asInteger printStringRadix: 16]);
		nextPutAll: ' - ';
		print: self fileName;
		nextPut: $)!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self!

systemError
	"Generate an error based on the last recorded host system error"

	^Win32Error signal!

systemError: anInteger
	"Generate an error for the host system error, anInteger"

	^HRESULTError signalWith: anInteger!

versionFormatString
	"Private - Answer a String containing the version format used by the receiver.
	The arguments than can be inserted into the string are:
		1) Product name
		2) Product major high word
		3) Product major low word
		4) Product minor high word
		5) Product minor low word
	"

	^'%2!!d!!.%3!!d!! build %4!!d!!'!

versionInfo
	"Answer a <VersionInfo> containing the version details from the receiver."

	^VersionInfo forPath: self moduleFileName!

versionString
	"Answer a version number String in the format used by the receiver,
	(typically N.N Build N, but see #versionFormatString)."

	^self versionInfo formatVersionString: self versionFormatString! !

ExternalStructure comment:
''!
!ExternalStructure class methodsFor!

alignment
	"Answer the natural alignment for instances of the receiver when embedded in arrays or other
	structures. This is the natural alignment of the largest field in the receiver. The actual
	alignment used may be different if the structure packing overrides it."

	self ensureDefined.
	^alignment!

atAddress: anAddress
	"Answer a new instance of the receiver instantiated from the
	data at the specified address. Normally  this will be a 'reference' 
	instance, that points at the data embedded	at the specified address. 
	However in the case of objects that always have reference form
	(e.g. COM interface pointers, BSTRs, etc) this will be a copy
	of the pointer at that address. This is particularly useful for accessing
	elements of arrays."

	^self fromAddress: anAddress!

autoGenCategories
	"Private - Answer a <sequencedReadableCollection> of <MethodCategory>s into 
	which the auto-generated the structure accessors for the receiver should be compiled."

	^Array
		with: self autoGenCategory
		with: self methodCategoryClass public.!

autoGenCategory
	"Private - Answer the basic<MethodCategory>s into which the auto-generated 
	structure accessors for the receiver should be compiled."

	^self methodCategoryClass name: '**compiled accessors**'!

autoGenComment
	"Private - Answer a suitable piece of comment to warn the user that a
	method is automatically generated and should not be modified.
	Implementation Note: As of v2.2 this is empty by default as otherwise
	it tends to lead to rather bloated source files."

	^''!

baseAlignment
	^self == ##(self) ifTrue: [1] ifFalse: [self superclass alignment]!

basicByteSize
	"Answer the size (in bytes) of the structure the receiver represents, or zero if not yet defined."

	^self extraInstanceSpec!

beCompiled
	"Mark the receiver as a structure which is to be compiled"

	flags := flags maskSet: CompiledMask!

beUncompiled
	"Mark the receiver as a structure which is not to be compiled"

	flags := flags maskClear: CompiledMask
!

byteSize
	"Answer the size (in bytes) of the structure the receiver represents"

	self ensureDefined.	"ensure the byte size has been calculated by lazy template accessor"
	^self basicByteSize!

byteSize: anInteger 
	"Private - Set the size (in bytes) of the structure the receiver represents"

	(anInteger between: 0 and: 2 ** 15 - 1) 
		ifFalse: [self error: 'Invalid structure size ' , anInteger displayString].
	self extraInstanceSpec: anInteger!

changedByteSizeFrom: oldByteSize 
	"Private - If the size of the receiver changes such that it fits into a different
	type for passing/returning structures by value, then we must recompile
	all existing referencing methods."

	| newByteSize |
	newByteSize := self byteSize.
	(oldByteSize ~= newByteSize and: 
			[oldByteSize == 0 or: 
					[(self descriptorClass structTypeForSize: oldByteSize) 
						~= (self descriptorClass structTypeForSize: newByteSize)]]) 
		ifTrue: [self recompileReferences]!

clear: addressOrBytes
	"Finalize an instance of the structure which instances of the receiver wrap
	which resides at the specified address. Note that this is not about freeing
	the specified memory block, but any resources which it references."!

compileAllDefinitions
	"Compile the definitions of the receiver and all its subclasses"

	self withAllSubclassesDo: [:each | each compileDefinition].
!

compileDefinition
	"Builds a new template and generates compiled methods for accessing the fields 
	described by it. Depending on the description held in each field, some accessor
	methods may be left as uncompiled to be addressed via the template and 
	#doesNotUnderstand:"

	self
		newTemplate;
		defineTemplate;
		recompileDefinition;
		shrink!

compileGetMethod: aSymbol forField: anExternalField 
	"Private - Generate a compiled 'get' accessor method for the selector aSymbol 
	and field definition anExternalField."

	| methodText remark |
	anExternalField canGenerateAccessor ifFalse: [^self].
	methodText := String writeStream: 256.
	methodText
		nextPutAll: aSymbol;
		crtab;
		nextPutAll: '"Answer the receiver''s ';
		nextPutAll: aSymbol;
		nextPutAll: ' field as a Smalltalk object.'.
	remark := self autoGenComment.
	remark notEmpty 
		ifTrue: 
			[methodText
				crtab;
				nextPutAll: remark].
	methodText
		nextPut: $";
		cr;
		crtab.
	anExternalField printAccessorBody: aSymbol on: methodText.
	self formatAndCompile: methodText contents categories: self autoGenCategories!

compileSetMethod: aSelector forField: anExternalField 
	"Private - Generate a compiled 'set' accessor method for the selector aSymbol 
	and field definition, anExternalField"

	| methodText remark fieldName |
	anExternalField canGenerateMutator ifFalse: [^self].
	methodText := String writeStream: 256.
	fieldName := aSelector allButLast asSymbol.
	methodText
		nextPutAll: aSelector;
		nextPutAll: ' anObject';
		crtab;
		nextPutAll: '"Set the receiver''s ';
		display: fieldName;
		nextPutAll: ' field to the value of anObject.'.
	remark := self autoGenComment.
	remark notEmpty 
		ifTrue: 
			[methodText
				crtab;
				nextPutAll: remark].
	methodText
		nextPut: $";
		cr;
		crtab.
	anExternalField printMutatorBody: fieldName on: methodText.
	self formatAndCompile: methodText contents categories: self autoGenCategories!

contentsAccessText
	"Private - Answer the method text that must be inserted to get access to the
	contents (bytes) of the instances of the receiver"

	^'bytes'!

decompileDefinition
	"Remove generated accessor methods from the receiver, and rebuild the
	structure template"

	[self removeCategory: self autoGenCategory] on: NotFoundError do: [:e | e notify]!

defineField: fieldName type: anExternalField
	"Add the argument anExternalField as the next field of the receiver's template, 
	with the name, fieldName"

	| offset |
	offset :=self structurePacker offsetFor: anExternalField base: self basicByteSize.
	self defineField: fieldName type: anExternalField offset: offset.
!

defineField: fieldName type: anExternalField offset: offset 
	"Add the argument anExternalField as the next field of the receiver's template, 
	with the name, fieldName, and the <integer> byte offset in the structure, offset.
	N.B. This should only be used where the offset is known, note also that the
	byte size is updated if the field is added at the end."

	self isCompiled ifFalse: [anExternalField beUncompiled].
	alignment := alignment max: anExternalField alignment.
	anExternalField offset: offset.
	self byteSize: (self basicByteSize max: offset + anExternalField byteSize).
	"We always retain the read selector in the template - this is needed to calc the field
	offset when compiling methods"
	template at: fieldName asSymbol put: anExternalField.
	anExternalField isWriteable ifTrue: [template at: (fieldName , ':') asSymbol put: anExternalField]!

defineFields
	"Set the structure template for the receiver. Implemented
	by subclasses which wish to make use of the Structure Template
	support"

!

definesNewFields
	"Private - Answer whether the receiver defines any new fields, as opposed to
	just inheriting the lot from a superclass."

	^self class includesSelector: #defineFields!

defineTemplate
	"Initialize the receiver class' structure template.
	Implementation Note: We try and share a superclass template
	if we don't directly implement #defineFields in a particular class.
	This is a space saving measure, and is necessary because 'template' is
	a class instance variable."

	| oldByteSize |
	oldByteSize := self extraInstanceSpec.
	self definesNewFields 
		ifFalse: 
			["Receiver doesn't define any new fields, so inherit the lot"
			self inheritTemplate.
			template notNil ifTrue: [^self changedByteSizeFrom: oldByteSize]].
	alignment := self baseAlignment.
	self
		initializeTemplate;
		defineFields;
		byteSize: (self structurePacker paddedSizeFor: self basicByteSize).
	template shrink.
	self changedByteSizeFrom: oldByteSize!

descriptorClass
	"Private - Return the class of external function descriptor associated with
	the receiver."

	^ExternalDescriptor!

elementSize
	"Answer the size (in bytes) of the structure the receiver represents
	when used as an array element."

	^self byteSize!

ensureDefined
	template isNil ifTrue: [self defineTemplate]	"ensure the structure accessors are correctly defined"!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^StructureField!

formatAndCompile: aString categories: categories 
	| source |
	source := (Smalltalk at: #SmalltalkSystem ifPresent: [:c | c current]) 
				ifNil: [aString]
				ifNotNil: [:devSys | devSys reformatSource: aString in: self].
	"Notification signal: source."
	^self compile: source categories: categories!

fromAddress: anAddress 
	"Answer a new instance that points to the ExternalAddress 
	respresented by anAddress (which responds to the protocol
	#isNull and #asExternalAddress).
	Implementation Note: If anAddress is the null pointer then 
	the answer is nil. This behaviour is useful when referencing
	an ExternalStructure from a PointerField, since such pointers
	are commonly Null."

	^anAddress isNull ifFalse: [self basicNew initializeAtAddress: anAddress]!

fromBytes: aByteObject
	"Answer a new instance of the receiver with contents copied from aByteObject"

	^self new copyBytes: aByteObject!

getFieldList
	"Private - Answer a <sequencedReadableCollection> of the fields defined 
	in the receiver's template, sorted in ascending order of offset from the start of the
	structure."

	| answer |
	answer := OrderedCollection new.
	(self template associations asSortedCollection: [:x :y | x value offset <= y value offset]) 
		do: [:assoc | (assoc key last == $: or: [assoc value isFiller]) ifFalse: [answer add: assoc key]].
	^answer!

hasHandCodedMethodFor: selector
	"Private - Answer whether the receiver appears to have a hand coded implementation
	for the specified selector <Symbol>."

	| method |
	method := self compiledMethodAt: selector ifAbsent: [^false].
	^(self autoGenCategory includesMethod: method) not!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

inheritTemplate
	| ancestor |
	ancestor := self superclass.
	self byteSize: ancestor byteSize.
	template := ancestor template.
	alignment := ancestor alignment!

init: buffer
	"Initialize a buffer (or buffer at the specified address) to hold an instance of the record type
	described by the receiver. Assumes that the memory is completely uninitialized."

	KernelLibrary default zeroMemory: buffer length: self byteSize!

initialize
	"Private - Initialize the receiver class.
		ExternalStructure initialize
	"

	CompiledMask := 16r1.!

initializeAfterBinaryLoad
	"Private - Perform any post-binary load initialisation for the class. 
	Implementation Note: Use the template lazy accessor to cause the template
	to be defined (if not already). This is a non-destructive way to ensure the class
	is initialized."

	self template.
	self register!

initializeAfterLoad
	"Private - Ensure the template is removed. This could have been incorrectly initialised
	during compilation of methods on load that caused the template to be lazily initialised
	BEFORE the #defineFields method had been loaded, or before any pre-requisite structures were
	correctly defined. Therefore we discard any existing template and leave it up to lazy
	initialisation to ensure the templates are built correctly and the relevant methods
	recompiled."

	self resetTemplate.
	super initializeAfterLoad!

initializeTemplate
	"Private - Initialize the template instance variables of the receiver."

	self resetTemplate.
	self newTemplate!

isCompiled
	"Private - Answer whether the receiver is a compiled definition (i.e. methods have been generated
	from the template)."

	^flags anyMask: CompiledMask!

libraryAndIndex
	"Answer an <Asssociation> between an <AXTypeLibraryAnalyzer> on the receiver's type library
	and the index of the receiver's type information in that library, or nil if no type information is
	available."

	^nil!

new
	"Answer a instance of the receiver. This may be either an internal buffer
	(containing a <ByteArray>) or a reference to an external buffer (containing
	a <ExternalAddress>), as appropriate for the subclass. The default is an 
	internal buffer."

	^self newBuffer!

new: anInteger
	"Answer a new instance of the receiver containing a buffer of the specified size.
	N.B. It is not normally necessary to specify the size of an ExternalStructure, because
	the subclasses normally know. However some structures may be of variable length."

	^super new
		initialize: anInteger!

new: anInteger bufferClass: bufferClass
	"Answer a new instance of the receiver containing a buffer of the specified size
	allocated by the specified buffer class."

	^super new
		bytes: (bufferClass newFixed: anInteger);
		initialize;
		yourself
!

newBuffer
	"Answer a new instance containing its own buffer."

	^self new: self byteSize!

newBufferClass: bufferClass
	"Answer a new instance of the receiver containing a buffer of the receiver's size
	allocated by the specified buffer class."

	^self new: self byteSize bufferClass: bufferClass!

newHeapPointer
	"Answer a new instance of the receiver suitable for use as a reference
	to an object allocated by some third party from the heap, but which
	we must free."

	^self basicNew beNullHeapPointer!

newPointer
	"Answer a new instance of the receiver suitable for use as a reference
	to an externally allocated object."

	^self basicNew beNullPointer!

newPointer: pointerClass
	"Answer a new instance of the receiver suitable for use as a reference
	to an externally allocated object, using the specified pointer class (e.g.
	COMTaskMemory)"

	^self basicNew initializeAtAddress: pointerClass new!

newTemplate
	"Private - Reset the template instance variable of the receiver in preparation for loading a
	new template."

	template := IdentityDictionary new!

offsetFor: anExternalField base: anInteger 
	"Answer the adjusted offset for the <ExternalField> from the base offset, anInteger.
	Typically this will round up to some granularity which is the minimum off the field size and
	the structure packing (typically 8) - e.g. 32-bit field typically packed to a four byte
	boundary, a 12-byte structure would be packed to an 8-byte boundary.."

	^anInteger roundUpTo: (anExternalField alignment min: self packing)!

offsetOf: aSymbol 
	"Answer the offset of the named field, or -1 if there is no such field."

	"Implementation Note: We want to avoid realising the template when compiling instance side
	methods before the template definition is available on the class side, so access the inst
	var directly"

	template ifNotNil: [(template at: aSymbol ifAbsent: []) ifNotNil: [:field | ^field offset]].
	^-1!

packing
	"Answer the default packing for instances of the receiver. N.B. This corresponds to the C
	compiler's /Zp parameter, and is the maximum alignment to which members of the structure
	after the first are padded. Each field type has a natural alignment (e.g. ints align to
	32-bit boundaries), and it is the smaller of the packing and the natural alignment which is
	used to decide the padding necessary for the field in the structure. Consider this simple
	example:

	struct S { char ch; int i; };

	1-byte packing (/Zp1) would pack fields on 1 byte boundaries so 'i' would be contiguous with
	'ch', i.e. the offset of 'i' would be 1. 2-byte packing (/Zp2) would align on 2 byte
	boundaries so there would need to be be one byte of padding between 'ch' and 'i', i.e. the
	offset of 'i' would be 2. 4-byte packing would align on 4 byte boundaries so there would
	need to be three bytes of padding between 'ch' and 'i', i.e. the offset of 'i' would be 4,
	making it naturally aligned. 8-byte packing (/Zp8) would be no different to 4-byte in this
	case because the natural alignment of 'i' is 4. If 'i' were an intptr, then seven bytes of
	padding would be needed to align to an 8-byte boundary (i.e. start at offset 8) on a 64-bit
	platform.

	Note that packing a structure so that fields are not aligned naturally can have very
	significant performance impact, particularly on 64-bit platforms.

	For Win32 and Win64 the default packing is 8."

	^8!

paddedSizeFor: size
	"Answer the adjusted size for the receiver rounded up from the 
	<integer>, size. Structures are padded so that there size is rounded
	up to the minimum of their natural alignment (which is the alignment
	of the largest member) and the packing setting 
	You may need to override this (or preferably the #packing method)
	if the external structure is compiled with a different packing (/Zp or 
	#pragma pack)"

	^self offsetFor: self base: size!

pointerClass
	"Private - Answer the default class to use as a pointer"

	^ExternalAddress!

recompileDefinition
	"Private - Recompiles the existing template for the receiver"

	self decompileDefinition.
	self definesNewFields ifFalse: [^self].
	self template keysAndValuesDo: 
			[:selector :field | 
			(self shouldCompile: selector forField: field) 
				ifTrue: 
					[selector last == $: 
						ifTrue: [self compileSetMethod: selector forField: field]
						ifFalse: [self compileGetMethod: selector forField: field]]
				ifFalse: 
					[Notification signal: self name , ': Compiled accessor ' , selector printString , ' not generated']]

!

recompileReferences
	"Private - Recompile all directly referencing external call methods
	that might need to change if the receiver's size changes."

	| binding |
	Notification signal: ('Recompiling references to <1d> (size <2d>)...' expandMacrosWith: self
				with: self basicByteSize).
	"First recompile own methods so that they have the correct offsets encoded"
	(self selectMethods: [:each | each refersToLiteral: #offsetOf:]) do: [:each | each recompile].
	"Then recompile any FFI calls that reference the class in case they are passing/returning by
	value (the calling conventions vary depending on the structure length), OR any methods that
	might be using static expressions to get the byte-size."
	binding := self environment associationAt: self name.
	Smalltalk allBehaviorsDo: 
			[:eachClass | 
			(eachClass whichMethodsReferTo: binding) do: 
					[:eachMethod | 
					(eachMethod isExternalCall or: [eachMethod refersToLiteral: #basicByteSize]) 
						ifTrue: [eachMethod recompile]]]!

register
	"(Re)Register the receiver's as the Record class for its GUID.
	This is used to map VT_RECORD <VARIANT>s and <SAFEARRAY>s
	back to the appropriate <ExternalStructure> class."

	self registerClass: self forGUID: _guid!

registerClass: structureClass forGUID: aGUID
	"Register the specified <ExternalStructure> class as the Record class
	for the specified <GUID>. Any existing registration is first removed.
	If the <GUID> is null, then only the removal occurs."

	| existingKey |
	RecordClasses isNil ifTrue: [^self].
	existingKey := RecordClasses keyAtValue: structureClass ifAbsent: [].
	existingKey isNil ifFalse: [RecordClasses removeKey: existingKey].
	aGUID isNull ifFalse: [RecordClasses at: aGUID put: structureClass]!

resetTemplate
	self byteSize: 0.
	flags := CompiledMask.
	template := nil!

setGuid: aGUID
	"Private - Set the value of the receiver's 'guid' instance variable to the 
	<GUID>, aGUID.
	Implementation Note: Override to register the structure in the table mapping GUIDs
	to record classes."

	_guid ~= aGUID ifTrue: [
		super setGuid: aGUID.
		self register]
!

shouldCompile: selector forField: anExternalField
	"Private - Answer whether to compile an accessor method
	with the specified selector for the specified field in the
	receiver."

	^anExternalField canGenerateAccessors 
		and: [(self hasHandCodedMethodFor: selector) not		"Don't overwrite manually written methods"
			and: ["Don't generate inherited fields unless specifically marked for override"
				anExternalField isOverride or: [
					(self superclass template includesKey: (selector upTo: $:) asSymbol) not]]]!

shrink
	"Private - Reduce the size of the structure template by removing the write accessors.
	This should only be done to compiled structures."

	self template keysAndValuesDo: [:k :f |
		(k last == $: and: [f canGenerateMutator])
			ifTrue: [self template removeKey: k]]

	!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	self ensureDefined.
	^super stbReadFrom: anSTBInFiler format: anSTBClassConversion!

structurePacker
	"Answer the object which implements the structure packing algorithm
	for use with the receiver.  The object must respond to the <structurePacker>
	protocol."

	^self!

template
	"Private - Answer the receiver's structure template (defines the types and 
	offsets of the fields)"

	self ensureDefined.
	^template!

understoodSelectors
	"Answer a Set of all message selectors understood by the receiver, not including those understood because
	they are implemented in superclasses. This should however include those that are not in the method dictionary
	but will be understood as a result of #doesNotUnderstand: processing, if that is possible."

	^(IdentitySet withAll: super understoodSelectors)
		addAll: self template keys;
		yourself!

uninitializeBeforeRemove
	"Perform any pre-removal uninitialisation for the class.
	We need to unregister all subclasses as they are removed. This
	can't be done by #uninitialize since this only gets sent to classes
	that explicitly implement it; i.e. it is not inherited by our subclasses."

	_guid notNil ifTrue: [self unregister].
	template := _guid := nil.
	super uninitializeBeforeRemove!

unregister
	"Unregister the receiver as a Record class for its guid."

	(_guid notNil and: [RecordClasses notNil]) ifTrue: [
		RecordClasses removeKey: _guid ifAbsent: []]! !

!ExternalStructure methodsFor!

_deepenShallowCopy: clone trail: copiesDictionary
	"Private - Deepen the argument, clone, which is a shallow copy of the receiver.
	Answer the deepened shallow copy (or another object to represent the deep copy
	if you so desire - though if you do this you must update the copiesDictionary).
	We need to override this in order to correctly deepen the contents instance
	variable which might be an external address - if so we copy the data pointed
	at, so that the clone is a true deep copy, and does not reference any of the
	same data as the receiver."

	self isNull 
		ifFalse: 
			["Create a new copy of the internal/referenced data"

			clone
				initialize: self byteSize;
				copyBytes: bytes].
	"Use the standard implementation for the rest of the object"
	2 to: self class instSize + self basicSize
		do: [:i | clone instVarAt: i put: ((clone instVarAt: i) _deepCopy: copiesDictionary)].
	^clone!

= anExternalStructure
	"Answer whether the receiver is equivalent to anExternalStructure.
	Two external structures are considered equivalent if they are of 
	the same type, and they contain the same bytes."

	^self == anExternalStructure or: 
			[self species == anExternalStructure species and: 
					[| isNull |
					(isNull := self isNull) == anExternalStructure isNull and: 
							[isNull or: 
									[(CRTLibrary default 
										memcmp: self
										buf2: anExternalStructure
										count: self comparisonSize) == 0]]]]!

alignment
	"Answer the alignment required for instances of the receiver when 
	embedded in arrays or other structures"

	^self class alignment!

asByteArray
	"Answer the raw contents of the receiver as a byte array."

	^self copyFrom: 1 to: self byteSize!

asObject
	"Answer the <Object> value represented by the receiver."

	^self value!

asParameter
	"Answer the receiver in a form suitable for passing
	to an ExternalLibrary call. Although ExternalStructures can be passed to 
	#lpvoid parameter types directly, it is more useful if we answer the contents
	as this allows, for example, DWORDs to be passed as #dword parameters."

	^bytes!

basicFree
	"Private - Free external resources owned by the receiver.
	This is a default implementation which relieves subclasses from
	the responsibility of providing both class (freeElement:) and instance 
	side (#basicFree) methods."

	self class clear: bytes!

beNullHeapPointer
	"Private - Set the receiver's contents to be a NULL heap pointer."

	self initializeAtAddress: self heapPointerClass new!

beNullPointer
	"Private - Set the receiver's contents to be a NULL pointer."

	self initializeAtAddress: self pointerClass new!

bufferClass
	"Private - Answer the default class to use as a contents buffer"

	^ByteArray!

bytes
	"Answer the byte buffer which the receiver represents (a (sub)instance of ExternalBytes)."

	^bytes!

bytes: aByteObject
	"Private - Set the contents of the receiver. Answer the receiver."

	bytes := aByteObject!

bytesAtOffset: anInteger put: anExternalStructureOrByteObject
	"Replace the bytes of the receiver from offset anInteger (0 based)
	with those of the argument aVariableByteObject"

	anExternalStructureOrByteObject
		replaceBytesOf: self bytes
		from: anInteger+1 
		to: anInteger + anExternalStructureOrByteObject size
		startingAt: 1!

byteSize
	"Answer the size in bytes of this structure"

	^self class byteSize!

comparisonSize
	"Private - Answer the number of bytes of the receiver to use in comparisons.
	This may be slightly less than the #byteSize in order to exclude any padding
	bytes that are present to fill the structure out to its packing boundary.
	Subclasses should override as necessary."

	^self byteSize!

copy
	"Answer a suitable copy of the receiver, which does not share the same byte data."

	^super copy
		initialize: self byteSize;
		copyBytes: bytes;
		yourself!

copy: aByteClass from: start to: stop 
	"Private - Answer a copy of the bytes of the receiver starting at index start, 
	until index stop, inclusive, as an instance of the argument, aByteClass."

	| len |
	len := stop - start + 1.
	^self 
		replaceBytesOf: (aByteClass new: len)
		from: 1
		to: len
		startingAt: start!

copyBytes: aByteObject
	"Private - Set the contents of the receiver (as appropriate for the subclass).
	Answer the receiver."

	aByteObject replaceBytesOf: self bytes from: 1 to: self byteSize startingAt: 1!

copyFrom: start to: stop
	"Answer a copy of the bytes of the receiver starting at index start, 
	until index stop, inclusive."

	^self copy: ByteArray from: start to: stop!

copyStringFrom: start to: stop
	"Answer a copy of the bytes of the receiver starting at index start, 
	until index stop, inclusive, as a String."

	^self copy: String from: start to: stop!

detach
	"Detach the receiver from the object at which it is pointing, answering the address
	of that object. This is useful where one wishes to take-over ownership of an object
	which would otherwise be cleaned up when the receiver is finalized."

	| detached |
	detached := self bytes.
	bytes := nil. 
	self beUnfinalizable.	"reduce Memory Manager load"
	^detached!

doesNotUnderstand: aMessage 
	"Sent to the receiver by the VM when a message sent to the receiver was 
	not implemented by the receiver or its superclasses. In this case then the 
	selector of aMessage is looked up in the receiver's class' template, and 
	if found the appropriate field is retrieved/set."

	| args field |
	args := aMessage arguments.
	field := self template at: aMessage selector ifAbsent: [^super doesNotUnderstand: aMessage].
	^args size == 0 
		ifTrue: 
			[field isReadable ifTrue: [field readFrom: self bytes] ifFalse: [super doesNotUnderstand: aMessage]]
		ifFalse: [field writeInto: self bytes value: (args at: 1)]!

fieldsDo: aMonadicValuable 
	"Evaluate the <monadicValuable> argument, operation, for each of the receiver's fields."

	self getValidFields do: [:field | aMonadicValuable value: (self getField: field)]!

fieldsDo: aMonadicValuable separatedBy: aNiladicValuable 
	"Evaluate the <monadicValuable> argument for each of the receiver's fields, interspersed
	with evaluations of the <niladicValuable> argument. The separator is first evaluated after
	the first field, and is not evaluated after the last."

	self getValidFields do: [:field | aMonadicValuable value: (self getField: field)]
		separatedBy: aNiladicValuable!

free
	"Free external resources owned by the receiver.
	Implementation Note: Whether we free the data or not we must
	make sure that we remove any lock for which we are responsible."

	self needsFree
		ifTrue: [self basicFree].
	bytes := nil.
	self beUnfinalizable	"finalization no longer required"!

getField: fieldNameString
	"Answer the value of the named field of the receiver,
	or if there is no such field then raise an exception."

	^self perform: fieldNameString asSymbol!

getValidFields
	"Private - Answer a <sequencedReadableCollection> of the fields defined 
	in the receiver's template, sorted in ascending order of offset from the start of the
	structure, that are valid in this particular instance (some Windows structures
	have a mask field which identifies which of the other fields have been 
	initialized with a value)."

	^self class getFieldList!

hash
	"Answer the SmallInteger hash value for the receiver.
	In order for internal structure to have the same value as pointer structures
	we use the VM export here."

	^VMLibrary default hashBytes: bytes count: self comparisonSize!

heapPointerClass
	"Private - Answer the default class to use as a heap pointer"

	^ExternalMemory!

hresultError: anInteger
	"Signal that a member function in the receiver returned the specified
	hresult."

	^HRESULTError signalWith: anInteger!

initialize
	"Private - Perform any initialization required for the receiver
	which is specific to the value form. Answer the receiver.
	To perform reference specific initialization, override #initializePointer."
!

initialize: anInteger
	"Private - Create an external buffer in the receiver of the specified size.
	Some subclasses, particularly for Win32 structures, may want to override
	to set their first member to their size."

	bytes := self bufferClass newFixed: anInteger.
	self initialize!

initializeAtAddress: anAddress
	"Private - Initialize the receiver to be a reference to an ExternalStructure
	of the receiver's type at the specified address. Any modifications to the 
	receiver will be reflected back into the structure/object at anAddress."

	self class ensureDefined.
	bytes := anAddress asExternalAddress.
	self initializePointer!

initializePointer
	"Private - Perform any initialization required for the receiver
	which is specific to the reference form. Answer the receiver.
	To perform value specific initialization, override #initialize."!

invalidArgErrorClass
	"Private - Answer the class of Error to be signalled when an argument to one of the receiver's
	external calls is invalid."

	^InvalidExternalCall
!

invalidCall
	"An invalid virtual call was attempted through one of the receiver's methods.
	Generate an appropriate error from the following categories:
		-	Argument type error. At least one argument was either out of range or of invalid type.
			Only the first such error is reported.
		-	Unknown primitive failure. An uncategorised primitive failure occurred. Seek assistance."

	| failureCode proc |
	proc := Processor activeProcess.
	(failureCode := proc primitiveFailureCode) < 0 ifTrue: [^self hresultError: proc primitiveFailureData].
	failureCode >= 16 
		ifTrue: 
			[| frame i arg descriptor |
			frame := proc topFrame sender.
			descriptor := frame method descriptor.
			i := descriptor argumentIndexFromOffset: failureCode - 16.
			arg := frame method isVirtualFunction ifTrue: [i - 1] ifFalse: [i].
			self invalidArgErrorClass 
				invalidArgument: arg
				got: (frame arguments at: arg)
				expected: (descriptor argumentTypes at: i)].	"One of the arguments was invalid?"

	"All arguments were apparently valid, it must have been some system or unknown error."
	^self primitiveFailed!

isNull
	"Answer whether the receiver is a null external data item
	(that is, a null pointer, or a nilled out structure)."

	<primitive: 170>
	^bytes isNull!

isPointer
	"Answer whether the receiver is a pointer to an external data item."

	^bytes class isIndirection!

maxPrint
	"Private - Answer the maximum number of characters to output when appending the 
	receiver's textual representation to a Stream"

	^500!

needsFree
	"Private - Answer whether the receiver requires freeing of any external resources."

	^false!

notNull
	"Answer whether the receiver is not Null (i.e. not equal to 0)"

	^self isNull == false!

pointerClass
	"Private - Answer the default class to use as a pointer"

	^ExternalAddress!

printArgumentTypeOn: aStream
	"Private - Append a compilable argument type name, which is the receiver, to aStream."

	self class displayOn: aStream.
	self isPointer ifTrue: [aStream nextPut: $*]!

printCyclicRefOn: aStream
	"Private - Append to the argument, aStream, a String whose characters describe
	a cyclic (or recursive) reference to the receiver. Used by some
	printOn: methods (e.g. see Collection) to prevent an infinite recursion."

	aStream nextPutAll: '... a cyclic ref to '.
	self basicPrintOn: aStream.
	aStream nextPutAll: '...'!

printFieldsOn: aStream limit: anInteger 
	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: 
			[self getValidFields do: 
					[:field | 
					aStream position > anInteger 
						ifTrue: 
							[aStream nextPutAll: '... etc ...'.
							^self].
					aStream
						display: field;
						nextPutAll: '=';
						print: (self getField: field)]
				separatedBy: [aStream space]]!

printOn: aStream 
	"Append a textual representation of the receiver to aStream.
	We use the template definition to do this in a generic way for all correctly 
	defined subclasses. Fields are printed in the order of their offset"

	| printed |
	printed := Processor activeProcess _alreadyPrinted.
	(printed includes: self) ifTrue: [^self printCyclicRefOn: aStream].
	printed add: self.
	
	[| tooMany |
	tooMany := aStream position + self maxPrint.
	super printOn: aStream.
	aStream nextPut: $(.
	self printFieldsOn: aStream limit: tooMany.
	aStream nextPut: $)] 
			ensure: [printed remove: self ifAbsent: []]!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched."

	^bytes replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart!

replaceFrom: start to: stop  with: aByteObject startingAt: fromStart
	"Standard method for transfering bytes from one variable
	byte object to another. See String>>replaceFrom:to:with:startingAt:"

	aByteObject replaceBytesOf: self bytes from: start to: stop startingAt: fromStart!

setField: fieldNameString value: anObject
	"Set the value of the named field of the receiver,
	or if there is no such field then raise an exception."

	^self perform: (fieldNameString, ':') asSymbol with: anObject!

size
	"Answer the size of the receiver's contents (more useful)."

	^self byteSize!

template
	"Private - Answer the receiver's structure template (defines the types and 
	offsets of the fields). Can be overridden by subclasses which wish to vary	
	the template on an instance specific basis, e.g. for a generic structure
	class."

	^self class template!

value
	"Answer the receiver's value field as an equivalent Smalltalk object."

	^self!

value: anObject
	"Set the value buffered by the receiver to anObject."

	^self copyBytes: anObject!

yourAddress
	"Answer the address of the receiver's contents"

	^bytes yourAddress! !

File comment:
''!
!File class methodsFor!

appendPathDelimiter: aString 
	"Answer a <readableString> that is the argument with a path separator appended to create the correct syntax for
	a path. If aString already ends in a path separator then the answer is equivalent."

	(aString notEmpty 
		and: [self pathDelimiters identityIncludes: aString last]) 
			ifTrue: [^aString].
	^aString copyWith: self pathDelimiter!

attributes: aFileNameString
	^KernelLibrary default getFileAttributes: aFileNameString!

change: aPathnameString extension: anExtensionString
 	"Changes the extension of aPathnameString to anExtensionString.
	Answers the new filename"

	| components |
	components := self splitPath: aPathnameString.
	components at: 4 put: anExtensionString.
	^self makePath: components!

commonPrefixOf: path1 and: path2
	"Answer the <readableString> common prefix shared between the two paths.
	This will be empty if the paths share no common prefix."

	| prefix len |
	prefix := File pathBuffer.
	len := ShlwapiLibrary default 
			pathCommonPrefix: path1 
			pszFile2: path2
			achPath: prefix.
	^prefix copyFrom: 1 to: len!

composePath: aPathString stem: aStemString extension: anExtensionString
	"Composes a full pathname from its components. The path or extension components 
	can be nil if necessary. The path can include the drive letter."

	^self makePath: (Array with: nil with: aPathString with: aStemString with: anExtensionString)
	!

composePath: path subPath: subpath
	"Composes a full pathname from path and subpath components."

	| fullName |
	fullName := self pathBuffer.
	^ShlwapiLibrary default pathCombine: fullName lpszDir: path lpszFile: subpath!

composeShortStem: aStemString extension: anExtensionString 
	"Answer a String which is a file name abbreviated from aStemString and anExtensionString.
	Lower case vowels are dropped from the right of aStemString until it is less than
	or equal to 8 characters.
	If still longer than 8 chars, then other lowercase letters are dropped from the
	right of the stem until it is less than or equal to 8 characters."

	| stemResult extResult |
	stemResult := self shortenComponent: aStemString max: 8.
	extResult := self shortenComponent: anExtensionString max: 3.
	^self composeStem: stemResult extension: extResult!

composeStem: aStemString extension: anExtensionString
	"Composes a full pathname from aStemString and anExtensionString components.
	Implementation Note: This could be implemented in terms of #composePath:stem:extension:,
	which ultimately is implemented in terms of #makePath:, however it is a very frequently
	used method so an optimized version which takes advantage of private knowledge of
	how file names are constructed is warranted. Note that the dot separator may be
	specified in the extension, or not."

	^anExtensionString first == $.
		ifTrue: [aStemString, anExtensionString]
		ifFalse: [aStemString, '.', anExtensionString]!

copy: oldFileNameString to: newFileNameString
	"Copy the file specified by oldFileNameString to newFileNameString.
	Signal a HostSystemError if the copy fails."

	(KernelLibrary default copyFile: oldFileNameString lpNewFileName: newFileNameString bfailIfExists: false)
		ifFalse: [KernelLibrary default systemError: Processor activeProcess lastError]!

createDirectory: path
	"Create a directory with the specified path.
	Answer whether the directory was actually created, or already existed.
	Raise a Win32Error if the call fails for any other reason than that the
	directory already exists."

	| kernel |
	kernel := KernelLibrary default. 
	^(kernel createDirectory: path lpSecurityAttributes: nil)
		or: [ | err |
			err := kernel getLastError.
			err = ERROR_ALREADY_EXISTS
				ifFalse: [^kernel systemError: err].
			false "already existed"]!

createDirectoryPath: path 
	"Create a directory tree with the specified path - i.e. this will create a nested set of directories
	to any depth. Answer true if the final directory 	was actually created, or false if it already existed. 
	Raise a Win32Error if the call fails for any other reason than that the directory already exists.
	Implementation Note: This may attempt more directory creation operations than are necessary,
	(e.g. to create the root directory if a drive is specified) but such requests are ignored."

	| delims pos created len |
	created := false.
	len := path size.
	delims := self pathDelimiters.
	(path beginsWith: '\\') 
		ifTrue: 
			[pos := 3.
			2 timesRepeat: 
					["Skip UNC machine name and share"

					pos := path indexOfAnyOf: delims startingAt: pos.
					pos == 0 ifTrue: [^Win32Error signalWith: ERROR_INVALID_NAME].
					pos := pos + 1]]
		ifFalse: [pos := 1].
	[pos <= len] whileTrue: 
			[| end |
			end := path indexOfAnyOf: delims startingAt: pos.
			end == 0 ifTrue: [end := len + 1].
			end == 1 
				ifFalse: 
					[| part |
					(part := path copyFrom: 1 to: end - 1) last == $: 
						ifFalse: 
							["Don't attempt to create the drive!!"

							created := self createDirectory: part]].
			pos := end + 1].
	^created!

default: aPathnameString extension: anExtensionString
 	"Defaults the extension of aPathnameString to anExtensionString if there is no current extension.
	Answers the new filename"

	| components |
	components := self splitPath: aPathnameString.
	components last isEmpty ifTrue: [components at: 4 put: anExtensionString].
	^self makePath: components!

delete: aFileNameString
	"Deletes the file whose name is specified by aFileNameString.
	Signal a Win32Error if the operation fails."

	(KernelLibrary default deleteFile: aFileNameString) 
		ifFalse: [KernelLibrary default systemError]!

deleteDirectory: aString
	"Recursively delete all files and folders within the specified directory, and
	remove the directory itself."

	self 
		forAll: '*.*'
		in: aString
		do: 
			[:each | 
			each isDirectory 
				ifTrue: 
					[| filename |
					filename := each fileName.
					(filename = '.' or: [filename = '..']) 
						ifFalse: [self deleteDirectory: each path]]
				ifFalse: [self delete: each path]].
	^self removeDirectory: aString!

exists: aFileNameString
	"Answer true if there is a file whose specification is given by aFileName."

	^(self attributes: aFileNameString) ~= -1!

extensionDelimiter
	"Answers the character that delimits a filename from its extension"

	^ $.!

find: fileSpec
	"Answer a collection of WIN32_FIND_DATA structs for each file matching the 
	wildcarded path string, fileSpec. e.g:

		| list |
		list := ListPresenter show.
		list list: ((File find: '*.*') collect: [:s | s fileName])
	"

	| answer |
	answer := OrderedCollection new.
	self for: fileSpec do: [:s | answer add: s copy].
	^answer!

for: aString do: operation
	"For each file/directory matching the wildcarded path string argument, aString, 
	evaluate the monadic valuable, operation, with a WIN32_FIND_DATA describing 
	the file/directory as the argument."

	^self 
		for: aString
		in: (File splitPathFrom: aString)
		do: operation!

for: matchString in: dirString do: operation 
	"For each file/directory matching the wildcarded string argument, matchString, 
	in the directory named, dirString, evaluate the monadic valuable, operation, with 
	a WIN32_FIND_DATA describing the file/directory as the argument."

	| lib handle findStruct |
	lib := KernelLibrary default.
	findStruct := WIN32_FIND_DATA new.
	findStruct directory: dirString.
	handle := lib findFirstFile: (File composePath: dirString subPath: matchString)
				lpFindFileData: findStruct.
	handle = INVALID_HANDLE_VALUE 
		ifTrue: 
			[| err |
			err := lib getLastError.
			^(err == ERROR_FILE_NOT_FOUND or: [err == ERROR_ACCESS_DENIED]) 
				ifTrue: [self]
				ifFalse: [lib systemError: err]].
	
	[| error |
	
	[operation value: findStruct.
	lib findNextFile: handle lpFindFileData: findStruct] 
			whileTrue.
	error := lib getLastError.
	error = ERROR_NO_MORE_FILES ifFalse: [^lib systemError: error]] 
			ensure: [lib findClose: handle]!

forAll: matchString in: dirString do: operation
	"For each file or directory matching the wildcarded path string, fileSpec, 
	in and below the directory identified by the <readableString>, dir, evaluate 
	the <monadicValuable>, operation, with a WIN32_FIND_DATA describing 
	the file/directory as the argument."

	self 
		for: matchString
		in: dirString
		do: [:each | operation value: each].
	self forDirectoriesIn: dirString
		do: 
			[:each | 
			self 
				forAll: matchString
				in: each path
				do: operation]!

forAllDirectories: matchString in: pathString do: operation 
	"For each directory whose name matches the wildcarded <readableString> argument,
	matchString, in the directory identified by the <readableString> argument, pathString,
	(and recursively below that), evaluate the monadic valuable, operation, with a 
	WIN32_FIND_DATA describing the directory as the argument."

	"Implementation Note: The tree traversal is pre-order, depth-first."

	self 
		forDirectories: matchString
		in: pathString
		do: 
			[:each | 
			operation value: each.
			self 
				forAllDirectories: matchString
				in: each path
				do: operation]!

forAllDirectoriesIn: aString do: operation
	"For each directory in the directory identified by the <readableString> argument,
	and recursively below that, evaluate the monadic valuable, operation, with a 
	WIN32_FIND_DATA describing the directory as the argument.
	Implementation Note: The tree traversal is pre-order, depth-first."

	^self 
		forAllDirectories: '*.*'
		in: aString
		do: operation!

forDirectories: matchString in: dirString do: operation
	"For each directory in the directory identified by the <readableString> argument, 
	dir, evaluate the monadic valuable, operation, with a WIN32_FIND_DATA describing the 
	directory as the argument."

	self 
		for: matchString
		in: dirString
		do: 
			[:each | 
			(each isDirectory and: 
					[| fileName |
					fileName := each fileName.
					fileName ~= '.' and: [fileName ~= '..']]) 
				ifTrue: [operation value: each]]!

forDirectoriesIn: aString do: operation
	"For each directory in the directory identified by the <readableString> argument 
	evaluate the monadic valuable, operation, with a WIN32_FIND_DATA describing the 
	directory as the argument."

	^self 
		forDirectories: '*.*'
		in: aString
		do: operation!

fromHandle: aHandle 
	"Answer a new instance of the receiver on the specified file handle.
	The instance will not automatically close the handle before it is GC'd (it assumes
	it does not own it)."

	^(super new)
		setHandle: aHandle asExternalHandle flags: ##(GENERIC_READ | GENERIC_WRITE);
		yourself!

fullPathOf: aPathnameString
	"Answers the full path of aPathnameString"

	| fullpath |
	fullpath := String new: self maxPath.
	((KernelLibrary default getFullPathName: aPathnameString 
		nBufferLength: fullpath size lpBuffer: fullpath lpFilePart: nil)==0) ifTrue: [
			KernelLibrary default systemError].
	^fullpath trimNulls!

fullPathOf: aPathnameString relativeTo: aBasePathString
	"Answers the full path of aPathnameString. If this is a truly relative
	path then it is formed as relative to aBasePathString"

	| actualPath |
	actualPath := (self isRelativePath: aPathnameString) 
		ifTrue: [self composePath: aBasePathString subPath: aPathnameString]
		ifFalse: [aPathnameString].
	^self fullPathOf: actualPath
!

initialize
	"Initialize the Class Variables of the receiver:
		File initialize

		OpenFlagsMask		Mask to extract the open mode flags.
		ShareModes		Map between portable share mode symbols and Win32 flag values.
		CheckModes	 	Map between portable access mode symbols and Win32 flag values 
						with error checking.
		NoCheckModes		Ditto, without error checking."

	OpenFlagsMask := 2r111.
	ShareModes := ##(
		IdentityDictionary new
			at: #read			put: FILE_SHARE_READ;
			at: #write		put: FILE_SHARE_WRITE;
			at: #readWrite		put: FILE_SHARE_READ | FILE_SHARE_WRITE;
			at: #exclusive		put: 0;
			shrink;
			yourself).
	
	CheckModes := ##(
		IdentityDictionary new
			at: #read			put: OPEN_EXISTING | GENERIC_READ;
			at: #create		put: CREATE_NEW | GENERIC_READ | GENERIC_WRITE;
			"open will only ever open an existing file"
			at: #open			put: OPEN_EXISTING | GENERIC_READ | GENERIC_WRITE;
			at: #append		put: OPEN_EXISTING | GENERIC_READ | GENERIC_WRITE;
			at: #truncate		put: TRUNCATE_EXISTING | GENERIC_READ | GENERIC_WRITE;
			shrink;
			yourself).

	NoCheckModes := ##(
		IdentityDictionary new
			"No check read is a bit of a nonsense, but ..."
			at: #read			put: OPEN_ALWAYS | GENERIC_READ;
			at: #create		put: OPEN_ALWAYS | GENERIC_READ | GENERIC_WRITE;
			at: #open			put: OPEN_ALWAYS | GENERIC_READ | GENERIC_WRITE;
			at: #append		put: OPEN_ALWAYS | GENERIC_READ | GENERIC_WRITE;
			at: #truncate		put: CREATE_ALWAYS | GENERIC_READ | GENERIC_WRITE;
			shrink;
			yourself)!

isDirectory: aString
	"Answer true if there is a directory whose path is given by aString."

	| attribs |
	attribs := self attributes: aString.
	^attribs ~= -1 and: [attribs allMask: FILE_ATTRIBUTE_DIRECTORY]!

isRelativePath: aFileNameString
	"Answers true if aFileNameString is a relative path with no absolute components"

	^ShlwapiLibrary default pathIsRelative: aFileNameString
!

isRootPath: aString
	"Answer whether the <String> argument is a root path, e.g. 'c:\'"

	^ShlwapiLibrary default pathIsRoot: aString!

isWriteable: aString 
	"Answer whether the file at the specified path is writeable. If there is no such file, then
	the answer will be true. If there file exists then the answer is based on file's attributes
	- i.e. whether or not it has the read-only flag set. Note that file permissions are not
	taken into account, so even if the answer is true a subsequent attempt to open the file for
	writing may fail."

	| attributes |
	attributes := KernelLibrary default getFileAttributes: aString.
	^(attributes ~= -1 and: [attributes allMask: FILE_ATTRIBUTE_READONLY]) not!

isWriteable: aFileNameString set: aBoolean
	"Set the writeable state of aFileNameString to aBoolean. Answers true if the
	operation succeeds"

	| mode |
	mode := aBoolean ifTrue: [ _S_IWRITE ] ifFalse: [ _S_IREAD ].
	^(CRTLibrary default _chmod: aFileNameString pmode: mode)=0!

lastWriteTime: aString 
	"Answer a <FILETIME> representing the time when the file with the specified filename was
	last modified, or nil if no such file exists."

	| file |
	(self exists: aString) ifFalse: [^nil].
	file := File 
				open: aString
				mode: #read
				check: true
				share: #read.
	^[file lastWriteTime] ensure: [file close]!

locateFilename: aFilenameString in: searchPath 
	"Answers the full pathname of aFilenameString searched for in the ordered collection
	of paths provided in searchPath. If aFilenameString includes a directory then it is
	answered. Otherwise the file is searched for in the directories in searchPath. If the
	file is not found in any of these directories then aFilenameString is answered"

	(self splitPathFrom: aFilenameString) isEmpty 
		ifTrue: 
			[searchPath do: 
					[:each | 
					| fullpath |
					fullpath := self composePath: each subPath: aFilenameString.
					(self exists: fullpath) ifTrue: [^fullpath]]].
	^aFilenameString!

makePath: anArray
	"Private - Composes a full pathname from its path, stem and extension components.
	The path and extension components can be nil or the empty string if the path
	does not have either of these components. The stem must be a non-empty String."

	| path |
	path := self pathBuffer.
	CRTLibrary default 
		_makepath: path 
			drive: (anArray at: 1) 
			dir: (anArray at: 2) 
			fname: (anArray at: 3) 
			ext: (anArray at: 4).
	^path trimNulls!

maxPath
	"Answers the maximum number of characters in a file pathname"

	^_MAX_PATH!

new
	"Answer a new initialized instance of the receiver."

	^(super new)
		setHandle: nil flags: 0;
		yourself!

open: aString
	"Open the file described by aString for exclusive read/write access.
	Answer the the new instance or signal a FileException if the operation fails."

	^self open: aString mode: #open!

open: aString mode: aSymbol
	"Open a file for exclusive read/write access. The mode symbol, aSymbol, determines what file
	opening mode to use when opening the file. Errors will be reported if an attempt is made to
	open a file which does not or does not exist, depending on the access mode (see
	open:mode:check:share: for the rules)."

	^self open: aString mode: aSymbol check: true!

open: aString mode: aSymbol check: aBoolean
	"Open a file for exclusive read/write access. The mode symbol, aSymbol, determines what file
	opening mode to use when opening the file. The check flag, aBoolean, determines whether or
	not errors are reported (see open:mode:check:share: for the rules)"

	"This method provides for ANSI (Posix) style file opening and is potentially
	more portable than those methods which require Win32 flags."

	^self open: aString mode: aSymbol check: aBoolean share: #exclusive!

open: aString mode: modeSymbol check: aBoolean share: shareSymbol
	"Open a file for read/write access. The mode symbol, modeSymbol, determines what file
	opening mode to use when opening the file. The check flag, aBoolean, determines whether or
	not errors are reported. See instance method for further details."

	^self new open: aString mode: modeSymbol check: aBoolean share: shareSymbol!

path: aPathnameString extension: anExtensionString
 	"Answer a full pathname with the specified extension, whether or not aPathnameString already
	has an extension."

	| components |
	components := self splitPath: aPathnameString.
	components at: 4 put: anExtensionString.
	^self makePath: components!

pathBuffer
	"Answer a buffer of sufficient size to contain a full path."

	^String new: self maxPath!

pathDelimiter
	"Answers the character that delimits a path (or parts thereof)"

	^ $\!

pathDelimiters
	"Answers the characters that can be used to delimits a path (or parts thereof).	
	Windows tends to accept the Unix delimiter, a forward slash, as well as its own
	back slash."

	^'/\'!

relativePathOf: aPathString to: aBasePathString 
	"Answers the relative path of aPathString relative to aBasePathString.
	Note that if the last component of aBasePathString is to be considered a directory
	then there must be a trailing slash, otherwise the last component is ignored (it is
	treated as if it were a file name)."

	| relPath |
	relPath := self pathBuffer.
	relPath := (ShlwapiLibrary default 
		pathRelativePathTo: relPath
		pszFrom: aBasePathString
		dwAttrFrom: 0
		pszTo: aPathString
		dwAttrTo: 0) 
			ifTrue: 
				[relPath trimNulls]
			ifFalse: [aPathString].
	^(relPath beginsWith: '.\') ifTrue: [relPath allButFirst: 2] ifFalse: [relPath]!

removeDirectory: aString
	(KernelLibrary default removeDirectory: aString) 
		ifFalse: [KernelLibrary default systemError]!

removeExtension: aPathnameString 
	"Answer a String which is fileName with the extension component removed."

	| answer |
	answer := aPathnameString copy.
	ShlwapiLibrary default pathRemoveExtension: answer.
	^answer trimNulls!

removePathDelimiter: aString
	"Answer a <readableString> that is the argument with a path separator at its end, if any, removed."

	^(aString notEmpty 
		and: [self pathDelimiters identityIncludes: aString last]) 
			ifTrue: [aString allButLast]
			ifFalse: [aString]!

rename: oldFileNameString to: newFileNameString
	"Rename the file specified in oldFileNameString to newFileNameString.
	Signal a HostSystemError if the operation fails."

	(KernelLibrary default moveFile: oldFileNameString lpNewFileName: newFileNameString)
		ifFalse: [ KernelLibrary default systemError ]!

replacePath: filePath with: newPath
	"Replace the path component of the full path name, filePath, with the new path name,
	newPath, i.e. only the stem and extension remain intact."

	| oldPathComponents |
	oldPathComponents := self splitPath: filePath.
	oldPathComponents 
		at: 1 put: nil;			"new path can include drive letter"
		at: 2 put: newPath.
	^self makePath: oldPathComponents!

shortenComponent: aString max: anInteger 
	| abbreviated |
	abbreviated := aString.
	abbreviated size > anInteger ifTrue: [abbreviated := abbreviated select: [:c | c isAlphaNumeric]].
	abbreviated size > anInteger 
		ifTrue: 
			[| len |
			len := abbreviated size.
			abbreviated := abbreviated reverse.
			abbreviated := abbreviated select: 
							[:c | 
							| useChar |
							(c isVowel and: [c isLowercase and: [len > anInteger]]) 
								ifTrue: 
									[useChar := false.
									len := len - 1]
								ifFalse: [useChar := true].
							useChar].
			abbreviated := abbreviated reverse].
	abbreviated size > anInteger 
		ifTrue: 
			[| len |
			len := abbreviated size.
			abbreviated := abbreviated reverse.
			abbreviated := abbreviated select: 
							[:c | 
							| useChar |
							(c isLowerCase and: [len > anInteger]) 
								ifTrue: 
									[useChar := false.
									len := len - 1]
								ifFalse: [useChar := true].
							useChar].
			abbreviated := abbreviated reverse].
	abbreviated size > anInteger ifTrue: [abbreviated := abbreviated leftString: anInteger].
	^abbreviated!

shortPathOf: aPathnameString
	"Answers the short path version of aPathnameString"

	| shortpath |
	shortpath := String new: self maxPath.
	((KernelLibrary default getShortPathName: aPathnameString 
		lpszShortPath: shortpath cchBuffer: shortpath size)==0) ifTrue: [
			KernelLibrary default systemError].
	^shortpath trimNulls!

splitExtensionFrom: aString
	"Splits aPathname string and answers the extension portion.
	Answers the empty string if there is no extension."

	^(self splitPath: aString) at: 4
!

splitFilenameFrom: aString
	"Splits aPathname string and answers the file name portion (including extension). Answers an
	empty string if there is no file stem."

	| splits |
	splits := self splitPath: aString.
	splits
		at: 1 put: nil;
		at: 2 put: nil.
	^self makePath: splits!

splitPath: aString 
	"Private - Splits aPathname string into its path, stem and extension components and answers 
	a four element Array of these.
	Note: We use the C-runtime library to implement this, hence either backward or forward
	slashes (i.e. $\ or $/) are acceptable as pathname delimiters."

	"Prevent GPF for common error case of nil argument"

	| drive dir fname ext |
	aString isNil ifTrue: [^self error: 'nil path'].
	drive := String new: _MAX_DRIVE.
	dir := String new: _MAX_DIR.
	fname := String new: _MAX_FNAME.
	ext := String new: _MAX_EXT.	"may be more than 3 chars now"
	CRTLibrary default 
		_splitpath: aString
		drive: drive
		dir: dir
		fname: fname
		ext: ext.
	"CRT function includes leading period on extension, which we don't"
	ext := ext trimNulls.
	(ext notEmpty and: [ext first == $.]) ifTrue: [ext := ext copyFrom: 2].
	^Array 
		with: drive trimNulls
		with: dir trimNulls
		with: fname trimNulls
		with: ext!

splitPathFrom: aPathnameString 
	"Splits aPathname string and answers the path portion (including the drive letter, if any).
	Answers an  empty <String> if there is no path."

	"Implementation Note: We use the CRT library _splitpath() function because the Win32
	API call, PathRemoveFileSpec() does not treat $/ as a path delimiter (only backslash).
	Also this is carefully implemented to minimise allocations and maximise speed."

	| drive dir |
	aPathnameString isNil 
		ifTrue: 
			["Passing a null pointer to _splitpath() will cause an unfriendly GPF"
			self error: 'nil path'].
	drive := String new: _MAX_DRIVE + aPathnameString size.
	dir := String new: aPathnameString size.
	^(CRTLibrary default)
		_splitpath: aPathnameString
			drive: drive
			dir: dir
			fname: nil
			ext: nil;
		strcat: drive strSource: dir!

splitStemFrom: aString 
	"Answers the file stem component of the path <String> argument, or an empty string if there
	is none."

	^(self splitPath: aString) at: 3!

temporary
	"Open a temporary file with a unique name generated by the system, for
	exclusive read/write access."

	^self open: self temporaryFilename!

temporaryFilename
	"Answer a new unique temporary filename in the logged on user's temp directory (see
	#tempPath). Note that this must create the file in order to ensure uniqueness. You are
	responsible for deleting the file when you have finished with it."
	
	^self temporaryFilenameWithPrefix: ''
	!

temporaryFilenameWithPrefix: prefixString 
	"Answer a temporary filename built from prefixString in the user's temporary files
	directory. Note that this will create the temp file in order to guarantee uniqueness. You
	are responsible for deleting the file when it is no longer required. Signals a Win32Error if
	the operation fails."

	| returnBuf |
	returnBuf := self pathBuffer.
	(KernelLibrary default 
		getTempFileName: self tempPath
		lpPrefixString: prefixString
		uUnique: 0
		lpTempFileName: returnBuf) == 0 
		ifTrue: [^KernelLibrary default systemError].
	^returnBuf trimNulls!

tempPath
	"Answer the path of the directory designated for temporary files on the host system."

	| buf len |
	buf := self pathBuffer.
	len := KernelLibrary default getTempPath: buf size lpBuffer: buf.
	^buf resize: len!

workingDirectory
	"Answer the current working directory."

	| buffer dir |
	buffer := self pathBuffer.
	dir := CRTLibrary default _getcwd: buffer maxlen: buffer size.
	^dir last = $\
		ifTrue: [dir]
		ifFalse: [dir copyWith: $\]!

workingDirectory: aString
	"Answer the current working directory."

	^CRTLibrary default _chdir: aString! !

!File methodsFor!

accessFlags
	"Private - Answer the Win32 access mode flags."

	^flags bitAnd: OpenFlagsMask bitInvert
!

asParameter
	"Answer the external representation of the receiver."

	^handle!

atEnd
	"Answer a Boolean indicating whether we are at the file's end
	or signal a FileException if the operation fails."

	^self position = (self size - 1)
!

basicFree
	"Private - Close the file and nil the handle.
	Signal a FileException if the operation fails."

	| fh |
	fh := handle.
	handle := nil.
	(KernelLibrary default closeHandle: fh) ifFalse: [self signalOsError: false]!

checkBoundsOf: aStringOrByteArray startingAt: startIndex for: bytesToTransferInteger
	"Private - Signal a FileException if the bounds of the transfer are out of range."

	bytesToTransferInteger == 0 ifFalse: [
		(startIndex < 1 or: [startIndex > aStringOrByteArray basicSize])
			ifTrue: [self error: 'Invalid array index'].
		startIndex + bytesToTransferInteger - 1 > aStringOrByteArray basicSize
			ifTrue: [self error: 'Buffer too small']]!

close
	"Close the file. The file can be reopened (depending on the access mode).
	Signal a FileException if an error occurs."

	self free; beUnfinalizable!

creationTime
	"Answer a <FILETIME> identifying the point in time at which some data was
	last written to the file associated with the receiver."

	| answer |
	answer := FILETIME new.
	self 
		getTimes: answer
		atime: nil
		mtime: nil.
	^answer!

delete
	"Private - Close the receiver and delete the associated file.
	Useful for finishing with temporary files."

	self free.
	self class delete: spec!

flags: anInteger
	"Private - Save away the Win32 access and open flags."

	flags := anInteger!

flush
	"Force write modifications to disk (where possible).
	Signal a FileException if the operation fails."

	(KernelLibrary default flushFileBuffers: handle) ifFalse: [self signalOsError: false]!

free
	"Private - Close the file if it is not already closed.
	Signal a FileException if the operation fails."

	handle notNull
		ifTrue: [self basicFree]!

getTimes: ctime atime: atime mtime: mtime
	"Private - Get the receiver's time of creation, last access, and last modification, 
	all answered through the FILETIME arguments (which are treated as value holders
	and updated directly)."

	(KernelLibrary default getFileTime: self asParameter
		lpCreationTime: ctime
		lpLastAccessTime: atime
		lpLastWriteTime: mtime) ifFalse: [KernelLibrary default systemError]!

handle
	"Answer the file handle."

	^handle!

isReadable
	"Answer true if the file is readable."

	^flags anyMask: GENERIC_READ!

isWriteable
	"Answer whether the receiver can be written to."

	^flags anyMask: GENERIC_WRITE!

lastAccessTime
	"Answer a <FILETIME> identifying the point in time at which some data was
	last written to the file associated with the receiver."

	| answer |
	answer := FILETIME new.
	self 
		getTimes: nil
		atime: answer
		mtime: nil.
	^answer!

lastWriteTime
	"Answer a <FILETIME> identifying the point in time at which some data was
	last written to the file associated with the receiver."

	| answer |
	answer := FILETIME new.
	self 
		getTimes: nil
		atime: nil
		mtime: answer.
	^answer!

name
	"Answer the receiver's filename."

	^spec
!

open
	"Open, or reopen, the file described by the receiver with the receiver's
	access and sharing modes.
	 If the operation fails then a resumable FileException is signalled. If
	the exception is handled and resumed, then a further attempt is made
	to open the file. This allows for easy implementation of '	retry' style
	functionality."

	| fh |
	
	[fh := KernelLibrary default 
				createFile: spec
				dwDesiredAccess: self accessFlags
				dwSharedMode: shareFlags
				lpSecurityAttributes: self securityAttributes
				dwCreationDistribution: self openFlags
				dwFlagsAndAttributes: FILE_ATTRIBUTE_NORMAL
				hTemplateFile: nil.
	fh asSignedInteger == -1] 
			whileTrue: [self signalOsError: true].
	handle := fh.
	self beFinalizable!

open: aStringFileName flags: flagsInteger share: shareFlagsInteger
	"Private - Open the file described by aString using the specified
	Win32 access and open flags (bitOr'd together), and share flags"
	
	self
		free;
		spec: aStringFileName;
		flags: flagsInteger;
		shareFlags: shareFlagsInteger;
		open!

open: aString mode: modeSymbol check: aBoolean share: shareSymbol
	"Open a file for read and/or write access. The mode symbol, modeSymbol, determines
	what file opening mode to use when opening the file. modeSymbol can be one of
	the three ANSI (posix based) modes:

		#create	- 	open an existing file, or create a new file, for read/write,
					positioned at the beginning
		#append	- 	open an existing file, or create a new file, for read/write
					and position to the end
		#truncate	-	open an existing file truncating existing contents, or
					create a new file, for read/write.

	Or one of two additional modes:

		#read	-	open an existing file, or create a new file, for read-only access
		#open	-	open an existing file, or create a new file, for read/write access

	Although some of these modes are similar, and are sometimes synonyms, there may be subtle
	differences depending on the value of the check flag. The check flag, aBoolean,
	determines whether or not errors are reported according to the following rules:

		If mode = #create and the file exists
			If check = true raise an error, else use the existing file
		If mode = #append and the file does not exist
			If check = true raise an error, else create a new file
		If mode = #truncate and the file does not exist
			If check = true raise an error, else create a new file
		If mode = #read and the file does not exist
			If check = true raise an error, else create a new file (for read only)
		If mode = #open and the file does not exist
			If check = true raise an error, else create a new file (for read/write)

	The shareSymbol can be one of:
		#exclusive
		#read
		#write
		#readWrite"

	self open: aString
			flags: ((aBoolean ifTrue: [CheckModes] ifFalse: [NoCheckModes]) at: modeSymbol)
			share: (ShareModes at: shareSymbol).
	modeSymbol == #append
		ifTrue: [self setToEnd]!

openFlags
	"Private - Answer the Win32 creation mode flags."

	^flags bitAnd: OpenFlagsMask!

position
	"Answer the absolute Integer position of the reciver's file pointer
	or signal a FileException if the operation fails."

	^self seek: 0 sense: FILE_CURRENT
!

position: anInteger 
	"Move the receiver's file pointer to the <integer> argument,
	which is a zero-based offset from the start of the file. 
	Answer the <integer> offset achieved or signal a <FileException> 
	if the operation fails."

	^self seek: anInteger sense: FILE_BEGIN!

printOn: aStream
	"Append the ASCII representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: spec; space;
		print: handle;
		nextPut: $)!

read: aByteObject
	"Read into aStringOrByteArray a maximum of aByteObject size bytes
	from the file.
	Answer the number of bytes or signal a FileException if the operation fails."

	^self
		read: aByteObject
		count: aByteObject basicSize
!

read: anAddress count: bytesToReadInteger 
	"Read a maximum of bytesToReadInteger bytes into anAddress from the file.

	It is not an error to read zero bytes.
	Answer the number of bytes read or signal a FileException if the operaion fails."

	| bytesRead |
	bytesToReadInteger == 0 ifTrue: [^0].
	bytesRead := ByteArray newFixed: 4.
	^(KernelLibrary default 
		readFile: handle
		lpBuffer: anAddress
		nNumberOfBytesToRead: bytesToReadInteger
		lpNumberOfBytesRead: bytesRead
		lpOverlapped: nil) 
			ifTrue: [bytesRead dwordAtOffset: 0]
			ifFalse: [self signalOsError: false]!

read: aStringOrByteArray startingAt: startIndex count: bytesToReadInteger
	"Read a maximum of bytesToReadInteger bytes from the file starting with aStringOrByteArray at: startIndex.

	It is not an error to read zero bytes.
	It is an error if aStringOrByteArray is shorter than startIndex + bytesToReadInteger - 1.
	Answer the number of bytes read or signal a FileException if the operaion fails."

	^self
		checkBoundsOf: aStringOrByteArray
		startingAt: startIndex
		for: bytesToReadInteger;

		read: aStringOrByteArray yourAddress + startIndex - 1
		count: bytesToReadInteger.

!

readByte
	"Answer the Integer value of the next byte from the file or nil if the receiver
	is positioned past the current EOF.
	Signal a FileException if an error occurs."

	| buffer |
	buffer := ByteArray new: 1.
	^(self read: buffer count: 1) == 0
		ifTrue: [nil]
		ifFalse: [buffer at: 1]

!

readCharacter
	"Answer the next Character from the file or nil if the receiver
	is positioned past the current EOF.
	Signal a FileException if an error occurs."

	| string |
	string := String new: 1.
	^(self read: string count: 1) == 0
		ifTrue: [nil]
		ifFalse: [string at: 1]!

readWriteStream
	"Answer a FileStream on the receiver initially configured to read/write text."

	^FileStream on: self!

reset
	"Move the receiver's file pointer to the begining of the file.
	Signal a FileException if the operation fails."

	self position: 0
!

securityAttributes
	"Answer the <SECURITY_ATTRIBUTES> to be used when opening the file,
	or nil if the default security attributes are to be used.
	N.B. Must be nil (or NULL) on Win9X machines as only supported on NT."

	^nil!

seek: offsetInteger sense: senseFlag 
	"Move the receiver's file pointer to position anInteger
	relative to the postition indicated by senseFlag.

	senseFlag
		must be one of (FILE_BEGIN, FILE_CURRENT, FILE_END).

	Answer the absolute integer position achieved or
	signal a FileException if the operation fails."

	| result high |
	high := DWORDBytes fromInteger: (offsetInteger bitShift: -32).
	result := KernelLibrary default 
				setFilePointer: handle
				lDistanceToMove: (16rFFFFFFFF bitAnd: offsetInteger)
				lpDistanceToMoveHigh: high
				dwMoveMethod: senseFlag.
	"N.B. If you step through this in the debugger you may get a false error because the 
	SetFilePointer API relies on the GetLastError() code to differentiate between
	 a legitimate file pointer low-word value and an error. As you step in the debugger 
	the error code will be altered by other API calls, and so it may no longer be zero
	when tested."
	^(16rFFFFFFFF = result and: [KernelLibrary default getLastError ~~ 0]) 
		ifTrue: [self signalOsError: false]
		ifFalse: [(high asSignedInteger bitShift: 32) bitOr: result]
!

setHandle: anExternalHandle flags: anInteger 
	"Private - Set the handle inst var to aHandle."

	handle := anExternalHandle.
	flags := anInteger!

setToEnd
	"Move the receiver's file pointer to the end of the file.
	Answer the absolute integer position achieved or
	signal a FileException if the operation fails."

	^self seek: 0 sense: FILE_END
!

shareFlags: anInteger
	"Private - Save away the Win32 sharing mode."

	shareFlags := anInteger!

signalOsError: aBoolean 
	"Private - Signal a FileException on this file with the current OS error.
	The <boolean> argument indicates whether the exception should be 
	resumable or not."

	^FileException signalOn: self resumable: aBoolean!

size
	"Answer the size of the file in bytes or
	signal a FileException if the operation fails."

	| result |
	result := KernelLibrary default getFileSize: handle lpFileSizeHigh: nil.
	^16rFFFFFFFF = result ifFalse: [result] ifTrue: [self signalOsError: false]!

size: anInteger 
	"Set the size of the file to the <integer> argument number of bytes
	(can be used to truncate or extend a file)."

	self position: anInteger.
	(KernelLibrary default setEndOfFile: handle) ifFalse: [self signalOsError: false]!

spec: aString
	"Private - Set the file path to the <readableString> argument."

	spec := aString!

write: aStringOrByteArray
	"Write all of aStringOrByteArray to the file.
	Answer the number of bytes written or signal a FileException if the operation fails."

	^self
		write: aStringOrByteArray
		count: aStringOrByteArray basicSize.!

write: aStringOrByteArrayOrAddress count: bytesToWriteInteger 
	"Write bytesToWriteInteger bytes from aStringOrByteArrayOrAddress to the file.

	It is not an error to write zero bytes.
	Answer the number of bytes written or signal a FileException if the operaion fails."

	| bytesWritten |
	bytesToWriteInteger == 0 ifTrue: [^0].
	bytesWritten := ByteArray newFixed: 4.
	^(KernelLibrary default 
		writeFile: handle
		lpBuffer: aStringOrByteArrayOrAddress
		nNumberOfBytesToWrite: bytesToWriteInteger
		lpNumberOfBytesWritten: bytesWritten
		lpOverlapped: nil) 
			ifTrue: [bytesWritten dwordAtOffset: 0]
			ifFalse: [self signalOsError: false]!

write: aStringOrByteArray startingAt: startIndex count: bytesToWriteInteger
	"Write bytesToWriteInteger bytes to the file starting with aStringOrByteArray at: startIndex.

	It is not an error to write zero bytes.
	It is an error if aStringOrByteArray is shorter than startIndex + bytesToWriteInteger - 1.
	Answer the number of bytes written or signal a FileException if the operation fails."

	^self
		checkBoundsOf: aStringOrByteArray
		startingAt: startIndex
		for: bytesToWriteInteger;

		write: (ExternalAddress fromInteger: aStringOrByteArray yourAddress + startIndex - 1)
		count: bytesToWriteInteger.
!

writeByte: anIntegerOrCharacter
	"Write the given byte to the file.
	Answer 1 or signal a FileException if the operation fails."

	^self write: (ByteArray with: anIntegerOrCharacter asInteger) count: 1! !

FileLocator comment:
'A FileLocator is an abstract root for a hierarchy of subclasses that implement the <fileLocator> protocol. 
A <fileLocator> is used map between an external resource pathname and an internal name. First an external name is mapped to an internal form using #relativePathTo:. The latter can be held in the image and later mapped back to it''s is full external name using #localFileSpecFor:.

Several singleton <fileLocator>s are supplied and can be referenced using the following class methods:

#imageRelative	- An instance of ImageRelativeFileLocator
#installRelative	- An instance of InstallRelativeFileLocator
#absolute		- An instance od AbsoluteFileLocator
#default		- Answers the #imageRelative locator

For example, say that you want to reference an Icon resource file that is held relative to your current image file (perhaps in the \Resources sudirectory). You want to do this in such a way that if you move your image then the \Resources directory will be expected to move with it.

icon := Icon fromFile: ''Resources\myIcon.ico'' usingLocator: FileLocator imageRelative.

Here, the path to the icon file will be held within the Icon instance in a form that is relative to the base location of the image directory. Icons also hold the file locator too and use this to map back to the full path of the icon file when it is necessary to load it. Hence if you move your image file, the Icon will still expect to be able to load the icon resource from a location that relative to the image directory.

Typically, this is the behaviour that you''ll want by default. At development time, resources are referenced relative to the image and, at runtime, relative to the executable file (which is effective an image, anyway). For this reason the above example could also have been written as:

icon := Icon fromFile: ''Resources\myIcon.ico'' usingLocator: FileLocator default
or
icon := Icon fromFile: ''Resources\myIcon.ico'' 

Sometimes, especially in the case of development tools, you might want a resource to be referenced relative to the Dolphin installation directory. In this case an InstallRelativeFileLocator would be moe appropriate. Take a look at DolphinSureCertificate>>image, for example. Note that, at runtime, the image location and installation location are treated as the same by a standard RuntimeSessionManager.

Class Variables:
	Absolute		<AbsoluteFileLocator> instance used for locating files by absolute directory.
	InstallRelative	<InstallRelativeFileLocator> instance used for locating files relative to the installation directory.
	ImageRelative	<ImageRelativeFileLocator> instance used for locating files relative to the image directory.

'!
!FileLocator class methodsFor!

absolute
	"Answers an instance of the receiver that can be used to locate external files
	with an absolute path."

	^AbsoluteFileLocator current
!

default
	"Answers an instance of the receiver that can be used to locate external files
	relative to the current image directory."

	^self imageRelative
!

imageRelative
	"Answers an instance of the receiver that can be used to locate external files
	relative to the current image  directory."

	^ImageRelativeFileLocator current!

installRelative
	"Answers an instance of the receiver that can be used to locate external files
	relative to the current installation directory."

	^InstallRelativeFileLocator current
! !

!FileLocator methodsFor!

basePath
	^SessionManager current imageBase!

findOrImportForeignClass
	"An attempt is being made by a <ClassLocator> to load a class when the dynamic loading
	capability is not installed. This is normally available as part of the Web Deployment Kit.
	Raise an error to the effect that the class cannot be found."

	^self errorClassNotFound!

localFileSpecFor: aString 
	"Answer a full filespec for the <readableString> relative path argument, formed according to
	the rules of this particular file locator. This is the reverse operation to
	#relativePathTo:, and is performed when the file needs to be located."

	^File fullPathOf: aString relativeTo: self basePath!

relativePathIfSubPath: aFilename 
	"Private - Answer a minimal <readableString> relative path to the resource with the
	specified <readableString> path, but only if a sub-path of the receiver's base path,
	otherwise answer the full absolute path."

	| relative |
	relative := self relativeToBase: aFilename.
	^(relative beginsWith: '..') ifTrue: [File fullPathOf: aFilename] ifFalse: [relative]!

relativePathTo: aString 
	"Answer a minimal <readableString> relative path to the resource with the specified
	<readableString> path from the receiver's base path."

	^self relativeToBase: aString!

relativeToBase: aFilename 
	^File relativePathOf: aFilename to: self basePath! !

GUID comment:
'GUID is the class of 128-bit Globally Unique Identifiers (guids) which are used wherever a unique identifier is required in COM, for example to identify specific coclasses and interfaces.

You can easily allocate a new GUID by sending #newUnique to this class. Note that this process is very fast, so there is no particular reason not to use GUIDs for other purposes requiring unique identifiers such as records in a database.

Note: In versions of Dolphin prior to 2.2 GUID was a subclass of ExternalStructure. Although logically GUID belongs under ExternalStructure, it was move for reasons of space efficiency (every class now has a unique GUID).

Instance Variables:
	None (byte class)

Class Variables:
	Null	- The null <GUID>.'!
!GUID class methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	Implementation Note: The receiver is actually defined as a structure
	of the following form:
		typedef struct _GUID {
		    unsigned long  Data1;
		    unsigned short Data2;
		    unsigned short Data3;
		    unsigned char  Data4[ 8 ];
		} GUID;
	This means it's maximum alignment requirement is for a 32-bit integer,
	i.e. 4 rather than 16.
	"

	^4!

atAddress: anAddress
	"Answer a new instance of the receiver instantiated from the
	data at the specified address. Normally  this will be a 'reference' 
	instance, that points at the data embedded	at the specified address. 
	However in the case of objects that always have reference form
	(e.g. COM interface pointers, BSTRs, etc) this will be a copy
	of the pointer at that address. This is particularly useful for accessing
	elements of arrays."

	^self fromAddress: anAddress!

basicByteSize
	^16!

byteSize
	"Answer the size in bytes of this structure"

	^self basicByteSize!

clear: addressOrBytes
	"Finalize an instance of the structure which instances of the receiver wrap
	which resides at the specified address. Note that this is not about freeing
	the specified memory block, but any resources which it references."!

compileDefinition
	"Implemented as part of the <externalStructure class> protocol, but nothing to do here."!

defineFields
	"Define the fields of the GUID structure.
		GUID defineTemplate
	
		typedef 		struct tagGUID {
			unsigned long Data1;
			unsigned short Data2;
			unsigned short Data3;
			char Data4[8];
		} GUID;

	"

	"This method only present to prevent auto-generation from stdole type library

	self
		defineField: #Data1 type: DWORDField new offset: 0;
		defineField: #Data2 type: WORDField new offset: 4;
		defineField: #Data3 type: WORDField new offset: 6;
		defineField: #Data4 type: (ArrayField type: ByteArray length: 8) offset: 8.
	self byteSize: 16"


!

elementSize
	"Private - Answer the size (in bytes) of the structure the receiver represents
	when used as an array element."

	^self byteSize!

fromAddress: ptr
	"Answer a new instance of the receiver with contents copied from
	the  GUID pointed at by ptr"

	^ptr asExternalAddress
		replaceBytesOf: self new
		from: 1 to: 16 startingAt: 1!

fromBytes: guidBytes
	"Answer a new instance of the receiver which is a copy of the specified bytes."

	^guidBytes replaceBytesOf: self new from: 1 to: self byteSize startingAt: 1
!

fromString: aString
	"Answer a new instance of the receiver instantiated from the argument, aString,
	which is in Microsoft(tm) GUID format.
	Implementation Note: Subclasses override this because OLE defines more specific
	functions for that purpose, which we use to be good boys, even though it appears not
	to be necessary (i.e. if we drop down a level and use the underlying
	RPC library function, it works anyway)."

	| answer status |
	answer := self newNull.
	(status := RPCLibrary default uuidFromString: (aString copyFrom: 2 to: aString size - 1) uuid: answer) == 0
		ifFalse: [RPCError signalWith: status].
	^answer!

init: addressOrBytes
	"Initialize an instance of the structure which instances of the receiver wrap
	which resides at the specified address."!

initialize
	"Private - Initialize the receiver's class variables.
		GUID initialize
	"
	self extraInstanceSpec: self byteSize!

new
	"Answer a new, null, instance of the receiver."

	^self new: self byteSize!

newBuffer
	"Answer a new instance containing its own buffer."

	^self newNull
!

newNull
	"Answer a new, null, instance of the receiver."

	^self new!

newUnique
	"Answer a new instance of the receiver generated using the standard
	algorithm (i.e. the answer should be unique)."

	| answer |
	answer := self new.
	RPCLibrary default uuidCreate: answer.
	^answer!

null
	"Answer a null instance of the receiver."

	Null isNil ifTrue: [Null := self newNull].
	^Null!

onPreStripImage
	"Private - Tidy up the receiver's lazily initialized class vars in preparation for image stripping."

	self uninitialize!

uninitialize
	"Private - Tidy up the receiver in preparation for removal from the system."

	Null := nil.
	VMLibrary default registryAt: #GUID put: nil! !

!GUID methodsFor!

_collate: comperand
	"Private - Answer the ordering relationship between the receiver
	and the argument, comperand."

	| status answer |
	status := ByteArray newFixed: 4.
	answer := RPCLibrary default uuidCompare: self uuid2: comperand status: status.
	status := status dwordAtOffset: 0.
	status == 0 ifFalse: [RPCError signalWith: status].
	^answer!

= comperand
	"Answer whether the receiver is equivalent to the <Object>, comperand."

	^self species = comperand species and: [(self _collate: comperand) == 0]!

asByteArray
	"Answer the raw contents of the receiver as a byte array."

	^self yourAddress asExternalAddress copyFrom: 1 to: self size!

asInteger
	"Answer the 128-bit integer value of the receiver."

	| answer |
	answer := ByteArray new: 16.
	self 
		replaceBytesOf: answer
		from: 1
		to: 16
		startingAt: 1.
	answer isImmutable: true.
	^answer becomeA: LargeInteger!

asObject
	"Answer the <Object> value represented by the receiver."

	^self!

asString
	"Answer a string representation of the receiver.
	Implementation Note: We want to use the standard COM string
	representation, so we need to add curly brackets. We could use the 
	COM function, but that would mean creating a dependency on 
	OLELibrary."

	| sz |
	sz := self stringSize.
	^(String new: sz)
		at: 1 put: ${;
		replaceFrom: 2
			to: sz - 1
			with: self idlString
			startingAt: 1;
		at: sz put: $};
		yourself!

displayOn: target
	"Append an 'end-user suitable' textual representation of the receiver to the
	<puttableStream> argument, target.
	GUIDs are a fairly technical concept, but they do appear in the registry in a
	certain format, which we use here."

	target nextPutAll: self asString!

hash
	"Hash the bytes of the object using the standard byte hashing
	primitive (which should not fail)."

	<primitive: 106>
	^VMLibrary default hashBytes: self count: self basicSize!

idlString
	"Answer the IDL string representation of the receiver."

	| pSz answer status |
	pSz := ExternalAddress new.
	(status := RPCLibrary default uuidToString: self stringUuid: pSz) == 0 ifFalse: [RPCError signal: status].
	UserLibrary default stringUpperA: pSz.
	answer := String fromAddress: pSz.
	RPCLibrary default rpcStringFree: pSz.
	^answer!

isNull
	"Answer whether the receiver is a null external data item
	(that is, a null pointer, or a nilled out structure)."

	^self = self class null!

notNull
	"Answer whether the receiver is a null external data item
	(that is, a null pointer, or a nilled out structure)."

	^self isNull == false!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: self;
		nextPut: $)!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:

	Primitive Failure Reasons:
		0 	- fromStart is not a SmallInteger.
		1	- stop is not a SmallInteger.
		2	- start is not a SmallInteger.
		3	- aByteObject is not a byte object
		4	- 'from' or 'to' interval is out-of-bounds
	"

	| fromOffset |
	<primitive: 142>
	fromOffset := fromStart - start.
	stop to: start by: -1 do: [:i | aByteObject at: i put: (self basicAt: i + fromOffset)].
	^aByteObject!

species
	"Answer the preferred class of the receiver - not always the same as the
	answer to #class (in this case the species of GUID and its subclasses 
	is always GUID)."

	^GUID!

stringSize
	"Answer the number of characters in a GUID string."

	^38!

value: guidBytes
	"Set the raw binary value of the receiver from those of the argument."

	guidBytes replaceBytesOf: self from: 1 to: self class byteSize startingAt: 1! !

InputState comment:
'<InputState> is a singleton responsible for managing the windows message loop and related <Process>es.

Instance Variables:
	inputSemaphore	<Semaphore> on which the UI process blocks when the idle (i.e. when message loop is empty).
	idler		<Process>. The idle process responsible for relinquishing control to Windows when no other Smalltalk <Process>es are ready to run.
	idleTimer		<WeakArray> holding <window> currently hosting WM_TIMER used to keep background processing operational when running Windows modal msg loops such as those for common dialogs.
	main		<Process>. The current main UI process.
	windows		<LookupTable> of <Integer>. Map of window handles to associated Smalltalk windows (usually <View>s).
	deferredActions	<SharedQueue> of <niladicValuable>. Actions to be processed by the main process when the message loop is empty.
	lastWindow	<window> that last received a message (cached because most likely to receive next message too).
	wakeupEvent	<ExternalHandle> of Win32 Event object signalled by the VM when it wants the image to wake up.

Class Variables:
	MaxIdleSleep9x		<SmallInteger>. Timeout passed to MsgWaitForMultipleObjects by idle process when on Windows 9x 
	MaxIdleSleepNT		<SmallInteger>. Timeout passed to MsgWaitForMultipleObjectsEx by idle process when on Windows NT 
	EnumHandlesDescriptor	<ExternalDescriptor>. Callback descriptor for EnumWindows.
	UserInterruptSignal		<Signal>. Exception raised when Ctrl+Break key press detected.
	SamplingInterval		<SmallInteger> interval (measured in full method/blockactivations) between tests of 					system input queue for host system messsages when running background processes.
'!
!InputState class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	SamplingInterval := 16384.
	EnumHandlesDescriptor := ExternalDescriptor fromString: 'stdcall: dword handle dword'.
	maxIdleSleep := 15000!

maxIdleSleep
	^maxIdleSleep!

maxIdleSleep: aSmallInteger 
	maxIdleSleep := aSmallInteger!

newFromOld: anInputState 
	^(self new)
		initializeFrom: anInputState;
		yourself! !

!InputState methodsFor!

aboutToForkUI
	"Private - A new main UI process is being started. Reset any global UI state."

	Smalltalk at: #Cursor ifPresent: [:cursorClass | cursorClass current: nil]!

aboutToIdle
	"The message loop is about to go to sleep - perform any actions necessary before that
	happens. We inform all views so that they may perform idle time updating of their user
	interfaces. Note that this is called from the main UI process, NOT the idle process."

		"Make sure we have at least one process (the idle process) to run"

	self uiIdle ifFalse: [^self].
	self
		ensureIdlerRunning;
		keepAlive.
		"Publish that the UI is about to go idle"
	self trigger: #aboutToIdle!

consoleStartup
	"Private - System startup has entered the second stage, and it is time to reinitialize the
	user interaction subsystem for a console session."

	windows := LookupTable new.
	self createPostedActionWindow.
	"#aboutToIdle will not be invoked, so best to to start the idler manually as otherwise an
	idlePanic interrupt will be sent by the VM"
	self ensureIdlerRunning!

createAndRegisterInputSemaphore
	"Private - Create the input semaphore and register it with the VM to be signalled when input
	is available for the Main UI Process."

	inputSemaphore := Semaphore new.
	VMLibrary default registryAt: #InputSemaphore put: inputSemaphore!

createAndRegisterWakeupEvent
	"Private - Create and register the Win32 Event object that is signalled by the VM when it
	wants to wake up the image from an idle state (i.e. from its call to
	MsgWaitForMultipleObjects[Ex])."

	wakeupEvent := KernelLibrary default 
				createEvent: nil
				bManualReset: false
				bInitialState: false
				lpName: nil.
	VMLibrary default registryAt: #WakeupEvent put: wakeupEvent!

createPostedActionWindow
	| hWnd  |
	hWnd := VMLibrary default registryAt: #MsgWndHandle.
	msgWindow := (PostedActionWindow new)
				handle: hWnd;
				yourself.
	self windowAt: hWnd put: msgWindow!

deferredActions
	^deferredActions!

ensureIdlerRunning
	"Private - Ensure that the idle process is still running, and if not restart it."

	idler isNil ifTrue: [self forkIdler].
	idler isReady ifFalse: [idler terminate. "auto reforks"]
	!

ensureMainRunning
	main notNil 
		ifTrue: 
			[main suspendingList == inputSemaphore ifTrue: [^self].
			main isAlive 
				ifTrue: 
					["Check for break key - inlined to avoid dependency on Keyboard class"
					((UserLibrary default getAsyncKeyState: Win32Constants.VK_CANCEL) anyMask: 16r8001) 
						ifTrue: [main queueInterrupt: Processor userBreakInterrupt].
					^self]].
	self forkMain!

enterIdle
	"Private - Put the current active process to sleep on the inputSemaphore. This is intended
	to provide an opportunity for background processes to run. Use with care."

	self inputSemaphore wait!

forkIdler
	"Private - Start a process at the lowest possible priority (system background) to perform
	idle time processing. The VM scheduler requires that there always be a process ready to run,
	and the system idle process is that process. It is designed to put Dolphin to sleep in a
	CPU-cycle friendly manner by calling the Win32 function MsgWaitForMultipleObjects() to put
	the main Dolphin thread to sleep. Should the system idle process die for some reason, then
	another is normally started by the dying idler. If this mechanism fails, then the VM will
	send an Idle Panic interrupt to whatever was the last active process, regardless of its
	state. See ProcessorScheduler>>idlePanic: for further details. The system idle process is
	not the appropriate place to perform background processing; simply fork a further Process at
	#userBackgroundPriority. It is important that any background processes run at a priority
	below #userSchedulingPriority, or Windows message starvation could occur."

	idler := (
			["Notification signal: self class name, ': Starting Idler process...'."
			
			[[self idleLoop] on: self userInterruptSignal
				do: 
					[:s | 
					"Assume user really wants to interrupt main UI process"
					self main queueInterrupt: Processor userBreakInterrupt.
					"Must explicitly resume to continue idle loop"
					s resume]] 
					ifCurtailed: 
						["If the idler terminates for some reason, start another"
						Processor activeProcess == idler ifTrue: [self forkIdler]]] 
					forkAt: Processor systemBasePriority)
				name: 'Idler';
				yourself!

forkMain
	"Private - Start a new Main process at user scheduling priority, which runs until another
	Process asserts that it is the Main process. Any existing main process will terminate.
	Answer the new process."

	self aboutToForkUI.
	(
	[main := Processor activeProcess.
	self mainLoop] forkAt: Processor userSchedulingPriority)
		name: 'Main';
		yourself!

guiStartup
	"Private - System startup has entered the second stage, and it is time to reinitialize the
	user interaction subsystem for a GUI session."

	| oldWindows |
	oldWindows := windows.
	lastWindow := nil.
	windows := LookupTable new.
	oldWindows notNil ifTrue: [oldWindows do: [:w | w onStartup]].
	self createPostedActionWindow!

hasVisibleWindows
	"Private - Answer whether there are any visible windows belonging to the current session
	still open."

	"Implementation Note: We use the bare metal UserLibrary functions to avoid any dependency on
	the existing View classes. This might be important to those wanting to implement their own
	window class hierarchy."

	| hDesktop user |
	user := UserLibrary default.
	hDesktop := user getDesktopWindow.
	^windows anySatisfy: 
			[:each | 
			| hWnd |
			hWnd := each asParameter.
			hWnd notNil and: [hWnd ~= hDesktop and: [(user isWindow: hWnd) and: [user isWindowVisible: hWnd]]]]!

idle
	"Private - Put the VM thread to sleep until there are messages from the host system, or a
	timer fires, to prevent unecessary consumption of host system time. This is called from the
	idle Process."

	"Implementation Note: This implementation is only suitable for platforms that correctly
	support MsgWaitForMultipleObjectsEx() with the MWMO_ALERTABLE flag,"

	MemoryManager current aboutToIdle.
	"Disable background sampling while sleeping"
	self primSampleInterval: -1.
	UserLibrary default 
		msgWaitForMultipleObjectsEx: 1
		pHandles: wakeupEvent
		dwMilliseconds: self class maxIdleSleep
		dwWakeMask: Win32Constants.QS_ALLINPUT
		dwFlags: Win32Constants.MWMO_ALERTABLE.
	"Rather than use the return value from MsgWaitForMultipleObjectsEx() we call
	GetQueueStatus(). This has the effect of clearing the 'new message' flag so that the next
	call to MsgWaitFor&c will not return immediately if the UI loop is blocked for some reason
	and so is not calling PeekMessage/GetMessage (which also clear the flag). This prevents
	short-cycling where the idle process goes into a tight loop calling MsgWaitFor&c when the
	main UI process is put to sleep."
	self isInputAvailable 
		ifTrue: 
			[self ensureMainRunning.
			inputSemaphore set]!

idleLoop
	"Private - Repeatedly perform system idle processing (this is the control loop of the Idler
	process). This loop is intended for system idle processing only, and should be kept simple
	to avoid instability. Perform user background processing in a background process forked for
	the purpose."

	[Processor activeProcess == idler] whileTrue: [self idle]!

idlePanic
	"Private - The Processor is panicking because it can't find any processes which are prepared
	to run. This has probably happened due to a deadlock, so terminate the existing idler in an
	attempt to continue. In order not to terminate the current active process, fork off a new
	one to do the termination, at the highest possible priority. When we kill the idler it will
	get restarted by its termination handler, will notice that the main process is dead, and
	restart that too if necessary."

	[self forkIdler] forkAt: Processor timingPriority!

idler
	"Private - Answer the Idle Process."

	^idler!

initializeFrom: anInputState 
	anInputState isNil 
		ifTrue: 
			[deferredActions := SharedQueue new.
			windows := LookupTable new]
		ifFalse: 
			[deferredActions := anInputState deferredActions.
			windows := anInputState windows.
			anInputState main: nil.
			anInputState idler ifNotNil: [:process | process kill]].
	idleTimer := WeakArray with: DeadObject current.
	self
		createAndRegisterWakeupEvent;
		registerAsDispatcher;
		createAndRegisterInputSemaphore;
		setSamplingInterval: 60!

inputSemaphore
	"Private - Answer the queue empty/not-empty semaphore"

	^inputSemaphore!

isDolphinWindow: hWnd 
	"Answer whether the window with handle, hWnd, is a Dolphin window or not."

	^(self windowAt: hWnd ifAbsent: []) notNil!

isInputAvailable
	"Private - Answer whether there is any input waiting in the Windows message queue. Note that
	a true answer does not guarantee that a call to GetMessage() will not block, since
	pre-processing may remove the messages, therefore this is only an indication that
	GetMessage() may need to be called (see also #isInputReady:)."

	"Implementation Note: We want to see if any input is available, not just what new input has
	arrived since the last call to GetMessage, PeekMessage, or GetQueueStatus, so we have to
	test against the high word."

	^(UserLibrary default getQueueStatus: Win32Constants.QS_ALLINPUT) anyMask: ##(Win32Constants.QS_ALLINPUT << 16)!

isInputReady: aMSG 
	"Private - Answer whether there is currently a message waiting in the host system queue (if
	there is, it is peeked into the argument, aMSG). Reset the VM sample interval too. Does not
	signal the inputSemaphore, which is left to the caller to do when appropriate."

	"Implementation Note: We must use PeekMessage() rather than GetQueueStatus() because the
	latter provides only an indication that a certain sort of input is available, and does not
	guarantee that a subsequent call to GetMessage() will not block. Since blocking on
	GetMessage() would prevent Dolphin's background green threads from getting any CPU time, we
	have to peek with the no-remove flag so that if this method answers true it is guaranteed
	that GetMessage() can be called without it blocking."

	self primSampleInterval: SamplingInterval.
	^UserLibrary default 
		peekMessage: aMSG
		hWnd: 0
		uMsgFilterMin: 0
		uMsgFilterMax: 0
		wRemoveMsg: Win32Constants.PM_NOREMOVE!

keepAlive
	"Private - Stay-alive test. Sent during idle time to determine if the session needs to stay
	alive. Detects headless condition and reports to the session manager."

	self hasVisibleWindows ifFalse: [SessionManager current noVisibleWindows]!

loopWhile: aBlock 
	"Pump messages until the <niladicValuable> argument evaluates to false."

	"Implementation Note: Host system events are processed at a higher priority to deferred
	actions. A single message/action is processed before testing again to see if the loop should
	be terminated. A single deferred action is processed between each test to see if there are
	further Windows messages. Generally however the Windows message queue remains empty for long
	periods, and all deferred messages will be quickly processed. When both queues are empty the
	active process (which should be the UI process) will yield control to lower priority
	processes, in particular the idle process which is responsible for quiescing the whole
	system."

	| msg activity |
	msg := MSG new.
	activity := false.
	
	[
	[aBlock value ifFalse: [^self].
	self isInputReady: msg] whileTrue: 
				[activity := true.
				self pumpMessage: msg].
	"The PostedActionWindow should evaluate all posted actions in the message pump, but for
	robustness ensure it does not accumulate a backlog of actions as this would cause very
	strange behaviour."
	msgWindow evaluatePendingActions ifTrue: [activity := true].
	deferredActions nextNoWait 
		ifNil: 
			[self waitForInput: activity.
			activity := false]
		ifNotNil: 
			[:action | 
			activity := true.
			action value]] 
			repeat!

main
	"Private - Answer the Main Process"

	^main!

main: aProcess
	"Private - Set the Main Process to be the argument, aProcess. Any existing main process will
	drop out of its message loop."

	main := aProcess!

mainLoop
	"Private - Pump messages until the another process assumes the role of main message loop."

	self loopWhile: [main == Processor activeProcess]
!

millisecondClockValue
	"Private - Answer the current value of the system millisecond clock."

	"Implementation Note: Primitive 174 is actually just a call to the WinMM function
	timeGetTime() which should be accurate to 1mS (unlike GetTickCount() which is only accurate
	to 10mS)."

	<primitive: 174>
	^self primitiveFailed!

onExit
	"Private - The system is closing down, release system resources."

	KernelLibrary default closeHandle: wakeupEvent!

postAction: aNiladicValuable 
	"Queue a niladic valuable (e.g. a MessageSend or niladic block) for deferred evaluation from
	in synchronisation with the message queue (i.e. it is effectively posted to the message queue)"

	msgWindow postAction: aNiladicValuable!

postQuit: anInteger
	"Private - Initiate graceful system shutdown with the appropriate Windows API call."

	UserLibrary default postQuitMessage: anInteger!

preTranslateMessage: aMSG 
	"Private - Pre-dispatch message filter. Answers true if some window consumed the message, or
	false to have message dispatched as normal."

	| handle |
	handle := aMSG hwnd.
	[handle isNull] whileFalse: 
			[(self windowAt: handle ifAbsent: []) 
				ifNotNil: [:window | (window preTranslateMessage: aMSG) ifTrue: [^true]].
			handle := UserLibrary default getParent: handle].
	^false!

primSampleInterval: anInteger
	"Private - Set the interval (measured in milliseconds) between polls of the host system input
	queue when running background processes. After at least the polling interval (on average 1.5
	times the interval) following the last invocation of #isInputReady, or the dispatch of the
	last message through the VM window proc, the VM will test the queue, and will signal the
	inputSemaphore if there is any input ready. If anInteger is 0, the sample counter is reset
	to the current sampling interval value (which is answered)."

	"Primitive failure reasons:
		0 -	anInteger is not a SmallInteger."

	"Notes:

	1) The sampling interval only comes into play when running CPU intensive background
	Processes - it has no significance if you never run lengthy computations in background
	Processes.

	2) It determines the frequency with which the VM samples the Windows message queue and
	checks for Ctrl+Break.

	3) During normal operation the sampling is suppressed by the main thread's message loop (in
	fact by it calling #isInputReady:, and by the arrival of messages dispatched through the
	VM's window procedure..

	4) The choice of sampling interval is a trade off between best performance and
	responsiveness when running CPU intensive background tasks continually. Increasing the value
	may give a slight performance boost, but it will probably not be significant. Reducing the
	value can improve responsiveness, but if it is reduced much below about 30mS then the cost
	will start to become measurable.

	4) The sampling can be turned off completely by specifying a value of -1 to
	#primSampleInterval:, but this will disable CTRL+BREAK, and switching away from background
	processes, so this should be done programmatically for short periods only."

	<primitive: 94>
	^self primitiveFailed!

processDeferredActions
	"Process all deferred actions. Normally these are processed one at a time when the message
	queue is found to be empty by the main UI process, but this message can be sent to empty the
	deferred actions queue if desired."

	| deferred |
	[(deferred := deferredActions nextNoWait) isNil] whileFalse: [deferred value]!

prod
	"Prod the message loop into life if sent from a background process. Useful when a background
	process does something with visual effect that would not be seen unless the message loop
	comes to life."

	Processor activeProcess == main ifFalse: [self inputSemaphore signal]!

pumpMessage: aMSG 
	"Private - Read and dispatch the first pending host system message. If a WM_QUIT is
	received, then exit Smalltalk."

	(UserLibrary default 
		getMessage: aMSG
		hWnd: 0
		wMsgFilterMin: 0
		wMsgFilterMax: 0) == 0 
		ifTrue: [SessionManager current onQuit: aMSG swParam]
		ifFalse: 
			[(self preTranslateMessage: aMSG) 
				ifFalse: 
					[(UserLibrary default)
						translateMessage: aMSG;
						dispatchMessage: aMSG]]!

pumpMessages
	"Read and dispatch any pending host system messages until the queue is empty. If a WM_QUIT
	is received, then exit Smalltalk. This can be used from user code to empty the message queue
	if necessary."

	| msg |
	msg := MSG new.
	self loopWhile: [self isInputReady: msg]!

purgeDeadWindows
	"Remove any windows in the windows collection which have a NULL handle. In normal use there
	will be no such windows, but as a result of errors, debugging sessions, etc, these can
	arise, so this message is provided to be used to purge any such zombies."

	| bEnabled |
	bEnabled := Processor enableAsyncEvents: false.
	windows := windows select: 
					[:each | 
					| hWnd |
					(hWnd := each asParameter) notNil and: [UserLibrary default isWindow: hWnd]].
	lastWindow := nil.
	Processor enableAsyncEvents: bEnabled!

queueDeferredAction: operation
	"Queue a niladic valuable (e.g. a MessageSend or niladic block) for deferred evaluation from
	the message pump when the Windows message queue is empty."

	"Implementation Note: We must signal the input semaphore or the action may end up hanging
	around until the next windows message arrives if the main process is currently idle (i.e.
	this is not the main process, or does not return to the message loop)."

	deferredActions nextPut: operation.
	inputSemaphore set!

registerAsDispatcher
	"Private - Notify the VM that the receiver should receive callbacks via the WndProc().
		SessionManager inputState registerAsDispatcher
	"

	VMLibrary default registryAt: #Dispatcher put: self!

removeWindowAt: aHandle 
	"Private - Unregister a Window object with the specified handle."

	"Implementation Note: Interrupts are disabled to prevent concurrent access to the windows
	collection without the possibility of deadlock."

	| bEnabled |
	aHandle isNil ifTrue: [^self].
	bEnabled := Processor enableAsyncEvents: false.
	windows removeKey: aHandle asInteger ifAbsent: [].
	lastWindow := nil.
	Processor enableAsyncEvents: bEnabled!

setSamplingInterval: anInteger 
	"Private - Set sampling interval. This is the approximate interval, in milliseconds, at
	which the system will sample the input queue and check for Ctrl+Break when running
	computationally expensive tasks in background threads."

	SamplingInterval := anInteger.
	self primSampleInterval: SamplingInterval!

startIdleTimer: aView 
	"Private - Start the idle timer (e.g. when a menu is popped), hosted by the window, aView,
	which must respond to #asParameter by answering its window handle (it need not be a View).
	If the idle timer is already active then this do nothing."

	
	[| idleHost hWnd |
	idleHost := idleTimer basicAt: 1.
	hWnd := aView asParameter.
	(idleHost == DeadObject current or: [hWnd isNull or: [(UserLibrary default isWindow: hWnd) not]]) 
		ifTrue: 
			[idleTimer basicAt: 1 put: aView.
			UserLibrary default 
				setTimer: hWnd
				nIDEvent: Win32Constants.WM_ENTERIDLE
				uElapse: 100
				lpTimerFunc: nil]] 
			critical!

stopIdleTimer: aView 
	"Private - Stop the idle timer hosted by the specified window. If the idle timer is not
	actually hosted by aView, then do nothing."

	
	[| idleHost |
	idleHost := idleTimer basicAt: 1.
	idleHost == aView 
		ifTrue: 
			[idleTimer basicAt: 1 put: DeadObject current.
			UserLibrary default killTimer: aView asParameter uIDEvent: Win32Constants.WM_ENTERIDLE]] 
			critical!

topLevelWindows
	"Answer a Collection containing all top level windows belonging to the Dolphin process.

	Note that this will include windows which are not frame windows (e.g. tool tips), and
	furthermore it is not lightening fast!!"

	| shells bEnabled desktop |
	shells := OrderedCollection new: 20.
	desktop := Smalltalk at: #View ifPresent: [:view | view desktop].
	bEnabled := Processor enableAsyncEvents: false.
	windows do: 
			[:each | 
			"This selection filter has been re-written for bug fix #2261. Previously
			WS_CHILD views that were children of the desktop were not being included in
			the answered collection. This resulted in the View Composer not having any
			non-shell views it was editing being saved and restored across an image
			restart."
			(each isView and: [each parentView == desktop]) ifTrue: [shells add: each]].
	Processor enableAsyncEvents: bEnabled.
	^shells!

uiIdle
	"Private - Inform the receiver's registered windows that the UI is going idle so that they
	can update visual elements accordingly - e.g. enable/disable toolbar buttons. The windows
	can do other processing from their idle notification handlers, but it should be of very
	short duration, or the responsiveness of the UI will be adversely affected."

	self topLevelWindows do: 
			[:each | 
			self isInputAvailable 
				ifTrue: 
					[self inputSemaphore set.
					^false	"stop enumerating"]
				ifFalse: [self uiIdle: each]].
	^true!

uiIdle: aShellWindow 
	"Private - If the argument is one of the receiver's currently visible windows, then request
	it to update its UI."

	(UserLibrary default isWindowVisible: aShellWindow asParameter) ifTrue: [aShellWindow enterIdle]!

userInterruptSignal
	"Answer the user interrupt <Signal>."

	UserInterruptSignal isNil 
		ifTrue: [UserInterruptSignal := Signal resumableDescription: 'User Interrupt'].
	^UserInterruptSignal!

visibleWindows
	"Private - Answer a collection of the visible windows belonging to the current session."

	"Implementation Note: We use the bare metal UserLibrary functions to avoid any dependency on
	the existing View classes. This might be important to those wanting to implement their own
	window class hieararchy."

	| hDesktop user |
	user := UserLibrary default.
	hDesktop := user getDesktopWindow.
	^windows select: 
			[:each | 
			| hWnd |
			hWnd := each asParameter.
			hWnd notNil and: [hWnd ~= hDesktop and: [(user isWindow: hWnd) and: [user isWindowVisible: hWnd]]]]!

waitForInput: aBoolean 
	"Private - The input queues are empty, so quiesce the main process to avoid consuming CPU
	cycles unecessarily, and to provide an opportunity for background processes to run. Before
	putting the main process to sleep (this method should only be invoked by the UI process) on
	the inputSemaphore, various pre-idle activities may be performed before, depending on
	whether any input has been processed since the UI process last woke up, as indicated by the
	<boolean> argument."

	aBoolean ifTrue: [self aboutToIdle].
	self inputSemaphore wait!

windowAt: aHandle ifAbsent: exceptionHandler 
	"Answers an open window that has a handle of aHandle (an Integer or ExternalHandle). If the
	handle is nil, then answers nil."

	| hWnd wasEnabled window |
	aHandle isNil ifTrue: [^exceptionHandler value].
	hWnd := aHandle asInteger.
	wasEnabled := Processor enableAsyncEvents: false.
	window := windows at: hWnd ifAbsent: [].
	Processor enableAsyncEvents: wasEnabled.
	^window ifNil: [exceptionHandler value]!

windowAt: aHandle put: aWindow 
	"Register a Window object (which understands #dispatchMessage:) with the specified handle."

	| wasEnabled hWnd |
	hWnd := aHandle asInteger.
	wasEnabled := Processor enableAsyncEvents: false.
	windows at: hWnd put: aWindow.
	lastWindow := nil.
	Processor enableAsyncEvents: wasEnabled!

windows
	"Private - Answer the collection of all open windows (a <LookupTable> mapping <integer>
	window handles to <windows>."

	^windows!

wndProc: hWnd message: message wParam: wParam lParam: lParam cookie: cookie 
	"Private - Dispatch a Windows message to the appropriate event handler of the view whose
	handle is hWnd. If the window handle is not registered, then the default window procedure is
	invoked."

	"WARNING: This method is an entry point from the VM, and must not be invoked from Smalltalk
	code, as it returns directly to the VM as if from a callback. Do not modify or remove this
	method."

	"Implementation Note: The VM sends this message with asynchronous process switching
	disabled."

	| window |
	lastWindow asParameter = hWnd 
		ifTrue: [window := lastWindow]
		ifFalse: 
			[window := windows at: hWnd ifAbsent: [].
			window isNil 
				ifTrue: 
					[^Processor callback: cookie
						evaluate: 
							[UserLibrary default 
								defWindowProc: hWnd
								msg: message
								wParam: wParam
								lParam: lParam]]
				ifFalse: [lastWindow := window]].
	^Processor
		enableAsyncEvents: true;
		callback: cookie
			evaluate: 
				[(window 
					dispatchMessage: message
					wParam: wParam
					lParam: lParam) asUIntPtr]! !

InstructionInterpreter comment:
'InstructionInterpreter is the abstract class of <bytecodeInterpreter>s that can act as the client of a <ByteCodeDispatcher>.

Instance Variables:
	dispatcher		<ByteCodeDispatcher>

'!
!InstructionInterpreter class methodsFor!

dispatcher: aByteCodeDispatcher 
	^(self new)
		dispatcher: aByteCodeDispatcher;
		yourself!

method: aCompiledMethod 
	"Answer a String containing a disassembly listing for aMethod."

	^(self new)
		method: aCompiledMethod;
		yourself!

new
	^self basicNew initialize! !

!InstructionInterpreter methodsFor!

blockCopy: argc stack: stack env: env copy: copy offset1: offset1 offset2: offset2 
	"Interpret a Block Copy instruction."
!

break
	"Interpret a Debug Break instruction."

	!

decodeNearOffset: extensionByte1 
	^extensionByte1 >= 128 ifTrue: [extensionByte1 - 256] ifFalse: [extensionByte1]!

decPushTemp: arg1 temp: offset
	"Private - Interpret an Decremement & Push Temporary Variable instruction."

	self
		pushTemp: offset;
		decrementStackTop;
		storeTemp: offset!

decrementStackTop
	"Interpret a Decrement Stack Top instruction."
!

decTemp: arg1 temp: offset 
	"Private - Interpret an Decremement Temporary Variable instruction."

	self
		pushTemp: offset;
		decrementStackTop;
		popTemp: offset!

dispatcher
	^dispatcher!

dispatcher: aByteCodeDispatcher 
	dispatcher := aByteCodeDispatcher.
	aByteCodeDispatcher interpreter: self!

duplicateStackTop
	"Interpret a Dup instruction."
!

exLongSend: extensionByte1 with: extensionByte2 with: extensionByte3 
	"Interpret an extended long send instruction."

	self send: extensionByte2 + (extensionByte3 bitShift: 8) args: extensionByte1!

exLongSupersend: extensionByte1 with: extensionByte2 with: extensionByte3 
	"Interpret an Extended Long Supersend instruction."

	self supersend: extensionByte2 + (extensionByte3 bitShift: 8) args: extensionByte1!

incPushTemp: arg1 temp: offset
	"Private - Interpret an Incremement & Push Temporary Variable instruction."

	self
		pushTemp: offset;
		incrementStackTop;
		storeTemp: offset!

incrementStackTop
	"Interpret an Increment Stack Top instruction."
!

incTemp: arg1 temp: offset 
	"Private - Interpret an Incremement Temporary Variable instruction."

	self
		pushTemp: offset;
		incrementStackTop;
		popTemp: offset!

interpret
	"Interpret all the instructions in the method."

	dispatcher dispatchAll!

isZero
	"Interpret an IsZero instruction (compares for identity with SmallInteger zero)."
!

jump: anInteger 
	"Private - Interpret an unconditional Jump instruction to the specified offset from the current IP
	(i.e. the IP after fetching the jump instruction)."
	!

jumpIfFalse: anInteger 
	"Private - Interpret a conditional Jump If False instruction to the specified offset from the current IP
	(i.e. the IP after fetching the jump instruction)."!

jumpIfNil: anInteger 
	"Private - Interpret a conditional Jump If Nil instruction to the specified offset from the current IP
	(i.e. the IP after fetching the jump instruction)."!

jumpIfNotNil: anInteger 
	"Private - Interpret a conditional Jump If Not Nil instruction to the specified offset from the current IP
	(i.e. the IP after fetching the jump instruction)."!

jumpIfTrue: anInteger 
	"Private - Interpret a conditional Jump If True instruction to the specified offset from the current IP
	(i.e. the IP after fetching the jump instruction)."!

longJump: extensionByte1 with: extensionByte2 
	"Interpret a long jump instruction of the offset specified by the arguments."

	self jump: (ByteCodeDispatcher decodeLongJump: extensionByte1 byte2: extensionByte2)!

longJumpIfFalse: extensionByte1 with: extensionByte2 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfFalse: (ByteCodeDispatcher decodeLongJump: extensionByte1 byte2: extensionByte2)!

longJumpIfNil: extensionByte1 with: extensionByte2 
	self jumpIfNil: (ByteCodeDispatcher decodeLongJump: extensionByte1 byte2: extensionByte2)!

longJumpIfNotNil: extensionByte1 with: extensionByte2 
	self jumpIfNotNil: (ByteCodeDispatcher decodeLongJump: extensionByte1 byte2: extensionByte2)!

longJumpIfTrue: extensionByte1 with: extensionByte2 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfTrue: (ByteCodeDispatcher decodeLongJump: extensionByte1 byte2: extensionByte2)!

longPopStoreStatic: byte1 with: byte2 
	"Interpret a Long Pop And Store Literal Variable instruction."

	self popStatic: (byte2 * 256) + byte1!

longPushConst: extensionByte1 with: extensionByte2 
	"Interpret a Long Push Const instruction."

	self pushConst: extensionByte2 * 256 + extensionByte1!

longPushImmediate: extensionByte1 with: extensionByte2 
	"Interpret a Push Immediate Word instruction."

	self 
		pushImmediateInteger: (extensionByte2 >= 128 
				ifTrue: [extensionByte2 - 256]
				ifFalse: [extensionByte2]) * 256 
				+ extensionByte1!

longPushStatic: extensionByte1 with: extensionByte2 
	"Interpret a Long Push Literal Variable instruction."

	self pushStatic: extensionByte2 * 256 + extensionByte1!

longSend: extensionByte1 with: extensionByte2 
	"Interpret a Long Send instruction."

	self send: extensionByte2 args: extensionByte1!

longStoreStatic: byte1 with: byte2
	"Interpret a Long Store Literal Variable instruction."

	self storeStatic:  byte2 * 256 + byte1!

longSupersend: extensionByte1 with: extensionByte2 
	"Interpret a Long Supersend instruction."

	self supersend: extensionByte2 args: extensionByte1!

macroInstructionPart2
	"Sent between the first and second parts of a macro instruction."

	!

method
	"Answer the <CompiledMethod> which the receiver is decoding."

	^dispatcher method!

method: aCompiledMethod 
	"Set the method to be decoded by the receiver to aCompiledMethod."

	self dispatcher: (aCompiledMethod byteCodeDispatcherClass on: aCompiledMethod for: self)!

nearJump: extensionByte1 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jump: (self decodeNearOffset: extensionByte1)!

nearJumpIfFalse: extensionByte1 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfFalse: (self decodeNearOffset: extensionByte1)!

nearJumpIfNil: extensionByte1 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfNil: (self decodeNearOffset: extensionByte1)!

nearJumpIfNotNil: extensionByte1 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfNotNil: (self decodeNearOffset: extensionByte1)!

nearJumpIfTrue: extensionByte1 
	"Interpret a long jump instruction of the offset specified by the argument."

	self jumpIfTrue: (self decodeNearOffset: extensionByte1)!

nop
	"Interpret a Nop (no-operation) instruction."
!

popContextTemp: anInteger 
	"Interpret a Short Pop And Store Context Temp instruction."

	self popOuter: 0 temp: anInteger!

popDup
	"Interpret a Pop & Dup instruction.
	This instruction is commonly used in cascaded sends."

	self
		popStackTop;
		macroInstructionPart2;
		duplicateStackTop!

popInstVar: instVarIndex 
	"Interpret a Pop And Store Instance Variable instruction."

	self
		storeInstVar: instVarIndex;
		macroInstructionPart2;
		popStackTop!

popOuter: contextDepth temp: envTempIndex 
	"Private - Interpret a Pop & Store Outer [M] Temp [N] instruction."

	self
		storeOuter: contextDepth temp: envTempIndex;
		macroInstructionPart2;
		popStackTop!

popOuterTemp: arg 
	"Interpret a Pop And Store Instance Environment Temporary instruction."

	self popOuter: (arg bitShift: -5) temp: (arg bitAnd: 16r1F)!

popPushSelf
	"Interpret a Pop & Push Self instruction.
	This instruction is commonly used in sequences of statements that are uncascaded
	sends to self."

	self
		popStackTop;
		macroInstructionPart2;
		pushSelf!

popPushTemp: tempIndex 
	"Interpret a Pop & Push Temp [N] instruction."

	self
		popStackTop;
		macroInstructionPart2;
		pushTemp: tempIndex!

popReturnSelf
	"Interpret a Pop & Return Self instruction. 
	This is commonly used in methods with no explicit return to pop the value
	of the last statement from the stack and return in one operation."

	self
		popStackTop;
		macroInstructionPart2;
		returnSelf!

popStackTop
	"Interpret a Pop instruction."

	!

popStatic: literalIndex 
	"Interpret a Pop And Store Literal Variable instruction."

	self
		storeStatic: literalIndex;
		macroInstructionPart2;
		popStackTop!

popTemp: tempIndex 
	"Interpret a Pop And Store Stack Temporary instruction."

	self
		storeTemp: tempIndex;
		macroInstructionPart2;
		popStackTop!

pushActiveFrame
	"Interpret a Push Active Frame instruction."
!

pushChar: asciiValue 
	"Interpret a Push Char instruction."

	self pushCharacter: (Character value: asciiValue)!

pushCharacter: aCharacter 
!

pushConst: literalIndex 
	"Interpret a Push Literal Constant instruction."
!

pushContextTemp: anInteger 
	"Interpret a short Push Context Temporary Variable instruction.
	This is equivalent to a Push Outer[0] Temp[N] instruction."

	self pushOuter: 0 temp: anInteger!

pushImmediate: offset
	"Interpret a Push Immediate Byte instruction."

	self pushImmediateInteger: (offset >= 128 ifTrue: [ offset - 256 ] ifFalse: [ offset ])!

pushImmediateInteger: anInteger 
	"Private - Interpret a Push Immediate N instruction."!

pushInstVar: instVarIndex 
	"Interpret a Push Instance Variable instruction."

	!

pushOuter: contextDepth temp: envTempIndex
	"Interpret a Push Outer [M] Temp [N] instruction."!

pushOuterTemp: arg 
	"Interpret a Push Environment Temporary Variable instruction."

	self pushOuter: (arg bitShift: -5) temp: (arg bitAnd: 16r1F)!

pushPseudo: offset 
	"Interpret a Push nil/true/false/self instruction."

	!

pushSelf
	"Interpret a Push Self instruction."

	!

pushSelfAndTemp: tempIndex 
	"Interpret a Push Self And Temporary Variable instruction.
	Commonly used in sends to self of one argument messages."

	self
		pushSelf;
		macroInstructionPart2;
		pushTemp: tempIndex!

pushStatic: offset
	"Interpret a Short Push Literal Variable instruction."

!

pushTemp: offset
	"Interpret a Push Temporary Variable instruction."

!

pushTempPair: anInteger 
	"Interpret a Push Pair of Temporary Variables instruction.
	Commonly used when pushing the arguments to muli-keyword messages,
	or in sends of one-argument messages to a temporary."

	self
		pushTemp: anInteger >> 4;
		macroInstructionPart2;
		pushTemp: (anInteger bitAnd: 16rF)!

reset
	dispatcher reset!

returnFromBlock
	"Interpret a return from block to its caller."

	!

returnFromBlockHome
	"Interpret a return from block's home method (i.e. a ^-return inside a block)."

	!

returnFromMessage
	"Interpret a return from message (^-return in a method)."

	!

returnPseudo: offset
	"Interpret a Return nil/true/false/self instruction."
!

returnSelf
	"Interpret a Return Self instruction."!

send: extensionByte
	"Interpret a Send instruction."

	self send: (extensionByte bitAnd: 31) args: (extensionByte bitShift: -5)!

send: literalIndex args: argumentCount 
	"Private - Interpret a Send [N]with M args instruction."

	self sendSelector: (self method literalAt: literalIndex + 1) args: argumentCount!

sendSelector: aSymbol args: anObject 
	!

sendSelf: literalIndex args: argumentCount 
	"Private - Interpret a Send Self [N] with M args instruction."

	self
		pushSelf;
		macroInstructionPart2;
		send: literalIndex args: argumentCount!

sendSelfSelector: aSymbol args: anInteger 
	!

sendSelfZeroArgs: anInteger 
	"Interpret a Send Self [N] with 0 Args instruction."

	self sendSelf: anInteger args: 0!

sendTempZeroArgs: anInteger 
	"Interpret a Send [N] to Temp [M] with 0 Args instruction."

	self sendZeroArgs: (anInteger bitAnd: 16r1F) toTemp: (anInteger bitShift: -5)!

sendZeroArgs: literalInteger toTemp: tempInteger 
	"Private - Interpret a Send [N] to Temp [M] with 0 Args instruction."

	self
		pushTemp: tempInteger;
		macroInstructionPart2;
		send: literalInteger args: 0!

shortJump: offset 
	"Interpret a short jump instruction of the offset specified by the argument."

	self jump: offset+1!

shortJumpIfFalse: offset 
	"Interpret a short jump instruction of the offset specified by the argument."

	self jumpIfFalse: offset+1!

shortPopInstVar: instVarIndex 
	"Interpret a Short Pop And Store Instance Variable instruction."

	self popInstVar: instVarIndex!

shortPopOuterTemp: anInteger 
	"Interpret a Short Pop And Store Outer Temp instruction."

	self popOuter: 1 temp: anInteger!

shortPopPushTemp: offset 
	"Interpret a Short Pop & Push Temporary Variable instruction."

	self popPushTemp: offset!

shortPopTemp: offset 
	"Interpret a Short Pop And Store Instance Variable instruction."

	self popTemp: offset!

shortPushConst: offset 
	"Interpret a Short Push Literal Constant instruction."

	self pushConst: offset!

shortPushImmediate: offset 
	"Interpret a Short Push -1/0/1/2 instruction."

	self pushImmediateInteger: offset - 1!

shortPushInstVar: instVarIndex 
	"Interpret a Short Push Instance Variable instruction."

	self pushInstVar: instVarIndex!

shortPushOuterTemp: anInteger 
	"Interpret a short Push Outer Temporary Variable instruction."

	self pushOuter: 1 temp: anInteger!

shortPushSelfAndTemp: anInteger 
	"Interpret a Short Push Self & Temp[N] instruction."

	self pushSelfAndTemp: anInteger!

shortPushStatic: literalIndex 
	"Interpret a Short Push Literal Variable instruction."

	self pushStatic: literalIndex!

shortPushTemp: tempIndex 
	"Interpret a Short Push Temporary Variable instruction."

	self pushTemp: tempIndex!

shortSendOneArg: literalIndex 
	"Interpret a Short Send instruction."

	self send: literalIndex args: 1!

shortSendSelfZeroArgs: anInteger 
	"Interpret a Short Send Self [N] with 0 Args instruction."

	self sendSelfZeroArgs: anInteger!

shortSendTwoArgs: literalIndex
	"Interpret a Short Send [N] with 2 Args instruction."

	self send: literalIndex args: 2!

shortSendZeroArgs: literalIndex 
	"Interpret a Short Send instruction."

	self send: literalIndex args: 0!

shortSpecialSend: offset 
	"Interpret a Short Special Send instruction."

	| selector |
	selector := dispatcher selectorOfSpecialSend: offset.
	self sendSelector: selector args: selector argumentCount!

shortStoreTemp: anInteger
	"Interpret a short Store Temporary Variable instruction."

	self storeTemp: anInteger!

storeInstVar: offset 
	"Interpret a Store Instance Variable instruction."

	!

storeOuter: contextDepth temp: envTempIndex 
	"Interpret a Store Outer [M] Temp [N] instruction."

	!

storeOuterTemp: arg 
	"Interpret a Store Environment Temporary Variable instruction."

	self storeOuter: (arg bitShift: -5) temp: (arg bitAnd: 16r1F)!

storeStatic: literalIndex 
	"Interpret a Store Literal Variable instruction."

	!

storeTemp: tempIndex 
	"Interpret a Store Temporary Variable instruction."

	!

supersend: extensionByte 
	"Interpret a Supersend instruction."

	self supersend: (extensionByte bitAnd: 31) args: (extensionByte bitShift: -5)!

supersend: literalIndex args: argumentCount 
	"Private - Interpret a Supersend [N] with M args instruction."

	self supersendSelector: (self method literalAt: literalIndex+1)!

supersendSelector: aSymbol 
!

unused
	"Interpret an unused short instruction."

	!

unused: extensionByte 
	"Interpret an unused double byte instruction."

	!

unused: extensionByte1 with: extensionByte2 
	"Interpret an unused triple byte instruction."

	!

unused: extensionByte1 with: extensionByte2 with: extensionByte3
	"Interpret an unused quad byte instruction."
! !

Keyboard comment:
''!
!Keyboard class methodsFor!

buildVKeyMap
	^(LookupTable new)
		at: 'BACKSPACE' put: VK_BACK;
		at: 'TAB' put: VK_TAB;
		at: 'ENTER' put: VK_RETURN;
		at: 'SHIFT' put: VK_SHIFT;
		at: 'CTRL' put: VK_CONTROL;
		at: 'ALT' put: VK_MENU;
		at: 'PAUSE' put: VK_PAUSE;
		at: 'CAPSLOCK' put: VK_CAPITAL;
		at: 'ESC' put: VK_ESCAPE;
		at: 'SPACE' put: VK_SPACE;
		at: '0' put: $0 codePoint;
		at: '1' put: $1 codePoint;
		at: '2' put: $2 codePoint;
		at: '3' put: $3 codePoint;
		at: '4' put: $4 codePoint;
		at: '5' put: $5 codePoint;
		at: '6' put: $6 codePoint;
		at: '7' put: $7 codePoint;
		at: '8' put: $8 codePoint;
		at: '9' put: $9 codePoint;
		at: 'A' put: $A codePoint;
		at: 'B' put: $B codePoint;
		at: 'C' put: $C codePoint;
		at: 'D' put: $D codePoint;
		at: 'E' put: $E codePoint;
		at: 'F' put: $F codePoint;
		at: 'G' put: $G codePoint;
		at: 'H' put: $H codePoint;
		at: 'I' put: $I codePoint;
		at: 'J' put: $J codePoint;
		at: 'K' put: $K codePoint;
		at: 'L' put: $L codePoint;
		at: 'M' put: $M codePoint;
		at: 'N' put: $N codePoint;
		at: 'O' put: $O codePoint;
		at: 'P' put: $P codePoint;
		at: 'Q' put: $Q codePoint;
		at: 'R' put: $R codePoint;
		at: 'S' put: $S codePoint;
		at: 'T' put: $T codePoint;
		at: 'U' put: $U codePoint;
		at: 'V' put: $V codePoint;
		at: 'W' put: $W codePoint;
		at: 'X' put: $X codePoint;
		at: 'Y' put: $Y codePoint;
		at: 'Z' put: $Z codePoint;
		at: 'NUM 0' put: VK_NUMPAD0;
		at: 'NUM 1' put: VK_NUMPAD1;
		at: 'NUM 2' put: VK_NUMPAD2;
		at: 'NUM 3' put: VK_NUMPAD3;
		at: 'NUM 4' put: VK_NUMPAD4;
		at: 'NUM 5' put: VK_NUMPAD5;
		at: 'NUM 6' put: VK_NUMPAD6;
		at: 'NUM 7' put: VK_NUMPAD7;
		at: 'NUM 8' put: VK_NUMPAD8;
		at: 'NUM 9' put: VK_NUMPAD9;
		at: 'NUMMULT' put: VK_MULTIPLY;
		at: 'NUM PLUS' put: VK_ADD;
		at: 'NUM SUB' put: VK_SUBTRACT;
		at: 'NUM DECIMAL' put: 16r6E;
		at: '/' put: VK_DIVIDE;
		at: 'F1' put: VK_F1;
		at: 'F2' put: VK_F2;
		at: 'F3' put: VK_F3;
		at: 'F4' put: VK_F4;
		at: 'F5' put: VK_F5;
		at: 'F6' put: VK_F6;
		at: 'F7' put: VK_F7;
		at: 'F8' put: VK_F8;
		at: 'F9' put: VK_F9;
		at: 'F10' put: VK_F10;
		at: 'F11' put: VK_F11;
		at: 'F12' put: VK_F12;
		at: '=' put: VK_OEM_PLUS;
		at: ',' put: VK_OEM_COMMA;
		at: '-' put: VK_OEM_MINUS;
		at: '.' put: VK_OEM_PERIOD;
		at: '[' put: VK_OEM_4;
		at: '\' put: VK_OEM_5;
		at: ']' put: VK_OEM_6;
		at: '#' put: VK_OEM_7;
		at: '`' put: VK_OEM_8;
		at: 'NUM ENTER' put: VK_RETURN | 16r100;
		at: 'PGUP' put: VK_PRIOR | 16r100;
		at: 'PGDOWN' put: VK_NEXT | 16r100;
		at: 'END' put: VK_END | 16r100;
		at: 'HOME' put: VK_HOME | 16r100;
		at: 'LEFT' put: VK_LEFT | 16r100;
		at: 'UP' put: VK_UP | 16r100;
		at: 'RIGHT' put: VK_RIGHT | 16r100;
		at: 'DOWN' put: VK_DOWN | 16r100;
		at: 'INSERT' put: VK_INSERT | 16r100;
		at: 'DEL' put: VK_DELETE | 16r100;
		at: 'DELETE' put: VK_DELETE | 16r100;
		shrink;
		isImmutable: true;
		yourself!

default
	"Answers the default Keyboard to use"

	DefaultInstance isNil ifTrue: [self default: self new initialize].
	^DefaultInstance!

default: aKeyboard
	"Assigns the default Keyboard"

	DefaultInstance := aKeyboard!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables.
		Keyboard initialize
	"

	VirtualKeys := self buildVKeyMap!

keyNameFromLParam: lParam
	"Private - Answer the name of the specified key.
	Answers nil if the key cannot be translated."

	| buf len |
	buf := String new: 32.
	len := UserLibrary default
			getKeyNameText: lParam lpString: buf nSize: buf basicSize+1.	"includes null term"
	"Despite what the help says, the function does not call SetLastError(), so no
	point signalling a system error here"
	len == 0 ifTrue: [^nil].
	^buf leftString: len!

keyNameFromScanCode: anInteger 
	"Private - Answer the name of the specified key scan code.
	Answers nil if not translatable.
	"

	^self keyNameFromLParam: (anInteger bitShift: 16)!

keyNameFromVKey: anInteger
	"Private - Answer the name of the specified virtual key code.
		Keyboard keyNameFromVKey: 16r23
	"

	^self
		keyNameFromVKey: anInteger 
		ifNone: [self error: 'invalid virtual key ', anInteger displayString]!

keyNameFromVKey: anInteger ifNone: exceptionHandler 
	"Private - Answer the name of the specified virtual key code,
	or evaluate the exceptionHandler block if none."

	| scanCode |
	scanCode := self vKeyToScanCode: anInteger.
	scanCode == 0 ifTrue: [^exceptionHandler value].
	^(self keyNameFromScanCode: (scanCode bitOr: (anInteger maskClear: 16rFF))) 
		ifNil: [exceptionHandler value]!

onPreStripImage
	"Private - The image is about to be stripped."

	self uninitialize!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	DefaultInstance := nil.!

virtualKey: aString 
	"Answer the <integer> virtual key code corresponding to the key with
	English name, aString."

	^VirtualKeys at: aString asUppercase
		ifAbsent: [self error: 'Unrecognised virtual key: ''' , aString , '''']!

vKeyToScanCode: anInteger
	"Private - Answer the scan code corresponding to the virtual key
	code, anInteger, or 0 if there isn't one."

	^UserLibrary default mapVirtualKey: (anInteger bitAnd: 16rFF) uMapType: 0! !

!Keyboard methodsFor!

asyncKeyState: virtualKeyCodeInteger
	"Private - Answer the state of the specified virtual key."

	^UserLibrary default getAsyncKeyState: virtualKeyCodeInteger!

getState
	"Private - Refresh the cached Win32 asynchronous keyboard state ByteArray and answer it."

	^(UserLibrary default getKeyboardState: state)
		ifTrue: [state]
		ifFalse: [UserLibrary default systemError]!

initialize
	"Private - Initialize the receiver."

	state := ByteArray new: 256!

isAltDown
	"Answer whether the <ALT> key is down."

	^self isKeyDown: VK_MENU!

isButtonDown: aSymbol 
	"Answer whether the mouse button identified by the symbolic name (either #left, #right, or #middle)
	is currently pressed down."

	^self 
		isKeyDown: (##((IdentityDictionary new)
				at: #left put: VK_LBUTTON;
				at: #right put: VK_RBUTTON;
				at: #middle put: VK_MBUTTON;
				at: #xButton1 put: VK_XBUTTON1;
				at: #xButton2 put: VK_XBUTTON2;
				yourself) at: aSymbol)!

isCancelDown
	"Answer whether the Cancel (CTRL+BREAK) key is down."

	^self isKeyDown: VK_CANCEL!

isCancelPressed
	"Answer whether the Cancel (CTRL+BREAK) key has been pressed or is being pressed."

	^self isKeyPressed: VK_CANCEL!

isCtrlDown
	"Answer whether the <CTRL> key is down."

	^self isKeyDown: VK_CONTROL!

isKeyDown: virtualKeyCodeInteger
	"Private - Answer whether the specified virtual key is down. Under Windows the high bit of
	a key state is set when the key is down, and GetKeyState() returns a signed short, so the
	result key state will be negative if a key is down."

	^(self keyState: virtualKeyCodeInteger) < 0!

isKeyPressed: virtualKeyCodeInteger
	"Private - Answer whether the specified virtual key has been pressed or is down now.
	Note this is not a reliable indication, so is only suitable for detecting Ctrl+Break or similar."

	^(self asyncKeyState: virtualKeyCodeInteger) anyMask: 16r8001!

isModifierDown
	"Answer whether the any of the keyboard modifier keys (Ctrl, Alt, Shift) are down."

	^##(Array 
		with: VK_CONTROL
		with: VK_SHIFT
		with: VK_MENU) anySatisfy: [:each | self isKeyDown: each]!

isShiftDown
	"Answer whether the <SHIFT> key is down."

	^self isKeyDown: VK_SHIFT!

keyState: virtualKeyCodeInteger
	"Private - Answer the state of the specified virtual key."

	^UserLibrary default getKeyState: virtualKeyCodeInteger!

resetCancel
	"Reset the Cancel (CTRL+BREAK) key."

	self resetKey: VK_CANCEL!

resetKey: virtualKeyCodeInteger
	"Private - Reset the specified virtual key."

	self setKeyState: virtualKeyCodeInteger to: 0!

setKeyState: virtualKeyCodeInteger to: byteMask
	"Private - Set the Win32 keyboard state of the specified virtual key to the specified byteMask"

	self getState at: virtualKeyCodeInteger+1 put: byteMask.
	self setState!

setState
	"Private - Modify Win32's keyboard state to that currently cached."

	UserLibrary default setKeyboardState: state
! !

Link comment:
'Links are records of a reference to another Link, and are used to represent the linked elements of a <LinkedList>.

Link is an abstract base class which should be subclasses to hold objects of the appropriate type.'!
!Link class methodsFor!

nextLink: aLink
	"Answer a new instance of the receiver which refers to aLink as the
	link which succeeds it in a LinkedList"

	<primitive: 157>
	^self new
		nextLink: aLink;
		yourself! !

!Link methodsFor!

nextLink
	"Answer the next Link in the list after the receiver"

	^nextLink
!

nextLink: aLink
	"Set the next Link referred to by the receiver to a aLink."

	^nextLink := aLink! !

Locale comment:
''!
!Locale class methodsFor!

default
	"Answer the instance of the receiver which represents the default user locale."

	^self userDefault!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

installedSystemLocales
	"Private - Answer the installed Win32 system locales.
		Locale installedSystemLocales
	"

	^self systemLocales: 1!

lcid: anLCID
	"Answer an instance of the receiver to represent the Locale with the specified id."

	^self new lcid: anLCID!

makeLangId: langIdBits subLang: subLangIdBits
	"Private - Answer a Win32 language Id word constructed from langIdBits (10 bits
	are significant) and subLangIdBits (6 bits are significant)."

	^(subLangIdBits bitAnd: 63) << 10 bitOr: (langIdBits bitAnd: 1023)!

makeLcId: langIdWord sortId: sortIdBits
	"Private - Answer a Win32 Locale Id dword constructed from langIdWord and 
	sortIdBits (4 bits are significant).
		#define MAKELCID(lgid) ((unsigned long)(((unsigned short)(lgid)) | (((unsigned long)((unsigned short)(0))) << 16)))
	"

	^(sortIdBits bitAnd: 16rF) << 16 
		bitOr: (langIdWord bitAnd: 16rFFFF)!

onPreStripImage
	"Private -  Assist in the image stripping process by clearning down any
	lazily initialized variables held by the receiver."

	UserDefault := nil!

onStartup
	"Private - The system has just started. Adjust any locale specific
	information (e.g. Dates and Times). Can be sent at other times
	if the Locale has been changed."

	UserDefault := SystemDefault := nil!

supportedSystemLocales
	"Private - Answer the supported Win32 system locales.
		Locale supportedSystemLocales
	"

	^self systemLocales: 2!

systemDefault
	"Answer the instance of the receiver which represents the default user locale."

	SystemDefault isNil ifTrue: [SystemDefault := self lcid: KernelLibrary default getSystemDefaultLCID].
	^SystemDefault!

systemLocales: anInteger 
	"Private - Answer a collection of system locales, depending on the flags argument, anInteger."

	| enum locales |
	locales := OrderedCollection new: 30.
	enum := ExternalCallback block: 
					[:locale | 
					locales addLast: locale.
					true]
				descriptor: (ExternalDescriptor returnType: 'bool' argumentTypes: 'lpstr').
	KernelLibrary default enumSystemLocales: enum asParameter dwFlags: anInteger.
	enum free.
	^locales collect: [:s | self lcid: (Integer readFrom: s asUppercase readStream radix: 16)]!

userDefault
	"Answer the instance of the receiver which represents the default user locale."

	UserDefault isNil ifTrue: [UserDefault := self lcid: KernelLibrary default getUserDefaultLCID].
	^UserDefault! !

!Locale methodsFor!

amDesignator
	"Answer the String used in the receiver locale to designate AM (morning)."

	amDesignator isNil ifTrue: [amDesignator := self getInfo: LOCALE_S1159].
	^amDesignator!

asParameter
	"Answer the receiver in a form suitable for passing to an external
	function call (the Win32 representation of a Locale, is the LCID)."

	^lcid!

currency
	"Answer the currency symbol String used in the receiver locale.
	Implementation Note: We cache this because it is used for printing, etc."

	currencySymbol isNil ifTrue: [currencySymbol := self getInfo: LOCALE_SCURRENCY].
	^currencySymbol
!

dateFormat
	"Answer the default date format for the receiver locale."

	^self getInfo: LOCALE_SSHORTDATE!

dateFormats: aBoolean 
	"Private - Answer a collection of the date formats for the specified locale, with short
	or long formats according to the argument, aBoolean."

	| enum formats |
	formats := OrderedCollection new: 4.
	enum := ExternalCallback block: 
					[:format | 
					formats add: format.
					true]
				descriptor: (ExternalDescriptor returnType: 'bool' argumentTypes: 'lpstr').
	(self nlsLib 
		enumDateFormats: enum asParameter
		locale: self asParameter
		dwFlags: (aBoolean ifTrue: [DATE_LONGDATE] ifFalse: [DATE_SHORTDATE])) 
			ifFalse: [self nlsLib systemError].
	enum free.
	^formats!

dateOrder
	"Answer the date ordering used in the receiver locale.
		0	Month - Day - Year
		1	Day - Month - Year
		2	Year - Month - Day."

	^self getIntegerInfo: LOCALE_IDATE!

dateSeparator
	"Answer the character used in the receiver locale to separate date components.
	Implementation Note: We cache this because it is used for printing Dates, etc."

	dateSeparator isNil ifTrue: [dateSeparator := self getInfo: LOCALE_SDATE].
	^dateSeparator!

dayNames
	"Answer a lookup table mapping abbreviated and normal day names in the
	receiver locale to the day number."

	dayNames isNil ifTrue: [
		dayNames := LookupTable new: 14.
		1 to: 7 do: [ :i |
			dayNames 
				at: (self nameOfDay: i abbrev: false) asLowercase put: i;
				at: (self nameOfDay: i abbrev: true) asLowercase put: i ]].
	^dayNames!

decimalSeparator
	"Answer the decimal separator String used in the receiver locale.
	Implementation Note: We cache this because it is used for printing Floats, etc."

	decimalSeparator isNil ifTrue: [decimalSeparator := self getInfo: LOCALE_SDECIMAL].
	^decimalSeparator!

displayOn: aStream
	"Append a displayable representation of the receiver to aStream."

	aStream nextPutAll: self name!

getInfo: anIntegerLcType 
	"Private - Answer a locale specific date String of the specified type for the receiver's locale.
	Implementation Note: Try a default maximum size of 20, which will handle most locale info,
	and if that is not enough fall back on the slower mechanism of enquiring for the size first."

	| size buf lib |
	lib := self nlsLib.
	buf := String new: 20.
	size := lib 
				getLocaleInfo: lcid
				lCType: anIntegerLcType
				lpLCData: buf
				cchData: buf size + 1.
	size == 0 
		ifTrue: 
			[size := lib 
						getLocaleInfo: lcid
						lCType: anIntegerLcType
						lpLCData: nil
						cchData: 0.
			size == 0 ifTrue: [^lib systemError].
			"Strings allocate extra space for null automatically"
			buf := String new: size - 1.
			lib 
				getLocaleInfo: lcid
				lCType: anIntegerLcType
				lpLCData: buf
				cchData: size].
	^buf resize: size - 1!

getIntegerInfo: anIntegerLcType
	"Private - Answer a locale specific single character of the specified type for the 
	receiver's locale."

	| buf lib |
	lib := self nlsLib.
	buf := String new: 15.
	(lib getLocaleInfo: lcid lCType: anIntegerLcType lpLCData: buf cchData: 11) == 0
		ifTrue: [lib systemError].
	^CRTLibrary default atoi: buf!

isMonthBeforeDay
	"Answer true if the format for the receiver is expecting a month before a day"

	^self dateOrder ~= 1!

lcid: anLCID
	"Private - Set the receiver's Win32 LCID which identifies the locale the
	receiver is representing. Answer the receiver."

	lcid := anLCID!

listSeparator
	"Answer the String used in the receiver locale to separate items in lists.
	Implementation Note: We cache this because it is used for printing, etc."

	listSeparator isNil ifTrue: [listSeparator := self getInfo: LOCALE_SLIST].
	^listSeparator!

longDateFormat
	"Answer the default long date format for the receiver locale."

	^self getInfo: LOCALE_SLONGDATE!

longDateFormats
	"Private - Answer a collection of the long date formats for the receiver locale."

	^self dateFormats: true!

monthNames
	"Answer a map between <readableString> month names (and abbreviated month
	names) and the corresponding month number in the receiving locale."

	monthNames isNil ifTrue: [
		monthNames := LookupTable new: 24.
		1 to: 12 do: [ :i |
			monthNames
				at: (self nameOfMonth: i abbrev: false) asLowercase put: i;
				at: (self nameOfMonth: i abbrev: true) asLowercase put: i]].
	^monthNames!

name
	"Answer the name of the receiver locale."

	^self getInfo: LOCALE_SLANGUAGE!

nameOfDay: dayIndex abbrev: aBoolean
	"Private - Answer a String that is the localised short/long name of the day whose index is the 
	argument, dayIndex, where Monday is 1 and Sunday is 7, depending on the abbrev argument.
	N.B. This is Win32 specific."

	^self getInfo: LOCALE_SDAYNAME1 + 
					(aBoolean ifTrue: [7] ifFalse: [0]) +
					dayIndex - 1!

nameOfMonth: monthIndex abbrev: aBoolean
	"Private - Answer a localised long/short String name for the month whose index is the argument, 
	monthIndex, where January is month 1, and December is month 12.
	N.B. This is Win32 specific."

	^self getInfo: LOCALE_SMONTHNAME1 + 
					(aBoolean ifTrue: [12] ifFalse: [0]) +
					monthIndex - 1!

nlsLib
	"Private - Answer the library responsible for locale support."

	^KernelLibrary default!

pmDesignator
	"Answer the character used in the receiver locale to designate PM (afternoon)."

	pmDesignator isNil ifTrue: [pmDesignator := self getInfo: LOCALE_S2359].
	^pmDesignator!

printDate: aDate format: aStringOrNil flags: dwFlags
	"Private - Answer a locale specific formatted date String generated from the arguments."

	| year |
	"If a Date is prior to 01 January 1601, or post 31 December 65535, then it cannot be
	formatted by Windows."
	^((year := aDate year) < 1601 or: [year > 65535])
		ifTrue: [self printUnboundedDate: aDate format: aStringOrNil flags: dwFlags]
		ifFalse: [self printSysDate: aDate asParameter format: aStringOrNil flags: dwFlags]!

printOn: aStream
	"Append a debug representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; print: self name; nextPut: $)!

printSysDate: aSYSTEMTIME format: aStringOrNil flags: dwFlags
	"Private - Answer a locale specific formatted date <String> generated from the arguments."

	| size buf lib |
	lib := self nlsLib.
	buf := String new: 30.
	size := lib getDateFormat: self asParameter dwFlags: dwFlags 
				lpDate: aSYSTEMTIME lpFormat: aStringOrNil lpDateStr: buf cchDate: buf size+1.
	size == 0 ifTrue: [
		"Probably too big, find out how big a buffer is needed"
		size := lib getDateFormat: self asParameter dwFlags: dwFlags 
				lpDate: aSYSTEMTIME  lpFormat: aStringOrNil lpDateStr: nil cchDate: 0.
		size == 0 ifTrue: [lib systemError].
		buf := String new: size-1.	"Strings allocate extra space for null terminator"
		lib getDateFormat: self asParameter dwFlags: dwFlags 
			lpDate: aSYSTEMTIME lpFormat: aStringOrNil lpDateStr: buf cchDate: size].
	"size includes terminating null"
	^buf resize: size-1!

printTime: aTime format: aStringOrNil flags: dwFlags
	"Private - Append a locale specific string representation of the argument, aTime, to,
	aStream, using the specified format String (the default is used if it is nil)."

	| size buf timeParm lib |
	timeParm := aTime asParameter.
	lib := self nlsLib.
	buf := String new: 20.
	size := lib 
				getTimeFormat: self asParameter
				dwFlags: dwFlags
				lpTime: timeParm
				lpFormat: aStringOrNil
				lpTimeStr: buf
				cchBuf: buf size + 1.
	size == 0 
		ifTrue: 
			[size := lib 
						getTimeFormat: self asParameter
						dwFlags: dwFlags
						lpTime: timeParm
						lpFormat: aStringOrNil
						lpTimeStr: nil
						cchBuf: 0.
			size == 0 ifTrue: [^lib systemError].
			buf := String new: size - 1.	"Strings allocate extra space for null terminator"
			lib 
				getTimeFormat: self asParameter
				dwFlags: dwFlags
				lpTime: timeParm
				lpFormat: aStringOrNil
				lpTimeStr: buf
				cchBuf: size].
	^buf resize: size - 1!

printUnboundedDate: aDate format: aStringOrNil flags: dwFlags
	"Private - Answer a locale specific formatted date String generated
	from the arguments. This is usually only employed if aDate is
	outside the range supported by Windows."

	| strm |
	#todo "Implement correctly to respect the format string".
	strm := String writeStream: 64.
	(dwFlags allMask: DATE_LONGDATE) 
		ifTrue: [
			strm
				display: aDate dayOfMonth; space;
				display: aDate monthName; space;
				display: aDate year]
		ifFalse: [
			self isMonthBeforeDay 
				ifTrue: [
					strm
						display: aDate monthIndex; nextPutAll: self dateSeparator;
						display: aDate dayOfMonth; nextPutAll: self dateSeparator]
				ifFalse: [
					strm
						display: aDate dayOfMonth; nextPutAll: self dateSeparator;
						display: aDate monthIndex; nextPutAll: self dateSeparator].
				strm display: aDate year].
	^strm contents!

shortDateFormats
	"Private - Answer a collection of the short date formats for the user locale."

	^self dateFormats: false!

timeFormat
	"Answer the default time format for the receiver locale."

	^self getInfo: LOCALE_STIMEFORMAT!

timeFormats
	"Answer a collection of the time formats for the specified locale."

	| enum formats |
	formats := OrderedCollection new: 4.
	enum := ExternalCallback block: 
					[:format | 
					formats add: format.
					true]
				descriptor: (ExternalDescriptor returnType: 'bool' argumentTypes: 'lpstr').
	(self nlsLib 
		enumTimeFormats: enum asParameter
		locale: self asParameter
		dwFlags: 0) ifFalse: [self nlsLib systemError].
	enum free.
	^formats!

timeSeparator
	"Answer the character used in the receiver locale to separate time components.
	Implementation Note: We cache this because it is used for printing, etc."

	timeSeparator isNil ifTrue: [timeSeparator := self getInfo: LOCALE_STIME].
	^timeSeparator!

timeZoneInformation
	| timeZoneInfo rc |
	timeZoneInfo := TIME_ZONE_INFORMATION new.
	rc := KernelLibrary default getTimeZoneInformation: timeZoneInfo.
	rc = -1 ifTrue: [^KernelLibrary default systemError].
	^Array with: rc with: timeZoneInfo


! !

Magnitude comment:
'Magnitude is an abstract class which provides the protocol objects which can be compared
along a linear dimension, e.g. Numbers, Dates, Times.

Subclasses of Magnitude must implement the following comparing protocol (at the very least):
#<, #=, #hash'!
!Magnitude methodsFor!

< operand
	"Answer whether the receiver is less than the <magnitude>, operand.

	Only this relational operator need be implemented by subclasses, since the others can 
	be implemented in terms of it (though performance may dictate otherwise)."

	^self subclassResponsibility!

<= operand
	"Answer whether the receiver is less than or equal to the <magnitude>, operand.
	Implemented in terms of #<, which must be implemented by subclasses, also make use 
	of compiler optimisation of #== instead of #not"

	^(operand < self) == false!

= aMagnitude
	"Answer whether the receiver is equivalent to the argument, aMagnitude."

	^self subclassResponsibility!

> operand
	"Answer whether the receiver is greater than the <magnitude>, operand.
	Implemented in terms of #<, which must be implemented by subclasses."

	^operand < self!

>= operand
	"Answer whether the receiver is greater than or equal to the <magnitude>, operand.
	Implemented in terms of #<, which must be implemented by subclasses."

	^(self < operand) == false!

between: min and: max
	"Answer whether the receiver is inclusively between the <magnitude> arguments, 
	min and max."

	^self >= min and: [self <= max]!

hash
	"Answer a SmallInteger hash value for the receiver which obeys the invariant that any two 
	objects which compare equal (using #=) must have the same hash value (but not 
	necessarily vice-versa). Like #=, and #<, must be implemented by subclasses."

	^self subclassResponsibility!

max: operand
	"Answer the greater of the receiver and the <magnitude>, operand.
	 Implementation Note: #< is used since other relational operators are often implemented 
	in terms of it."

	^self < operand
		ifTrue:  [operand]
		ifFalse: [self]!

min: operand
	"Answer the lesser of the receiver and the <magnitude>, operand."

	^self < operand
		ifTrue:  [self]
		ifFalse: [operand]! !

MemoryManager comment:
'MemoryManager is a singleton class whose sole instance is responsible for scheduling garbage collection, performing finalization, saving the image, etc.

The MemoryManager owns two processes which are responsible for performing certain garbage collection activities in synchronization with the image. The garbage collector itself cannot perform these tasks because it runs asynchronously in the VM. The first of these processes is responsible for sending #finalize messages to objects that were previously marked as finalized before they expired. It does this by consuming objects from a queue which is populated by the collector. This activity is performed at low priority, as in general it is considered that reclaiming resources is a lower priority activity than interactive tasks. Also the asynchronous nature of garbage collection makes it unpredictable when (if ever) an object will actually be ready for finalization. However, to avoid the queue growing indefinitely when a higher priority CPU intensive task is consuming all available cycles, the finalization queue has a "high water mark". When the collector enqueues a finalizable object and finds the queue has passed the high water mark, it sends an interrupt (via the Processor object) to indicate this condition. The MemoryManager responds by temporarily boosting the priority of the finalization task to a relatively high level (above the normal "user" levels), so that it is cleared down quickly.

There is also a "bereavement" queue which is managed in a similar way. The bereavement queue is populated by the collector with weakling objects (i.e. those with weak references) when they lose one or more of those references. Bereaved objects are consumed from the bereavement queue and sent #elementsExpired: messages by the "undertaker" process. A significant difference from the finalization process is that the undertaker runs at a very high priority in order to guarantee that weak objects are repaired immediately.

Note that collections that nil weak references can only be scheduled from the image (e.g. by the background idle process), never asynchronously by the VM. This is so that weak objects can be operated on atomically without the rug being pulled from under their feet by the collector.

Instance Variables:
	finalizer		<Process>. Low priority task responsible for sending #finalize message to finalizable objects.
	lastRequests	<Semaphore>. Semaphore signalled the GC when finalizable objects enqueued for finalizer.
	hospice		<Array>. Queue of objects requiring finalization. Growns dynamically by the GC as required.
	hospiceHighWater	<integer>. Level at which GC interrupts to notify finalizable garbage building up (default 64)
	reserved		Reserved for future use.
	undertaker		<Process>. High priority task responsible for repairing weak collections.
	bereavements	<Semaphore>. Semaphore signalled by GC when weak collections have suffered bereavements.
	bereaved		<Array>. Queue of weak collections which have suffered losses.
	bereavedHighWater	<integer>. Level at which GC interrupts to notify bereaved queue building up (default 32).
	gcInterval		<integer>. Milliseconds between major GC cycles.
	lastGCTime	<integer>. Milliseconds clock at last major GC cycle.
	lastGCDuration	<integer>. Duration in milliseconds of last major GC cycle.
	objectHeaderSize	<integer>. Number of bytes in object headers allocated by the VM (a constant).

Class Variables:
	GCInterval	<integer>. Default GC interval.
	Current		<MemoryManager>. Singleton instance.

'!
!MemoryManager class methodsFor!

current
	"Answer the singleton instance of the receiver.
	N.B. This instance can only be replaced with #become:, and the format
	must be the same."

	^Current
!

gcInterval: anInteger
	"Set the interval between GC's (idle time) to anInteger"

	GCInterval := anInteger!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Initialize the class variables of the receiver
		Current		-	The singleton instance of the receiver. Can be replaced with an 
						alternative memory manager if desired by sending #current:.
		GCInterval		-	Minimum idle time (milliseconds) between scheduled GC's"

	GCInterval := 15000.
	Current isNil ifTrue: [Current := super new initialize].
	"GUID is not properly set up by boot"
	self setGuid: (GUID fromString: '{703BD0AD-FBFF-4D00-866B-B80387F7B1D7}')!

new
	"The receiver is a singleton class."

	^self shouldNotImplement!

removeFromSystem
	"Private - Remove the receiver completely from the system.
	Override because this class is critical to system operation, 
	and must not be deleted."

	^self shouldNotImplement! !

!MemoryManager methodsFor!

aboutToIdle
	"Private - The system is about to quiesce, see whether its appropriate to reschedule 
	memory management activities. At the moment we just check that the finalization processes
	are still alive, and if not fork new ones."

	| now interval |
	self ensureProcessesRunning.
	Delay aboutToIdle.
	now := self millisecondClockValue.
	interval := now - lastGCTime.
	(interval > self gcInterval or: [interval < 0]) ifFalse: [^self].
	self collectGarbage.
	lastGCDuration := self millisecondClockValue - now max: 10.
	gcInterval := GCInterval max: (lastGCDuration * 2 max: self minGCInterval)!

administerLastRites
	"Private - Dequeue dying objects from the system finalization queue, and send them a 
	#finalize message. Multiple finalization processes are permissible because access to the 
	VM queue is atomic (which is in any case required for synchronisation with the VM's garbage 
	collection activities). This allows a user Process to synchronously perform finalization at 
	certain points, for example, so that all objects pending finalization are processed before 
	the image is saved. This may be necessary because the Finalizer rusually uns at a very low priority."

	| dying |
	[(dying := self dequeueForFinalization) isNil] whileFalse: [dying finalize].
	finalizer priority: self finalizerPriority!

bereavedOverflow: interruptArg
	"Private - The VM has detected that the bereavement queue has reached
	its high water mark. This should not happen, because the undertaker
	process runs at very high priority. If it does happen, then presumably
	it is because the Undertaker has died, and must be restarted."

	Notification signal: 'WARNING: Bereavement queue overflow'.
	self ensureProcessesRunning
!

bytesUsedByObject: anObject 
	"Answer the memory consumed directly by the <Object> argument. This does not include any
	space used by objects referenced from the object, and neither does it include any overhead
	such as heap overhead. The calculation is implementation dependent, and may change in new
	versions of Dolphin."

	| bodySize |
	anObject isImmediate ifTrue: [^0].
	"The body is rounded to a multiple of 8 bytes"
	bodySize := (anObject class isPointers 
				ifTrue: [(anObject basicSize + anObject class instSize) * VMConstants.IntPtrSize]
				ifFalse: [anObject basicSize + (anObject class isNullTerminated ifTrue: [1] ifFalse: [0])]) + 7 
				bitAnd: -8.
	"Each object has a header containing a pointer to the body, a class Oop, a intptr object size, and an intptr of flags, i.e. 4 machine words (16 or 32 bytes))"
	^bodySize + (VMConstants.IntPtrSize * 4)!

collectGarbage
	"Private - Invoke the fast (non-compacting) garbage collector to reclaim inaccessible objects
	(those not reachable from root objects, such as the SystemDictionary, Smalltalk),
	and perform the grim reaping of objects which only have weak references from the roots
	of the world. Such objects are queued for finalization if so marked (see 
	Object>>beFinalizable). Objects marked as weak (see Object>>beWeak) will have their 
	losses replaced with the Corpse object, and if an instances of mourning classes (see 
	Behavior>>makeMourner) they will be queued to receive a #elementsExpired: message 
	informing them of the scale of their losses.

	If following the GC there are any objects awaiting finalization in the queue, then
	the Finalizer is signalled via its Semaphore, and it finalizes all objects waiting in
	the queue.

	This message is sent from system idle processing, but can also be invoked directly if desired.

	The MemoryManager makes certain guarantees to objects marked as requiring finalization:
	-	Such objects will receive a #finalize message, at some interval
		(of unspecified duration) after their last reference from an object not
		marked as weak has been cleared.
	- 	Objects with last requests are guaranteed to receive only a single #finalize 
		message no matter how many objects weakly reference them.
	-	Objects with last requests will die immediately after they have carried out
		their last requests.

	Should an objects' #finalize methods cause, directly or indirectly, further references to be 
	taken to itself (e.g. by assignment to variables), then it will receive a reprieve and continue 
	to live. Should such an object require a further finalization message the next time it's on its 
	death bed, then it must be sent the #beFinalizable message again, because its finalization mark 
	is cleared when it is queued for finalization.
	
	It may be that an application requires that finalized objects be able to suspend their own 
	deaths, and this is the reason for the above described behavior, but it is necessary to
	regenerate any weak references still required, as these will have been lost.

	The guarantees to objects with weak references are:
	-	They will receive one, and only one, #elementsExpired: message following each GC,
		should they suffer a bereavement or bereavements, and the argument will inform them
		how many NEW Corpses they have.
	-	Former weak references will have been replaced with references to the Corpse 
		object.
	
	Note that the GC does not remove references to corpse from previous reapings.
	Should this be the behaviour desired, then weaklings must clear away corpses themselves
	from their #elementsExpired: method."

	lastGCTime := self millisecondClockValue.
	self primCollectGarbage: 0!

compact
	"Private - Invoke the slow (compacting) garbage collector to minimize the size
	of the object memory. Answers the number of objects in the system following 
	compaction. See #collectGarbage for further GC details."

	^self primCompact
!

dequeueBereavementInto: anArray
	"Private - Remove the next entry from the system bereavement queue and populate anArray
	with its contents. Answers true if an element was dequeued into anArray, or false if the queue is empty.

	Primitive failure reasons:
		0 -	anArray is not an Array, or is not of sufficient size to hold a complete queue entry."

	<primitive: 119>
	^self primitiveFailed
!

dequeueForFinalization
	"Private - Answer the next entry in the system finalization queue, or nil if it is
	empty. The primitive should not fail."

	<primitive: 118>
	^self primitiveFailed
!

directFunerals
	"Private - Dequeue bereaved objects from the system bereavement queue, and send them an 
	#elementsExpired: message with an argument informing them of the magnitude of their losses. 
	Multiple funeral direction processes are permissible because access to the VM queue is atomic 
	(which is in any case required for synchronisation with the VM's garbage collection activities). 
	This allows a user Process to synchronously send #directFunerals at certain points, though this 
	should not be necessary because the Undertaker (necessarily) runs at a very high priority."
	
	| queueEntry |
	queueEntry := Array new: 2.
	[self dequeueBereavementInto: queueEntry] 
		whileTrue: [(queueEntry basicAt: 1) elementsExpired: (queueEntry basicAt: 2)]!

ensureProcessesRunning
	"Private - If the finalization processes have not been forked, or have died, 
	or are suspended on Semaphores other than the receiver's, refork them"

	(finalizer isNil or: [(finalizer isAlive: lastRequests) not])
		ifTrue: [self forkFinalizer].
	(undertaker isNil or: [(undertaker isAlive: bereavements) not])
		ifTrue: [self forkUndertaker]
	!

finalizer
	"Private - Answer the finalizer <Process>."

	^finalizer!

finalizerMain
	"Private - Wait for objects to be queued to the system finalization queue, then attempt to
	empty that queue. The VM signals the queue semaphore each time it queues a group of objects
	to the queue so the semaphore's signal count does not reflect the number of elements waiting
	in the queue (this is to reduce the asynchronous signalling overhead and to permit user code
	to force synchronous finalization by directly invoking administerLastRites). Should the
	finalizer be prematurely terminated by an error occurring in a #finalize method, then it
	will be restarted the next time the system goes idle, but the semaphore's signal count will
	not be reset, so any waiting objects should get serviced in the near future, assuming
	Processor time is available. Should the VM detect that the finalization queue has reached
	the configured high water mark, then it will send an interrupt to the processor, which
	forwards it to the current memory manager. The default action on receipt of the interrupt is
	to raise the priority of the finalization process to lowIOPriority. After each iteration
	through #administerLastRites we set the priority back to its initial priority, so it never
	remains permanently elevated."

	finalizer := Processor activeProcess.
	finalizer name: 'Finalizer'.
	[finalizer == Processor activeProcess] whileTrue: 
			[lastRequests
				wait;
				excessSignals: 0.
			self administerLastRites]!

finalizerPriority
	^Processor systemBackgroundPriority!

forkFinalizer
	"Private - Start/restart the finalization process which oversees the administration of
	last rites. Note that because the finalizer runs at a low priority, finalization receives
	a low priority. For this reason, and others, it is not a good idea to rely on finalization
	to release limited resources."

	"Notification signal: self class name , ': Restarting Finalizer process...'."
	[self finalizerMain] forkAt: self finalizerPriority!

forkUndertaker
	"Private - Start/restart the process which directs funerals on behalf of objects 
	with weak references which suffer bereavements during a garbage collect. 
	The undertaker MUST run at a priority above that of any process likely to make 
	use of weakly referencing objects, unless those objects are prepared to handle 
	the appearance of Corpses before they receive a notification of the loss. 
	The undertaker's task is to inform weakly referencing objects of their bereavements, 
	so that they can make the necessary repairs. Weakly referencing objects that need 
	to make repairs, will almost certainly need to make these repairs to the exclusion 
	of other processes, so they will need to use a Mutex around all accesses (the Pattern 
	is: subclass the strong version, add a mutex, perform all accesses to potentially shared 
	data inside a critical section against the mutex with a supersend, implement 
	elementsExpired: repairing the shared data inside the mutex)."

	Notification signal: self class name, ': Restarting Undertaker process...'.
	[self undertakerMain] forkAt: Processor highIOPriority!

gcInterval
	"Private - Answer the interval (in milliseconds) between idle time GCs"

	^gcInterval!

hospiceOverflow: interruptArg 
	"Private - The VM has detected that the finalization queue has reached its high water mark.
	Boost the priority of the finalizer thread so that it will run the next time thread
	scheduling occurs."

	finalizer setPriority: Processor lowIOPriority!

initialize
	"Private - Initialize the receiver's instance variables.
	N.B. Use of this method in a running system is likely to result in 
	system failure."

	self resetGCStats.
	hospiceHighWater := 64.	"Max finalization queue before high priority administerLastRites"
	bereavedHighWater := 16.
	hospice := Array new: hospiceHighWater * 2.
	bereaved := Array new: bereavedHighWater * 2.
	lastRequests := Semaphore new.
	bereavements := Semaphore new.
	self registerObjects!

instanceStats: anArrayOrNil 
	"Answer an <LookupTable>, containing counts of the number of instances and the approximate storage used by all instances of a set of classes.
	If the argument is nil, then the table contains the statistics for every class in the system. Note that this will also include metaclass instances. If the
	argument is a collection of classes then the table will contain statistics for only those classes."

	| triplets answer |
	answer := IdentityDictionary new.
	triplets := self primInstanceStats: (anArrayOrNil ifNotNil: [anArrayOrNil asArray]).
	1 to: triplets size
		by: 3
		do: [:i | answer at: (triplets at: i) put: (Array with: (triplets at: i + 1) with: (triplets at: i + 2))].
	^answer!

millisecondClockValue
	"Private - Answer the current millisecond clock value."

	<primitive: 174>
	^self primitiveFailed!

minGCInterval
	"Private - Answer the minimum interval (in milliseconds) between idle time GCs"

	^5000!

objectCount
	"Private - Answer an approximate indication of the number of live objects in the system
	at the time of invocation."

	<primitive: 169>
	^Class allRoots inject: 0 into: [:sum :e | sum + e primAllSubinstances size]!

objectHeaderSize
	"Private - Answer the value of the receiver's ''objectHeaderSize'' instance variable."

	^objectHeaderSize!

onPreSaveImage
	"Private - Clean up before a snapshot. We perform a compacting garbage collect
	to minimize the image size, and then move objects queued for finalization. 
	We need to ensure that all objects pending finalization do actually get finalized 
	to ensure that those holding external resources are cleared down. If any such objects
	were later finalized in a new session their internal state would be invalid (they will 
	contain invalid handles), but in any case the finalization queue is renewed on restart.
	It is not necessary to inform weak objects of their losses, because the Undertaker 
	runs at a high priority and should interrupt us to perform that task."

	self
		compact;
		administerLastRites!

onStartup
	"Private - The system has just started, kick start the Memory Manager."

	self resetGCStats.
	self registerObjects.
	self ensureProcessesRunning!

otOverflow: anInteger 
	"Private - The VM has allocated more memory for objects headers. The <integer>
	argument specifies the new size of the OT. Initiate a GC if we haven't done so very 
	recently (we try to avoid performing unecessary GCs when object growth rates are
	very high, as that may not be due to the accumulation of garbage, but just the result 
	of normal activity). N.B. Sent with interrupts disabled from the Processor in response 
	to an interrupt generated by the VM."

	| now |
	now := self millisecondClockValue.
	(now - lastGCTime) > (lastGCDuration * 4) ifFalse: [^self].
	lastGCTime := now.
	self primCollectGarbage: 1.
	lastGCDuration := self millisecondClockValue - now max: 10!

primCollectGarbage: flags
	"Private - Invoke the fast (non-compacting) garbage collector. Answers the receiver.
	The primitive should not fail.
	Flags:
		1	- Treat all references as strong (i.e. ignore weak attribute of objects).
	"

	<primitive: 112>
	^self primitiveFailed!

primCompact
	"Private - Invoke the slow (compacting) garbage collector. Answers the number of
	objects in the system following compaction. The primitive should not fail."

	<primitive: 115>
	^self primitiveFailed

!

primInstanceStats: anArrayOrNil 
	"Private - Answer a packed <Array> of triplets {class, instance count, approximate storage
	usage}. If the argument is nil, the answer will contain a triplet for every class in the
	system. If the argument is an array, it is expected to contain the classes for which
	statistics are to be returned. The primitive runs in constant time no matter how many
	classes you choose, in particular it takes just as long to return the stats for one class as
	it does for all classes, and therefore it is less efficient than using #primAllInstances
	unless requesting stats for several classes at once.

	Primitive failure reasons: 
		0 - anArrayOrNil is not an Array, or nil."

	<primitive: 179>
	^self primitiveFailed!

registerObjects
	"Private - Register the finalize and bereavement queue Semaphores with the VM."

	VMLibrary default
		registryAt: #MemoryManager put: self;
		registryAt: #Corpse put: DeadObject current;
		registryAt: #FinalizeQueue put: hospice;
		registryAt: #FinalizeSemaphore put: lastRequests;
		registryAt: #BereavementQueue put: bereaved;
		registryAt: #BereavementSemaphore put: bereavements.

	"Signal the semaphores in case any objects waiting in the queues"
	lastRequests signal.
	bereavements signal
	!

resetGCStats
	lastGCTime := lastGCDuration := 0.
	gcInterval := GCInterval!

undertaker
	"Private - Answer the value undertaker <Process>."

	^undertaker!

undertaker: aProcessOrNil
	"Private - Set the receiver's undertaker process to the argument, aProcessOrNil, 
	terminating any existing undertaker. The undertaker funerals for bereaved weak objects 
	(i.e. it sends them #elementsExpired: messages)."

	undertaker isNil ifFalse: [undertaker terminate].
	undertaker := aProcessOrNil!

undertakerMain
	"Private - Wait for bereaved objects to be queued to the system bereavement queue, then attempt
	to empty that queue. The VM signals the queue semaphore each time it queues a group of objects to 
	the queue	so the semaphore's signal count does not accurately reflects the number of elements waiting 
	in the queue (this is to reduce the asynchronous signalling overhead and to permit user code to force
	synchronous notification by synchronously sending #directFunerals). Should the undertaker be
	prematurely terminated by an errror occurring in an elementsExpired: method, then it will be 
	automatically restarted."

	undertaker := Processor activeProcess.
	undertaker name: 'Undertaker'.
	[undertaker == Processor activeProcess] whileTrue: [
	 	bereavements wait.
		self directFunerals]! !

Message comment:
''!
!Message class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

selector: aSymbol 
	"Answer a new instance of the receiver with the selector, aSymbol"

	^self selector: aSymbol arguments: #()!

selector: aSymbol argument: anObject 
	"Answer a new instance of the receiver with selector, aSymbol, and argument, 
	anObject"

	^self selector: aSymbol arguments: (Array with: anObject)!

selector: aSymbol arguments: anArray 
	"Answer a new instance of the receiver with selector, aSymbol, and arguments, anArray"

	<primitive: 157>
	^self new setSelector: aSymbol arguments: anArray! !

!Message methodsFor!

= aMessage
	"Answer true if the receiver and aMessage are equal.
	Since we override = we also override hash."

	^self == aMessage or: [
		self species == aMessage species and: [
			self selector == aMessage selector and: [self arguments = aMessage arguments]]]!

argumentCount
	"Answer the <integer> number of arguments in the receiver's
	message."

	^args size!

arguments
	"Answer a <sequencedReadableCollection> containing the receiver's
	arguments."

	^args!

arguments: anArray
	"Set the argument list of the receiver to anArray.
	Answer the receiver."

	args := anArray
!

asSymbol
	"Answer the receiver's <selector>."

	^selector!

forwardTo: anObject
	"Send the receiver Message to anObject for evaluation, 
	answering the result"

	^anObject perform: selector withArguments: args!

forwardTo: anObject with: aParameter
	"Private - Send the receiver Message to anObject for evaluation with aParameter, 
	answering the result"

	^anObject perform: selector with: aParameter

!

forwardTo: anObject withArguments: anArray
	"Private - Send the receiver Message to anObject for evaluation with anArray of arguments, 
	answering the result"

	^anObject perform: selector withArguments: anArray
!

hash
	"Since we implement = we must also implement hash to match"
	
	^selector hash + args hash!

messages
	"Answer a <collection> of the messages sent by the receiver."

	^Array with: self selector!

printOn: target 
	"Append a short textual description of the receiver to the <puttableStream>, 
	target, in the form a developer might want to see it (attempt an evaluable
	literal representation)."

	target
		nextPutAll: self class name;
		nextPutAll: ' selector: ';
		print: selector.
	args notEmpty 
		ifTrue: 
			[target
				nextPutAll: ' arguments: ';
				print: args]!

selector
	"Answer the receiver's <selector>"

	^selector!

selector: aSymbol
	"Set the <selector> for the receiver to the argument."

	selector := aSymbol.!

setSelector: aSymbol arguments: argArray
	"Private - Initialize the receiver's instance variables."

	selector := aSymbol.
	args := argArray!

value: anObject
	"Answer the result of sending the receiver to the object, anObject.
	Implementation Note: By implementing this selector from the monadic
	valuable protocol, we enable the substitution of Messages for a
	large number of parameterization cases where blocks would otherwise
	be required."

	^self forwardTo: anObject


!

value: receiver value: argument
	"Answer the result of sending the receiving message to the object, receiver,
	with the argument, argument.
	Implementation Note: By implementing this selector from the dyadic
	valuable protocol, we enable the substitution of Messages for a
	further set of parameterization cases where blocks would otherwise
	be required."

	^self forwardTo: receiver with: argument!

valueWithArguments: argArray
	"Evaluate the receiver with an <Array> of arguments in argArray"

	^self forwardTo: argArray first withArguments: (argArray copyFrom: 2)! !

MessageBoxAbstract comment:
'MessageBoxAbstract is the abstract class of dialogs that display a message to the user to acknowledge. Subclasses might include a number of responses that the user can make, typically by pressing buttons, making them useful for asking questions as well as displaying informational messages.

Instance Variables:
	text			<String>. Message text.
	caption		<String>. Caption text.
	owner		<view>

Class Variables:
	DefaultCaptions		<LookupTable> mapping <integer> message box iocn styles (e.g. MB_ICONQUESTION) to caption <String>s
	IconStyles			<IdentityDictionary>

'!
!MessageBoxAbstract class methodsFor!

defaultCaption: anInteger
	"Private - Answer a suitable default caption based on style of the 
	message box."

	^DefaultCaptions at: anInteger ifAbsent: [
		SessionManager current applicationName]!

errorMsg: aString 
	"Display a message with the default error caption, standard error icon, the specified
	<readableString> error message, and an OK button. Answer the receiver."

	self errorMsg: aString caption: nil!

errorMsg: errorString caption: titleString 
	"Display a Windows balloon tooltip for the receiver with the specified <readableString>
	caption, standard error icon, the specified <readableString> error message, and an OK button."

	(self new)
		caption: titleString;
		errorMsg: errorString!

initialize
	"Private - Initialize the class variables of the receiver:
		self initialize

	"

	IconStyles := (IdentityDictionary new)
				at: #none put: 0;
				at: #error put: MB_ICONERROR;
				at: #prompt put: MB_ICONQUESTION;
				at: #warning put: MB_ICONWARNING;
				at: #notify put: MB_ICONINFORMATION;
				at: #user put: MB_USERICON;
				shrink;
				yourself.

	"Where there is no entry in the table for the message box type, the application name is used."
	DefaultCaptions := (LookupTable new)
				at: #confirm put: 'Please confirm...';
				at: #notify put: 'Note';
				shrink;
				yourself	"Use the Windows default caption"!

new
	"Answer a new, initialized, instance of the receiver."

	^super new initialize!

notify: aString 
	"Display a message with the default information caption, standard information icon,  the
	specified <readableString> message, and an OK button."

	self notify: aString caption: nil!

notify: notifyString caption: titleString
	"Display a message with the specified <readableString> caption, standard information icon,
	and the specified <readableString> message."

	^self new 
		caption: titleString;
		notify: notifyString!

warning: aString 
	"Display a message with the default warning caption, standard warning icon, the specified
	<readableString> warning message, and an OK button. Answer the receiver."

	self warning: aString caption: nil!

warning: warningString caption: titleString 
	"Display a Windows balloon tooltip for the receiver with the specified <readableString>
	caption, standard warning icon, the specified <readableString> warning message, and an OK
	button."

	(self new)
		caption: titleString;
		warning: warningString! !

!MessageBoxAbstract methodsFor!

beep
	"Private - Play the system parp appropriate for the style of the receiver."

	| iStyle |
	iStyle := self iconStyleFlag.
	iStyle = 0 ifFalse: [UserLibrary default messageBeep: iStyle]!

caption
	"Answer the receiver's current caption."

	^caption ifNil: [self defaultCaption]!

caption: aString 
	"Set the receiver's caption to be the argument, aString."

	caption := aString!

defaultCaption
	^self class defaultCaption: self iconStyle!

errorMsg: textString 
	"Display a Windows message box for the receiver with the currently
	configured caption, and the error message, textString. Answer the 
	receiver (after the message box has closed)."

	self text: textString.
	self iconStyle: #error.
	^self open!

iconStyle
	"Answer the receiver's symbolic icon style name."

	^IconStyles keyAtValue: self iconStyleFlag!

iconStyle: aSymbol 
	"Set the receiver's icon style to that named by the argument."

	self iconStyleFlag: (IconStyles at: aSymbol)!

iconStyleFlag
	"Private - Answer the  icon style flag of the receiver (an integer from the MB_ICONXXX enumeration)."

	^self subclassResponsibility!

iconStyleFlag: anInteger 
	"Private - Set the receiver's icon to be that named by the argument."

	^self subclassResponsibility!

notify
	#deprecated.
	self iconStyle: #notify!

notify: notifyString 
	"Display a bubble message box with the current caption, the
	notification icon, and the specified informational message."

	self text: notifyString.
	self iconStyle: #notify.
	^self open!

open
	"Display the message box for the receiver, and answer a portable symbolic constant 
	for the button pressed by the user."

	^self subclassResponsibility!

owner
	^owner!

owner: aViewOrHandle 
	"Set the receiver's owning window handle to be the argument, aHandle.
	aHandle can be 0 if desired. If the handle is not explicitly set to 0,
	then the current active window handle will be used."

	owner := aViewOrHandle!

ownerHandle
	| handle |
	handle := owner ifNil: [UserLibrary default getActiveWindow] ifNotNil: [owner].
	^handle notNil ifTrue: [handle asParameter] ifFalse: [0]!

text
	^text!

text: aString 
	"Set the receiver's text message to be the argument, aString."

	text := aString!

warning
	#deprecated.
	self iconStyle: #warning!

warning: warningString 
	"Display a Windows message box for the receiver with the currently configured caption,
	and the warning message, warningString, and an OK button. Answer the receiver (after 
	the message box has closed)."

	self text: warningString.
	self iconStyle: #warning.
	^self open! !

MessageSequenceAbstract comment:
''!
!MessageSequenceAbstract class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer an instance of the receiver; instance require initialization"

	^super new initialize! !

!MessageSequenceAbstract methodsFor!

add: anEventMessageSend
	"Adds a <MessageSend> to this sequence."

	^self subclassResponsibility!

argumentCount
	"Actually the argument count might be variable, but this seems the only sensible 
	implementation for this part of the protocol <message>."

	^0!

asMinimumRepresentation
	"Attempts to fold the receiver to its minimum representation.
	If the receiver is empty return nil, otherwise return the receiver unchanged.
	Subclasses may re-implement this to compress dead space in themselves"
	
	^self size == 0 ifFalse: [self]
!

forwardTo: anObject
	"Forwards all the messages in this sequence to anObject. Answers the
	result of the last message in the sequence."

	| answer |
	self messagesDo: [:each | answer := each forwardTo: anObject].
	^answer!

includes: aMessage
	"Answer whether the argument, anObject, is equal to one of the 
	receiver's elements."

	self messagesDo: [:each | aMessage = each ifTrue: [^true]].
	^false!

isEmpty
	"Answers true if there are no message in this sequence"

	^self size == 0!

messagesDo: aBlock
	"Private - Enumerates through the receiver"

	^self subclassResponsibility!

notEmpty
	"Answers true if there are any messages in this sequence"

	^self isEmpty not!

value
	"Plays all the messages in this sequence. They are assumed to be MessageSends
	that are fully qualified with their receivers. Answers the result of the last 
	message in the sequence."

	| answer |
	self messagesDo: [:each | answer := each value].
	^answer!

value: arg1
	"Plays all the messages in this sequence passing the <Object> arg1 as a parameter. 
	They are assumed to be <message>s that are fully qualified with their receivers. 
	Answers the result of the last message in the sequence."

	| answer |
	self messagesDo: [:each | answer := each value: arg1].
	^answer!

value: arg1 value: arg2
	"Plays all the messages in this sequence passing the <Object>s arg1 and arg2 as parameters. 
	They are assumed to be <message>s that are fully qualified with their receivers. 
	Answers the result of the last message in the sequence."

	| answer |
	self messagesDo: [:each | answer := each value: arg1 value: arg2].
	^answer!

valueWithArguments: argArray
	"Evaluate the receiver with an <Array> of arguments in argArray"

	| answer |
	self messagesDo: [:each | answer := each valueWithArguments: argArray].
	^answer! !

MethodProtocol comment:
'MethodProtocol is a meta-information class which groups a set of selectors to form a cohesive unit of behavior which is independent of the class hierarchy. A class is said to conform to a MethodProtocol if it implements each of the selectors in the protocol, and if it claims to support the protocol, i.e. implementation of the set of selectors is a necessary but not sufficient condition because the implementation of the selectors must be as specified by the protocol. The precise semantics of the protocol are not formally specified by instances of this class, and cannot be tested by it, therefore if the programmer asserts that a class conforms to a protocol and it implements all the necessary selectors, that is deemed sufficient for conformance. A class automatically conforms to any protocols to which its superclasses conform.

If a method implementing a required protocol selector is removed from a class then the system automatically removes the protocol from the list supported by that class. Conversely if a protocol is extended by the addition of new selectors then this may result in the addition of stub method implementations to all conforming classes which do not currently respond to that selector. These stub methods raise an error when invoked and may be located by browsing the ''not yet implemented'' pseudo-category.

Conformance to a protocol may be tested a run-time by sending the message #conformsToProtocol: to the class. This is akin to send a #respondsTo: message to enquire whether a class understands an individual selector. By maintaining the protocol invariant that all conforming classes must respond to all a protocols selectors the system can perform a very fast conformance test (symbol lookup with in a set, chaining up the class hierarchy).

Each class (ClassDescription) stores a set of the symbolic names of the protocols to which it conforms, excluding those to which its superclasses conform. Testing for protocol conformance (using #conformsToProtocol:) is by symbolic name, and therefore it may be possible to strip the MethodProtocol objects themselves from a run-time application.

It is a good idea to keep protocols small, as this reduces the burden of implementation in a new class (you can quickly add a full set of stub methods in a class by dragging the protocol into the class, or by using the Add/Protocol command, in the Class Hierarchy Browser). You should also avoid extending the system defined protocols: Most of these are as defined by the ANSI Smalltalk Standard.

Instance Variables:
	name	<Symbol>		Unique symbolic name of the protocol (identity)
	comment	<String> or nil.	Description of the protocol (e.g. its specifiction)
	selectors	<IdentitySet>	The set of selectors required by the protocol
	flags	<integer>		Various boolean attributes of the protocol

Class Variables
	Protocols		<IdentityDictionary>	Maps protocol names to instances.
	StubAddedSignal	<NotificationSignal> Resumable signal raised when a stub method is generated.
	ReadOnlyMask	<integer> Masks read-only flag from flags instance variable
	ANSIMask	<integer> Masks ANSI flag from flags instance variable

'!
!MethodProtocol class methodsFor!

allMethodProtocols
	"Answer the a <collection> of all <MethodProtocols>s current registered in the system.
		MethodProtocol allMethodProtocols size
	"

	^Protocols asArray!

existing: protocolName
	"Answer an existing <MethodProtocol> with the specified
	<Symbol> name, protocolName. Signals a NotFound exception
	if protocolName does not specify an existing protocol."

	^Protocols at: protocolName asSymbol.!

exists: protocolName
	"Answer whether the named protocol exists."

	^Protocols includesKey: protocolName asSymbol!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables.
		MethodProtocol initialize
	"

	StubAddedSignal := NotificationSignal description: '%1'.
	Protocols isNil ifTrue: [self initializeProtocols].

	ReadOnlyMask := 1.
	ANSIMask := 2.!

initializeProtocols
	"Private - Discard all existing protocols."

	Protocols := IdentityDictionary new!

name: protocolName
	"Answer a new or existing <MethodProtocol> with the specified
	<Symbol> name, protocolName."

	| symbol |
	symbol := protocolName asSymbol.
	^Protocols at: symbol ifAbsentPut: [self basicNew setName: symbol; yourself]!

new
	"MethodProtocols must be unique for any particular name, and must be instantiated with the #name:
	method."

	^self shouldNotImplement!

purgeUnused
	"Discard all method protocols which are not currently implemented by any class in the system.
	This might take a while.
		MethodProtocol purgeUnused
	"

	| allUsed |
	allUsed := IdentitySet new.
	self environment allBehaviorsDo: [:c | allUsed addAll: c protocols].
	(Protocols difference: allUsed) do: [:p | 
		self assert: [p behaviors isEmpty].
		Protocols removeKey: p name]

		
		!

removeProtocol: protocolName
	"Remove the <MethodProtocol>, named by the <symbol>, protocolName, from the system."

	| symbol prot |
	symbol := protocolName asSymbol.
	prot := Protocols at: symbol.
	prot baseBehaviors do: [:c | c removeProtocol: prot].
	Protocols removeKey: symbol.
	self environment trigger: #protocolRemoved: with: prot!

separator
	"Private - Answer a Character used to split the individual names in a
	complete category."

	^ $-!

stubAddedSignal
	"Private - Answer the signal which is raised when a stub method is added
	automatically in order to keep a class' protocol implementation complete."

	^StubAddedSignal! !

!MethodProtocol methodsFor!

<= comperand
	"Answer whether the receiver is less than or equal to the <MethodProtocol>,
	comperand. This is to allow protocols to be sorted with the default sort block."

	^self name <= comperand name!

= comperand
	"Answer whether the receiver is considered equal to the <Object>, comperand."

	^self species == comperand species and: [self asSymbol == comperand asSymbol]!

addAllSelectors: newSelectors 
	"Add the <collection> of <Symbol>s, newSelectors, to the set of method selectors 
	included in the receiver's protocol. Then ensure that the MethodProtocol invariants are
	maintained by ensuring that all conforming classes can understand the new selectors
	(by adding a dummy implementations if necessary), and that their implementing
	methods are recorded in the protocol."

	| extras |
	extras := newSelectors difference: selectors.
	extras notEmpty 
		ifTrue: 
			["Record the additional selectors in the protocol"

			selectors addAll: extras.

			"Ensure all conforming classes implement the newly expanded protocols.
		 Note that it is very important that #behaviors orders superclasses before subclasses"
			self baseBehaviors do: 
					[:e | 
					extras do: [:selector | self addClass: e selector: selector].
					"Ensure class marked as changed even if no stub methods added"
					e isChanged: true].

			"Finally inform any observers (browsers) of the change"
			self class environment trigger: #protocolUpdated: with: self]!

addClass: class
	"Add the <ClassDescription>, class, to the collection of classes associated with the receiver.
	Including a class in a protocol asserts that the class conforms to the protocol. In
	order to be sure that such is true, we generate default implementations for any
	messages the class does not currently implement."

	(class conformsToProtocol: self) ifFalse: [
		self selectors do: [:s | self addClass: class selector: s].
		class addProtocol: self.

		"We don't need to mark the base classes as having been changed
		in this situation." 
		self class environment trigger: #protocolUpdated: with: self ]!

addClass: behavior selector: selector
	"Private - Add the <symbol>, selector, to the receiver's protocol in the <Behavior>, 
	behavior. i.e. ensure that the behavior can understand the selector by adding
	a dummy implementation if necessary."

	(behavior canUnderstand: selector) ifFalse: [
		self compileStub: selector into: behavior]!

addMethodSilently: method
	"Private - Add the <CompiledMethod>, method, to the collection of methods within 
	the receiver.  As this is a method protocol we must maintain the protocol invariant 
	that all claimed implementors must respond to all the selectors. If the protocol is
	extended by the addition of this method (i.e. its selector is a new one) this may involve
	compiling stub methods into conformant classes. Furthermore we must make sure that
	the class of the method implements the whole protocol."

	(selectors includes: method selector) ifFalse: [
		self addSelector: method selector].
	self addClass: method methodClass!

addProtocol: protocol
	"Add all the selectors in the <MethodProtocol>, protocol, to the set of method 
	selectors included in the receiver's protocol. Then ensure that the MethodProtocol
	invariants are maintained by ensuring that all conforming classes can understand
	the added selectors."

	protocol selectors do: [:each | self addSelector: each ].

	!

addSelector: selector
	"Add the <symbol>, selector, to the set of method selectors included
	in the receiver's protocol. Then ensure that the MethodProtocol invariants are
	maintained by ensuring that all conforming classes can understand the selector
	(by adding a dummy implementation if necessary), and that their implementing
	methods are recorded in the protocol."

	self addAllSelectors: (Array with: selector)!

ansi
	"Set the receiver to be marked as an ANSI standard protocol as defined in the American National
	Standard for Information Technology - Programming Languages - Smalltalk, ANSI NCITS 319-1998."

	^self isANSI: true!

asSymbol
	"Answer a <Symbol> which uniquely identifies the receiver."

	^name!

attributes
	"Answer a <collection> of the <Symbol>s specifying attributes of the receiver."

	| attr |
	attr := OrderedCollection new.
	self isANSI ifTrue: [attr addLast: #ansi].
	self isReadOnly ifTrue: [attr addLast: #readOnly].
	^attr!

attributes: attributes
	"Private - Set the attributes of the receiver to those named by the <Array> of <Symbol>s, attributes."

	(self attributes asSet equals: attributes asSet) ifFalse: [
		flags := 0.
		attributes do: [:e | self perform: e]]!

baseBehaviors
	"Answer a <collection> of all the <ClassDescription> objects which
	directly conform to the receiver without inheriting such conformance
	from a superclass."

	| conformers |
	conformers := OrderedCollection new.
	self class environment allBehaviorsDo: [:c | 
		(c protocolNames includes: name) ifTrue: [conformers add: c]].
	^conformers
!

behaviors
	"Answer a <sequencedReadableCollection> of all the <ClassDescription> objects which conform
	to the receiver in class hierarchy order (i.e. superclasses first)."

	| answer |
	answer := OrderedCollection new: 10.
	self class environment allBehaviorsDo:  [:c | (c conformsToProtocol: self) ifTrue: [answer addLast: c]].
	^answer!

comment
	"Answer a <readableString> describing the the receiver."

	^comment ifNil: ['']!

comment: blah
	"Set the receiver's comment to the <readableString>, blah.
	If blah is empty (or nil) then stored comment is set to nil."

	comment := blah = '' ifFalse: [blah]!

compileStub: selector into: behavior
	"Private - Compile a target implementation method with the identified by the <symbol>,
	selector, into the <ClassDescription>, behavior."

	| target args sig |
	target  := String writeStream: 128.
	args := selector argumentCount.
	args == 0
		ifTrue: [target nextPutAll: selector]
		ifFalse: [ 
			(args == 1 and: [selector isInfix])
				ifTrue: [target nextPutAll: selector; nextPutAll: ' operand']
				ifFalse: [ | keywords |
					keywords := selector keywords.
					(1 to: keywords size)
						do: [:i | target nextPutAll: (keywords at: i); space; 
								nextPutAll: 'arg'; display: i]
						separatedBy: [target space]]].
	target crtab; nextPutAll: '"This is an auto-generated target implementation for the protocol <';
		nextPutAll: self asSymbol; nextPut: $>; crtab; 
		nextPutAll: 'and remains to be correctly implemented."'; cr; crtab;
		nextPutAll: '^Error notYetImplemented'.
	behavior compile: target contents.
	sig := self class stubAddedSignal.
	sig notNil ifTrue: [
		target reset;
			nextPutAll: 'Protocol ';
			display: self;
			nextPutAll: ' added stub implementation of new message ';
			print: behavior;
			nextPutAll: '>>';
			print: selector.
		sig
			signal: target contents
			with: behavior]
!

contents
	"Answer a <collection> of all methods classified under the receiver."

	| foundMethods |
	foundMethods := Set new.
	self behaviors do: [:aBehavior |
		foundMethods addAll: (self methodsInBehavior: aBehavior)].
	^foundMethods!

displayOn: aStream
	"Append the receiver to aStream in a format that a user would want to see"

	aStream nextPut: $<; nextPutAll: name; nextPut: $>!

hash
	"Answer the <integer> hash value for the receiver."

	^self asSymbol hash!

includesMethod: method
	"Answer whether the receiver includes the <CompiledMethod>, method,
	which it does if the methods selector is part of the protocol."

	^(method methodClass conformsToProtocol: self) 
		and: [self includesSelector: method selector]!

includesSelector: selector
	"Answer whether the receiver includes the selector represented by the 
	<Symbol>, selector."

	^selectors identityIncludes: selector!

initialize
	"Private - Initialize the receiver."

	selectors := IdentitySet new.
	flags := 0!

isANSI
	"Answer whether the receiver is an ANSI standard protocol."

	^flags allMask: ANSIMask!

isANSI: aBoolean
	"Set whether the receiver is an ANSI standard protocol.
	Note that all ANSI protocols are considered 'ReadOnly' too."

	| newFlags |
	newFlags := aBoolean 
		ifTrue: [flags maskSet: (ANSIMask bitOr: ReadOnlyMask)]
		ifFalse: [flags maskClear: ANSIMask].
	newFlags ~= flags ifTrue: [
		flags := newFlags.
		self protocolUpdated].
!

isReadOnly
	"Answer whether the receiver is a read-only protocol which should not be updated by the tools
	(this is not enforced here)."

	^flags allMask: ReadOnlyMask!

isReadOnly: aBoolean 
	"Set whether the receiver is a read-only protocol."

	self isReadOnly == aBoolean ifTrue: [^self].
	flags := flags mask: ReadOnlyMask set: aBoolean.
	aBoolean ifTrue: [selectors rehash].
	self protocolUpdated!

methodsInBehavior: class
	"Answer all the methods in the <ClassDescription>, class, which are members of the receiver."

	^(class conformsToProtocol: self)
		ifTrue: [class methodDictionary select: [:m | self includesSelector: m selector]]
		ifFalse: [Set new]!

name
	"Answer the unique <readableString> name for the receiver."

	^name!

printOn: aStream
	"Append a representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		display: self!

protocolUpdated
	"Private - Flag the receiver as updated and inform any observers."

	self class environment trigger: #protocolUpdated: with: self.
	self updateBaseClasses.!

readOnly
	"Set the receiver to be a read-only protocol (i.e. one which has a fixed set of selectors.
	This is not enforced by the #addSelector:, etc, methods of this class, but is expected
	to be respected by the tools."

	^self isReadOnly: true!

removeAllSelectors: selectorsToRemove
	"Remove the <collection> of <symbol>s, selectors, from the set of method selectors included
	in the receiver's protocol. The absence of any of the selectors is ignored. Answer the argument."

	| missing |
	missing := IdentitySet new.
	selectorsToRemove do: [:s | selectors remove: s ifAbsent: [missing add: s]].
	selectorsToRemove size > missing size ifTrue: [self protocolUpdated].
	^selectorsToRemove
!

removeClass: class
	"Remove the <ClassDescription>, class, from the classes 'held' by the receiver.
	In the case of a protocol we must remove the protocol from the classes set of
	implemented protocols - note that we cannot do that if the protocol is inherited."

	class removeProtocol: self.
	self protocolUpdated!

removeSelector: selector
	"Remove the <symbol>, selector, from the set of method selectors included
	in the receiver's protocol."

	^self removeSelector: selector ifAbsent: [self errorNotFound: selector]!

removeSelector: selector ifAbsent: exceptionHandler
	"Remove the <symbol>, selector, from the set of method selectors included
	in the receiver's protocol."

	| answer |
	answer := selectors remove: selector ifAbsent: [^exceptionHandler value].
	self protocolUpdated.
	^answer!

rename: newName
	"Rename the protocol to have the new symbolic name, newName.
	N.B. This is not recommended, as there may be symbolic references to the old name."

	| implementors sym |
	implementors := self baseBehaviors.
	sym := newName asSymbol.
	(Protocols includesKey: sym) ifTrue: [self error: 'Duplicate protocol name'].
	implementors do: [:i | i removeProtocol: self].
	Protocols 
		removeKey: name;
		at: sym put: self.
	name := sym.
	implementors do: [:i | i addProtocol: self; isChanged: true].
	self class environment trigger: #protocolUpdated: with: self!

selectors
	"Answer a <collection> of the selectors which make up the receiver's protocol."

	^selectors!

setName: stem
	"Private - Set the name of the receiver to the <Symbol> equivalent 
	of the <readableString>, stem."

	name := stem asSymbol.
	self initialize!

updateBaseClasses
	"Private - The receiver has changed in such a way that it's
	base classes need to be marked as having been changed."

	self baseBehaviors do: [:each | each isChanged: true]
! !

ModalMsgLoop comment:
'ModalMsgLoop is a special process synchronisation object that can be used to block the main UI process while still servicing the message queue, without having to start a new UI process.

For example:

	sync := ModalMsgLoop new.
	[(Delay forSeconds: 10) wait. sync signal] fork.
	sync wait.
	Sound bell.

This will ring the bell after 10 seconds, without preventing the UI from updating. Of course this is a contrived example, since this could be achieved more easily by performing the delayed operation from the background process forked off to wait on the delay, however the mechanism is useful where one really wants to block the main UI process temporarily. Note that while the modal loop is active the <InputState>''s message pump will continue to dispatch all arriving Windows messages. If the requirement is that the application stop accepting further input while the modal loop is active (i.e. one just wants it to keep painting, not respond to further commands) it will be necessary to explicitly disable the application''s Windows.

Instance Variables:
	loop		<boolean>. Used to control termination of the modal loop.

'!
!ModalMsgLoop class methodsFor!

new
	"Answer a new initialized instance of the receiver."

	^super new initialize! !

!ModalMsgLoop methodsFor!

initialize
	"Private - Initialize the receiver's instance variables."

	loop := true!

signal
	"Terminate the modal loop, and return control to the sender of #wait."

	loop := false.
	SessionManager inputState prod
!

wait
	"Start the modal loop, returning when the receiver is signalled. While waiting the Windows
	message loop continues to be serviced, but keyboard and mouse input is discarded."

	SessionManager inputState loopWhile: [loop]! !

Model comment:
'Model is an abstract class whose subclasses implement the <model> protocol and represent domain level data that is likely to be observed by other objects. The Model hierarchy is part of the MVP framework although <model> classes may well be used outside of this framework. 

SmalltalkSystem help: ''Overviews/ModelViewPresenter''.

In general, <models> differ from other objects which would otherwise be simply subclasses of Object by triggering change events when aspects of their data are modified. This enables the Observers of this data to keep up-to-date with the changes. In the MVP framework a <view> is typically an Observer of a <model>''s data. 

The Model class provides a faster means of event triggering for its subclasses than is available in standard objects but, apart from this it supplies, no new facilities other than to conveniently group classes that be considered to act as models and place them within the <model> protocol.

Instance Variables:
	events	<EventsCollection> holding the model''s event registrations.



'!
!Model class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new initialize instance of the receiver."

	^super new initialize!

stbConvert: anArray fromVersion: anInteger 
	"Private - Convert from earlier version view by updating and answering the array of instance
	variables, instVarArray. "

	| instVars |
	instVars := anArray.
	anInteger < 1 ifTrue: [instVars := self stbConvertFromVersion0: instVars].
	anInteger < 2 ifTrue: [instVars := self stbConvertFromVersion1: instVars].
	anInteger < 3 ifTrue: [instVars := self stbConvertFromVersion2: instVars].
	^instVars!

stbConvertFrom: anSTBClassFormat 
	"Private - Convert from previous version resource. 
	Version Changes:
		1: Added 'events' instance variable to Model."

	^
	[:data | 
	| answer instVars |
	instVars := self stbConvert: data fromVersion: anSTBClassFormat version.
	answer := self basicNew.
	1 to: instVars size do: [:i | answer instVarAt: i put: (instVars at: i)].
	answer]!

stbConvertFromVersion0: anArray 
	"Private - Perform an STB conversion from a version 0 <Model> to version 1.
	i.e. insert 'events' instance variable (which should always be nil in an STB stream)."

	^(Array new: anArray size + 1)
		replaceFrom: 2
			to: anArray size + 1
			with: anArray
			startingAt: 1;
		yourself!

stbConvertFromVersion1: anArray 
	"Private - Perform an STB conversion from a version 1 <Model> to version 2.
	No change at this level."

	^anArray!

stbConvertFromVersion2: anArray 
	"Private - Perform an STB conversion from a version 2 <Model> to version 3.
	No change at this level."

	^anArray!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^1! !

!Model methodsFor!

getEvents
	"Private - Answer the EventsCollection belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^events!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original. Answer the receiver."

	events := nil.
	^self!

setEvents: anEventsCollectionOrNil
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	events := anEventsCollectionOrNil!

stbSaveOn: anSTBOutFiler
	"Output the receiver to anSTBOutFiler. We must ensure that the local events collection
	is NOT saved to the filer"

	anSTBOutFiler override: events with: nil.
	super stbSaveOn: anSTBOutFiler.! !

Mutex comment:
'Mutex is the class of process synchronisation objects which provide mutually exclusive access to critical sections, potentially permitting a single process to enter such critical sections multiple times recursively (in some other Smalltalk systems this class is in fact called, RecursionLock).

If any process is in a Mutex, then no other process is permitted to enter that Mutex, but that process may re-enter.

Mutex is particulary useful where the use of a simple mutual exclusion <Semaphore> alone might cause deadlock, e.g. in implementing process safe collections.

Access to the Mutex is through the #critical: method only. Versions of Dolphin prior to 3.0 also supported #wait and #signal messages, but these were not entirely safe.

Instance Variables:

	owner		<Process> which currently owns the instance, or nil if no owner
	semaphore	<Semaphore> used for mutual exclusion	'!
!Mutex class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new initialized instance of the receiver."

	^super new initialize! !

!Mutex methodsFor!

critical: aNiladicBlock
	"Wait until the receiver is NOT owned by another Process than that currently
	active, and then evaluate the argument, aNiladicBlock, to the 
	exclusion of other Processes using this mutex, answering the result.
	Implementation Note: We could use Semaphore>>critical: to implement the
	#ifFalse: branch, but we code inline to avoid the overhead of a further #ensure:
	block to reset the owner instance variable in addition to that in Semaphore>>critical:
	which guarantees that the Semaphore is never left unsignalled on exit."

	| active stateHolder |
	(active := Processor activeProcess) == owner
		ifTrue: [^aNiladicBlock value].

	"We need to acquire the mutex before we can proceed"
	stateHolder := Array new: 1.
	^[	"The semaphore primitive will atomically wait AND set the wait result if it completes"
		semaphore wait: INFINITE ret: stateHolder.
		owner := active.
		"Set the state to indicate that the owner has been set and can be tested for premature release"
		stateHolder basicAt: 1 put: active.
		aNiladicBlock value
	] ensure: [ | state |
		"There are a number of possibilities:
			1: The normal case. The mutex was acquired, and the block evaluated to termination.
			2: The mutex was acquired and the block evaluated, but it prematurely released the mutex with #signal.
			3: The mutex was acquired, but the process was terminated before it could proceed any further.
			4: The process was terminated before the mutex could be acquired.
		In case 4 there is no action required."
		(state := stateHolder basicAt: 1) == active
			ifTrue: [ "Cases 1 & 2"
				owner == active ifTrue: [ "Case 1: Normal completion"
					owner := nil. semaphore signal]]
			ifFalse: [ "Cases 3 & 4"
				state == WAIT_OBJECT_0 ifTrue: [ "Case 3: Acquired but not evaluated"
					owner := nil. semaphore signal]]]!

critical: aNiladicBlock ifLocked: exceptionHandler
	"If the receiver is NOT owned by another Process than that currently
	active, then grab it and then evaluate the argument, aNiladicBlock, to the 
	exclusion of other Processes using this mutex, answering the result, otherwise
	evaluate the <niladicValuable>, exceptionHandler.
	Implementation Note: See #critical: for comments on the implementation."

	| active stateHolder |
	(active := Processor activeProcess) == owner
		ifTrue: [^aNiladicBlock value].

	stateHolder := Array new: 1.
	^[
		semaphore wait: 0 ret: stateHolder.
		(stateHolder basicAt: 1) == WAIT_TIMEOUT 
			ifTrue: [exceptionHandler value]
			ifFalse: [
				owner := active.
				stateHolder basicAt: 1 put: active.
				aNiladicBlock value]
	] ensure: [ | state |
		(state := stateHolder basicAt: 1) == active
			ifTrue: [
				owner == active ifTrue: [
					owner := nil. semaphore signal]]
			ifFalse: [
				state == WAIT_OBJECT_0 ifTrue: [
					owner := nil. semaphore signal]]]!

initialize
	"Private - Initialise the receiver. The owner is initially nil, signifying no owner,
	the first process to send #critical: will be permitted to take ownership of
	the receiver."

	semaphore := Semaphore forMutualExclusion.
	owner := nil!

owner
	"Private - Answer the owner of the Mutex"

	^owner!

printOn: aStream
	"Append a textual representation of the receiver to the <puttableStream> argument
	as a developer might want to see it."

	aStream 
		basicPrint: self;
		nextPutAll: '(owner: ';
		print: owner;
		nextPutAll: ', waiting: ';
		print: semaphore;
		nextPut: $)!

signal
	"Private - Release the mutex if still owned by the receiver.
	Note that this message _must only_ be sent from inside a critical: block
	as otherwise thread safety may be compromised. Indeed this method
	is only intended for prematurely releasing a mutex, for example on
	the occurrence of an error."

	Processor activeProcess == owner ifTrue: [
		owner := nil. semaphore signal]! !

ObjectRegistry comment:
'ObjectRegistry is part of Dolphin''s external interfacing support, its purpose being to provide a unique <integer> identifier for a specific object, and, depending on the subclass, to maintain a reference to that object to prevent it from being garbage collected. This can be useful, for example, where one needs some unique identifier for an object to be passed to some external entity. 

Note: The Oop (address) of an object is not a suitable candidate for uniquely identifying an object, because it may change over time as the garbage collector moves objects in memory. The identity hash of an object, although time invariant, is not suitable either because it is of limited range (16-bits), and therefore not guaranteed to be unique.

ObjectRegistry itself is abstract: Subclasses implement both permanent registries (that maintain a strong reference to registered objects and thus keep them alive) and weak registries (that reference registered objects only weakly and thus do not prevent them from being garbage collected).

Instance Variables:
	registry		<sequencedCollection>. The collection of registered objects.'!
!ObjectRegistry class methodsFor!

defaultCapacity
	"Private - Answer the default capacity for an instance of the receiver."

	^4!

new
	"Answer a new permanent object registry with space for the default number of elements."

	^self new: self defaultCapacity!

new: anInteger
	"Answer a new object registry with initial capacity 
	for anInteger elements."

	^self basicNew initialize: anInteger! !

!ObjectRegistry methodsFor!

addAnsweringIndex: anObject
	"Register the argument, anObject, answering a unique SmallInteger id which can be used
	subsequently to retrieve that object."

	^self subclassResponsibility!

at: anInteger
	"Answer the object registered with the receiver with the specified id.
	If the id is invalid, raise an exception.
	Implementation Note: Although we could check to see if the object 
	with the specified id is a valid object, we cannot detect the situation
	where an id has simply been reused, so we don't bother to incur the overhead."

	^registry basicAt: anInteger!

at: anInteger ifAbsent: exceptionHandler
	"Answer the object registered with the receiver with the specified id.
	If the id is out of bounds, evaluate the niladic valuable argument, exceptionHandler."

	^registry at: anInteger ifAbsent: exceptionHandler!

indexOf: anObject ifAbsent: exceptionHandler
	"Answer the element of the receiver at the specified id. If there is
	no such registered object, answer the result of evaluating the
	the niladic value argument, exceptionHandler.
	Implementation Note: We do an identity search, because object registries
	are intended for registering specific object instances, and because
	it is very fast."

	^registry identityIndexOf: anObject ifAbsent: exceptionHandler!

initialize: anInteger
	"Private - Initialize the receiver with the specified initial capacity."

	^self subclassResponsibility!

remove: anObject ifAbsent: exceptionHandler
	"Remove the registration of the argument, anObject, freeing its unique integer id for
	subsequent re-use."

	^self removeAtIndex: (self indexOf: anObject ifAbsent: [ ^exceptionHandler value ])!

removeAtIndex: anInteger
	"Remove, and answer, the registered object with id anInteger in the receiver. 
	Raise an error if there is no element indexed by anInteger."

	^self subclassResponsibility! !

Package comment:
''!
!Package class methodsFor!

binaryGlobalExtension
	"Private - Answer the file extension for the files to which binary globals are stored."

	^ 'stb'!

clashSignal
	"Private - Answer the <Signal> which is raised should overlapping/clashing membership
	be detected when attempting to install a package."

	^ClashSignal!

defaultSortBlock
	^[:a :b | a name < b name]!

errorInvalidPACFile: pathString 
	"Private - Raise an <Error> to the effect that the file with the specified path is
	not a valid .PAC file."

	^self error: 'Invalid PAC file: ', pathString!

errorInvalidPAXFile: pathString 
	"Private - Raise an <Error> to the effect that the file with the specified path is
	not a valid .PAX file."

	^self error: 'Invalid PAX file: ', pathString!

fromFile: path
	"Private - Answer a new instance of the receiver created from the package file at the
	specified <readableString> path, pathname, or nil if the file does not contain a
	package"

	| answer pathname |

	pathname := File default: path extension: self sourcePackageExtension.
	answer := ((File splitExtensionFrom: pathname) sameAs: self sourcePackageExtension) 
		ifTrue: [self fromPAXFile: pathname]
		ifFalse: [self fromPACFile: pathname].
	answer packageFileName: pathname.
	^answer!

fromPACFile: pathname 
	"Private - Answer a new instance of the receiver created from the .PAC file at the
	specified <readableString> path, pathname, or raise an error if the file does not contain a
	package."

	| pacStream answer |
	pacStream := FileStream read: pathname text: false.
	answer := 
			[(STBInFiler peekForSignatureIn: pacStream) 
				ifTrue: 
					[pacStream reset.
					(STBInFiler on: pacStream) next]
				ifFalse: 
					[pacStream beText.
					self readFrom: pacStream]] 
					ensure: [pacStream close].
	answer isNil ifTrue: [self errorInvalidPACFile: pathname].
	^answer!

fromPAXFile: pathname 
	"Private - Answer a new instance of the receiver created from the .PAX file at the
	specified <readableString> path, pathname, or raise an error if the file does not contain a
	package in source text representation."

	| paxStream answer |
	paxStream := FileStream read: pathname.
	answer := [self readFrom: paxStream] ensure: [paxStream close].
	answer isNil ifTrue: [self errorInvalidPAXFile: pathname].
	^answer!

icon
	"Answers an Icon that can be used to represent this class."

	^##(self) defaultIcon!

initialize
	"Private - Initialize the receiver's class variables.
		Package initialize
	"

	_Uncommitted := (self basicNew)
				initialize;
				packagePathname: '<Unpackaged>';
				yourself.
	ClashSignal := Signal resumableDescription: 'Package contents clash'.
	UnsaveableSignal := Signal description: 'Package cannot be saved (check for cyclic dependencies or unpackaged prereqs)'.
	CheckTimestamps := true!

manager
	"Answer the object responsible for managing the collection of installed packages.
	N.B. This should be the only reference to PackageManager in the entire system,
	as the class may be removed from a future release."

	^PackageManager current!

name: nameString
	"Answer a new instance of the receiver with the <readableString> name, nameString."

	^self new
		packageFileName: nameString;
		yourself
!

nameForMethod: aMethod
	"Private - Answer an Association of the method class name String -> methods selector Symbol.
	See: Package>>methodFromName for the reverse transformation.
	Implementation Note: As of file version 1 we use a symbolic class name, if one
	is available, to save space. Metaclasses are not globals, so these _will_ have string names."

	^aMethod methodClass name -> aMethod selector!

new
	"Answer a new instance of the receiver."

	^super new initialize!

onPreStripImage
	"Private - The image is about to be stripped, clear lazily initialize class variables to assist
	the stripping process."

	ChangedIcon := SourcePackageIcon := nil!

packageExtension
	"Private - Answer the file extension for the file which an instance of the
	receiver is filed out to."

	^ 'pac'!

packageFileVersion
	"Answer the current file format version of the receiever."

	^5!

paxVersion
	"Private - Answer the current PAX format version number.
	0 - Original D5.1 format
	1 - D6.0 format with implicit literal (i.e. not embedded binary) resources"

	^1!

readFrom: pacStream
	"Private - Answer a new instance of the receiver created from the .PAX (source 
	text) format representation in the <readableStream>, pacStream."

	| chunk |
	chunk := (ChunkSourceFiler on: pacStream) nextChunk.
	^Compiler evaluate: chunk logged: false!

sourceGlobalExtension
	"Private - Answer the file extension for the files to which source globals are stored."

	^ 'st'!

sourcePackageExtension
	"Private - Answer the file extension for the file to which sources for an instance of the
	receiver is filed out to."

	^ 'pax'!

stbConvertFrom: anSTBClassFormat
	"Convert version 0 packages by mutating class names from Strings
	into Symbols. There is no layout change."

	Notification signal: 'Converting package from version ',
						anSTBClassFormat version printString, ' to: ',
						self stbVersion printString.

	^[:data |
		(anSTBClassFormat version to: self stbVersion - 1)
			inject: data into: [:inject :version |
				self perform: ('stbConvertFromVersion', version displayString, ':') asSymbol with: inject]]
		
		
		!

stbConvertFromVersion0: data
	"Private - Convert version 0 packages by mutating class names from Strings
	into Symbols. There is no layout change. Answer the mutated data.

	Version 0 Package		-->		Version 1 Package
	1	name						1	name
	2	packagePathname			2	packagePathname
	3	comment					3	comment
	4	classNames				4	classNames
	5	methodNames				5	methodNames
	6	globalNames				6	globalNames
	7	prerequisiteNames			7	prerequisiteNames
	8	preinstall				8	preinstall
	9	postinstall				9	postinstall
	10	singleFile				10	singleFile"

	| classNames globalNames |
	classNames := data instVarAt: 4.
	classNames become: (classNames collect: [:n | n asSymbol]).
	classNames becomeA: IdentitySet.
	globalNames := data instVarAt: 6.
	globalNames becomeA: IdentitySet.
	^data!

stbConvertFromVersion1: anArray 
	"Private - Convert version 1 packages  to version2. The preinstall and
	postinstall instance variables are replaced by a dictionary which holds
	those scripts and any more we define. Answer the mutated data.

	Version 1 Package		-->		Version 2 Package
	1	name						1	name
	2	packagePathname			2	packagePathname
	3	comment					3	comment
	4	classNames				4	classNames
	5	methodNames				5	methodNames
	6	globalNames				6	globalNames
	7	prerequisiteNames			7	prerequisiteNames
	8	preinstall				8	singleFile
	9	postinstall				9	scripts
	10	singleFile"

	| preinstall postinstall newData scripts |
	preinstall := anArray at: 8.
	postinstall := anArray at: 9.
	"need to temporarily convert data Array into a Package so we can
	use public methods to add preinstall/postinstall scripts"
	newData := Array new: 9.
	1 to: 7 do: [:index | newData at: index put: (anArray at: index)].
	newData at: 8 put: (anArray at: 10).
	scripts := IdentityDictionary new.
	(preinstall notNil and: [preinstall notEmpty]) ifTrue: [scripts at: #preinstall put: preinstall].
	(postinstall notNil and: [postinstall notEmpty]) 
		ifTrue: [scripts at: #postinstall put: postinstall].
	newData at: 9 put: scripts.
	^newData!

stbConvertFromVersion2: anArray 
	"Private - Convert version 2 packages to version3. The only change is the
	addition of a list of resources owned by a packkage which doesn't also
	own the class which the resource is from. This is similar to the methodNames
	support.

	Version 2 Package		-->		Version 3 Package
	1	name						1	name
	2	packagePathname			2	packagePathname
	3	comment					3	comment
	4	classNames				4	classNames
	5	methodNames				5	methodNames
	6	globalNames				6	globalNames
	7	prerequisiteNames			7	prerequisiteNames
	8	singleFile				8	singleFile
	9	scripts					9	scripts
								10 resourceNames"

	^anArray copyWith: Set new!

stbConvertFromVersion3: anArray 
	"Private - Convert version 3 packages to version 4. The main change is the
	addition of an imageStripperBytes instance variable to hold a filed imageStripper
	to be associated with the package. We hold the image stripper in this form to allow
	filing of the package into images that do not have ImageStripper installed. 
	Additionally we must convert the full stored pathname of the package to a
	name relative to the image base."

	"Note that this is currently the last converter in the chain and answers the
	coverted Package object rather than an Array. This will need to be changed
	to answer an Array if an additional converter is added."

	"Version 3 Package		-->		Version 4 Package
	1	name						1	name
	2	packagePathname			2	packagePathname
	3	comment					3	comment
	4	classNames				4	classNames
	5	methodNames				5	methodNames
	6	globalNames				6	globalNames
	7	prerequisiteNames			7	prerequisiteNames
	8	singleFile					8	singleFile
	9	scripts					9	scripts
	10 	resourceNames				10	resourceNames
								11 imageStripperBytes"

	"Copy over adding a nil imageStripperBytes slot"
	| newData packagePathName |
	newData := anArray copyWith: nil.

	"Convert the imagePathName to a relative path"
	packagePathName := File relativePathOf: (anArray at: 2) to: SessionManager current imageBase.
	newData at: 2 put: packagePathName.
	^newData!

stbConvertFromVersion4: anArray 
	"Private - Convert version 4 packages (Dolphin 3.0) to version 5 (Dolphin 3.05).
	Adds an aboutBlock (12) and versionString (13) instance variables."

	^(Array new: 13)
		replaceFrom: 1
			to: 11
			with: anArray
			startingAt: 1;
		yourself!

stbConvertFromVersion5: anArray 
	"Private - Convert version 5 (Dolphin 3.05) packages to version 6 (new PAX format).
	singleFile instance variable is no longer used."

	"Version 5 Package		-->		Version 4 Package
	1	name						1	name
	2	packagePathname			2	packagePathname
	3	comment					3	comment
	4	classNames				4	classNames
	5	methodNames				5	methodNames
	6	globalNames				6	globalNames
	7	prerequisiteNames			7	prerequisiteNames
	8	singleFile					8	events
	9	scripts					9	scripts
	10 	resourceNames				10	doNotReuse
	11 	imageStripperBytes			11	imageStripperBytes
	12 	aboutBlock				12	aboutBlock
	13 	packageVersion			13	packageVersion
								14	manualPrerequisites
								15	timestamp
								16	untracedGlobals"

	| newPackage |
	anArray at: 8 put: nil.	"singleFile"
	anArray at: 10 put: nil.
	"Last converter in the chain, so return a package instance"
	newPackage := self new.
	anArray keysAndValuesDo: [:eachKey :eachValue | newPackage instVarAt: eachKey put: eachValue].
	^newPackage!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^6!

uncommitted
	"Answer the special package used to 'hold' uncommitted classes and other globals."

	^_Uncommitted!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	ChangedIcon := _Uncommitted := nil!

unsaveableSignal
	"Private - Answer the <Signal> which is raised should an attempt be made to save
	a package with uncommitted or cyclic pre-requisites."

	^UnsaveableSignal! !

!Package methodsFor!

about
	"Displays an about screen for the receiver using the aboutBlock if any has been set."

	self aboutBlock notNil ifTrue: [
		self aboutBlock value: self ]!

aboutBlock
	"Answer the <monadicValuable> that will display an About screen
	or nil if there is none. The receiver is passed as the parameter."

	^aboutBlock
!

aboutBlock: aMonadicValuableOrNil
	"Set the <monadicValuable> that will display an About screen.  The receiver
	will be passed as the parameter to the valuable. 
	When a package is created it does not have an about operation set. 
	To set a default splash screen see #defaultAbout."

	aboutBlock := aMonadicValuableOrNil.
	self isChanged: true.

!

aboutBlockBytes: aByteArray
	"Private - Set the receiver's about block by rehydrating that in serialized
	form in the <ByteArray> argument."

	aboutBlock := Object fromBinaryStoreBytes: aByteArray

!

addClass: aClass
	"Add aClass to the list of classes owned by the receiver. A class can only be owned by
	a single package. Answer aClass."

	self manager addClass: aClass to: self.
	^aClass!

addGlobalNamed: globalName
	"Add the global object to those owned by the receiver. Answer anObject."

	self manager addGlobalNamed: globalName to: self.
	^globalName!

addLooseMethod: method 
	"Private - Add the <CompiledMethod>, method, to the set of loose methods
	owned by the receiver."

	self assert: [(self includesClass: method methodClass) not].
	self methodNames add: (self nameForMethod: method)!

addMethod: method
	"Add the <CompiledMethod>, method, to the list of methods owned by the receiver and
	answer that method. As this will involve moving the method from another package, this
	is a composite operation and we need to involve the package manager to avoid problems
	with issuing events while the package system is in an interim state."

	self manager addMethod: method to: self.
	^method!

addPackagedMethod: method 
	"Private - The <CompiledMethod> argument, which is owned indirectly by this package because
	it is a method of a class which is owned, is to be re-added to this package."

	self assert: [self includesClass: method methodClass].
	method methodClass methodChanged: method!

addResourceIdentifier: rid
	"Add the <ResourceIdentifier>, rid, to the list of resources owned by the
	receiver. Answer the argument."

	self manager addResourceIdentifier: rid to: self.
	^rid!

allDependentPackages
	"Answer a <collection> of the packages which are directly dependant on the receiver."

	^self manager allDependentPackagesOf: self visited: Set new!

allFileOutNames
	"Private - Answers an OrderedCollection of the source filenames for the receiver and all of its 
	contents when in PAX source mode. Note that the PAX filename is alway last in the collection."

	| answer |
	answer := OrderedCollection new.
	self allSourceObjectsDo: [:each | answer add: each fileOutName].
	^answer!

allMethods
	"Answer an <IdentitySet> of all the <CompiledMethod>s directly owned by
	the receiver or by owning the class in which it is situated."

	| answer |
	answer := IdentitySet new: (classNames size * 20).	"On average, about 10 methods per behaviour"
	self allMethodsDo: [:m | answer add: m].
	^answer!

allMethodsDo: operation
	"Private - Evaluate the <monadicValuable>, operation, for Answer an <IdentitySet> of all the <CompiledMethod>s 
	directly owned by the receiver or by owning the class in which it is situated."

	| loose |
	loose := self manager looseMethods.
	self behaviorsDo: 
			[:eachBehavior | 
			eachBehavior methodDictionary 
				do: [:eachMethod | (loose includesKey: eachMethod name) ifFalse: [operation value: eachMethod]]].

	"Finally evaluate the operation for all the package's own loose methods"
	self methods do: operation!

allPrerequisites
	"Private - Answer a collection of all the Packages objects which must be loaded in before the
	receiver may be loaded in."

	| answer immediatePrereqs |
	immediatePrereqs := self prerequisites asIdentitySet.
	answer := IdentitySet new.
	immediatePrereqs do: [:each | 
		(answer includes: each) ifFalse: [answer add: each; addAll: each allPrerequisites]].
	^answer!

allResourceIdentifiers
	"Answer a Set of all the ResourceIdentifiers directly owned by
	the receiver or by owning the class in which it is situated."

	| resources resourceMethods |
	resources := Set new.
	self classesDo: [:each | resources addAll: each resourceIdentifiers].
	resourceMethods := self methods 
				select: [:each | each selector beginsWith: ResourceIdentifier selectorPrefix].
	resourceMethods do: [:each | resources add: (ResourceIdentifier forMethod: each)].
	^resources!

allResourceNames
	"Answer a <Collection> of all the resource names directly owned by the receiver or by its owned classes."

	^self propertyAt: #allResourceNames ifAbsent: [^OrderedCollection new]!

allResourceNames: resources
	"Private - Record the <Collection> of <Associations>s, resources, as the names of all resources
	in this package. This information is recorded only temporarily during package loading, and later
	it is generated dynamically."

	self propertyAt: #allResourceNames put: resources!

allSourceObjects
	"Answer a <collection> containing the members of the receiver that can be filed out as 
	separate source files. These objects must respond to the <sourceObject> protocol. If the
	receiver is not the system package, then it is included as the last element of the collection.
	Currently we can externalize the receiver's PAX and it's classes, resources and 
	constant pools."

	| answer |
	answer := OrderedCollection new.
	self allSourceObjectsDo: [:each | answer add: each].
	^answer!

allSourceObjectsDo: operation 
	self classesDo: operation.
	self sourceGlobalVariables do: [:each | operation value: each value].
	"Note that the package itself is always enumerated last - this is important"
	(self isSystemPackage not or: [SessionManager current isOAD]) ifTrue: [operation value: self]!

basicAddClass: aClass 
	"Private - Add aClass to the list of classes owned by the receiver. A class can only be owned by
	a single package. Answer aClass. Note that it is assumed that the class is _not_ currently
	packaged. To correctly add a class regardless of packaging use PackageManager>>addClass:to:"

	"ignore any methods of aClass which we own as they are included by our new ownership of aClass"
	| className |
	(self methods 
		select: [:aMethod | aMethod methodClass == aClass or: [aMethod methodClass == aClass class]]) 
			do: [:method | self removeLooseMethod: method].
	className := self nameForClass: aClass.
	classNames add: className.

	"Although the class hasn't changed in itself, it will need to be filed out to its new location, if using .PAX format"
	aClass isChanged: true.
	^aClass!

basicAddGlobalNamed: globalName
	"Private - Add the global object to those owned by the receiver. Answer anObject.
	 Note that it is assumed that the global is _not_ currently packaged. To 
	correctly add a class regardless of packaging use the PackageManager."

	| global names |
	names := self globalNames.
	names add: globalName.

	"The global's value has not changed, but it may now need filing out to a new location"
	global := self globalFromName: globalName.
	(self isSourceGlobal: global) ifTrue: [
		global isChanged: true].

	^globalName!

basicComment: aString
	"Private - Set the comment of the receiver."

	comment := aString!

basicPackageVersion: aString
	"Private - Sets the package version identification to aStringOrNil."

	packageVersion := (aString isNil or: [aString isEmpty]) ifFalse: [aString]!

basicRemoveClass: aClass
	"Private - Remove aClass from the list of Classes owned by the receiver.
	Answer aClass."

	classNames remove: (self nameForClass: aClass).
	^aClass!

basicRemoveGlobalNamed: globalName 
	"Private - Remove globalName from the list of globals owned by the receiver.
	Answer globalName."

	| names |
	names := self globalNames.
	names remove: globalName ifAbsent: [].
	names isEmpty ifTrue: [globalNames := nil].
	^globalName!

basicScriptAt: scriptSymbol put: aString 
	"Private - Set the script String associated with scriptSymbol."

	scripts := self scripts.
	aString isEmpty 
		ifTrue: 
			[scripts removeKey: scriptSymbol ifAbsent: [].
			scripts isEmpty ifTrue: [scripts := nil]]
		ifFalse: [scripts at: scriptSymbol put: aString]!

behaviorFromName: aString ifAbsent: exceptionHandler 
	| index |
	index := aString identityIndexOf: $ .
	^index == 0 
		ifTrue: [self classFromName: aString ifAbsent: exceptionHandler]
		ifFalse: 
			[(self classFromName: (aString leftString: index - 1) ifAbsent: []) 
				ifNil: [exceptionHandler value]
				ifNotNil: [:class | class class]]!

behaviors
	"Answer an <IdentitySet> of the <Behavior>s owned by the receiver."

	| answer |
	answer := IdentitySet new: (classNames size + 1) * 2. "Avoid need to grow set by presizing"
	self behaviorsDo: [:b | answer add: b].
	^answer!

behaviorsDo: operation
	"Evaluate the monadicValuable, operation, for each and every <Behavior> owned
	by the receiver."

	self classesDo: [:aClass | operation value: aClass; value: aClass class].
!

beNotUsingPAX
	"Place the receiver into a mode where it is not using PAX source files.
	This simply involves deleting any PAX source files that currently exist. Without the
	presence of a same named PAX file, the receiver assumes it is operating in
	non-PAX mode for all future save operations."

	| msg names |
	self isUsingPAX ifFalse: [^self].
	names := self allFileOutNames.
	msg := 'Placing this package into PAC mode will delete <2d> PAX source files in the<n>directory <3s>.<n><n>Are you sure that you wish to proceed?' 
				expandMacrosWith: self name
				with: names size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAC mode...' expandMacrosWith: self name)) 
		ifTrue: [names do: [:each | File delete: each]]!

beUsingPAX
	"Place the receiver into a mode where it is using PAX source files.
	This simply involves creating the PAX source files for the first time. With the
	presence of a same named PAX file, the receiver assumes it is operating in
	PAX mode for all future save operations."

	| msg |
	self isUsingPAX ifTrue: [^self].
	msg := 'Placing this package into PAX source mode will create <1d> source files<n>in the directory <2s>.<n><n>Are you sure that you wish to proceed?' 
				expandMacrosWith: self allSourceObjects size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAX mode...' expandMacrosWith: self name)) 
		ifTrue: [self fileOutAll]!

binaryGlobalNames
	"Private - Answer a <Collection> of <Symbol>s, being the names of all binary global variables
	in this package. This information is cached temporarily during package loading, and
	subsequently (after the package has been loaded) calculated."

	^self propertyAt: #binaryGlobalNames 
		ifAbsent: [self binaryGlobalVariables collect: [:var | var key]]!

binaryGlobalNames: globs
	"Private - Record the <Collection> of <Symbol>s, globs, as the names of all binary global variables
	in this package. This information is recorded only temporarily during package loading."

	self propertyAt: #binaryGlobalNames put: globs!

binaryGlobalVariables
	"Private - Answer the receiver's binary globals that can't be filed out as separate source 
	objects. Note that this _includes_ any aliases."

	^self globalVariables reject: [:e | self isSourceGlobal: e value]!

buildPrerequisiteNames
	"Private - Calculate the names of the receiver's prerequisite packages."

	| prereqs |
	prereqs := Set new.
	self calculatePrerequisites do:[:each | prereqs add: each name].
	self manualPrerequisites 
		do: [:each | (self manager packageNamed: each ifNone: []) notNil ifTrue: [prereqs add: each]].
	^prereqs!

calculatePrerequisites
	"Private - Answer an <IdentitySet? of the prerequisite <Package>s which have to be
	present before the receiver's objects may be successfully used. These packages may
	well need other packages to be loaded before they can operate."

	^self tracePrerequisites keys!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	all the file out names associated with the PAX file are writeable."

	^self fileOutNames allSatisfy: [:each | File isWriteable: each]!

canShowAbout
	"Answer true if we can show an about box for the receiver, i.e. we have an aboutBlock"

	^self aboutBlock notNil!

changedFrom: aMonadicValuable 
	"Set the changed flag for the receiver to aBoolean"

	self isChanged ifTrue: [^self].
	self changeIndexValue: aMonadicValuable.
	self trigger: #changed!

changeIndex
	^self propertyAt: #changeIndex ifAbsent: []!

changeIndexValue: aBlock 
	self propertyManager 
		propertyOf: self
		at: #changeIndex
		ifAbsentPut: aBlock!

checkTimestamps
	"Compare the timestamp cached when the package was installed against the timestamp of the
	package file. If the package file has been modified since the package was loaded, then warn
	the user to avoid inadvertent overwrites of later package versions causing loss of changes."

	(CheckTimestamps and: [self isRenegade]) ifFalse: [^self].
	Warning 
		signal: ('The package <1s> has been modified outside this image since it was loaded or last saved.

	Package timestamp:	<2s>
	File modification time:	<3s>

If you proceed and save it from this image then you may lose changes that have been made in another image. It is recommended that before proceeding you first take a backup copy of the current version on disk, or that you abort this operation.' 
				expandMacrosWith: self name
				with: self timestamp displayString
				with: (FILETIME fromInteger: self fileModificationTime) displayString)

!

classDefinitionsFileName
	"Private - Answer a filename to use for filing out the class definitions of the receiver.
	Note this is only relevant if the receiver is a system package."

	^File composePath: self path stem: self name, 'Classes' extension: 'st'.!

classes
	"Answer a Set of the Classes owned by the receiver."

	^classNames collect: [:className | self classFromName: className]!

classesDo: operation 
	"Evaluate the <monadicValuable>, operation, for each of the classes 
	owned by the receiver. Note that this does not include the classes of
	the receiver's loose methods."

	^classNames do: [:each | operation value: (self classFromName: each)]!

classesInHierarchyOrder
	"Private - Answer an <sequencedReadableCollection> of the
	receiver's ownded classes in the order that they would be
	visited by a depth-first traversal of the class hierarchy."

	^self hierarchyOrderOfClasses: self classes!

classFromName: className
	"Private - Answer the Class object which className encodes.

	See Package>>nameForClass: for the reverse transformation."

	^self environment at: className!

classFromName: className ifAbsent: exceptionHandler
	"Private - Answer the Class object which className encodes.

	See Package>>nameForClass: for the reverse transformation."

	^self environment at: className ifAbsent: exceptionHandler!

classNames
	"Answer an <Set> of <Symbol>s naming all the classes owned by the receiver."

	^classNames!

comment
	"Answer the comment String of the receiver"

	^comment 
		ifNil: ['']
		ifNotNil: 
			[comment isInteger 
				ifTrue: [String readFrom: (self sourceManager getSourceFromDescriptor: comment) readStream]
				ifFalse: [comment]]!

comment: aString 
	"Set the comment of the receiver, and flag as changed."

	self basicComment: aString.
	self storeComment.
	self isChanged: true!

createPackagePath
	"Private - Create the directory where the receiver resides on disk"

	File createDirectoryPath: (File splitPathFrom: self fileOutName)
!

declareClasses
	"Private - Predefine global variables for each of the classes in the package prior to those classes
	being loaded. Only required for PAX (not PAC) loading"

	self classNames do: 
			[:each | 
			Object 
				subclass: each asSymbol
				instanceVariableNames: ''
				classVariableNames: ''
				poolDictionaries: '']!

declareGlobals
	"Private - Define global variables for each of the globals in the package prior to those globals
	being loaded. Later (after the classes in the package have been defined - in case the globals are 
	instances of any of those classes) these will be loaded from their individual STB files."

	self globalNames do: [:each | self environment at: each put: nil]!

dependentPackages
	"Answer a <collection> of the packages which are directly dependant on the receiver."

	^self manager dependentPackagesOf: self!

depthOfClass: aClass 
	| depth class |
	depth := 0.
	class := aClass.
	[class superclass isNil] whileFalse: [
		class := class superclass.
		depth := depth + 1].
	^depth!

displayOn: aStream
	"Append a representation of the receiver to aStream which is suitable for display to the end user."

	aStream nextPutAll: self name!

dotPacPath
	^File path: self packageFileName extension: self class packageExtension!

endClassDefinitionsMarker
	"Private - Answer a String marker used to indicate the end of the
	class definitions section in a legacy (pre 4.0) package file."

	^'end-class-definition'!

environment
	"Private - Answer the global name associated with the receiver."

	^Smalltalk!

errorFileCorrupt
	"Private - Filing in the receivers owned objects has failed because the
	file is corrupt."

	self error: 'FileIn of ', self name, ' package has failed, file is corrupt'!

fileInClassDefinitions: aFileStream 
	"Private - Load all package classes from the filestream up to the end marker.
	Note that this is only used for loading binary legacy (pre 4.0) packages."

	| filer |
	aFileStream beText.
	filer := ChunkSourceFiler on: aFileStream.
	
	[filer atEnd ifTrue: [^self errorFileCorrupt].
	(Compiler evaluate: filer nextChunk logged: true) = 'end-class-definition'] 
			whileFalse.
	aFileStream skipSeparators.
	aFileStream next ~= $X ifTrue: [^self errorFileCorrupt].
	aFileStream beBinary!

fileInClasses
	"Private - Load all packaged classes from external files"

	self classesInHierarchyOrder do: [:each | self sourceManager fileIn: each fileOutName]!

fileInScript: aSymbol 
	"Private - 'File in' the named script."

	| filer |
	filer := self sourceManager chunkFilerOn: (self scriptAt: aSymbol) readStream.
	filer evaluationContext: self.
	[filer fileIn] on: Compiler errorClass
		do: 
			[:x | 
			| msg |
			msg := 'Error: Script for <1p> at line <2d>: <3d>' 
						expandMacrosWith: aSymbol
						with: x line
						with: (x _descriptionArguments at: 5).
			Notification signal: msg.
			x
				beep;
				resume]!

fileLocator
	^PackageRelativeFileLocator package: self!

fileModificationTime
	"Private - Answer the modification time of the receiver's package file on disk as the
	<integer> number of 100-nanosecond intervals since 12:00 A.M. January 1, 1601 UTC (i.e. a
	Win32 FILETIME), or 0 if it does not currently exist."

	| fileName |
	fileName := self isSystemPackage 
				ifTrue: [self classDefinitionsFileName]
				ifFalse: [self isUsingPAX ifTrue: [self fileOutName] ifFalse: [self packageFileName]].
	^(File lastWriteTime: fileName) ifNil: [0] ifNotNil: [:filetime | filetime asInteger]!

fileNameForBinaryGlobal: globalName
	"Private - Answer a filename for storing the binary globalName."

	^File composePath: self path stem: globalName extension: self class binaryGlobalExtension
!

fileNameForSourceGlobal: globalName
	"Private - Answer a filename for storing the source globalObject."

	^File composePath: self path stem: globalName extension: self class sourceGlobalExtension
!

fileOut
	"Private - File out a definition of the receiver to source files. Normally this
	involves saving a PAX file except in the case where the receiver is a system package
	when separate class and resource definitions files are saved instead."

	self isSystemPackage 
		ifFalse: 
			[self
				savePAC;
				savePAX;
				versionIfRequired]
		ifTrue: [self fileOutBootDefinitions].
	self updateTimestamp.
	self isChanged: false!

fileOutAll
	"Fileout the receiver to a PAX file and all out it's associated source files.
	The .PAC file is also saved when the .PAX is created in order to ensure that
	the two remain in sync."

	self allSourceObjectsDo: [:each | each fileOut]!

fileOutAllChanged
	"Fileout the changed source objects in the receiver"

	self allSourceObjectsDo: [:each | each isChanged ifTrue: [each fileOut]]!

fileOutAllOn: aSourceFiler 
	self fileOutOn: aSourceFiler.
	self
		fileOutSourceGlobalsOn: aSourceFiler;
		fileOutClassesOn: aSourceFiler;
		fileOutBinaryGlobalsOn: aSourceFiler
!

fileOutBinaryGlobals
	"Private - File out binary globals to individual .STB files.
	This is used in the multi-file .PAX format to avoid binary merge conflicts in the
	main PAX."

	(self binaryGlobalVariables - self globalAliasVariables) do: [:var | | globalStream |
		globalStream := FileStream write: (self fileNameForBinaryGlobal: var key) text: false.
		var value binaryStoreOn: globalStream.
		globalStream close].

!

fileOutBinaryGlobalsOn: aSourceFiler 
	"Private - File out the binary representation of the receiver's non-<sourceObject> 
	globals onto the <SourceFiler> argument. Binary globals are saved as the literal 
	representation of their #binaryStoreBytes.  This is used in the single-file .PAC format."

	aSourceFiler 
		emitComment: 'Binary Globals';
		cr.
	(self binaryGlobalVariables asSortedCollection: self variableSortBlock) 
		do: [:var | aSourceFiler fileOutBinaryGlobal: var; cr]!

fileOutBootDefinitions
	"Private - If this is a system package then only write out .st files capable of defining
	the classes independently of the PAX. These are required by the Dolphin boot process.
	Note that the base system package cannot contain any resources."

	| filer |
	filer := ChunkSourceFiler 
				on: (FileStream write: self classDefinitionsFileName text: true).
	[self fileOutClassDefinitionsOn: filer] ensure: [filer close]!

fileOutClassDefinitionsOn: aSourceFiler 
	"Private - Append the text definitions of the receivers owned classes to aFileStream.
	This should produce the minimal amount of information to create a new class when 
	loaded in (i.e. only the basic definitions are emitted)."

	aSourceFiler
		emitComment: 'Class Definitions';
		cr.
	self classesInHierarchyOrder 
		do: [:aClass | aSourceFiler fileOutBasicDefinitionOfClass: aClass].
	aSourceFiler cr!

fileOutClassesOn: aSourceFiler 
	"Private - Append definitions of all the classes owned by the
	receiver to the <SourceFiler>, aSourceFiler.
	Note that the classes are filed out in class hierarchy order to 
	avoid creating forward references and to create a consistently
	ordered source file that can be effectively diff'd."

	aSourceFiler
		emitComment: 'Classes';
		cr.
	self classesInHierarchyOrder do: 
			[:aClass | 
			aSourceFiler fileOutAttributesOfClass: aClass.
			self fileOutMethodsOfClass: aClass on: aSourceFiler.
			self fileOutMethodsOfClass: aClass class on: aSourceFiler]!

fileOutGlobalAliasesOn: aSourceFiler 
	"Private - File out the text representation of the receiver's global aliases onto the
	<puttableStream>, stream."

	aSourceFiler
		emitComment: 'Global Aliases';
		cr.
	(self globalAliasVariables asSortedCollection: self variableSortBlock) 
		do: [:var | aSourceFiler fileOutExpression: var key , ' := ' , var value name].
	aSourceFiler cr!

fileOutLooseMethodsOn: aSourceFiler 
	"Private - File out the loose methods owned by the receiver to the <SourceFiler> argument."

	aSourceFiler
		emitComment: 'Loose Methods';
		cr.
	aSourceFiler fileOutMethods: self methods!

fileOutMethodsOfClass: aClass on: aSourceFiler 
	"Private - Append any definitions of the classes methods which
	are not owned by another package to the <puttableStream>, target."

	| methods |
	methods := self methodsOfClass: aClass.
	methods size = aClass methodDictionary size 
		ifTrue: 
			["The common case is that all methods of the class also belong to the this package..."

			aSourceFiler fileOutAllMethodsOfBehavior: aClass]
		ifFalse: 
			["...but if some methods are not owned by this package we have more work to do"

			| selectors prereqs addBlock |
			selectors := methods collect: [:m | m selector].
			aSourceFiler fileOutMessages: selectors ofBehavior: aClass.

			"File out the intersection of the immediate protocols of the class and those of this
			and prerequisite packages' methods"

			"First add all selectors in the superclass chain which are in this package or one of its
			pre-requisites into the set of available selectors."
			prereqs := self prerequisites.
			addBlock := 
					[:e :p | 
					selectors addAll: ((p methodsOfClass: e) collect: [:m | m selector])].
			prereqs do: [:p | addBlock value: aClass value: p].
			aClass allSuperclassesDo: 
					[:e | 
					addBlock value: e value: self.
					prereqs do: [:p | addBlock value: e value: p]].
			#todo.	"File out partial protocols, although tools should prevent protocols being split across packages really"
			aSourceFiler fileOutProtocols: (aClass protocols 
						select: [:p | (p selectors difference: selectors) isEmpty])
				ofBehavior: aClass]!

fileOutName
	"Answer the pathname used to store the PAX file for the sources of the receiver"

	^File composePath: self path stem: self name extension: self class sourcePackageExtension!

fileOutNames
	"Private - Answers a set of the source filenames for the receiver when in the multi-file
	(.PAX) source mode. This contains pathnames used to store the PAX file and each of the
	binary globals, etc. It does not include the source files for the	<sourceObject>s held by the 
	receiver."
	
	^self isSystemPackage 
		ifTrue: [Set with: self classDefinitionsFileName]
		ifFalse: [
			Set new 
				add: self fileOutName;
				addAll: (self binaryGlobalNames collect: [:each | self fileNameForBinaryGlobal: each]);
				yourself]!

fileOutOn: aSourceFiler
	"Append the definition of the receiver in PAX format onto the
	<SourceFiler> argument. This does not file out the source files of the 
	receiver's contents."

	self savePAXChunkOn: aSourceFiler.
	self fileOutClassDefinitionsOn: aSourceFiler.
	self fileOutGlobalAliasesOn: aSourceFiler.
	self fileOutLooseMethodsOn: aSourceFiler.
	aSourceFiler
		emitComment: 'End of package definition';
		cr!

fileOutSourceGlobalsOn: aSourceFiler 
	"Private - File out the text representation of the receiver's globals onto the
	<puttableStream>, stream. This is used in the single-file .PAC format."

	aSourceFiler
		emitComment: 'Source Globals';
		cr.
	(self sourceGlobalVariables asSortedCollection: self variableSortBlock) do: 
			[:var | 
			var value fileOutOn: aSourceFiler.
			aSourceFiler cr]!

getEvents
	"Private - Answer the EventsCollection belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^events!

getPrerequisites
	"Private - Answer a collection of <Package>s that must be loaded before the
	receiver can be loaded. Note that this differs from #prerequisites in that it will
	trace the prerequisites of the system package (which is slow)."

	(prerequisiteNames isNil and: [self isSystemPackage]) 
		ifTrue: [prerequisiteNames := self buildPrerequisiteNames].
	^self prerequisites!

globalAliases
	"Private - Answer a <collection> of <Symbol>s, being the names of global 
	variables owned by the receiver that are just aliases to other globals."

	^self propertyAt: #globalAliases
		ifAbsent: [self globalAliasVariables collect: [:var | var key]]!

globalAliases: aliases
	"Private - Record the <Collection> of <Symbol>s, globs, as the names of all global variables
	owned by this package which are just aliases for other globals. This information is recorded only 
	temporarily during package loading and is subsequently calculated."

	self propertyAt: #globalAliases put: aliases!

globalAliasVariables
	"Private - Answer a <collection> of <Association>s, being the global variables owned
	by the receiver that are just aliases to classes."

	^self globalVariables select: [:var | self isGlobalAlias: var]!

globalFromName: globalName
	"Private - Answer the global Object which globalName encodes.

	See Package>>nameForGlobal: for the reverse transformation."

	^self environment at: globalName!

globalNameOfLiteral: anObject 
	"Private - Answer the global name of the argument, anObject, extracted from a CompiledMethods
	literal frame, or nil if it is not a global."

	^(anObject isKindOf: VariableBinding) 
		ifTrue: 
			[| key |
			key := anObject key.
			self environment associationAt: key ifPresent: [:v | v == anObject ifTrue: [key]]]
		ifFalse: 
			[(anObject isKindOf: Class) 
				ifTrue: 
					[| key |
					key := anObject name.
					(self environment includesKey: key) ifTrue: [key]]]!

globalNames
	"Answer an <Set> of <Symbol>s,  naming all global objects
	(including pools but excluding classes) owned by the receiver."

	^globalNames ifNil: [globalNames := IdentitySet new]!

globals
	"Private - Answer a set of the non-class globals in the receiver."

	^self globalVariables collect: [:a | a value]
!

globalVariables
	"Private - Answer a <collection> of <Association>s, being the receiver's global variables."

	^self globalNames collect: [:each | self environment associationAt: each ifAbsent: [each->nil]]!

hasCyclicPrerequisites
	"Private - Answer whether any of the receivers prerequisites or their
	prerequisites are cyclic. So two packages rely on each other to be
	loaded before they can be loaded. The package system does not currently
	handle this smoothly though it is possible to load in such a thing by
	repeatedly trying to load in all packages until it works..."

	^self hasCyclicPrerequisites: IdentitySet new!

hasCyclicPrerequisites: trail
	"Private - Walk the package pre-requisite net looking for a cyclic dependency.
	The <collection> trail includes all those packages already visited. If we find
	a duplicate package on the path then we know a cycle exists."

	| answer |
	trail add: self.
	answer := self prerequisites anySatisfy: [:prereq | 
				(trail includes: prereq) or: [prereq hasCyclicPrerequisites: trail]].
	trail remove: self.
	^answer!

hasImageStripper
	^imageStripperBytes notNil and: [self imageStripper notNil]!

hasUncommittedPrerequisites
	"Private - Answer whether any of the receivers prerequisites or their
	prerequisites are current uncomitted. If so the package should not be saved
	as it will not be reloadable into an image without the uncommitted objects.
	N.B. This method will go infinitely recursive if the package has cyclic
	pre-requisites as it does not maintain a visit list. It should therefore
	be called only after hasCyclicPrerequisites has returned false."

	^self prerequisites anySatisfy: [:prereq | 
		prereq == _Uncommitted or: [prereq hasUncommittedPrerequisites]]!

hierarchyOrderOfClasses: aCollection 
	"Private - Answer an OrderedCollection of all the Classes owned
	by the receiver intersected with the collection in classes. 
	The classes are ordered by their depth in the class hierarchy, with Object
	being first if it is owned by the receiver."

	^self environment allClasses intersection: aCollection!

imageStripper
	"Answer an image stripper for the receiver, or nil ImageStripper class is not present.
	Since we have to be able to load the receiver into images that do no necessarily have the 
	ImageStripper class installed, we hold the stripper as a binary filed out ByteArray in imageStripperBytes.
	We reconstitute this here."

	^self environment at: #ImageStripper
		ifPresent: [:stripperClass | self rehydrateImageStripper: stripperClass]!

imageStripper: anImageStripper 
	"Set the image stripper for the receiver to anImageStripper. 
	Since we have to be able to load the receiver into images that do no necessarily 
	have the ImageStripper class installed, we hold the stripper as a binary filed out ByteArray 
	in imageStripperBytes"

	| newBytes |
	newBytes := anImageStripper isNil ifFalse: [anImageStripper binaryStoreBytes].
	imageStripperBytes = newBytes ifTrue: [^self].
	self imageStripperBytes: newBytes.
	self isChanged: true!

imageStripperBytes
	^imageStripperBytes!

imageStripperBytes: aByteArray
	"Private - Set the image stripper bytes for the receiver to aByteArray."

	imageStripperBytes := aByteArray.

!

includesClass: aClass 
	"Answer whether the receiver owns aClass. aClass's metaclass is
	automatically owned as well."

	^(classNames includes: (self nameForClass: aClass instanceClass)) 
		and: [(self isImportedClass: aClass) not]!

includesGlobalNamed: globalName
	"Answer whether the receiver owns the global named globalName."

	^self globalNames includes: globalName!

includesMethod: aCompiledMethod 
	"Answer whether the receiver owns aMethod."

	^methodNames notNil and: 
			[(self isImportedClass: aCompiledMethod methodClass) not 
				and: [methodNames includes: (self nameForMethod: aCompiledMethod)]]!

includesResourceIdentifier: aResourceIdentifier 
	"Private - Answer whether the receiver directly owns aResourceIdentifier.
	Implementation Note: Avoid the lookup in the table of imported classes if
	possible, as that is a relatively expensive operation."

	^aResourceIdentifier owningPackage == self 
		and: [(self isImportedClass: aResourceIdentifier owningClass) not]!

initialize
	"Private - Initialize the state of the receiver."

	classNames := IdentitySet new.
	timestamp := 0!

initializeClasses
	"Private - Initialize all loaded classes."

	self classesInHierarchyOrder do: [:aClass | aClass initializeAfterLoad]!

initializeGlobals
	"Private - Initialize all globals (including classes) that require it."

	self initializeClasses.
	self globals 
		do: [:each | (each respondsTo: #initializeAfterLoad) ifTrue: [each initializeAfterLoad]].
	self globalAliasVariables 
		do: [:each | each value class isMeta ifTrue: [ClassLocator addAlias: each key forClass: each value]]!

initializeOldSourcePackage
	(self respondsTo: #loadLegacyResources) 
		ifTrue: [self perform: #loadLegacyResources]
		ifFalse: [self error: 'Unable to load package (Legacy package importer is not loaded)']	"Initialize old style (pre D6) binary resources"!

isBaseImagePackage
	"Answer true if the receiver is a basic component of Dolphin "

	#deprecated.

	^self isBasePackage!

isBasePackage
	"Answer true if the receiver is a basic component of Dolphin. This is usually an indication that
	it was present at the time the image was booted and may be used as a hint that
	you may not need to version the package into an external repository such as STS."

	^self class manager basePackages includes: self!

isChanged
	"Answer true if the receiver or any of it's contents have been changed since
	their changed flag was last reset."

	^self changeIndex notNil!

isChanged: aBoolean 
	"Set the changed flag for the receiver to aBoolean"

	self isChanged = aBoolean ifTrue: [^self].
	aBoolean 
		ifTrue: [self changeIndexValue: [Package sourceManager changesFileSize]]
		ifFalse: [self removePropertyAt: #changeIndex ifAbsent: []].
	self trigger: #changed!

isDefaultPackage
	"Answer whether the receiver is the default package to which all newly defined
	classes and methods are added."

	^self manager defaultPackage == self!

isGlobalAlias: anAssociation 
	| glob |
	glob := anAssociation value.
	^(self isSourceGlobal: glob) and: [anAssociation key ~= glob name]!

isImportedClass: aClass
	"Private - Answer true if aClass is an imported binary class"

	^ClassLocator importedClasses identityIncludes: aClass!

isInstalled
	"Answer whether the receiver is currently installed in the system."

	^self manager includesPackage: self!

isRenegade
	"Answer whether the receiver was loaded (or last saved) before its source representation in the file system.
	An example of where a package might be a renegade is if it has been modified and saved from another image."

	| lastWriteTime |
	lastWriteTime := self fileModificationTime.
	^lastWriteTime > timestamp!

isSourceGlobal: aGlobal
	"Private - Answer true if aGlobal can be filed out as an external source file"

	^aGlobal class conformsToProtocol: #sourceObject
!

isSystemPackage
	"Answer whether the receiver is the system package"

	^self manager systemPackage == self!

isUsingPAX
	"Answer true if the receiver is using PAX mode. If a PAX file of the same name as the
	receiver exists on disk then both PAC and PAX files are saved simultaneously."

	^self isSystemPackage or: [File exists: self fileOutName]!

isUsingPAX: aBoolean
	"Place the receiver into a mode where it is using PAX source format according to aBoolean."

	self assert: [self isSystemPackage not].
	aBoolean 
		ifTrue: [ self beUsingPAX ]
		ifFalse: [ self beNotUsingPAX ]!

load
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded in."

	((File splitExtensionFrom: self packageFileName) sameAs: self class sourcePackageExtension) 
		ifTrue: [self loadPAX]
		ifFalse: [self loadPAC].
	self removePAXProperties.
	self synchronizeNames.
	self upateFileNames!

loadBinaryGlobals
	"Private - Load each of the receiver's binary globals from their individual STB files."

	self binaryGlobalNames do: [:each | | globalStream |
		globalStream := FileStream read: (self fileNameForBinaryGlobal: each) text: false.
		self environment at: each put: (Object binaryReadFrom: globalStream).
		globalStream close]!

loadPAC
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded."

	| filename stream |
	filename := self packageFileName.
	Notification signal: ('Loading package <1p> from: <2s>' expandMacrosWith: self name with: filename).
	stream := FileStream read: filename text: false.
	timestamp := stream file lastWriteTime asInteger.
	
	[(STBInFiler peekForSignatureIn: stream) 
		ifTrue: 
			[stream reset.
			self loadLegacyPAC: stream]
		ifFalse: 
			[stream beText.
			self loadPAC: stream]] 
			ensure: [stream close]!

loadPAC: stream 
	"Private - Load a chunked source text .PAC from the <readableStream>, stream."

	| filer |
	filer := ChunkSourceFiler on: stream.

	"Skip the first chunk since it represents the receiver."
	filer nextChunk.
	self fileInScript: #preinstall.

	"Must declare the globals before filing in any code"
	self declareGlobals.

	"File in the definitions of the package's members (pools, classes, methods, globals, resources, etc)"
	filer fileIn.
	self paxVersion < 1 ifTrue: [self initializeOldSourcePackage].
	self initializeGlobals.
	self fileInScript: #postinstall!

loadPAX
	"Private - Load all the objects owned by the receiver. This assumes that all prerequisite
	packages are currently loaded in."

	| filename filer stream |
	filename := self packageFileName.
	Notification 
		signal: ('Loading source package <1p> from: <2s>' expandMacrosWith: self name with: filename).
	stream := FileStream read: filename.
	timestamp := stream file lastWriteTime asInteger.
	filer := ChunkSourceFiler on: stream.
	
	[filer nextChunk.	"Skip the first chunk since it represents the receiver."
	self fileInScript: #preinstall.

	"Define any globals that might be referenced from source code, but don't load them as yet as they
		 may be instances of one of the classes in the package."
	self declareGlobals.

	"Forward reference any classes just in case they are required by the globals that are just about to be loaded"
	self declareClasses.

	"Load source globals"
	self globalNames - (self propertyAt: #binaryGlobalNames ifAbsent: [#()]) 
		- (self propertyAt: #globalAliases ifAbsent: [#()]) 
			do: [:each | self sourceManager fileIn: (self fileNameForSourceGlobal: each)].

	"Load class definitions, aliases, and loose methods from the remainder of the PAX file"
	filer fileIn.
	self fileInClasses.
	self loadBinaryGlobals.
	self initializeGlobals.
	self paxVersion < 1 
		ifTrue: 
			["Initialize old style (pre D6) binary resources"
			self initializeOldSourcePackage].
	self fileInScript: #postinstall] 
			ensure: [filer close]!

manager
	"Answer the object responsible for managing this package."

	^self class manager!

manualPrerequisites
	"Answer the <collection> of manually specified pre-requisite package names for the receiver.
	Normally pre-requisites are calculated automatically, but in certain instances (such as method-only
	packages) the pre-requisite tracing mechanism doesn't find the dependency, so this collection
	is provided to permit the user to specify any additional pre-requisites. At present the collection
	must be maintained by inspecting the properties of the package."

	^manualPrerequisites isNil 
		ifTrue: [OrderedCollection new]
		ifFalse: [manualPrerequisites asOrderedCollection]!

manualPrerequisites: aCollectionOfStrings 
	"Set the <collection> of manually specified pre-requisite package names for the receiver."

	| newPrereqs |
	newPrereqs := aCollectionOfStrings notEmpty 
				ifTrue: [aCollectionOfStrings asSortedCollection asArray copyWithout: self name].
	newPrereqs = manualPrerequisites ifTrue: [^self].
	manualPrerequisites := newPrereqs.
	self isChanged: true.
	self resetPrerequisites!

membershipChanged
	^self membershipChangedAt: [Package sourceManager changesFileSize]!

membershipChangedAt: aNiladicValuable 
	"Private - The receiver's membership has changed, and its immediate pre-requisites may have 
	changed as a result."

	self memberUpdatedAt: aNiladicValuable.
	self trigger: #ownedChanged!

memberUpdatedAt: aBlockClosure 
	"Private - The receiver, or an object owned by the receiver has been updated.
	Mark the receiver as changed, and reset pre-requisites just in case there is any 
	effect on those, but do not trigger an #ownedChanged event."

	self resetPrerequisites.
	self changedFrom: aBlockClosure!

methodFromName: methodName ifAbsent: exceptionHandler 
	"Private - Answer the <CompiledMethod> object which the <Association> argument encodes.
	There is some messing around to handle class methods. If there is no such method, then
	answer the value of evaluating the <niladicValuable>, exceptionHandler.

	See Package>>nameForMethod: for the reverse transformation."

	^(self behaviorFromName: methodName key ifAbsent: []) 
		ifNil: [exceptionHandler value]
		ifNotNil: [:methodClass | methodClass compiledMethodAt: methodName value asSymbol ifAbsent: exceptionHandler]!

methodNames
	"Answer a <Set> of <Association>s, naming the methods owned by the
	receiver. Note that this only includes loose methods that extend classes in other 
	packages, not the name of methods defined in classes owned by this package."

	^methodNames ifNil: [methodNames := PluggableSet searchPolicy: AssociationSearchPolicy current]!

methods
	"Answer an <IdentitySet> of the <CompiledMethod>s owned by the receiver."

	| newIdentitySet names |
	names := self methodNames.
	newIdentitySet := IdentitySet new: names size.
	names do: [:methodName | newIdentitySet add: (self methodFromName: methodName ifAbsent: [])].
	^newIdentitySet!

methodsOfClass: aClass
	"Answer a Collection of the methods of aClass which the receiver either
	directly owns (as loose methods) or through owning aClass."

	^(self includesClass: aClass) 
		ifTrue: 
			["A neat way to express this would be:
				aClass methodDictionary asIdentitySet difference: self class manager looseMethods
			but unfortunately performance is critical here, and we can double the speed as follows:"

			| owned loose all |
			all := aClass methodDictionary.
			owned := IdentitySet new: all size.
			loose := self manager looseMethods.
			all do: [:each | (loose includesKey: each name) ifFalse: [owned add: each]].
			owned]
		ifFalse: 
			["Just pick out any loose methods we own in the class"

			self methods select: [:aMethod | aMethod methodClass == aClass]]!

name
	"Answer the name of the receiver. This must always be the same as the stem of the package's
	file name, and must be unique amongst all loaded packages in the system."

	^name!

nameForClass: aClass
	"Private - Answer a String name suitable for adding to the receivers classNames.
	See: Package>>classFromName for the reverse transformation.
	Implementation Note: As of package binary file version 1, we store the class names
	as Symbols to avoid wasting space."

	^aClass name!

nameForMethod: aMethod
	"Private - Answer an Association of the method class name String -> methods selector Symbol.
	See: Package>>methodFromName for the reverse transformation."

	^self class nameForMethod: aMethod!

nameForResourceIdentifier: aResourceIdentifier
	"Private - Answer an <Association> that uniquely identifies the <ResourceIdentifier> argument."

	^aResourceIdentifier owningClass name -> aResourceIdentifier name!

okToSaveOrDeploy
	"Private - Prior to saving or deploying the receiver, check that all is consistent and answer whether the
	receiver should be saved. Raise Errors that describe any problems."

	self isSystemPackage ifTrue: [^false].
	self hasCyclicPrerequisites 
		ifTrue: 
			[self class unsaveableSignal 
				signal: ('The package <1p> has cyclic prerequisites.' expandMacrosWith: self name).
			^false].

	"N.B. This must be done after the above, as it will go infinitely recursive if there are cycles."
	self hasUncommittedPrerequisites 
		ifTrue: 
			[self class unsaveableSignal 
				signal: ('The package <1p> has prerequisites which are not currently assigned to any other package, or it is dependent on other packages which in turn have uncommitted prerequisites.' 
						expandMacrosWith: self name).
			^false].
	self validate.
	^true!

okToUninstall
	"Private - Validate that the receiver can be uninstalled. 
	Raise Errors that describe any problems. Answer whether
	OK to proceed."

	self isSystemPackage 
		ifTrue: 
			[Error signal: 'The base system package cannot be uninstalled'.
			^false].
	self hasCyclicPrerequisites 
		ifTrue: 
			[Error signal: ('The package <1p> has cyclic prerequisites and cannot be uninstalled.' 
						expandMacrosWith: self name).
			^false].
	^true!

onClassRemoved: aClass 
	"Private - React to aClass being removed from the Dolphin system.
	Ensure that none of the receivers loaded packages refer to aClass
	or its methods now it has departed.

	N.B. We have to take care here when checking methods. As aClass is
	no longer tied into the system class tree we have to use the method
	names."

	| className classClassName ownedChanged |
	className := aClass name.
	classClassName := aClass class name.
	ownedChanged := false.

	"remove any directly owned methods from aClass"
	methodNames 
		ifNotNil: 
			[| removed |
			removed := methodNames 
						select: [:methodName | methodName key = className or: [methodName key = classClassName]].
			removed notEmpty 
				ifTrue: 
					[ownedChanged := true.
					self removeMethodNames: removed]].
	(self includesClass: aClass) 
		ifTrue: 
			[ownedChanged := true.
			self basicRemoveClass: aClass].
	^ownedChanged!

onClassRenamed: aClass from: oldName to: newName 
	"Private - React to the <Class>, aClass, being removed from the Dolphin system.
	Ensure that none of the receivers loaded packages refer to aClass
	or its methods now it has departed.

	N.B. We have to take care here when checking methods. As aClass is
	no longer tied into the system class tree we have to use the method
	names."

	"Search for and rename any resources keyed on the class"

	(classNames includes: oldName) 
		ifTrue: 
			[classNames
				remove: oldName;
				add: newName.
			"If class includes package, can't be any loose methods or resources, so early out"
			^true].
	^self renameLooseMethodsOf: oldName to: newName!

onGlobalRenamed: anAssociation from: oldName 
	"Private - React to oldName global being renamed. Note that this
	is sent only for non-Class globals."

	| names |
	names := self globalNames.
	(names includes: oldName) ifFalse: [^self].
	names
		remove: oldName;
		add: anAssociation key.
	"Note that the pre-requisites are unaffected, but we reset them anyway because this is rare"
	self memberUpdatedAt: [Package sourceManager changesFileSize].
	self trigger: #ownedChanged!

owningPackage
	"Answers the package that owns the receiver. This is obviously self in the case of packages"

	^self!

packageFileName
	"Answer the full path name (ie Path+Stem+Extension) of the file used
	to store the source code representation of the receiver. This is recomposed
	from the relative path held"

	^File fullPathOf: packagePathname relativeTo: SessionManager current imageBase!

packageFileName: pathname 
	"Private - Set the path name (ie Path+Stem+Extension) of the file used
	to store the binary representation of the receiver. This is always held as
	relative to the current image base. This name should only be changed
	through the PackageManager, and in fact it is not advisable to change
	it any way because other packages may be dependent upon it.."

	self packagePathname: (FileLocator imageRelative 
				relativePathTo: (File default: pathname
						extension: self class packageExtension))!

packageFolder
	^File splitPathFrom: self packagePathname!

packagePathname
	^packagePathname!

packagePathname: aString 
	"Private - Set the receiver's path and name."

	| oldname |
	packagePathname := aString.
	"The name can no longer be independent of the file name, and is in fact just cached from the file stem"
	oldname := name.
	name := File splitStemFrom: aString.
	(oldname isNil or: [oldname sameAs: name]) ifTrue: [^self].
	self isChanged: true.
	"If a package is renamed, then the dependent packages need to be resaved to update their pre-requisite information"
	self dependentPackages do: [:each | each isChanged: true]!

packageVersion
	"Answer the version identification of the receiver as a String"

	^packageVersion notNil ifTrue: [packageVersion] ifFalse: [''].
!

packageVersion: aString
	"Sets the package version identification to the <readableString>, aString,
	and flag as changed."

	self basicPackageVersion: aString.
	self isChanged: true.
!

path
	"Private - Answer the full path to the directory holding the receivers files."

	^File splitPathFrom: self packageFileName!

paxVersion
	"Private - Answer the PAX format version of the package being loaded (or the current
	format if a loaded package)."

	^self propertyAt: #paxVersion ifAbsent: [self class paxVersion]!

paxVersion: anInteger
	"Private - Temporarily record the PAX format version in which the package being loaded
	was saved. This may be used for loading old format source packages in future."

	self propertyAt: #paxVersion put: anInteger!

prerequisiteNames
	"Private - Answer the <readableString> names of the receiver's prerequisite packages, i.e.
	the packages which must be loaded before the receiver.

	There is a lazy evaluation here because anytime an object is added/removed/deleted
	from the current PackageManager then the prerequisites may change. Rather than
	updating after every change we set all Packages prerequisitePackages to nil and 
	recalculate them as they are requested."

	^prerequisiteNames ifNil: 
			["To save time make a special case of the system package"

			self isSystemPackage 
				ifTrue: [Set new]
				ifFalse: [prerequisiteNames := self buildPrerequisiteNames]]!

prerequisites
	"Answer a collection of <Package>s that must be loaded before the
	receiver can be loaded."

	| pacman |
	pacman := self manager.
	^self prerequisiteNames 
		collect: [:packageName | pacman packageNamed: packageName ifNone: [_Uncommitted]]!

printBinaryStoreBytesOf: anObject
	"Private - Prints the literal representation of the binary store bytes of anObject
	onto a String and answers this."

	| bytes stream |
	stream := String writeStream.
	bytes := anObject binaryStoreBytes.
	bytes printPrefixOn: stream.
	bytes do: [:each | stream display: each; display: ' '].
	bytes printSuffixOn: stream.
	^stream contents!

printOn: aStream
	"Append a representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: self name;
		nextPut: $)
!

privateUninstall
	"Private - This attempt to delete all the objects owned by the receiver
	from the system. This is a very defensive method, taking the view that any
	of the named objects it owns may not have a real object to match with that
	name. Still it tries to battle on and rid the system of all its owned objects.

	This does not remove the receiver from its package manager. Other than
	emergency situations it should be called from PackageManager>>uninstall:."

	self
		uninstallGlobals;
		uninstallClasses;
		uninstallMethods!

rebaseTo: basePathName 
	"Rebase this package relative to the give base image directory"

	self packageFileName: (File 
				relativePathOf: (File fullPathOf: self packagePathname relativeTo: basePathName)
				to: SessionManager current imagePath)!

remainingClasses
	"Answer a Set of the classes that are still present (i.e. ignore missing classes)"

	| classes |
	classes := Set new.
	classNames do: [:className |
		[
			classes add: (self classFromName: className)
		] on: Error do: [:ignoredException | ignoredException notify]].
	^classes
!

removeClass: aClass
	"Remove aClass from the list of Classes owned by the receiver.
	Answer aClass."

	self manager addClass: aClass to: nil.
	^aClass!

removeGlobalNamed: globalName
	"Remove globalName from the list of globals owned by the receiver.
	Answer globalName."

	self manager addGlobalNamed: globalName to: nil.
	^globalName!

removeLooseMethod: aCompiledMethod 
	"Private - Remove the <CompiledMethod> argument which is directly owned by the receiver
	(i.e. a loose method) from this package. Do not fire any events."

	self assert: [(self includesClass: aCompiledMethod methodClass) not].
	self removeMethodNames: (Array with: (self nameForMethod: aCompiledMethod))!

removeMethod: method
	"Remove the <CompiledMethod>, method, from the list of loose methods owned by 
	the receiver, and answer that method.
	Note that the method is _not_ being removed from the system, just this package."

	self manager addMethod: method to: nil.
	^method
!

removeMethodNames: aCollection 
	methodNames removeAll: aCollection.
	methodNames isEmpty ifTrue: [methodNames := nil]!

removePackagedMethod: method
	"Private - Remove the <CompiledMethod>, method, which is a method of one of the classes
	owned by the receiver (i.e. not a loose method) from this package."

	self assert: [self includesClass: method methodClass].
	method methodClass isChanged: true!

removePAXProperties
	"Private - Throw away any info cached to load the package, and make sure not marked as changed"

	#(#allResourceNames #binaryGlobalNames #globalAliases #paxVersion #changeIndex) 
		do: [:each | self removePropertyAt: each ifAbsent: []]!

renameLooseMethodsOf: oldClassNameString to: newClassNameString 
	| oldMetaName renamed |
	methodNames ifNil: [^false].
	oldMetaName := oldClassNameString , ' class'.
	renamed := methodNames select: [:each | each key = oldClassNameString or: [each key = oldMetaName]].
	^renamed notEmpty and: 
			[| newMetaName |
			newMetaName := newClassNameString , ' class'.
			renamed do: 
					[:each | 
					methodNames 
						add: (each key = oldClassNameString ifTrue: [newClassNameString] ifFalse: [newMetaName]) 
								-> each value].
			self removeMethodNames: renamed.
			true]!

resetChangeFlags
	self allSourceObjectsDo: [:each | each isChanged: false].
	self isChanged: false!

resetPrerequisites
	"Private - Mark that the prerequisite packages for the receiver
	have changed. The packages will be recalculated the next time the
	#prerequsiteNames accessor is sent. An event is triggered
	iff the pre-reqs are actually reset, in case any tool (such as a
	PackagePrerequisitesShell) is monitoring them."

	prerequisiteNames isNil ifTrue: [^self].
	prerequisiteNames := nil.
	self trigger: #prerequisitesReset!

resourceIdentifiers
	"Answer a collection of <ResourceIdentifier> objects owned by the receiver."

	^ResourceIdentifier allResourceIdentifiers select: [:each | each owningPackage == self]!

save
	"Save the receiver to a single PAC file. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the source files are also
	filed out, including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save' command."

	self isUsingPAX ifTrue: [self fileOutAll] ifFalse: [self saveSingleFilePackage].
	^true!

saveAs: aString 
	self manager renamePackage: self to: aString.
	self save!

saveChanges
	"Save the receiver, if changed. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the changed source files are
	also filed out. including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save Changes' command."

	self isChanged ifFalse: [^self].
	self isUsingPAX 
		ifTrue: 
			[self fileOutAllChanged.
			self isChanged: false]
		ifFalse: [self saveSingleFilePackage]!

savePAC
	"Private - File out a definition of the receiver and all the objects it owns to a single
	text .PAC file. Any binary objects (views, non-<sourceObject> globals) are saved as a
	printed representation of their STB'd binary store bytes."

	| filer |
	self okToSaveOrDeploy.
	self checkTimestamps.
	self createPackagePath.
	"This event can be hooked to backup the old package before it is overwritten, etc"
	self manager trigger: #aboutToSave: with: self.
	filer := self sourceManager sourceFilerOn: (FileStream write: self dotPacPath).
	[self fileOutAllOn: filer] ensure: [filer close]!

savePAX
	"Private - File out a definition of the receiver to a .PAX source file. This does not file
	out the source files of the receiver's contents."

	"Implementation Note: All fileouts use case sensitive collation in order to avoid problem of order
	switches for same named identifiers with different case, which can cause a line-based source
	management system to detect a change where there isn't one."

	| filer |
	self createPackagePath.
	filer := self sourceManager sourceFilerOn: (FileStream write: self fileOutName).
	[self fileOutOn: filer] ensure: [filer close].

	"We must also file out the binary globals at this stage, as they are not <sourceObject>s."
	self fileOutBinaryGlobals!

savePAXAboutBlockOn: stream 
	aboutBlock isNil ifTrue: [^self].
	stream nextPutAll: 'package aboutBlockBytes: '.
	aboutBlock binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXChunkOn: aSourceFiler 
	"Private - File out the receiver's package description stream in PAX source file format
	to the <puttableStream>, stream. This is in the form of a chunk which, when re-evaluated,
	creates an equivalent package description in a state which can be used for comparision
	or loading, etc. None of the code in the package, with the exception of the package scripts,
	is included. None of the code, including the package scripts, is evaluated."

	| stream |
	stream := String writeStream: 1024.
	self
		savePAXPackageOn: stream;
		savePAXPackageVersionOn: stream;
		savePAXAboutBlockOn: stream;
		savePAXStripperBytesOn: stream;
		savePAXScriptsOn: stream;
		savePAXNamesOn: stream;
		savePAXGlobalNamesOn: stream;
		savePAXPrerequisiteNamesOn: stream;
		savePAXManualPrerequisitesOn: stream;
		savePAXUntracedGlobalsOn: stream.

	"Finish off the stream by answering the package loaded"
	stream nextPutAll: 'package'.
	aSourceFiler fileOutExpression: stream contents!

savePAXGlobalNamesOn: target
	"Private - File out the PAX source file expressions to record the names of
	the non-source globals owned by the receiver."

	#(#binaryGlobalNames #globalAliases) do: 
			[:each | 
			target
				nextPutAll: 'package ';
				nextPutAll: each;
				nextPutAll: ': (Set new';
				cr.
			self savePAXNames: (self perform: each) on: target.
			target
				nextPutAll: ').';
				cr;
				cr]!

savePAXManualPrerequisitesOn: target 
	"Private - File out the names of any manually configured pre-requisite packages 
	of the receiver onto the <puttableStream>, target."

	| prereqs |
	prereqs := self manualPrerequisites.
	prereqs isEmpty ifTrue: [^self].
	target
		nextPutAll: 'package ';
		nextPutAll: #setManualPrerequisites:;
		nextPutAll: ' #('.
	manualPrerequisites do: 
			[:s | 
			target
				crtab;
				print: s].
	target
		nextPutAll: ').';
		cr;
		cr!

savePAXNames: names on: stream
	"Private - File out the PAX source file representation of the list of source object
	names, names, onto the <puttableStream>, stream, in ascending order of their
	printable representation."

	((names collect: [:each | each printString]) asSortedCollection: SortedCollection caseSensitiveSortBlock)
		do: [:eachName | stream tab; nextPutAll: 'add: '; nextPutAll: eachName; nextPut: $;; cr ].
	stream 
		tab; nextPutAll: 'yourself'!

savePAXNamesOn: target 
	"Private - File out the PAX source file representation of the class names, loose method 
	names, global names, resource names, onto the <puttableStream>, stream, in ascending 
	order of their printable representation."

	#(#classNames #methodNames #globalNames) do: 
			[:each | 
			| names |
			names := self perform: each.
			names notEmpty 
				ifTrue: 
					[target
						nextPutAll: 'package ';
						nextPutAll: each;
						cr.
					self savePAXNames: names on: target.
					target
						nextPut: $.;
						cr;
						cr]]!

savePAXPackageOn: stream
	"Private - Save the basic details of the receiver in the PAX source file 
	representation onto the <puttableStream>, target."

	"Create package and set some basic attributes"

	stream
		nextPutAll: '| package |';
		cr;
		nextPutAll: 'package := ';
		print: self class;
		space;
		nextPutAll: #name:;
		space;
		print: self name;
		nextPut: $.;
		cr;
		nextPutAll: 'package ';
		nextPutAll: #paxVersion:;
		space;
		print: self paxVersion;
		nextPut: $;;
		crtab;
		nextPutAll: #basicComment:;
		space;
		print: self comment;
		nextPut: $.;
		cr;
		cr.
!

savePAXPackageVersionOn: aStream 
	"Private - Save Package Version - this is the version of the package, not the file out format"

	packageVersion isNil ifTrue: [^self].
	aStream
		nextPutAll: 'package ';
		nextPutAll: #basicPackageVersion:;
		space;
		print: self packageVersion;
		nextPut: $.;
		cr;
		cr!

savePAXPrerequisiteNamesOn: target
	"Private - File out names of the pre-requisite packages of the receiver onto the onto 
	the <puttableStream>, target, in ascending order."

	| basePath |
	target
		nextPutAll: 'package ';
		nextPutAll: #setPrerequisites:;
		nextPutAll: ' (IdentitySet new';
		cr.
	basePath := self path.
	(self prerequisites asSortedCollection: [:a :b | (a name trueCompare: b name) < 0]) do: 
			[:each | 
			target
				tab;
				nextPutAll: 'add: ';
				print: (File removeExtension: (File relativePathOf: each packageFileName to: basePath));
				nextPut: $;;
				cr].
	target
		tab;
		nextPutAll: 'yourself).';
		cr;
		cr!

savePAXScriptsOn: target 
	"Private - File out the PAX source file representation of the receiver's scripts
	onto the <puttableStream>, target.
	Implementation Note: The scripts are installed using #basicScriptAt:put: to
	avoid the package being flagged as changed and the consequent transmission 
	of a change event."

	self scripts keys asSortedCollection do: 
			[:each | 
			target
				nextPutAll: 'package basicScriptAt: ';
				print: each;
				nextPutAll: ' put: ';
				print: (self scriptAt: each);
				nextPut: $.;
				cr].
	target cr!

savePAXStripperBytesOn: stream 
	"Private - File out the PAX source file representation of the receiver's 
	image stripper bytes (if any) onto the <puttableStream>, target."

	imageStripperBytes isNil ifTrue: [^self].
	stream nextPutAll: 'package imageStripperBytes: '.
	imageStripperBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXUntracedGlobalsOn: aWriteStream 
	| untraced |
	untraced := self untracedGlobals.
	untraced isEmpty ifTrue: [^self].
	aWriteStream
		nextPutAll: 'package ';
		display: #untracedGlobals:;
		nextPutAll: ' (Set new';
		cr.
	self savePAXNames: self untracedGlobals on: aWriteStream.
	aWriteStream
		nextPutAll: ').';
		cr;
		cr!

saveSingleFilePackage
	"Save the receiver and all owned objects to a single .PAC file.
	The complementary message to save a multi-file package is #fileOutAll."

	self savePAC.
	self updateTimestamp.
	self resetChangeFlags!

scriptAt: scriptName 
	"Answer the script <String> associated with the <Symbol>, scriptName.

	The currently used scripts are: #preinstall, #postinstall, #preuninstall and
	#postuninstall."

	^self scripts at: scriptName ifAbsent: ['']!

scriptAt: scriptSymbol put: aString
	"Set the script String associated with scriptSymbol."

	self basicScriptAt: scriptSymbol put: aString.
	self isChanged: true.!

scripts
	^scripts ifNil: [IdentityDictionary new]!

setEvents: anEventsCollectionOrNil
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	events := anEventsCollectionOrNil!

setManualPrerequisites: anArrayOfStrings
	"Private - Set the names of the extra manually specified pre-requisite packages for 
	the receiver.
	**Note that this is sent from the chunks which define a package in .PAC and .PAX files
	and should not be deleted**."

	manualPrerequisites := anArrayOfStrings!

setPrerequisites: anIdentitySet
	"Private - Set the pre-computed pre-requisites of the receiver to specified Set of package names. 
	**Note that this is sent from the chunks which define a package in .PAC and .PAX files
	and should not be deleted**."

	prerequisiteNames := anIdentitySet!

sourceDescriptor
	^comment isInteger ifTrue: [comment]!

sourceDescriptor: anObject
	comment := anObject!

sourceGlobalNames
	"Private - Answer a <collection> of <Symbols>'s, being the names of the global variables 
	owned by the receiver that can be filed out as separate source objects."

	^self globalNames 
		- self binaryGlobalNames 
		- self globalAliases!

sourceGlobalVariables
	"Private - Answer a <collection> of <Association>'s, being the global variable owned 
	by the receiver that can be filed out as separate source objects."

	^self globalVariables 
		select: [:var | (self isSourceGlobal: var value) and: [(self isGlobalAlias: var) not]]!

sourceManager
	"Answer the receiver's source manager."

	^self class sourceManager!

stbSaveOn: anSTBOutFiler
	"Output the receiver to anSTBOutFiler. We must ensure that the local events collection
	is NOT saved to the filer"

	anSTBOutFiler override: events with: nil.
	super stbSaveOn: anSTBOutFiler.!

storeComment
	self assert: [comment isKindOf: String].
	self sourceManager storeCommentString: comment forPackage: self!

synchronizeNames
	"Private - Classes in the package may have been renamed (or otherwise refactored) and 
	aliased over, so we want to sync.up to the current names."

	| methods |
	methods := self methods.
	methodNames := methods isEmpty 
				ifFalse: 
					[| names |
					names := methodNames copyEmpty.
					methods do: [:each | names add: (self nameForMethod: each)].
					names]!

systemGlobalRenamed: oldName to: newName 
	"Private - React to oldName global being renamed."

	| globals |
	(classNames includes: oldName) 
		ifTrue: 
			[classNames
				remove: oldName;
				add: newName.
			^self].
	globals := self globalNames.
	(globals includes: oldName) 
		ifTrue: 
			[globals
				remove: oldName;
				add: newName]!

timestamp
	"Answer a <FILETIME> that represents the last write time of the receiver (i.e. the
	modification time of the file from which the package was loaded, or the time when the
	package was last saved) expressed as the number of 100-nanosecond intervals since 12:00 A.M.
	January 1, 1601 UTC. The <integer> value of the FILETIME will be 0 if the package is new and
	has not been written to disk."

	^FILETIME fromInteger: timestamp!

toggleUsingPAX
	"Toggles the use of PAX mode."

	^self isUsingPAX: self isUsingPAX not!

trace: trace prerequisite: aPackage from: from to: to type: type
	"Private - Append the supplied details of a prerequisite link
	to trace."

	| entries prereq |
	aPackage == self ifTrue: [^self].
	prereq := aPackage ifNil: [_Uncommitted].
	entries := trace at: prereq ifAbsentPut: [OrderedCollection new].
	entries add: (Array 
				with: from
				with: to
				with: type)!

tracePrerequisiteGlobals: trace packagedGlobals: globalLookup
	"Private - Trace the prerequisites of the receiver that come about because of
	references to globals from methods."

	self allMethodsDo: [:aMethod | 
		aMethod literalReferencesDo: [:literal | | global |
			global := self globalNameOfLiteral: literal.
			global notNil ifTrue: [ | prereq |
				prereq := globalLookup at: global ifAbsent: [].
				self trace: trace prerequisite: prereq from: aMethod to: global type: 'references global']]]!

tracePrerequisites
	"Private - Answer an IdentityDictionary of prerequisite package keys against an
	OrderedCollection of traces of the owned objects which forced a prerequisite link
	and the reason why. See #tracePrerequisites for further details."

	"Notification signal: 'Tracing prerequisites of ', self name."
	^self tracePrerequisites: self manager packagedGlobals!

tracePrerequisites: anIdentityDictionary 
	"Private - Answer an <IdentityDictionary> of prerequisite package keys against an
	<OrderedCollection> of traces of the owned objects which forced a prerequisite link and the
	reason why. The argument is an <IdentityDictionary>, the keys of which are# the names of all
	packaged globals, with the associated values being the owning <Package> of the global.

	1	from	The owned object of the receiver
	2	to		The object belonging to a prerequsite package which from references
	3	reason	String description of how from references to.

	There are quite a few reasons for a prequisite being generated:

	*	'from' is a Class which is a subclass of the Class 'to'.
	*	'from' is a directly owned CompiledMethod which is a method of the Class 'to'.
	*	'from' is a CompiledMethod which references the global object 'to'.
	*	'from' is a Class whose shared pools includes the global object 'to'.
	*	'from' is a global that aliases the class 'to'
	*	'from' is a global that references an instance of the class 'to'."

	| trace |
	trace := IdentityDictionary new.
	self
		tracePrerequisitesOfClasses: trace packagedGlobals: anIdentityDictionary;
		tracePrerequisitesOfGlobals: trace packagedGlobals: anIdentityDictionary;
		tracePrerequisitesOfMethods: trace;
		tracePrerequisitesOfImageStripper: trace;
		tracePrerequisiteGlobals: trace packagedGlobals: anIdentityDictionary.
	^trace!

tracePrerequisitesOfClasses: trace packagedGlobals: globalLookup
	"Private - Trace the prerequisites of the receiver's owned classes."

	| manager |
	manager := self manager.
	self classesDo: [:aClass | | base prereq |
		base := aClass superclass.
		"Have to account specially for subclasses of nil to avoid dependency on _Uncommitted"
		prereq := base isNil 
					ifTrue: [manager systemPackage] 
					ifFalse: [manager packageOfClass: base].
		self 
			trace: trace 
			prerequisite: prereq 
			from: aClass 
			to: base 
			type: 'is a subclass of'.

		"Look for references to pool dictionaries"
		aClass sharedPoolNames do: [:poolName |
			self 
				trace: trace 
				prerequisite: (globalLookup at: poolName ifAbsent: [])
				from: aClass 
				to: poolName 
				type: 'uses the shared pool']]

!

tracePrerequisitesOfGlobals: trace packagedGlobals: anObject 
	"Private - Trace the prerequisites of the receiver's loose methods."

	| untraced |
	untraced := self untracedGlobals.
	self globalVariables do: 
			[:each | 
			(untraced includes: each key) 
				ifFalse: 
					[(self isGlobalAlias: each) 
						ifTrue: 
							[self 
								trace: trace
								prerequisite: (anObject at: each value name)
								from: each key
								to: each value
								type: 'is an alias for']
						ifFalse: 
							[self 
								trace: trace
								prerequisite: (anObject at: each value class name)
								from: each value
								to: each value class
								type: 'is an instance of']]]!

tracePrerequisitesOfImageStripper: anIdentityDictionary 
	"Only possible to trace the stripper prereqs in DPRO"

	| stream hiddenObjects |
	(imageStripperBytes isNil or: [(self environment includesKey: #ImageStripper) not]) ifTrue: [^self].
	stream := imageStripperBytes readStream.
	hiddenObjects := 
			[(STBInFiler on: stream)
				basicNext;
				readMap] ensure: [stream close].
	hiddenObjects do: 
			[:each | 
			(each class isMeta and: 
					[
					"We only trace prerequisite objects that are NOT in the
					Lagoon package. After all, we know that Loaggon must be
					present if an ImageStripper is ever loaded into memory"
					| imageStripperClass lagoonPackage |
					imageStripperClass := self environment at: #ImageStripper.
					lagoonPackage := imageStripperClass owningPackage.
					each owningPackage ~= lagoonPackage]) 
				ifTrue: 
					[self 
						trace: anIdentityDictionary
						prerequisite: each owningPackage
						from: self
						to: each
						type: 'references class']]!

tracePrerequisitesOfMethods: trace 
	"Private - Trace the prerequisites of the receiver's loose methods."

	| manager |
	manager := self manager.
	self methods do: 
			[:aMethod | 
			self 
				trace: trace
				prerequisite: (manager packageOfClass: aMethod methodClass)
				from: aMethod
				to: aMethod methodClass
				type: 'is a method of']!

uninstall
	"Uninstall the receiver and any dependent packages from the system with no questions asked.
	Does not prompt to save changes."

	self manager uninstall: self!

uninstallClasses
	"Private - Uninstall the classes owned by the receiver.
	Note that the ClassBuilder may raise its #hasInstancesSignal if the class has extant
	instances. This is passed on to any outer handler, giving that handler the opportunity
	to state whether the presence of instances hould be ignored or not. For example a
	graphical tool might prompt the user to decide, whereas an automatic uninstaller might
	just affirm. The outer handler needs to resume with true in order to actually go ahead
	and remove the class, otherwise the class will be "

	| classes empty |
	classes := self remainingClasses.

	"Remove classes, bottom up so as to remove subclasses first"
	classes := classes asSortedCollection: [:a :b | (self depthOfClass: a) > (self depthOfClass: b)].
	classes do: 
			[:aClass | 
			"Notification signal: 'Removing class ', aClass name."
			[ClassBuilder removeClass: aClass ignoreInstances: true] 
				on: ClassBuilder invalidRemoveError
				do: 
					[:e | 
					e notify.
					e isNested 
						ifTrue: 
							["Remember that global Error trap will also count as nest"
							e outer == true ifFalse: [e return]].
					"Either no outer handler, or outer said to ignore, in either case remove it anyway"
					e resume]
				on: Error
				do: 
					[:ignoredException | 
					ignoredException notify
					"aClass allInstances do: [:e | Notification signal: e allReferences printString]"]].

	"If having difficulty tracking down the source of an image stripping problem which is
	 keeping references to uninstalled packaged classes, then try commenting in this code."
	empty := MethodDictionary new.
	classes do: 
			[:aClass | 
			(aClass environment includesKey: aClass name) 
				ifFalse: 
					[aClass class methodDictionary: empty.
					aClass methodDictionary: empty]]!

uninstallGlobals
	"Private - Uninstall the globals owned by the receiver. Should be done before classes 
	in case globals hold onto instances of any of the classes."

	self globalNames do: [:globalName |
		[	self environment removeGlobalNamed: globalName
		] on: Error do: [:ignoredException | ignoredException notify]].

!

uninstallMethods
	"Private - Uninstall the methods owned by the receiver that belong to classes which are not
	owned by the receiver (i.e. methods installed into classes outside this package)."

	self methodNames do: 
			[:methodName | 
			| method |
			method := self methodFromName: methodName ifAbsent: [].
			method isNil 
				ifTrue: 
					[Notification 
						signal: ('Packaged method <1s>>><2s> no longer exists' expandMacrosWith: methodName key
								with: methodName value)]
				ifFalse: [method methodClass removeSelector: method selector]]!

untracedGlobals
	"Answer a <collection> of <Symbol>s, being the names of the global variables which should be
	ignored when tracing prerequisites. This allows a global to reference an object from another
	package without creating a dependency on that package. An example of where this is useful is
	that the Transcript global owned by the the base package is assigned an instance of
	TranscriptShell by the Transcript development package when the latter is loaded. "

	^untracedGlobals isNil 
		ifTrue: [IdentitySet new]
		ifFalse: [untracedGlobals asIdentitySet]!

untracedGlobals: aCollectionOfSymbols 
	untracedGlobals := aCollectionOfSymbols notNil ifTrue: [aCollectionOfSymbols asArray]!

upateFileNames
	"Private - Update the package filename to match the package name and to be a PAC."

	self packageFileName: (File 
				composePath: self path
				stem: self name
				extension: self class packageExtension).
	"The prereqs may be out of date due to changes since last load, also the pre-reqs set at package load time
	include relative paths, so just toss them away"
	prerequisiteNames := nil!

updateTimestamp
	"Private - Synchronise the receiver's timestamp with its source file."

	timestamp := self fileModificationTime!

validate
	"Private - Validate the internal structure repairing any errors"

	methodNames := self methodNames select: [:each | (self methodFromName: each ifAbsent: []) notNil].
	methodNames isEmpty ifTrue: [methodNames := nil]!

variableSortBlock
	"Private - Answer a <dyadicValuable> sort block suitable for sorting global variable <Association>s
	into alphabetic order."

	^[:a :b | (a key trueCompare: b key) <= 0]!

versionIfRequired
	Package manager versionPackageIfRequired: self!

vmVersionCheck: verWhenSaved 
	"Private - Raise a warning to the effect that the package being loaded
	was saved with an older, and incompatible, version of the VM, and so
	it may need to be modified (e.g. by recompiling blocks in version resources)
	in order to work - it should load OK though."

	| versionString verOnLoad |
	verOnLoad := VMLibrary default bytecodeVersion.
	verWhenSaved = verOnLoad ifTrue: [^self].
	versionString := verWhenSaved > 0 
				ifTrue: [verWhenSaved highWord displayString , '.' , verWhenSaved lowWord displayString]
				ifFalse: ['unknown'].
	Notification 
		signal: ('The package <1p> was saved with a different version of the Dolphin VM (<2s>). 
It will probably load, but it may not operate correctly. 
If you experience subsequent problems please contact the package supplier for an updated version.' 
				expandMacrosWith: self name
				with: versionString)! !

PackageManager comment:
'The PackageManager class contains a collection of all the Packages currently loaded into
the system. The class obeys the Singleton pattern.

All the Packages known by a PackageManager must have unique names.

One of the packages is known as the system package. This Packages owns all of the system classes,
methods and globals which define the base Smalltalk system. It is not possible to remove or load in
a replacement for this package.

When Packages are loaded or removed from the CategoryManager we strive to leave the manager in a fully
working state. This is to ensure that the development tools will keep on working even if objects are
left unowned by a Package. It is possible to clear these up by using the PackageBrowser.

instance variables
	packages		Collection of loaded packages
	processEvents	Count of whether update events generated by the packages should be passed
			onto the rest of the system. Switched off during package install/uninstall for
			performance reasons.
	packagedGlobals	<IdentityDictionary> mapping package format global names to the owning
			package. Globals may be Classes or general global variables. This is a cache.
	looseMethods	<Collection> of all loose methods in the package system (i.e. methods owned
			by a package other that that of their class). This is a cache.

class variables
	Current		Singleton instance of PackageManager
	SystemPackage	Single package which owns all the system classes/globals

triggers generated
	loadedChanged	The collection of loaded packages has changed
	ownedChanged	The owned objects of a package have been changed, ie added to/removed.
	resetPrerequisites	The lazily generated prerequisites data for each of  the packages has been
			invalidated. This will happen quite often, for example compiling a method.
			The next time you request the prerequisites of a package it will calculate them.'!
!PackageManager class methodsFor!

buildSingletonInstance
	| dolphin |
	Notification signal: 'Creating new PackageManager'.
	Current := self basicNew initialize.
	dolphin := self systemPackage.
	Current
		basicAddPackage: dolphin;
		observePackage: dolphin;
		buildGlobalsMap!

current
	"Answer the singleton instance of the receiver."

	Current isNil ifTrue: [self buildSingletonInstance].
	^Current!

icon
	"Answers an Icon that can be used to represent this class."

	^Package icon!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize.
	"

	DuplicatePackageSignal := Signal 
				description: 'Package ''%1'' already installed'.
	PackageNotFoundSignal := Signal 
				description: 'Failed to locate Package ''%1'''.
	PrerequisiteNotFoundSignal := NotificationSignal 
				description: 'Package ''%1'' cannot be found'!

new
	"The receiver is a singleton class"

	^self shouldNotImplement!

newSystemPackage
	"Private - Set up and answer the system Package. All existing Classes and Globals are
	assigned to the package. It is assumed that there are no other packages currently defined.
	N.B. This should only ever be used during the boot process."

	| dolphin globalNames all inst |
	inst := self current.
	self assert: [inst packages isEmpty].
	(dolphin := Package name: self systemPackageName)
		basicComment: 
'Dolphin Smalltalk Base System.
Copyright (c) Object Arts Ltd. 1997-2016';
		basicScriptAt: #preinstall put: 'Error signal: ''Cannot replace the system package'''.
	all := self environment allClasses.
	all do: [:aClass | dolphin addClass: aClass].
	globalNames := Smalltalk keys.
	globalNames removeAll: (all collect: [:aClass | aClass name]).
	globalNames do: [:globalName | inst addGlobalNamed: globalName to: dolphin].
	dolphin untracedGlobals: (Array with: #Transcript).
	dolphin isChanged: false.
	^dolphin
!

reset
	"Reset the receivers singleton current instance and SystemPackage."

	Current notNil ifTrue: [Current release].
	Current := nil.
	SystemPackage := nil.!

systemPackage
	"Answer the Package which contains all the base objects of the system."

	SystemPackage isNil ifTrue: [
		SystemPackage := self newSystemPackage.
		SystemPackage updateTimestamp].
	^SystemPackage!

systemPackageName
	"Private - Answer the String name of the Package which owns all
	the system objects."

	^'Core\Object Arts\Dolphin\Base\Dolphin'!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self reset.! !

!PackageManager methodsFor!

addClass: aClass to: aPackageOrNil
	"Add the <Class>, aClass, to the <Package>, destination, after first 
	removing it from any existing package. If aPackage is nil, then the
	class becomes uncommitted (i.e. not owned by any package)."

	| source destination |
	source := self packageOfClass: aClass.
	destination := aPackageOrNil == Package uncommitted ifFalse: [aPackageOrNil].
	source == destination ifTrue: [^self].
	self forgetLooseMethods.	"Could be more discriminating, but rebuild is pretty quick"
	source notNil 
		ifTrue: 
			[packagedGlobals removeKey: aClass name.
			source basicRemoveClass: aClass].
	destination notNil 
		ifTrue: 
			[destination basicAddClass: aClass.
			packagedGlobals at: aClass name put: aPackageOrNil].
	self 
		classRepackaged: aClass
		from: source
		to: destination!

addGlobalNamed: globalName to: aPackageOrNil
	"Add the global variable named, globalName, to the <Package>, destination,
	after first removing it from any existing package."

	| source destination |
	source := self packageOfGlobalNamed: globalName.
	destination := aPackageOrNil == Package uncommitted ifFalse: [aPackageOrNil].
	source == destination ifTrue: [^self].
	source notNil 
		ifTrue: 
			[packagedGlobals removeKey: globalName.
			source basicRemoveGlobalNamed: globalName].
	destination notNil 
		ifTrue: 
			[aPackageOrNil basicAddGlobalNamed: globalName.
			packagedGlobals at: globalName put: aPackageOrNil].
	self 
		globalRepackaged: globalName
		from: source
		to: destination!

addLooseMethod: aCompiledMethod to: aPackage
	"Private - The loose <CompiledMethod> argument has been (or is about to
	be) added to the <Package> argument. Maintain the loose method cache."

	looseMethods notNil ifTrue: [looseMethods at: aCompiledMethod name put: aPackage].
	aPackage addLooseMethod: aCompiledMethod!

addManagedPackage: aPackage
	"Private - Add the <Package> argument to the collection of packages held by the receiver. 
	Each package must have a unique name. Answer the argument, or raise an error if either
	a package with the same name already exists or there is some clash between the
	contents of the package and existing installed packages."

	self addPackage: aPackage; observePackage: aPackage!

addMethod: aCompiledMethod to: aPackageOrNil 
	"Add the <CompiledMethod>, method, to the <Package>, destination,
	after first removing it from any existing package. Note that this is a
	composite operation with 4 possible cases:
		1) packaged -> loose
		2) loose -> packaged
		3) loose -> loose
		4) packaged -> packaged (not possible)
	Moving a packaged method (one owned by the same package as the class in
	which it implements a message) to become a loose method in a foreign package
	is different to the others in that we can't actually 'remove' a packaged method 
	from its package since it is not listed separately. In order that the state of the
	packages is consistent in that case we all cases we therefore first add the method to its package in 
	which it becomes a loose method before 'removing' it from its home package."

	| source destination classPackage moved indexValue |
	classPackage := self packageOfClass: aCompiledMethod methodClass.
	destination := (aPackageOrNil isNil or: [aPackageOrNil == Package uncommitted]) 
				ifTrue: [classPackage]
				ifFalse: [aPackageOrNil].
	source := self packageOfMethod: aCompiledMethod.
	source == destination ifTrue: [^self].
	moved := source isNil 
				ifTrue: 
					[self 
						moveMethod: aCompiledMethod
						from: classPackage
						to: destination]
				ifFalse: 
					[self 
						moveLooseMethod: aCompiledMethod
						from: source
						to: destination].

	"Only after the move is complete do we publish events to observers"
	moved ifFalse: [^self].
	"If the method is moving or returning to its home package, then that package is marked as
	changed, but the objects it lists as owned has not changed. Where a method is/was loose in a
	package, then the owning package has changed its owned contents."
	indexValue := [aCompiledMethod changePosition].
	source isNil 
		ifTrue: 
			[source := classPackage.
			self memberOf: classPackage updatedAt: indexValue]
		ifFalse: [source membershipChangedAt: indexValue].
	aPackageOrNil isNil 
		ifTrue: [self memberOf: destination updatedAt: indexValue]
		ifFalse: [self membershipChanged: destination at: indexValue].
	self 
		methodRepackaged: aCompiledMethod
		from: source
		to: destination!

addPackage: aPackage 
	"Private - Add the <Package> argument to the collection of packages held by the receiver. 
	Each package must have a unique name. Answer the argument, or raise an error if either
	a package with the same name already exists or there is some clash between the
	contents of the package and existing installed packages. Note that at this point we don't
	subscribe to any of the package's events."

	| name |
	name := aPackage name.
	(self includesPackageNamed: name) ifTrue: [^self errorNameIsNotUnique: name].
	(self loadCompatibilityCheck: aPackage) do: [:each | each owningPackage: Package uncommitted].
	self basicAddPackage: aPackage.
	^aPackage!

addPackagedMethod: aCompiledMethod to: aPackageOrNil 
	"Private - The <CompiledMethod> argument has been (or is about to
	be) added back to the same <Package> (as specified by the argument) to 
	which its method class belongs. Note that the target might be nil if the 
	method class is uncomitted."

	aPackageOrNil isNil 
		ifTrue: [aCompiledMethod methodClass methodChanged: aCompiledMethod]
		ifFalse: [aPackageOrNil addPackagedMethod: aCompiledMethod]!

addResourceIdentifier: aResourceIdentifier to: aPackageOrNil 
	"Add the <ResourceIdentifier>, aResourceIdentifier, to the <Package>, destination,
	after first removing it from any existing package."

	| source destination |
	destination := aPackageOrNil isNil ifTrue: [Package uncommitted] ifFalse: [aPackageOrNil].
	source := self packageOfResourceIdentifierOrItsClass: aResourceIdentifier.
	source == destination ifTrue: [^self].
	self addMethod: aResourceIdentifier compiledMethod to: aPackageOrNil.
	self 
		resourceRepackaged: aResourceIdentifier
		from: source
		to: destination!

allDependentPackagesOf: aPackage visited: visitedPackages 
	"Private - Add dependent packages of the <Package> argument, package, which
	are not already members of the <Set>, visitedPackages, to that set, and visit
	them. Answer the combined dependents."

	(self dependentPackagesOf: aPackage) do: 
			[:each | 
			(visitedPackages includes: each) 
				ifFalse: 
					[visitedPackages add: each.
					self allDependentPackagesOf: each visited: visitedPackages]].
	^visitedPackages!

allGlobalAliases
	^self packages inject: IdentitySet new
		into: 
			[:all :each | 
			all addAll: each globalAliases.
			all]
!

allPackagedClasses
	"Private - Answer a <collection> of all the packaged classes in the system."

	| answer |
	answer := OrderedCollection new: 2000.
	self packages do: [:eachPackage | eachPackage classesDo: [:eachClass | answer add: eachClass]].
	^answer!

allPackagedGlobalNames
	"Private - Answer a <Set> of <Symbol>, being the names of all the 
	packaged globals in the system. Note that this does not include the
	names of packaged classes."

	| answer |
	answer := IdentitySet new: 50.
	self packages do: [:p | answer addAll: p globalNames].
	^answer!

allSourceObjects
	"Answer a <collection> of all the source objects known to the receiver"

	| answer |
	answer := OrderedCollection new: 2000.
	self packages 
		do: [:eachPackage | eachPackage allSourceObjectsDo: [:each | answer addLast: each]].
	^answer!

basePackages
	^basePackages ifNil: [basePackages := IdentitySet new].
!

basicAddPackage: aPackage
	self packages at: aPackage name put: aPackage!

basicInstall: aPackage 
	aPackage load!

basicRemovePackage: aPackage
	"Private - Remove the <Package> argument from the receiver's
	collection of loaded packages. All the packages owned objects are 
	assumed to have already been removed from the system.
	Answer the Package."

	self packages removeKey: aPackage name.
	defaultPackage == aPackage ifTrue: [defaultPackage := nil].
	^aPackage!

basicUninstall: aPackage
	"Private - Remove aPackage from the receivers loaded packages.
	All the packages owned objects are removed from the system.
	Answer aPackage."

	self beNotProcessingEvents.
	[	
		aPackage removeEventsTriggeredFor: self.
		[aPackage privateUninstall]	 ensure: [self basicRemovePackage: aPackage]
	] ensure: [self beProcessingEvents]!

beNotProcessingEvents
	"Private - Temporarily suspend the processing of system events or
	triggering of our own. This is not a binary mode but a count, so the same
	number of beProcessingEvents must be sent to the reeciever as
	beNotProcessingEvents before events are again processed. Ignored
	events are NOT cached by the receiver for processing later.

	N.B. Note that processing of events should only be suspending when
	installing or uninstalling a package, as it can leave the receiver and the
	Packages it holds in an inconsistent state. The reason for suspending
	events is to prevent the package from receiving events while it is
	in a partially loaded or unloaded state, and also to avoid an unecessary
	flurry of knock-on events."

	self changeProcessEventsBy: 1.
	self forgetLooseMethods!

beProcessingEvents
	"Private - Recommence processing system events and sending our own
	only if an equal number of beProcessingEvents as beNotProcessingEvents
	have been sent to the receiver."

	(self changeProcessEventsBy: -1) == 0
		ifTrue: [self clearCachedInformation]!

buildGlobalsMap
	"Private - Answer an <IdentityDictionary> which maps the symbolic names of all packaged
	globals to the owning package. This is used during the tracing of package prerequisites.
	"

	packagedGlobals := IdentityDictionary new: self class environment size.
	self packages do: [:package |
		package globalNames do: [:globalName |
			packagedGlobals at: globalName put: package].
		package classNames do: [:className |
			packagedGlobals at: className asSymbol put: package]].
	^packagedGlobals 
!

changedPackages
	"Answer a <collection> of all the packages that have been changed."

	^self packages select: [:each | each isChanged]!

changeProcessEventsBy: countChange
	"Private - Change the receivers count of the processEvents by countChange.
	A value of zero indicates that no one has a lock on the triggers and that they 
	should be processed as they are received from the rest of the system or generated 
	by the receiver. A value greater than 0 indicates that processing is temporarily suspend 
	until it is reduced back to 0. Any events received while suspended ar NOT cached for later
	processing."

	processEvents := processEvents + countChange.
	processEvents < 0 ifTrue: [
		Notification signal: 'PackageManager processEvents became corrupt and has been reset.'.
		processEvents := 0].
	^processEvents!

classRepackaged: aClass from: source to: destination 
	"Private - Trigger class repackaging notifications."

	"When a class is repackaged (or removed), we reset all pre-reqs as it may affect not just
	 the source and destination packages (e.g. packages with loose methods in the repackaged
	 class are affected). This could probably be done more intelligently though."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		resetPrerequisites;
		trigger: #classRepackaged:from:to:
			withArguments: (Array 
					with: aClass
					with: source
					with: destination)!

clearCachedInformation
	"Private - Clear down all cached information such as prerequisites."

	packagedGlobals notNil ifTrue: [self buildGlobalsMap].
	self forgetLooseMethods; resetPrerequisites!

defaultPackage
	^defaultPackage!

defaultPackage: aPackage 
	defaultPackage := aPackage!

dependentPackagesOf: aPackage 
	"Private - Answer a <collection> of the packages which have the <Package> argument,
	as a prerequisite."

	^self packages select: [:each | each prerequisites includes: aPackage]!

duplicatePackageSignal
	"Private - Answer the Signal raised when an attempt is made to install a package
	with the same name as one already present in the image."

	^DuplicatePackageSignal!

errorFileInCompatibilityCheck: aPackage overlap: overlappingObjects 
	"Private - Raise an error that the receiver can not be filed in
	because some objects which it expects to own are already owned
	by existing Packages."

	Notification signal: aPackage name , ': ' , overlappingObjects asArray printString.
	Package clashSignal 
		signal: ('The package <1p> contains objects that are already installed in the image.' 
				expandMacrosWith: aPackage name)
		with: overlappingObjects asArray!

errorNameIsNotUnique: aString 
	^DuplicatePackageSignal signal: aString!

errorPackageNotFound: aString 
	"Private - Raise an <Error> to the effect that the named package could
	not be located. This is trapped in install:."

	^PackageNotFoundSignal signal: aString!

errorPrerequisiteNotFound: aString 
	"Private - Raise a resumable error to the effect that the named package cannot be found.
	Answer a <readableString> being a revised the path for the package, or nil if no suggestions
	are available (e.g. this is not an interactive session and so user input is not available)."

	^PrerequisiteNotFoundSignal signal: aString!

errorRemovingSystemPackage
	^self error: 'The system package must not be uninstalled.'!

forgetLooseMethods
	"Forget the cached <LookupTable> of all the <CompiledMethod>s which are owned by
	packages which do not own the corresponding method class (i.e. those methods
	added by a package to classes in other packages)."

	looseMethods := nil!

getEvents
	"Private - Answer the <EventsCollection> belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^events!

getLooseMethods
	"Private - Answer a <LookupTable> of all the <CompiledMethod>s which are owned by
	packages which do not own the corresponding method class (i.e. those methods
	added by a package to classes in other packages). The table maps loose methods
	by name to their owning package."

	| loose |
	loose := PluggableLookupTable new: 1500 searchPolicy: AssociationSearchPolicy current.
	self packages do: [:each | loose atAll: each methodNames put: each].
	^loose!

getVersionInfoFor: aCompiledMethod 
	"Part of the StsManager protocol implemented here for systems which do not have STS
	installed. Answer nil to indicate that we cannot supply version information for
	aCompiledMethod"

	^nil!

globalRepackaged: globalName from: source to: destination 
	"Private - The global variable named by the <Symbol>, globalName, 
	has been repackaged. The operation is now complete and the package
	system in a consistent state so this is an appropriate point to pdate change 
	flags for all objects affected by the move and to trigger various notifications."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		resetPrerequisites;
		trigger: #globalRepackaged:from:to:
			withArguments: (Array 
					with: globalName
					with: source
					with: destination)!

includesPackage: aPackage 
	"Answer whether the receiver manages the specified <Package>."

	^self packages includes: aPackage!

includesPackageNamed: aString 
	"Answer whether the receiver holds a <Package> whose name matches 
	that specified."

	^(self packageNamed: aString ifNone: []) notNil!

initialize
	"Private - Initialize the receivers instance variables and connect to a number of system
	triggers to ensure that the receivers packages remove references to any system objects which
	are removed."

	packages := PluggableLookupTable searchPolicy: SearchPolicy caseInsensitive.
	processEvents := 0.
	packagedGlobals := IdentityDictionary new.
!

install: aString 
	"Install the package file at the specified <readableString> path, and any pre-requisite
	packages, and any of the their pre-requisites, and so on. Answer a
	<sequencedReadableCollection> of packages in the installation order (i.e. the target package
	will be last in the list). If the package cannot be loaded, answer an empty collection."

	"Note that 'installation' loads the Package object and all the objects it owns too, i.e. all
	classes, methods, resources and globals are loaded into the system and the packages' install
	scripts are run. The receiver attempts to load any prerequsite packages from the same path
	location as that of the requested package, but if a suitable package then the 'prerequisite
	not found' exception is signalled. The caller can trap this exception (the
	<exceptionSelector> can be accessed using the #prerequisiteNotFoundSignal message), prompt
	the user to locate the path (for example), and resume the exception with the prerequisite
	package path as the argument. The receiver's #loadedChanged event is triggered on completion
	of installation of the network of packages."

	| newPackages startPackage |
	startPackage := self loadPackage: aString.
	(self includesPackageNamed: startPackage name) 
		ifTrue: [^self errorNameIsNotUnique: startPackage name].
	
	[| filename |
	filename := startPackage packageFileName.
	newPackages := self 
				loadPrereqsForPackage: startPackage
				relativeTo: startPackage path
				extension: (File splitExtensionFrom: filename)
				loaded: (PluggableSet searchPolicy: SearchPolicy caseInsensitive)
				trail: OrderedCollection new] 
			on: PackageNotFoundSignal
			do: 
				[:ex | 
				"Installation aborted"
				^#()].
	self assert: [newPackages last == startPackage].
	self beNotProcessingEvents.
	
	[newPackages do: 
			[:each | 
			self addPackage: each.
			[self basicInstall: each] ifCurtailed: [self basicUninstall: each].
			self observePackage: each]] 
			ensure: 
				[self beProcessingEvents.
				self loadedChanged].
	^newPackages!

installHere: aString 
	"Same as #install: except that aString is seen as being relative to the current directory
	rather than the image base."

	^self install: (File fullPathOf: aString)!

isConnected
	"Part of the StsManager protocol implemented here for systems which do not have STS
	installed. Answer nil to indicate that we are not connected to a repository"

	^false!

isLooseMethod: aCompiledMethod
	"Answer whether the argument is a loose method (i.e. one owned by a package other
	than that of its class)."

	^self looseMethods includesKey: aCompiledMethod name!

isLooseResource: aResourceIdentifier
	"Answer whether the argument is a loose resource (i.e. one owned by a package other
	than that of its associated class)."

	^self looseResourceIdentifiers includes: aResourceIdentifier!

isProcessingEvents
	"Private - Answer whether the receiver will act on triggers from the rest of the system that
	it is interested in."

	^processEvents == 0!

loadCompatibilityCheck: aPackage 
	"Private - The <Package> argument is about to be filed in. Ensure that no existing package
	managed by the receiver owns any of the objects which the package thinks it owns. This must
	be executed before the package can be taken under the receiver's wing as a managed package.

	All the package's owned object names which overlap with any existing packages are stored in
	the overlappingObjects collection which is raised with the error. Refer to its contents if
	you have any problems."

	| overlappingObjects |
	overlappingObjects := Set new.
	aPackage classNames 
		do: [:each | Smalltalk at: each ifPresent: [:class | overlappingObjects add: class]].
	aPackage globalNames 
		do: [:each | Smalltalk associationAt: each ifPresent: [:global | overlappingObjects add: global]].
	"The methods accessor answers a collection of those methods named in the package that can
	be found in the image, since the package is not yet loaded, this will only include the clashing methods"
	overlappingObjects addAll: aPackage methods.
	overlappingObjects notEmpty 
		ifTrue: [self errorFileInCompatibilityCheck: aPackage overlap: overlappingObjects].
	^overlappingObjects!

loadedChanged
	"Private - The set of installed packages has changed. Clear down all cached information
	that might be invalidated, and trigger an event for observers."

	self isProcessingEvents ifTrue: [
		self trigger: #loadedChanged]!

loadPackage: aString 
	"Private - Answer the Package object stored in the package file at the specified path. Note that the
	loaded package's contents are NOT loaded and the package is NOT inserted into the receiver's
	collection of packages at this stage."

	^Package fromFile: aString!

loadPrereq: prereqPathString relativeTo: basePathString extension: extensionString loaded: loadedCollection trail: trailCollection 
	"Private - Answer a Collection of Packages which have had to be loaded in for the
	pre-requisite package at the <readableString> path, prereqPath, which is relative to the
	<readableString> path, pathString. The collection also includes the contents of
	loadedCollection."

	| package expectedPathname actualPathname prereqName |
	prereqName := File splitFilenameFrom: prereqPathString.
	"Already installed or already visited?"
	((self includesPackageNamed: prereqName) or: [loadedCollection includes: prereqName]) 
		ifTrue: [^trailCollection].
	"First look using relative path from base"
	expectedPathname := File default: (File fullPathOf: prereqPathString relativeTo: basePathString)
				extension: extensionString.
	actualPathname := (File exists: expectedPathname) 
				ifTrue: [expectedPathname]
				ifFalse: 
					["Try directly in the base folder"
					| localPathname |
					localPathname := File 
								composePath: basePathString
								stem: prereqName
								extension: extensionString.
					(File exists: localPathname) 
						ifTrue: [localPathname]
						ifFalse: [self errorPrerequisiteNotFound: expectedPathname]].
	actualPathname notNil 
		ifTrue: [package := self loadPackage: actualPathname]
		ifFalse: [self errorPackageNotFound: prereqPathString].
	^self 
		loadPrereqsForPackage: package
		relativeTo: package path
		extension: extensionString
		loaded: loadedCollection
		trail: trailCollection!

loadPrereqsForPackage: aPackage relativeTo: pathString extension: extensionString loaded: loadedCollection trail: trailCollection 
	"Private - Load and append pre-requisites of the <Package>, aPackage, to the
	<OrderedCollection>, trailCollection, before appending aPackage to the trail. Answer the
	resulting trail. A package's pre-requisites always appear before itself, and each package
	only appears once in the trail. The <PluggableSet>, loaded, records the names of those
	packages that have previously been loaded while walking the pre-requisites tree, but which
	may not necessarily be in the trail yet, since that is constructed by a post-order
	traversal. The <readableString>, pathString, specifies the original package path, and the
	<readableString>, extensionString, specifies the original package extension (be it PAC or
	PAX, since we try and load the same type of pre-requisite package if we can). This method is
	mutually recursive with #loadPrereq:path:extension:loaded:trail:"

	loadedCollection add: aPackage name.
	aPackage prerequisiteNames do: 
			[:each | 
			self 
				loadPrereq: each
				relativeTo: pathString
				extension: extensionString
				loaded: loadedCollection
				trail: trailCollection].
	trailCollection addLast: aPackage.
	^trailCollection!

looseMethodRemoved: aCompiledMethod 
	"Private - The loose <CompiledMethod> argument has been (or is about to be) removed from the
	system or is no longer loose. Maintain the loose method cache."

	looseMethods notNil ifTrue: [looseMethods removeKey: aCompiledMethod name ifAbsent: []]!

looseMethods
	"Answer an <LookupTable> of all the <CompiledMethod>s which are owned by packages which do
	not own the corresponding method class (i.e. those methods added by a package to classes in
	other packages). This information is cached to speed up the tracing of pre-requisites,
	particular where the whole dependency tree must be calculated (as when uninstalling
	packages). Note that the information may be outdated if requested when event processing is
	disabled, but as this only applies during installation and uninstallation this is not
	material since the cache is then bypassed and is regenerated when event processing is again
	enabled."

	looseMethods isNil ifTrue: [looseMethods := self getLooseMethods].
	^looseMethods!

looseMethodUpdated: aCompilationResult 
	"There is nothing to do because the loose method cache now holds method 'names' which are
	indirect and remain valid as long as the class name and selector are unchanged, which they
	must be for a #methodUpdated: event"

	!

looseResourceIdentifiers
	"Private - Answer a <Set> of all <ResourceIdentifier>s owned by a package other than that of
	their associated class (by default a rid is owned by the package of its owning class)."

	| answer |
	answer := Set new: 25.
	self packages do: [:p | answer addAll: p resourceIdentifiers].
	^answer!

markAllPackagesAsBase
	"Marks all the currently loaded packages as part of the base system. This should normally
	only be called at the end of the image boot."

	self basePackages addAll: self packages!

memberOf: aPackage updatedAt: aNiladicValuable 
	"Private - Inform the <Package> argument that it has been changed and needs to reset its
	prerequisites, but not that its membership has changed. The <niladicValuable> argunment is
	evaluated (if needed) to determine the position in the change log from which the package
	should be considered to have changed. This is used to distinguish between owned objects that
	were modified since the last package save from those which were modified before it."

	aPackage isNil 
		ifTrue: [Package uncommitted resetPrerequisites]
		ifFalse: [aPackage memberUpdatedAt: aNiladicValuable]!

membershipChanged: aPackage 
	"Private - Trigger an ownership notification off the <Package> argument."

	self membershipChanged: aPackage at: [Package sourceManager changesFileSize]!

membershipChanged: aPackage at: aNiladicValuable 
	aPackage isNil 
		ifTrue: [Package uncommitted resetPrerequisites]
		ifFalse: [aPackage membershipChangedAt: aNiladicValuable]!

memberUpdatedIn: aPackage 
	self memberOf: aPackage updatedAt: [Package sourceManager changesFileSize]!

methodRepackaged: aCompiledMethod from: sourcePackage to: destinationPackage 
	self assert: [sourcePackage ~~ destinationPackage].
	self trigger: #methodRepackaged:from:to:
		withArguments: (Array 
				with: aCompiledMethod
				with: sourcePackage
				with: destinationPackage)!

moveLooseMethod: aCompiledMethod from: sourcePackage to: destinationPackage 
	"Private - Move the loose <CompiledMethod> argument from the <Package>,
	sourcePackage, to the <Package>, destinationPackage."

	sourcePackage == destinationPackage 
		ifTrue: 
			["No-op"
			^false].
	sourcePackage removeLooseMethod: aCompiledMethod.
	self looseMethodRemoved: aCompiledMethod.
	destinationPackage == (self packageOfClass: aCompiledMethod methodClass) 
		ifTrue: [self addPackagedMethod: aCompiledMethod to: destinationPackage]
		ifFalse: [self addLooseMethod: aCompiledMethod to: destinationPackage].
	^true!

moveMethod: method from: source to: destination 
	"Private - Move the packaged (not loose) <CompiledMethod>, method, from the package of its
	method class to the foreign <Package>, destination. Answer whether the method was moved."

	"Note that the destination cannot be nil (i.e. it is not possible to have uncommitted loose
	methods), however the source could be nil if the method's class is currently uncommitted."

	self assert: [destination notNil].
	source == destination 
		ifTrue: 
			["No-op: Add packaged method to its own package"
			^false].
	self addLooseMethod: method to: destination.
	source notNil ifTrue: [source removePackagedMethod: method].
	^true!

newPackage: aString 
	"Private - Add a new <Package> to the collection of packages held by the receiver,
	with the specified <readableString> package filename. Answer the new package."

	| pkg |
	pkg := Package name: aString.
	self addManagedPackage: pkg.
	self loadedChanged.
	^pkg!

observePackage: aPackage 
	"Private - Subscribe to certain events from the specified managed <Package>."

	aPackage
		when: #changed
			send: #onPackageChanged:
			to: self
			with: aPackage;
		when: #ownedChanged
			send: #onOwnedChanged:
			to: self
			with: aPackage;
		when: #prerequisitesReset
			send: #onPrerequisitesReset:
			to: self
			with: aPackage!

onClassAdded: aClass
	"The <Class> argument has been newly added to the system. Associate
	it with the default package, if set."

	#todo.	"This event needs an additional parameter which should be the desired package, or nil for default"
	self isProcessingEvents ifTrue: [self addClass: aClass to: self defaultPackage]!

onClassRemoved: aClass 
	"Private - React to aClass being removed from the Smalltalk system. Ensure that none of the
	packages held by the receiver refer to aClass or its methods now it has departed."

	| changed |
	self isProcessingEvents ifFalse: [^self].
	packagedGlobals removeKey: aClass name ifAbsent: [].
	"We must inform all packages, not just the package owning the class, in case any other
	packages include loose methods of the class. In case they do we empty our loose method
	cache."
	self forgetLooseMethods.
	changed := self packages select: [:aPackage | aPackage onClassRemoved: aClass].
	changed do: [:aPackage | aPackage membershipChanged].
	self resetPrerequisites!

onClassRenamed: aClass from: oldSymbol to: newSymbol 
	| changed indexValue changePoint |
	changed := self packages select: 
					[:each | 
					each 
						onClassRenamed: aClass
						from: oldSymbol
						to: newSymbol].
	changed isEmpty ifTrue: [^self].
	"Only trigger events once all packages updated"
	self forgetLooseMethods.
	changePoint := aClass sourceManager changePositionOf: aClass.
	indexValue := [changePoint].
	changed do: [:each | each memberUpdatedAt: indexValue]!

onClassUpdated: aClass 
	"Private - React to aClass being updated. This could be in response to
	its pool dictionaries changing, super class changing, etc. Note that this
	shouldn't changed the packaged status of the class, but may well change
	the prerequisites."

	self isProcessingEvents ifFalse: [^self].
	self memberOf: (self packageOfClass: aClass)
		updatedAt: [self sourceManager changePositionOf: aClass]!

onGlobalRemoved: anAssociation 
	"Private - React to globalName being removed from the Dolphin
	system. Ensure that none of the packages held by the receiver refer
	to globalObject now it has departed."

	| package |
	self isProcessingEvents ifFalse: [^self].
	package := packagedGlobals removeKey: anAssociation key ifAbsent: [].
	package isNil ifFalse: [package basicRemoveGlobalNamed: anAssociation key].
	self membershipChanged: package.
	"Removing a global resets all pre-rereqs"
	self resetPrerequisites!

onGlobalRenamed: anAssociation from: aSymbol 
	"Private - A global has been renamed. Ensure that all the receivers packages
	are aware of this change. Note that pre-requisites should be unaffected."

	| global pkg newName |
	pkg := packagedGlobals at: aSymbol ifAbsent: [].
	newName := anAssociation key.
	pkg notNil ifTrue: [packagedGlobals changeKey: aSymbol to: newName].
	self isProcessingEvents ifFalse: [^self].

	"Unfortunately we get the same event for classes as other globals, so we must test,
	also we must be careful not to act on the rename of global aliases."
	global := anAssociation value.
	(global class isMeta and: [global name == newName]) 
		ifTrue: 
			[self 
				onClassRenamed: global
				from: aSymbol
				to: newName]
		ifFalse: [pkg notNil ifTrue: [pkg onGlobalRenamed: anAssociation from: aSymbol]]!

onMethodAdded: aCompilationResult 
	"Private - A new method has been added to the system. Establish
	its package as either the suggestion in the CompilationResult (which
	was passed as a parameter with the original compilation request), or
	the default package if set, or the package of the method's class if
	both are nil."

	| owner default method package |
	self isProcessingEvents ifFalse: [^self].
	method := aCompilationResult method.
	package := aCompilationResult package.
	self assert: [method isLoose not].
	default := self defaultPackage ifNil: [package].
	owner := self packageOfClass: method methodClass.
	(default isNil or: [default == owner]) 
		ifTrue: [self addPackagedMethod: method to: owner]
		ifFalse: 
			[self addLooseMethod: method to: default.
			owner := default].
	aCompilationResult package: owner.
	self memberOf: owner updatedAt: [method changePosition]!

onMethodCategorized: aCompiledMethod 
	"Private - React to aMethod being recategorized in the Dolphin system.
	We may need to maintain change flags, but that should be it."

	| package |
	self isProcessingEvents ifFalse: [^self].
	package := self packageOfMethod: aCompiledMethod.
	package isNil 
		ifTrue: 
			["If not a loose method, then the class has changed (marking its package as changed)"
			aCompiledMethod methodClass isChanged: true]
		ifFalse: 
			["If a loose method, then only the package has changed"
			package isChanged: true]!

onMethodRemoved: aCompiledMethod 
	"Private - The <CompiledMethod> argument is being removed from the Dolphin
	system. Ensure that any package which might own the method is informed."

	| package |
	self isProcessingEvents 
		ifFalse: 
			[self looseMethodRemoved: aCompiledMethod.
			^self].
	package := self packageOfMethod: aCompiledMethod.
	package isNil 
		ifTrue: 
			[package := self packageOfClass: aCompiledMethod methodClass.
			package notNil ifTrue: [package removePackagedMethod: aCompiledMethod].
			"Remove a normal (not loose) method does not change package ownership"
			self memberUpdatedIn: package]
		ifFalse: 
			[self looseMethodRemoved: aCompiledMethod.
			package removeLooseMethod: aCompiledMethod.
			"Removing a loose method does change package ownership"
			self membershipChanged: package]!

onMethodUpdated: aCompilationResult 
	"Private - A pre-existing method has been updated. React by informing the 
	owning package (if any).
	Note that this event is only triggered when an existing method is modified, and 
	as it may previously have been loose we may need to replace the old instance
	in the loose method cache. If it was not loose before, it cannot be now (by
	this action)."

	| package method |
	self isProcessingEvents 
		ifFalse: 
			[self looseMethodUpdated: aCompilationResult.
			^self].
	package := self packageOfMethod: aCompilationResult oldMethod.
	method := aCompilationResult method.
	package isNil 
		ifTrue: 
			[package := self packageOfClass: method methodClass.
			self addPackagedMethod: method to: package]
		ifFalse: [self looseMethodUpdated: aCompilationResult].

	"We don't ask the package to trigger an #ownedChanged event for the addition
	 of new methods, this must be tracked by watching the normal system #methodAdded:
	 event."
	self memberOf: package updatedAt: [method changePosition]!

onOwnedChanged: aPackage 
	"Private - The contents of aPackage have been changed"

	self isProcessingEvents ifTrue: [self trigger: #ownedChanged: with: aPackage]!

onPackageChanged: aPackage
	"Private - Inform any interested parties that the <Package> argument 
	has been marked as changed. Note that this is only fired when a
	change mark is added or removed, not every time a package is changed."

	self isProcessingEvents ifTrue: [
		self trigger: #packageChanged: with: aPackage]!

onPrerequisitesReset: aPackage
	"Private - The <Package> argument has reset its prerequisites. Fire off
	an event to our own observers with that package as an argument."

	self trigger: #prerequisitesReset: with: aPackage!

onPreStripImage
	"Private - Image stripping is in progress. Set up the receiver so as not to interfere."

	packagedGlobals := nil.
	self release.
	self beNotProcessingEvents !

packagedGlobals
	"Private - Answer an <IdentityDictionary> which maps the symbolic names of all packaged
	globals to the owning package. This is used during the tracing of package prerequisites."

	^packagedGlobals!

packageNamed: packageName
	"Answer the <Package> held by the receiver whose name matches
	the <readableString>, packageName, or raise an error if there is
	no match."

	^self packageNamed: packageName ifNone: [self errorNotFound: packageName]!

packageNamed: packageName ifNone: absentBlock
	"Answer the <Package> held by the receiver whose name matches
	<readableString>, packageName, or, if there is no such package,
	the result of evaluating the <niladicValuable>, absentBlock.
	Implementation Note: Use a case-insensitive comparison of the package
	names."

	^self packages at: packageName ifAbsent: absentBlock!

packageNames
	"Answer a <collection> of <readableString>s, being the names of all <Package>s
	installed in the system (and managed the receiver)."

	^self packages keys!

packageOfClass: aBehavior 
	"Answer the package held by the receiver which owns aBehavior or the special 'Uncommitted' package if the class has no other assignment."

	^packagedGlobals at: aBehavior instanceClass name
		ifAbsentPut: 
			["Fall back on enumerating the packages."
			self packages detect: [:p | p includesClass: aBehavior] ifNone: [^nil	"Package uncommitted"]]!

packageOfGlobalNamed: globalName 
	"Answer the package held by the receiver which owns globalName (excluding
	classes) or nil if there isn't one."

	| package |
	package := packagedGlobals at: globalName
				ifAbsentPut: 
					["Fall back on enumerating the packages."
					self packages detect: [:each | each includesGlobalNamed: globalName] ifNone: [^nil]].
	self assert: [package includesGlobalNamed: globalName].
	^package!

packageOfMethod: aCompiledMethod
	"Answer the Package held by the receiver which directly owns the 
	<CompiledMethod> argument as a loose method or nil if it is
	associated with the package of its class (i.e. it is not a loose method).
	Implementation Note: Use the loose method cache if available, otherwise
	do the slower search through each package in turn."

	^looseMethods isNil 
		ifTrue: [self packages detect: [:pkg | pkg includesMethod: aCompiledMethod] ifNone: []]
		ifFalse: 
			[looseMethods at: aCompiledMethod name
				ifPresent: 
					[:pkg | 
					self assert: [pkg includesMethod: aCompiledMethod].
					pkg]]!

packageOfMethodOrItsClass: aMethod
	"Answer the <Package> which owns the <CompiledMethod>, method,
	either directly as a loose method, or indirectly by ownership of its
	class."

	| package |
	package := self packageOfMethod: aMethod.
	^package notNil
		ifTrue: [package]
		ifFalse: [self packageOfClass: aMethod methodClass]!

packageOfResourceIdentifier: aResourceIdentifier 
	"Answer the Package held by the receiver which directly owns aResourceIdentifier as a loose
	resource, or nil if there isn't one."

	^aResourceIdentifier owningPackage!

packageOfResourceIdentifierOrItsClass: aResourceIdentifier 
	"Answer the <Package> managed by the receiver which owns either
	the <ResourceIdentifier> argument, or its class, or nil if resource is
	uncommitted."

	^aResourceIdentifier owningPackage!

packages
	"Answer the <collection> of <Package>s held by the receiver, note that this excluded the
	<Unpackaged> package which is the hypothetical owner of any unpackaged source objects."

	^packages!

prerequisiteNotFoundSignal
	^PrerequisiteNotFoundSignal!

rebaseBasePackagesTo: basePathname
	"Rebase the base image packages so they are relative to basePathname. This may be used
	when an image has been saved to a new directory and one wishes to continue to reference the
	old core packages (usually held under the installatin directory). Note that basePathname
	(if not an absolute path) is treated as being relative to the installation directory NOT the
	image directory or working directory). Hence, a typical rebase can be performed using '.' as
	basePathname"

	self basePackages do: [:each | each  rebaseTo: basePathname ].
	self resetPrerequisites!

release
	"Private - Remove any event registrations the receiver has made 
	(this is not strictly necessary as the registrations are weak, but it hastens 
	the receiver's demise)."

	self class environment removeEventsTriggeredFor: self!

removePackage: aPackage
	"Remove aPackage from the receivers loaded packages. All the packages
	owned objects are removed from the system. This is only possible if no
	other packages require it for their continued operation. Answer aPackage
	or an error if other loaded packages have aPackage as a prerequisite.

	It is important with this method that we do not leave the receiver in a
	corrupt state. As a result once the removal process has started if we
	come across an error knowledge of aPackage is simply dropped which might
	result in classes/methods/globals not owned by any package.

	If aPackage is corrupt, leading to the canRemove: test raising an error
	then you can evaluate basicRemove: directly to remove aPackage."

	aPackage == self systemPackage
		ifTrue: [^self errorRemovingSystemPackage].
	self basicRemovePackage: aPackage.
	self loadedChanged.
	^aPackage.!

renamePackage: aPackage to: aStringPathname 
	"Attempts to rename aPackage held by the receiver to aStringName."

	| existing newName |
	newName := File splitStemFrom: aStringPathname.
	existing := self packageNamed: newName ifNone: [].
	(existing isNil or: [existing == aPackage]) ifFalse: [^self error: 'Package already exists'].
	(self packages)
		removeKey: aPackage name ifAbsent: [];
		at: newName put: aPackage.
	aPackage packageFileName: aStringPathname.
	self
		resetPrerequisites;
		loadedChanged!

resetPrerequisites
	"Private - Inform all packages that their prerequisites may have
	changed, and trigger the generic event announcing that to the world."

	self packages do: [:aPackage | aPackage resetPrerequisites].
	self isProcessingEvents ifTrue: [
		self trigger: #prerequisitesReset]!

resourceRepackaged: aResourceIdentifier from: source to: destination 
	"Private - Trigger resource repackaging notifications."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		trigger: #resourceRepackaged:from:to:
			withArguments: (Array 
					with: aResourceIdentifier
					with: source
					with: destination)!

setEvents: anEventsCollectionOrNil
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	events := anEventsCollectionOrNil!

sortedPackages
	"Answer a SortedCollection of the packages held by the receiver,
	ordered by name."

	^self packages asSortedCollection: Package defaultSortBlock!

sourceControl
	^self!

sourceManager
	"Answer the receiver's source manager."

	^self class sourceManager!

systemPackage
	"Private - Answer the system package held by the receiver."

	^self class systemPackage!

uninstall: aPackage 
	"Uninstall aPackage and (recursively) any packages dependent upon it, with no questions 	
	asked, deleting all its owned objects from the system.  Run its preuninstall and postuninstall 
	scripts as well."

	aPackage isInstalled ifFalse: [^self].
	aPackage okToUninstall.
	self beNotProcessingEvents.
	
	["First forcibly uninstall all the dependents - if you get a stack overflow here, it's
			probably because two or more packages are cyclically dependent."
	aPackage dependentPackages do: [:each | self uninstall: each].
	Notification signal: ('Uninstalling package <1p>' expandMacrosWith: aPackage name).
	aPackage fileInScript: #preuninstall.
	self basicUninstall: aPackage] 
			ensure: 
				[self
					beProcessingEvents;
					loadedChanged].
	aPackage fileInScript: #postuninstall!

unpackagedClasses
	^self class environment allClasses asIdentitySet difference: self allPackagedClasses asIdentitySet!

versionPackageIfRequired: aPackage 
	"If we are connected to a repository and aPackage is included in the repository then prompt to version it"

	^self!

youShouldBeProcessingEvents
	"Private - The development system is informing us that the user-interface is active, and hence we
	should expect to be responding to events as otherwise change flags, and pre-requisites, etc
	will not be operating correctly."

	| mb |
	self isProcessingEvents ifTrue: [^self].
	mb := MessageBox new.
	mb
		buttonStyle: #yesNo;
		beTaskModal.
	(mb 
		warning: 'The package system is not currently monitoring change events. This means that changes may not be detected and flagged, caches are not maintained, and pre-requisites may be incorrect. Change monitoring should normally only be suppressed during lengthy install/uninstall operations. A previous error or debugging session may have left the package manager in an inconsistent state. 

Would you like to re-enable change monitoring (recommended)?') 
			== #yes 
			ifTrue: 
				[[self isProcessingEvents] whileFalse: [self beProcessingEvents].
				self clearCachedInformation]! !

PostedActionWindow comment:
'PostedActionWindow is a private class used by <InputState> to represent the special message only window created by the VM. This window is used to synchronise with the message queue.

A queue of niladic valuable actions is maintained. When a new action is posted to this queue, a windows message is posted to the message window. When this is picked up by the message pump, it sends #preTranslateMessage:, and if the message was a posted action (and there are posted actions in the queue) then the next posted action is processed. The effect is that posted actions are processed in synchronisation with the message queue by the main UI thread. The mechanism is unlike the old deferred actions mechanism in that it will work even when a modal message loop implemented outside Dolphin is active (e.g. the menu processing loop), and that it will fire actions interspersed with windows messages in the queue on a FIFO basis, rather than processing all windows messages before processing all deferred actions.'!
!PostedActionWindow methodsFor!

asParameter
	^handle!

dispatchMessage: msgInteger wParam: wParam lParam: lParam 
	^msgInteger == WM_USER 
		ifTrue: 
			[self evaluateNextAction.
			0]!

evaluateNextAction
	"Private - Evaluate the next pending action, if any. Answer whether an action was evaluated."

	^actions nextNoWait 
		ifNil: [false]
		ifNotNil: 
			[:action | 
			action value.
			true]!

evaluatePendingActions
	"Private - Evaluate  all pending actions, if any. Answer whether any actions were evaluated."

	| activity |
	activity := false.
	[self evaluateNextAction] whileTrue: [activity := true].
	^activity!

handle: anObject
	actions := SharedQueue new.
	handle := anObject!

isPersistentView
	"Private - Answer whether the receiver has persistent state which can and should
	be persistent in the image (i.e. top-level windows which answer true
	to this will be sent #state and #state: messages by the 
	SessionManager before the image is saved, and on session startup, respectively)."

	^false!

isView
	"Private - Answer whether the receiver is a View."

	^false!

onStartup
	"Private - Ensure that the handle of the receiver is set to nil at startup."

	handle := nil!

postAction: aNiladicValuable 
	"Post the <niladicValuable> argument to the queue, to be evaluated in sync with the Windows
	message queue (after any Windows messages currently in the queue), and by the main UI
	thread."

	actions nextPut: aNiladicValuable.
	UserLibrary default 
		postMessage: handle
		msg: WM_USER
		wParam: 0
		lParam: 0!

preTranslateMessage: aMSG 
	"Private - Dispatch any posted action requests on the message loop side - we don't want to
	do this inside a callback. Also the window belongs to the VM, and messages are not
	dispatched into the image anyway."

	^aMSG message == WM_USER and: 
			[self evaluateNextAction.
			true]! !

ProcessorScheduler comment:
'The singleton instance of ProcessorScheduler (the global, Processor) manages the set of live, ready to run, processes, scheduling the interpreter in a round-robin fashion but in strict priority order.

Processor is the destination for all asynchronous interrupts from the VM, and also manages ''callbacks'' (i.e. invocations of Smalltalk code from external systems, such as the dispatching of windows messages to the window procedure). In particular the Processor ensures that processes return from callbacks in strict LIFO order so that synchronization with the native machine stack is maintained.

Asynchronous interrupts may be delivered to a process at any time including when the process is suspended, e.g. waiting on a Semaphore. The only exceptions are that any interrupts queued to terminated processes are discarded, and that interrupts will not be delivered while asynchronous events are disabled (see #(enable|disable)Interrupts). Interrupts may be sent by the VM to notify of certain conditions, such as the weak loss or finalization queues exceeding their high water marks, but they can also be used to ''inject'' code from one process into another (see Process>>#interruptWith:). A similar mechanism is used when one Process explicitly terminates another (i.e. murder rather than suicide) to inject a terminate signal which is then used to raise an exception caught by a handler at the very base of the Process entry point. This has the effect of running all unwind blocks (set up by #ifCurtailed: and #ensure:) so that a Process can shut down cleanly.

Note that much of the behaviour of the ''processor'' is actually implemented in the process subsystem of the VM. This is partly for performance reasons, and partly because primitives are atomic.

Instance Variables:
	processLists 	<Array> of <LinkedList>s of processes which are ready to run and awaiting scheduling.
	activeProcess 	The <Process> which is currently executing
	pendingReturns	<Semaphore> on which out-of-order callback exit attempts wait their turn to exit.
	comStubs		<PermanentRegistry> of currently registered COM server stub object. Used to map virtual callbacks to their destination object.
	_reserved		nil. Reserved for future use.
	pendingTerminations	<Sempahore> on which processes being terminated wait until any outstanding overlapped calls have been terminated.
		
Class Variables:
	InterruptSelectors	<Array> of <Symbol> selectors for each of the interrupt numbers sent by the VM.'!
!ProcessorScheduler class methodsFor!

initialize
	"Initialize the receiver's class variables:
		ProcessorScheduler initialize
	"

	ConstWriteSignal := Signal description: 'Attempt to update read-only object'.
	self initializeInterruptSelectors!

initializeInterruptSelectors
	InterruptSelectors := #(#terminate: #stackOverflow: #unusedInterrupt: #unusedInterrupt: #gpFault: #idlePanic: #interruptWith: #onStartup: #kill: #fpException: #userBreak: #zeroDivide: #otOverflow: #constWrite: #win32Fault: #fpStackFault: #noMemory: #hospiceOverflow: #bereavedOverflow: #unusedInterrupt:) copy!

interruptSelectors
	^InterruptSelectors!

new
	"There can be only one scheduler, and it is stored in the global variable Processor (which
	must not be reassigned!!)."

	^self shouldNotImplement!

newPriorities: highestPriority activeProcess: aProcess
	"Private - Create Processor during boot."

	^self basicNew setHighestPriority: highestPriority activeProcess: aProcess! !

!ProcessorScheduler methodsFor!

activePriority
	"Answer the priority of the current active process."

	^self activeProcess priority!

activeProcess
	"Answer the current active process."

	^activeProcess!

bereavedOverflow: interruptArg
	"Private - The VM has detected that the bereavement queue has reached
	its high water mark. Inform the memory manager."

	MemoryManager current bereavedOverflow: interruptArg.
	self enableInterrupts.
	!

callback: cookie evaluate: aNiladicBlock
	"Private - Evaluate aNiladicBlock and return the result to the VM. Should any
	attempt be made to make a far return over this context, then ensure that the
	VM stack for the callback is unwound."

	^self callback: cookie return: (aNiladicBlock ifCurtailed: [self unwindCallback: cookie])!

callback: receiver perform: aSymbol cookie: cookie
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and send the 
	Object, receiver, the unary message whose selector is aSymbol. Return the result to the 
	VM. The receiver will then resume its previously active context.
	We must trap any attempts to return over the callback (e.g. due to trapping an exception
	in an outer context) and unwind the VM stack too.
	WARNING: Do not remove or modify this method."

	^self callback: cookie return: 
		([receiver perform: aSymbol] ifCurtailed: [self unwindCallback: cookie])!

callback: receiver perform: aSymbol with: arg cookie: cookie
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and send the 
	Object, receiver, the binary message whose selector is aSymbol with the argument, arg. 
	Return the result to the VM.  The receiver will then resume its previously active context.
	We must trap any attempts to return over the callback (e.g. due to trapping an exception
	in an outer context) and unwind the VM stack too.
	WARNING: Do not remove or modify this method."

	^self callback: cookie return: 
		([receiver perform: aSymbol with: arg] ifCurtailed: [self unwindCallback: cookie])!

callback: receiver perform: aSymbol with: arg1 with: arg2 cookie: cookie
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and send the 
	Object, the keyword message whose selector is aSymbol with the arguments, arg1 and arg2.
	Return the result to the VM.  The receiver will then resume its previously active context.
	We must trap any attempts to return over the callback (e.g. due to trapping an exception
	in an outer context) and unwind the VM stack too.
	WARNING: Do not remove or modify this method."

	^self callback: cookie return: 
		([receiver perform: aSymbol with: arg1 with: arg2] 
			ifCurtailed: [self unwindCallback: cookie])!

callback: receiver perform: aSymbol with: arg1 with: arg2 with: arg3 cookie: cookie
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and send the 
	Object, the keyword message whose selector is aSymbol with the arguments, arg1, arg2 and arg3.
	Return the result to the VM.  The receiver will then resume its previously active context.
	We must trap any attempts to return over the callback (e.g. due to trapping an exception
	in an outer context) and unwind the VM stack too.
	WARNING: Do not remove or modify this method."

	^self callback: cookie return: 
		([receiver perform: aSymbol with: arg1 with: arg2 with: arg3] 
			ifCurtailed: [self unwindCallback: cookie])!

callback: receiver perform: aSymbol withArguments: anArray cookie: cookie
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and send the 
	Object, receiver, the keyword message whose selector is aSymbol with the arguments contained
	in anArray. Return the result to the VM. The receiver will resume from its active context
	before the callback.
	We must trap any attempts to return over the callback (e.g. due to trapping an exception
	in an outer context) and unwind the VM stack too.
	WARNING: Do not remove or modify this method."

	^self callback: cookie return: (
		[receiver perform: aSymbol withArguments: anArray]
			ifCurtailed: [self unwindCallback: cookie])!

callback: cookie return: result
	"Private - Return the <Object>, result, to the VM as the result of the callback identified by the 
	<integer>, cookie, which the VM passed in when it originated the callback,
	restoring the current active process to the context it was executing before the callback occurred.
	If the primitive returns nil, then we wait on the Processor's pendingCallbacks list (Semaphore).
	The primitive does not return here if the callback return succeeds.
	The VM ensures that when a callback exit succeeds pendingCallbacks has enough signals such
	that any Processes which attempted to return from callbacks out of sync since the last successful 
	callback return, will be restarted so that they can try to return again.
	This mechanism is necessary to synchronise the multiple threads in Smalltalk with the single VM
	thread. It works quite satifactorily unless a Process with an active callback lower down the VM
	stack than the pending callbacks becomes indefinitely blocked - the result is a deadlock."

	[(self primReturn: result callback: cookie) isNil] whileTrue: [
		"There is a more recent callback which has still not returned, so we must wait..."
		pendingReturns wait].
	^result	"Will not get this far unless in restarted image"!

callback: anInteger withArgumentsAt: anAddress cookie: cookie 
	"Private - Entry point from the VM. Suspend whatever the receiver is doing and evaluate
	the callback message or block with magic cookie, anInteger, whose arguments are stored in 
	the VM's stack at the address, anAddress."

	^self callback: cookie
		return: ([(ExternalCallback callback: anInteger withArgumentsAt: anAddress) asUIntPtr] 
				ifCurtailed: [self unwindCallback: cookie])!

cannotReturn: anObject
	"Private - Sent when the VM is unable to return anObject from the current active block
	because it's home method has already returned, or is homed in another process. This happens 
	when a block which contains a ^-return is stored into a variable, and is evaluated at some point
	not in the call stack above the method from which the block originated. In other
	words, blocks which are stored for parameterizing, etc, (e.g. a sort block), or used to 
	fork new processes, cannot contain ^-returns.
	N.B. If you get a walkback with this error from BlockClosure>>newProcess (the bottom
	stack frame) then it is advisable to Kill the offending process, as further walkbacks
	will occur if it is terminated normally."

	^self error: 'Cannot return ', anObject basicPrintString, ' to expired context or across Processes'!

constWrite: exceptionRecordBytes 
	"Private - The VM generated a GP Fault interrupt. The argument is the relevant 
	EXCEPTION_RECORD."

	| exceptionRecord |
	self enableInterrupts.
	exceptionRecord := EXCEPTION_RECORD fromBytes: exceptionRecordBytes.
	^self constWriteSignal signalWith: exceptionRecord!

constWriteSignal
	^ConstWriteSignal!

enableAsyncEvents: aBoolean
	"Private - Enable/disable asynchronous interrupts and semaphore signals.
	This does not prevent process switches due to synchronous process synchronisation,
	but it does prevent a process from being pre-empted due to asynchronous events.
	N.B. Do not rely on disabling async events as a means of process synchronisation
	because this facility may not be available in a future pre-emptive multi-threaded VM."

	<primitive: 95>
	^self primitiveFailed!

enableInterrupts
	"Private - Enable asynchronous interrupts and semaphore signals, and yield
	the processor in case a process switch would have occurred while async. events
	were disasbled.
	N.B. This is similar to #enableAsyncEvents:, but yields the processor if
	necessary. It is intended to be used from interrupt handlers: Since the VM
	dispatches interrupts even if it means pre-empting a higher priority process,
	we must allow that higher priority process to be rescheduled when re-enabling
	async. events. Where async. events are turned off to disable process switching
	in critical sections, the basic, #enableAsyncEvents:, message should be sent,
	since the normal process scheduling will not have been disrupted. Generally
	speaking this message need only be used in an interrupt handler."

	(self enableAsyncEvents: true)
		ifFalse: [self yield]!

forkMain
	"Private - Start a new main process."

	^self systemProcessOwner forkMain!

forkMainIfMain
	"Private - Start a new main process if executed in the context of the current
	main process. Answer whether the active process was formerly the main 
	process."

	| wasMain |
	wasMain := self isActiveMain.
	wasMain ifTrue: [self forkMain].
	^wasMain!

fpException: ieeeExceptionBytes
	"Private - The active process has caused an IEEE floating point exception, whose details
	are the argument. Raise a matching Smalltalk exception."

	| ieeeRecord |
	self enableInterrupts.
	ieeeRecord := _FPIEEE_RECORD fromBytes: ieeeExceptionBytes.
	ieeeRecord isZeroDivide
		ifTrue: [ZeroDivide dividend: ieeeRecord operand1 value]
		ifFalse: [FloatingPointException signalWith: ieeeRecord]!

fpStackFault: exceptionRecordBytes
	"Private - The VM generated an interrupt because it detected a floating point stack
	over or underflow. The argument is the relevant Win32 EXCEPTION_RECORD.
	Note that the VM will have reinitialized the floating point stack to avoid repeated
	FP stack check errors. FP stack check errors are an indication of a serious bug
	in some floating point code, the prime suspect being the reported module, 
	however it is worth bearing in mind that said module might be an innocent victim
	of the mess left by some previous user of the FP stack."

	| exceptionRecord |
	Float reset.
	self enableInterrupts.
	exceptionRecord := EXCEPTION_RECORD fromBytes: exceptionRecordBytes.
	Win32Fault signal: 'Floating point stack under/overflow' with: exceptionRecord!

genericInterrupt
	"Private - Answer the interrupt number of the generic interrupt."

	^7!

gpFault: exceptionRecordBytes
	"Private - The VM generated a GP Fault interrupt. The argument is the relevant 
	EXCEPTION_RECORD.
	Notes: 
	1) GPFs most commonly occur during an external library call - check the parameters,
	it is often possible to identify the culprit from the reported invalid address.
	2) GPFs are OFTEN recoverable (by catching the GPFault exception and handling it,
	or during development by dismissing the walkback), but be aware that the VM is likely
	to become unstable if the faulting code overwrote any Smalltalk memory. Furthermore the 
	problem will often not show up until the next GC or later.
	3) If a GP fault occurred while WRITING to memory, then the chances are that corruption 
	may have occurred and you should prepare for the worst!!"

	| exceptionRecord |
	self enableInterrupts.
	exceptionRecord := EXCEPTION_RECORD fromBytes: exceptionRecordBytes.
	GPFault signalWith: exceptionRecord
"
ExternalAddress new dwordAtOffset:0
"!

highestPriority
	"Answer the highest priority level available"

	^processLists size
!

highIOPriority
	"Answer the priority for critical I/O processes (e.g. network I/O)"

	^9!

hospiceOverflow: interruptArg 
	"Private - The VM has detected that the finalization queue has reached
	its high water mark. Inform the memory manager."

	"N.B. We don't enable interrupts, as we don't want to affect thread scheduling immediately."

	MemoryManager current hospiceOverflow: interruptArg!

idlePanic: interruptArg
	"Private - The processor has determined that there are no processes ready to run - i.e.
	it is in a state of 'idle panic'. The argument is the interrupt enable/disable status.
	We take the remedial action of starting another idle process."

	SessionManager inputState idlePanic.
	self enableInterrupts!

idleProcess
	"Private - Answer the current idle process."

	^self systemProcessOwner idler
!

interruptWith: aBlock
	"Private - Another process queued the argument aBlock for evaluation as an interrupt
	block in the context of the receiver, so evaluate it. The queuer of the block will
	not get an answer. The block is evaluated with async events disabled."

	aBlock value.
	self enableInterrupts!

iret: frameOffset list: suspendingList
	"Private - Return to the active process'  frame, at the specified 
	offset from the process base, on completion of an interrupt, restoring 
	the <List>|<Semaphore>, suspendingList, which is nil if the process 
	was active at the time of the interrupt. If a process is interrupted while
	suspended on a list, then it is re-suspended on that list when it has finished
	handling the interrupt, but note that it will be placed at the back of the list
	regardless of the position it was in when interrupted.
	Primitive failure reasons:
		0 -	the argument, frameOffset, is not a SmallInteger

	Be warned: This primitive method is not intended to be sent by user code
	it does not perform much error checking, and may cause the VM to
	terminate unexpectedly if the specified frameOffset is invalid."

	<primitive: 68>
	^self primitiveFailed!

isActiveMain
	"Answer whether or not the active process is the main GUI process."

	^activeProcess isMain!

kill: interruptArg
	"Private - The active process has been sent a kill interrupt, terminate it without running
	its unwind blocks."

	self enableInterrupts.
	activeProcess kill!

killInterrupt
	"Private - Answer the interrupt number of the Kill interrupt. The kill interrupt is used to terminate
	a Process with extreme prejudice (i.e. without giving it a change to run its unwind blocks)."

	^9!

lowIOPriority
	"Answer the priority for normal I/O processes (e.g. keyboard/mouse input)."

	^8
!

mainProcess
	"Private - Answer the current User Interface (Main) process"

	^self systemProcessOwner main
!

noMemory: interruptArg
	"Private - The VM was unable to allocate or commit some virtual memory.
	In some cases this is not fatal, and Dolphin can continue. In other cases
	the VM will have no choice but to call FatalAppExit()."

	self enableInterrupts.
	OutOfMemoryError signal!

onStartup: args 
	"Private - Interrupt sent by the VM after the image has been loaded. Interrupts are disabled.
	N.B. DO NOT REMOVE THIS METHOD OR YOUR SYSTEM WILL NOT START."

	"Any overlapped calls waiting for threads to terminate are wasting their time."
	pendingTerminations := Semaphore new.

	"Pass control to the SessionManager to start up as it wishes"
	SessionManager current onStartup: args!

otOverflow: anInteger
	"Private - The VM has allocated more memory for object headers. Inform the
	memory manager."

	MemoryManager current otOverflow: anInteger.
	"This interrupt is only ever sent to the active process, therefore no need to reschedule"
	self enableAsyncEvents: true!

pendingTerminations
	^pendingTerminations!

primReturn: anObject callback: cookie
	"Private - Return the <Object>, result, to the VM as the result of the callback identified by the 
	<integer>, cookie, which the VM passed in when it originated the callback.
	Restore the current active process to the context it was executing before the callback occurred.
	The primitive will fail (but will not set the failure result) if:
		- the current active process is not in a callback
		- the callback identified by cookied was not the last
	Answer nil in the latter case so that #callbackReturn: keeps trying to exit (assuming no deadlock,
	it will eventually succeed when its turn comes). Where the process is attempting to return from a
	non-existant callback (perhaps the image was saved down with a process in the middle of a callback)
	then answer self so that the process continues, effectively ignoring the callback return request."

	<primitive: 104>
	^activeProcess isInCallback
		ifFalse: [self]!

primUnwindCallback: cookie
	"Private - Unwind (i.e. abnormally terminate) the callback identified by the <integer>, cookie, 
	The context is unaffected (i.e. we continue to run in our caller).
	Note that this is achieved by raising a Win32 structured exception, and therefore any intervening
	frame based unwind handlers will be run.
	The primitive answers self if it 'succeeds'.
	The primitive will fail (but not set the failure reason) if:
		- the current active process is not in a callback
		- the last callback was not that identified by the cookie
	Answer nil in the latter case, so that the caller can put the active process to sleep to 
	wait its turn. In the former case, answer self to ignore the unwind request and continue."

	<primitive: 107>
	^activeProcess isInCallback
		ifFalse: [self]!

primUnwindInterrupt
	"Private - Unwind (i.e. abnormally terminate) the most recent interrupt for the current active 
	process, the context is unaffected (i.e. we continue to run in our caller).
	The primitive answers self if it 'succeeds'.
	The primitive does not fail."

	<primitive: 150>
	^self primitiveFailed!

processesAt: anInteger
	"Answer the number of processes at the specified priority level."

	^(processLists at: anInteger) size!

returnValue: anObject toFrame: frameAddress
	"Private - Return anObject to the active process'  frame at the specified 
	address (a SmallInteger - the actual address is frameAddress*2).
	The primitive does not fail.
	Be warned: This primitive method is not intended to be sent by user code
	it does not perform any error checking, and may cause the VM to
	terminate unexpectedly if the specified frameAddress is invalid."

	<primitive: 78>
	^self!

setHighestPriority: priority activeProcess: aProcess
	"Private - Construct the process lists, and set the active process to aProcess.
	Used only during bootstrap to generate the singleton instance of the
	ProcessorScheduler class - Processor"

	processLists := (1 to: priority) collect: [ :i | LinkedList new ].
	activeProcess := aProcess.
	pendingReturns := Semaphore new!

signal: aSemaphore afterMilliseconds: anInteger
	"Private - Request that the VM signal aSemaphore as soon as possible after the
	the specified millisecond delay. Cancel any existing request if aSemaphore is 
	not actuall a Semaphore (typically nil). If anInteger <= 0, then the Semaphore
	is signalled immediately.

	Primitive failure results:
		0 -	anInteger is not a SmallInteger
		2 -  anInteger was greater than the maximum Delay which can be requested.
		3 -	OS refused to set timer (try KernelLibrary>>getLastError)"

	<primitive: 100>
	^self primitiveFailed!

sleep: anInteger
	"Delay the current active process for at least anInteger milliseconds."

	(Delay forMilliseconds: anInteger) wait!

stackOverflow: interruptArg
	"Private - The active process overflowed its maximum stack. This is most commonly caused by 
	failing to terminate a recursion. The default maximum stack should be sufficient for a 
	depth of several thousand message sends, but can be increased if necessary."

	self enableAsyncEvents: true.
	StackOverflow signal!

suspendActive
	"Suspend the currently active process. A suspended process is removed from consideration
	by the scheduler (it will not be waiting on any of the Processor's lists), and will not 
	therefore be able to run until it is #resume'd."

	activeProcess suspend
!

systemBackgroundPriority
	"Answer the priority for background processes (idle time)"

	^2
!

systemBasePriority
	"Answer the lowest possible priority."

	^1!

systemProcessOwner
	"Private - Answer the object responsible for maintaining the system processes (excluding
	those which belong to the memory manager."

	^SessionManager inputState!

terminate: interruptArg
	"Private - The current active process has been sent a terminate interrupt, terminate it."

	self enableInterrupts.
	self terminateActive!

terminateActive
	"Terminate the current active process"

	activeProcess terminate!

terminateInterrupt
	"Private - Answer the interrupt number of the Terminate interrupt. The terminate interrupt can be used
	to terminate a process gracefully, even if it is not the current active process."

	^1!

timingPriority
	"Answer the priority for timing process. This must be the highest possible priority."

	^10
!

unregisterCOMStubs
	"Private - Unregister all COM object stubs."

	comStubs := nil!

unusedInterrupt: interruptArg
	"Private - The current active process has been sent an unknown interrupt, 
	raise an error."

	self enableInterrupts.
	self error: 'Unknown interrupt with ', interruptArg printString!

unwindCallback: cookie
	"Private - Unwind (i.e. abnormally terminate) the most recent callback of the current
	active process, passing the VM back the <SmallInteger> cookie which it passed in as one
	of the arguments to the entry point through which it originally called in to Smalltalk.
	The primitive method answers nil if an attempt was made to unwind
	a callback out of synchronisation with other callbacks (i.e. another Process is handling
	a more recent callback and has not yet returned/unwound it). If this happens we put
	the current active process to sleep until the VM signals the pendingCallbacks Semaphore on 
	a successful callback return or unwind, at which point this process can make another
	attempt at unwinding the callback identified by the cookie."

	[(self primUnwindCallback: cookie) isNil] whileTrue: [pendingReturns wait]!

unwindCallbacks
	"Private - Unwind the outstanding callbacks in the active process. This
	lives in ProcessorScheduler rather than Process, because callback returns
	can only be made while a Process is active."

	[activeProcess isInCallback] whileTrue: [self unwindCallback: 0]!

userBackgroundPriority
	"Answer the priority for user background processes."

	^3!

userBreak: interruptArg
	"Private - The user pressed the interrupt key combination (e.g. CTRL+BREAK)
	to interrupt the active process.	Forward to the SessionManager as the
	response will depend on the application requirements."

	self enableInterrupts.
	SessionManager current onUserBreak!

userBreakInterrupt
	"Private - Answer the interrupt number of the CTRL+BREAK interrupt."

	^11!

userInterruptPriority
	"Answer the priority for high-priority user interaction processes, such
	as window management tasks of limited duration"

	^7!

userSchedulingPriority
	"Answer the priority for normal user interation"

	^5
!

vmi: frameOffset list: suspendingList no: interruptNumber with: arg
	"Private - The VM has delivered the <integer> interrupt, interruptNumber, 
	which was queued with the <Object> argument, arg. At the time the interrupt occurred
	the process' active stack frame was at the <integer> offset, frameOffset, from the process
	base, and the process' suspendingList was the <Semaphore> suspendingList (nil if not waiting).
	N.B. The VM ensures that the current active process is the process for which the interrupt
	is intended, which may mean that a Semaphore wait is interrupted (this will be resumed on
	return from the interrupt, so there are no ill effects), or a suspended Process may be
	temporarily resumed.
	Implementation Notes:
	-	The frame is passed in as an offset, rather than a real address, because
		the process base address may not be the same on reloading a saved image, and it is possible
		to return from the interrupt in a subsequent session, e.g. when debugging a process.
	-	The VM ensures that the current active process is the process during
		whose execution the interrupt originally occurred, which may mean that a Semaphore wait 
		is interrupted (this will be resumed on return from the interrupt, so there are no side
		effects), or a suspended Process may be temporarily resumed.
	-	Async. process switches are disabled on entry to this method."

	[self perform: (InterruptSelectors basicAt: interruptNumber) with: arg]
		ifCurtailed: [self primUnwindInterrupt].
	self iret: frameOffset list: suspendingList!

win32Fault: exceptionRecordBytes
	"Private - The VM generated an unhandled Win32 Exception interrupt. The argument is the relevant 
	EXCEPTION_RECORD."

	| exceptionRecord |
	self enableInterrupts.
	exceptionRecord := EXCEPTION_RECORD fromBytes: exceptionRecordBytes.
	Win32Fault signalWith: exceptionRecord!

yield
	"Suspend the current active process, giving other processes at the same
	priority (and higher priorities of course?) a chance to run. If there are no
	other processes at the same, or higher, priority then the active process
	continues running.
	The primitive does not fail, and is much faster than the alternative
	of prodding a higher priority process to cause a rescheduling
	to occur (e.g. the timing process)."

	<primitive: 156>

	"Sleeping, for whatever duration, yields the processor."
	self sleep: 0!

zeroDivide: interruptArg
	"Private - The VM generated a Integer Divide by Zero interrupt. This will happen if any attempt is
	made to divide by zero, either in the execution of Dolphin code, in a Dolphin primitive, OR in
	an external library function."

	self enableInterrupts.
	ZeroDivide dividend: interruptArg

"
1/0
"! !

PropertyManager comment:
''!
!PropertyManager class methodsFor!

new
	"Answers an instance of the receiver; instances require initialization"

	^super new initialize! !

!PropertyManager methodsFor!

initialize
	"Private - Initialize the receiver"

	register := (WeakIdentityDictionary new) haveStrongValues; yourself.!

propertyOf: anObject at: aSymbol 
	"Answers a property value matching aSymbol for anObject"

	^self 
		propertyOf: anObject
		at: aSymbol
		ifAbsent: [anObject errorNotFound: aSymbol]!

propertyOf: anObject at: aSymbol ifAbsent: aBlock 
	"Answers a property value matching aSymbol for anObject. If no such property
	exists then aBlock will be evaluated"

	^(register at: anObject ifAbsent: [^aBlock value]) at: aSymbol ifAbsent: aBlock!

propertyOf: anObject at: aSymbol ifAbsentPut: valueOperation 
	"Answers a property value matching aSymbol for anObject. If no such property
	exists then the result of evaluating aBlock will is stored as the value of the
	property, and then answered."

	^(register at: anObject ifAbsentPut: [IdentityDictionary new]) at: aSymbol
		ifAbsentPut: valueOperation!

propertyOf: anObject at: aSymbol put: valueObject 
	"Associates a property valueObject with the property name aSymbol for anObject.
	Answer the valueObject put."

	^(register at: anObject ifAbsentPut: [IdentityDictionary new]) at: aSymbol
		put: valueObject!

removeAllPropertiesOf: anObject
	"Removes all properties for anObject"

	register removeKey: anObject ifAbsent: []
	!

removePropertyOf: anObject at: aSymbol
	"Removes a property value matching aSymbol for anObject"

	self removePropertyOf: anObject at: aSymbol ifAbsent: [anObject errorNotFound: aSymbol]
!

removePropertyOf: anObject at: aSymbol ifAbsent: aBlock
	"Removes a property value matching aSymbol for anObject. If no such property
	exists then aBlock will be evaluated"

	| propertyDict |
	propertyDict := register at: anObject ifAbsent: [^aBlock value].
	propertyDict removeKey: aSymbol ifAbsent: [^aBlock value].
	propertyDict isEmpty ifTrue: [register removeKey: anObject].
	! !

Rectangle comment:
'Instances of Rectangle represent a rectangular areas in a two dimensional Cartesian coordinate system. A Rectangle contains two Points; origin, which specifies the top left corner, and corner, which indicates the bottom right corner of the region described. 

A Rectangle is typically created by sending the method #corner: to an instance of Point, although a number of other instance creation class methods are also provided:

100@100 corner: 150@150

Rectangles inhabit the same Smalltalk standard "left-handed" coordinate system as do Points; i.e. with the y axis increasing downwards. Because of this, in a non-empty Rectangle, the origin is always expected to be above and to the left of the corner. Rectangles that are not in this normalised state can be sent the message #normalize to answer a copy that is. Many of the operation messages on Rectangles will assume that the receiver is normalised.

(150@150 corner: 100@100) normalize'!
!Rectangle class methodsFor!

center: centrePoint extent: extentPoint 
	"Answer an instance of the receiver of the extent, extentPoint, centred on centrePoint."

	^self origin: centrePoint - (extentPoint // 2) extent: extentPoint!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

left: leftNumber top: topNumber right: rightNumber bottom: bottomNumber 
	"Answer an instance of the receiver with the specified coodinates."

	^self origin: leftNumber @ topNumber corner: rightNumber @ bottomNumber!

new
	"Answer a new, empty, rectangle."

	^self origin: 0@0 corner: 0@0!

origin: originPoint corner: cornerPoint 
	"Answer a new instance of the receiver with specified origin and corner <Point>s."

	<primitive: 157>
	^(self basicNew)
		origin: originPoint corner: cornerPoint;
		yourself!

origin: originPoint extent: extentPoint 
	"Answer a new instance of the receiver with the specified origin and extent."

	^self origin: originPoint corner: originPoint + extentPoint!

vertex: aPoint1 vertex: aPoint2 
	"Answer a new, normalised, instance of the receiver with the specified diagonally opposite
	vertices."

	^self origin: (aPoint1 min: aPoint2) corner: (aPoint1 max: aPoint2)! !

!Rectangle methodsFor!

_expandRectangle: aRectangle 
	"Private - Expand the <Rectangle> argument by the magnitude of the receiver.
	Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin - origin corner: aRectangle corner + corner!

_insetRectangle: aRectangle 
	"Private - Inset the <Rectangle> argument by the magnitude of the receiver.
	Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + origin corner: aRectangle corner - corner!

_offsetRectangle: aRectangle 
	"Private - Offset the <Rectangle> argument by the magnitude of the receiver.
	Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + origin corner: aRectangle corner + corner!

= anObject 
	"Answer whether the receiver is considered equivalent to the argument
	anObject."

	"Implementation Note: We use the non-evaluating conjunction to prevent anObject being sent
	messages it might not understand."

	^self species == anObject species and: [origin = anObject origin and: [corner = anObject corner]]!

area
	"Answer the area of the receiver; the product of width and height."

	^self width * self height!

areasOutside: aRectangle 
	"Answer a <collection> of <Rectangle>s describing areas of the receiver outside the
	<Rectangle> argument."

	| areas yOrigin yCorner |
	(self intersects: aRectangle) ifFalse: [^Array with: self].
	areas := OrderedCollection new: 4.
	yOrigin := self top.
	aRectangle top > yOrigin 
		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin := aRectangle top))].
	yCorner := self bottom.
	aRectangle bottom < yCorner 
		ifTrue: [areas addLast: (self left @ (yCorner := aRectangle bottom) corner: corner)].
	aRectangle left > self left 
		ifTrue: [areas addLast: (self left @ yOrigin corner: aRectangle left @ yCorner)].
	aRectangle right < self right 
		ifTrue: [areas addLast: (aRectangle right @ yOrigin corner: self right @ yCorner)].
	^areas!

bottom
	"Answer the y coordinate of the receiver's bottom edge."

	^corner y!

bottom: aNumber 
	"Set the y-coordinate of the receiver's bottom edge."

	corner := corner x @ aNumber!

bottomAlign
	"Answers the bottom edge of the receiver. Used when paired with #bottomAlign:"

	^self bottom	!

bottomAlign: aNumber 
	"Move the receiver's bottom edge to be aligned with the specified y-coordinate. The extent
	of the receiver is maintained."

	origin := origin x @ (origin y + aNumber - corner y).
	corner := corner x @ aNumber!

bottomCenter
	"Answer a <Point> specifying the position of the centre of the bottom edge of the receiver."

	^self centerX @ self bottom!

bottomCenter: aPoint 
	"Move the receiver's bottom edge to be centered over the <Point> argument."

	self bottom: aPoint y.
	self center: aPoint x @ self centerY!

bottomLeft
	"Answer a <Point> representing the position of the receiver's bottom-left corner."

	^origin x @ corner y!

bottomLeft: aPoint 
	"Set the receiver's bottom-left corner to be at the <Point> argument. The top-right remains
	unchanged."

	origin x: aPoint x.
	corner y: aPoint y!

bottomRight
	"Answer a <Point> representing the position of the receiver's bottom-left corner. Note that
	this is the actual corner point. If it is modified, then the receiver will be affected."

	^corner!

bottomRight: aPoint 
	"Set the receiver's bottom-right corder to be the <Point> argument. The top-left remains
	unchanged."

	self corner: aPoint!

center
	"Answer a <Point> representing the position of the centre of the receiver."

	^self centerX @ self centerY!

center: aPoint 
	"Centre the receiver over the <Point> argument. The extent remains the same."

	self position: aPoint - (self extent // 2)!

centerX
	"Answer the x-coordinate of the point at the receiver's centre. Used in conjunction with
	#centerX:"

	^(self left + self right) // 2!

centerX: aNumber 
	"Centre the receiver over the specified x-coordinate. The extent remains the same"

	self center: aNumber @ self centerY!

centerY
	"Answer the y-coordinate of the point at the receiver's centre. Used in conjunction with
	#centerY:"

	^(self top + self bottom) // 2!

centerY: aNumber 
	"Centre the receiver over the specified y-coordinate. The extent remains the same"

	self center: self centerX @ aNumber!

constrain: aPoint 
	"Answer a <Point> which is the <Point> argument constrained to be within the bounds of the
	receiver."

	^(aPoint max: self origin) min: self corner - 1!

contains: aRectangle 
	"Answer whether the <Rectangle> argument is contained by the receiver (inclusive)."

	^aRectangle origin >= origin and: [aRectangle corner <= corner]!

containsPoint: aPoint 
	"Answer whether the <Point> argument is contained by the receiver. Containment is defined by
	origin point <= aPoint (inclusive), and aPoint < corner point (non-inclusive)"

	^origin <= aPoint and: [aPoint < corner]!

copy
	"Answer a copy of the receiver."

	^self class origin: self origin copy corner: self corner copy
	
	!

corner
	"Answer the <Point> at the bottom-right corner of the receiver."

	^corner!

corner: aPoint 
	"Set the position of the receiver's bottom-right corner."

	corner := aPoint!

expandBy: delta 
	"Answer a new <Rectangle> that is expanded from the receiver by the argument delta, where
	delta may be a <Rectangle>, a <Point>, or a <Number>."

	^delta _expandRectangle: self!

expandedBy: delta 
	"Present for VisualWorks compatibility. Use #expandBy: in preference."

	^self expandBy: delta!

extent
	"Answer a <Point> representing the extent of the receiver. The x-coordinate is the width and
	the y-coordinate is the height."

	^self width @ self height!

extent: aPoint 
	"Set the extent of the receiver to equal the <Point> argument. The origin remains the same and the
	corner stays in the same quadrant it was in relative to the origin point. If aPoint contains
	any negative value, the result is undefined."

	corner := origin + aPoint!

hash
	"Answer the <integer> hash value for the receiver such that for any two Rectangles which
	compare equivalent, they have the same hash value."

	^origin hash bitXor: corner hash!

height
	"Answer the height of the receiver."

	^corner y - origin y!

height: aNumber
	"Change the receiver's height to aNumber. (The origin remains the same. If aNumber
	is negative, then the result is undefined)."

	corner := corner x @ (origin y + aNumber)!

insetBy: delta 
	"Answer a new <Rectangle> that is inset from the receiver by the argument, delta, where
	delta may be a <Rectangle>, a <Point>, or a <Number>."

	^delta _insetRectangle: self!

insetCornerBy: aPoint 
	^self species origin: origin corner: corner - aPoint!

insetOriginBy: delta 
	"Answer a new <Rectangle> that is inset from the receiver by the argument, delta, where
	delta may be a <Point>, or a <Number>."

	^self species origin: origin + delta corner: corner!

insetOriginBy: originDelta cornerBy: cornerDelta 
	"Answer a <Rectangle> that is inset from the receiver by a given amounts at its origin and
	corner. The deltas may be <Number>s or <Point>s."

	^self species origin: origin + originDelta corner: corner - cornerDelta!

intersect: aRectangle 
	"Answer a new <Rectangle> representing the area in which the receiver and argument overlap.
	If the receiver and aRectangle do not overlap then the result will have negative height
	and/or width."

	^self species origin: (origin max: aRectangle origin) corner: (corner min: aRectangle corner)!

intersects: aRectangle 
	"Answer whether the receiver and argument overlap."

	^origin < aRectangle corner 
		and: [aRectangle origin < corner and: [origin < corner and: [aRectangle origin < aRectangle corner]]]!

left
	"Answer the position of the receiver's left edge."

	^origin x!

left: aNumber 
	"Sets the position of the receiver's left edge."

	origin := aNumber @ origin y!

leftAlign
	"Answers the left edge of the receiver. Used when paired with #leftAlign:"

	^self left	!

leftAlign: newLeft 
	"Move the receiver to align its left edge with the specified x-coordinate. The extent of the
	receiver is maintained."

	corner := (corner x + newLeft - origin x) @ corner y.
	origin := newLeft @ origin y!

leftCenter
	"Answer a <Point> specifying the position of the centre of the receiver's left edge."

	^self left @ self centerY!

leftCenter: aPoint 
	"Move the receiver's left edge so that it is centred over the specified <Point>."

	self left: aPoint x.
	self center: self centerX @ aPoint y!

merge: aRectangle 
	"Answer the smallest <Rectangle> that contains both the receiver and argument <Rectangle>.
	The resulting rectangle will be defined by the leftmost edge of the two left edges (from the
	two rectangles being merged), the rightmost edge, the topmost edge, and the bottommost
	edge."

	^self species origin: (origin min: aRectangle origin) corner: (corner max: aRectangle corner)!

moveBy: delta 
	"Move the receiver's origin and corner by the argument, delta, where delta can be a <Point>
	or a <Number>."

	"N.B. This is a transformation; the receiver itself is modified. You probably want to use
	#translatedBy: instead!!"

	origin := origin + delta.
	corner := corner + delta!

moveTo: aPoint 
	"Move the receiver so that its origin is at the specified <Point>."

	"N.B. This is a transformation; the receiver itself is modified."

	corner := corner + aPoint - origin.
	origin := aPoint!

normalize
	"Answer a Rectangle that is a normalized version of the receiver.
	ie. the origin is above and to the left of the corner"

	^self species vertex: origin vertex: corner
!

origin
	"Answer the <Point> at the top-left corner of the receiver."

	^origin!

origin: aPoint 
	"Sets the position of the receiver's top left corner."

	origin := aPoint!

origin: originPoint corner: cornerPoint 
	"Set the receiver's origin and corner <Point>s."

	origin := originPoint.
	corner := cornerPoint!

origin: originPoint extent: extentPoint
	"Set the receiver's origin and extent."

	origin := originPoint.
	self extent: extentPoint.!

position
	"Answers the position of the receiver's top left corner"

	^self origin!

position: aPoint 
	"Move the receiver so that its top-left corner is at the specified position."

	self origin: aPoint extent: self extent!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream 
		print: origin; 
		nextPutAll: ' corner: '; 
		print: corner!

right
	"Answer the position of the receiver's right edge."

	^corner x!

right: aNumber 
	"Sets the position of the receiver's right edge to the <Number> argument."

	corner := aNumber @ corner y!

rightAlign
	"Answers the right edge of the receiver. Used when paired with #rightAlign:"

	^self right	!

rightAlign: aNumber 
	"Move the receiver so that its right edge is aligned with the specified x-coordinate. The
	extent of the receiver is maintained."

	origin := (origin x + aNumber - corner x) @ origin y.
	corner := aNumber @ corner y!

rightCenter
	"Answer a <Point> specifying the position of the centre of the receiver's right edge."

	^self right @ self centerY!

rightCenter: aPoint 
	"Move the receiver's right edge so that it is centred over the specified <Point>."

	self right: aPoint x.
	self center: self centerX @ aPoint y!

rounded
	"Answer a new <Rectangle> whose origin and corner coordinates are the same as the
	receiver's, but rounded to the nearest <integer>."

	^self species origin: origin rounded corner: corner rounded!

scaleBy: delta 
	"Answer a new <Rectangle> representing the receiver with origin and corner multiplied by
	delta, where delta is a Point or a Number. Use the #vertex:vertex: constructor in order to
	create a normalised rectangle"

	^self species vertex: origin * delta vertex: corner * delta!

top
	"Answer the position of the receiver's top edge."

	^origin y!

top: aNumber 
	"Set the position of the receiver's top edge to the <Number> argument."

	origin := origin x @ aNumber!

topAlign
	"Answers the top edge of the receiver. Used when paired with #topAlign:"

	^self top	!

topAlign: aNumber 
	"Move the receiver so that its top edge is aligned with the specified the y-coordinate. The
	extent of the receiver is maintained."

	corner := corner x @ (corner y + aNumber - origin y).
	origin := origin x @ aNumber!

topCenter
	"Answer a <Point> specifying the position of the centre of the receiver's top edge."

	^self centerX @ origin y!

topCenter: aPoint 
	"Move the receiver's top edge so that it is centred on the specified <Point>."

	self top: aPoint y.
	self center: aPoint x @ self centerY!

topLeft
	"Answer the <Point> at the top-left corner of the receiver."

	^origin!

topLeft: aPoint 
	"Set the receiver's top-left corner to the <Point> argument. (The bottom right remains
	unchanged)."

	self origin: aPoint!

topRight
	"Answer a <Point> specifyihng the position of the receiver's top-right corner."

	^corner x @ origin y!

topRight: aPoint 
	"Set the receiver's top-right corner to aPoint. (The bottom-left remains unchanged)."

	origin y: aPoint y.
	corner x: aPoint x!

translateBy: delta 
	"Answer a new <Rectangle> representing the receiver with origin and corner incremented by
	delta, where delta is a <Point>, a <Number>, or another <Rectangle>. This is the message
	used in the IBM Red Book, but Smalltalk-80 uses #translatedBy: (which has the correct
	tense)."

	^self translatedBy: delta!

translatedBy: delta 
	"Annswer a new <Rectangle> representing the receiver with origin and corner incremented by
	delta, where delta is a <Point>, a <Number>, or another <Rectangle>."

	^delta _offsetRectangle: self!

truncated
	"Answer a new <Rectangle> whose origin and corner coordinates are the same as the
	receiver's, but truncated to the nearest <integer>."

	^self species origin: origin truncated corner: corner truncated!

width
	"Answer the width of the receiver."

	^corner x - origin x!

width: aNumber 
	"Change the receiver's width to aNumber. (The origin remains the same. If aNumber is
	negative, the result is undefined)"

	corner := (origin x + aNumber) @ corner y! !

ResourceIdentifier comment:
''!
!ResourceIdentifier class methodsFor!

allResourceIdentifiers
	| rids |
	rids:= OrderedCollection new: 1000. 
	Object withAllSubclassesDo: [:each | rids addAll: each resourceIdentifiers].
	^rids asSortedCollection
!

class: aClass 
	^self class: aClass name: 'Default view'!

class: aClass name: aString 
	"Answer a new instance of the receiver identifying a Resource with name aString
	belonging to aClass."

	^(super new)
		owningClass: aClass;
		name: aString;
		yourself!

class: aClass selector: aSymbol 
	^self class: aClass name: (self nameFromSelector: aSymbol)!

exportFileExtension
	"Answer the file extension associated with resources of this type when
	stored in files."

	^'vu'!

forMethod: aCompiledMethod 
	| thisName |
	thisName := self nameFromSelector: aCompiledMethod selector.
	thisName isNil ifTrue: [^nil].
	^self class: aCompiledMethod methodClass instanceClass name: thisName!

icon
	"Answers an Icon that can be used to represent this class"

	^(self environment at: #Icon) fromId: 'Resource.ico'!

nameFromSelector: aSymbol 
	(aSymbol beginsWith: self selectorPrefix) ifFalse: [^nil].
	^(aSymbol rightString: aSymbol size - self selectorPrefix size) copyReplacing: $_
		withObject: Character space!

onPreStripImage
	"Private -  Allow the receiver to be stripped by clearing lazy initialized class variable
	which holds an instance of the receiver."

	self allResourceIdentifiers do: [:each | each icon: nil]!

removeResource: aResourceIdentifier 
	^aResourceIdentifier owningClass class removeSelector: aResourceIdentifier selector ifAbsent: []!

selectorFromName: aString 
	| selector |
	selector := (aString copyReplacing: Character space withObject: $_) 
				select: [:each | each isAlphaNumeric or: [each = $_]].
	^('resource_' , selector) asSymbol!

selectorPrefix
	^'resource_'!

value: a value: b
	"Private - The receiver acts as the default sort block for its instances."

	^a owningClass == b owningClass
		ifTrue: [a name <= b name]
		ifFalse: [a owningClass name asString <= b owningClass name asString]
!

viewResourceCategoryName
	^'resources-views'! !

!ResourceIdentifier methodsFor!

<= aResourceIdentifier
	"Answer whether the receiver is 'less than' aResourceIdentifier.
	By implementing this method, we enable ResourceIdentifier objects to be stored
	in a SortedCollection with the default sort block."

	^(self owningClass = aResourceIdentifier owningClass) 
		ifTrue: [self name <= aResourceIdentifier name]
		ifFalse: [self owningClass <= aResourceIdentifier owningClass].!

= aResourceIdentifier
	"Answer true if aResourceIdentifier is equal to (represents the same resource as) the receiver."

	^self species == aResourceIdentifier species and: [ 
		self owningClass == aResourceIdentifier owningClass and: [
			self name = aResourceIdentifier name]]!

canShow
	^self resourceOrNil notNil and: [self owningClass respondsTo: #show:]!

compiledMethod
	^self owningClass class compiledMethodAt: self selector ifAbsent: []!

copy
	"Answer a new instance like the receiver."

	^self class class: owningClass name: self name!

editExpression
	"Private - Answer a String that can be evaluated to edit an emitted resource"

	^'ViewComposer openOn: (ResourceIdentifier class: self selector: <1p>)' expandMacrosWith: self selector!

emit: aResourceArray asStringOn: aWriteStream 
	aWriteStream nextPutAll: '#('.
	aResourceArray do: [:each |  each literalPrintOn: aWriteStream. aWriteStream space].
	aWriteStream nextPut: $)!

emitMethodHeaderFor: aSymbol on: stream 
	stream
		nextPutAll: aSymbol;
		cr;
		nextPutAll: (self resourceMethodComment expandMacrosWith: self name with: self editExpression);
		cr;
		cr!

exists
	^(self owningClass class includesSelector: self selector)!

exportedFileName
	"Private - Answer the receiver's default file name for file outs."

	| package path |
	package := self owningPackage.
	path := package isNil ifTrue: [''] ifFalse: [package path].
	^File 
		composePath: path
		stem: self displayString
		extension: self class exportFileExtension!

hash
	"Answer the SmallInteger hash value for the receiver."

	^owningClass hash bitXor: self name hash!

hiddenObjects
	"Private - Answers a <collection> of the <Object>s that are contained in the receiver's resource
	Implementation note. This is not particularly fast since it loads the resource
	classes it needs into the image. View resources will not be realized as windows however."

	| stlInFilerClass |
	stlInFilerClass := Smalltalk at: #STLInFiler.
	^(stlInFilerClass on: self resource readStream)
		basicNext;
		readMap!

icon	
	^self propertyAt: #_icon ifAbsent: [self fixupIcon]!

icon: anIcon
	anIcon isNil ifTrue: [self removePropertyAt: #icon ifAbsent: []] ifFalse: [self propertyAt: #_icon put: anIcon]!

isChanged
	^false!

isChanged: aBoolean 
	self shouldNotImplement!

load
	"Load and answer the resource represented by the receiver."

	^self shouldNotImplement!

name
	"Answer the name of the resource represented by the receiver."

	selector isNil ifTrue: [^nil].
	selector class == String ifTrue: [self name: selector].
	^self class nameFromSelector: selector!

name: aStringOrNil 
	"Set the name of the resource represented by the receiver."

	aStringOrNil isNil 
		ifTrue: 
			[selector := nil.
			^self].
	selector := self class selectorFromName: aStringOrNil!

owningClass
	"Answer the class that owns the resource represented by the receiver."

	^owningClass!

owningClass: aClass
	"Set the class that owns the resource represented by the receiver."

	owningClass := aClass!

owningPackage
	^(self compiledMethod ifNil: [self owningClass]) owningPackage!

owningPackage: aPackage 
	"Set the receiver's <Package> to be the argument. Any current package association is lost."

	self compiledMethod owningPackage: aPackage!

printOn: aStream 
	"Append, to aStream, a String whose characters are a description of the receiver as a developer
	would want to see it."

	owningClass printOn: aStream.
	aStream nextPut: $..
	(self name notNil ifTrue: [self name] ifFalse: ['untitled']) displayOn: aStream!

resource
	"Answer the literal resource data represented by the receiver. "

	(self owningClass respondsTo: selector) ifFalse: [^nil].
	^self owningClass perform: self selector!

resourceMethodComment
	^'	"Answer the literal data from which the ''<1s>'' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	<2s>
	"'!

resourceOrNil
	"Answer the resource represented by the receiver or nil if none exists"

	(self owningClass class includesSelector: self selector) ifFalse: [^nil].
	^self resource!

selector
	^self class selectorFromName: self name!

show
	"Display the resource identified by the receiver in whatever way is appropriate. 
	Answer the <Presenter> opended to display it."

	^self owningClass show: self name.
!

storeOn: aStream
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	aStream
		nextPut: $(;
		print: self class;
		nextPutAll: ' class: ';
		print: self owningClass;
		nextPutAll: ' name: ';
		print: self name;
		nextPut: $)! !

SearchPolicy comment:
'SearchPolicy is for configuring pluggable collections and models to use different searching policies, e.g. equality vs. identity. SearchPolicy itself implements an equality based policy using #= and #hash, etc.

SearchPolicy is the canonical implementation of the <searchPolicy> and <comparisonPolicy> protocols (the latter is really a subset of the former).

The <comparisonPolicy> protocol can be used to compare two objects in order to determine if they are the "same". Different comparison policies can be employed which, for example, consider that two objects are the same iff they are the exact same identical object (i.e. ''''obj1 == obj2'''' is true), or on the other hand if they are of equal value (i.e. ''''obj1 = obj2'''' is true).

SearchPolicy maintains a number of prebuilt instances which implement popular search/comparison policies. These are accessible via class side methods in the ''''instance creation'''' category.

Class Variables:
	Always		<AlwaysSearchPolicy>. Maintains that two objects are always equal.
	Identity		<IdentitySearchPolicy>. Singleton instance for identity searching.
	Equality		<SearchPolicy>. Singleton instance for equality searching.
	Never		<NeverSearchPolicy>. Maintains that two objects are never equal.

'!
!SearchPolicy class methodsFor!

always
	"Answers the singleton instance of the receiver that always answers 
	true to #compare:with: (i.e. under this comparison policy two objects 
	are always considered equal)."

	Always isNil ifTrue: [Always := AlwaysSearchPolicy new].
	^Always!

caseInsensitive
	"Answer the singleton sub-instance of the receiver which supports a search policy
	based on case-insensitive string comparisons."

	CaseInsensitive isNil ifTrue: [CaseInsensitive := CaseInsensitiveSearchPolicy new].
	^CaseInsensitive
!

equality
	"Answer the singleton sub-instance of the receiver which supports a search policy
	based on equality."

	Equality isNil ifTrue: [Equality := EqualitySearchPolicy new].
	^Equality
!

identity
	"Answer the singleton sub-instance of the receiver which supports a search policy
	based on identity."

	Identity isNil ifTrue: [Identity := IdentitySearchPolicy new].
	^Identity!

never
	"Answers the singleton instance of the receiver that always answers 
	false to #compare:with: (i.e. under this comparison policy two objects 
	are never considered equal)."

	Never isNil ifTrue: [Never := NeverSearchPolicy new].
	^Never!

onPreStripImage
	"Private - Tidy up the receiver's lazily initialized class vars in preparation for image stripping."

	self uninitialize!

uninitialize
	"Private - Tidy up the receiver in preparation for removal from the system."

	Always := Never := CaseInsensitive := Equality := Identity := nil! !

!SearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^self subclassResponsibility
!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy."

	^operand hash!

hash: operand max: maximum
	"Answer a suitable hash value for the <Object>, operand, under this search policy, 
	between 1 and the <integer>, maximum. If maximum is a significant proportion
	of the range of hash values generated, then the result should be scaled to distribute
	evenly between 1 and maximum in order to avoid generating excessive collisions at
	the low end of the range."

	^(self hash: operand) \\ maximum + 1!

keyAtValue: value in: collection ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value in the keyed
	collection, collection, using the receiver's search policy. If there is no such 
	value, answer the result of evaluating the <niladicValuable>, operation."

	collection keysAndValuesDo: [:k :v | (self compare: v with: value) ifTrue: [^k]].
	^operation value!

newLookupTable
	"Answer a new <LookupTable> with a search policy equivalent to the receiver."

	^PluggableLookupTable searchPolicy: self!

nextIndexOf: anElement in: sequence from: start to: stop
	"Answer the index of the next occurrence of anElement in the <sequencedReadableCollection>
	argument,  collection, between startIndex and stopIndex inclusive. If there are no such occurrences, 
	answer 0."

	sequence from: start to: stop keysAndValuesDo: [:i :elem | (self compare: elem with: anElement) ifTrue: [^i]].
	^0! !

SessionManager comment:
'SessionManager is the class of objects responsible for managing the lifecyle of an application, from startup to shutdown. SessionManagers are also responsible for determining the global policy for dealing with unhandled Exceptions. 

SessionManager itself is abstract, with two further abstract subclasses that divide applications into two groups: <ConsoleSessionManager> whose subclasses implement Console (that is, command line, DOS style) applications, and <GUISessionManager> whose subclasses implement GUI (that is, Windows) applications.

When you come to deploy an application, you will probably need to write a SessionManager for it, although it is possible to do without (see the ADK documentation). In the case of a console application you should subclass <ConsoleSessionManager>, and in the case of a GUI application you should typically subclass <RuntimeSessionManager>. To get going it is only necessary to implement a #main method which either implements the main body of the application (in the case of simple console apps), or which invokes it by creating an instance of some other class, passing it appropriate arguments drawn from the #argv collection which is a collection of the components that formed the original command which started the application.

Instance Variables:
	inputState		<InputState>. Implements the Windows message loop (even console apps have one in Dolphin).
	resourceLibrary	<ExternalResourceLibrary>. Default library containing application resources.
	resourceManager	<ResourceManager>. Manager for Dolphin resources, such as views.
	imagePath		<String>. Path from which the image was loaded (path of the .EXE if a deployed app)
	servers		<SharedIdentitySet>. Running "servers" e.g. OLE servers, which need the session to stay up.
	argv		<Array> of <String>. Command line arguments in the normal C arrangement (first is .EXE name)
	cmdLineFlags	<Set> of <String>. Command line arguments prefixed with - or /.
	state		<SmallInteger>. Current stage of sessions life. Mostly relevant during startup and shutdown.
	sentry		<ExternalHandle>. Handle of Win32 named Semaphore which indicates running instance of image.
	startupArgs	<Array>. Raw startup arguments passed in by the VM.
	consoleHandler	<MessageCallback>. Handler for Win32 console control message callback.
	stdin		<StdioFileStream>. Standard input stream.
	stdout		<StdioFileStream>. Standard output stream.
	stderr		<StdioFileStream>. Standard error stream.

Class Variables:
	PreStartFile	<String>. Name of the file-in fairly early in startup to effect repairs, etc.
	Current		<SessionManager>. Singleton instance, being the current session manager.

'!
!SessionManager class methodsFor!

asSessionManagerClass
	^self!

current
	"Answer the singleton instance of the receiver"

	^Current!

current: aSessionManager
	"Assign the current SessionManager instance (which will be a subinstance).
	In order to preserve the triggers hanging off the old SessionManager, we
	use a #become:, we also copy across any existing input state so that
	the system continues to run."

	Current isNil
		ifTrue: [Current := aSessionManager. Current initialize]
		ifFalse: [
			aSessionManager
				inputState: Current inputState;
				initialize.
			Current become: aSessionManager]!

imageExtension
	"Answer the suffix for an executable image file"

	^'exe'!

initialize
	"Private - Initialize the class variables of the receiver."

	Current 
		ifNil: 
			[PreStartFile := 'prestart.st'.
			Current := BootSessionManager basicNew.	"For boot reasons, do not initialize"
			Current imagePath: '.\Dolphin']!

inputState
	"Answer the InputState of the current session manager."

	^self current inputState!

installNew
	"Install a new instance of the receiver as the current SessionManager.
	Answer the PREVIOUS SessionManager."

	^self asSessionManagerClass basicNew install!

isConsoleApplication
	"Answer whether the sessions managed by instances of the receiver are for a console application 
	(as opposed to a GUI application, which is a completely separate thing under Windows).
	Implementation Note: This isn't really a console application, but the test is slightly misnamed
	since it really means is this not a GUI application."

	^true!

isDLL
	"Private - Answer whether the receiver is a shared library, as opposed to an application."

	^false!

isRuntime
	"Answer whether the sessions managed by instances of the receiver are for a run-time applications 
	(as opposed to development, or abstract)."

	^false	"This is abstract"!

new
	"The receiver is a singleton class (in general) so this is not a permitted operation
	(see however #installNew)."

	^self shouldNotImplement!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Current class==self ifTrue: [Current := nil]! !

!SessionManager methodsFor!

allocConsole
	"Private - Open a console window for this session."

	KernelLibrary default allocConsole
!

allowDuplicate
	"It would appear that the image associated with this session is already open. Take action
	appropriate to the policies of the receiver. Answer whether to continue the session.
	The default is to carry on brazenly."

	^true

!

appIdString
	"Answer a unique string name for the receiver - this does not need to be human readable, as
	it is used to uniquely identify the application in common registry locations, etc. For
	example it is used to form the unique name for suppressible message boxes. A good choice
	would be the numeric characters of the session manager class' GUID, but note that class
	GUIDs are stripped on deployment by default."

	^self applicationName!

applicationName
	"Answer the application name. Use the applications executable name."

	^self argc > 0
		ifTrue: [File splitStemFrom: self argv first]
		ifFalse: ['Application']!

applicationShortName
	"Answer the abbreviated application name."

	^self applicationName!

argc
	"Answer the number of the command line arguments."

	^self argv size!

argv
	"Answer an array of Strings containing the command line arguments."

	argv isNil 
		ifTrue: 
			[| lib pArray |
			lib := CRTLibrary default.
			pArray := lib argv.
			argv := (0 to: (lib argc - 1) * VMConstants.IntPtrSize by: VMConstants.IntPtrSize) 
						collect: [:offset | String fromAddress: (pArray dwordAtOffset: offset)]].
	^argv!

argvLegacyOptionsRemoved
	"Private - Answer the argv arguments vertor with the old style legacy options removed"

	^self argv reject: 
			[:each | 
			| opt |
			opt := each allButFirst asLowercase.
			opt = 'nosplash' or: [opt = 'embedding']]!

backupOnImageSave
	"Answer whether the image should be backed up (i.e. the old .img file is renamed to .bak when the new .img
	file is successfully written). Note that this will slow down the operation quite a bit, as the OS has to do a lot
	more juggling."

	^false!

basicPrimaryStartup
	"Perform critical startup operations which initialize the basic
	services in the image such as the process system. These startup activities
	should be kept to a minimal set, as there is no opportunity to repair any
	damage until these are completed, so if they fail, you've had it."

	VMLibrary default onStartup.	"The VMLibrary must be initialized before we do anything else."
	self openLibraries.	"Now we can open the permanent libraries"
	self imagePath: imagePath.	"Split off the extension now can use lib functions."
	ExternalCallback onStartup.	"Old callbacks will be invalid"
	self createInputState.	"Register input semaphore, etc, kill previous idler in case on a different host OS"
	self class environment at: #Delay ifPresent: [:d | d onStartup].	"Reschedule delays etc."
	MemoryManager current onStartup	"Start (if necessary) finalization/bereavement processing, etc"!

basicSecondaryStartup
	"Perform secondary startup operations which initialize non-critical
	basic services in the image, such as the dates and times, and also initialize
	the message loop handler (we have a basic message loop even in a console 
	app)."

	Float onStartup.
	self class environment at: #Locale ifPresent: [:d | d onStartup]!

basicShutdown
	"Private - Perform basic system shutdown operations, just prior to the VM putting
	out the lights."

	self closeConsole.
	self comShutdown.
	self class environment at: #Delay ifPresent: [:d | d onExit].
	inputState onExit.
	ExternalLibrary onExit.
	KernelLibrary default closeHandle: sentry
!

basicStdioStreams
	"Private - Answer the 3-element <Array> of <StdioFileStream>s which are the 
	CRT stdin, stdout, and stderr streams, or nil if not opened yet."

	^stdioStreams!

basicTertiaryStartup
	"Perform tertiary system startup operations."

	^self subclassResponsibility!

clearSessionState
	"Clear any state saved down for a image save which is will not be required until that saved image is
	rehydrated."

	"By default, assume there is no extra state to save, and do nothing."!

closeConsole
	"Disconnect from and close any open console, including the standard input and output
	streams."

	self 
		closeConsoleStreams;
		unregisterConsoleCtrlHandler;
		freeConsole
!

closeConsoleStreams
	"Private - Close the standard console I/O streams."
	
	stdioStreams isNil ifTrue: [^self].
	1 to: 3
		do: 
			[:i | 
			| stm |
			(stm := stdioStreams at: i) notNil ifTrue: [stm close]].
	stdioStreams := nil!

closeEventLog
	"Private - Close the NT event log, if open."

	eventLogHandle notNil ifTrue: [
		AdvApiLibrary default deregisterEventSource: eventLogHandle.
		eventLogHandle := nil]!

cmdLineFlags
	"Private - Answer the Set of flags specified on the command line. Currently this is rather
	simplistic, since it doesn't handle parameters with an argument, if the argument is
	separated from the parameter name by whitespace. The VM can't handle these anyway, as it
	knows nothing about the potential parameters, and so treats the first argument which does
	not beging with $/ or $- as the name of the image file. So, currently, parameters with
	arguments must be specified without any whitespace between the parameter name and the
	parameter value."

	cmdLineFlags isNil 
		ifTrue: 
			[cmdLineFlags := Set new.
			self argv 
				do: [:each | (each notEmpty and: ['/-' includes: each first]) ifTrue: [cmdLineFlags add: (each copyFrom: 2)]]].
	^cmdLineFlags!

computerName
	"Answer the name of the computer hosting the current session. 
	Signals an exception if the request fails."

	| name nameSize |
	name := String new: MAX_COMPUTERNAME_LENGTH.
	nameSize := DWORD fromInteger: name size+1.
	(KernelLibrary default getComputerName: name nSize: nameSize asParameter)
		ifFalse: [KernelLibrary default systemError].
	^name leftString: nameSize asInteger!

comShutdown
	"Private - The system is about to shut down, so clear up any COM hangers on.
	Note: This used to be done by hanging of the shutdown trigger, but with the
	advent of control hosting there are sequencing issues, in particular it is important
	that the window system be closed before any COM object stubs in the receiver
	are destroyed. As the COM package may not be loaded, we can't use a hard
	reference to <COMInterface>"

	self outer notNull ifTrue: [self outer free].
	Smalltalk at: #COMInterface ifPresent: [:c | c onExit]!

createInputState
	inputState := self inputStateClass newFromOld: inputState!

createSentinel
	sentry := KernelLibrary default 
				createMutex: nil
				bInitialOwner: false
				lpName: self sentinelName.
	^KernelLibrary default getLastError == ERROR_ALREADY_EXISTS!

defaultResLibPath
	"Answer the path of the development resource library."

	^'DolphinDR7'!

defaultResourceLibrary
	"Private - Answer the ExternalResourceLibrary containing the Dolphin 
	development system resources."

	resourceLibrary isNil 
		ifTrue: 
			[resourceLibrary := ExternalResourceLibrary 
						open: self defaultResLibPath
						withAliases: #('dolphindr7' 'dolphindr006' 'dolphindr005' 'dolphindr004' 'dolphindevres' 'dolphindr993')
						flags: 0].
	^resourceLibrary!

embeddedStartup
	"Private - The session has been started as an embedded session, perform appropriate
	actions."

	#todo "This is necessary because of dum GC strategy - we need to wake up to ensure it happens".
	[[Processor sleep: 1000] repeat] forkAt: Processor systemBackgroundPriority
			
			!

errorLogExtension
	"Answer the suffix for an error log file"

	^'errors'!

errorLogName
	"Answer the name of the error log file used to record error information (e.g. unhandled exceptions)."

	^File default: self imagePath extension: self errorLogExtension!

eventLogSource
	"Answer the 'source' that should be passed to the ReportEvent() API when logging events
	to the NT event log. This name will appear as the source of the event in the NT event
	viewer."

	^self applicationName!

exit
	"Request to close down the session (user may cancel)."

	self exit: 0!

exit: anInteger
	"Request to close down the session with the specified exit code (user may cancel)."

	self inputState postQuit: anInteger!

forkMain
	"Start a new main process appropriate for the session.
	Override this to fork a specific main process. The default is to fork
	the standard message loop executing main process via the input state.
	We also defer an action to be processed by that UI process that acks
	the receiver that the UI loop has started."

	self inputState queueDeferredAction: [self mainLoopStarted].
	inputState forkMain!

free
	"Free up any artifacts belonging to relevant to the current Session."

	^self!

freeConsole
	"Private - Close (actually detach from) the console for this session.
		SessionManager current freeConsole
	"

	KernelLibrary default freeConsole!

getCommandLine
	"Private - Answer the command line String used to start Dolphin."

	^KernelLibrary default getCommandLine!

getenv: aString
	"Answer the value of the specified environment variable, or nil if it does not exist.
	N.B. Size answered includes null terminator IF not enough space (or nil buffer)."

	| buf size |
	"N.B. Size answered includes null terminator IF not enough space (or nil buffer)."
	size := KernelLibrary default getEnvironmentVariable: aString lpBuffer: nil nSize: 0.
	size == 0 ifTrue: [^nil].
	buf := String new: size-1.	"Dolphin Strings alloc. extra space for null terminator"
	KernelLibrary default getEnvironmentVariable: aString lpBuffer: buf nSize: size.
	^buf
	!

hasActiveServers
	"Private - Answer whether there are any servers still registered in this
	session."

	^self servers notEmpty!

imageBase
	"Answer the base directory in which the image resides"

	^File splitPathFrom: self imagePath!

imageExtension
	"Private - Answer the suffix for an executable image file"

	^self class imageExtension!

imageFileName
	"Answer the file name of the current image."

	^File default: self imagePath extension: self imageExtension!

imagePath
	"Answer the base file path on which the image, source and changes
	file names are based. An example might be: c:\Program Files\Dolphin\Dolphin."

	^imagePath!

imagePath: aPathString 
	"Private - used only after loading an image to set up path to the image and sources."

	imagePath := File removeExtension: (File fullPathOf: aPathString)!

imageVersion
	"Answer a String in the form N.N.N.N which specifies the version number of the image."

	| ms ls |
	ms := self imageVersionMajor.
	ls := self imageVersionMinor.
	^'<1d>.<2d>.<3d>.<4d>' 
		expandMacrosWith: ms highWord
		with: ms lowWord
		with: ls highWord
		with: ls lowWord!

imageVersionMajor
	"Answer the major component of the images version Integer."

	^VMLibrary default registryAt: #ImageVersionMajor!

imageVersionMinor
	"Answer the minor component of the images version Integer."

	^VMLibrary default registryAt: #ImageVersionMinor!

initialize
	"Private - Initialize the receiver after installation as the current SessionManager.
	Answer the receiver."

	state := 6.
	servers := SharedIdentitySet new.
	imagePath := '.\Dolphin'.
	^self!

initializeFromSessionManager: oldSessionManager
	"Private - The receiver has taken take over as the current session
	manager from oldSessionManager. This is an opportunity to transfer
	state information from the replaced manager."

	imagePath := oldSessionManager imagePath.
	stdioStreams := oldSessionManager basicStdioStreams.
	startupArgs := oldSessionManager startupArgs.
	^self!

inputState
	"Answer the receiver's <InputState>, lazily creating it if necessary."

	^inputState!

inputState: anInputState 
	"Private - Set the receiver's InputState.
	WARNING: Do this very carefully, or the system will crash."

	inputState := anInputState!

inputStateClass
	^InputState!

install
	SessionManager current retire.
	SessionManager current: self.
	^SessionManager current initializeFromSessionManager: self!

installationDirectory
	"Private - Answer the <readableString> path name of the directory in which this
	application is installed.
		SessionManager current installationDirectory.
	Application specific subclasses can override this to answer a directory read from
	a registry key (for example), or whatever is appropriate. The default is derived
	from the path of the loaded image."

	^self imageBase

	!

isBinaryLooseMethodInstallationAllowed
	"Private - Answer true if loose method can be installed into the image by a BinaryPackage"

	^true!

isConsoleApplication
	"Answer whether the session is for a console application (as opposed to a GUI application)."

	^self class isConsoleApplication!

isDLL
	"Private - Answer whether the receiver is a shared library, as opposed to an application."

	^self class isDLL!

isEmbedded
	"Answer whether the session is running, or should be started, in 'embedded' 
	mode (i.e. headless)."

	^self isDLL or: [self isEmbedding]!

isEmbedding
	"Answer whether the session was started with a headless flag"

	^self cmdLineFlags includes: 'Embedding'!

isHeadless
	"Private - Answer whether the session is _currently_ headless. This is most likely if the
	image was started a headkess-h flag, and no visible windows have subsequently been
	opened."

	^self inputState hasVisibleWindows not!

isOAD
	"Private - Is this an Object Arts Development image?"

	^false!

isRuntime
	"Answer whether this is a run-time session (i.e. running an application rather than the development
	system."

	^self class isRuntime!

keepAlive
	"The inputState has determined that there are no live windows.
	By default we therefore shutdown if not acting as an embedded server.

	This can be overridden by derived classes that want to employ
	a different policy for deciding when to shut down."

	(self isEmbedded and: [self hasActiveServers])
		ifFalse: [self quit]!

logComment: aString
	"Ignore the comment string."

!

logError: anException
	"Append details about the unhandled exception, anException, to the session error log.
	Ignored for runtime systems, but it is suggested that subclasses perform some appropriate
	form of error logging. Here we are using the VM's dump facility to append a short
	but informative log each time an error occurs, to <app name>.ERRORS."

	VMLibrary default dump: anException description path: nil stackDepth: 0 walkbackDepth: -1!

logErrorEvent: message
	"Write a EVENTLOG_ERROR_TYPE entry to the system event log. Only available on NT/Win2K."

	self logEvent: message type: EVENTLOG_ERROR_TYPE!

logEvent: message type: typeCode
	"Write an entry to the system event log. Only available on NT/Win2K."

	| inserts app |
	eventLogHandle isNil ifTrue: [
		self openEventLog.
		eventLogHandle isNil ifTrue: ["Event log not available" ^self]].

	inserts := DWORDArray new: 2.
	app := self applicationName.
	inserts at: 1 put: app yourAddress.
	inserts at: 2 put: message yourAddress.

	(AdvApiLibrary default reportEvent: eventLogHandle wType: typeCode wCategory: 0 dwEventId: 1
			lpUserSid: nil wNumStrings: 2 dwDataSize: 0 lpStrings: inserts lpRawData: nil)
		ifFalse: [Win32Error signal]!

logInformationEvent: message
	"Write a EVENTLOG_INFORMATION_TYPE entry to the system event log. Only available on NT/Win2K."

	self logEvent: message type: EVENTLOG_INFORMATION_TYPE!

logSuccessEvent: message
	"Write a EVENTLOG_SUCCESS entry to the system event log. Only available on NT/Win2K."

	self logEvent: message type: EVENTLOG_SUCCESS!

logWarningEvent: message
	"Write a EVENTLOG_WARNING_TYPE entry to the system event log. Only available on NT/Win2K."

	self logEvent: message type: EVENTLOG_WARNING_TYPE!

main
	"Start the application associated with this run-time session. 
	This is the point to open the main application window, etc. It is called from the
	main UI process after the system startup has completed. See, for example,
	NotepadSessionManager that accompanies the Notepad sample."

	"N.B. There is no need to supersend this, it is a hook designed purely for app. use"!

mainLoopStarted
	"Private - The main UI loop has started, from which this message was sent.
	Enter the fifth age (maturity), and be 'In fair round belly with good capon lined.
	This is an appropriate time to fire up the application."

	state := 5.
	self main!

noVisibleWindows
	"Private - The inputState has determined that there are no live windows.
	If we have entered the fifth age (up and running), but not progressed
	into the sixth age, then send out a keepAlive heartbeat."

	state == 5 	"Full of wise saws and modern instances?"
		ifTrue: [self keepAlive]
!

onCloseConsole
	"The user is attempting to close the console window. Act accordingly."

	self exit: 0!

onConsoleCtrl: dwCtrlType
	"Private - Private  - Handle a console control event.
	If you set a breakpoint in here, don't terminate the process or it will exit
	the Dolphin image when 0 (false) is returned and NT invokes the default
	handler."

	dwCtrlType < CTRL_CLOSE_EVENT
		ifTrue: [self inputState queueDeferredAction: [self onUserBreak]]
		ifFalse: [
			dwCtrlType = CTRL_CLOSE_EVENT
				ifTrue: [self onCloseConsole]
				ifFalse: [self inputState postQuit: dwCtrlType]].
	^true!

onExit
	"Perform pre-termination actions.
	Note that it is too late to stop session termination now (at least in the design
	of the DevelopmentSessionManager)."

	state := 6.		"Into the lean and slippered pantaloon"

	self trigger: #sessionStopped.
	self shutdown.
	^true	"We don't allow cancel, but a subclass could answer false if it wanted"!

onPostSaveImage
	"Private - Perform post-image save actions"

	self clearSessionState.
	self trigger: #imageSaveCompleted!

onPreSaveImage
	"Private - Perform pre-image save actions"

	self trigger: #imageSaveStarting.
	self saveSessionState.
	
	"These could be done with triggers, but they are critical to system operation
	and will always be required. In addition, the Delay pre-save operation should
	be done as close as possible to the actual save so that it is able to record
	the correct milliscond clock value for rescheduling delays on restart."
	MemoryManager current onPreSaveImage.
	self class environment at: #Delay ifPresent: [:d | d onPreSaveImage].

!

onQueryWindowsShutdown
	"The Windows operating system is shutting down. Shut down the image without saving."

	self quit: 0!

onQuit: anInteger 
	"Handle a request to exit - the argument is the exit code.
	This message is normally sent from the InputState message pump.
	The request may be aborted if #queryEndSession: answers false."

	self trigger: #quitSessionRequested.
	self queryEndSession ifTrue: [self quit: anInteger]!

onStartup: args
	"Initialize the receiver immediately following system startup.
	This is the main system initialization routine, and is responsible
	for starting the windowing system, the process system, etc.
	WARNING: If you break the early startup process (especially before prestart.st)
	then you will not be able to load your image. It is recommended, therefore, that
	if changing startup code, you should attempt to run up a new copy of the image
	just saved BEFORE closing down. Walkbacks will work at just about any stage,
	but other windows will not open if View>>onStartup has not been run."

	state := 0.
	eventLogHandle := stdioStreams := consoleHandler := nil.

	"Save away the Array of startup arguments, passed in by the VM, for later use"
	startupArgs := args.
	imagePath := args class == Array ifTrue: [args first] ifFalse: [args].
	cmdLineFlags := argv := nil.

	[self primaryStartup.
	state := 1.		"Mewling and puking in the nurse's arms"

	"Before the secondary startup, lets have an opportunity of getting
	in and fixing and possible problems with the image (only required in Development?)"
	self preStart.
	self secondaryStartup.
	state := 2.		"The whining schoolboy with shining morning face"

	"We are now in a position to claim ownership of the image file, if relevant."
	self registerRunning.

	"Trigger any user startup processing"
	[self trigger: #sessionStarted] ensure: [self tertiaryStartup].
	state := 3	"The Lover sighing like furnace"] 
			ensure: 
				["Always attempt to start the main process (must place into state 5)
		 even if earlier startup failed. This may help recover a damaged
		 development image if the startup has progressed sufficiently far."
		self forkMain.
				state := 4	"Full of strange oaths and bearded like the pard"].

	"We must terminate the active process to prevent it from continuing from where it left
	off when the image was saved and running onExit processing, or whatever it would have
	done next. We also kill it to prevent any invalid termination running."
	Processor activeProcess kill!

onUnhandledError: anError
	"The unhandled Error, anError, occurred in the active Process.
	Perform whatever default processing is appropriate for the application."

	^self unhandledException: anError!

onUnhandledNotification: aNotification
	"The unhandled Notification, aNotification, occurred in the active Process.
	Display the notification description on the Transcript (or other trace device)."

	aNotification toTrace.
	"aNotification printTraceOn: Transcript."		"Use this to get more detail about where it came from."
	^nil!

onUnhandledWarning: aWarning
	"The unhandled Warning, aWarning, occurred in the active Process.
	Depending on the user response, either resume or terminate the process."

	^self unhandledException: aWarning!

onUserBreak
	"Private - The user interrupted the currect active process by pressing the
	interrupt key combination (usually CTRL+BREAK). Take appropriate action
	according to the session requirements."

	self inputState userInterruptSignal signal
!

openConsole
	"Open and a console for this session and connect standard input and output streams.
	Answer whether the console was open already."

	| wasOpen |
	wasOpen := consoleHandler notNil.
	self 
		allocConsole;
		registerConsoleCtrlHandler;
		openConsoleStreams.
	^wasOpen!

openConsoleStreams
	"Private - Open the standard console I/O streams."

	^self subclassResponsibility!

openEventLog
	"Private - Open the NT event log for writing, and answer a handle onto it that can be passed to the
	ReportEvent() API."

	OSVERSIONINFO current isNT 
		ifTrue: 
			[eventLogHandle := VMLibrary default 
						registerEventSource: self eventLogSource].
	^eventLogHandle!

openLibraries
	"Private - Open the base set of external libraries (ExternalLibrary>>onStartup must
	open the PermanentLibraries)."

	ExternalLibrary onStartup!

outer
	"Answer the 'outer' value which was passed by the .EXE which started up the image.
	Often this will be an IUnknown pointer, but as far as the default SessionManager is
	concerned it is just an opaque value."

	^startupArgs at: 2!

popupHelpFile
	self subclassResponsibility!

preStart
	"A hook for user configuration of the starutp - for example the development session
	manager uses this to file in a prestart.st fixup file, if there is one.
	The default is to do nothing."
!

primaryStartup
	"Perform very early startup actions."

	self basicPrimaryStartup!

primQuit: anInteger
	"Private - Terminate Smalltalk immediately with anInteger as the exit code. Graceful termination 
	should be initiated via #exit. The primitive never fails, and never returns."

	<primitive: 113>
	^self primitiveFailed!

primSnapshot: fileName backup: aBoolean type: anInteger
	"Private - Save the current image to fileName, optionally creating a backup of the existing file.

	Primitive failure codes:
		0	- fileName not a String
		1	- The image has expired
		2	- Unable to open image file
		3	- I/O Error writing image file (try KernelLibrary>>getLastError)."

	| result |
	<primitive: 97>
	result := Processor activeProcess primitiveFailureCode.
	result == 1 
		ifTrue: 
			[Warning signal: (String fromId: 516
						in: VMLibrary default asParameter)]
		ifFalse: [self error: 'Dolphin was unable to save the image.']!

queryEndSession
	"Fire off an event to enquire of observers whether they object to the end of this session.
	If any observer does, then it must set the boolean value argument to the event to false."

	"Implementation Note: We are using an Association here to avoid creating a base-system
	dependency on ValueHolder, and therefore the Value Models package."

	| okToQuit |
	okToQuit := nil -> true.
	self trigger: #queryEndSession: with: okToQuit.
	^okToQuit value!

quit
	"Force a close down of the session with the default exit code (0)"

	self quit: 0!

quit: anInteger
	"Private - Force a close down of the session with the specified exit code."

	self onExit == true ifTrue: [self primQuit: anInteger].
	^false	"cancelled"!

registerConsoleCtrlHandler
	"Private - Associate a control callback with the console for Ctrl-C, etc, events from
	the OS."

	consoleHandler isNil ifTrue: [
		consoleHandler :=  MessageCallback
						receiver: self
						selector: #onConsoleCtrl:
						descriptor: (ExternalDescriptor fromString: 'stdcall: bool dword').
		KernelLibrary default setConsoleCtrlHandler: consoleHandler asParameter add: true]!

registerRunning
	"Private - Register this session as the owner of the image by creating a named Win32 event.
	If we find that we have been beaten to it by a new pretender, then perform SessionManager
	specific action, which could include bowing out, or perhaps brazenly continuing."

	self createSentinel ifTrue: [self allowDuplicate ifFalse: [self quit: ERROR_ALREADY_EXISTS]].!

registerServer: server
	"Register the argument as a 'server' object which is handling unsolicited
	requests, e.g. an OLE COM class factory. The presence of registered servers
	prevents the receiver shutting down when run as a headless server."

	self servers add: server!

resourcesLocatorForClass: aClass 
	^FolderRelativeFileLocator basePath: (File composePath: self installationDirectory subPath: 'Resources')!

retire
	"This SessionManager instance is stepping down in favour of a new boy. Perform any
	uninitialisation that might be required."!

saveImage
	"Save an image of the current session so that it may be restored later. The precise operation 
	performed depends on the subclass (e.g. the DevelopmentSessionManager performs the traditional
	image snapshot, but a run-time SessionManager may save some other smaller set of information
	which is not a dump of the entire object memory)."

	self onPreSaveImage.
	[self saveImageDefault] ensure: [self onPostSaveImage]
!

saveImage: name
	"Save an image of the current session to the specified name (generally a file path).
	The precise operation performed (what is saved to where and how) is the responsibility
	of the subclass."

	self onPreSaveImage.
	[self saveImageTo: name] ensure: [self onPostSaveImage]
!

saveImageDefault
	"Save an image of the current session to the default persistant store (whatever that is)."

	^self error: 'Unable to save image'!

saveImageTo: name
	"Save an image of the current session to the persistant store with the specified
	name (whatever that is)."

	^self snapshot: name!

saveSessionState
	"Save down any session state that needs to be preserved and which is not automatically
	preserved by a normal image save. Examples would be externally managed resources
	such as Windows."

	"By default, assume there is no saved state, and do nothing"!

secondaryStartup
	"Perform second stage startup actions which can be done after prestart which
	provides a window to fix startup problems. Try and do things here rather than in 
	primary startup."

	self basicSecondaryStartup.
	self startUI.
	(self respondsTo: #comStartup) ifTrue: [self perform: #comStartup]!

sentinelName
	"Answer the name of the Win32 Event object created to uniquely identify this session
	so that attempts to run additional instances can be detected."

	^(self imageFileName copyReplacing: $\ withObject: $/) asLowercase.!

servers
	"Private - Answer the registry of servers registered with this session."

	servers isNil ifTrue: [servers := SharedIdentitySet new].
	^servers!

serverShutdown
	"Private - Determine if the system is running as a server, and if so, whether
	it should shut down."

	Notification signal: 'Server shutdown request'.
	(self isHeadless and: [self servers isEmpty])
		ifTrue: [self exit]!

setenv: nameString value: valueString
	"Set the value of the specified environment variable."

	(KernelLibrary default setEnvironmentVariable: nameString lpValue: valueString)
		ifFalse: [KernelLibrary default systemError]!

shutdown
	"Perform shutdown operations before the VM puts out the lights."

	state := 7.		"Second childishness and mere oblivion"
	self basicShutdown
!

snapshot: fileName
	"Private - Save the current image to fileName."

	^self 
		primSnapshot: fileName
		backup: false
		type: 0!

startUI
	"Start up the input loop/message loop (instruct InputState appropriate depending on whether
	this is a GUI or console session)."

	^self subclassResponsibility!

startupArgs
	"Private - Answer two element Array containing the startup arguments that were passed to this
	session."

	^startupArgs!

stderr
	"Answer the standard error stream (a <puttableStream>)."

	^self stdioStreams at: 3!

stderr: aStream
	"Set the standard error stream to the be <puttableStream> argument.
	Generally speaking this is connected to the CRT stderr stream."

	self stdioStreams at: 3 put: aStream!

stdin
	"Answer the standard input stream (a <gettableStream>)."

	^self stdioStreams at: 1!

stdin: inputStream
	"Set the standard input stream to the be <gettableStream> argument."

	self stdioStreams at: 1 put: inputStream!

stdioStreams
	"Private - Answer the 3-element <Array> of <StdioFileStream>s which are the 
	CRT stdin, stdout, and stderr streams, opening the streams if they are not
	currently available."

	stdioStreams isNil ifTrue: [self openConsole].
	^stdioStreams!

stdout
	"Answer the standard output stream (a <puttableStream>)."

	^self stdioStreams at: 2!

stdout: outputStream
	"Set the standard output stream to the be <puttableStream> argument."

	self stdioStreams at: 2 put: outputStream
!

systemDirectory
	"Answer the path of the Windows system directory on the host computer for the current
	session."

	| path len |
	path := File pathBuffer.
	len := KernelLibrary default getSystemDirectory: path uSize: path size.
	^len == 0
		ifTrue: [KernelLibrary default systemError]
		ifFalse: [path leftString: len]!

tertiaryStartup
	"Perform last startup operations before the main process is started - this includes firing the onStartup
	trigger."

	self basicTertiaryStartup!

trace: aString
	"Append aString to the trace device."

	KernelLibrary default outputDebugString: aString!

unhandledException: anException
	"Private - The unhandled Exception, anException, occurred in the active Process.
	Depending on the user response and the resumability of the exception, either 
	resume or terminate the process.
	Note: The exception response protocol (#resume, #pass, #outer, #exit, etc)
	can only be sent to an Exception inside a handler block (i.e. the second
	argument to BlockClosure>>on:do:)."

	self logError: anException.
	^anException okToContinue
		ifTrue: ["Resume execution" anException]
		ifFalse: [Processor activeProcess terminate]!

unregisterConsoleCtrlHandler
	"Private - Unregister the console control callback."

	consoleHandler isNil ifTrue: [^self].
		KernelLibrary default  setConsoleCtrlHandler: consoleHandler asParameter add: false.
		consoleHandler free.
	consoleHandler := nil!

unregisterServer: server
	"The argument, server, is requesting session termination, as it is no
	longer required. If there are no further services active and the system is only
	running services (i.e. it is a headless app.), then the request is accepted."

	self servers remove: server ifAbsent: [].
	self serverShutdown!

userName
	"Answer the name of the user currently logged on. Signals a Win32Error if
	the request fails"

	| name nameSize |
	name := String new: 256.
	nameSize := DWORD fromInteger: name size.
	(AdvApiLibrary default getUserName: name nSize: nameSize asParameter)
		ifFalse: [AdvApiLibrary default systemError].
	^name leftString: (nameSize asInteger-1)!

versionInfo
	"Answer the <VersionInfo> for this session, extracted from the host executable."

	^VersionInfo forPath: (ExternalLibrary moduleFileName: nil)
!

whatsThis: object 
	self subclassResponsibility!

windowsDirectory
	"Answer the path of the Windows directory on the host computer for the current session. Note
	that under Terminal Server this will be the shared Windows directory, not the per-user
	Windows directory. See MSDN KB281316  for further information."

	^OSVERSIONINFO current dwMajorVersion >= 5 
		ifTrue: 
			[| path len |
			path := File pathBuffer.
			len := KernelLibrary default getSystemWindowsDirectory: path uSize: path size.
			len == 0 ifTrue: [^KernelLibrary default systemError].
			path leftString: len]
		ifFalse: 
			["The system call returns the path sans a delimiter, so we must maintain that behaviour"
			File removePathDelimiter: (File splitPathFrom: (File removePathDelimiter: self systemDirectory))]! !

SharedQueue comment:
''!
!SharedQueue class methodsFor!

initialize
	"Private - Initialize the receiver's class variables.
		SharedQueue initialize
	"

	AbsentCookie := Object new!

new
	"Answer a new instance of the receiver."

	^self new: 4!

new: anInteger 
	"Answer a new instance of the receiver with initial space
	for anInteger elements in the queue."

	^(self basicNew)
		initialize: anInteger;
		yourself! !

!SharedQueue methodsFor!

errorOutOfSync
	"Private - An internal synchronisation error (between the valueAvailable
	Semaphore and the contents OrderedCollection) has been detected.
	Raise an appropriate exception."

	self error: 'internal synchronisation error'!

initialize: anInteger
	"Private - Initialize the receiver, providing sufficient initial space
	in the queue for anInteger elements (the queue will grow however)."

	contents := OrderedCollection new.
	accessProtect := Semaphore forMutualExclusion.
	valueAvailable := Semaphore new
!

next
	"Answer the first item in the queue. If the queue is empty, make the current active 
	Process wait until another Process has put an object in the queue. Safe for multiple 
	consumers, since valueAvailable effectively records the number of entries in the queue."

	| value |
	valueAvailable wait.
	value := accessProtect critical: [contents removeFirstIfAbsent: [AbsentCookie]].
	value == AbsentCookie ifTrue: [self errorOutOfSync].
	^value!

nextNoWait
	"Answer the first item in the queue, or nil if the queue is empty. The current active Process
	will not be made to wait, regardless of the queue state.
	Note: This is implemented rather than #isEmpty in order that the test and retrieval can
	be performed as an atomic unit. We also suppress any error due to the valueAvailable and
	contents collection size being out of sync. in order to avoid leaving the critical
	section locked. So even if the queue really is empty when the valueAvailable Semaphore
	says it is not, the external behaviour is correctly maintained."

	| value |
	(valueAvailable wait: 0) == WAIT_TIMEOUT ifTrue: [^nil].
	value := accessProtect critical: [contents removeFirstIfAbsent: [AbsentCookie]].
	value == AbsentCookie ifTrue: [self errorOutOfSync].
	^value!

nextPut: value
	"Place the object, value, at the end of the queue, signalling the valueAvailable 
	semaphore	to permit consumers to continue, or record the current number of items in
	the queue if there are no consumers waiting. Answer the argument, value."

	accessProtect critical: [contents addLast: value].
	valueAvailable signal.
	^value
!

peek
	"Answer the first object in the queue, but do not remove it. If the queue is empty, answer nil.
	The current active process will not be made to wait regardless of the queue state."

	^accessProtect critical: [contents notEmpty ifTrue: [contents first]]!

removeAll
	"Empty the receiver of all contents."

	"Implementation Note: We must be careful to make sure that the valueAvailable semaphore 
	correctly reflects the number of items in the queue. Since #nextPut: signals valueAvailable
	after adding a new entry to the queue, we mustn't remove any items not yet accounted for
	in the signal count of valueAvailable."

	accessProtect critical: 
			[
			[((valueAvailable wait: 0) == WAIT_TIMEOUT 
				ifFalse: [contents removeFirstIfAbsent: [AbsentCookie]]) isNil] 
					whileFalse]!

size
	"Answer the number of objects currently in the queue"

	^accessProtect critical: [contents size]! !

Signal comment:
''!
!Signal class methodsFor!

description: anObject
	"Answer a new, non-resumable, instance of the receiver with the specified description"

	^self new description: anObject!

icon
	"Answers an Icon that can be used to represent this class"

	^Error icon!

new
	"Answer a new correctly initialize instance of the receiver."
	
	^super new initialize!

resumableDescription: anObject
	"Answer a new continuable instance of the receiver with the specified description."

	^self new 
		description: anObject;
		makeResumable! !

!Signal methodsFor!

, arg
	"Answer a new <ExceptionSet> containing the receiver and the argument."

	^ExceptionSet with: self with: arg!

defaultAction: exception
	"Private - Perform the default action for the raised incarnation of the receiver,
	exception, as it has not been handled.
	Implementation Note: forward to the SessionManager for application specific handling."

	"Will not return unless execution is to be resumed"
	^SessionManager current onUnhandledError: exception!

defaultResumption
	"Private - Answer the default setting for the receiver's resumable flag."

	^false!

description
	"Private - Answer the receiver's description format string."

	^description!

description: aString
	"Set the description of the receiver to be aString. The description can include
	Win32 format substitution specifiers."

	description := aString!

exceptionClass
	"Private - Answer the class of Exception to be raised when the receiver
	is signalled."

	^RaisedSignal!

handles: exception
	"Answer whether the receiver matches the <exceptionDescription>, exception, and 
	any handler at this scope should be invoked."

	^exception signalType == self
!

initialize
	"Private - Initialize the receiver's instance variables."

	resumable := self defaultResumption.
	description := '%1'!

isResumable
	"Answer whether the receiver represents a resumable Signal."

	^resumable!

makeNonResumable
	"Make the receiver a non-resumable Signal. Answer the receiver."

	resumable := false!

makeResumable
	"Make the receiver a resumable Signal. Answer the receiver."

	resumable := true!

newException
	"Answer a new <Exception> instantiated on the receiver, but as yet unsignalled."

	^self exceptionClass new
		signalType: self;
		yourself!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: self description;
		nextPut: $)
!

resumable: aBoolean
	"Set whether the receiver represents a resumable Signal."

	resumable := aBoolean!

signal
	"Signal the occurrence of an exceptional condition.
	This method will not normally return to its sender.
	Implementation Note: A new <Exception> is instantiated and
	signalled, initiating a search for an ExceptionHandler prepared to
	handle that exception."

	^self newException signal!

signal: signalerText
	"Signal the occurrence of an exceptional condition with the specified description.
	This method will not normally return to its sender.
	N.B. X3J20 requires that the argument, signalDescription, conform to the 
	<readableString> protocol, but we relax this to permit an object (which is sent 
	#displayString to get a <readableString>).
	Portable code should use only <readableString> descriptions.
	Implementation Note: Raise a new <Exception> instance with the specified details, 
	initiating a search for an ExceptionHandler prepared to handle that exception."
	
	^self newException signal: signalerText!

signal: signalerText with: signalerTag
	"Signal the occurrence of an exceptional condition with the specified description
	and tag. This method will not normally return to its sender."
	
	^self newException
		signal: signalerText
		with: signalerTag
!

signalWith: signalerTag
	"Signal the occurrence of an exceptional condition with the specified tag object.
	This method will not normally return to its sender."
	
	^self newException signalWith: signalerTag! !

SortAlgorithm comment:
'SortAlgorithm is the abstract class of singleton sort algorithms primarily used to implement the sorting strategy of <SortedCollection> instances, although in fact SortAlgorithms can be used to sort the indexable variables of any object. Concrete subclasses provide implementations of well-known sort algorithms for use in different circumstances. A <SortAlgorithm> is responsible for defining the order of elements (i..e. it implements or holds the comparison predicate, or sort block), and for performing the sorting of a requested range of indexable instance variables of some other object, typically a SortedCollection.

No one sort algorithm is best in all cases; the traditional Smalltalk sort algorithm is Quicksort. Quicksort is a reasonable default, but can exhibit poor performance for large numbers of sort-equal elements, or when the sort order is inverted. Another disadvantage of quicksort is that it is not stable, so any previous ordering of sort-equal elements in the list is lost. Heapsort is slower than Quicksort on average, but has no worst cases. Introsort is a recently developed algorithm that combines Quicksort with Heapsort. It starts off with Quicksort, and then monitors itself to see if the sort is performing poorly, at which point it will switch to Heapsort. Introsort performs nearly as well as Quicksort on its best cases, and is better on average, and it is thus the default sort algorithm in Dolphin. However, since it is based on Quicksort and Heapsort it is still unstable. Mergesort and Insertion sort are both stable sorts, making them preferable for use in cases where one wants to sort by multiple criteria but in multiple passes (e.g. when sorting the items in a list view by sorting on the columns). Insertion sort is, however, slow in general, although comes into its own when sorting small sequences or sequences that are already largely sorted - in fact it is the algorithm of choice in both cases. Mergesort is nearly as fast as Quicksort on average, has no worst cases, and is stable. However it has the disadvantage of requiring auxiliary storage equal to the size of the collection being sorted. 

If choosing a default sorting algorithm for Smalltalk today, as opposed to in the 1970s, the memory usage would not be such a significant issue, and Mergesort might be a better choice than Quicksort. Fortunately in Dolphin one has the flexibility to choose the sorting algorithm to suit the task: If sorting random data, use Quicksort; if the data is known to be mostly sorted, Insertion sort is (perhaps surprisingly) the algorithm of choice; if the data is sorted and one needs to reverse the sort order, avoid Quicksort because this is one of the cases for which it will perform very poorly, Heapsort or Mergesort are good choices in this case; for lists in a UI Mergesort is preferable because it is stable, as well as having no worse cases that can result in significant pauses when inverting the column sort order in a list view. You can even implement your own custom sorting algorithms - for example if you know you will be sorting strings, then a radix sort will beat the pants off any comparison based sorting algorithm. To squeeze the last ounce of speed from your sorting you can also implement a custom sorting algorithm in order to inline the comparison predicate, indeed <DefaultSortAlgorithm> is an example of this that uses #<= to compare elements in order to emulate the default SortedCollection sort block, or perhaps to implement some new sorting algorithm you want to try.
'!
!SortAlgorithm methodsFor!

compare: operand1 with: operand2 
	"Answer whether the <Object>, operand1, should sort before the <Object> argument, operand2,
	using the receiver's comparison method."

	^self sortBlock value: operand1 value: operand2!

copyWithSortBlock: aDyadicValuable 
	"Answer a new <SortAlgorithm> that implements the same sorting algorithm as the receiver,
	but using the <dyadicValuable> argument for comparing elements instead of the receiver's
	current comparison."

	^self subclassResponsibility!

heapsort: anObject from: startInteger to: stopInteger 
	| i |
	i := (stopInteger + startInteger) // 2.
	[i < startInteger] whileFalse: 
			[self 
				sift: anObject
				from: i
				between: startInteger
				and: stopInteger.
			i := i - 1].
	i := stopInteger.
	[i <= startInteger] whileFalse: 
			[| temp |
			temp := anObject basicAt: startInteger.
			anObject basicAt: startInteger put: (anObject basicAt: i).
			anObject basicAt: i put: temp.
			self 
				sift: anObject
				from: startInteger
				between: startInteger
				and: (i := i - 1)]!

insertionSort: anObject from: startInteger to: stopInteger 
	| compare |
	compare := self sortBlock.
	startInteger + 1 to: stopInteger
		do: 
			[:j | 
			| a t i |
			a := anObject basicAt: j.
			i := j.
			[i <= startInteger or: [compare value: (t := anObject basicAt: i - 1) value: a]] whileFalse: 
					[anObject basicAt: i put: t.
					i := i - 1].
			anObject basicAt: i put: a]!

quicksortRecursionLimit: anInteger 
	^(2.0 * (anInteger log: 2)) floor!

sift: anObject from: anInteger between: startInteger and: stopInteger 
	| val i compare |
	compare := self sortBlock.
	val := anObject basicAt: anInteger.
	i := anInteger.
	
	[| left right max j leftVal rightVal |
	max := val.
	j := i.
	left := j + j + 1 - startInteger.
	(left <= stopInteger and: [compare value: max value: (leftVal := anObject basicAt: left)]) 
		ifTrue: 
			[i := left.
			max := leftVal].
	right := left + 1.
	(right <= stopInteger and: [compare value: max value: (rightVal := anObject basicAt: right)]) 
		ifTrue: 
			[i := right.
			max := rightVal].
	i == j 
		ifTrue: 
			[j > anInteger ifTrue: [anObject basicAt: j put: val].
			^self].
	anObject basicAt: j put: max] 
			repeat!

sort: aCollection from: startInteger to: stopInteger
	"Sort elements in the range of indexable instance variables of the <Object> argument from
	startInteger through stopInteger to be non-descending according to the <DyadicValuable> sort
	block."

	^self subclassResponsibility!

sortBlock
	"Answer a <dyadicVariable> that implements the sort-order comparison in use by the receiver.
	Note that receiver may not actually use a block to perform comparisons, so the answer may
	not be the actual sort block, although in many cases it will be."

	^self subclassResponsibility! !

Sound comment:
'Sound is the class of objects that represent wave audio resources (.wav files).

Instance Variables:
	name		<String> identifier (e.g. filename or resource identifier)
	location		<ExternalHandle> of the module containing the wave resource, or nil if a .wav file.
	type		<SmallInteger> flags.
	fileLocator	<FileLocator>

Class Variables:
	Registry		<IdentityDictionary>. Registry of standard named sounds.

"test"'!
!Sound class methodsFor!

beep
	"Generate the standard system parp."

	self beep: 0!

beep: anInteger
	"Generate a parp of the specified type (see Win32 documentation) from the system speaker."

	UserLibrary default messageBeep: anInteger!

beep: freqInteger duration: durationInteger
	"Generate a parp of the specified frequency and duration from the system speaker."

	KernelLibrary default beep: freqInteger dwDuration: durationInteger!

bell
	"Generate a very short parp using the computer speaker - useful for debugging.
	Implementation Note: Annoyingly MessageBeep(-1) does not have the desired effect on
	NT4.0 because it doesn't actually use the speaker if a Sound card is present."

	self beep: 750 duration: 15!

clearRegistry
	"Create the standard sound registry"

	Registry := IdentityDictionary new.
!

defaultBeep
	"Generate the default system beep."

	self beep: 0!

errorBeep
	"Generate the standard system error parp."

	self beep: MB_ICONERROR!

for: aSymbol ifAbsent: aBlock
	"Answers a standard sound from our own registry"

	^Registry at: aSymbol ifAbsent: aBlock.!

for: aSymbol put: aSound
	"Sets a standard sound into our own registry"

	^Registry at: aSymbol put: aSound.!

fromAlias: aString
	"Answer a new instance of the receiver from the alias aString (stored in the windows registry 
	and configurable from the control panel)"

	^(self new)
		name: aString;
		type: SND_ALIAS | SND_ASYNC;
		yourself!

fromFile: aString
	"Answer a new instance of the receiver from the wave file named aString."

	^self fromFile: aString usingLocator: FileLocator default!

fromFile: aString usingLocator: aFileLocator
	"Answer a new instance of the receiver from the wave file named aString
	using aFileLocator."

	^(self new)
		name: (aFileLocator relativePathTo: aString);
		fileLocator: aFileLocator;
		type: SND_FILENAME | SND_ASYNC;
		yourself!

fromId: aResourceId in: anExternalHandle
	"Answer a new instance of the receiver from the resource identified by
	aResourceId in the external module identified by anExternalHandle"

	^(self new)
		name: aResourceId;
		location: anExternalHandle;
		type: (SND_RESOURCE | SND_ASYNC);
		yourself!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

informationBeep
	"Generate the standard system information parp."

	self beep: MB_ICONINFORMATION!

initialize
	"Private - Initialize the receiver"

	self clearRegistry!

promptBeep
	"Generate the standard system prompt (question) parp."

	self beep: MB_ICONQUESTION!

warningBeep
	"Generate the standard system warning parp."

	self beep: MB_ICONWARNING!

woofAndWaitFor: aSymbol
	"Woofs standard sound from our own registry"

	self woofAndWaitFor: aSymbol ifAbsent: []!

woofAndWaitFor: aSymbol ifAbsent: exceptionBlock
	"Woofs standard sound from our own registry"

	| sound |
	sound := (Registry at: aSymbol ifAbsent: []). 
	sound notNil 
		ifTrue: [ sound woofAndWait ]
		ifFalse: [ exceptionBlock value ]!

woofFor: aSymbol
	"Woofs standard sound from our own registry"

	self woofFor: aSymbol ifAbsent: []!

woofFor: aSymbol ifAbsent: exceptionBlock
	"Woofs standard sound from our own registry"

	| sound |
	sound := (Registry at: aSymbol ifAbsent: []). 
	sound notNil 
		ifTrue: [ sound woof ]
		ifFalse: [ exceptionBlock value ]! !

!Sound methodsFor!

fileLocator: aFileLocator	
	"Private - Set the file locator used to locate the receiver's WAV file.
	Answers nil for non-file based sounds."

	fileLocator := aFileLocator!

location: anObject
	"Private - Set the 'location' of the receiver's wave resource"

	location := anObject!

name: aString
	"Private - Set the 'name' of the receiver's wave resource"

	name := aString!

play: anInteger 
	"Private - Play the receiver with the specified flags. Answer whether it succeeded."

	| soundName |
	soundName := fileLocator ifNotNil: [fileLocator localFileSpecFor: name] ifNil: [name].
	^WinMMLibrary default 
		playSound: soundName
		hmod: location asParameter
		fdwSound: anInteger!

type
	"Answer the type of the receiver (flags specifying whether it is asynchronous, etc)"

	^type!

type: anInteger 
	"Private - Set the 'type' of the receiver's wave resource"

	type := anInteger!

woof
	"Play the receiver, but do not wait for the woof to finish. Subsequent woofs may terminate this one."

	self play: type!

woofAndWait
	"Play the receiver, waiting for the woof to finish"

	| flags |
	flags := (type bitAnd: ##(SND_ASYNC bitInvert)) bitOr: SND_SYNC.
	self play: flags! !

SourceFiler comment:
''!
!SourceFiler class methodsFor!

on: aWriteStream 
	"Answer a new instance of the receiver for filing out source code onto the 
	<puttableStream> argument."

	^(self new)
		setStream: aWriteStream;
		yourself! !

!SourceFiler methodsFor!

atEnd
	"Answer whether the receiver is at the end of its source stream."

	^stream atEnd!

close
	"Close the source stream"

	stream close!

cr
	"Emit a line-delimiter to the source stream"

	stream cr!

emitCategoriesOfClass: aClass 
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	^self subclassResponsibility!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append an entry to the source stream to reclassify the <CompiledMethod>, 
	aCompiledMethod, in all its current method categories."

	^self subclassResponsibility!

emitCategoriesOfMethods: methods 
	"Emit source that associates the <CompiledMethod>s in the <collection>, methods, with their
	current categories."

	methods do: [:m | self emitCategoriesOfMethod: m]!

emitComment: aString 
	"Private - Record aString to the source stream.
	N.B. Logging requests should be directed through the SessionManager."

	^self subclassResponsibility!

emitCommentOfClass: aClass 
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to source stream."

	^self subclassResponsibility!

emitFooterForMethodsOf: aClass 
	"Private - Ends the method definition chunks for aClass onto
	the source stream."

	^self subclassResponsibility!

emitGUIDOfClass: aClass 
	"Private - Emit a GUID definition chunk for the <Class>, aClass, to the source stream."

	^self subclassResponsibility!

emitHeaderForMethodsOf: aClass 
	"Private - Emits a category header for the class, aClass, to the source stream."

	^self subclassResponsibility!

emitMessages: aClass ofBehavior: selectors 
	| methods sortedSelectors |
	sortedSelectors := selectors 
				asSortedCollection: SortedCollection caseSensitiveSortBlock.
	methods := sortedSelectors asArray collect: 
					[:selector | 
					| method |
					self
						cr;
						cr.
					method := aClass compiledMethodAt: selector.
					self emitMethod: method.
					method].
	^methods!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, to the source stream."

	^self subclassResponsibility!

emitSetBehaviorFlag: flagName forClass: aClass 
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	^self subclassResponsibility!

emitSpecialBehaviourAttributesOfClass: aClass 
	"Private - Emit attributes for the <Class>, aClass, to define its special behaviour flags."

	#(#isIndirection #isNullTerminated) do: 
			[:flagName | 
			(aClass perform: flagName) 
				ifTrue: [self emitSetBehaviorFlag: flagName forClass: aClass]]!

evaluationContext
	^evaluationContext!

evaluationContext: anObject
	evaluationContext := anObject!

fileIn
	"File in the expressions/definitions from receiver's source stream, which is
	expected to be in the receiver's format. Any methods that fail to compile are stubbed 
	with instances of <CompileFailedMethod> and errors are logged to the Transcript."

	^self subclassResponsibility!

fileOutAllMethodsOfBehavior: aClassDescription 
	"Emit definitions of all methods in the <ClassDescription> argument, aClassDescription,
	to the source stream."

	self fileOutMessages: aClassDescription selectors ofBehavior: aClassDescription.
	self isSourceOnly 
		ifFalse: [self fileOutProtocols: aClassDescription protocols ofBehavior: aClassDescription]!

fileOutAttributesOfClass: aClass 
	"File-out any attributes of the aClass (e.g. the comment, GUID, etc) not included in the basic
	aClass definition, onto the source stream."

	self emitGUIDOfClass: aClass.
	self emitSpecialBehaviourAttributesOfClass: aClass.
	self emitCommentOfClass: aClass.
	self emitCategoriesOfClass: aClass!

fileOutBasicDefinitionOfClass: aClass 
	"Print a definition of the <Class>, aClass, to the source stream."

	^self subclassResponsibility!

fileOutBinaryGlobal: anAssociation 
	"File out the text representation of the non-<sourceObject>
	which is the value of the <Association>, anAssociation, to the
	source stream. The key of the association is the global name."

	^self subclassResponsibility!

fileOutClass: aClass 
	"File out a full definition of the <ClassDescription>, aClass, to the source stream
	including all methods, categories and protocols. This includes all methods of the
	class, including any loose methods that may belong to packages other than the
	owning package of the class."

	self
		fileOutDefinitionOfClass: aClass;
		fileOutAllMethodsOfBehavior: aClass;
		fileOutAllMethodsOfBehavior: aClass class!

fileOutDefinitionOfClass: aClass 
	"File-out a definition of the <Class> to the source stream."

	self
		fileOutBasicDefinitionOfClass: aClass;
		fileOutAttributesOfClass: aClass!

fileOutExpression: aString
	"Append an immediate expression evaluation to the the source stream."

	^self subclassResponsibility!

fileOutMessages: selectors ofBehavior: aClass 
	"Append the definitions of the methods of the <ClassDescription>, aClassDescription,
	whose names match the selectors in the <collection> of <Symbol>, aCollection, to the source 
	stream. Any method category settings are included."

	| methods |
	selectors isEmpty ifTrue: [^self].
	self emitHeaderForMethodsOf: aClass.
	methods := self emitMessages: aClass ofBehavior: selectors.
	self emitFooterForMethodsOf: aClass.
	self isSourceOnly ifFalse: [self emitCategoriesOfMethods: methods].
	self cr!

fileOutMethods: aCollection 
	"Append the definitions of the methods in the <collection> argument to the source stream,
	ordered by class. Any method category settings are included."

	| methodsByClass |
	methodsByClass := Dictionary new.
	aCollection do: 
			[:each | 
			"Note that the selectors will be filed out in sorted order, so we don't need to sort them"
			(methodsByClass at: each methodClass ifAbsentPut: [OrderedCollection new]) add: each selector].
	(methodsByClass associations 
		asSortedCollection: [:a :b | (a key name trueCompare: b key name) <= 0]) 
			do: [:each | self fileOutMessages: each value ofBehavior: each key]!

fileOutPoolDictionary: aPoolDictionary 
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the source stream. The definition should be sufficient to recreate a copy  of the dictionary."

	^self subclassResponsibility!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to the source stream,
	associating them with the <ClassDescription>, aClassDescription."

	^self subclassResponsibility!

fileOutResource: aResourceIdentifier 
	"Append a definition of the resource identified by the <ResourceIdentifier>, aResourceIdentifer,
	to the source stream. The definition should be sufficient to recreate a copy  of the resource."

	^self subclassResponsibility!

flush
	"Flush the source stream."

	stream flush!

getSourceFromDescriptor: sourceDescriptor
	"Answer the <readableString> source corresponding to the specified <integer> 
	descriptor, sourceDescriptor, from the receiver's source stream."

	^self subclassResponsibility!

isSourceOnly
	^isSourceOnly!

isSourceOnly: aBoolean 
	isSourceOnly := aBoolean!

setStream: aPuttableStream 
	stream := aPuttableStream.
	self isSourceOnly: false!

setToEnd
	"Seek to the end of the source stream."

	stream setToEnd!

sourcePositionFromDescriptor: sourceObject
	"Private - Answer the offset from the start of the source file at which the chunk containing
	the source code whose location is described by, sourceDescriptor, can be found.
	If sourceObject is not an Integer, then an error will result."

	^sourceObject bitShift: -4!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	^self subclassResponsibility!

storeCommentString: aString forPackage: aPackage
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	^self subclassResponsibility!

storeSource: aString for: aSourceObject
	"Private - Store the <readableString>, aString, as the source text for the <sourceObject>,
	aSourceObject, updating its source descriptor."

	^self subclassResponsibility!

storeSourceString: aString forMethod: aCompiledMethod 
	"Save the <readableString>, aString, as the source text for the 
	<CompiledMethod>, aCompiledMethod, to the receiver's source stream
	encoding the position and index into the methods source descriptor so that 
	the source may be retrieved later."

	^self subclassResponsibility!

stream
	"Private - Answer the value of the receiver's ''stream'' instance variable."

	^stream! !

SourceManager comment:
''!
!SourceManager class methodsFor!

default
	"Answer the default SourceManager to use."

	DefaultInstance isNil ifTrue: [ SourceManager newDefault ].
	^DefaultInstance!

default: aSourceManager
	"Set the default  source manager to aSourceManager."

	DefaultInstance notNil ifTrue: [ DefaultInstance closeSources ].
	DefaultInstance := aSourceManager.
	DefaultInstance notNil ifTrue: [ DefaultInstance openSources ].!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon!

initialize
	"Initialize the class variables of the receiver"

	SourcesIndex := 1.
	ChangesIndex := 2!

new
	^super new initialize!

newDefault
	"Answer an instance of the receiver which becomes the default source manager"

	| sm |
	sm := self new.
	self default: sm.
	^sm!

reset
	"Private - Reset this class"
	DefaultInstance class==self ifTrue: [ 
		DefaultInstance closeSources.
		DefaultInstance  := nil ].
!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self reset! !

!SourceManager methodsFor!

basicChangesFiler
	^SourceFiles at: ChangesIndex!

basicCompressSources: progress 
	"Private - Compresses the sources file reporting the progress to
	<monadicValuable>, progress."

	| totalClasses index tmpPath smlFile filer classes |
	index := 0.
	classes := self class environment allClasses.
	totalClasses := classes size.

	"Create temporary stream file"
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	smlFile := self sourcesFileName.
	filer := self sourceFilerOn: (FileStream write: tmpPath).
	filer
		sourceFileIndex: SourcesIndex;
		isSourceOnly: true.
	self logComment: 'Compressing sources....' to: filer.
	index := 0.
	classes do: 
			[:class | 
			filer storeCommentString: class comment forClass: class.
			filer fileOutAllMethodsOfBehavior: class class.
			filer fileOutAllMethodsOfBehavior: class.
			progress value: (index := index + 1) * 100 / totalClasses].
	self compressPackageCommentsOn: filer.
	filer close.

	"Copy temporary file over to dolphin.sml"
	self closeSourcesFile.
	File
		delete: smlFile;
		rename: tmpPath to: smlFile.
	self openSourcesFile: smlFile.

	"Save image"
	SessionManager current saveImage.

	"Clear down change log"
	self truncateChanges.
	self logComment: 'Compressed sources'!

basicOpenSources: filePath
	"Private - Open the source streams"

	self
		openSourcesFile: filePath;
		openChangesFile: filePath!

changePositionFromDescriptor: anInteger 
	"Private - Answer the offset from the start of the source file at which the chunk containing
	the source code whose location is described by, sourceDescriptor, can be found.
	If sourceObject is not an Integer, then an error will result."

	^self basicChangesFiler sourcePositionFromDescriptor: anInteger!

changePositionOf: aSourceObject 
	"Private - Answer the offset from the start of the source file at which the chunk containing
	the source code of the specified <sourceObject> can be found. The answer is only valid
	if aSourceObject has actually been changed."

	^aSourceObject sourceDescriptor 
		ifNil: [self changesFileSize]
		ifNotNil: [:descriptor | self changePositionFromDescriptor: descriptor]!

changesExtension
	"Private - Answers the suffix to use for the changes file"

	^'chg'!

changesFileName
	"Answer the file name for the current change log."

	^self changesStream name!

changesFileNameFromPath: filePath
	"Answer the file name for a change log with the specified image path."

	^File path: filePath extension: self changesExtension!

changesFiler
	"Private - Answer a <SourceFiler> open on the changes log file, or nil 
	if there is no change log. The <SourceFiler> is position to the end of 
	the log ready to log new source, etc."

	^self basicChangesFiler ifNotNil: 
			[:changes | 
			changes
				setToEnd;
				yourself]!

changesFileSize
	"Answer the current size of the change log."

	^self changesStream size!

changesStream
	"Private - Answer the FileStream open on the changes log file."

	^self basicChangesFiler ifNotNil: [:changes | changes stream]!

chunkFilerOn: aStream 
	"Answer a <ChunkSourceFiler> on the specified stream."

	^ChunkSourceFiler on: aStream!

closeChangesFile
	"Private - Close the changes log file FileStream."

	self closeSourceAt: ChangesIndex
!

closeSourceAt: anInteger
	"Private - Closes the source FileStream SourceFiles at: anInteger and nil it out."

	(SourceFiles at: anInteger) notNil ifTrue: [
		(SourceFiles at: anInteger) close.
		SourceFiles at: anInteger put: nil ].
!

closeSources
	"Private - Closes the changes and the sources files."

	self closeSourcesFile; closeChangesFile!

closeSourcesFile
	"Private - Close the sources FileStream."

	self closeSourceAt: SourcesIndex
!

compressChangedMethodsOf: aBehavior onto: aSourceFiler 
	"Private - Emits the changed methods of aBehavior onto aSourceFiler."

	| changed |
	changed := aBehavior changedMethods collect: [:each | each selector].
	aSourceFiler fileOutMessages: changed ofBehavior: aBehavior!

compressChanges
	"Compresses the change log to remove duplicate entries, and save the image to keep it in sync."

	| tmpPath filer |
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	filer := self chunkFilerOn: (FileStream write: tmpPath).
	filer sourceFileIndex: ChangesIndex.
	mutex critical: 
			[self compressChangesOnto: filer.
			filer close.
			self openNewChangesFile: tmpPath].
	self logComment: 'Compressed changes'.

	"Save image"
	SessionManager current saveImage!

compressChangesOf: aClass onto: aSourceFiler 
	"Private - Compress any changes to the specified class onto the <SourceFiler>."

	"First the comment ..."

	(self sourceIndexFromDescriptor: aClass sourceDescriptor) = ChangesIndex 
		ifTrue: [aSourceFiler storeCommentString: aClass comment forClass: aClass].
	"...then the methods..."
	self
		compressChangedMethodsOf: aClass class onto: aSourceFiler;
		compressChangedMethodsOf: aClass onto: aSourceFiler.
	"Have to reset the changes index so that all changed methods are included since we have lost
	the save point"
	aClass isChanged 
		ifTrue: 
			["Note that it is necessary to remove the existing change index first since
			 attempts after the first to set it are ignored"
			aClass
				isChanged: false;
				changeIndexValue: [0]]!

compressChangesOnto: aSourceFiler 
	self class environment allClassesDo: [:each | self compressChangesOf: each onto: aSourceFiler].
	Package manager packages do: 
			[:each | 
			(self sourceIndexFromDescriptor: each sourceDescriptor) = ChangesIndex 
				ifTrue: [aSourceFiler storeCommentString: each comment forPackage: each]]!

compressPackageCommentsOn: aSourceFiler 
	Package manager packages do: 
			[:each | 
			| comment |
			comment := each comment.
			comment isEmpty 
				ifTrue: [each sourceDescriptor: nil]
				ifFalse: [aSourceFiler storeCommentString: comment forPackage: each]]!

compressSources
	"Compresses the change log into the sources file. The result is a new empty changes log.
	The image must be saved to keep it in sync."

	self basicCompressSources: [:x | ]

!

copyAndReopenSources: aString 
	"Private - Copy sources to the path and root file name (i.e. without extension) specified
	by the <readableString> argument, and then open the copies for any further perusal and 
	modification.

	Take a special interest if we do not currently have the source files available.
	This will be the case when we load from a .exe. In this case we generate some
	suitable empty source files. We also have to mark methods so that they know
	they have lost any reference to information in a .sml file."

	| hadSources |
	hadSources := self hasSources.

	"Copy and and swap over sources. Take care to end up with a good sources and imagePath"
	hadSources 
		ifTrue: 
			[self copySourceFilesTo: aString.
			self closeSources].
	hadSources 
		ifFalse: 
			[self createSources: aString.
			"We have permanently lost access to any source information so mark all methods"
			self class environment 
				allBehaviorsDo: [:aBehavior | aBehavior methodDictionary do: [:aMethod | aMethod loseSource]]].
	self openSources: aString!

copySourceFilesTo: path
	"Private - Copy the various Smalltalk sources files to a new root name"

	self flushChanges.
	[ File
		copy: self sourcesFileName to: (self sourcesFileNameFromPath: path);
		copy: self changesFileName to: (self changesFileNameFromPath: path)
	] on: HRESULTError do: [:e |
		self error: 'Failed to copy sources to ', path, '(', e osErrorMessage, ')']!

createSources: filePath
	"Private - This will create a sources and changes file for the current image. Does not
	update the receiver to use these new files though."

	self createSourcesFile: filePath.
	(File open: (self changesFileNameFromPath: filePath) mode: #truncate check: false) close!

createSourcesFile: filePath 
	"Private - Create (or truncate) a source file with the specified path (and default extension)."

	(self newSourceFiler: (self sourcesFileNameFromPath: filePath)) close!

emitFileOutHeaderOn: aSourceFiler 
	"Private - Append the standard Dolphin file out header to the
	<puttableStream>, aWriteStream."

	aSourceFiler
		emitComment: 'Filed out from ' , VMLibrary default productName;
		cr!

errorNotPackaged: anObject
	"Private - Signal an error to indicate than anObject is not yet assigned to a packaged
	and therefore cannot be filed out"

	anObject error: 'Object is not owned by any package'!

fileIn: aFileName
	"File in the chunk format file named, aFileName, into the system."

	| stream |
	stream := FileStream read: aFileName.
	[self fileInFrom: stream] ensure: [stream close].!

fileInFrom: aStream 
	"Private - File in the expressions/definitions from the chunk stream, aStream.
	in the receiver's chunk format. Any methods that do not	compile are stubbed 
	with instances of CompileFailedMethod and errors logged to the Transcript."

	(self chunkFilerOn: aStream) fileIn!

fileInHere: aFileName 
	"File in the chunk format file named, aFileName, into the system but with
	the working directory set to the location of the file. The original directory
	is restored on completion."

	| cwd |
	cwd := File workingDirectory.
	File workingDirectory: (File splitPathFrom: aFileName).
	[self fileIn: (File splitFilenameFrom: aFileName)] ensure: [File workingDirectory: cwd]!

fileInPackagedClass: aClass
	"File in aClass via the package mechanism. The class is filed in from the same directory as the
	package which contains it. Following this call the class and its methods are marked as unchanged."

	self fileInPackagedClass: aClass from: aClass fileOutName.


	!

fileInPackagedClass: aClass from: aFileName
	"File in aClass via the package mechanism. The class is filed in from aFileName.
	Following this call the class and its methods are marked as unchanged."

	self fileIn: aFileName.
	aClass initializeAfterLoad


	!

fileItIn: aString
	"File the chunk format Smalltalk expression in aString into the system"

	self fileInFrom: aString readStream
!

fileOut: anObject
	"File out anObject to its default file. If an error occurs during file out, the file
	will be closed by finalization."

	self fileOut: anObject to: anObject fileOutName.!

fileOut: anObject to: aFileName 
	"File out anObject to aFileName. If an error occurs during file out, the file
	will be closed by finalization."

	| filer |
	filer := self newSourceFiler: aFileName.
	anObject fileOutOn: filer.
	filer close!

fileOutPackagedClass: aClass
	"File out aClass via the package mechanism. The class is filed out to the same directory as the
	package which contains it. Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	self fileOutPackagedClass: aClass to: aClass fileOutName.
	!

fileOutPackagedClass: aClass to: aFileName 
	"File out aClass via the package mechanism. The class is filed out to aFileName.
	Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	| package filer |
	package := self packageManager packageOfClass: aClass.
	package isNil 
		ifTrue: 
			["Not in any package so just file out normally"
			^self fileOut: aClass to: aFileName].
	filer := self newSourceFiler: aFileName.
	filer fileOutDefinitionOfClass: aClass.
	package fileOutMethodsOfClass: aClass on: filer.
	package fileOutMethodsOfClass: aClass class on: filer.
	filer close.

	"Flag the class as being saved, i.e. no longer changed"
	aClass isChanged: false!

flushChanges
	"Private - Perform a full flush (i.e. flush OS file buffers) on the change log so 
	that change log file is guaranteed to be up-to-date. This should be performed before 
	an image save to guarantee that source is not lost."

	self changesStream fullFlush
!

getSourceFromDescriptor: sourceDescriptor
	"Answer the <readableString> source corresponding to the specified <integer> 
	descriptor, sourceDescriptor, from the receiver's source files. Note that the descriptor
	is allowed to be nil (in which case the answer is the empty string), or some other
	non-integer <readableString> object directly representing the source."

	| filer |
	filer := self sourceFileFromDescriptor: sourceDescriptor.
	filer notNil 
		ifTrue: [^mutex critical: [filer getSourceFromDescriptor: sourceDescriptor]]
		ifFalse: 
			[(sourceDescriptor isNil or: [sourceDescriptor isInteger]) 
				ifFalse: [^sourceDescriptor asString]].
	^''!

getSourceOfMethod: aCompiledMethod
	"Answer the source of the method, aCompiledMethod, from the receiver's source files."

	| source |
	source := self getSourceFromDescriptor: aCompiledMethod sourceDescriptor.
	^source isEmpty 
		ifTrue: ['"Source currently unavailable"']
		ifFalse: [source]!

hasMethodChanged: aCompiledMethod
	"Private - Answer whether the receiver has been 'changed' (i.e. it has source in
	the change log)."

	^(self sourceIndexFromDescriptor: aCompiledMethod sourceDescriptor) == ChangesIndex!

hasSources
	"Private - Answer whether the the sources and changes files are available."

	^self changesStream notNil and: [self sourcesFileStream notNil]!

ignoreSources
	"Private - Initialize the receiver so that no source is available"

	SourceFiles
		at: ChangesIndex put: nil;
		at: SourcesIndex put: nil.!

initialize
	"N.B. This must be a mutex as, for example,when copying a methods source from one source stream from another 
	re-entry will occur."

	mutex := Mutex new!

isMethodChanged: aCompiledMethod 
	"Private - Answer whether the <CompiledMethod> argument is 'changed' (i.e. it has been
	changed since its class was last saved)."

	"Implementation Note: Its faster to lookup the class 'first change' index last, because it
	is stored in a property."

	^(self hasMethodChanged: aCompiledMethod) and: 
			[(aCompiledMethod isLoose 
				ifTrue: [aCompiledMethod owningPackage changeIndex]
				ifFalse: [aCompiledMethod methodClass instanceClass changeIndex]) 
					ifNil: [false]
					ifNotNil: [:i | (self changePositionOf: aCompiledMethod) >= i]]!

logChanged: aSourceObject
	"File out the changed <sourceObject>, aSourceObject, to the change log."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[aSourceObject fileOutOn: logger.
					logger flush]]!

logComment: aString
	"Record aString to the change log as a comment. All comments
	logged are prefixed with a timestamp.
	N.B. Logging requests should be directed through the SessionManager."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: [self logComment: aString to: logger]]!

logComment: aString to: aSourceFiler
	"Private - Record aString to the specified source file as a comment. All comments
	logged are prefixed with a timestamp."

	aSourceFiler emitComment: TimeStamp current displayString, ': ', aString; cr!

logEvaluate: aString
	"Record aString to the change log as an expression which has been evaluated."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[logger
						fileOutExpression: aString;
						flush]]!

newSourceFiler: path
	"Private - Answer a new <SourceFiler> on the specified path with the default
	format. Any existing file with at the specified path is truncated."

	| answer dir |
	dir := File splitPathFrom: path.
	(File isDirectory: dir) ifFalse: [File createDirectoryPath: dir].
	answer := self sourceFilerOn: (FileStream write: path).
	self emitFileOutHeaderOn: answer.
	^answer!

onExit
	"Private - The system is about to exit, close the source files."

	SourceFiles do: [:f | f notNil ifTrue: [f close]]
!

openChangesFile: filePath 
	"Private - Open the change log file and record it in SourceFiles at: 2."

	| stream |
	stream := FileStream readWrite: (self changesFileNameFromPath: filePath).
	SourceFiles 
		at: ChangesIndex 
			put: ((self chunkFilerOn: stream) sourceFileIndex: ChangesIndex; yourself)!

openNewChangesFile: aString 
	| changesFileName |
	changesFileName := self changesFileName.
	self closeChangesFile.
	File
		delete: changesFileName;
		rename: aString to: changesFileName.
	^self openChangesFile: changesFileName!

openSources
	"Private - Initialize source streams -to the defaults for the current session"

	self openSources: SessionManager current imagePath!

openSources: aString
	"Private - Initialize source streams - otherwise we'll not be able to see any source code.
	This should be done very early on in the startup."

	self closeSources.
	[self basicOpenSources: aString] on: FileException do: [:aFileException |
		aFileException notify.
		self ignoreSources]!

openSourcesFile: filePath 
	"Private - Opens a big sources file and record it in SourceFiles at: 1."

	| stream |
	stream := FileStream read: (self sourcesFileNameFromPath: filePath).
	SourceFiles 
		at: SourcesIndex 
		put: ((self sourceFilerOn: stream) sourceFileIndex: SourcesIndex; yourself)!

packageManager
	"Private - Answer the package manager to be used by the receiver."

	^Package manager!

sourceFileFromDescriptor: sourceDescriptor
	"Private - Answer the <SourceFiler> corresponding to the <integer> source descriptor,
	sourceDescriptor, which encodes the index of the filer in its first 4 bits. The remaining
	bits are the unique identifier used by that filer to locate the source for that object. If
	the specified source descriptor is not actually an integer (which is permitted) then answer
	nil, in which case the source descriptor is expected to be an object which can be resolved
	to the source by sending it the #asString method."

	^SourceFiles at: (self sourceIndexFromDescriptor: sourceDescriptor) ifAbsent: []!

sourceFilerClass
	"Answer the class of <SourceFiler> used by the receiver to write source files."

	^ChunkSourceFiler!

sourceFilerOn: aStream
	"Answer a <SourceFiler> on the <puttableStream>, aWriteStream."

	^self sourceFilerClass on: aStream!

sourceIndexFromDescriptor: sourceObject 
	"Private - Answer an index into the SourceFiles array which specifies where the source of the 
	method whose source descriptor is, sourceObject, or 0 if the sourceObject is not an <integer>
	source descriptor."

	^sourceObject isInteger ifTrue: [sourceObject bitAnd: 16rF] ifFalse: [0]!

sourcesExtension
	"Private - Answer the suffix for the sources file"

	^'sml'!

sourcesFileName
	"Answer the file name for the current sources file."

	^self sourcesFileStream name!

sourcesFileNameFromPath: filePath
	"Private - Answer a file name for a source file at the specified path."

	^File path: filePath extension: self sourcesExtension!

sourcesFileStream
	"Private - Answer the FileStream open on the big sources file."

	^(SourceFiles at: SourcesIndex) ifNotNil: [:sourceFile | sourceFile stream]!

storeCategoriesForClass: class
	"Private - Store the categories of the <ClassDescription>, class, to
	the change log so that they may be reloaded later."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[logger
						emitCategoriesOfClass: class;
						flush]]!

storeCategoriesForMethod: method
	"Private - Store the categories of the <CompiledMethod>, method, to the change
	log so that they may be reloaded later."

	self changesFiler ifNotNil: 
			[:logger | 
			mutex critical: 
					[logger
						emitCategoriesOfMethod: method;
						cr;
						flush]]!

storeCommentString: aString forClass: aClass 
	"Private - Append the <readableString> comment, aString, for the <Class>, aClass, to the
	change log, saving the position and index so that it may be retrieved later. If a valid
	source file is not available then just store aString directly in the class."

	self changesFiler 
		ifNil: [aClass sourceDescriptor: aString]
		ifNotNil: 
			[:filer | 
			mutex critical: 
					[filer
						storeCommentString: aString forClass: aClass;
						flush]]!

storeCommentString: aString forPackage: aPackage 
	"Private - Append the <readableString> comment, aString, for the <Package>, aPackage, to the
	change log, saving the position and index so that it may be retrieved later. If a valid
	source file is not available then just store aString directly in the package."

	self changesFiler 
		ifNil: [aPackage sourceDescriptor: aString]
		ifNotNil: 
			[:filer | 
			mutex critical: 
					[filer
						storeCommentString: aString forPackage: aPackage;
						flush]]!

storeGUIDForClass: class
	"Private - Append the GUID of the <Class>, class, to the change log in a evaluable chunk."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[logger
						emitGUIDOfClass: class;
						flush]]!

storeSourceString: aString forMethod: aCompiledMethod
	"Private - Append the source, aString, for the method, aCompiledMethod, 
	to the change log, saving the position and index so that it may be 
	retrieved later.
	If a valid source file is not available then just store aString
	directly in the method."

	| logger |
	(logger := self changesFiler) isNil 
		ifTrue: [aCompiledMethod sourceDescriptor: aString]
		ifFalse: [mutex critical: [logger storeSourceString: aString forMethod: aCompiledMethod]]!

truncateChanges
	"Private - Truncate the change log.
	WARNING: If you do this you will lose the source of all changes since the
	last #compressSources."

	mutex critical: 
			[| chgFile |
			chgFile := self changesFileName.
			self closeChangesFile.
			(FileStream write: chgFile) close.	"truncate it"
			self openChangesFile: chgFile]! !

StackFrame comment:
'StackFrame encapsulates behaviour of an activation record for use by the development tools (especially the debugger) and other reflective activities. A StackFrame is only valid as a snapshot of <Process> state (e.g. when the process is suspended, as it is when being debugged).

Dolphin''s activation records are not objects, in fact they are just range of slots in the Process stack, so this class is employed to stand in and wrap those records.

The layout of a stack frame is:

	Method (CompiledCode subinstance)
	Environment (pointer to environment/context object, or nil if the activation does not require one)
	Calling stack frame address
	Instruction Pointer (offset into methods byte codes)
	Stack Pointer (address in Process stack)
	Base Pointer (address of stack temps, which preceed the stack frame)

An activation''s arguments and receiver preceed the frame, with the arguments being pointed at by the frames BP. The receiver is at BP-1, with arguments at BP+0..BP+n-1, where n is the number of arguments. 

If the activation is for a block then any copied values it contains are pushed onto the stack immediately after the arguments. Subsequently the copied values are accessed using normal push temp instructions (they will never be written too). After the arguments (and copied values, if any), slots are reserved for the stack temporaries required by the method/block. The frame itself follows these - i.e. all stack temps are directly indexable off BP because they are contiguously allocated before the frame. Any stack working space required by the method/block succeeds the frame.

Note that there is no difference between method and block activations (with one special case, see below). Either may have stack based arguments and temps which are always stored on the stack before the frame. Either may define shared temps that require an "environment" object. This will be an instance of Context, which is not a context in the Smalltalk-80 sense, but a rather simpler object that consists of a vector of the shared temps and a pointer to any outer Context. The outer context chain is used to locate shared temps that a nested block may reference from its enclosing scopes. It is also used to locate the home context when a block performs a ^-return.

When a block does not itself require a context to hold shared temps (the common case in fact), the environment slot is initialised with a reference to the block itself. This is useful for the debugger and other reflective facilities in the image, as otherwise it would not be possible to locate the closure associated with the frame. It is also used by the VM when it needs to create a nested block that requires an outer pointer; the outer pointer of the new block is set to be the same as the outer pointer of the enclosing, contextless, block. i.e. the outer pointer of a block may *not* point to the context of its immediately enclosing block, but to the context of some wider scope such as the method.'!
!StackFrame class methodsFor!

frameClassFor: aProcess at: anInteger 
	"Private - Answer the subclass of the receiver to use to represent a stack frame in aProcess
	at the specified index. Answer nil if the index is out of bounds."

	| env |
	env := aProcess at: anInteger + EnvOffset ifAbsent: [^nil].
	^(env isInteger or: [env isNil]) ifTrue: [self] ifFalse: [env frameClass]!

initialize
	"Initialize the class variables of the receiver.

		self initialize 
	"

	"Hmmm, we really need a syntax for declaring constant class variables."

	| pool |
	pool := self classPool.
	pool associationsDo: [:each | each isImmutable: false].
	pool
		at: 'MethodOffset' put: 0;
		at: 'EnvOffset' put: 1;
		at: 'ReturnOffset' put: 2;
		at: 'IPOffset' put: 3;
		at: 'SPOffset' put: 4;
		at: 'BPOffset' put: 5;
		at: 'FrameSize' put: BPOffset + 1.
	pool associationsDo: [:each | each isImmutable: true].
	"The compiler will inline the const refs, making the frame slot accessor methods more efficient"
	self recompileAll!

process: aProcess index: anInteger
	"Private - Answer a new instance of the receiver representing the stack frame in aProcess
	at the specified index in aProcess, or nil if the specified index is out of bounds in the process."

	^(self frameClassFor: aProcess at: anInteger) ifNotNil: 
			[:frameClass | 
			(frameClass new)
				setProcess: aProcess index: anInteger;
				yourself]! !

!StackFrame methodsFor!

= anObject
	"Answer whether the receiver and anObject are considered equivalent.
	Two frames are equal if they are of the same species, are for the same
	Process, and frame pointer."

	^self species == anObject species and: [
		process = anObject process and: [index == anObject index]]
	!

argAt: anInteger
	"Private - Answer the argument indexed, anInteger, from the receiver's stack frame.
	Arguments preceed other temporaries."

	^(anInteger between: 1 and: self argumentCount) 
		ifTrue: [self at: anInteger + self argsOffset]
		ifFalse: [self errorSubscriptBounds: anInteger]!

argsOffset
	^0!

argumentCount
	"Private - Answer the number of arguments to the receivers stack frame, this will 
	vary depending on whether the receiver is a frame for a block or method activation."
	
	^self method argumentCount!

arguments
	"Private - Answer a SequenceableCollection of the receiver's arguments."

	^(1 to: self argumentCount) collect: [:i | self argAt: i]!

asInteger
	"Private - Answer the stack frame index represented by the receiver."

	^index!

at: anInteger
	"Private - Answer the stack temporary indexed, anInteger, from the receivers stack frame."
	
	^(anInteger between: 1 and: self localCount)
		ifTrue: [process at: self bp + anInteger - 1] 
		ifFalse: [self errorSubscriptBounds: anInteger]!

at: anInteger put: anObject
	"Private - Replace the stack temporary indexed, anInteger, in the 
	receiver's stack frame with anObject."
	
	^(anInteger between: 1 and: self localCount)
		ifTrue: [process at: self bp + anInteger - 1 put: anObject] 
		ifFalse: [self errorSubscriptBounds: anInteger]!

basicBP
	"Private - Answer the <SmallInteger> base pointer of the frame. This points
	at the first argument of the activation."

	^process at: index + BPOffset!

basicBP: aSmallInteger 
	"Private - Set the base pointer of the frame. The argument must be a SmallInteger
	pointer (i.e. the address with the bottom bit set) to the first argument associated 
	with the activation. If there are no arguments then it 	will point at the frame itself 
	as the BP is still used to access the receiver, which is in the slot at [BP-1]."

	process at: index + BPOffset put: aSmallInteger!

basicIP
	"Private - Answer the unadjusted SmallInteger IP index from the appropriate stack slot."

	^process at: index + IPOffset!

basicIP: anInteger
	"Private - Set the IP of the process stack frame the receiver represents to
	anInteger (which is an offset from the start of the byte code object of the
	method)."

	process at: index + IPOffset put: anInteger!

basicSender
	"Private - Answer the context which caused the activation that the receiver represents"

	^process at: index + ReturnOffset!

basicSender: spInteger
	"Private - Set the sender of the process stack frame the receiver represents
	to spInteger (address/2 of the sender frame in the same process)."

	^process at: index + ReturnOffset put: spInteger!

basicSP
	"Private - Answer the SmallInteger stack pointer from the appropriate stack slot."

	^process at: index + SPOffset!

basicSP: aSmallInteger 
	"Private - Set the SP of the process stack frame the receiver represents
	to spInteger (address/2 of the receivers TOS in the process)."

	process at: index + SPOffset put: aSmallInteger!

bp
	"Private - Answer the index of first temporary of the frame the receiver represents."

	^process indexOfSP: self basicBP!

bp: anInteger 
	"Private - Set the BP of the process stack frame the receiver represents
	to be pointing at the slot with the specified index."

	self basicBP: (process spOfIndex: anInteger)!

debugPrintString
	^self basicPrintString!

displayOn: aStream 
	"Append a short textual description of the receiver to aStream appropriate
	for displaying in a stack trace."

	"Display processing will fail if this stack frame is dead"

	| method class mClass selector |
	self isDead 
		ifTrue: 
			[aStream nextPutAll: self debugPrintString.
			^self].
	method := self method.
	mClass := method methodClass.
	self receiver 
		ifNil: 
			["Assume a block which has no receiver refs"
			aStream display: mClass]
		ifNotNil: 
			[:receiver | 
			class := receiver basicClass.	"Use basic class to avoid deref'ing proxies"
			aStream nextPutAll: class name.
			mClass == class 
				ifFalse: 
					[aStream
						nextPut: $(;
						display: mClass name;
						nextPut: $)]].
	aStream nextPutAll: '>>'.
	selector := method selector.
	method isUnbound 
		ifTrue: 
			["Method is unbound if it is either not in the class' method dictionary, or it doesn't have the same
			source as that currently in the dictionary"
			aStream nextPutAll: '{unbound}'].
	aStream nextPutAll: selector!

environment
	"Private - Answer the environment associated with the stack frame, if any.
	This may be nil, a <Context> or a <BlockClosure>."

	| env |
	env := process at: index + EnvOffset.
	^env == 0 ifFalse: [env]!

environment: anObject 
	process at: index + EnvOffset put: anObject!

frameAddress
	^process spOfIndex: index!

frameSize
	"Private - Answer the size of a real stack frame (in Oops)."

	^FrameSize!

getOuter: anInteger 
	| answer |
	answer := self.
	anInteger timesRepeat: 
			[| outer |
			outer := answer outer.
			#todo.	"This is necessary because the Compiler seems to return the wrong outer depth in the temps map in some cases."
			outer isInteger ifTrue: [^answer].
			answer := outer].
	^answer!

hash
	"Answer the SmallInteger hash value for the receiver.

	Implemented here because equivalent objects (i.e. those that answer 
	true for #=) MUST answer the same hash value, and we override #=."

	^process hash bitXor: index hash!

homeContext
	^self environment ifNotNil: [:env | env home]!

homeFrame
	"Private - Answer a StackFrame to represent the receiver's home, or nil if it has returned."

	| env |
	env := process at: index + EnvOffset.
	^env == 0 
		ifTrue: 
			["Normal method frame without a context"

			self]
		ifFalse: 
			[
			"Context frame, may be block or method"
			env home ifNotNil: 
					[:homeContext | 
					| frame |
					frame := homeContext outer.
					frame == 0 ifFalse: [process frameAtAddress: frame]]]!

index
	"Private - Answer the receiver's frame index."

	^index!

index: anInteger
	"Private - Set the index of the receiver's actual frame in its process' stack to
	be anInteger. Answer the receiver."

	index := anInteger!

ip
	"Private - Answer the instruction pointer index into the bytes of the home method, 
	saved down when the context was last suspended."

	| ip |
	ip := self basicIP.
	^self method isPacked 
		ifTrue: [ip + 1]
		ifFalse: [ip - self ipBias]
!

ip: anInteger
	"Private - Set the IP of the process stack frame the receiver represents to
	anInteger (which is an index into the byte codes of the method)."

	self basicIP: (self method isPacked ifTrue: [anInteger - 1] ifFalse: [anInteger + self ipBias])!

ipBias
	"Private - Answer the bias of an IP index to the true IP offset in
	an compiled code object."

	^MemoryManager current objectHeaderSize - 1!

isBlockFrame
	^false!

isDead
	"Private - Answer whether this is a dead stack frame (i.e. one which has returned).
	Note that this is only an indication."

	^self index + BPOffset > process size!

isRestartable
	"Private - Answer whether this frame is restartable. Some methods, such as
	callback entry points, cannot be restarted at all, others not reliably."

	^self sender notNil and: [ | method |
		method := self method.
		method isExpression or: [
			method categories allSatisfy: [:c | c name ~= 'not restartable']]]!

localAt: anInteger
	"Private - Answer the argument indexed, anInteger, from the receiver's stack frame."

	^self at: anInteger + self argumentCount!

localCount
	"Private - Answer the number of locals variables (stack temporaries and arguments) in the receiver's
	stack frame."
	
	^index - self bp!

method
	"Private - Answer a compiled code object for which the receiver represents a stack frame."

	^process at: index + MethodOffset!

method: aCompiledMethod
	"Private - Set the method of the stack frame."

	process at: index + MethodOffset put: aCompiledMethod!

outer
	^self environment!

printOn: aStream 
	self displayOn: aStream.
	aStream
		nextPutAll: ' @ ';
		print: index!

process
	"Private - Answer the process for which the receiver is representing a stack frame"
	
	^process!

process: aProcess
	"Private - Set the Process in whose stack the receiver's frame resides"

	process := aProcess!

receiver
	"Private - Answer the 'self' of the context. This is at BP-1."

	^process at: self bp - 1!

return: anObject
	"Return anObject from the receiver to its caller."

	| sender |
	sender := self basicSender.
	(sender isNil or: [sender == 0]) ifTrue: [^Processor cannotReturn: anObject].
	Processor returnValue: anObject toFrame: (process indexOfSP: sender)!

sender
	"Private - Answer the invoking/calling/sending StackFrame."

	| sender |
	sender := self basicSender.
	^sender == 0
		ifFalse: [process frameAtAddress: sender]!

sender: aStackFrameOrIndex
	"Private - Set the sender of the process stack frame the receiver represents
	to aStackFrameOrIndex."

	self basicSender: (process spOfIndex: aStackFrameOrIndex asInteger)!

setProcess: aProcess index: anInteger
	"Private - Set the Process in whose stack the receiver's frame resides
	and the index of the frame in that stack."

	process := aProcess.
	index := anInteger!

sp
	"Private - Answer the index into the process stack which is the TOS for the receivers
	corresponding activation record"

	^process indexOfSP: self basicSP!

sp: anIntegerIndex
	"Private - Set the SP of the process stack frame the receiver represents
	to the slot at the specified index."

	self basicSP: (process spOfIndex: anIntegerIndex)!

temp: depthInteger at: indexInteger 
	"Private - Answer the stack temporary indexed, anInteger, from the receivers stack frame."

	| env |
	env := self getOuter: depthInteger.
	^env at: indexInteger!

tempNames
	"Private - Answer a list of temporaries in-scope for the instruction before the 
	receiver's ip. This may include 'unnamed' temporaries which are not in scope,
	but which are placeholders for temporaries reserved for previous blocks."

	^self temps collect: [:each | each first]!

temps
	^self tempsBeforeIp: self ip!

tempsBeforeIp: anInteger 
	"Private - Answer a list of temporaries for the instruction before the specified ip."

	^anInteger isNil 
		ifTrue: [Array new]
		ifFalse: [self method debugInfo tempsAtIp: anInteger - 1]!

textMap
	"Private - Answer the map between source text and ip values for the receiver's method."

	^self method textMap! !

STBClassConversion comment:
''!
!STBClassConversion class methodsFor!

forFiler: anSTBInFiler class: aClass version: oldVersion prefix: anInteger 
	"Answer a new instance representing the STB format of oldVersion of aClass."

	| format |
	format := self new 
				version: oldVersion
				prefix: anInteger
				filer: anSTBInFiler.
	format converterBlock: (aClass stbConvertFrom: format).
	^format! !

!STBClassConversion methodsFor!

converterBlock
	"Answer the receiver's converterBlock.
	The block should expect a single argument being the old object
	represented by:
		an Array if it was stored as pointers, or
		a ByteArray if it was stored as bytes.
	The block should answer a new object initialised from the data
	contained in the block parameter."

	^converterBlock!

converterBlock: aBlock
	"Set the receiver's converterBlock inst var to aBlock.
	The block should expect a single argument being the old object
	represented by:
		an Array if it was stored as pointers, or
		a ByteArray if it was stored as bytes.
	The block should answer a new object initialised from the data
	contained in the block parameter."

	converterBlock := aBlock!

instSize
	"Answer the receiver's instSize inst var."

	^instSize!

isBytes
	"Answer the receiver's isBytes inst var."

	^isBytes!

isUpgrading
	^filer isUpgrading!

isVariable
	"Answer the receiver's isVariable inst var."

	^isVariable!

prefix: anSTBPrefix
	"Initialise the receiver from the details contained in anSTBPrefix."

	instSize := anSTBPrefix instSize.
	isBytes := anSTBPrefix isBytes.
	isVariable := anSTBPrefix isVariable.!

version
	"Answer the receiver's version inst var."

	^version!

version: versionInteger prefix: anInteger filer: anSTBInFiler 
	"Private - Initialise the receiver from the arguments."

	version := versionInteger.
	instSize := (anInteger bitShift: InstSizeShift) bitAnd: InstSizeMask.
	isBytes := anInteger allMask: BytesMask.
	isVariable := anInteger allMask: VariableMask.
	filer := anSTBInFiler! !

STBFiler comment:
''!
!STBFiler class methodsFor!

errorInconsistentSTB: anObject 
	"Private - Signal an STBError indicating that the stream being
	read contains inconsistent STB data."

	STBError signal: ('<2s> input stream is inconsistent (object <1p> referenced but not yet defined)' 
				expandMacrosWith: anObject
				with: self signature)!

errorNotSTB
	"Private - Signal an STBError indicating that the stream being
	read is not in Smalltalk Binary (STB) format."

	STBError signal: ('Input stream not in <1s> format' expandMacrosWith: self signature)!

errorUnrecognisedClass: aClass version: version 
	"Private - Signal an STBError indicating that the STB data contains
	instances of aClass of version that we don't know how to convert."

	STBError 
		signal: self signature , ' contains a version ' , version displayString , ' instance of ' 
				, aClass name , ' and is unable to convert it.'!

errorVersion: anInteger 
	"Private - Signal an STBError indicating that the stream being
	read has been written in a different version of STB."

	^STBError 
		signal: ('Input stream is an incompatible <2s> format (version <1d>)' expandMacrosWith: anInteger
				with: self signature)!

fixedClasses
	"Answer a <sequencedReadableCollection> of the classes that are pre-registered in every STB
	file. These make it possible to binary file the classes STBClassProxy and String. Also these
	clases are almost always needed, so we can save space pre-registering them so that they
	don't need to be written into the filer."

	"Note that pre-registering classes does not inflate the size of the binary file, it just
	pre-allocates a range of indices for fixed uses. Changing the order of these (or deleting
	registrations) will break existing binary files. Lastly a consequence of pre-registering
	these classes is that normal STB versioning will have no effect - the #stbVersion is only
	checked when a class is first read from the file. In order to version these classes it is
	necessary to increment the global STB version number."

	^#(##(String) ##(Array) ##(ByteArray) ##(LargeInteger) ##(STBClassProxy) ##(STBMetaclassProxy) ##(Symbol) ##(STBCollectionProxy) ##(OrderedCollection) ##(STBIdentityDictionaryProxy) ##(LookupTable) ##(IdentityDictionary))!

on: aStream
	"Answer a new instance attached to the binary stream aStream."

	^self new
		stream: aStream;
		initialize!

signature
	"Private - Answer the signature that identifies the data as
	being in Smalltalk Binary (STB) format."

	^##('!!STB ' asByteArray)
!

version
	"Private - Answer the version number of the format produced by the receiver.
		Version 1 - Preregisters certain commonly occurring classes
		Version 2 - Delegates save/load to class, format changed for certain pre-registered classes.
		Version 3 - Only writes basicSize for objects of variable classes."

	^3
! !

!STBFiler methodsFor!

atEnd
	"Answer true if the receiver is positioned at end of its stream."

	^stream atEnd

!

context
	"Answers the context for objects read by the receiver"

	^context!

context: anObject
	"Sets the context for objects read by the receiver to anObject. This may be,
	for example, the parent window of a window being read."

	context := anObject!

initialize
	version isNil ifTrue: [version := self class version].
	self reset.
	^self!

position: anInteger
	"Position the receiver's stream to anInteger, read/write a header at this
	place and prepare it for a new input or output session."

	stream position: anInteger.
	self reset.!

register: anObject 
	"Register an object has having been seen before in the STB stream. Answer the unique object reference."

	^self subclassResponsibility!

reset
	"Private - Reset the instance. We pre-register objects that must never be recreated - note
	that if the 'fixed' list of pre-registered objects is changed, then the STB version must be
	changed and the old versions handled appropriately."

	self
		register: true;
		register: false;
		register: Smalltalk;
		register: Processor.
	version > 0 ifFalse: [^self].
	self class fixedClasses do: [:each | self register: each].
	self setRefOffset: 24!

setRefOffset: anInteger
	^self subclassResponsibility!

stream
	"Answer the stream to which the receiver is attached."

	^stream!

stream: aStream
	"Set stream to aStream."

	stream := aStream!

version
	^version!

version: anInteger
	version := anInteger! !

STBPrefix comment:
'STBPrefix represents the object prefix encoding used in an STB binary file stream. It encapsulates much of the complexity of the data encoding performed by the STBOutFiler and STBInFiler classes. As the data encoding has been designed to achieve a reasonably compact format there are some restrictions on the order in which the methods can be called.

Instance Variables:

	dword		The actual 32-bit <Integer> encoding

Pools:
	STBPrefixConstants	<PoolConstantsDictionary> containing bit masks for testing the encoding.


The encodings are as follows (this is best viewed in a non-proportional font):

	SSSSSSSS SSSSSSSS SSSSSSSS SSSSSS11    a SmallInteger
	RRRRRRRR RRRRRRRR RRRRRRRR RRRR0000    an Object Reference
	RRRRRRRR RRRRRRRR RRRRRRRR RRRR0010    a Class Reference (Non-proxy object)
	???????? ????CCCC CCCCCCCC CCCC0100    a Character
	LLLLLLLL LLLLLLLL IIIIIIII ?NVB0110    an Initial Class prefix (to Non-proxy object)
	???????? ???????? ???????? ????1000    a Literal Object (STL filters only)
	RRRRRRRR RRRRRRRR RRRRRRRR RRRR1010    a Class Reference (Proxy object)
	???????? ???????? ???????? ????1100    RESERVED
	LLLLLLLL LLLLLLLL IIIIIIII ?NVB1110    an Initial Class prefix (to Proxy object)
	                            |||||||
	                            |||||| --> isSmallInteger
	                            ||||| ---> isDataPrefix
	                            |||| ----> isClassPrefix
	                            ||| -----> isProxy
	                            || ------> isBytes
	                            | -------> isVariable
	                             --------> isNonZeroVersion

	0SSSSSSS SSSSSSSS SSSSSSSS SSSSSSS1 -> 30 bit SmallInteger value (low bit always 1)
	00000000 00000000 CCCCCCCC CCCCCCCC -> 16 bit Charater value
	0000RRRR RRRRRRRR RRRRRRRR RRRRRRRR -> 28 bit Reference index
	00000000 00000000 LLLLLLLL LLLLLLLL -> 16 bit Class name length
	00000000 00000000 00000000 IIIIIIII -> 8 bit Instance size

When testing an instance of this class the tests should be performed in the following order.

	anSTBPrefix isLiteral
		ifTrue: [^the data for the literal follows in the stream].
	anSTBPrefix isSmallInteger
		ifTrue: [^anSTBPrefix smallInteger. to yeild the SmallInteger represented.]
		ifFalse: [
			anSTBPrefix isDataPrefix
				ifFalse: [
					anSTBPrefix isCharacter
						ifTrue: [^anSTBPrefix character]
						ifFalse: [^anSTBPrefix refIndex. to answer the index of an already loaded object.]]
				ifTrue: [
					The data of the object represented will follow the prefix (although perhaps not immediately).
					anSTBPrefix isClassPrefix
						ifFalse: [
							anSTBPrefix refIndex. is the index of the class of the object represented.
							The data of the object represented follows the prefix.]
						ifTrue: [
							anSTBPrefix isNonZeroVersion
								ifTrue: [The integer following the prefix is the version of the class of the object represented].
							anSTBPrefix classLocatorLen. is the number of following bytes containing the name
								of the class of the object represented.
							anSTBPrefix instSize. This is the instance size of the class of the object represented.
							anSTBPrefix isBytes
								ifTrue: [The class of the object represented is made of bytes].
							anSTBPrefix isVariable
								ifTrue: [The class of the object represented is indexable]].
					anSTBPrefix isProxy
						ifTrue: [
							The object represented is a proxy for the real one and should be sent a #fixup:at: message
							to yeild the real object]]]."'!
!STBPrefix class methodsFor!

forCharacter: aCharacter
	"Answer a new instance to prefix aCharacter."

	^self new
		character: aCharacter;
		yourself!

forData
	"Answer a newly initialised instance to prefix a data object."

	^self fromInteger: DataPrefixMask!

forLiteral
	"Answer a newly initialised instance to prefix a literal object."

	^self fromInteger: LiteralPrefixMask !

forObjectRef: anInteger
	"Answer a new instance to prefix an object that has already been output."

	^self new
		objectRef: anInteger;
		yourself!

forProxy
	"Answer a newly initialised instance to prefix a proxy object."

	^self forData
		beProxy;
		yourself!

forSmallInteger: aSmallInteger
	"Answer a new instance to prefix aSmallInteger."

	^self new
		smallInteger: aSmallInteger;
		yourself!

fromInteger: anInteger
	"Answer a new instance initialise from anInteger."

	^self new
		dword: anInteger! !

!STBPrefix methodsFor!

beDataPrefix
	"Set the receiver's isDataPrefix bit flag."

	dword := dword bitOr: DataPrefixMask!

beLiteralPrefix
	"Set the receiver's isLiteralPrefix bit flag."

	dword := dword bitOr: LiteralPrefixMask!

beProxy
	"Set the receiver's isProxy bit flag."

	dword := dword bitOr: ProxyMask!

character
	"Answer the Character represented by the receiver."

	^Character value: (dword bitShift: IndexShift)!

character: aCharacter
	"Make the receiver a prefix to a 'virtual' Character, virtual because
	as we encode aCharacter's value entirely within the prefix no object data need follow."

	dword := (aCharacter asInteger bitShift: IndexShift negated) bitOr: CharacterMask!

class: aClass locator: aString
	"Make the receiver a prefix for an object of a hitherto unencountered class
	aClass with locator aString."

	dword := (dword bitOr: (
			ClassPrefixMask bitOr: (
				(aString size bitShift: 16) bitOr: 
					(aClass instSize bitShift: 8)))).
	aClass isBytes
		ifTrue: [dword := dword bitOr: BytesMask].
	aClass isVariable
		ifTrue: [dword := dword bitOr: VariableMask].
	aClass stbVersion ~= 0
		ifTrue: [dword := dword bitOr: NonZeroVersionMask].!

classLocatorLen
	"Answer the receiver's classLocatorLen field."

	^dword bitShift: -16.!

classRef: anInteger
	"The receiver will prefix a hitherto unencountered object whose class
	has already been output with reference index anInteger.
	As we encode the class reference within the prefix the object data
	immediately follows it."

	dword := dword bitOr: (anInteger bitShift: 4)!

dword
	"Answer the receiver as a 4 byte DWORD."

	^dword
!

dword: anInteger
	"Set the receiver's dword inst var to anInteger.
	Answer the receiver."

	dword := anInteger.
	^self!

instSize
	"Answer the receiver's instSize field."

	^(dword bitShift: InstSizeShift) bitAnd: InstSizeMask!

isBytes
	"Answer the Boolean value of the isBytes bit flag."

	^dword allMask: BytesMask!

isCharacter
	"Answer whether the receiver represents a Character."

	^dword anyMask: CharacterMask!

isClassPrefix
	"Answer the Boolean value of the isClassPrefix bit flag."

	^dword anyMask: ClassPrefixMask!

isDataPrefix
	"Answer the Boolean value of the isDataPrefix bit flag."

	^dword anyMask: DataPrefixMask!

isLiteralPrefix
	"Answer the Boolean value of the isLiteralPrefix bit flag."

	^dword anyMask: LiteralPrefixMask!

isNonZeroVersion
	"Answer the Boolean value of the isNonZeroVersion bit flag."

	^dword anyMask: NonZeroVersionMask!

isProxy
	"Answer the Boolean value of the isProxy bit flag.
	If true, the object that the receiver prefixes is
	a proxy for the object rather than the object itself."

	^dword anyMask: ProxyMask!

isSmallInteger
	"Answer the Boolean value of the isSmallInteger bit flag."

	^dword anyMask: 1!

isVariable
	"Answer the Boolean value of the isVariable bit flag."

	^dword allMask: VariableMask!

objectRef: anInteger
	"Make the receiver a prefix to a 'virtual' object that has already been
	output with index anInteger, virtual because as we encode the reference
	entirely within the prefix no object data need follow."

	dword := anInteger bitShift: 4!

printOn: aStream
	"Append a debugging description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	dword printOn: aStream base: 16 showRadix: true.
	aStream nextPutAll: ': '.
	self isSmallInteger ifTrue: [
		aStream print: self smallInteger]
	ifFalse: [ self isDataPrefix ifFalse: [
		self isCharacter
			 ifTrue: [aStream print: self character]
			ifFalse: [aStream nextPut: 'object ref: '; print: self refIndex]]
	ifTrue: [
		aStream nextPutAll: 'class'.
		self isClassPrefix
			ifTrue: [aStream nextPutAll: ' object']
			ifFalse: [aStream nextPutAll: ' ref: '; print: self refIndex]]].
	aStream nextPut: $)!

refIndex
	"Answer the receiver's object or class reference index."

	^dword bitShift: IndexShift!

smallInteger
	"Answer the receiver decoded into a SmallInteger."

	^dword bitShift: -1!

smallInteger: aSmallInteger
	"Make the receiver a prefix to a 'virtual' SmallInteger, virtual because
	as we encode the integer entirely within the prefix no object data need follow."

	dword := (aSmallInteger bitShift: 1) bitOr: 1! !

STBProxy comment:
''!
!STBProxy class methodsFor!

new
	"Private - Use specialized instance creation methods"

	^self subclassResponsibility! !

!STBProxy methodsFor!

stbFixup: inFiler at: anInteger
	"Answer the object that this one represents.
	As we use become to change the receiver's identity no fixups are required."

	^self become: self value!

value
	"Answer the object that this one represents."

	^self subclassResponsibility! !

Stream comment:
'Stream represents a class of objects which can be used for streaming I/O. Stream itself is abstract.

InstanceVariables
	None.

Class Variables:
	EndOfStreamSignal	<exceptionSignaler/exeptionSelector>. Exception to mark attempts to read off the end of the stream.'!
!Stream class methodsFor!

endOfStreamSignal
	"Answer an exceptionSignaler/exceptionSelector object raised when an attempt is 
	made to read off the end of the stream. Those interested in catching end of 
	Stream exceptions should use this accessor to get the exceptionSelector to pass
	as the first parameter to an #on:do: message. Current the answer is a Signal
	instance, but it could be an Exception subclass in future."

	^EndOfStreamSignal!

initialize
	"Private - Initialize the receiver's class variables.
		Stream initialize
	"

	EndOfStreamSignal := Signal description: 'End of stream'!

new
	"Streams must be instantiated onto something."

	^self shouldNotImplement! !

!Stream methodsFor!

atEnd
	"Answer whether the receiver is at the end of its values."

	^self subclassResponsibility!

close
	"Relinquish any external resources associated with the receiver, and put the
	receiver into a 'closed' state (as appropriate to the subclass). Answer the receiver."

	^self!

contentsSpecies
	"Private - Answer the class of Object to be used when answering collections of elements
	from the receiver."

	^Array!

do: aMonadicValuable 
	"Evaluate the <monadicValuable> argument for each of the receiver's future sequence values,
	terminating only when there are no more future sequence values (i.e. the stream is at an
	end). N.B. If evaluating the valuable has side effects on the receiver stream, then the
	behaviour is undefined."

	[self atEnd] whileFalse: [aMonadicValuable value: self next]!

errorEndOfStream
	"Raise an error to the effect that an attempt was made to read off the end of the collection
	over which the receiver is streaming."

	^self class endOfStreamSignal signalWith: self!

isReadable
	"Answer whether the receiver can be read from (i.e. it implements the gettableStream
	protocol)."

	^false!

isWriteable
	"Answer whether the receiver can be written to (i.e. it implements the puttableStream
	protocol)."

	^false!

next
	"Answer the next object accessible by the receiver."

	"Implementation Note: Must be defined by subclasses which wish to implement the 
	<gettableStream> protocol."

	^self subclassResponsibility!

next: anInteger 
	"Answer a <sequencedReadableCollection> containing the next anInteger number of objects
	accessible by the receiver."

	"Implementation Note: Subclasses should not generally override this method, but the more
	flexible #next:into:startingAt: message which this uses."

	^self 
		next: anInteger
		into: (self contentsSpecies new: anInteger)
		startingAt: 1!

next: countInteger into: aSequenceableCollection startingAt: startInteger 
	"Destructively replace the elements of the <sequenceableCollection> argument in the
	<integer> interval (startAt..startAt+count-1) with the next countInteger elements of the
	receiver. Answer aSequenceableCollection."

	"Implementation Note: This will fail if the receiver is not readable."

	startInteger to: startInteger + countInteger - 1
		do: [:i | aSequenceableCollection at: i put: self next].
	^aSequenceableCollection!

nextAvailable: anInteger 
	"Answer up to anInteger elements of the receiver's collection. Generally, the answer will be
	a collection of the same class as the one accessed by the receiver (though this is
	determined by the receiver), and will contain anInteger elements, or as many as are left in
	the receiver's collection."

	| newStream count |
	count := 0.
	newStream := self contentsSpecies writeStream: anInteger.
	[count == anInteger or: [self atEnd]] whileFalse: 
			[newStream nextPut: self next.
			count := count + 1].
	^newStream contents!

nextMatchFor: anObject 
	"Access the next object and answer whether it is equal to the argument, anObject. Raise an
	end of stream exception (via #next) if there are no more elements in the receiver."

	^anObject = self next!

skipThrough: anObject 
	"Set the receivers position reference to be past the next occurrence of the argument,
	anObject, in the collection. Answer the receiver, or nil if no such occurrence existed."

	"Included for compatibility with VisualWorks - the ANSI standard message #skipTo: should be
	used in preference"

	[self atEnd] whileFalse: [self next = anObject ifTrue: [^self]].
	^nil!

skipTo: anObject 
	"Set the receivers position reference to be past the next occurrence of the argument,
	anObject, in the collection. Answer whether such an occurrence existed."

	[self atEnd] whileFalse: [self next = anObject ifTrue: [^true]].
	^false!

upTo: anObject 
	"Answer a collection of elements starting with the next element accessed by the receiver,
	and up to, not inclusive of, the next element that is equal to anObject. Positions the
	stream after anObject if found. If anObject is not in the collection, answer the entire rest
	of the collection. If the receiver is at its end, answer an empty Collection."

	| newStream nextObject |
	newStream := self contentsSpecies writeStream: 128.
	[self atEnd or: 
			[nextObject := self next.
			nextObject = anObject]] 
		whileFalse: [newStream nextPut: nextObject].
	^newStream contents!

upToEnd
	"Answer a collection consisting of the future sequence values of the receiver (i.e. from the
	current position to the end)."

	| remainder |
	remainder := self contentsSpecies writeStream: 128.
	[self atEnd] whileFalse: [remainder nextPut: self next].
	^remainder contents! !

UndefinedObject comment:
'UndefinedObject is the singleton class of the distinguished object, <nil>.

<nil> is the initial value of all new variables (instance or otherwise), and hence a  primary purpose of UndefinedObject is to provide a means of detecting errors, especially those resulting from the failure to correctly initialize variables.

<nil> is also useful for explicitly representing a null value, e.g. in a variable which has no value. A common use of this type is in conjunction with lazy initialization. In this respect <nil> has a similar purpose to the SQL <null> value.

When interfacing to external functions, etc, <nil> is treated as the null pointer, or zero, as appropriate to the parameter type.

UndefinedObject implements the following ANSI protocols:
	<Object>
	<nil>'!
!UndefinedObject class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new instance of the receiver.
	There can be only one!!"

	^nil! !

!UndefinedObject methodsFor!

_deepCopy: copiesDictionary
	^self!

bindingFor: aString 
	"Answer a variable binding for the named variable in the scope of this class. 
	If there is no such variable, then answer nil."

	^nil!

deepCopy
	"Answer the receiver - there is only one instance, nil."

	^self!

displayOn: aStream
	"Append a representation of the receiver to aStream as a user would want to see it.
	The default is to do nothing, since, from the end-user perspective, the receiver is a null."!

ifNil: aBlock 
	"If the receiver is the nil object, then answer the result of evaluating the
	<niladicValuable>, aBlock, otherwise answer the receiver."

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd."

	^aBlock value!

ifNil: nilBlock ifNotNil: notNilBlock 
	"If the receiver is the nil object, then answer the result of evaluating the
	<niladicValuable>, nilBlock, otherwise answer the result of evaluating the
	<monadicValuable>, notNilBlock, with the receiver as its argument."

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd."

	^nilBlock value!

ifNotNil: aBlock 
	"If the receiver is not the nil object, then answer the result of evaluating the valuable
	argument, aBlock, otherwise answer nil. aBlock can be a <niladicValuable> or a
	<monadicValuable>, in which case it is evaluated with the receiver as its argument, "

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd."

	^self!

ifNotNil: notNilBlock ifNil: nilBlock 
	"If the receiver is the nil object, then answer the result of evaluating the
	<niladicValuable>, nilBlock, otherwise answer the result of evaluating the
	<monadicValuable>, notNilBlock, with the receiver as its argument."

	"Implementation Note: This message is normally inlined by the compiler and so is never sent
	unless #perform'd."

	^nilBlock value!

includesBehavior: aBehavior
	"Answer whether the receiver includes the behavior, aClass
	(i.e. is aBehavior the receiver or a superclass of the receiver)"

	^aBehavior isNil!

isLiteral
	"Answer whether or not the receiver has a literal representation (probably its
	printString) which is directly recognised by the Compiler. Of course nil does."

	^true!

isNil
	"Answer whether the receiver is the manifest constant, nil. Of course it is."

	^true
!

isNull
	"Private - Answer whether the receiver is 'Null'. A Dolphin object is Null
	if it is passed/returned to an external library function as the Null pointer.
	nil is interchangeable with 0 in this respect."

	^true!

name
	"Answer the name of a class."

	^'nil'!

newClassBuilder: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(ClassBuilder new)
		className: aClassSymbol asString;
		instanceVariableString: instVarString;
		classVariableString: classVarString;
		sharedPoolString: poolDictString;
		yourself!

notNil
	"Answer whether the receiver is not the manifest constant, nil. Of course it isn't."

	^false
!

notNull
	"Private - Answer whether the receiver is not 'Null'. See #isNull for
	further explanation."

	^false!

printOn: aStream
	"Append a short textual description of the receiver to <aStream>.
	Note that this override refines #printString to comply with the ANSI 
	protocol <nil>."
	
	aStream nextPutAll: 'nil'!

printString
	"Answer a <readableString> whose characters are a description of the receiver 
	as a developer would want to see it."

	^'nil'!

shallowCopy
	"Answer the receiver - there is only one instance, nil."

	^self!

subclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		modifyOrCreate!

subclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString category: aCategoryOrString
	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		categoryNames: (Array with: aCategoryOrString);
		modifyOrCreate!

subclass: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString
		classInstanceVariableNames: classInstVarString
	"If aClassSymbol is not an existing class then create and answer a new fixed-pointer subclass,
	otherwise modify the class with name aClassSymbol to have the indicated features and answer it.
	Subclasses of nil are root classes, like Object, and special care is needed in their definition. 
	It is also the case that many modifications of Object are illegal (it cannot have named instance 
	variables for example)."

	| subclass |
	subclass := self 
				subclass: aClassSymbol
				instanceVariableNames: instVarString
				classVariableNames: classVarString
				poolDictionaries: poolDictString.
	subclass class instanceVariableNames: classInstVarString.
	^subclass
!

yourAddress
	"Private - Answer the address of the receiver.
	Nil is treated like a NULL pointer."

	^0! !

VersionInfo comment:
'VersionInfo is a wrapper class to simplify access to Win32 DLL and EXE version information.

For example:

	VersionInfo forPath: ''notepad.exe''	"Ctrl+I"

Instance Variables:
	fileInfo		<ByteArray>. Buffer containing the raw version information resource.
	prefix		<String>. Prefix used to access language specific information from the version info. string table.
	fixedInfo		<VS_FIXEDFILEINFO>. The basic version information which is always present.'!
!VersionInfo class methodsFor!

forPath: path
	"Answer a new instance of the receiver which can be used to query the version
	information of the file with the specified path."

	^self new
		fileInfo: (VersionLibrary default getFileVersionInfo: path);
		yourself		!

uninitialize
	"Assist the version library in departing this world"

	Smalltalk at: #VersionLibrary ifPresent: [:lib | lib closeDefault]! !

!VersionInfo methodsFor!

at: valueName
	"Answer the named version information from the receiver."

	| lpstr len |
	lpstr := ExternalAddress new.
	len := self queryValue: self prefix, valueName into: lpstr.
	^len == 0
		ifTrue: ['']
		ifFalse: [String fromAddress: lpstr]!

comments
	^self at: 'Comments'!

fileDescription
	"Answer the <readableString> file name from the receiver."

	^self at: 'FileDescription'!

fileInfo: bytes
	"Private - Set the version data block to the <ByteArray>, bytes."

	fileInfo := bytes!

fileVersionString
	"Answer a String in the form N.N.N.N which specifies the version number of the file."

	^self fixedInfo fileVersionString!

fixedInfo
	"Answer a <VS_FIXEDFILEINFO> containing the standard (fixed)
	version info from the receiver.
	Implementation Note: Cache it for later use."

	fixedInfo isNil
		ifTrue: [fixedInfo := self getFixedInfo].
	^fixedInfo!

formatVersionString: format 
	"Answer a version string formatted as per the Win32 format string, format."

	| major minor |
	major := self productMajor.
	minor := self productMinor.
	^format formatWithArguments: (Array 
				with: self productName
				with: major highWord
				with: major lowWord
				with: minor highWord
				with: minor lowWord)!

getFixedInfo
	"Private - Answer a <VS_FIXEDFILEINFO> containing the standard (fixed)
	version info from the receiver."

	| info lib dwLen |
	dwLen := DWORDBytes new.
	info := VS_FIXEDFILEINFO newPointer.
	lib := VersionLibrary default.
	^(lib verQueryValue: fileInfo lpSubBlock: '\' lplpBuffer: info puLen: dwLen)
		ifTrue: [info]
		ifFalse: [lib systemError]!

getTranslationInfo
	"Private - Get the language/code-page id from the version info block."

	| lpvi len |
	lpvi := ExternalAddress new.
	len := self queryValue: '\VarFileInfo\Translation' into: lpvi.
	self assert: [len >= 4].
	^'%04x%04x' sprintfWith: (lpvi wordAtOffset: 0) with: (lpvi wordAtOffset: 2)!

legalCopyright
	"Answer the <readableString> copyright notice from the receiver."

	^self at: 'LegalCopyright'
!

prefix
	"Private - Answer the <readableString> prefix to be prepended to names in
	order to extract them from the version information."

	prefix isNil
		ifTrue: [prefix := '\StringFileInfo\', self getTranslationInfo, '\'].
	^prefix!

productMajor
	"Answer the <integer> major version number of the product."

	^self fixedInfo dwProductVersionMS!

productMinor
	"Answer the <integer> minor version number of the product."

	^self fixedInfo dwProductVersionLS!

productName
	"Answer the <readableString> product name from the receiver."

	^self at: 'ProductName'!

productVersionString
	"Answer a String in the form N.N.N.N which specifies the version number of the product."

	^self fixedInfo productVersionString!

queryValue: name into: buf
	"Private - Get the language/code-page id from the version info block."

	| dwLen |
	dwLen := DWORDBytes fromInteger: 123.
	VersionLibrary default verQueryValue: fileInfo lpSubBlock: name lplpBuffer: buf puLen: dwLen.
	^dwLen asInteger!

specialBuild
	"Answer the <readableString> product name from the receiver."

	^self at: 'SpecialBuild'! !

ExternalField comment:
''!
!ExternalField class methodsFor!

filler
	"Answer an instance of the receiver which describes a field which will not be used
	(it cannot be read or written)."

	^self new beFiller! !

!ExternalField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	This is the default alignment required for a field of the receiver's type
	when embedded in an array or structure, generally speaking this is the
	same as the byte size."

	^self byteSize!

beFiller
	"Set the receiver's flag to specify that it is a filler field.
	The field will be largely ignored being neither readable nor writeable.
	Answer the receiver."

	self beInaccessible!

byteSize
	"Private - Answer the byteSize of the field the receiver represents."

	^self subclassResponsibility!

emitStaticExpression: operation on: aWriteStream 
	aWriteStream nextPutAll: '##('.
	operation value: aWriteStream.
	aWriteStream nextPut: $)!

isFiller
	"Private - Answer whether the receiver is a filler field."

	^self isInaccessible
!

isFixedSize
	^true!

offset
	"Private - Answer the offset of the receiver's field in its structure template."

	^offset!

offset: anInteger
	"Private - Set the offset of the receiver's field in a structure template to be anInteger."

	offset := anInteger.
	!

printAccessorBody: aSymbol on: aWriteStream 
	"Private - Answer suitable method text for compiling a read-accessor method
	to substitute for the receiver (does not include the selector)"

	aWriteStream nextPut: $^.
	self printAccessorExpression: aSymbol on: aWriteStream.
	self printAccessorExpressionSuffixOn: aWriteStream!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self subclassResponsibility!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"By default, nothing is needed."

	!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self subclassResponsibility!

printOffsetExpression: aSymbol on: aWriteStream 
	self 
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: 0!

printOffsetExpression: aSymbol on: aWriteStream extra: anObject 
	self offset = 0 
		ifTrue: 
			[anObject isInteger 
				ifTrue: [aWriteStream display: anObject]
				ifFalse: [self emitStaticExpression: [:stream | stream display: anObject] on: aWriteStream]]
		ifFalse: 
			[self emitStaticExpression: 
					[:stream | 
					stream
						nextPutAll: '(self ';
						display: #offsetOf:;
						space;
						print: aSymbol;
						nextPut: $).
					anObject ~= 0 
						ifTrue: 
							[aWriteStream
								nextPutAll: ' + ';
								display: anObject]]
				on: aWriteStream]!

printOn: aStream
	"Append a representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; print: self offset; nextPut: $)! !

EmbeddedField comment:
''!
!EmbeddedField class methodsFor!

new
	"Private - Answer an instance of the receiver which describes an embedded attribute.
	This is an error because embedded attributes must include a type, and possibly
	a length."

	^self shouldNotImplement! !

!EmbeddedField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	This is the default alignment required for a field of the receiver's type
	when embedded in an array or structure, generally speaking this is the
	same as the byte size."

	^self fieldClass alignment!

byteSize
	"Private - Answer the byte size of the embedded ExternalStructure the
	receiver represents"

	^self fieldClass byteSize!

fieldClass
	"Private - Answer the class of <ExternalStructure> used to represent the 
	type of this field."

	^fieldClass!

fieldClass: aClass
	"Private - Set the class of object to be used to represent the ExternalField in
	Smalltalk. Answer the receiver."

	fieldClass := aClass!

fieldClassName
	"Private - Answer the name of the class of object to be used to represent 
	the embedded field described by the receiver."

	^self fieldClass name!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	"Note that if returning an ExternalStructure subclass, then the resulting object will be a
	reference (an alias) to the original structure embedded in the contents of the receiving
	ExternalStructure, and therefore modifications to it will also modify the complete
	ExternalStructure. If, however, the structureClass is some other object which responds to
	#fromAddress:, the answer may be a copy of the embedded structure (e.g. subclasses of
	External) - so care is needed when updating the result."

	aWriteStream
		nextPutAll: self fieldClassName;
		nextPutAll: ' fromAddress: (';
		nextPutAll: 'bytes';
		nextPutAll: ' yourAddress'.
	self offset = 0 
		ifFalse: 
			[aWriteStream
				space;
				display: #+;
				space.
			self printOffsetExpression: aSymbol on: aWriteStream].
	aWriteStream nextPut: $)!

printOn: aStream
	"Append a representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; 
		print: self offset;
		nextPutAll: ': ';
		nextPutAll: self fieldClassName;
		nextPut: $)
! !

FillerField comment:
''!
!FillerField class methodsFor!

byteSize: anInteger
	"Answer a FillerField of the specified number of bytes"

	^(self new) byteSize: anInteger; yourself! !

!FillerField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	FillerFields pad to a specified number of bytes, so no further alignment
	is required."

	^1!

byteSize
	"Private - Answer the byte size of the filler data the receiver represents"

	^byteSize!

byteSize: anInteger
	"Private - Set the byte size of the filler data the receiver represents"

	byteSize := anInteger!

canGenerateAccessors
	^false!

initialize
	"Private - Initialize the receiver."
	
	super initialize.
	self beInaccessible!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self shouldNotImplement!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self shouldNotImplement!

readFrom: anExternal
	"Private - Answer the embedded object at the receiver's offset 
	in anExternal."

	^self shouldNotImplement!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the appropriate offset and in the 
	appropriate format for the receiver"

	^self shouldNotImplement! !

PointerField comment:
'PointerField is an <ExternalField> type to represent pointer members of <ExternalStructure>s.'!
!PointerField class methodsFor!

type: aClass
	"Answer a new instance of the receiver which is used for dereferencing
	pointers to objects of type aClass"

	^super new pointerClass: aClass! !

!PointerField methodsFor!

byteSize
	"Private - Answer the byte size of the ExternalField the receiver represents
	Answer the size of a 32-bit pointer"

	^VMConstants.IntPtrSize!

pointerClass
	"Private - Answer the class of Smalltalk object to be used when dereferencing
	pointers of the receiver's type."

	^pointerClass!

pointerClass: aClass
	"Private - Set the class of Smalltalk object to be used when dereferencing
	pointers of the receiver's type. Answer the receiver."

	pointerClass := aClass!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	aWriteStream
		display: self pointerClass;
		space;
		display: #fromAddress:;
		nextPutAll: ' (bytes ';
		display: #intPtrAtOffset:;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream nextPut: $)!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords |
	keywords := #uintPtrAtOffset:put: keywords.
	aWriteStream
		nextPutAll: 'bytes ';
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		space;
		display: keywords second;
		nextPutAll: ' anObject ';
		display: #yourAddress!

readFrom: anExternal 
	"Private - Answer an object of the type pointed at by the receiver in 
	anExternal. WARNING: May be a copy or a reference depending on 
	the behavior of pointerClass (which can be any Behavior which
	has the instance creation method #fromAddress:)"

	^self pointerClass fromAddress: (anExternal intPtrAtOffset: offset)!

writeInto: anExternal value: anObject 
	"Private - Write the address of the externally addressable Smalltalk object, anObject,
	into anExternal at the receiver's offset.
	N.B. Precautions must be taken (such as saving the Object as an
	instance variable of the ExternalStructure which encapsulates anExternal)
	to prevent anObject being garbage collected, which will invalidate its
	address. anObject cannot be saved by the receiver, because it is shared
	among all instances of a subclass of ExternalStructure (it is part of
	the class instance variable 'template')."

	^anExternal uintPtrAtOffset: offset put: anObject yourAddress! !

ScalarField comment:
''!
!ScalarField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A large number of fields are the same size as an integer."

	^VMConstants.IntSize! !

!ScalarField methodsFor!

accessorConverter
	"Private - Answer the converter message to be sent to the value read from the structure to
	convert it to an appropriate Smalltalk object."

	^nil!

accessorMessage
	"Private - Answer the stem of the accessor message used to access the value of the field
	described by the receiver in a structure."

	^self subclassResponsibility!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	This is fixed for ScalarFields."

	^self class byteSize!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	aWriteStream
		nextPutAll: '(bytes ';
		display: self accessorMessage keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream nextPut: $).
	self accessorConverter 
		ifNotNil: 
			[:message | 
			aWriteStream
				space;
				display: message]!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords |
	keywords := self accessorMessage keywords.
	aWriteStream
		nextPutAll: 'bytes';
		space;
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		space;
		display: keywords second;
		nextPutAll: ' anObject'! !

ArrayField comment:
'ArrayField is an <ExternalField> type to represent <ExternalStructure> members which are arrays whose contents are actually embedded in the structure, as opposed to being merely pointed at from the structure.'!
!ArrayField class methodsFor!

type: aClass length: anInteger
	"Answer a new instance of the receiver which is used for describing
	embedded arrays of type aClass, with anInteger elements."

	^self basicNew initialize;
		fieldClass: aClass;
		length: anInteger! !

!ArrayField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	This is the default alignment required for a field of the receiver's type
	when embedded in an array or structure, generally speaking this is the
	same as the byte size."

	^self elementSize!

arrayClass
	"Private - Answer the class of <ExternalArray> that this field type describes."

	^fieldClass!

byteSize
	"Private - Answer the byte size of the embedded array the receiver represents.
	By default we assume that the length of the receiver is specified in bytes."

	"N.B. We use the length variable directly, rather than sending the length message as we need
	the allocation length, not the element count (the latter excludes null-terminators)"

	^length * self elementSize!

elementClass
	"Private - Answer the byte size of the structures/values that constitute
	the elements of the embedded array the receiver represents."

	^self arrayClass elementClass!

elementSize
	"Private - Answer the byte size of the structures/values that constitute
	the elements of the embedded array the receiver represents."

	^self arrayClass elementSize!

elementSizeSelector
	^#elementSize!

length
	"Private - Answer the length of the embedded array represented by the receiver."

	^length!

length: anInteger
	"Private - Set the length (element count) of the embedded array the receiver 
	represents. Answer the receiver."

	length := anInteger!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length of the array"

	aWriteStream
		space;
		display: #length:;
		space.
	self printLengthExpressionOn: aWriteStream!

printElementSizeExpressionBodyOn: stream 
	stream
		display: self arrayClass;
		space;
		display: #elementSize!

printElementSizeExpressionOn: aWriteStream 
	self emitStaticExpression: [:stream | self printElementSizeExpressionBodyOn: stream]
		on: aWriteStream!

printFieldSizeExpressionBodyOn: aWriteStream 
	self printLengthExpressionOn: aWriteStream.
	aWriteStream nextPutAll: ' * '.
	self isFixedSize 
		ifTrue: [self printElementSizeExpressionBodyOn: aWriteStream]
		ifFalse: [self printElementSizeExpressionOn: aWriteStream]!

printFieldSizeExpressionOn: aWriteStream 
	self isFixedSize 
		ifTrue: 
			[self emitStaticExpression: [:stream | self printFieldSizeExpressionBodyOn: stream] on: aWriteStream]
		ifFalse: [self printFieldSizeExpressionBodyOn: aWriteStream]!

printLengthExpressionOn: aWriteStream 
	aWriteStream display: self length!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords |
	aWriteStream
		nextPutAll: '| size |';
		crtab;
		nextPutAll: 'size := (anObject byteSize'.
	"Null terminator is included in the reported byteSize, but not the size/basicSize"
	self arrayClass isNullTerminated 
		ifTrue: 
			[aWriteStream nextPutAll: ' - '.
			self printElementSizeExpressionOn: aWriteStream].
	aWriteStream nextPutAll: ') min: ('.
	self printFieldSizeExpressionOn: aWriteStream.
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	aWriteStream
		nextPutAll: ').';
		crtab;
		nextPutAll: 'anObject ';
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self 
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: 1.
	aWriteStream
		space;
		display: keywords third;
		space.
	self offset = 0 
		ifFalse: 
			[self printOffsetExpression: aSymbol on: aWriteStream.
			aWriteStream nextPutAll: ' + '].
	aWriteStream
		nextPutAll: 'size ';
		display: keywords fourth;
		nextPutAll: ' 1'!

readFrom: anExternal
	"Private - Answer the embedded object at the receiver's offset 
	in anExternal. This may be a copy of the original data
	(e.g. if structureClass is a subclass of External) or a
	reference to the original data (e.g. if structureClass is a
	subclass of ExternalStructure)"

	^self arrayClass fromAddress: anExternal yourAddress + offset length: self length!

writeInto: bytes value: anObject
	"Private - Write the bytes of anObject into anExternal."

	| size |
	size := anObject size min: self length * self elementSize.
	bytes replaceFrom: offset+1 to: offset+size with: anObject startingAt: 1! !

StructureField comment:
'ExternalField Type for embedded structures'!
!StructureField class methodsFor!

type: aClass
	"Answer a new instance of the receiver which is used for describing
	embedded structures of type aClass."

	^self basicNew
		initialize;
		fieldClass: aClass! !

!StructureField methodsFor!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Answer suitable method text for compiling a write-accessor method
	to substitute for the receiver (does not include the selector).
	N.B. In this case we overwrite the entire embedded structure with
	a new one"

	| keywords |
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	aWriteStream
		nextPutAll: 'anObject ';
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self 
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: 1.
	aWriteStream
		space;
		display: keywords third;
		space.
	self 
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: ((String writeStream)
				display: self fieldClass;
				space;
				display: #basicByteSize;
				contents).
	aWriteStream
		space;
		display: keywords fourth;
		space;
		display: 1!

readFrom: anExternal
	"Private - Answer the embedded object at the receiver's offset 
	in anExternal. This may be a copy of the original data
	(e.g. if structureClass is a subclass of External) or a
	reference to the original data (e.g. if structureClass is a
	subclass of ExternalStructure)"

	^self fieldClass fromAddress: anExternal yourAddress + offset!

writeInto: anExternal value: anExternalStructure
	"Private - Write the bytes of anExternalStructure into anExternal."

	anExternalStructure
		replaceBytesOf: anExternal
		from: offset+1
		to: offset+self byteSize
		startingAt: 1! !

ConformantArrayField comment:
'ConformantArrayField is a class of <AttributeDescriptor> which can be used to describe fields of <ExternalStructure>s which are embedded arrays of scalar types who''s number of elements is not known until runtime.'!
!ConformantArrayField methodsFor!

byteSize
	"Private - Answer the byte size of the embedded array the receiver represents"

	^self length * self elementSize!

isFixedSize
	^false!

length
	"Answer the length of the array at the field described by the receiver. The point of a
	conformant array is that we don't know until run time what the length is, so claim there is
	one element."

	^1!

printLengthExpressionOn: aWriteStream 
	aWriteStream
		nextPutAll: 'self ';
		display: length!

readFrom: struct 
	"Private -  Answer a <StructureArray> which references the array
	of structures embedded in the <ExternalStructure>, struct, in the
	field described by the receiver.  The result may be sent #at: and #at:put:
	messages to get/set the actual elements in-place."

	^self arrayClass fromAddress: struct yourAddress + offset length: (struct perform: length)! !

StringField comment:
'<StringField> is an <ExternalField> class which can be used to represent embedded strings fields in <ExternalStructure>s.

StringField can be used for both <String>s and <UnicodeString>s.'!
!StringField class methodsFor!

length: anInteger
	"Answer a new instance of the receiver which is used for describing
	embedded arrays of type aClass, and of byte size anInteger"

	^self type: String length: anInteger! !

!StringField methodsFor!

length
	"Private - Answer the size of object of the receivers fieldClass required to hold the
	number of elements in the field."

	^super length - 1!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"Implementation Note: Revert back to the doing nothing as we don't want to use the length (need
	to trim nulls)."

	!

printElementSizeExpressionBodyOn: aWriteStream 
	aWriteStream display: self arrayClass elementSize!

printElementSizeExpressionOn: aWriteStream 
	self printElementSizeExpressionBodyOn: aWriteStream!

printFieldSizeExpressionOn: aWriteStream 
	| charSize |
	charSize := self arrayClass elementSize.
	charSize > 1 
		ifTrue: 
			[self emitStaticExpression: 
					[:stream | 
					stream
						display: self length;
						nextPutAll: ' * ';
						display: charSize]
				on: aWriteStream]
		ifFalse: [aWriteStream display: self length]!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	"Implementation Note: In this case we overwrite the embedded String, not forgetting to Null
	Terminate it"

	| keywords |
	super printMutatorBody: aSymbol on: aWriteStream.
	aWriteStream
		nextPut: $.;
		crtab;
		nextPutAll: 'bytes '.
	keywords := (self elementSize == 2 ifTrue: [#wordAtOffset:put:] ifFalse: [#byteAtOffset:put:]) 
				keywords.
	aWriteStream
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		nextPutAll: ' + size ';
		display: keywords second;
		space;
		nextPut: $0!

readFrom: anExternal
	"Private - Answer the embedded object at the receiver's offset 
	in anExternal. We trim any trailing nulls."

	^self arrayClass fromAddress: anExternal yourAddress + offset!

writeInto: bytes value: anObject 
	"Private - Write the bytes of anObject into anExternal. Don't forget the Null Terminator"

	| size elemSize |
	elemSize := self elementSize.
	size := anObject byteSize - elemSize min: self length * elemSize.
	bytes 
		replaceFrom: offset + 1
		to: offset + size
		with: anObject
		startingAt: 1.
	"We need 2 null-terminator bytes for a wide-char string of course"
	1 to: elemSize do: [:i | bytes at: offset + size + i put: 0]! !

StructureArrayField comment:
''!
!StructureArrayField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	This is the default alignment required for a field of the receiver's type
	when embedded in an array or structure, generally speaking this is the
	same as the byte size."

	^self fieldClass alignment!

arrayClass
	"Private - Answer the class of <ExternalArray> that this field type describes."

	^StructureArray!

byteSize
	"Private - Answer the byte size of the embedded array the receiver represents"

	^self length * self elementSize!

elementClass
	^self fieldClass!

elementSize
	"Private - Answer the byte size of the structures/values that constitute
	the elements of the embedded array the receiver represents."

	^self fieldClass elementSize!

fieldClassName
	"Private - Answer the name of the class of object to be used to represent 
	the embedded field described by the receiver."

	^self arrayClass name!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aWriteStream.
	aWriteStream
		space;
		display: #elementClass:;
		space;
		display: self fieldClass!

printElementSizeExpressionBodyOn: aWriteStream 
	aWriteStream
		display: self elementClass;
		space;
		display: #basicByteSize!

readFrom: anExternal
	"Private -  Answer a <StructureArray> which references the array
	of structures embedded in the <ExternalStructure>, struct, in the
	field described by the receiver.  The result may be sent #at: and #at:put:
	messages to get/set the actual elements in-place."

	^self arrayClass 
		fromAddress: anExternal yourAddress + offset 
		length: self length
		elementClass: self fieldClass! !

ConformantStructureArrayField comment:
'ConformantStructureArrayField is a class of <AttributeDescriptor> which can be used to describe those fields of <ExternalStructure>s which are themselves embedded arrays of <ExternalStructure>s. For example, give the C++ structure definitions:

	struct PALETTEENTRY {...};
	struct LOGPALETTE {	
		struct LOGPALETTE {
			WORD         palVersion; 
			WORD         palNumEntries; 
			PALETTEENTRY palPalEntry[1]; 
		};

then a template definition for LOGPALETTE might be as follows:

	self
		defineField: #palVersion 	type: WORDField new;
		defineField: #palNumEntries 	type: WORDField new;
		defineField: #palPalEntry 	type: (StructureArrayField type: PALETTEENTRY length: #palNumEntries)

Note: The #byteSize method must be overridden in structures with variable length embedded items, as the base implementation is calculated statically. Furthermore such structures cannot be passed and returned by value because the VM is unable to determine the correct size.

Instance Variables:

None, but we hijack the superclass instance variable ''length'' to hold the selector used to get the length at runtime. This is not terribly clean, but reflects this classes late addition to the design.'!
!ConformantStructureArrayField methodsFor!

isFixedSize
	^false!

length
	"Answer the length of the array at the field described
	by the receiver. We don't know until run time what the length
	is, so claim there is one element."

	^1!

printLengthExpressionOn: aWriteStream 
	aWriteStream
		nextPutAll: 'self ';
		display: length!

readFrom: struct
	"Private -  Answer a <StructureArray> which references the array
	of structures embedded in the <ExternalStructure>, struct, in the
	field described by the receiver.  The result may be sent #at: and #at:put:
	messages to get/set the actual elements in-place."

	^self arrayClass
		fromAddress: struct yourAddress + offset
		length: (struct perform: length)
		elementClass: self elementClass! !

PointerArrayField comment:
''!
!PointerArrayField methodsFor!

alignment
	"Answer the alignment requirements for the receiver.
	All pointers are 32-bits."

	^VMConstants.IntPtrSize!

arrayClass
	"Private - Answer the class of <ExternalArray> that this field type describes."

	^PointerArray!

elementSize
	"Private - Answer the byte size of the structures/values that constitute
	the elements of the embedded array the receiver represents.
	All pointers are 32-bits."

	^VMConstants.IntPtrSize! !

ArrayPointerField comment:
'ArrayPointerField is an <ExternalField> type to represent <ExternalStructure> members which are pointers to arrays.'!
!ArrayPointerField class methodsFor!

type: aClass length: length
	"Answer a new instance of the receiver which is used for dereferencing
	pointers to arrays objects of type aClass, of the specified fixed <integer> length."

	^(super type: aClass) length: length! !

!ArrayPointerField methodsFor!

length
	"Answer the <integer> length of the array pointed at by the field described
	by the receiver. If this is a dynamic value which will vary at runtime depending
	on the structure in which the field is embedded, then answer one."

	^length!

length: elementCountOrSelector
	"Private - Set the length of the array pointed at by the field described
	by the receiver."

	length := elementCountOrSelector!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length of the array"

	aWriteStream
		space;
		display: #length:;
		space.
	self printLengthExpressionOn: aWriteStream!

printLengthExpressionOn: aWriteStream 
	aWriteStream display: self length!

readFrom: anExternal
	"Private - Answer an object of the type pointed at by the receiver in 
	anExternal. WARNING: May be a copy or a reference depending on 
	the behavior of pointerClass (which can be any Behavior which
	has the instance creation method #fromAddress:)"

	^self pointerClass fromAddress: (anExternal sdwordAtOffset: offset) length: self length! !

StructureArrayPointerField comment:
'StructureArrayPointerField is an <ExternalField> type to represent <ExternalStructure> members which are pointers to arrays of structures.'!
!StructureArrayPointerField methodsFor!

elementClass
	"Private - Answer the class of Smalltalk object embedded in the structure
	array pointed at by fields described by the receiver."

	^pointerClass!

pointerClass
	"Private - Answer the class of Smalltalk object to be used when dereferencing
	pointers of the receiver's type."

	^StructureArray!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aWriteStream.
	aWriteStream
		space;
		display: #elementClass:;
		space;
		display: self elementClass!

readFrom: struct
	"Private - Answer a <StructureArray> which references the array of structures
	pointed at by the field described by the receiver in the <ExternalStructure>, struct.
	N.B. The answer is a reference, and modifications to it will update the original buffer."

	^self pointerClass 
		fromAddress: (struct sdwordAtOffset: offset) 
		length: self length
		elementClass: self elementClass! !

ConformantStructureArrayPointerField comment:
'VariableStructureArrayPointerField is an <ExternalField> type to represent <ExternalStructure> members which are pointers to variable length arrays of structures where another field in the structure holds the length of the array, e.g. as in the various OLE counted array structures.'!
!ConformantStructureArrayPointerField methodsFor!

isFixedSize
	^false!

length
	"Answer the length of the array pointed at by the field described
	by the receiver. We don't know until run time what the length
	is, so claim there is one element."

	^1!

printLengthExpressionOn: aWriteStream 
	aWriteStream
		nextPutAll: 'self ';
		display: length!

readFrom: struct
	"Private - Answer a <StructureArray> which references the array of structures
	pointed at by the field described by the receiver in the <ExternalStructure>, struct.
	N.B. The answer is a reference, and modifications to it will update the original buffer."

	^self pointerClass
		fromAddress: (struct sdwordAtOffset: offset) 
		length: (struct perform: length)
		elementClass: self elementClass! !

PointerArrayPointerField comment:
''!
!PointerArrayPointerField methodsFor!

pointerClass
	"Private - Answer the class of Smalltalk object to be used when dereferencing
	pointers of the receiver's type."

	^PointerArray! !

BOOLField comment:
''!
!BOOLField methodsFor!

accessorConverter
	"Private - Answer the converter message to be sent to the value read from the structure to
	convert it to an appropriate Smalltalk object."

	^#asBoolean!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#dwordAtOffset:put:!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	super printMutatorBody: aSymbol on: aWriteStream.
	aWriteStream
		space;
		display: #asParameter!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^(anExternal dwordAtOffset: offset) asBoolean
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^(anExternal dwordAtOffset: offset put: anObject) asBoolean! !

BYTEField comment:
''!
!BYTEField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes."

	^1! !

!BYTEField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#byteAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal byteAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write the value of anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal byteAtOffset: offset put: anObject! !

DOUBLEField comment:
''!
!DOUBLEField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes."

	^VMConstants.DoubleSize! !

!DOUBLEField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#doubleAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal doubleAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal doubleAtOffset: offset put: anObject! !

DWORDField comment:
''!
!DWORDField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A DWORD is always 4 bytes."

	^4! !

!DWORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#dwordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal dwordAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal dwordAtOffset: offset put: anObject! !

FLOATField comment:
''!
!FLOATField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes."

	^VMConstants.FloatSize! !

!FLOATField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#floatAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal floatAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal floatAtOffset: offset put: anObject! !

INT_PTRField comment:
''!
!INT_PTRField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	This size will vary between 32 and 64-bit machines."

	^VMConstants.IntPtrSize! !

!INT_PTRField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#intPtrAtOffset:put:!

readFrom: anExternal 
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal intPtrAtOffset: offset!

writeInto: anExternal value: anObject 
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal intPtrAtOffset: offset put: anObject! !

QWORDField comment:
''!
!QWORDField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A QWORD is always 8 bytes."

	^8! !

!QWORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#qwordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal qwordAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal qwordAtOffset: offset put: anObject! !

SBYTEField comment:
''!
!SBYTEField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes."

	^1! !

!SBYTEField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#sbyteAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal sbyteAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write the value of anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal sbyteAtOffset: offset put: anObject! !

SDWORDField comment:
''!
!SDWORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#sdwordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal sdwordAtOffset: offset!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal sdwordAtOffset: offset put: anObject! !

SQWORDField comment:
''!
!SQWORDField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A QWORD is always 8 bytes."

	^8! !

!SQWORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#sqwordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal sqwordAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal sqwordAtOffset: offset put: anObject! !

SWORDField comment:
''!
!SWORDField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A WORD is always 16-bits/2 bytes."

	^2! !

!SWORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#swordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal wordAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal swordAtOffset: offset put: anObject! !

UINT_PTRField comment:
''!
!UINT_PTRField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	This size will vary between 32 and 64-bit machines."

	^VMConstants.IntPtrSize! !

!UINT_PTRField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#uintPtrAtOffset:put:!

readFrom: anExternal 
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal uintPtrAtOffset: offset!

writeInto: anExternal value: anObject 
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal uintPtrAtOffset: offset put: anObject! !

WORDField comment:
''!
!WORDField class methodsFor!

byteSize
	"Private - Answer the size of the field type the receiver represents in bytes.
	A WORD is always 16-bits/2 bytes."

	^2! !

!WORDField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#wordAtOffset:put:!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal"

	^anExternal wordAtOffset: offset
!

writeInto: anExternal value: anObject
	"Private - Write anObject into anExternal at the receiver's offset, and in a form
	appropriate for the receiver's External type"

	^anExternal wordAtOffset: offset put: anObject! !

HANDLEField comment:
''!
!HANDLEField methodsFor!

accessorConverter
	"Private - Answer the converter message to be sent to the value read from the structure to
	convert it to an appropriate Smalltalk object."

	^#asExternalHandle!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal."

	^(super readFrom: anExternal) asExternalHandle! !

LPVOIDField comment:
''!
!LPVOIDField methodsFor!

accessorConverter
	"Private - Answer the converter message to be sent to the value read from the structure to
	convert it to an appropriate Smalltalk object."

	^#asExternalAddress!

readFrom: anExternal
	"Private - Instantiate an object of the the type the receiver represents
	at the receiver's offset in anExternal."

	^(super readFrom: anExternal) asExternalAddress! !

ClassDescription comment:
'ClassDescription is an abstract class which adds descriptive information such as instance variable names and method categories to Behavior. This additional state and behaviour is generally not required or used by the VM, but is important for the development environment, the compiler in particular.

Instance Variables:
	instanceVariables		<String>. A space separated list of instance variable names.
	methodsCatalogue		<IdentityDictionary> mapping <MethodCategory>s to <Array>s of <Symbol>
	protocols			<Set> of <MethodProtocol>s implemented by (sub-)instances.'!
!ClassDescription methodsFor!

<= aClassDescription
	"Answer whether the receiver is 'less than' aClassDescription.
	By implementing this method, we enable Class objects to be stored
	in a SortedCollection with the default sort block."

	^self name <= aClassDescription name!

>> aSymbol
	^self compiledMethodAt: aSymbol!

addInstVarName: aString
	"Add a new instance variable to the receiver with the specified <readableString> name."

	| newClass |
	newClass := (ClassBuilder forModifying: self)
				instanceVariables: (self instVarNames copyWith: aString);
				modifyExistingClass.
	newClass notNil ifTrue: [newClass logDefinition].
	^newClass!

addProtocol: protocol
	"Private - Add the specified method protocol to the list implemented by the receiver.
	Implementation Note: The protocols are stored by symbolic name in order not to
	require that the <MethodProtocol> objects be present at run-time. Note further
	that this method only adds the protocol to the list directly supported by this class,
	and should not be called directly or the integrity of the protocol will be impaired."

	| protName |
	protName := protocol asSymbol.
	protocols isNil ifTrue: [protocols := IdentitySet new].
	protocols add: protName.
	self allSubclassesDo: [:q | q removeProtocol: protName ifAbsent: []]!

addSharedPool: aPoolDictionary 
	"Add the specified pool dictionary to the list of those referenced by the receiver. 
	Note that this is a low-level operation intended for system use. The <ClassBuilder>
	should be used to modify classes."

	self instanceClass
		setSharedPoolNames: (self sharedPoolNames copyWith: aPoolDictionary name)!

allGetters
	"Private - Answer a <Set> of the instance variable getter methods in the receiver"

	^self withAllSuperclasses inject: Set new
		into: 
			[:getters :each | 
			getters addAll: each getters.
			getters]!

allProtocols
	"Answer a <collection> of all the <MethodProtocol>s implemented by the receiver's
	instances, including those inherited from superclasses."

	| answer |
	answer := IdentitySet new.
	self withAllSuperclassesDo: [ :c | answer addAll: c protocols].
	^answer!

canUnderstandProtocol: protName
	"Answer whether the receiver can understand the named <MethodProtocol>,
	even if it does not necessarily claim to implement it. See also #conformsToProtocol:"

	| protocol |
	protocol := self methodProtocolClass name: protName asSymbol.
	^protocol selectors allSatisfy: [:s | self canUnderstand: s]!

categoriesFor: selector 
	"Answer a chunk reader which will include the selector in
	each of the method category names to be read in.
	If the receiver doesn't actually include the selector, then just stream 
	over the categories and ignore them"

	^(self compiledMethodAt: selector ifAbsent: []) 
		ifNil: [ChunkReader null]
		ifNotNil: 
			[:method | 
			| categories |
			categories := OrderedCollection new.
			ChunkReader do: [:chunk | categories addLast: (self methodCategoryClass name: chunk)]
				atEnd: 
					[method categories: categories.
					method storeCategories]]!

categoriesFor: selector are: categories
	"Compatibility ith IBM Smalltalk fileIn format (which is of the form
	<class> categoriesFor: <selector> are: #([<categoryString>]*).
	Sets the additional categories of a selector if it exists."

	(self includesSelector: selector) ifTrue: [
		categories do: [:categoryString |
			self 
				includeSelector: selector 
				inCategory: (self methodCategoryClass name: categoryString)]]
!

categoriesOfMethod: aCompiledMethod 
	"Private - Answer a <Set> of all the <methodCategory> objects in the receiver
	of which the <CompiledMethod> (assumed to belong to the receiver), 
	method, is a member."

	"Implementation Note: There is a much simpler implementation for this method,
	but we want to avoid running the Unclassified category's inclusion test because
	it is slow and duplicates work we already have to do in enumerating the method
	catalogue. Performance is important as emitting the method categories constitutes
	a large proportion of file-out time. Unfortunately this optimized implementation
	does break encapsulation a little since it relies on the current implementation of
	the methods catalogue."

	"The simple implementation - about one third the speed
	^self methodCategories select: [:category | category includesMethod: method]"

	| answer catClass unclassified aSelector |
	catClass := self methodCategoryClass.
	unclassified := catClass unclassified.
	aSelector := aCompiledMethod selector.
	answer := self whichNonVirtualCategoriesIncludeSelector: aSelector.
	answer isEmpty ifTrue: [answer add: catClass unclassified].
	catClass pseudoCategories do: 
			[:each | 
			(each ~~ unclassified and: [each includesMethod: aCompiledMethod]) 
				ifTrue: [answer add: each]].
	answer add: aCompiledMethod privacyCategory.
	^answer!

classCategoryClass
	"Private - Answer the class of object used to categorize classes.
	Answer nil if the category system is not present."

	^Smalltalk at: #ClassCategory ifAbsent: []!

classPool
	"Answer the dictionary of class variables."

	^self subclassResponsibility!

classVariableString
	"Answer a space separated string of the names of the receiver's class variables"

	| aStream |
	aStream := String writeStream: 40.
	self classPool keys asSortedCollection 
		do: [ :key | aStream nextPutAll: key]
		separatedBy: [aStream space].
	^aStream contents!

comment
	"Answer the class comment for the receiver"

	^self subclassResponsibility!

comment: aString
	"Set the class comment for the receiver to aString"

	^self subclassResponsibility!

compile: aString categories: aCollection
	"Compile the <readableString> argument, aString,  as source code in the context of the receiver
	and add the resulting method to the receiver's method dictionary, in the 
	categories in the <collection> of <MethodCategory>s.
	If the collection of categories does not include a privacy category, then the
	suggestion made by the default <MethodCategorizationPolicy> is chosen.
	If a compile error occurs then a <CompilerNotification> is signalled. 
	Answers the new method or nil if it failed to compile."

	^self 
		compile: aString
		categories: aCollection
		package: nil!

compile: aString categories: categories package: aPackageOrNil 
	"Compile the <readableString> argument, aString, as source code in the context of the
	receiver with the default compilation flags, and add the resulting method to the receiver's
	method dictionary, in the <collection> of <MethodCategory>s, categories. A #methodAdded: or
	#methodUpdated: event (depending on whether the resulting method is new or replaces an
	existing method) is fired with the <CompilationResult> as its argument. Note that a
	#methodCategorized: event will not be generated, even if the set of categories of a
	pre-existing method are changed, because all the necessary information is available with a
	#methodUpdated: event. If the collection of categories does not include a privacy category,
	then the suggestion made by the default MethodCategorizationPolicy is chosen. If a compile
	error occurs then a <CompilerNotification> is signalled. Answers the new method or nil."

	^self 
		compile: aString
		categories: categories
		package: aPackageOrNil
		flags: self defaultCompilationFlags!

compile: aString categories: categories package: aPackageOrNil flags: anInteger 
	"Compile the <readableString> argument, aString, as source code in the context of the
	receiver with the specified compilation flags, and add the resulting method to the
	receiver's method dictionary, in the <collection> of <MethodCategory>s, categories. A
	#methodAdded: or #methodUpdated: event (depending on whether the resulting method is new or
	replaces an existing method) is fired with the <CompilationResult> as its argument. Note
	that a #methodCategorized: event will not be generated, even if the set of categories of a
	pre-existing method are changed, because all the necessary information is available with a
	#methodUpdated: event. If the collection of categories does not include a privacy category,
	then the suggestion made by the default MethodCategorizationPolicy is chosen. If a compile
	error occurs then a <CompilerNotification> is signalled. Answers the new method or nil."

	| method result |
	result := self basicCompile: aString flags: anInteger.
	result notNil 
		ifTrue: 
			[| allCats |
			result package: aPackageOrNil.
			allCats := categories.
			method := result method.
			(allCats anySatisfy: [:c | c isPrivacy]) 
				ifFalse: 
					[(self suggestedPrivacyFor: method) 
						ifNotNil: 
							[:privacy | 
							allCats := (OrderedCollection
										withAll: categories)
										addLast: privacy;
										yourself]].
			"To avoid generating a recategorization event we eschew CompiledMethod>>categories:"
			self methodCategoryClass setMethod: method categories: allCats.
			method storeCategories.
			"Now we can safely trigger #methodAdded/Updated: since the source and categories are now available"
			result fireSystemUpdateEvent].
	^method!

compile: codeString classified: categoryString
	"Compile the argument, code, as source code in the context of the receiver
	and add the resulting method to the receiver's method dictionary.
	The newly compiled method is added to the category identified by the <readableString>,
	cat. If the new method replaces an existing one then the original categorization is maintained.
	If a compile error occurs then a CompilerNotification is signalled. 
	Answers the new method or nil if the compilation failed.
	N.B. This method is present primarily as part of the original ST-80 ClassDescription
	protocol, but is of limited use in a multi-category system like Dolphin. We recommend that
	#compile:categories: be used in preference."

	| method result |
	result := self basicCompile: codeString.
	result notNil 
		ifTrue: 
			[| category |
			method := result method.
			category := self methodCategoryClass name: categoryString asString.
			result isNew 
				ifTrue: [category addMethodSilently: method]
				ifFalse: [category addMethod: method].
			method storeCategories.
			result fireSystemUpdateEvent].
	^method!

conformsToProtocol: protocol
	"Answer whether the receiver conforms to the named <MethodProtocol>."

	| protName |
	protName := protocol asSymbol.
	^(protocols notNil and: [protocols includes: protName]) or: [
		superclass notNil and: [superclass conformsToProtocol: protName]]
!

copy: selector from: class
	"Copy the method with the selector <Symbol>, selector, in <ClassDescription>, 
	class, to the receiver's method dictionary, maintaining any existing categories.
	If a compile error occurs then a CompilerNotification is signalled. 
	Answers the new method or nil."

	^self copy: selector from: class categories: (class compiledMethodAt: selector) categories

!

copy: aSymbol from: aClass categories: aCollection 
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, classifying it in each of the the <Collection> of
	<methodCategory>s specified by the last argument. If a compile error occurs then a
	CompilerNotification is signalled. Answers the new method or nil."

	| method |
	method := aClass compiledMethodAt: aSymbol.
	^self 
		compile: method getSource
		categories: aCollection
		package: method owningPackageIfLoose!

copy: aSymbol from: aClass classified: aString 
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, adding it to the category identified by the final <String>
	argument."

	"This method is primarily present for Smalltalk-80 compatibility, but differs in that as
	Dolphin supports multiple categories, the existing method classifications are retained and
	'cat' is treated as a new classification. The method is recompiled in its new class. If a
	compile error occurs then a CompilerNotification is signalled. Answers the new method or
	nil."

	| categories |
	categories := (aClass compiledMethodAt: aSymbol) categories.
	categories add: (self methodCategoryClass name: aString asString).
	^self 
		copy: aSymbol
		from: aClass
		categories: categories!

copyAll: selectors from: class
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	maintaining the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyAll: selectors from: class classified: cat
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	adding the new methods to the category with <readableString> name, cat,
	as well as the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | 
		(self copy: selector from: class classified: cat) notNil]!

copyAllCategoriesFrom: class
	"Copy all categories of method from the <Behavior>, class, to the receiver.
	Answers whether all of the methods copied successfully."
	
	^class selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyCategory: category from: aClass
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully."

	| cat |
	cat := self methodCategoryClass name: category asString.
	^(cat methodsInBehavior: self) 
		allSatisfy: [:m | (self copy: m selector from: aClass classified: cat) notNil]!

copyCategory: category from: aClass classified: newCategory
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully. The methods are additionally classified
	under the <MethodCategory> named by the <readableString>, newCategory."

	| cat |
	cat := self methodCategoryClass name: category asString.
	^(cat methodsInBehavior: self) 
			allSatisfy: [:m | (self copy: m selector from: aClass classified: newCategory) notNil]!

defaultIcon
	"Answer a suitable default icon to use for this class. Not all classes use their 
	default icon; one must define an appropriate #icon method in each class where the 
	icon required differs from that of the superclass."

	^(self environment at: #Icon) fromId: self defaultIconName.

	!

defaultIconFrom: anExternalResourceLibrary
	"Answer a suitable default icon to use for this class. If anExternalResourceLibrary
	is, for some reason not open, then use the icon for the Object class."

	anExternalResourceLibrary asParameter isNull
		ifTrue: [^Object defaultIcon].
	^(self environment at: #Icon) fromId: self defaultIconName in: anExternalResourceLibrary.

	!

defaultIconName
	"Answer a filename to use for an icon of this class."

	^File composeStem: self name extension: 'ico'.!

defaultResourceIcon
	"Answer a suitable default icon resource to use for this class. Note that this method differs
	from #defaultIcon in that it uses the #resourceLocator of the class to locate the icon file"

	^(self environment at: #Icon) fromId: self defaultResourceIconName.

	!

defaultResourceIconName
	"Answer a filename to use for an icon of this class loaded from the class resources location."

	^self instanceClass resourcesLocator localFileSpecFor: self defaultIconName!

definition
	"Answer the <readableString> definition message, which, when evaluated, will define the
	receiver."

	| strm |
	strm := String writeStream: 256.
	self printDefinitionOn: strm.
	^strm contents!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream nextPutAll: self name
!

getters
	"Private - Answer a <Set> of the instance variable getter methods in the receiver"

	^self methodDictionary values select: [:each | each isGetter]!

includesCategory: category
	"Answer whether the receiver includes the named category."

	^self methodsCatalogue includesKey: (self methodCategoryClass name: category)!

includeSelector: aSelector inCategory: category 
	"Add aSelector to aCategoryString while leaving it in its existing set of categories."

	| catalogue selectors |
	self assert: [category isKindOf: self methodCategoryClass].

	"Ensure a methods catalogue entry exists for the requested category"
	catalogue := self methodsCatalogue.
	(self includesCategory: category) ifFalse: [catalogue at: category put: Array new].

	"Now add to the category if not already present therein"
	((selectors := catalogue at: category) identityIncludes: aSelector) 
		ifFalse: [catalogue at: category put: (selectors copyWith: aSelector)].
	self methodsCatalogue: catalogue!

indexOfInstVar: instVarName
	"Answer the index of the specified inst. var in the receiver, or
	if no matching instance variable, raise a NotFoundError."

	^self allInstVarNames indexOf: instVarName ifAbsent: [self errorNotFound: instVarName]!

indexOfInstVar: instVarName ifAbsent: exceptionHandler
	"Answer the <integer> index of the inst. var of the receiver
	identified by the <readableString> name, instVarName, or
	if no matching instance variable, the result of evaluating the
	<niladicValuable>, exceptionHandler."

	^self allInstVarNames indexOf: instVarName ifAbsent: exceptionHandler!

instanceClass
	"Answer the receiver's singleton instance (the actual class object)."

	^self subclassResponsibility!

instanceVariables: aString 
	"Private - Set the receiver's instanceVariables inst var."

	instanceVariables := (aString notNil and: [aString notEmpty]) ifTrue: [aString]!

instanceVariableString
	"Answer a string containing the names of the instance 
	variables in instances of the receiver, in the order they
	appear in those instances. The names are separated by spaces."

	| aStream |
	instanceVariables isNil ifTrue: [^''].
	instanceVariables class == String ifTrue: [^instanceVariables].
	aStream := String writeStream: 64.
	instanceVariables 
		do: [:instVarName | aStream nextPutAll: instVarName]
		separatedBy: [aStream space].
	^aStream contents!

instVarNames
	"Answer a <sequencedReadableCollection> of the receiver's instance variable 
	names."

	instanceVariables isNil ifTrue: [^#()].
	"This required for bootstrapping purposes only"
	instanceVariables class == Array ifTrue: [^instanceVariables].
	"N.B. This assumes that the names in the instance variable string are separated by exactly one space"
	^instanceVariables subStrings: Character space!

logDefinition
	self sourceManager logEvaluate: self definition!

logRemoveSelector: aSymbol 
	self sourceManager 
		logEvaluate: self name , ' removeSelector: ' , aSymbol printString , ' ifAbsent: []'!

logRemoveSelectors: aCollection 
	| stream |
	stream := String writeStream: 128.
	stream
		print: self;
		space;
		display: #removeSelectors:;
		nextPutAll: ' #('.
	aCollection do: [:each | stream print: each] separatedBy: [stream space].
	stream nextPut: $).
	self sourceManager logEvaluate: stream contents!

methodCategories
	"Answer a <collection> of all the <methodCategory>s in which 
	the receiver's methods are classified."

	^(self realMethodCategories)
		addAll: self methodCategoryClass pseudoCategories;
		yourself!

methodCategoryClass
	"Private - Answer the class of object used to categorize methods in the receiver.
	Implementation Note: This method cannot be stripped because it is required for
	compilation, but we want to allow the class to be stripped, and so answer a
	DeafObject if it has been."

	^Smalltalk at: #MethodCategory ifAbsent: [DeafObject current]!

methodChanged: aCompiledMethod
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self instanceClass methodChanged: aCompiledMethod!

methodProtocol: protocolName attributes: attributes selectors: selectors
	"Instantiate and install the MethodProtocol named by the <Symbol>, protocolName,
	with the attributes named in the <Array> of <Symbol>s, attributes, with the selectors 
	in the <Array> of <Symbol>s selectors."

	
	(self methodProtocolClass name: protocolName)
		attributes: attributes;
		addAllSelectors: selectors;
		addClass: self!

methodProtocolClass
	"Private - Answer the class of object used to represent method protocols for the receiver."

	^Smalltalk at: #MethodProtocol!

methods
	"For compatibility with Visual Smalltalk/Smalltalk Express
	 file out format (both bereft of categories)."

	^self methodsFor!

methodsCatalogue
	"Private - Answer an IdentityDictionary which stores Arrays of selectors
	keyed by category objects."

	^methodsCatalogue ifNil: [IdentityDictionary new]!

methodsCatalogue: mapOrNil
	"Private - Sets the methods catalogue to mapOrNil which stores Arrays of selectors
	keyed by category objects. If the map is empty, then it is reduced to nil to save space."

	methodsCatalogue := (mapOrNil notNil and: [mapOrNil notEmpty])
							ifTrue: [mapOrNil]
!

methodsFor
	"Answer a chunk reader to read and compile method chunks for the receiver.
	New methods are classified into the default category (''unclassified'')."

	^ChunkReader 
		do: [:chunkString | self compile: chunkString]
		inContext: self
		atEnd: []!

owningPackage
	^self instanceClass owningPackage!

printDefinitionOn: target
	"Private - Append the textual definition of the receiver to the <puttableStream>, target."

	^self subclassResponsibility!

printOn: aStream
	"Append the name of the receiver to aStream."

	aStream nextPutAll: self name.
!

protocolNames
	"Private - Answer a <collection> of <Symbol>s, being the names of the
	<MethodProtocol>s  implemented directly by the receiver's instances (i.e. 
	excluding inherited protocols)."

	^protocols ifNil: [IdentitySet new]!

protocols
	"Private - Answer the <collection> of <MethodProtocol>s  implemented 
	directly by the receiver's instances (i.e. excluding inherited protocols)."

	^protocols isNil
		ifTrue: [IdentitySet new]
		ifFalse: [ | mpc |
			mpc := self methodProtocolClass.
			protocols collect: [:p | mpc name: p]]!

protocols: anIdentitySetOrNil
	"Private - Set the protocols collection to anIdentitySetOrNil"

	protocols := anIdentitySetOrNil
!

realMethodCategories
	"Answer a <collection> of all the <methodCategory>s in which 
	the receiver's methods are classified, but excluding pseudo-categories.
	Note, though, that public/private categories are included since
	these are not 'calculated' as such, but based on a flag in the method header."

	| catClass |
	catClass := self methodCategoryClass.
	^self methodsCatalogue keys
		add: catClass public;
		add: catClass private;
		yourself!

removeCategory: category
	"Remove the Category from the receiver. N.B. All the methods belonging to the
	category are removed even if the method belongs to any other categories.
	In other words this removes a category of methods, not just the category."

	self removeSelectors: (((self methodCategoryClass name: category asString) methodsInBehavior: self) 
						collect: [:method | method selector])!

removeInstVarName: aString
	"Remove the instance variable of the receiver with the specified <readableString> name."

	| newClass |
	newClass := (ClassBuilder forModifying: self)
				instanceVariables: (self instVarNames copyWithout: aString);
				modifyExistingClass.
	newClass notNil ifTrue: [	newClass notNil ifTrue: [newClass logDefinition]].
	^newClass!

removeMethodFromNonVirtualCategories: aCompiledMethod 
	"Private - Remove the specified method (assumed to be of the receiver)
	from all the categories under which it is currently classified."

	(self whichNonVirtualCategoriesIncludeSelector: aCompiledMethod selector) 
		do: [:each | each removeMethodSilently: aCompiledMethod]!

removeProtocol: protocol
	"Private - Remove the specified method protocol from the list implemented by the receiver."

	self removeProtocol: protocol ifAbsent: [self protocols errorNotFound: protocol]!

removeProtocol: protocol ifAbsent: exceptionHandler
	"Private - Remove the specified method protocol from the list implemented by the receiver."

	protocols isNil ifTrue: [^exceptionHandler value].
	protocols remove: protocol asSymbol ifAbsent: [^exceptionHandler value].
	protocols isEmpty ifTrue: [protocols := nil]!

removeSelector: aSelector fromCategory: category 
	"Private - Remove aSelector from aCategory. If no selectors are associated with
	aCategory as the outcome of this, then aCategory is removed"

	| catalogue |
	catalogue := self methodsCatalogue.
	(catalogue at: category ifAbsent: []) ifNotNil: 
			[:selectors | 
			| sels |
			(selectors identityIncludes: aSelector) ifFalse: [^self].
			sels := catalogue at: category put: (selectors copyWithout: aSelector).
			sels isEmpty ifTrue: [catalogue removeKey: category].
			self methodsCatalogue: catalogue]!

removeSelector: aSymbol ifAbsent: aBlock 
	"Remove the method with selector, selector, from the receiver's method dictionary, answering
	the removed method. If it is not in the receiver's method dictionary, then answer the 
	result of evaluating aBlock."

	| method |
	method := super removeSelector: aSymbol ifAbsent: [^aBlock value].
	self logRemoveSelector: aSymbol.
	(self canUnderstand: aSymbol) 
		ifFalse: [self removeUnsupportedProtocols: IdentitySet new selector: aSymbol].
	self removeMethodFromNonVirtualCategories: method.
	^method!

removeSelectors: aCollection 
	"Remove each of the <Symbol> selectors in the <collection> argument from the receiver's
	message dictionary. If any of the selectors are not present, they are simply ignored. Answer
	a <collection> of the methods which were actually removed."

	| methods |
	methods := super removeSelectors: aCollection.
	self logRemoveSelectors: aCollection.
	aCollection do: 
			[:each | 
			(self canUnderstand: each) 
				ifFalse: [self removeUnsupportedProtocols: IdentitySet new selector: each]].
	methods do: [:each | self removeMethodFromNonVirtualCategories: each].
	^methods!

removeSharedPool: aPoolDictionary 
	"Remove the specified pool dictionary to the list of those referenced by the receiver. 
	Note that this is a low-level operation intended for system use. The <ClassBuilder>
	should be used to modify classes."

	self instanceClass
		setSharedPoolNames: (self sharedPoolNames remove: aPoolDictionary name; yourself)!

removeUnsupportedProtocols: superUnsupported selector: removedSelector
	"Private - Remove any protocols that are no longer supported after the removal
	of the <selector>, removedSelector, from the receiver. Any removed protocols still 
	supported by subclasses are migrated down."

	| unsupported |
	unsupported := self protocols select: [:p | p includesSelector: removedSelector].
	unsupported do: [:p | p removeClass: self].
	unsupported addAll: superUnsupported.
	self subclasses do: [:s |
		"If the subclass has its own implementation for the selector, then it can still
		 support the protocol, otherwise it might need to remove further protocols"
		(s canUnderstand: removedSelector)
			ifTrue: [unsupported do: [:p | p addClass: s]]
			ifFalse: [s removeUnsupportedProtocols: unsupported selector: removedSelector]]!

renameInstVar: oldString to: newString
	"Private - Rename the instance variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own instance 
	variables , not of one of its superclasses.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access instance variables by index they will remain valid until recompiled. It is the caller's responsibility
	to rewrite and recompile methods that reference the instance variable."

	self setInstanceVariables: (self instVarNames copyReplacing: oldString withObject: newString).
	self logDefinition.
	self environment classUpdated: self!

resourceIdentifierClass
	^Smalltalk at: #ResourceIdentifier!

resourceIdentifiers
	^self resourceSelectors collect: [:each | self resourceIdentifierClass class: self selector: each]!

resourceNames
	^(self resourceSelectors collect: [:each | self resourceIdentifierClass nameFromSelector: each]) 
		asSortedCollection!

resources
	^self resourceIdentifiers collect: [:each | each resource]!

resourceSelectors
	| answer |
	answer := IdentitySet new.
	self resourceSelectorsDo: [:each | answer add: each].
	^answer!

resourceSelectorsDo: aMonadicValuable 
	| prefix |
	prefix := self resourceIdentifierClass selectorPrefix.
	^self class methodDictionary 
		do: [:each | (each selector beginsWith: prefix) ifTrue: [aMonadicValuable value: each selector]]!

selectorsInCategory: category
	"Answer an <Collection> of selector <Symbol>s, of the receiver's methods 
	which are included in the <methodCategory>, category."

	^self methodsCatalogue at: category ifAbsent: [Array new]!

setInstanceVariables: aCollection 
	"Private - Set the instance variable string of the receiver to be the list
	of names in aCollection, separated by spaces."

	instanceVariables := aCollection notEmpty 
				ifTrue: 
					[| aStream |
					aStream := String writeStream: 64.
					aCollection do: [:i | aStream nextPutAll: i] separatedBy: [aStream space].
					aStream contents]!

sharedPoolNames
	"Answer a <Set> of <String>s, being the names of the shared pool dictionaries that
	are specified locally in the receiver (pools are inherited in Dolphin)."

	^self instanceClass sharedPoolNames!

sharedPools
	"Answer a Set of the pools (dictionaries) that are specified locally 
	in the receiver."

	| environment |
	environment := self environment.
	^self sharedPoolNames collect: [:symbol | environment at: symbol ifAbsent: [Dictionary new]]!

sharedVariableString
	"Answer a String containing the names of the Pools accessable
	from the receiver and its instances. The names are separated
	by spaces."

	| aStream |
	aStream := String writeStream: 32.
	self sharedPoolNames asSortedCollection
		do: [:s | aStream nextPutAll: s]
		separatedBy: [aStream space].
	^aStream contents!

sourceManager
	"Answer the receiver's source manager. Answer a DeafObject if none is available."

	^(Smalltalk at: #SourceManager ifAbsent: []) 
		ifNil: [DeafObject current]
		ifNotNil: [:sm | sm default]!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler. In most cases we can
	just bat this right back to the in-filer, and let it read its standard format from the
	stream. Custom format (or read routines) are useful where the standard STB format, and/or
	reader, is too inefficient in terms of space, or time, or both. It can also be used to avoid
	the need to create a proxy class; an example of this in D6 is the filing of symbols, which
	relegates the old STBSymbolProxy class to use only for reading older STB files."

	^anSTBInFiler readObjectOfClass: self format: anSTBClassConversion!

storeCategoriesOfMethod: aCompiledMethod
	aCompiledMethod storeCategories!

storeClassCategories
	"Private - Record the categories of the receiver to the change log.
	The job is simply delegated to the receiver's source manager (if available)."

	self sourceManager storeCategoriesForClass: self!

suggestedPrivacyFor: aCompiledMethod 
	| policy |
	policy := Smalltalk at: #MethodCategorizationPolicy ifAbsent: [].
	^policy notNil ifTrue: [policy default suggestedPrivacyFor: aCompiledMethod]!

whichCategoriesIncludeSelector: aSelector 
	"Private - Answer a <collection> of the 'real' (i.e. non-pseudo or virtual) categories in the 
	receiver's method catalogue which include the specified selector."

	| answer |
	answer := self whichNonVirtualCategoriesIncludeSelector: aSelector.
	"The privacy category is considered 'real' because it is not calculated but based on a flag in the method header."
	answer add: (self compiledMethodAt: aSelector) privacyCategory.
	^answer!

whichNonVirtualCategoriesIncludeSelector: aSelector 
	| answer |
	answer := IdentitySet new: 5.
	self methodsCatalogue keysAndValuesDo: 
			[:eachCategory :eachSelectors | 
			(eachSelectors identityIncludes: aSelector) ifTrue: [answer add: eachCategory]].
	^answer! !

Class comment:
'"Instances" of Class describe the representation and behavior of objects. Class adds more comprehensive programming support facilities to the basic ones provided in the abstract superclass Behavior and more descriptive facilities to the ones provided in the abstract superclass ClassDescription. In particular Class adds the representation for class variable names and shared (pool) variables.

In reality, Class has no instances. All classes in the system are actually instances of a parallel hierarchy of Metaclass instances, but they do have the same shape as Class and are logically, if not physically, instances of it.

Instance Variables:

	name		<Symbol> which is the name of the class
	classPool		<PoolDictionary> mapping class variable name <String>s to values
	sharedPools	<Array> of <Symbol> names of shared variable pools
	comment		<String> comment about the class (like this one), or nil if none.
	classCategories	<Array> of <ClassCategory>. The categories of the class, if any.
	_guid		<GUID>. Unique identifier for the class.
	'!
!Class class methodsFor!

allBehaviors
	"Private - Answer a Set of all of the Behaviors contained in the system.
	N.B. There is currently no specified ordering (hence the answer is a Set)."

	| answer |
	answer := Set new: 1000.
	self allBehaviorsDo: [:behavior | answer add: behavior].
	^answer!

allBehaviorsDo: operation
	"Private - Evaluate the monadic valuable, operation, for each of the Behaviors in the system.
	N.B. No guarantee is made about ordering, except that the operation is evaluated
	for a subclass after its superclass."

	self allClassesDo: [ :class |
		operation value: class.
		operation value: class class]!

allClasses
	"Private - Answer an OrderedCollection of all of the classes in the system, in breadth-first order.
	There is no particular ordering at a particular depth.
	N.B. Do not change this ordering to depth-first without careful thought about the
	implications for the rest of the system (even though it might be faster)."

	| answer roots |
	roots := self allRoots.
	answer := OrderedCollection withAll: roots.
	roots do: [:root | answer addAll: root allSubclasses].
	^answer.!

allClassesDo: operation
	"Private - Evaluate the monadic valuable, operation, for each of the classes in the system.
	N.B. No guarantee is made about ordering, except that the block is evaluated
	for a subclass after its superclass."

	self allRoots do: [:root | root withAllSubclassesDo: operation]!

allMethodsDo: operation
	"Private - Evaluate the monadic valuable, operation, for each and every method in the system
	which is connected into the class hierarchy. No ordering should be assumed."

	self allBehaviorsDo: [:behavior | behavior methodDictionary do: operation]!

allRoots
	"Private - Answer a Collection of all global root classes - ie. those that are subclasses of nil.
	The answered collection will include only global classes. We do a bit of shuffling to ensure that
	Object will be the first class."

	| roots |
	roots := (self basicAllRoots 
				select: [:each | (self environment at: each name ifAbsent: []) == each]) asSet.
	roots remove: Object.
	^(roots asOrderedCollection)
		addFirst: Object;
		yourself!

basicAllRoots
	"Private - Answer a Collection of all root classes - ie. those that are subclasses of nil."

	^(Metaclass primAllInstances select: [:meta | meta instanceClass superclass isNil])
		collect: [:meta | meta instanceClass]!

foldLiteralStrings
	"Fold duplicate literal strings so that there is only a single literal string for each unique character sequence in the image.
	This is should be a safe operation in Dolphin 6 because method literals are immutable.
		Class foldLiteralStrings
	"

	| after total literalStrings |
	literalStrings := Set new.
	total := 0.
	self allMethodsDo: 
			[:each | 
			each whileMutableDo: 
					[1 to: each literalCount
						do: 
							[:i | 
							| literal |
							literal := each literalAt: i.
							literal class == String 
								ifTrue: 
									[total := total + 1.
									literalStrings add: literal.
									each literalAt: i put: (literalStrings find: literal)]]]].
	after := literalStrings size.
	^Array with: total with: after!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!Class methodsFor!

addClassVarName: aString 
	"Add a new class variable to the receiver with the specified <readableString> name.
	Note: This is a low-level operation and does not recompile affected classes. Generally 
	speaking any modification to a class should be made through a <ClassBuilder>."

	| varName |
	varName := aString asString.	"Allow symbolic names too"
	(self withAllSubclasses detect: [:each | (each classPool bindingFor: varName) notNil]
		ifNone: []) ifNotNil: 
				[:existingClass | 
				^self 
					error: aString , ' is already used as a variable name in class ' , existingClass name].
	classPool := self classPool.
	(classPool includesKey: varName) 
		ifFalse: 
			[classPool at: varName put: nil.
			self logDefinition.
			self environment classUpdated: self]!

addSharedPool: aPoolDictionary 
	"Add the argument, aPoolDictionary, as one of the receiver's pool dictionaries. 
	It is an error if the dictionary is already one of the pools.
	Note: This is a low-level operation and does not recompile affected classes. Generally 
	speaking any modification to a class should be made through a <ClassBuilder>."

	| poolName pools |
	poolName := aPoolDictionary name.
	pools := self sharedPoolNames.
	(pools includes: poolName)
		ifTrue: [^self error: 'The dictionary is already in my pool'].
	pools add: poolName.
	sharedPools := pools.!

addToSuper
	"Private - Add the receiver as a subclass of its superclass
	and do the same for the receiver's metaclass buddy."

	super addToSuper.
	self class addToSuper!

basicClassPool
	"Private - Answer the receiver's class pool (dictionary of class variables)."

	^classPool
!

basicClassPool: aDictionaryOrNil
	"Private - Set the receiver's class pool (dictionary of class variables).
	The Associations in this Dictionary are those referenced from CompiledMethod's
	literal frame - if you are calling this method make certain you understand what
	you're doing!!"

	classPool := aDictionaryOrNil!

basicSharedPools: aCollection
	"Private - Set the receiver's shared pools collection."

	sharedPools := aCollection!

bindingFor: aString 
	"Answer a variable binding for the named variable in the scope of this class. 
	If there is no such variable, then answer nil.
	Note that in Dolphin pools are inherited."

	classPool isNil 
		ifFalse: [(classPool bindingFor: aString) ifNotNil: [:classVar | ^classVar]].
	sharedPools isNil 
		ifFalse: 
			[self sharedPools 
				do: [:each | (each bindingFor: aString) ifNotNil: [:sharedVar | ^sharedVar]]].
	^superclass bindingFor: aString!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

categories
	"Answer a <Array> of <ClassCategory>s in which the receiver is included.
	This will always contains at least one entry ('Unclassified' if there are no others)."

	^classCategories ifNil: [Array with: self classCategoryClass unclassified]!

categories: aCollection 
	"Set the Categories of the receiver to those in the specified <collection> of <ClassCategory>s.
	Remove from any other categories."

	| unclassified newCategories oldCategories |
	unclassified := self classCategoryClass unclassified.
	newCategories := aCollection reject: [:c | c = unclassified].
	oldCategories := self classCategories ifNil: [#()].
	(newCategories symmetricDifference: oldCategories) notEmpty ifFalse: [^self].
	self classCategories: newCategories.
	self isChanged: true.
	self storeClassCategories.
	self class environment trigger: #classCategorized: with: self!

categoriesForClass
	"Private - Answer an <ChunkReader> configured for reading the receiver's
	<ClassCategory>s."

	| catclass cats |
	catclass := self classCategoryClass.
	cats := OrderedCollection new.
	^ChunkReader 
		do: [:chunkString | cats addLast: (catclass name: chunkString)]
		atEnd: [self categories: cats]!

category
	"Answer the <ClassCategory> of the receiver or nil if it does not have one.

	If the receiver is associated with a number of category objects then the alphabetically
	first one is answered (the list is maintained in sort order)."

	| categories |
	categories := self categories.
	^categories notEmpty ifTrue: [categories first]!

category: category
	"Set the category of the receiver to be the <ClassCategory> category, or the
	<ClassCategory> named by the <readableString>, category.
	The receiver is removed from any existing categories."

	self categories: (Array with: (self classCategoryClass name: category asString))!

changeIndex
	^self propertyAt: #changeIndex ifAbsent: []!

changeIndexValue: aBlock 
	self propertyManager 
		propertyOf: self
		at: #changeIndex
		ifAbsentPut: aBlock!

classCategories
	"Private - Answer a <collection> of <ClassCategory> objects representing the 
	class categories of which the receiver is a member, or nil if unclassified."

	^classCategories!

classCategories: categoryCollection 
	"Private - Set the class categories of the receiver to categoryCollection."

	classCategories := categoryCollection notEmpty 
				ifTrue: [categoryCollection asSortedCollection asArray]!

classPool
	"Answer the Dictionary of class variables belonging to the receiver.
	N.B. This should not be modified as it may not be the actual class pool
	(though it is guaranteed to have identical contents)."

	^classPool ifNil: [PoolDictionary new]!

classVarNames
	"Answer a Set of the class variable names of the receiver."

	^classPool isNil ifTrue: [Set new] ifFalse: [classPool keys]!

clearGuid
	"Private - Set the receiver's GUID to be the null <GUID>.
	Might be overridden by subclasses which must retain their GUIDs (e.g. COMInterfaces)."

	_guid := nil!

comment
	"Answer the class comment for the receiver."

	^String readFrom: (self sourceManager getSourceFromDescriptor: comment) readStream!

comment: blahBlah
	"Set the class comment for the receiver to the readableString, blahBlah."

	self sourceManager storeCommentString: blahBlah forClass: self.
	self isChanged: true.
	"No need to clear the class caches in this case"
	self environment trigger: #classCommented: with: self!

definitionChunk
	"Answer a chunk string for the definition of the receiver"

	| stream |
	stream := String writeStream: 256.
	(self sourceManager sourceFilerOn: stream) fileOutDefinitionOfClass: self.
	^stream contents!

fileIn
	"File in the receiver's definition from a class file in the receiver's
	package directory."

	self sourceManager fileInPackagedClass: self!

fileOut
	"File out the receiver's definition to a class file in the receiver's
	package directory."

	self sourceManager fileOutPackagedClass: self!

fileOutName
	"Private - Answer the default file name for the class to file out on."

	| path package |
	path := File composeStem: self fileOutStem extension: 'cls'.
	package := self owningPackage.
	package notNil ifTrue: [path := File replacePath: path with: package path].
	^path!

fileOutOn: aSourceFiler
	aSourceFiler fileOutClass: self!

fileOutStem
	"Private - Answer the default file name stem for the class to file out on."

	^self name!

guid
	"Answer the receiver's globally unique id (a 128-bit number allocated/set 
	when the receiver was created or filed in)."

	^_guid ifNil: [GUID null]!

guid: id
	"Private - Set the value of the receiver's 'guid' instance variable to the 
	<GUID>, id.
	N.B. A classes GUID should not normally be changed after the class has
	been created, but should remain with it throughout its life."

	self setGuid: id.
	self storeGUID!

includeInCategory: category
	"Add the receiver to the ClassCategory with specified name, while leaving it in its existing
	set of categories."

	self categories: (self categories asSet add: (self classCategoryClass name: category asString); yourself)!

initializeAfterBinaryLoad
	"Private - Perform any post-binary load initialisation for the class. Ensure all the
	methods are marked as having no source."

	self initializeAfterLoad.
	"self methodDictionary do: [:each | each loseSource].
	self class methodDictionary do: [:each | each loseSource]"!

initializeAfterLoad
	"Perform any post-load initialisation for the class. This includes any specific #initialize
	implementation (but not that #initialize is only sent to classes which directly implement
	#initialize, otherwise we'd end up re-initializing the class variables of the superclass
	every time a new subclass was added).
	There may be some circumstances where an entire hierarchy of classes requires some
	common initialization after load, in which case this message can be overridden."

	"Initialize if necessary"
	(self class includesSelector: #initialize) ifTrue: [self initialize].

	"Flag as not changed"
	self isChanged: false!

instanceClass
	"Answer the receiver's singleton instance (the actual class object)."

	^self!

isChanged
	"Answer true if the receiver or any of it's contents have been changed since
	their changed flag was last reset."

	^self changeIndex notNil!

isChanged: aBoolean 
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self propertyManager isNil ifTrue: [^self].
	"Note that we don't test the existing value of the change flag here, because
	 we want to inform the package regardless (in case it isn't currently changed
	 for some reason)"
	aBoolean 
		ifTrue: 
			[self changeIndexValue: [self sourceManager changesFileSize].
			self notifyPackageOfChange]
		ifFalse: [self removePropertyAt: #changeIndex ifAbsent: []]!

isLiteral
	"Private - Answer whether or not the receiver has a literal representation (probably its
	printString) which is directly recognised by the Compiler"

	^true!

methodChanged: aCompiledMethod 
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self propertyManager isNil ifTrue: [^self].
	self changeIndexValue: [aCompiledMethod changePosition].
	self notifyPackageOfChange!

name
	"Answer a <readableString> that is the name of the receiver
	Implementation Note: For compatibility reasons, the answer is actually a Symbol."

	^name!

newClassBuilder: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(ClassBuilder new)
		superclass: self;
		className: aClassSymbol asString;
		instanceVariableString: instVarString;
		classVariableString: classVarString;
		sharedPoolString: poolDictString;
		yourself!

noClassCategoryName
	"Answer the String name of the ClassCategory used to mark that no
	category has been set for a Class."

	^self classCategoryClass unclassifiedName!

notifyPackageOfChange
	self owningPackage ifNotNil: [:package | package isChanged: true]!

owningPackage
	"Answers the package that owns the receiver or nil if it is not yet owned
	by any package."

	"We use an indirect reference to the Package to avoid referencing
	this development class in a runtime image. The answer should always be nil
	in a runtime application."

	^(self environment at: #Package ifAbsent: []) 
		ifNotNil: [:pkgClass | pkgClass manager packageOfClass: self]!

owningPackage: aPackageOrNil 
	"Set the receiver's <Package> to be the argument. Any current package association is lost.
	Note that setting the owning package of a class to the distinguished '_Uncommitted' package
	is exactly the same as setting it to nil."

	(self environment at: #Package ifAbsent: []) 
		ifNotNil: [:pkgClass | pkgClass manager addClass: self to: aPackageOrNil]!

printDefinitionOn: puttableStream 
	"Private - Append the textual definition of the receiver to the <puttableStream>,
	target. Note that this includes the definition of the receiver's metaclass since
	we now define the whole caboodle using a single message."

	puttableStream
		nextPutAll: self superclass name;
		space;
		nextPutAll: self kindOfSubclass;
		space;
		print: self name;
		crtab;
		nextPutAll: 'instanceVariableNames: ';
		print: self instanceVariableString;
		crtab;
		nextPutAll: 'classVariableNames: ';
		print: self classVariableString;
		crtab;
		nextPutAll: 'poolDictionaries: ';
		print: self sharedVariableString;
		crtab;
		nextPutAll: 'classInstanceVariableNames: ';
		print: self class instanceVariableString!

removeClassVarName: aString
	"Remove the class variable from the receiver with the specified <readableString> name.
	Note: This is a low-level operation and does not recompile affected classes. Generally 
	speaking any modification to a class should be made through a <ClassBuilder>."

	| varName |
	varName := aString asSymbol.
	self classPool removeKey: varName.
	classPool isEmpty ifTrue: [classPool := nil].
	self logDefinition.
	self environment classUpdated: self!

removeFromCategory: category
	"Remove the receiver from the aCategoryOrString, while leaving it in any other
	class categories."

	| classCat |
	classCat := self classCategoryClass name: category asString.
	self categories: (self categories asSet remove: classCat; yourself)!

removeFromSuper
	"Private - Remove the receiver as a subclass of its superclass
	and do the same for the receiver's metaclass buddy."

	super removeFromSuper.
	self class removeFromSuper!

removeFromSystem
	"Private - Remove the receiver from the system. This method will fail if the class has instances
	or subclasses so these must be removed first where ever  possible, which should be done in
	an #uninitialize method. #unitialize is sent immediately before the class is removed, but (like
	#initialize) only if directly implemented by the class - i.e. it will not be sent if the implementation
	is inherited. N.B. Do not supersend #uninitialize from an override, as you may damage a
	superclass which is not being removed."

	self subclasses do: [:each | each removeFromSystem].
	self sourceManager logEvaluate: self name, ' removeFromSystem'.
	ClassBuilder removeClass: self!

removeSharedPool: aPoolDictionary 
	"Remove the argument, aPoolDictionary, as one of the receiver's pool dictionaries. 
	Note: This is a low-level operation and does not recompile affected classes. Generally 
	speaking any modification to a class should be made through a <ClassBuilder>."

	| poolName |
	poolName := aPoolDictionary name.
	self sharedPoolNames remove: poolName.
	sharedPools isEmpty ifTrue: [sharedPools := nil]!

rename: aString
	"Private - Change the name of the receiver to aString.
	N.B. This is the low-level rename operation, and does not rename any references
	to the class."

	| currentName |
	currentName := self name.
	self rename: aString in: self environment.
	self sourceManager logEvaluate: ((String writeStream)
				nextPutAll: currentName;
				space;
				nextPutAll: #rename:;
				space;
				print: aString;
				contents)!

rename: aString in: aSystemDictionary
	"Private - Rename the receiver to aString.
	This will change the receiver's key in aSystemDictionary whilst maintaining the association.
	This means that any existing references will be maintained but method source code will still
	contain the old name and will subsequently fail to compile unless edited.

	We Remove the receiver from the subclass collection of its superclass for the
	duration of the rename just in case the subclass collection is key-sensitive."

	| newName oldName binding |
	self removeFromSuper.
	oldName := name.
	newName := aString asSymbol.
	binding := self environment changeKey: oldName to: newName.
	name := newName.
	self addToSuper.
	"Note how the event is delayed until the class is correctly wired in"
	self environment triggerGlobalRenamed: binding from: oldName!

renameClassVar: oldString to: newString
	"Private - Rename the class variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own class 
	variables , not of one of its superclass'.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access class variables via the binding (Association) they will remain valid until recompiled. It is the 
	caller's responsibility to rewrite and recompile methods that reference the variable."

	self classPool changeKey: oldString to: newString.
	self logDefinition.
	self environment classUpdated: self!

requiresInstallation
	"Answer whether the receiver requires 'installing' into its environment."

	^name notNil!

setClassVarNames: anArray 
	"Private - Change the set of class variables to be those specified in anArray.
	Existing variables which are still required are left untouched, those no
	longer required are deleted, and new ones may be added (initialised to nil).
	Answer whether any class variables were removed as this indicates that a
	recompilation is required."

	| removed added original |
	classPool := self classPool.
	original := classPool keys.
	removed := original difference: anArray.
	removed do: [:each | classPool removeKey: each].
	added := anArray difference: original.
	added do: [:each | classPool at: each put: nil].
	classPool isEmpty ifTrue: [classPool := nil].
	^removed notEmpty or: [added notEmpty and: [self hasCompilationFailures]]!

setGuid: id
	"Private - Set the value of the receiver's 'guid' instance variable to the 
	<GUID>, id.
	N.B. A classes GUID should not normally be changed after the class has
	been created, but should remain with it throughout its life."

	_guid := id.
!

setName: aSymbol
	"Private - Set the name of the receiver to be aSymbol."

	name := aSymbol!

setSharedPoolNames: aCollection 
	"Private - Set the shared variable pool to include the names in aCollection.
	N.B. initial conversion to a set removes duplicates."

	sharedPools := aCollection notEmpty 
				ifTrue: [aCollection asSet asArray collect: [:poolName | poolName asSymbol]]!

sharedPoolNames
	"Answer a Set of the names of the shared pool dictionaries that
	are specified locally in the receiver."

	sharedPools isNil ifTrue: [^Set new].
	^sharedPools asSet.
!

sharedStaticPools
	"Private - Answer an array of all the non-empty shared pools for the 
	receiver.
	N.B. Sent by compiler, and may be removed in future."

	| answer |
	answer := OrderedCollection new.
	"First the class variables"
	self withAllSuperclassesDo: 
			[:c | 
			| pool |
			pool := c basicClassPool.
			(pool notNil and: [pool notEmpty]) ifTrue: [answer add: pool]].
	"Then the pool variables"
	self 
		withAllSuperclassesDo: [:c | c sharedPools do: [:s | s notEmpty ifTrue: [answer add: s]]].
	^answer asArray!

sourceDescriptor
	"Answer the source descriptor for the receiver's comment."

	^comment!

sourceDescriptor: sourceDes
	"Private - Set the class comment source descriptor for the receiver 
	to sourceDes, the format of which only the SourceManager understands."

	comment := sourceDes!

stbConvertFrom: anSTBClassFormat
	"Private - Answer a block that answers a new instance initialised from the block's single
	parameter, an Array or ByteArray representing the old object whose format is
	described by anSTBClassFormat.

	By default, classes only know about the current format."

	^nil!

stbModifyExportProxy: anSTBImportedClassProxy
	"Private - This is an opportunity to modifiy the classes' binary export proxy just before it is
	output (to an STC file). The default is to do nothing - the standard STBImportedClassProxy is
	generally sufficient for nearly all cases."!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBClassProxy forClass: self)!

stbVersion
	"If instances of a class are saved out to an STBOutFiler and must
	remain loadable even if the class format changes then we need to be able
	to distinguish between the different formats. A new binary format is
	created whenever the number or order of instance variables in a class
	are changed. All classes initially answer a version number of zero.

	This identification of a changed format is achieved by overriding this
	class method in the changed subclass to answer a new SmallInteger.
	Also, in order to 'upgrade' an old instance to a new one, you must
	provide or amend the class method #stbConvertFrom:."

	^0!

storeGUID
	"Private - Record the receivers GUID to the change log."

	self sourceManager storeGUIDForClass: self
!

subclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString) modifyOrCreate!

subclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString category: aCategoryOrString
	"If aClassSymbol is not an existing class then create and answer a new fixed pointer subclass,
	otherwise modify the class with name aClassSymbol to have the indicated features and answer it.
	Primarily present for backwards compatibility with Smalltalk-80."

	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		categoryNames: (Array with: aCategoryOrString);
		modifyOrCreate!

subclass: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString
		classInstanceVariableNames: classInstVarString
	"Create or modify the class, classSymbol, to be a subclass of the receiver
	with the specified instance variables, class pool, and pool dictionaries,
	and class instance variables."

	| subclass |
	subclass := self 
				subclass: aClassSymbol
				instanceVariableNames: instVarString
				classVariableNames: classVarString
				poolDictionaries: poolDictString.
	subclass class instanceVariableNames: classInstVarString.
	^subclass!

uninitialize
	"Private - Perform any uninitialisation for the class - typically clearing down class variables - in
	preparation for removal from the system. You should override this method if, for example,
	your class maintains a registry of its own instances in a class variable.
	This message will only be sent to a class which directly implements it, i.e. it will not be
	sent if the implementation is inherited."

	^self error: 'Do not supersend #uninitialize'!

uninitializeBeforeRemove
	"Perform any pre-removal uninitialisation for the class. This includes any specific #uninitialize
	implementation (but note that #uninitialize is only sent to classes which directly implement
	#uninitialize, otherwise we'd probably end up damaging superclasses which are not being
	removed).
	There may be some circumstances where an entire hierarchy of classes requires some
	common uninitialization prior to removal, in which case this message can be overridden."

	(self class includesSelector: #uninitialize) ifTrue: [self uninitialize].
	self removeAllProperties!

variableByteSubclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		beBytes;
		modifyOrCreate!

variableByteSubclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString category: aCategoryOrString
	"If aClassSymbol is not an existing class then create an answer a new variable byte subclass,
	otherwise modify the class with name aClassSymbol to have the indicated features and answer 
	it. Primarily present for backwards compatibility with Smalltalk-80."

	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		beBytes;
		categoryNames: (Array with: aCategoryOrString);
		modifyOrCreate!

variableByteSubclass: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString
		classInstanceVariableNames: classInstVarString
	"Create or modify the class, classSymbol, to be a variable-byte subclass 
	(has indexable byte-size nonpointer variables) of the receiver
	with the specified class pool, and pool dictionaries, and class instance
	variables. Note that variable byte classes cannot have any named
	instance variables, and therefore the instVarString must be empty."

	| subclass |
	subclass := self 
				variableByteSubclass: aClassSymbol
				instanceVariableNames: instVarString
				classVariableNames: classVarString
				poolDictionaries: poolDictString.
	subclass class instanceVariableNames: classInstVarString.
	^subclass
!

variableSubclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString
	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		beVariable;
		modifyOrCreate!

variableSubclass: aClassSymbol instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolDictString category: aCategoryOrString
	"If aClassSymbol is not an existing class then create and answer a new variable pointer 
	subclass, otherwise modify the class with name aClassSymbol to have the indicated features and 
	answer it. Primarily intended for backwards compatibility with Smalltalk-80."

	^(self 
		newClassBuilder: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString)
		beVariable;
		categoryNames: (Array with: aCategoryOrString);
		modifyOrCreate!

variableSubclass: aClassSymbol
		instanceVariableNames: instVarString
		classVariableNames: classVarString
		poolDictionaries: poolDictString
		classInstanceVariableNames: classInstVarString
	"Create or modify the class classSymbol to be a variable subclass (has
	indexable pointer variables) of the receiver with the specified
	instance variables, class pool, pool dictionaries, and class instance
	variables."

	| subclass |
	subclass := self 
				variableSubclass: aClassSymbol
				instanceVariableNames: instVarString
				classVariableNames: classVarString
				poolDictionaries: poolDictString.
	subclass class instanceVariableNames: classInstVarString.
	^subclass

! !

Metaclass comment:
'Metaclass is the class of objects which represent the classes of the Classes of the system.
In other words, every class in the system (e.g. Integer) is the sole instance of an instance of Metaclass
(e.g. Integer class), they are not instances of Class (which, in fact, has no instances). A class object''s 
class (a Metaclass) provides the instance specific behavior of that class (i.e. it is where the class 
methods live, whereas the instance methods live in the class object itself).

A Metaclass fulfils the role for a class object that a class object does for its instances.

The Metaclass hierarchy parallels the Class hierarchy in that if class X is a subclass of class Y, then
X class is also a subclass of Y class. The roots of the class hierarchy (e.g. Object), however, are
exceptions to this rule since Object''s superclass is nil, but Object class (i.e. the Metaclass instance of
which Object is an instance) is a subclass of Class.

Please see the Blue Book for further explanation.

Metaclass has the following instance variables:
	instanceClass	- the single instance of the Metaclass which is a Class object'!
!Metaclass class methodsFor!

icon
	"Answers an Icon that can be used to represent this class. Here we use a constant expression 
	evaluated at compile time in order to statically bind 'self' at this position in the class hierarchy 
	(i.e. to Object). This ensures that subclasses which do not override this method still answer 
	'Object defaultIcon' rather than 'aSubclass defaultIcon'. Classes which provide their own default icon 
	can override this method with a similar implementation perhaps with #defaultIconFrom: if the icon comes
	from an ExternalResourceLibrary other than the system default."

	^##(self) defaultIcon! !

!Metaclass methodsFor!

addToSuper
	"Private - Add the receiver into its superclasses' subclass collection.
	Root Metaclasses will have a superclass of Class - we do not put such
	classes into Class's subclass collection."	

	superclass ~~ Class
		ifTrue: [super addToSuper]
!

bindingFor: aString 
	"Answer a variable binding for the named variable in the scope of this class. 
	If there is no such variable, then answer nil."

	^self instanceClass bindingFor: aString!

classPool
	"Answer the dictionary of class variables."

	^instanceClass classPool!

classVariables
	"Answer the dictionary of class variables."

	^instanceClass classVariables!

classVarNames
	"Answer a Set of the class variable names of the receiver."

	^Set new!

comment
	"Answer the class comment for the receiver."

	^self instanceClass comment
!

comment: aString
	"Set the class comment for the receiver to aString."

	self instanceClass comment: aString
!

instanceClass
	"Answer the receiver's singleton instance (the actual class object)."

	^instanceClass
!

instanceClass: aClass
	"Private - Set the receiver's instance class to aClass.
	Any users of this method probably don't understand what they're doing."

	instanceClass := aClass
!

instanceVariableNames: aString 
	"Set the instance variables of the receiver (the class instance variables
	of its instance class) to those in aString - a space separated name list."

	| classInstVars |
	classInstVars := aString trimBlanks.
	^self instanceVariableString trimBlanks = classInstVars 
		ifTrue: [self]
		ifFalse: [
			ClassBuilder new
				class: self;
				superclass: superclass;
				instanceSpec: instanceSpec;
				instanceVariableString: classInstVars;
				modifyExistingClass]!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument.
	Implementation Note: The change flags are held on the instance side."

	self instanceClass isChanged: aBoolean!

isMeta
	"Answer whether the receiver is a <Metaclass>."

	^true!

name
	"Answer a String containing the receiver name. 
	For speed code directly rather than use concatenation.
	N.B. This is NOT a global name."

	^instanceClass name, ' class'!

new
	"Answer a new instance of the receiver - there can be only one (the
	class object). Why define an instance creation method as an instance
	method? Because Metaclasses are actually the classes of classes."

	instanceClass notNil 
		ifTrue: [self error: 'There can be only one (instance of a metaclass)'].
	^instanceClass := super new!

printDefinitionOn: target
	"Private - Append the textual definition of the receiver to the <puttableStream>, target."

	target
		nextPutAll: self name;
		space;
		display: #instanceVariableNames:;
		space;
		print: self instanceVariableString!

removeClassVarName: aString 
	"Remove the class variable from the receiver with the specified <readableString> name."

	^self instanceClass removeClassVarName: aString!

removeFromSuper
	"Private - Remove the receiver from its superclasses' subclass collection.
	Root Metaclasses will have a superclass of Class - we do not put such
	classes into Class's subclass collection."

	superclass ~~ Class
		ifTrue: [super removeFromSuper]
!

setSharedPoolNames: aCollection
	"Private - Set the <Symbol> names of the shared pool dictionaries that
	are specified locally in the receiver (pools are inherited in Dolphin)."

	self instanceClass setSharedPoolNames: aCollection
!

sharedStaticPools
	"Answer the receiver's shared pools."

	^instanceClass sharedStaticPools!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBMetaclassProxy forClass: self)! !

False comment:
'The False class implements the behaviour of the false (logical false) object.

False is a singleton whose sole instance is the object represented by the reserved word, false. (i.e. any reference to false will always answer true when compared with any other using the #== message).

False implement the ANSI protocols <Object> and <boolean>.'!
!False class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!False methodsFor!

and: operand 
	"Answer whether the receiver and the result of evaluating the <niladicValuable>,
	 operand, are both true. The argument is only evaluated if the receiver is true."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self!

asDword
	"Answer the receiver in a form suitable for passing/returning as a
	32-bit integer value."

	^0!

asParameter
	"Answer the value of the receiver in a form suitable for
	passing to an external function call."

	^0
!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^0!

ifFalse: operand 
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is false, otherwise answer nil. "

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^operand value!

ifFalse: falseOperand ifTrue: trueOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^falseOperand value!

ifTrue: operand 
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is true, otherwise answer nil."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^nil!

ifTrue: trueOperand ifFalse: falseOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^falseOperand value!

not
	"Answer the logical inverse of the receiver."

	^true
!

or: operand 
	"Answer whether either the receiver or the result of evaluating the
	<niladicValuable> argument, operand, is true. The argument is only
	evaluated if the receiver is false."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^operand value!

printOn: target
	"Append the a textual representation of the receiver to the puttableStream, <target>..
	Note that this override refines #printString to comply with the ANSI 
	protocol <boolean>."
	
	target nextPutAll: 'false'!

xor: operand
	"Answer whether either the receiver or the boolean argument <operand>
	is true, but not both.
	Since the receiver is false, the answer depends entirely on the argument."

	^operand! !

True comment:
'The True class implements the behavior of the true (logical truth) object.

Trueis a singleton whose sole instance is the object represented by the reserved word, true. true is an identity object (i.e. any reference to true will always answer true when compared with any other using the #== message).

True implement the ANSI protocols <Object> and <boolean>.'!
!True class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!True methodsFor!

and: operand 
	"Answer whether the receiver and the result of evaluating the <niladicValuable>,
	 operand, are both true. The argument is only evaluated if the receiver is true."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^operand value!

asDword
	"Answer the receiver in a form suitable for passing/returning as a
	32-bit integer value."

	^1!

asParameter
	"Answer the value of the receiver in a form suitable for
	passing to an external function call."

	^1
!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^1!

ifFalse: operand 
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is false, otherwise answer nil."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^nil!

ifFalse: falseOperand ifTrue: trueOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^trueOperand value!

ifTrue: operand 
	"Evaluate and answer the result of the evaluating the <niladicValuable>
	argument, operand, if the receiver is true, otherwise answer nil. "

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^operand value!

ifTrue: trueOperand ifFalse: falseOperand 
	"Evaluate, and answer the result, of the <niladicValuable>, falseOperand, if 
	the receiver is false, or the <niladicValuable>, trueOperand, if the receiver is 
	true."

	"Implementation Note:  The compiler inlines this message if the arguments
	are literal blocks. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^trueOperand value!

not
	"Answer the logical inverse of the receiver."

	^false
!

or: operand 
	"Answer whether either the receiver or the result of evaluating the
	<niladicValuable> argument, operand, is true. The argument is only
	evaluated if the receiver is false."

	"Implementation Note:  The compiler inlines this message if the argument
	is a literal block. The compiler assumes that the receiver will be a boolean,
	so this message cannot be overridden."

	^self!

printOn: target
	"Append the a textual representation of the receiver to the puttableStream, <target>..
	Note that this override refines #printString to comply with the ANSI 
	protocol <boolean>."
	
	target nextPutAll: 'true'!

xor: operand
	"Answer whether either the receiver or the boolean argument <operand>
	is true, but not both.
	Since the receiver is false, the answer is true only if the argument
	is false."

	^operand not! !

ClassCategory comment:
''!
!ClassCategory class methodsFor!

allClassCategories
	"Answer the set of all <classCategory>s current registered in the system."

	^Table asArray!

initialize
	"Private - Initialize the receiver's class variables.

	This is a No-Op because we have to create the table
	during the booting process of Dolphin so all the methods
	categories can be set as they are loaded. Support for the booting
	of the system is unnecessary in the release version of Dolphin but
	it resolves the conundrom of creating the Smalltalk system, which
	relies on itself to work, from nothing using smalltalk. 

	It is unwise to clear down this table, as the development system
	expects methods and classes to be correctly categorized."
"	| newTable |

	newTable := WeakLookupTable new.
	newTable addAll: Table associations.
	Table := newTable"

	"During the boot, weakness doesn't work properly, so some repairs may be needed"
	Unclassified := self newNamed: self unclassifiedName.
	Table 
		at: self unclassifiedName put: Unclassified;
		removeKey: 'No category' ifAbsent: []!

name: cat
	"Answer a new or existing class category with the specified name."

	| nameString |
	nameString := cat asString.
	^nameString isEmpty 
		ifTrue: [self unclassified]
		ifFalse: [Table at: nameString ifAbsentPut: [self newNamed: nameString]]!

unclassified
	"Answer a <ClassCategory> used to mark an unclassified classes."

	^Unclassified!

unclassifiedName
	"Private - Answer the String name used to mark a none existing category."

	^ 'Unclassified'!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Table := nil.
	Unclassified := nil! !

!ClassCategory methodsFor!

addClass: class
	"Add the <Class>, class, to the collection of classes associated with the receiver."

	class includeInCategory: self!

contents
	"Answer a Collection of all Class objects which are 
	held by the receiver."

	^self class environment allClasses select: [:aClass | self includesClass: aClass]!

includesClass: class 
	"Answer whether the receiver includes the <ClassDescription>, class."

	| classCategories |
	^(classCategories := class classCategories) isNil 
		ifTrue: [self == self class unclassified]
		ifFalse: [classCategories identityIncludes: self]!

removeClass: aClass
	"Remove aClass from the classes held by the reciver. Answer
	aMethod."

	aClass removeFromCategory: self.
	^aClass! !

MethodCategory comment:
'MethodCategory is the class of objects used to classify the methods of classes in taxonomies that are generally unrelated to the class hierarchy.

Instance Variables: (None)

Class Variables:
	Pseuds		<Set> of <VirtualMethodCategory>s. The pseudo-categories.
	Table		<WeakLookupTable> mapping <String> names to <MethodCategory> instances.'!
!MethodCategory class methodsFor!

addPseud: category
	"Add the virtual method category, category, to the global list of virtual categories
	which may be associated with any class. Any samed name standard category
	is removed from the system."

	self removeCategory: category.
	Pseuds add: category.
	^Table at: category name put: category.!

allMethodCategories
	"Answer the set of all <methodCategory>s current registered in the system."

	^Table values!

deprecatedMethods
	"Answer the category for deprecated methods. Note we choose not to use #deprecated as the selector
	for this method, as otherwise it too would appear in the deprecated category."

	^self name: '*-deprecated'!

initialize
	"Private - Initialize the receiver's class variables.
		MethodCategory initialize
	"

	self initializeTable!

initializeTable
	"Private - Initialize the receiver's dictionary of instances.

	This is a No-Op because we have to create the table
	during the booting process of Dolphin so all the methods
	categories can be set as they are loaded. Support for the booting
	of the system is unnecessary in the release version of Dolphin but
	it resolves the conundrom of creating the Smalltalk system, which
	relies on itself to work, from nothing using smalltalk. 

	It is unwise to clear down this table, as the development system
	expects methods and classes to be correctly categorized."
"	| newTable |

	newTable := WeakLookupTable new.
	newTable addAll: Table associations.
	Table := newTable"

	"Repair table as weakness not operative during boot process"
	Table removeAllKeys: (Table keys select: [:k | k isKindOf: DeadObject])!

name: categoryName
	"Answer the subinstance of the receiver with the <readableString> name, categoryName."

	| nameString |
	nameString := categoryName asString.
	^Table at: nameString ifAbsentPut: [self newNamed: nameString]!

primitives
	"Answer the category for primitive methods."

	^self name: '*-primitives'!

private
	"Answer the category for private methods."

	Private isNil ifTrue: [Private := self name: 'private'].
	^Private!

pseudoCategories
	"Answer the <collection> of standard pseudo categories, the contents of which 
	are calculated, and which might therefore be associated with any class in the system."

	^Pseuds!

pseudPrefix
	"Private - Answer the <readableString> prefix to be prepended to the names of the
	standard pseudo categories. N.B. The prefix should be short."

	^'*-'!

public
	"Answer the category for public methods."

	Public isNil ifTrue: [Public := self name: 'public'].
	^Public!

removeCategory: category
	"Remove the specified category from all classes with which it is associated,
	and also from the table of categories."

	| catName |
	catName := category asString.
	"Make absolutely sure any standard category of the same name has been removed"
	self environment allBehaviorsDo: [:c | | catalogue |
		catalogue := c methodsCatalogue.
		(catalogue keys select: [:e | e name = catName]) 
			do: [:k | catalogue removeKey: k]].
	Pseuds remove: (Table removeKey: catName ifAbsent: []) ifAbsent: []!

removePseud: pseud
	"Remove the virtual method category, pseud, from the global list of virtual 
	categories which may be associated with any class."

	^Pseuds notNil ifTrue: [Pseuds remove: (Table removeKey: pseud asString ifAbsent: []) ifAbsent: []]!

setMethod: method categories: categories 
	"Private - Set the categories of the <CompiledMethod>, method, to be the <Collection> of
	<methodCategory>s, categories, only (i.e. any existing non-pseudo classifications
	not in 'categories' are removed)."

	| newCategories original unwanted |
	original := method realCategories.
	newCategories := categories reject: [:each | each isPseud].
	unwanted := original difference: newCategories.
	newCategories := newCategories difference: original.
	unwanted do: [:c | c removeMethodSilently: method].
	newCategories do: [:each | each addMethodSilently: method].
	^unwanted notEmpty or: [newCategories notEmpty]!

unclassifiedName
	"Private - Answer the <readableString> name for the unclassified category."

	^ '*-unclassified'!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Pseuds := Table := nil! !

!MethodCategory methodsFor!

addClass: class
	"Add the <Class>, class, to the collection of classes associated with the receiver.
	There is nothing we can do for method categories as we don't have the notion of
	a set of selectors which constitutes the category, and therefore we can't update
	the class in any useful manner (however see MethodProtocol)."!

addMethod: method
	"Add the <CompiledMethod>, method, to the collection of methods within the receiver."

	(self includesMethod: method) ifFalse: [
		self addMethodSilently: method.
		method methodClass environment trigger: #methodCategorized: with: method]
!

addMethods: aCollection 
	aCollection do: [:each | self addMethod: each]!

addMethodSilently: method
	"Private -  Add the <CompiledMethod>, method, to the collection of methods 
	classified under receiver, without triggering a recategorization event."

	method methodClass includeSelector: method selector inCategory: self!

behaviors
	"Answer a <sequencedReadableCollection> of all the <ClassDescription> objects which have
	methods in this category in class hierarchy order (i.e. superclasses first)."

	| answer |
	answer := OrderedCollection new: 32.
	self behaviorsDo: [:each | answer addLast: each].
	^answer!

behaviorsDo: aMonadicValuable 
	self class environment 
		allBehaviorsDo: [:each | (each includesCategory: self) ifTrue: [aMonadicValuable value: each]]!

contents
	"Answer a <collection> of all methods classified under the receiver."

	| foundMethods |
	foundMethods := IdentitySet new.
	self behaviorsDo: [:aBehavior | foundMethods addAll: (self methodsInBehavior: aBehavior)].
	^foundMethods!

includesMethod: method
	"Answer whether the receiver includes the <CompiledMethod>, method."

	^(method methodClass selectorsInCategory: self) identityIncludes: method selector!

isPrivacy
	"Private - Answer whether the receiver is a method privacy category."

	^false!

methodsInBehavior: aBehavior 
	"Answer a <sequencedReadableCollection> of <CompiledMethods>s being all the methods in the <Behavior>
	argument which are members of the receiver."

	| answer |
	answer := OrderedCollection new: 32.
	self methodsInBehavior: aBehavior do: [:each | answer addLast: each].
	^answer!

methodsInBehavior: aBehavior do: aMonadicValuable 
	(aBehavior selectorsInCategory: self) do: 
			[:eachSelector | 
			(aBehavior compiledMethodAt: eachSelector ifAbsent: []) 
				ifNotNil: [:eachMethod | aMonadicValuable value: eachMethod]]!

removeClass: aClassDescription 
	"Remove the <ClassDescription> argument from the classes 'held' by the receiver.
	In this case we just remove all references to this category from the class."

	| methods |
	methods := self methodsInBehavior: aClassDescription.
	methods isEmpty ifTrue: [^self].
	methods do: [:each | self removeMethodSilently: each].
	aClassDescription isChanged: true!

removeMethod: method
	"Remove the <CompiledMethod>, method, from the methods held 
	by the receiver, triggering a method categorization event to inform
	observers."

	self removeMethodSilently: method.
	method methodClass environment trigger: #methodCategorized: with: method!

removeMethods: aCollection 
	aCollection do: [:each | self removeMethod: each]!

removeMethodSilently: method
	"Private - Remove the <CompiledMethod>, method, from the set of 
	methods that are members of the receiver, and make no fuss about it." 

	method methodClass removeSelector: method selector fromCategory: self! !

Bag comment:
'A Bag is a variable sized, unordered, collection which is extensible and contractible, but not accesssible using external keys. Bag is similar to Set, but can contain duplicate elements (which it counts). Elements are considered to  be duplicates if they compare as equal using #=.

Bag conforms to the ANSI protocols:
	Object
	collection
	extensibleCollection
	Bag'!
!Bag class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

identityNew
	"Answer a new instance of the receiver with default initial capacity, which uses identity 
	as the comparison for identifying duplicate elements."

	^self identityNew: 3
!

identityNew: anInteger
	"Answer a new instance of the receiver with sufficient initial capacity for anInteger unique
	elements, which uses identity as the comparison for identifying duplicate elements."

	^super new contents: (IdentityDictionary new: anInteger)
!

new
	"Answer a new instance of the receiver with default initial capacity, 
	which uses equality as the comparison for identifying duplicate elements."

	^self new: 3!

new: count
	"Answer a new instance of the receiver with sufficient initial capacity for 
	the number of elements specified by the <integer> argument, count,
	which uses equality as the comparison for identifying duplicate elements."

	^super new 
		contents: (LookupTable new: count)! !

!Bag methodsFor!

add: newElement
	"Include the <Object> argument, newElement, as an element of the receiver, once.
	newElement must not be nil. Answer newElement."

	^self add: newElement withOccurrences: 1.!

add: anObject withOccurrences: anInteger 
	"Include the argument, anObject, as an element of the receiver, anInteger number of times.
	The new element must not be nil. Answer the new element."

	"Implementation Note: Although nil is not a valid value for bag elements the ANSI standard
	specifies that the result is undefined if nil is added, so we do not explicitly test for it
	here."

	contents at: anObject put: anInteger + (self occurrencesOf: anObject).
	^anObject!

asBag
	"Answer a <Bag> containing the same elements as the receiver."

	^self!

asSet
	"Answer a <Set> containing each of the unique elements of the receiver.
	Implementation Note: Reimplement for efficiency only."

	^contents keys asSet!

at: index
	"Generate an error to the effect that Bag's are not keyed 
	(they're like Sets with duplicates)."

	^self errorNotKeyed!

at: index put: value
	"Generate an error to the effect that Bag's are not keyed 
	(they're like Sets with duplicates)"

	^self errorNotKeyed!

contents: initialContents
	"Private - Set the receiver's contents to be the
	<abstractDictionary>, initialContents."

	contents := initialContents!

do: operation
	"Evaluate <monadicValuable> argument, operation, for each of the element of the 
	receiver. Answers the receiver.
	Implementation Note: Bags need to perform the operation repeatedly for each element, 
	depending on the number of occurrences."

	contents keysAndValuesDo: [:elem :count |
		count timesRepeat: [operation value: elem]]!

elements
	"Private - Answers the contents of the receiver as an OrderedCollection"

	^self asOrderedCollection!

elements: anOrderedCollection
	"Private - Sets the contents of the receiver from anOrderedCollection"

	contents := contents class new: anOrderedCollection size.
	self addAll: anOrderedCollection!

includes: target
	"Answer whether the <Object> argument, target, 
	is one of the elements of the receiver."

	^contents includesKey: target!

occurrencesOf: target
	"Answer the <integer> number of the receiver's elements which are 
	equal to the <Object> argument, target."

	^contents at: target ifAbsent: [0]!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver.

	In the case of a Bag we need a completely new dictionary because it is part of the
	implementation of the Bag, rather than a public characteristic of the data structure."

	| original |
	super postCopy.
	original := contents.
	contents := original copyEmpty.
	original keysAndValuesDo: [:k :v | contents at: k put: v].
	^self!

remove: oldElement ifAbsent: exceptionHandler
	"Decrement the number of occurrences of the <Object> argument, 
	oldObject, in the receiver, and if it reaches zero remove oldElement 
	completely. If oldElement is not an element of the receiver, answer 
	the result of evaluating the <niladicValuable>, exceptionHandler, 
	else answer oldElement."

	| count |
	(count := contents at: oldElement ifAbsent: [^exceptionHandler value]) == 1
		ifTrue:  [contents removeKey: oldElement]
		ifFalse: [contents at: oldElement put: count - 1].
	^oldElement!

removeAllOccurrencesOf: target ifAbsent: exceptionHandler
	"Remove all the occurrences of the <Object> target from the receiver. 
	If target is not an element of the receiver, answer the result of evaluating 
	the <niladicValuable>, exceptionHandler."

	^contents removeKey: target ifAbsent: exceptionHandler!

size
	"Answer the <integer> number of elements in the receiver, counting duplicates as the
	number of times which they occur.
	Implementation Note: Could implement more elegantly with #inject:into:, but
	this implementation is faster."

	| tally |
	tally := 0.
	contents do: [:elemCount | tally := tally + elemCount].
	^tally!

valuesAndCountsDo: aBlock 
	contents keysAndValuesDo: aBlock! !

SequenceableCollection comment:
'SequenceableCollection is the class of Collections whose elements are ordered and which are externally named by integer indices.'!
!SequenceableCollection class methodsFor!

binarySearch: aSequenceableCollection for: anObject using: searchBlock 
	"Private - Answer the index at which anObject is located within aSequenceableCollection using a binary chop
	search based on searchBlock"

	| index low high |
	low := 1.
	high := aSequenceableCollection size.
	
	[index := (high + low) // 2.
	low > high] whileFalse: 
				[(searchBlock value: (aSequenceableCollection at: index) value: anObject) 
					ifTrue: [low := index + 1]
					ifFalse: [high := index - 1]].
	^low!

ofSize: anInteger
	"Private - Answer a new instance of the receiver with anInteger nil elements.
	This method is subtly different from #new: because that, as defined for 
	SequenceableCollections, answers a Collection with sufficient space for 
	anInteger elements, but which, in the case of some subclasses, may be considered 
	empty - i.e. containing no elements. If we attempt to perform a #replaceFrom:to:with:startingAt:
	on an empty SequenceableCollection, then a bounds error will result. This protocol 
	enables SequenceableCollection's implementation of copy replacement to work for most 
	subclasses."

	^self new: anInteger!

writeStream
	"Answer a WriteStream on the a new empty instance of the receiver."

	^self new writeStream!

writeStream: anInteger
	"Answer a WriteStream on the a new instance of the receiver with
	initialize size, anInteger."

	^(self new: anInteger) writeStream! !

!SequenceableCollection methodsFor!

, aSequencedReadableCollection
	"Answer a new <sequencedReadableCollection> like the receiver (i.e. of the receiver's
	species but not necessarily the exact same class) containing the elements	of the receiver 
	in their original order with those of the <sequencedReadableCollection> argument
	appended in their original order.
	Note: This is the concatenation operation, and is a simplified form of 
	#copyReplaceFrom:to:with:."

	| size newSize |
	size := self size.
	newSize := size + aSequencedReadableCollection size.
	^(self copyLikeOfSize: newSize)
		replaceFrom: 1
			to: size
			with: self
			startingAt: 1;
		replaceFrom: size + 1
			to: newSize
			with: aSequencedReadableCollection
			startingAt: 1;
		yourself!

_sameAsString: comparand
	"Private - Answer whether the receiver collates the same as <readableString>
	argument, comparand.
	This will only work if the receiver contains integers in the range of character
	values, if not an exception will be raised.
	Implementation Note: Double dispatched from String>>sameAs:."

	| string2 size |
	size := self size.
	string2 := String new: size.
	1 to: size do: [:i | string2 basicAt: i put: (self at: i)].
	^(comparand _collate: string2) == 0!

= comparand
	"Answer whether the receiver and the <Object> argument, comparand,
	are considered equivalent - that is they are of the same class and size, and
	contain eqivalent elements that are in the same sequence.
	Implementation Note: We perform a series of tests of increasing slowness, culminating
	in an element-by-element equality test."

	| size |
	self == comparand ifTrue: [^true].
	#todo "ANSI draft says must be same class, not just same species".
	(self species == comparand species) ifFalse: [^false].
	size := self size.
	size = comparand size ifFalse: [^false].
	1 to: size do: [ :i |
		(self at: i) = (comparand at: i)
			ifFalse: [^false]].
	^true!

after: target
	"Answer the element after the <Object> argument, target.  
	Report an error if target is not in the receiver, or if there 
	are no elements after it."

	^self after: target ifAbsent: [self errorNotFound: target]!

after: target ifAbsent: exceptionHandler
	"Answer the element after target, or if not present the result of evaluating the
	niladic valuable, exceptionHandler."

	| index |
	index := self indexOf: target.
	^index == 0
		ifTrue: [exceptionHandler value]
		ifFalse: [
			index = self size 
				ifTrue: [self errorLastObject: target]
				ifFalse: [self at: index + 1]]!

allButFirst
	"Answer a copy of the receiver containing all but the first
	element. Raise an error if there are not enough elements."

	^self allButFirst: 1!

allButFirst: n
	"Answer a copy of the receiver containing all but the first n
	elements. Raise an error if there are not enough elements."

	^ self copyFrom: n + 1 to: self size!

allButLast
	"Answer a copy of the receiver containing all but the last
	element. Raise an error if there are not enough elements."

	^ self allButLast: 1!

allButLast: anInteger
	"Answer a copy of the receiver containing all but the last anInteger
	elements. Raise an error if there are not enough elements."

	^self first: self size - anInteger!

anyOne
	"Answer an arbitrary element of the collection.Raise an error if the collection is empty."

	^self first!

appendToStream: puttableStream
	"Private - Append the receiver's elements to the argument, puttableStream.
	We can be able to do a fast block copy. Answer the receiver.
	Implementation note: Double dispatched from puttableStream>>nextPutAll:."

	puttableStream next: self size putAll: self startingAt: 1!

approxSize
	"Private - Answer the approximate size of the receiver.
	Implementation Note: In general sequenceable collections keep a
	tally, so we can use the actual size."

	^self size!

asRunArray
	"Answer a <RunArray> whose elements are the same as those of the receiver. The order of
	elements will be the same, and there will be the same number when enumerated, but the
	identity of any duplicated elements in a run will be lost. This is useful for obtaining a
	compressed representation of a <sequencedReadableCollection> known to contain runs of equal
	elements."

	| runs values |
	runs := Array writeStream.
	values := Array writeStream.
	self runsAndValuesDo: 
			[:run :value | 
			runs nextPut: run.
			values nextPut: value].
	^RunArray runs: runs contents values: values contents!

associations
	"Answer a <SequenceableCollection>, like the receiver, containing the receiver's associations."

	"Implementation Note: SequenceableCollections don't actually contain associations so the result 
	is built afresh each time and modifying its contents will not affect the original collection. However
	this is no different to the implementation for LookupTable/IdentityDictionary."

	| answer |
	answer := self copyLikeOfSize: self copySize.
	self keysAndValuesDo: [:i :each | answer at: i put: i -> each].
	^answer!

at: index
	"Answer an <Object> which is the element of the receiver 
	at the specified index. If the index is out of bounds, raise an exception."

	^self subclassResponsibility!

at: index ifAbsent: exceptionBlock
	"Answer an <Object> which is the element of the receiver 
	at the specified index. If the index is out of bounds answer
	the result of evaluating the <niladicValuable> exceptionBlock."

	^(index > 0 and: [index <= self size])
		ifTrue: [self at: index]
		ifFalse: [exceptionBlock value]!

at: key ifPresent: operation 
	"Answer the result of evaluating the monadic valuable, operation, if
	the argument, key, is the key of an element in the receiver, with that
	element as its argument. If the key is not present, then answer nil."

	| value |
	value := self at: key ifAbsent: [AbsentCookie].
	^value == AbsentCookie ifFalse: [operation value: value]!

at: index put: newElement
	"Replace the element of the receiver at the specified <integer> index with 
	the <Object> argument, newElement. If the index is out of bounds, raise 
	a BoundsError."

	^self subclassResponsibility!

atAll: indices put: newElement
	"Replace the elements of the receiver at each <integer> element of the <collection> 
	argument, indices, with the <Object> argument, newElement."

	indices do: [:index | self at: index put: newElement]!

atAllPut: newElement
	"Replace all the elements of the receiver with the <Object> argument,
	newElement."

	1 to: self size do: [:index | self at: index put: newElement]!

basicBeginsWith: aCollection
	"Answer whether the receiver begins with the sequence
	of objects in the <Collection> argument.
	Should not be overridden (but see #beginsWith:)"

	| i |
	self size < aCollection size ifTrue: [^false].
	i := 1.
	aCollection do: 
			[:each | 
			(self at: i) = each ifFalse: [^false].
			i := i + 1].
	^true!

before: target
	"Answer the receiver's element immediately before the argument, target. 
	Raise an exception if target is not an element of the receiver, or if 
	there are no elements before it (i.e. it is the first element)."

	^self before: target ifAbsent: [self errorNotFound: target]!

before: target ifAbsent: exceptionHandler
	"Answer the element before the argument, target, or if not present the 
	result of evaluating the niladic valuable, exceptionHandler."

	| index |
	index := self indexOf: target.
	^index == 0
		ifTrue: [exceptionHandler value]
		ifFalse: [
			index == 1 
				ifTrue: [self errorFirstObject: target]
				ifFalse: [self at: index - 1]].!

beginsWith: aCollection
	"Answer whether the receiver begins with the sequence
	of objects in the <Collection> argument."

	^self basicBeginsWith: aCollection!

binarySearchFor: anObject using: searchBlock 
	"Answer the index at which anObject is located using a binary chop search based on searchBlock"

	^self class 
		binarySearch: self
		for: anObject
		using: searchBlock!

collect: transformer 
	"Evaluate the <monadicValuable> argument, transformer, for each of the 
	receiver's elements in the order defined by the receiver's implementation of #do:.
	Answer a new collection like the receiver (i.e. of the same species but not
	necessarily the exact same class) containing the values returned by transformation
	block."

	"Implementation Note: By making use of the special instance creation method 
	#copyLikeOfSize: we can avoid using a WriteStream here."

	| answer |
	answer := self copyLikeOfSize: self copySize.
	self keysAndValuesDo: [:i :each | answer at: i put: (transformer value: each)].
	^answer!

copyFrom: start
	"Answer a copy of a subset of the receiver which starts with its element at Integer 
	index start."

	^self copyFrom: start to: self size!

copyFrom: start to: stop
	"Answer a new <sequencedReadableCollection> like the receiver
	containing those elements of the receiver between the <integer> indices start
	and stop, inclusive, and in the same order."

	| len |
	len := stop - start + 1.
	^(self copyLikeOfSize: len) 
		replaceFrom: 1
		to: len
		with: self
		startingAt: start!

copyLikeOfSize: anInteger
	"Private - Answer a new collection of the same species as the receiver but with
	anInteger nil or zero elements. 
	N.B. Subclasses must override to preserve additional instance variables."
	
	"Note: This message differs from #copyEmpty: in two ways:
	1) an instance of the receivers #species, rather than exact class (although this is usually the same) 
	is answered; and
	2) the answer doesn't just have sufficient capacity for anInteger elements, but actually has that 
	many nil or zero elements."

	^self species ofSize: anInteger!

copyReplaceAll: targetElements with: replacementElements
	"Answer a new <sequencedReadableCollection> which is a copy of the receiver
	but in which all occurrences of targetElements have been replaced 	by 
	the elements of the <sequencedReadableCollection> replacementElements."

	| occurrences resultCollection findSize replaceSize extraSpace index sourceIndex resultIndex selfSize |
	occurrences := self occurrencesOfSubCollection: targetElements.
	findSize := targetElements size.
	replaceSize := replacementElements size.
	extraSpace := (replaceSize - findSize) * occurrences.
	selfSize := self size.
	resultCollection := self copyLikeOfSize: selfSize + extraSpace.
	sourceIndex := 1.
	resultIndex := 1.
	
	[(index := self indexOfSubCollection: targetElements startingAt: sourceIndex) 
		> 0] 
			whileTrue: 
				["We have found a subCollection to replace.
		Copy the elements before the match."

				index > sourceIndex 
					ifTrue: 
						[resultCollection 
							replaceFrom: resultIndex
							to: resultIndex + index - sourceIndex - 1
							with: (self copyFrom: sourceIndex to: index - 1).
						resultIndex := resultIndex + index - sourceIndex.
						sourceIndex := index].
				"Copy the replacement collection."
				resultCollection 
					replaceFrom: resultIndex
					to: resultIndex + replaceSize - 1
					with: replacementElements.
				resultIndex := resultIndex + replaceSize.
				sourceIndex := sourceIndex + findSize].

	"Copy the collection following the last replacement (if any)."
	resultCollection 
		replaceFrom: resultIndex
		to: resultCollection size
		with: (self copyFrom: sourceIndex to: selfSize).
	^resultCollection.
	#todo	"This implementation does not look very efficient. Might be better to use Streams.
			OR a collection of the positions should be created, and then the construction of the copy
			could use that."!

copyReplaceFrom: start to: stop with: replacementElements
	"Answer a new <sequencedReadableCollection> which is a copy of the receiver
	but in which all elements of the receiver between the <integer> indices
	start and stop (inclusive) have been replaced by the elements of the
	<sequencedReadableCollection> replacementElements. The latter need not 
	be the same size as the range of elements being replaced.

	This message can be used to insert, append, or replace, so the rules are quite complicated!!
		If stop is less than start, then replacementElements is inserted in the receiver:
		If start = 1, then prepend
		If start = size+1 then append
		stop must = start-1
		Else treat as replacement"

	| newSize repSize |
	repSize := replacementElements size.
	newSize := self size + repSize - (stop - start + 1).
	^(self copyLikeOfSize: newSize)
		replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1;
		replaceFrom: start
			to: start + repSize - 1
			with: replacementElements
			startingAt: 1;
		replaceFrom: start + repSize
			to: newSize
			with: self
			startingAt: stop + 1!

copyReplaceFrom: start to: stop withObject: replacementElement
	"Answer a new <sequencedReadableCollection> which is a copy of 
	the receiver, but with the elements between the <integer> indices start
	to stop (inclusive) replaced with the <Object> replacementElement.

	This message can be used to insert, append, or replace:
	1) stop = start - 1, and start <= receiver size. This is the insert operation:
	The Replacement element is inserted between the elements at stop and 
	start. No elements are actually replaced.
	2) stop = receiver size, and start = stop + 1. This is the append operation:
	replacementElement is appended to the new collection.
	3) Otherwise the operation is a replacement and each of the elements
	in the specified range is replaced in the copy with replacementElement."

	| answer size |
	size := self size.
	(start < 1 or: [start > (size + 1)]) 
		ifTrue: [^self errorSubscriptBounds: start].
	(stop > size or: [stop < (start - 1)]) 
		ifTrue: [^self errorSubscriptBounds: stop].
	(stop = (start - 1) and: [start <= size]) 
		ifTrue: 
			["Insert"

			^(self copyLikeOfSize: size + 1)
				replaceFrom: 1
					to: stop
					with: self
					startingAt: 1;
				at: start put: replacementElement;
				replaceFrom: start + 1
					to: size + 1
					with: self
					startingAt: start;
				yourself].
	(stop = size and: [start = (stop + 1)]) 
		ifTrue: 
			["Append"

			^self copyWith: replacementElement].

	"Replace"
	answer := self copyLikeOfSize: size.
	answer 
		replaceFrom: 1
		to: start - 1
		with: self
		startingAt: 1.
	start to: stop do: [:i | answer at: i put: replacementElement].
	answer 
		replaceFrom: stop + 1
		to: size
		with: self
		startingAt: stop + 1.
	^answer!

copyReplacing: targetElement withObject: replacementElement
	"Answer a new <sequencedReadableCollection> which is a copy 
	of the receiver, but in which any occurrences of the <Object> targetElement
	are replaced with the <Object> replacementElement."

	^self collect: [:each | each = targetElement 
		ifTrue: [replacementElement] 
		ifFalse: [each]].!

copyWith: newElement
	"Answer a <sequencedReadableCollection> which is a copy of 
	the receiver that has newElement concatenated to its end."

	| size |
	size := self size.
	^(self copyLikeOfSize: size + 1)
		at: size + 1 put: newElement;
		replaceFrom: 1
			to: size
			with: self
			startingAt: 1!

copyWithout: oldElement
	"Answer a <sequencedReadableCollection> which is a copy of the receiver, but in
	which all occurrences of the <Object> oldElement have been removed."

	| aStream |
	aStream := (self copyLikeOfSize: self copySize) writeStream.
	self 
		do: [:element | element = oldElement ifFalse: [aStream nextPut: element]].
	^aStream contents!

copyWithoutAll: oldElements
	"Answer a <sequencedReadableCollection> which is a copy of the receiver, but in
	which all occurrences of the elements of the <Collection> oldElements have been removed."

	| aStream |
	aStream := (self copyLikeOfSize: self copySize) writeStream.
	self 
		do: [:element | (oldElements includes: element) ifFalse: [aStream nextPut: element]].
	^aStream contents!

copyWithoutDuplicates
	"Answers a copy of the receiver that contains no duplicate objects.
	Uses equality for comparison."

	| set |
	set := self asSet.
	^self select: [:each | (set includes: each) 
		ifTrue: [ set remove:each. true ]
		ifFalse: [ false ]].!

do: operation 
	"Evaluate the <monadicValuable> argument, operation, for each of the receiver's elements.
	Answers the receiver. The elements are enumerated in index order."

	"Implementation Note: Implemented in terms of #keysAndValuesDo: to reduce the burden of
	subclassing SequenceableCollection. Where performance is an issue subclasses may want to
	override."

	self keysAndValuesDo: [:i :elem | operation value: elem]!

endsWith: aCollection
	"Answer whether the receiver begins with the sequence
	of objects in the <Collection> argument"

	| i |
	(i := self size - aCollection size + 1) < 1 ifTrue: [^false].
	aCollection do: 
			[:each | 
			(self at: i) = each ifFalse: [^false].
			i := i + 1].
	^true!

errorFirstObject: target
	"Private - Report an error to the effect that an attempt was made to access the object
	before the argument, target, where the latter is the last element of the receiver."

	^self error: target printString, ' is my first object'!

errorLastObject: target
	"Private - Report an error to the effect that an attempt was made to access the object
	after the argument, target, where the latter is the last element of the receiver."

	^self error: target printString, ' is my last object'!

errorValueNotFound: aValue
	"Private - Report that an attempt was made to look up the key for a value which was not
	in receiver"

	^self error: 'value not found: ', aValue printString
!

fifth
	"Answer an <Object> which is the fifth element of the receiver. 
	Raise an exception if the element does not exist."

	^self at: 5!

findFirst: discriminator
	"Answer the <integer> index of the first element of the receiver for which the 
	<monadicValuable> argument, discriminator, evaluates to true. If there are 
	no such elements, answer 0.
	Implementation Note: We use #keysAndValuesDo: because subclass' implementations of
	#at: may be quite slow (e.g. LinkedList)."

	self keysAndValuesDo: [:i :elem | (discriminator value: elem) ifTrue: [^i]].
	^0!

findLast: discriminator
	"Answer the <integer> index of the last element of the receiver for which the 
	<monadicValuable> argument, discriminator, evaluates to true. If there are 
	If there are no such elements, answer 0."

	self size to: 1 by: -1 do: [:i | (discriminator value: (self at: i)) ifTrue: [^i]].
	^0!

first
	"Answer an <Object> which is the first element of the receiver. 
	Raise an exception if the receiver contains no elements."

	^self at: 1!

first: anInteger
	"Answer a copy of the receiver comprising the leftmost anInteger elements."

	^self copyFrom: 1 to: anInteger!

fourth
	"Answer an <Object> which is the fourth element of the receiver. 
	Raise an exception if the element does not exist."

	^self at: 4!

from: anInteger do: operation 
	"Evaluate the <monadicValuable>, operation, for each element of the receiver from start,
	inclusive. <BoundsError> will be raised if either start or stop is out of bounds."

	self from: anInteger keysAndValuesDo: [:i :each | operation value: each]!

from: anInteger keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver starting with
	the element at the specified <integer> index. A <BoundsError> will be raised if either the
	starting index is out of bounds."

	self 
		from: anInteger
		to: self size
		keysAndValuesDo: operation!

from: startInteger to: stopInteger do: operation 
	"Evaluate the <monadicValuable>, operation, for each element of the receiver in the
	specified (inclusive) range. A <BoundsError> will be raised if either start or stop index is
	out of bounds."

	"Implementation Note: Implemented in terms of #from:to:keysAndValuesDo: to reduce the burden
	of subclassing SequenceableCollection."

	self 
		from: startInteger
		to: stopInteger
		keysAndValuesDo: [:i :each | operation value: each]!

from: startInteger to: stopInteger keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments."

	"Implementation Note: Do the bounds check up front to avoid the need to check
	on each access."

	startInteger < 1 ifTrue: [self errorSubscriptBounds: startInteger].
	stopInteger > self size ifTrue: [self errorSubscriptBounds: stopInteger].
	self 
		uncheckedFrom: startInteger
		to: stopInteger
		keysAndValuesDo: operation!

grow
	"Private - Increase the capacity of the receiver. Answer the receiver."

	self resize: self size + self growSize!

hash
	"Answer the <integer> hash value for the receiver.
	Implementation Note: This is not a terribly good hash function (in particular it
	exhibits very poor temporal stability), but it is quick, and alternatives involve expensive 
	iteration through the receiver's elements."

	| size |
	(size := self size) == 0 ifTrue: [^17171].
	^size + (self at: 1) hash + (self at: size) hash!

identityIndexOf: anElement
	"Answer the index of the first occurrence of the object which is the argument 
	anElement, within the receiver. If the receiver does not contain anElement, 
	answer 0. This method is the same as #indexOf:, but uses #== for comparison."

	^self nextIdentityIndexOf: anElement from: 1 to: self size!

identityIndexOf: anElement ifAbsent: exceptionBlock
	"Answer the index of the first occurrence of the object which is the argument 
	anElement, within the receiver. If the receiver does not contain anElement, answer 
	the result of evaluating the argument, exceptionBlock. This method is the same
	as #indexOf:ifAbsent:, but uses #== for comparison."

	| index |
	index := self identityIndexOf: anElement.
	^index == 0
		ifTrue: [exceptionBlock value]
		ifFalse: [index]!

includesAnyOf: aCollection 
	"Answer whether the receiver includes any of the elements in the <collection> argument."

	^(self indexOfAnyOf: aCollection startingAt: 1) ~~ 0!

includesKey: anInteger
	^anInteger between: 1 and: self size!

indexOf: target
	"Answer the <integer> index of the first element of the receiver which is 
	equal to the <Object> argument, target, within the receiver. If the receiver 
	does not contain any elements equal to target, answer 0."

	^self nextIndexOf: target from: 1 to: self size!

indexOf: target ifAbsent: exceptionHandler
	"Answer the <integer> index of the first element of the receiver which is 
	equal to the <Object> argument, target, within the receiver. If the receiver 
	does not contain any elements equal to target, answer the result of evaluating 
	the <niladicValuable>, exceptionHandler."

	| index |
	index := self indexOf: target.
	^index == 0
		ifTrue: [exceptionHandler value]
		ifFalse: [index]!

indexOfAnyOf: aCollection startingAt: anInteger 
	"Answer the one-based integer index of the first encountered element of the receiver which 
	is equal to one of the elements of the <Collection> argument, starting from the specified
	one-based <integer> index. If no occurrences are found, then answer 0."

	self from: anInteger
		keysAndValuesDo: [:i :elem | (aCollection includes: elem) ifTrue: [^i]].
	^0!

indexOfSubCollection: aSequenceableCollection
	"Answer the index of the first occurrence within the receiver of aSequenceableCollection,
	starting at index anInteger. If there are no such occurrences, answer 0."

	^self indexOfSubCollection: aSequenceableCollection startingAt: 1!

indexOfSubCollection: targetSequence startingAt: start 
	"Answer the <integer> index of the next occurrence within the 
	receiver of the <sequencedReadableCollection> targetSequence,
	starting at the <integer> index start.
	If there are no such occurrences, answer 0."

	| size subSize firstElement |
	subSize := targetSequence size.
	subSize == 0 ifTrue: [^0].
	firstElement := targetSequence at: 1.
	size := self size.
	subSize == 1 
		ifTrue: 
			[^self 
				nextIndexOf: firstElement
				from: start
				to: size].
	start to: size - subSize + 1
		do: 
			[:i | 
			(self at: i) = firstElement 
				ifTrue: 
					[| j |
					j := 2.
					[(self at: i + j - 1) = (targetSequence at: j)] whileTrue: 
							[j = subSize ifTrue: [^i].
							j := j + 1]]].
	^0!

indexOfSubCollection: targetSequence startingAt: start ifAbsent: exceptionHandler
	"Answer the <integer> index of the next occurrence within the 
	receiver of the <sequencedReadableCollection> targetSequence,
	starting at the <integer> index start.
	If no such match is found, answer the result of evaluating the 
	<niladicValuable>, exceptionHandler."

	| index |
	index := self indexOfSubCollection: targetSequence startingAt: start.
	^index == 0
		ifTrue: [exceptionHandler value]
		ifFalse: [index]!

keyAtEqualValue: value ifAbsent: exceptionHandler
	"Answer the <integer> key of the <object> argument, value. 
	If there is no such element, answer the result of evaluating the 
	niladic valuable, exceptionHandler.
	N.B. Equality is used for comparison of the values (this increases the chances of 
	returning any duplicates the collection might contain)."

	^self indexOf: value ifAbsent: exceptionHandler!

keyAtValue: value 
	"Answer the <integer> key of the <Object> argument, value. 
	If there is no such value, send #errorNotFound: to the receiver with 
	value as its argument.
	N.B. Since elements are not necessarily unique, answer the index of the 
	first one encountered in a serial search."

	| index |
	index := self keyAtValue: value ifAbsent: [AbsentCookie].
	^index == AbsentCookie ifTrue: [self errorValueNotFound: value] ifFalse: [index]!

keyAtValue: value ifAbsent: operation
	"Answer the <integer> key of the <Object> argument, value. 
	If there is no such value, answer the result of evaluating the 
	<niladicValuable>, operation. Identity is used for comparison of the values."

	^self identityIndexOf: value ifAbsent: operation!

keys
	"Answer a <collection> containing the receiver's keys."

	^1 to: self size!

keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	with the <integer> index of that element and the element itself as the arguments."

	"Implementation Note: Subclasses should override #from:to:keysAndValuesDo: rather 
	than this method, unless they have a slow implementation of #size, or one that 
	relies on #countElements (since that uses #do: to calculate the size and may
	therefore go infinitely recursive)."

	self 
		uncheckedFrom: 1
		to: self size
		keysAndValuesDo: operation!

last
	"Answer the <Object> which is the last element of the receiver. 
	Raise an exception if the receiver contains no elements."

	^self at: self size!

last: anInteger
	"Answer a copy of the receiver comprising the rightmost anInteger elements."

	| size |
	size := self size.
	^self copyFrom: (size + 1 - anInteger) to: size!

lastIndexOf: target
	"Answer the <integer> index of the last element of the receiver which is 
	equal to the <Object> argument, target, within the receiver. If the receiver 
	does not contain any elements equal to target, answer 0."

	^self prevIndexOf: target from: self size to: 1!

lastIndexOf: anObject ifAbsent: exceptionHandler 
	"Answer the <integer> index of the last element of the receiver which is 
	equal to the <Object> first argument within the receiver. If the receiver 
	does not contain any elements equal to target, answer the result of 
	evaluating the <niladicValuable>, exceptionHandler."

	"Included for compatibility with Visual Works"

	| index |
	^(index := self lastIndexOf: anObject) == 0 
		ifTrue: [exceptionHandler value]
		ifFalse: [index]!

nextIdentityIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Subclasses may be able to provide a more efficient implementation using 
	#primIdentityIndexOf:from:to:."

	self from: start to: stop keysAndValuesDo: [:i :elem | elem == anElement ifTrue: [^i]].
	^0!

nextIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver between 
	startIndex and stopIndex inclusive. If there are no such occurrences, answer 0."

	self from: start to: stop keysAndValuesDo: [:i :elem | elem = anElement ifTrue: [^i]].
	^0!

occurrencesOfSubCollection: aSubCollection
	"Private - Answer the number of occurrences of aSubCollection in the receiver."

	| index count size |
	index := 1.
	count := 0.
	size := aSubCollection size.
	[(index := self indexOfSubCollection: aSubCollection startingAt: index) > 0] whileTrue: [ 
		count := count + 1.
		index := index + size].
	^count!

prevIndexOf: anElement from: start to: stop
	"Answer the index of the occurrence of anElement in the receiver between previous
	to start, but after stop. If there are no such occurrences, answer 0."

	start to: stop by: -1 do: [ :i | (self at: i) = anElement ifTrue: [ ^i ]].
	^0!

prevIndexOfSubCollection: aSequenceableCollection startingAt: anInteger 
	"Answer the index of the previous occurrence within the receiver between startIndex and stopIndex
	of aSequenceableCollection, before the element with index, anInteger. If there are no previous
	occurrences of aSequenceableCollection, answer 0."

	| subSize firstElement |
	(subSize := aSequenceableCollection size) == 0 ifTrue: [^0].
	firstElement := aSequenceableCollection at: 1.
	subSize == 1 
		ifTrue: 
			[^self 
				prevIndexOf: firstElement
				from: anInteger
				to: 0].
	anInteger to: 1
		by: -1
		do: 
			[:i | 
			(self at: i) = firstElement 
				ifTrue: 
					[| j |
					j := 2.
					[(self at: i + j - 1) = (aSequenceableCollection at: j)] whileTrue: 
							[j = subSize ifTrue: [^i].
							j := j + 1]]].
	^0!

prevIndexOfSubCollection: aSequenceableCollection startingAt: anInteger ifAbsent: exceptionBlock
	"Answer the index of the previous occurrence within the receiver between startIndex and stopIndex
	of aSequenceableCollection, before the element with index, anInteger. If there are no previous
	occurrences of aSequenceableCollection, answer the result of evaluating exceptionBlock."

	| index |
	index := self prevIndexOfSubCollection: aSequenceableCollection startingAt: anInteger.
	^index == 0
		ifTrue: [exceptionBlock value]
		ifFalse: [index]
!

readStream
	"Answer a ReadStream on the receiver."

	^ReadStream on: self!

remove: oldElement ifAbsent: exceptionHandler
	"Remove the <Object> oldElement from the receiver's elements.
	Raise an exception, as SequenceableCollections are not (in general) 
	contractible."

	^self shouldNotImplement!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one sequence of bytes (or characters)
	to another, normally double dispatched from #replaceFrom:to:with:startingAt:
	by byte subclasses. Implementing this message at this level allows for the concatenation
	of character arrays to strings, for example.
	Implementation Note: It is assumed that the receiver and the argument,
	cannot be the same object, which will be the case for correctly defined subclasses
	which must override this implementation.."

	| fromOffset |
	fromOffset := fromStart - start.
	start to: stop do: [:i | aByteObject at: i put: (self at: i + fromOffset)].
	^aByteObject!

replaceFrom: start to: stop with: replacementElements
	"Destructively replace the elements of the receiver between the <integer> arguments
	start and stop with the <Object> elements of the <sequencedReadableCollection> argument, 
	replacementElements. Answer the receiver. Raise an Exception if  replacementElements does 
	not contain the number of elements required to exactly fill the replacement interval in the receiver."

	replacementElements size = (stop - start + 1)
		ifFalse: [^self error: 'size of replacement incorrect'].
	^self replaceFrom: start to: stop with: replacementElements startingAt: 1!

replaceFrom: start to: stop with: replacementElements startingAt: repStart
	"Destructively replace the elements of the receiver between the <integer> arguments
	start and stop with the <Object> elements of the <sequencedReadableCollection> 
	argument, replacementElements beginning with its element with <integer> index 
	repStart. Answer the receiver. Overlapping moves are correctly handled.
	Unlike #replaceFrom:to:with:, the size of replacementElements is not checked
	directly (X3J20 does not specify that this should be an error), but an error will
	be raised when an attempt is made to access an out-of-bounds element in
	replacementElements.
	N.B. It is not an error to specify an empty replacement interval, even if
	start, stop, and/or repStart are out-of-bounds (this is compatible with the major
	implementations).
	Implementation Note: The performance of this method is very important to overall 
	system performance. This implementation is mostly inlined by the compiler."

	| offset |
	offset := repStart - start.
	(self == replacementElements and: [repStart < start])
		ifTrue: [
			"Move within same object overlaps, so do backwards"
			stop to: start by: -1 do: [:i |
				self at: i put: (replacementElements at: offset + i)]]
		ifFalse: [
			"Non-overlapping moves are done forwards"
			start to: stop do: [:i |
				self at: i put: (replacementElements at: offset + i)]]!

replaceFrom: start to: stop withObject: replacementElement
	"Destructively replace the elements of the receiver between the
	<integer> indices start and stop with the <Object> argument,
	replacementElement. Answer replacementElement."

	start to: stop do: [:i | self at: i put: replacementElement].
	^replacementElement!

resize: anInteger
	"Private - Resize the receiver to accomodate anInteger elements.
	Answer the receiver."

	(self copyEmpty: anInteger)
		replaceFrom: 1 to: self size with: self startingAt: 1;
		become: self!

reverse
	"Answer a new <sequencedReadableCollection> which contains the same elements
	as the receiver, but in reverse order."

	| answer i |
	i := self size.
	answer := self copyLikeOfSize: i.
	self do: 
			[:element | 
			answer at: i put: element.
			i := i - 1].
	^answer!

reverseDo: operation
	"Evaluate the <monadicValuable> argument, operation, against each 
	element of the receiver in reverse order, from end to start."

	self size to: 1 by: -1 do: [:i | operation value: (self at: i)]!

runsAndValuesDo: aDyadicValuable 
	"Evaluate the <dyadicValuable> argument passing it the length of each run of equal values in
	the receiver, and the corresponding value. This is obviously most efficient with a <RunArray>."

	| runLength current |
	runLength := 0.
	self do: 
			[:each | 
			runLength == 0 
				ifTrue: 
					[runLength := 1.
					current := each]
				ifFalse: 
					[each = current 
						ifTrue: [runLength := runLength + 1]
						ifFalse: 
							[aDyadicValuable value: runLength value: current.
							current := each.
							runLength := 1]]].
	runLength > 0 ifTrue: [aDyadicValuable value: runLength value: current]!

second
	"Answer an <Object> which is the second element of the receiver. 
	Raise an exception if the element does not exist."

	^self at: 2!

select: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements.
	Answer a new <collection> like the receiver containing only those elements for which 
	the discriminator evaluates to true."

	| aStream |
	aStream := self species writeStream: self copySize.
	self keysAndValuesDo: [:i :elem |
		(discriminator value: elem) ifTrue: [aStream nextPut: elem]].
	^aStream contents!

sixth
	"Answer an <Object> which is the sixth element of the receiver. 
	Raise an exception if the element does not exist."

	^self at: 6!

size
	"Answer the <integer> number of elements in the receiver."

	^self subclassResponsibility!

skipOver: stream
	"Private - Answer whether the receiver matches the contents of <sequencedStream> stream
	taking account of any case differences. Answers true if a complete match is
	found, false otherwise. If a match is found then the stream is left pointing to the next character
	following the match. If not, the stream position is left unchanged."

	| originalPosition |
	originalPosition := stream position.
	self do: [ :each | 
		(stream atEnd or: [stream next~=each]) ifTrue: [ 
			stream position: originalPosition. ^false]].
	^true
!

swap: integerIndex1 with: integerIndex2
	"Swap the elements of the receiver at the specified indices"

	| element |
	element := self at: integerIndex1.
	self at: integerIndex1 put: (self at: integerIndex2).
	self at: integerIndex2 put: element!

third
	"Answer an <Object> which is the third element of the receiver. 
	Raise an exception if the element does not exist."

	^self at: 3!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver in the
	specified inclusive range, with the element and its index as respectively the second and
	first arguments. No bounds checks need be performed since the caller has established that
	the start and stop indices are in bounds."

	"Implementation Note: Subclasses should override this method in order to replace all #do:
	family enumerators (#do:, #keysAndValuesDo:, #from:to:do:, and, of course,
	#from:to:keysAndValuesDo:). Subclasses may also want to override this if they have a slow
	implementation of the random accessor method #at:, but can be more efficiently accessed
	serially (e.g. a singly Linked List), or if they have to calculate their size using
	#countElements (which would cause an infinite recursion as it uses #do:, which uses #size,
	...)."

	startInteger to: stopInteger do: [:i | aDyadicValuable value: i value: (self at: i)]!

upTo: target
	"Answer a new <sequencedReadableCollection> containing the elements of 
	the receiver up to the specified target, or if the target is not present in the receiver, 
	the rest of the receiver.

	Implementation Note: This is a convenient shortcut method for:
		self readStream upTo: target
	And is usually faster since the Streams implementation is generic."

	^self copyFrom: 1 to: (self indexOf: target ifAbsent: [self size+1])-1!

with: otherCollection do: operation
	"Evaluate the <dyadicValuable> argument, operation, with each of 
	the receiver's elements along with the corresponding element from the 
	<sequencedReadableCollection> argument, otherCollection. 
	Raise an exception if otherCollection is not the same size as the receiver."

	self size = otherCollection size
		ifFalse: [^self error: 'collections are of different sizes'].
	self keysAndValuesDo: [:i :elem |
		operation
			value: elem
			value: (otherCollection at: i)]!

writeStream
	"Answer a WriteStream on the receiver."

	^WriteStream on: self! !

Set comment:
'Set is a generic collection class which represents an unordered, extensible/contractible, collection, accessible only by value, not by external keys. Element comparison is by equality (i.e. using #hash and #=).'!
!Set class methodsFor!

initialize
	"Private - Initialize the receiver's class variables."

	self initializeSizeTable!

initializeSizeTable
	"Private - Construct a difference table which can be used to calculate the nearest 
	larger prime for each odd integer up to a certain limit.  The greater the limit the more
	table space is used, although as this is a byte array this isn't likely to be a problem.
	Ultimately the use of a byte array limits the table size since at some point the offset
	to the next prime will be greater than 255.

		self initializeSizeTable
	"

	| primes last count max |
	max := (2**12)+1.	"Max size for which entry will be found in table"
	primes := Integer primesUpTo: max+255.
	count := max bitShift: -1.
	SmallPrimeOffsets := ByteArray new: count.
	last := 1.
	1 to: count do: [:i | | n p |
		n := (i bitShift: 1) bitOr: 1.
		[(p := primes at: last) >= n] whileFalse: [last := last + 1].
		SmallPrimeOffsets at: i put: p - n]!

new
	"Answer a new instance of the receiver with the default initial capacity.
	Implementation Note: Although it is tempting to implement this using
	#basicNew: to avoid going through the sizing code, that makes subclassing
	much more fragile (e.g. they will often need to override #new as well as
	#new:), so avoid the temptation."

	^self new: 2!

new: count
	"Answer a new instance of the receiver with an initial capacity of at least 
	<integer> count elements (i.e. the size is a hint)."

	^(self basicNew: (self sizeFor: count)) initialize!

sizeFor: anInteger
	"Private - Answer the size of Set that should be created to hold anInteger elements.
	This formula should be kept in step with that in the instance method #privateAt:put:.
	Try to answer only prime sizes as these give a better hash distribution."

	^anInteger < 2 
		ifTrue: 
			["Minimum capacity of Dolphin hashed collection is 2"

			2]
		ifFalse: 
			[| n i |
			n := anInteger * 100 // 75 bitOr: 1.
			i := n bitShift: -1.
			^i > SmallPrimeOffsets basicSize 
				ifTrue: 
					["Larger sizes just left odd"

					n]
				ifFalse: 
					["Calculate nearest prime larger than requested size plus 25% slop"

					(SmallPrimeOffsets basicAt: i) + n]]! !

!Set methodsFor!

- others
	"Answer a <Set> containing the elements of the receiver that are 
	not present in the <collection>, others."

	^self reject: [:each | others includes: each]!

_deepCopy: anIdentityDictionary 
	"Private - Answer a 'deep copy' of the receiver, cloning only those parts not already included
	in the <IdentityDictionary> argument."

	^anIdentityDictionary at: self
		ifAbsent: 
			[| clone |
			clone := self copyEmpty.
			anIdentityDictionary at: self put: clone.
			self _deepCopyElementsInto: clone trail: anIdentityDictionary.
			clone]!

_deepCopyElementsInto: aSet trail: anIdentityDictionary 
	self do: [:element | aSet uncheckedAdd: (element _deepCopy: anIdentityDictionary)]!

add: newElement
	"Include the <Object> newElement as one of the elements of the receiver. 
	If newElement is nil, then it is not added. Answer newElement.
	Note: If newElement is already in the receiver (i.e. has an equal element 
	already in the receiver), then this operation has no effect. Note further
	that if an equal element already exists then it is not overwritten, but the
	answer is still newElement. I tried to persuade the committee that the original
	element should be answered, but they didn't see the problem."

	| index |
	newElement isNil ifTrue: [^newElement].		"Sets cannot store empty objects"
	index := self findElementOrNil: newElement.
	(self basicAt: index) isNil
		ifTrue: [self privateAt: index put: newElement].
	^newElement!

approxSize
	"Private - Answer the approximate size of the receiver.
	Implementation Note: Sets keep a tally, so we can use the actual size."

	^self size!

asSet
	"Answer a <Set> whose elements are those stored in the receiver 
	(any duplicates are therefore eliminated)."

	^self!

at: index
	"Generate an exception to the effect that Sets are not keyed."

	^self errorNotKeyed
!

at: index put: value
	"Generate an exception to the effect that Sets are not keyed."

	^self errorNotKeyed
!

averageProbesPerElement
	"Answer the average number of probes necessary to  find an element 
	in the receiver. Ideally this should be close to 1."

	| probes capacity |
	self isEmpty ifTrue: [^1].
	probes := 0.
	capacity := self basicSize.
	1 to: capacity
		do: 
			[:i | 
			| element |
			element := self basicAt: i.
			element notNil 
				ifTrue: 
					[| pos distance |
					pos := self bestSlotFor: element boundedBy: capacity.
					distance := i - pos.
					distance < 0 ifTrue: [distance := distance + capacity].
					probes := probes + distance + 1]].
	^probes asFloat / self size!

bestSlotFor: element boundedBy: capacity
	^self hash: element max: capacity!

collisions
	"Answer the <Integer> number of the elements which are not found
	on first probe."

	| answer capacity |
	answer := 0.
	capacity := self basicSize.
	1 to: capacity
		do: 
			[:i | 
			| element |
			element := self basicAt: i.
			element notNil 
				ifTrue: 
					[(self hash: element max: capacity) ~= i ifTrue: [answer := answer + 1]]].
	^answer!

copyElementsInto: newMe
	"Private - Add the receiver's elements into the argument, newMe.
	Part of the implementation of hashed collection resizing. Subclasses
	override as necessary."

	self do: [:element | newMe uncheckedAdd: element]!

copyWithoutDuplicates
	"Answers a copy of the receiver that contains no duplicate objects. 
	Implementation Note: Sets are already free of duplicates so a plain
	copy will do."

	^self shallowCopy!

do: operation 
	"Evaluate the <monadicValuable> argument, operation, for each of the 
	elementss of the receiver. Answers the receiver."

	tally == 0 ifTrue: [^self].	"Nothing to do"
	1 to: self basicSize
		do: [:index | (self basicAt: index) ifNotNil: [:element | operation value: element]]!

elements
	"Private - Answers the contents of the receiver as an OrderedCollection"

	^self asOrderedCollection!

elements: anOrderedCollection
	"Private - Sets the contents of the receiver from anOrderedCollection"

	| originalContents|
	originalContents:= self shallowCopy.
	self removeAll: originalContents.
	self addAll: anOrderedCollection.
!

equals: comperand
	"Answer whether the receiver is equivalent to the <Object>, comperand.
	I often think this ought to be the definition of Set>>=, but for compatibility
	with other Smalltalks, we'll use the alternative selector.
	Implementation Note: Do our best to avoid an element-by-element
	comparison. The algorithm will be slowest where the comperand is
	equal to the receiver, but not identical."

	comperand == self ifTrue: [^true].
	comperand species == self species ifFalse: [^false].
	comperand size == self size ifFalse: [^false].
	self do: [:e | (comperand includes: e) ifFalse: [^false]].
	^true!

find: target
	"Answer the actual element of the receiver which matches (however 'match' is defined)
	the argument, target. This can be useful when eliminating duplicates."

	^self find: target ifAbsent: [self errorNotFound: target]!

find: target ifAbsent: exceptionHandler 
	"Answer the actual element of the receiver which matches (however 'match' is defined)
	the argument, target. If there is no such element, then the result of evaluating the
	niladic valuable, exceptionHandler, is answered."

	^(self basicAt: (self findElementOrNil: target)) ifNil: [exceptionHandler value]!

findElementOrNil: anObject 
	"Private - Answer the index of the given object in the receiver, or, if not found,
	the index of the first empty slot including and after that to which the object hashes.
	Implementation Note: This implementation is tuned to give the best performance on the
	current VM. Although it might seem worthwhile unrolling the loop to avoid performing
	a division operation inside the loop, in practice that operation is rarely taken and
	average performance suffers from the extra temporaries used."

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [anObject = element]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

fixCollisionsFrom: index
	"Private - Rehashes objects in the collection after index to see if any of
	them hash to index.  If so, that object is copied to index, and the
	process repeats with that object's index, until a nil is encountered."

	| slotIndex capacity element |
	slotIndex := index.
	capacity := self basicSize.
	[slotIndex := slotIndex \\ capacity + 1.
	  (element := self basicAt: slotIndex) isNil]
		whileFalse:  [ | hashIndex |
			hashIndex := self findElementOrNil: element.
			(self basicAt: hashIndex) isNil ifTrue: [self moveFrom: slotIndex to: hashIndex]]!

grow
	"Private - Expand the receiver to a capacity suitable for holding more elements"

	self resize: self size * 2!

hash: anObject max: anInteger
	^anObject hash \\ anInteger + 1!

identityIncludes: target
	"Answer whether the <Object> argument, target, is one of the receiver's elements.
	Implementation Note: If anObject is identical to any object in the Set, then
	it must also be equal to that object, which means it must have the same hash
	value as that object, and therefore we can use a hashed lookup to optimize
	this method over the serial search in the Collection implementation."

	| element |
	element := self basicAt: (self findElementOrNil: target).
	^element notNil and: [element == target]!

includes: target
	"Answer whether the <Object> argument, target, is one of 
	the elements of the receiver."

	^(self basicAt: (self findElementOrNil: target)) notNil!

initialize
	"Private - Instance variable initialization. The tally records the number of elements."

	tally := 0
!

moveFrom: fromIndex to: toIndex
	"Private - Destructively move the element at index, fromIndex, over
	the element (normally nil) at index, toIndex. Must be overridden by subclasses
	with a different structure which wish to inherit the collision repair mechanism."

	self basicAt: toIndex put: (self basicAt: fromIndex).
	self basicAt: fromIndex put: nil!

occurrencesOf: target
	"Answer an <integer> which is the number of occurrences of target in the receiver.
	Implementation Note: Sets cannot contain duplicates, so this is either 0 or 1"

	^(self includes: target) ifTrue: [1] ifFalse: [0]!

postResize: oldMe
	"Private - This message is sent by the receiver when resizing, after the
	receiver's elements have been added to a new Collection and the
	receiver has become that collection. It is a chance for the receiver
	to perform any final state changes needed."!

preResize: newMe
	"Private - This message is sent by the receiver when resizing, before the receiver's elements are added
	to newMe. It gives the receiver the opportunity to copy other parts of its state into newMe.
	See also, #postResize and #copyEmpty: (which is subtly different, since it is used for creating copies of the
	receiver, not for rebuilding it). Subclasses should implement as necessary."
!

privateAt: index put: newObject
	"Private - Insert newObject as the element of the receiver at index. Attempts to maintain the
	'optimal' load factor (and thereby ensures there is always a least one empty slot in the Set, an 
	invariant required by the search algorithm)."

	| capacity |
	self basicAt: index put: newObject.
	tally := tally + 1.
	capacity := self basicSize.
	capacity - tally <= (capacity bitShift: -2) ifTrue: [self grow].
	^newObject!

rehash
	"Rehash the receiver by making use of the resizing mechanism, which essentially builds a
	new collection. 
	Implementation Note: It is important that #resize: is not optimised as this method
	is used to reconstruct valid Sets from invalidated ones (e.g. where the hash value of
	an Object has changed)."

	self resize: self size!

remove: anObject ifAbsent: aBlock 
	"If oldObject is one of the receiver's elements, then remove it from the receiver 
	and answer oldObject (as Sets cannot contain duplicates, only one element is ever 
	removed). If oldObject is not an element of the receiver (i.e. no element of the 
	receiver is #= to oldObject) then answer the result of evaluating aBlock."

	| index |
	index := self findElementOrNil: anObject.
	^(self basicAt: index) 
		ifNil: [aBlock value]
		ifNotNil: 
			[:element | 
			self removeIndex: index.
			element]!

removeIndex: anInteger
	"Private - Remove the element at index, anInteger, in the receiver. Does not
	check that the element is empty."

	self basicAt: anInteger put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: anInteger!

resize: anInteger
	"Private - Resize the receiver to have a capacity suitable for accomodating
	at least anInteger elements. Answer the receiver (resized). The receiver is
	rehashed regardless of whether it is already of the correct capacity (this
	is important)."

	| newMe |
	newMe := self copyEmpty: anInteger.
	self preResize: newMe.
	self copyElementsInto: newMe.
	self become: newMe.
	"newMe is now the old me!!"
	self postResize: newMe
!

shrink
	"Rebuild the collection with the optimal size for its current number of elements,
	as #rehash, but doesn't resize if already correct size."

	| size |
	size := self size.
	(self basicSize = (self class sizeFor: size)) 
		ifFalse: [self resize: size]!

size
	"Answer an <integer> specifying the number of elements in the receiver."

	^tally!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBCollectionProxy forCollection: self)!

uncheckedAdd: newObject
	"Private - Add newObject to the receiver, without checking to see if it is already present.
	We also assume the receiver is large enough to accommodate the new element, and so do not
	attempt to maintain the load factor."

	tally := tally + 1.
	^self basicAt: (self findElementOrNil: newObject) put: newObject! !

ArrayedCollection comment:
'ArrayedCollection is the class of <SequenceableCollection>s of a fixed size which are indexable by integer keys from 1 to the size of the collection.'!
!ArrayedCollection class methodsFor!

new
	"Answer a new, empty, instance of the receiver."

	^self new: 0!

new: elementCount withAll: elementValue
	"Answer a new instance of the receiver with <integer>, elementCount, 
	elements, each of which is initialized to the <Object>, elementValue.
	Included mainly for compatibility with VisualWorks."

	^(self new: elementCount)
		atAllPut: elementValue;
		yourself!

with: element1
	"Answer a new instance of the receiver containing the single 
	<Object> element, element1."

	^(self new: 1)
		at: 1 put: element1;
		yourself!

with: element1 with: element2
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements"

	^(self new: 2)
		at: 1 put: element1;
		at: 2 put: element2;
		yourself!

with: element1 with: element2 with: element3
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements."

	^(self new: 3)
		at: 1 put: element1;
		at: 2 put: element2;
		at: 3 put: element3;
		yourself!

with: element1 with: element2 with: element3 with: element4
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements."

	^(self new: 4)
		at: 1 put: element1;
		at: 2 put: element2;
		at: 3 put: element3;
		at: 4 put: element4;
		yourself!

with: element1 with: element2 with: element3 with: element4 with: element5
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements.
	N.B. This is not an ANSI standard method (up to 4 elements are supported
	by <Array factory> #with:&c messages, for more one must use #withAll:)."

	^(self new: 5)
		at: 1 put: element1;
		at: 2 put: element2;
		at: 3 put: element3;
		at: 4 put: element4;
		at: 5 put: element5;
		yourself!

withAll: newElements
	"Answer a new instance of the receiver containing all of the 
	elements of the <collection> newElements."

	| answer |
	answer := self new: newElements size.
	newElements inject: 1 into: [:i :elem | answer at: i put: elem. i + 1].
	^answer! !

!ArrayedCollection methodsFor!

add: newElement
	"ArrayedCollections are not, in general, extensible."

	^self shouldNotImplement!

at: index
	"Answer the receiver's indexed element at the <integer> argument, index.
	Implementation Note: Subclasses are generally implemented as indexable objects,
	so we can use the indexable instance variable accessing primitive (i.e.
	revert to the Object implementation)."

	<primitive: 60>
	^self errorAt: index!

at: index put: newElement
	"Replace the element of the receiver at the specified <integer> index with 
	the <Object> argument, newElement. If the index is out of bounds, raise 
	a BoundsError.

	Implementation Note: Subclasses are generally implemented as indexable objects,
	so we can use the indexable instance variable accessing primitive (i.e.
	revert to the Object implementation)."

	<primitive: 61>
	^self errorAt: index put: newElement!

do: operation
	"Evaluate the <monadicValuable> argument, operation, for each of the elements of the 
	receiver. Answers the receiver. The elements are evaluated in index order.
	Implementation Note: Override the superclass for efficiency."

	1 to: self size do: [:i | operation value: (self at: i)]!

findFirst: discriminator
	"Answer the index of the first element of the receiver for which the monadic
	valuable argument, discriminator, evaluates to true. If there are no such elements,
	answer 0.
	Implementation Note: Override superclass to provide a more efficient implementation.
	ArrayedCollections have a very fast implementation of #at:, so it is better to inline
	the loop."

	1 to: self size do: [:i | (discriminator value: (self at: i)) ifTrue: [^i]].
	^0!

identityIncludes: anObject
	"Answer whether the argument, anObject, is one of the receiver's elements.
	Override superclass to provide a more efficient implementation (hence the
	esoteric logic ops)."

	^((self nextIdentityIndexOf: anObject from: 1 to: self size) == 0) == false!

includes: target
	"Answer whether the argument, target, is one of the elements of the receiver.
	Implementation Note: Override superclass to provide a more efficient implementation."

	1 to: self size do: [:i | target = (self at: i) ifTrue: [^true]].
	^false!

nextIdentityIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Override the inherited implementation to make use of the primitive"

	^self basicIdentityIndexOf: anElement from: start to: stop	!

nextIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver between 
	startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Implementation Note: Override the superclass to provide a more efficient
	inlined implementation."

	start to: stop do: [:i | (self at: i) = anElement ifTrue: [^i]].
	^0!

replaceIdentity: anObject with: newElement
	"If the receiver contains an identity match for anObject replace the first with newElement, 
	otherwise increase the size of the receiver, and append newElement. Answer the index.
	This is a very useful method in many system support tasks (e.g. the Dependency mechanism)"

	| size index |
	size := self size.
	index := self nextIdentityIndexOf: anObject from: 1 to: size.
	index == 0 ifTrue: [ 
		index := size + 1.
		self resize: index ].
	self at: index put: newElement.
	^index!

resize: anInteger
	"Override back to the primitive implementation for indexable objects (see Object>>resize:)"

	<primitive: 101>
	^super resize: anInteger!

size
	"Answer the size of the collection. 
	Implementation Note: Subclasses are generally implemented as indexable objects,
	so we can use the indexable instance variable size primitive.
	This primitive should not fail."

	<primitive: 62>
	^self primitiveFailed

!

sortUsing: aSortAlgorithm
	"Perform an in-place sort against the receiver using the specified sort algorithm"
	
	aSortAlgorithm 
		sort: self
		from: 1
		to: self size! !

Interval comment:
'<Interval>s represent a finite arithmetic progressions, that is a <sequencedReadableCollection> of numbers across a specified range and with a specified step between each element.

Instance Variables:
	start	<number>. First element in the collection.
	stop	<number>. Last element in the collection.
	step	<number>. Difference between elements of the collection (approximate where the elements are Floats)
'!
!Interval class methodsFor!

from: fromNumber to: toNumber 
	"Answer a new instance of the receiver representing the interval 
	between the <number> arguments from and to inclusive in increments
	of the <integer> one."

	^self 
		from: fromNumber
		to: toNumber
		by: 1!

from: fromNumber to: toNumber by: byNumber 
	"Answer a new instance of the receiver representing the interval between the <number>
	arguments from and to inclusive in increments of the <number> by."

	<primitive: 157>
	^self basicNew 
		setFrom: fromNumber
		to: toNumber
		by: byNumber!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Use #from:to:[by:]"

	^self shouldNotImplement! !

!Interval methodsFor!

- delta
	"Answer a new Interval the same as the receiver, but negatively offset by the specified delta."

	^self class from: start - delta to: stop - delta by: step!

+ delta
	"Answer a new Interval the same as the receiver, but positively offset by the specified delta."

	^self class from: start + delta to: stop + delta by: step!

= anObject 
	"Answer whether the receiver and the <Object>, comparand, 
	are considered equivalent (that is they contain the same number
	of equivalent objects in the same order, and are of like class).
	The supersend ensures that expressions such as '(1 to: 5) = #(1 2 3 4 5)' are true"

	^(anObject isKindOf: self class) 
		ifTrue: [start = anObject start and: [step = anObject step and: [self size = anObject size]]]
		ifFalse: [super = anObject]!

add: newElement
	"Intervals are not extensible."

	^self shouldNotImplement!

at: index
	"Answer the <number> at index position anInteger in the receiver.

	This should probably be refined into the Interval protocol, because the 
	return value is restricted to <number>."

	^(index >= 1 and: [index <= self size])
		ifTrue: [start + (step * (index - 1))]
		ifFalse: [self errorSubscriptBounds: index]!

at: anInteger put: anObject
	"Replace the element at index anInteger of the receiver with anObject.
	Intervals are immutable."

	^self shouldNotImplement!

collect: transformer 
	"Evaluate the <monadicValuable> argument, transformer, for each of the receiver's elements.
	Answer a new <sequencedReadableCollection> 'like' the receiver containing the values returned 
	by the transformer on each evaluation."

	"Implementation Note: Superclass implmementation works, so this override for efficiency only."

	| answer size |
	size := self size.
	answer := self copyLike: size.
	1 to: size
		do: [:each | answer at: each put: (transformer value: start + (step * (each - 1)))].
	^answer!

displayOn: target 
	"Append, to the <puttableStream> argument, target, a string whose characters 
	are a description of the receiver as an end user would want to see it."

	target
		display: self start;
		nextPutAll: ' .. ';
		display: self stop!

first
	"Answer the first element of the receiver."

	self isEmpty ifTrue: [self errorSubscriptBounds: 1].
	^start
!

hash
	"Answer the <integer> hash value for the receiver."

	^(((start hash bitShift: 2) bitXor: stop hash) bitShift: 1) bitXor: step hash!

includes: anObject
	"Answer whether the <Object> argument, target, is one of the elements of the receiver.
	Implementation Note: This is based on John Brant's suggestion posted to comp.lang.smalltalk.dolphin,
	though it has been modified slightly to reduce the number of comparisons at the expense of some
	code clarity."

	anObject understandsArithmetic ifFalse: [^false].
	(step < 0 
		ifTrue: [anObject >= stop and: [anObject <= start]]
		ifFalse: [anObject >= start and: [anObject <= stop]]) ifFalse: [^false].
	^step isInteger 
		ifTrue: [(anObject - start) \\ step = 0]
		ifFalse: [start + (step * ((anObject - start) / step) rounded) = anObject]!

isEmpty
	"Answer whether the receiver contains any elements.
	Implementation note: Override superclass for improved performance."

	^step < 0 ifTrue: [start < stop] ifFalse: [stop < start]!

last
	"Answer the last <number> element of the receiver.
	This is not necessarily the same as the value of 'stop' 
	(e.g. if the step if non-integral)."

	self isEmpty ifTrue: [self errorSubscriptBounds: 1].
	^stop - (stop - start \\ step)!

printOn: target
	"Append, to the <puttableStream> argument, target, a string whose characters 
	are a description of the receiver as a developer would want to see it."

	target
		nextPut: $(;
		print: self start;
		nextPutAll: ' to: ';
		print: self stop.
	self step = 1 ifFalse: [
		target
			nextPutAll: ' by: ';
			print: self step].
	target nextPut: $)!

setFrom: startInteger to: stopInteger by: stepInteger
	"Private - Initialize the receiver's instance variables."

	start := startInteger.
	stop := stopInteger.
	step := stepInteger
!

size
	"Answer the inclusive size of the receiver."

	^self isEmpty 
		ifTrue: [0]
		ifFalse: [stop - start // step + 1]!

species
	"Answer the kind of <sequencedReadableCollection> that should result 
	from enumerations such as #collect: and #select: when applied against 
	the receiver.
	Note that this message helps to support the ANSI protocol refinements
	of the sequencedReadableCollection copying messages (e.g. #copyFrom:to:) 
	in the Interval protocol, without actually having to reimplement those 
	messages in the Interval class."

	^Array!

start
	"Answer the first element of the receiver."

	^start!

start: anInteger
	"Sets the first element of the receiver to anInteger"

	start := anInteger!

step
	"Answer the receiver's step."

	^step
!

step: anInteger
	"Sets the step element of the receiver to anInteger"

	step := anInteger!

stop
	"Answer the end of the receiver's interval. Depending on the step, this is not necessarily
	the last element of the receiver."

	^stop
!

stop: anInteger
	"Sets the last element of the receiver to anInteger"

	stop := anInteger!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	self printOn: aStream!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver
	between the specified <integer> indices, inclusive, with the element and its index as
	respectively the second and first arguments. No bounds checks are performed."

	"Implementation Note: Override because #at: is relative slow on Intervals. By overriding
	this one method we effectively replace the implementation of all the #do: family of
	enumerators."

	startInteger to: stopInteger do: [:i | aDyadicValuable value: i value: start + (step * (i - 1))]! !

SequencedGrowableCollection comment:
'SequencedGrowableCollection is the abstract class of sequenceable, contractible, and extensible collections.

SequencedGrowableCollections comply with the ANSI protocols:
	Object
	collection
	extensibleCollection
	sequencedReadableCollection
	sequencedContractibleCollection
	sequencedCollection
	sequencedExtensibleCollection'!
!SequencedGrowableCollection methodsFor!

add: newElement
	"Append, and answer, newElement as the last element of the receiver."

	^self addLast: newElement!

add: newElement after: target
	"Insert newElement as a new element of the receiver immediately after target. 
	Raise an exception if target is not present in the receiver. Answer newElement."

	^self add: newElement afterIndex: 
		(self indexOf: target ifAbsent: [self errorNotFound: target])!

add: newElement afterIndex: index
	"Add newElement to the receiver immediately after the element currently at the
	specified <integer> index. index must be between 0 and the receiver's current 
	size (if not raise an exception). Answer newElement."

	^self subclassResponsibility!

add: newElement before: target
	"Insert newElement as a new element of the receiver immediately before target. 
	Report an error if target is not present in the receiver. Answer newElement."

	^self add: newElement beforeIndex: 
		(self indexOf: target ifAbsent: [self errorNotFound: target])!

add: newElement beforeIndex: index
	"Add newElement to the receiver immediately before the element currently at the specified
	<integer> index (i.e. the newElement will then have that index). index must be between 1 
	and the receiver's current size plus 1 (if not raise an exception). Answer newElement."

	^self add: newElement afterIndex: index - 1!

addAll: newElements
	"Include all the elements of the argument, newElements, as the receiver's elements. 
	Answer newElements. Note that this modifies and answers the receiver, not a copy."

	^self addAllLast: newElements!

addAll: newElements after: target
	"Insert the elements of the collection, newElements, as new elements of the 
	receiver immediately after target. Answer the newly added elements.
	Raise an exception if target is not present in the receiver.
	Implementation Note: We could use reverseDo: to avoid having to keep
	updating the index, but not all Collections understand #reverseDo:
	because they are not all ordered."

	| index |
	index := self indexOf: target ifAbsent: [^self errorNotFound: target].
	^self addAll: newElements afterIndex: index!

addAll: newElements afterIndex: index
	"Add all of the elements in the <collection>, newElements, after the existing element of
	the receiver at the one-based <integer> index, index. Answer the newly added elements."

	newElements inject: index into: [:i :e | self add: e afterIndex: i. i + 1].
	^newElements!

addAll: newElements before: target
	"Insert the elements of the collection, newElements, as a new element of the 
	receiver immediately before target. Answer the newly added elements.
	Report an error if target is not present in the receiver."

	| index |
	index := self indexOf: target ifAbsent: [^self errorNotFound: target].
	^self addAll: newElements beforeIndex: index!

addAll: newElements beforeIndex: index
	"Add all of the elements in the <collection>, newElements, before the existing element of
	the receiver at the one-based <integer> index, index. Answer the newly added elements."

	^self addAll: newElements afterIndex: index-1!

addAllFirst: newElements
	"Prepend all elements of the <collection> newElements to the receiver,
	in the order that they appear in newElements (as determined by
	its implementation of #do:). Answer newElements.
	Note that the ANSI standard specifies that newElements must comply with
	<sequencedCollection>, but we relax this to <collection> since this
	is implementable purely in terms of #do: (or #inject:into: as here)..
	Implementation Note: Avoid #reverseDo:, as not understood by all collections."

	newElements inject: 0 into: [:i :e | self add: e afterIndex: i. i + 1].
	^newElements!

addAllLast: newElements
	"Append the elements of the <sequencedCollection>, newElements, to the receiver,
	in the order that they appear in newElements (as defined by its implementation
	of #do:). Answer newElements."

	newElements do: [:each | self addLast: each].
	^newElements!

addFirst: newElement
	"Insert newElement as the first element of the receiver."

	^self add: newElement afterIndex: 0
!

addLast: newElement
	"Insert newElement as the last element of the receiver."

	^self add: newElement afterIndex: self size!

remove: oldElement ifAbsent: exceptionHandler
	"Remove oldElement from the receiver, and answer it. If oldElement is
	not present in the receiver, answer the result of evaluating 
	the niladic block, exceptionHandler."

	^self removeAtIndex: (self indexOf: oldElement ifAbsent: [^exceptionHandler value])!

removeAll
	"Empty the receiver of all contents"

	^self subclassResponsibility!

removeAtIndex: index
	"Remove, and answer, the element of the receiver at the specified 
	<integer> index, by shuffling elements which succeed it down one slot.
	Raise a <BoundsError> if there is no element with that index."

	^self subclassResponsibility!

removeFirst
	"Remove and answer the first element of the receiver, 
	raising an exception if the receiver is empty."

	^self removeFirstIfAbsent: [self errorSubscriptBounds: 1]!

removeFirstIfAbsent: exceptionHandler
	"Remove and answer the first element of the receiver, but if the
	receiver is empty answer the result of evaluating the <niladicValuable>,
	exceptionHandler."

	self isEmpty ifTrue: [^exceptionHandler value].
	^self removeAtIndex: 1!

removeLast
	"Remove and answer the last element of the receiver, 
	raising an exception if the receiver is empty."

	^self removeLastIfAbsent: [self errorSubscriptBounds: 1]!

removeLastIfAbsent: exceptionHandler
	"Remove and answer the last element of the receiver, but if the
	receiver is empty answer the result of evaluating the <niladicValuable>,
	exceptionHandler."

	self isEmpty ifTrue: [^exceptionHandler value].
	^self removeAtIndex: self size! !

Array comment:
'Array is the class of <ArrayedCollection>s whose elements are arbitraty <Object>s.

Array complies with the ANSI protocols:
	Object
	collection
	sequencedReadableCollection
	sequencedCollection
	Array'!
!Array class methodsFor!

with: element1 
	"Answer a new instance of the receiver containing the single 
	<Object> element, element1."

	<primitive: 157>
	^super with: element1!

with: element1 with: element2 
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements"

	<primitive: 157>
	^super with: element1 with: element2!

with: element1 with: element2 with: element3 
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements."

	<primitive: 157>
	^super 
		with: element1
		with: element2
		with: element3!

with: element1 with: element2 with: element3 with: element4 
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements."

	<primitive: 157>
	^super 
		with: element1
		with: element2
		with: element3
		with: element4!

with: element1 with: element2 with: element3 with: element4 with: element5 
	"Answer an instance of the receiver containing the <Object>
	arguments as its elements."

	"N.B. This is not an ANSI standard method (up to 4 elements are supported
	by <Array factory> #with:&c messages, for more one must use #withAll:)."

	<primitive: 157>
	^super 
		with: element1
		with: element2
		with: element3
		with: element4
		with: element5! !

!Array methodsFor!

addAnsweringIndex: newElement
	"Add newElement to the receiver by overwriting the first nil. If there are no nils
	then append it."

	^self replaceIdentity: nil with: newElement!

asArray
	"Answer an instance of <Array> containing the same elements as the receiver.
	In this case, no conversion is required."

	^self!

isLiteral
	"Answer whether the receiver can be represented as a literal (i.e. it has a printed
	representation which can be directly understood by the compiler)."

	^self class == ##(self) and: [self allSatisfy: [:element | element isLiteral]]!

printPrefixOn: aStream
	"Private - Print a prefix string for the debug representation of the receiver on aStream."

	aStream nextPutAll: '#('!

refersToLiteral: anObject 
	"Private - Answer whether the receiver is a reference to the literal argument."

	self = anObject ifTrue: [^true].
	self do: [:each | (each refersToLiteral: anObject) ifTrue: [^true]].
	^false!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	"Implementation Note: The receiver has a compact literal form, so use that. Any
	elements that are not themselves representable as literals are embedded as 
	expressions to be evaluated at compile time, i.e. using ##()."

	aStream nextPutAll: '#('.
	self do: 
			[:each | 
			each isLiteral 
				ifTrue: [each storeOn: aStream]
				ifFalse: 
					[aStream nextPutAll: '##('.
					each storeOn: aStream.
					aStream nextPut: $)]]
		separatedBy: 
			[aStream
				cr;
				space].
	aStream nextPut: $)! !

ByteArray comment:
'ByteArray is the class of <ArrayedCollection>s whose elements are bytes (i.e. <integer>s in the range 0..255).

ByteArray complies with the ANSI protocols:
	Object
	collection
	sequencedReadableCollection
	sequencedCollection
	ByteArray'!
!ByteArray class methodsFor!

elementSize
	"Private - Answer the size of the receiver's constituent elements in bytes."

	^1.
!

fromAddress: anAddress length: anInteger
	"Answer a new instance of the receiver, of size anInteger, copied from the first anInteger
	bytes at the specified address."

	^anAddress asExternalAddress
		replaceBytesOf: (self new: anInteger)
		from: 1 to: anInteger startingAt: 1
!

fromHexString: aString
	"Answer a new instance of the receiver instantiated from the contents of the hexadecimal <String> argument."

	| answer size |
	size := aString size / 2.
	size isInteger ifFalse: [self error: 'Invalid hex string (odd length)'].
	answer := self new: size.
	1 to: size do: [:i | | j |
		j := (i * 2)-1.
		answer at: i put: ((aString at: j) digitValue * 16) + ((aString at: j+1) digitValue)].
	^answer
			
!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler. Note that we can
	ignore the format argument, since ByteArray is a pre-registered class that cannot be
	versioned. The format we read here is the same as that which would be read by the in-filer
	itself, but we can do the job more efficiently since we know that a block read from the
	stream is possible."

	| stream size answer |
	stream := anSTBInFiler stream.
	size := stream nextSDWORD.
	answer := stream next: size.
	anSTBInFiler register: answer.
	^answer! !

!ByteArray methodsFor!

_sameAsString: comparand
	"Private - Answer whether the receiver collates the same as <readableString> 
	argument, comparand.
	This will only work if the receiver contains integers in the range of character
	values, if not an exception will be raised.
	Implementation Note: Double dispatched from String>>sameAs:."

	^(comparand _collate: self asString) == 0!

= comperand
	"Answer whether the receiver is equivalent to the <Object>, comperand.
	Uses standard byte comparison primitive which checks for identical bytes and size.

	Primitive failure reasons:
		0 -	comperand is not the same class as the receiver."

	<primitive: 55>
	^false!

addressAtOffset: anInteger 
	"Answer the 32-bit address stored at the specified offset in the receiver."

	^(self dwordAtOffset: anInteger) asExternalAddress!

asByteArray
	"Answer a <ByteArray> containing the same elements as the receiver.
	In this case no conversion is required."

	^self!

asString
	"Answer a byte String containing the same elements as the receiver."

	| size |
	size := self basicSize.
	^(String new: size) replaceFrom: 1 to: size with: self startingAt: 1!

basicDwordAtOffset: anInteger
	"Answer the unsigned 4 byte integer at offset (i.e. zero relative) 
	anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4)."

	| answer offset |
	<primitive: 120>
	offset := anInteger + 1.
	answer := 0.
	3 to: 0 by: -1 do: [:i |
		answer := (answer bitShift: 8) + (self basicAt: offset + i)].
	^answer
!

basicDwordAtOffset: anInteger put: anObject 
	"Private - Replace the internal contents of the receiver from offset anInteger with
	the first 4 bytes of anObject."

	<primitive: 121>
	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 32-bit range.
			Atempt to coerce to Integer and retry. anObject may not understand asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= 16rFFFFFFFF]) 
				ifTrue: [^self basicDwordAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

basicUIntPtrAtOffset: anInteger 
	"Answer the unsigned machine word sized integer at offset (i.e. zero relative) 
	anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - sizeof(UINT_PTR))."

	| answer offset |
	<primitive: 120>
	offset := anInteger + 1.
	answer := 0.
	VMConstants.IntPtrSize to: 0
		by: -1
		do: [:i | answer := (answer bitShift: 8) + (self basicAt: offset + i)].
	^answer!

basicUIntPtrAtOffset: anInteger put: anObject 
	"Private - Replace the internal contents of the receiver from offset anInteger with
	the first machine word of anObject."

	<primitive: 121>
	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned machine word range.
			Atempt to coerce to Integer and retry. anObject may not understand asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= VMConstants.UIntPtrMax]) 
				ifTrue: [^self basicUIntPtrAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

byteAtOffset: anInteger
	"Answer the byte at offset anInteger in the receiver"

	^self basicAt: anInteger+1!

byteAtOffset: anInteger put: aByte
	"Replace the byte of the receiver at offset anInteger with aByte. Answer aByte."

	^self basicAt: anInteger+1 put: aByte
!

bytesAtOffset: anInteger put: anExternalStructureOrByteObject
	"Replace the bytes of the receiver from offset anInteger (0 based)
	with those of the argument aVariableByteObject"

	self replaceFrom: anInteger+1 
		to: anInteger + anExternalStructureOrByteObject size
		with: anExternalStructureOrByteObject
		startingAt: 1!

byteSize
	"Private - Answer the size in bytes of this structure."

	^self basicSize!

copy: aByteClass from: start to: stop 
	"Private - Answer a copy of the bytes of the receiver starting at index start, 
	until index stop, inclusive, as an instance of the argument, aByteClass."

	| len |
	len := stop - start + 1.
	^self 
		replaceBytesOf: (aByteClass new: len)
		from: 1
		to: len
		startingAt: start!

copyStringFrom: start to: stop
	"Answer a copy of the bytes of the receiver starting at index start, 
	until index stop, inclusive, as a String."

	^self copy: String from: start to: stop!

doubleAtOffset: anInteger
	"Answer the double precision floating point value at offset (i.e. zero relative) 
	anInteger in the receiver, as a Smalltalk Float object (double precision).

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 8)."

	<primitive: 128>
	self validateOffset: anInteger forUpdate: false.
	^self primitiveFailed!

doubleAtOffset: anInteger put: aFloat 
	"Store the Smalltalk floating point Number, aFloat, as a double precision
	floating point value (e.g. a C double) at byte offset (i.e. zero based) anInteger 
	within the receiver. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 8).
		2 -	aFloat is not a Float.

	If the argument is not a float, then the primitive is retried having converted it
	to a Float. This allows other number types to be passed as arguments."

	<primitive: 129>
	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			[self doubleAtOffset: anInteger put: aFloat asFloat.
			^aFloat].	"coerce to float and retry"
	^self primitiveFailed!

dwordAtOffset: anInteger
	"Answer the unsigned 4 byte integer at offset (i.e. zero relative) 
	anInteger IN the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4)."

	| answer |
	<primitive: 120>
	answer := 0.
	3 to: 0 by: -1 do: [:i |
		answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

dwordAtOffset: anInteger put: anObject
	"Store an unsigned 4 byte value at byte offset anInteger 
	within the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4).
		2 -	anObject is not a SmallInteger or a 4-byte object
	"
	
	<primitive: 121>
	^self retryDwordAtOffset: anInteger put: anObject!

floatAtOffset: anInteger
	"Answer the single precision floating point value at offset (i.e. zero relative) 
	anInteger in the receiver, as a Smalltalk Float object (double precision).
	N.B. To access a double precision value (e.g. a C double) use #doubleAt:

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
	`	1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4)."

	<primitive: 130>
	self validateOffset: anInteger forUpdate: false.
	^self primitiveFailed!

floatAtOffset: anInteger put: aFloat
	"Store the Smalltalk floating point Number, aFloat, as a single precision
	floating point value (e.g. a C float) at byte offset (i.e. zero based) anInteger 
	within the receiver. N.B. Some loss of precision is likely, to store a Smalltalk
	Float as a double precision value in an ExternalBytes buffer, use #doubleAt:put:.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4).
		2 -	aFloat is not a Float."

	<primitive: 131>
	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: [^self floatAtOffset: anInteger put: aFloat asFloat].	"coerce to float and retry"
	^self primitiveFailed!

hash
	"Hash the bytes of the object using the standard byte hashing
	primitive (which should not fail)."

	<primitive: 106>
	^VMLibrary default hashBytes: self count: self basicSize!

hexStoreOn: puttableStream
	"Print the literal string representation of the receiver to the <puttableStream>
	argument."

	puttableStream nextPut: $(; 
		print: self class; space; nextPutAll: #fromHexString:; space;
		nextPut: $'.
	self printHexOn: puttableStream.
	puttableStream nextPutAll: ''')'!

includes: target
	"Answer whether the argument, target, is one of the elements of the receiver.
	Implementation Note: Override superclass to provide a more efficient implementation."

	^self identityIncludes: target!

indexOfSubCollection: targetSequence startingAt: start
	"Answer the <integer> index of the next occurrence within the 
	receiver of the <sequencedReadableCollection> targetSequence,
	starting at the <integer> index start. If there are no such occurrences, answer 0.

	Primitive Failure Reasons:
		0	- start is not a SmallInteger
		1	- start is out of bounds (not in the range 1..receiver's indexable size) 
		2	- targetSequence is not of the same class as the receiver.

	Implementation Note: The string search primitive is implemented using the 
	Boyer-Moore algorithm unless the receiver is less than 512 bytes long, in which
	case it isn't worth initializing the skip array in most cases, so a simple brute
	force search (much like that of the superclass) is used."

	<primitive: 149>
	^super indexOfSubCollection: targetSequence startingAt: start!

intPtrAtOffset: anInteger 
	"Answer the machine word sized signed integer value (i.e. may be 32 or 64-bit, depending on
	host OS) at offset (i.e. zero relative) anInteger in the receiver. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - sizeof(INT_PTR))."

	| answer |
	<primitive: 182>
	answer := 0.
	VMConstants.IntPtrSize - 1 to: 0
		by: -1
		do: [:i | answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	answer byteSize > VMConstants.IntPtrSize ifTrue: [answer := answer bitInvert + 1].
	^answer!

intPtrAtOffset: anInteger put: anObject 
	"Store anObject as a signed machine-word sized integer at anInteger offset in the receiver. anInteger must 
	be representable in a machine word. Uses the longPtrAtOffset:put: primitive."

	| value |
	<primitive: 183>
	value := anObject asInteger.
	value byteSize > VMConstants.IntPtrSize ifFalse: [^self errorCantHold: anObject].
	1 to: VMConstants.IntPtrSize do: [:index | self at: anInteger + index put: (value digitAt: index)].
	^anObject!

isLiteral
	"Answer whether or not the receiver has a literal representation (probably its
	printString) which is directly recognised by the Compiler."

	^self class == ##(self)!

isNull
	"Answer whether the receiver is Null (i.e. equal to 0). 
	This message is useful way of testing for NULL pointers or handles."

	^false!

longDoubleAtOffset: anInteger
	"Answer the 80-bit floating point value at offset (i.e. zero relative) anInteger in the 
	receiver, as a Smalltalk Float object (i.e. 64-bit precision, so some precision may be
	lost).

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 8)."

	<primitive: 159>
	self validateOffset: anInteger forUpdate: false.
	^self primitiveFailed!

notNull
	"Answer whether the receiver is not Null (i.e. not equal to 0)"

	^self isNull == false!

printHexOn: aStream
	"Append a hex string representation of the receiver to the <puttableStream> argument."

	self do: [:byte |
		aStream 
			nextPut: (Character digitValue: (byte // 16));
			nextPut: (Character digitValue: (byte \\ 16))]!

printHexString
	"Answer a hex string representation of the receiver. N.B. For reasons of backwards
	compatibility the result includes quotes, if this is not what you want then use
	#printHexOn:."

	| stream |
	stream := String writeStream: self size * 2 + 2.
	stream nextPut: $'.
	self printHexOn: stream.
	stream nextPut: $'.
	^stream contents!

printPrefixOn: aStream
	"Private - Print a prefix string for the debug representation of the receiver on aStream."

	aStream nextPutAll: '#['!

printSuffixOn: aStream
	"Private - Print a suffix string for the debug representation of the receiver on aStream."

	aStream nextPut: $]!

qwordAtOffset: offset
	"Answer an <integer> representing the unsigned 8 byte integer at 
	<integer> offset (i.e. zero relative), offset, in the receiver."

	#todo "Add a primitive (easy)".
	^((self dwordAtOffset: offset+4) bitShift: 32) +
		(self dwordAtOffset: offset)!

qwordAtOffset: offset put: value
	"Replace the unsigned 8 byte integer at <integer> offset (i.e. zero relative), offset,
	in the receiver, with the <integer> argument, value."

	self 
		dwordAtOffset: offset put: (value bitAnd: 16rFFFFFFFF);
		dwordAtOffset: offset+4 put: (value bitShift: -32)!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:

	Primitive Failure Reasons:
		0 	- fromStart is not a SmallInteger.
		1	- stop is not a SmallInteger.
		2	- start is not a SmallInteger.
		3	- aByteObject is not a byte object
		4	- 'from' or 'to' interval is out-of-bounds
	"

	| fromOffset |
	<primitive: 142>
	fromOffset := fromStart - start.
	stop to: start by: -1 do: [:i | aByteObject at: i put: (self basicAt: i + fromOffset)].
	^aByteObject!

replaceFrom: start to: stop with: aByteObject startingAt: fromStart
	"Standard method for transfering bytes from one variable
	byte object to another. See String>>replaceFrom:to:with:startingAt:."

	aByteObject replaceBytesOf: self from: start to: stop startingAt: fromStart!

retryDwordAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing unsigned 32-bit integer into the receiver when a
	primitive fails. Either raises an appropriate error, or converts the argument to an Integer
	and retries."

	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 32-bit
			 range. Attempt to coerce to Integer and retry. anObject may not understand
			 asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= 16rFFFFFFFF]) ifTrue: [^self dwordAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

retrySWordAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing signed word into the reciever when a primitive fails.
	Either raises an appropriate error, or converts the argument to an Integer and retries."

	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in signed 16-bit
			 range. Attempt to coerce anObject and retry. anObject may not understand
			 asInteger."
			| int |
			int := anObject asInteger.
			(int >= -16r8000 and: [int < 16r8000]) ifTrue: [^self swordAtOffset: anInteger put: int]].
	^self errorCantHold: anObject!

retryUIntPtrAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing unsigned machine-word sized integer into the receiver
	when a primitive fails. Either raises an appropriate error, or converts the argument to an
	Integer and retries."

	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned
			 machine-word sized range. Attempt to coerce to Integer and retry. anObject
			 may not understand asInteger."
			| intVal |
			intVal := anObject asInteger.
			(intVal >= 0 and: [intVal <= VMConstants.UIntPtrMax]) ifTrue: [^self uintPtrAtOffset: anInteger put: intVal]].
	^self errorCantHold: anObject!

retryWordAtOffset: anInteger put: anObject 
	"Private - Fallback code for storing unsigned word into the reciever when a primitive fails.
	Either raises an appropriate error, or converts the argument to an Integer and retries."

	(self validateOffset: anInteger forUpdate: true) == 2 
		ifTrue: 
			["Not a suitable value - could be non-Numeric, or not in unsigned 16-bit
			 range. Attempt to coerce to Integer and retry. anObject may not understand
			 asInteger."
			| int |
			int := anObject asInteger.
			(int >= 0 and: [int <= 16rFFFF]) ifTrue: [^self wordAtOffset: anInteger put: int]].
	^self errorCantHold: anObject!

sbyteAtOffset: anInteger 
	"Answer the signed 8-bit <Integer> at offset anInteger in the receiver"

	| answer |
	answer := self byteAtOffset: anInteger.
	^answer > 127 ifTrue: [answer - 256] ifFalse: [answer]!

sbyteAtOffset: anInteger put: aByte
	"Replace the byte of the receiver at offset anInteger with aByte. Answer aByte."

	^self byteAtOffset: anInteger put: (255 bitAnd: aByte)!

sdwordAtOffset: anInteger 
	"Answers the signed 4 byte integer at byte offset anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds."

	| answer |
	<primitive: 122>
	answer := self dwordAtOffset: anInteger.
	^answer > 16r7FFFFFFF ifTrue: [(answer bitXor: 16rFFFFFFFF) bitInvert] ifFalse: [answer]!

sdwordAtOffset: anInteger put: anObject 
	"Store anObject as a signed integer at anInteger offset in the receiver. anInteger must 
	be representable in 32-bits. Uses the dwordAtOffset:put: primitive."

	| value |
	<primitive: 123>
	value := anObject asInteger.
	value isSDWORD ifFalse: [^self errorCantHold: anObject].
	1 to: 4 do: [:index | self basicAt: anInteger + index put: (value digitAt: index)].
	^anObject!

sqwordAtOffset: anInteger
	"Answer the signed 8 byte integer at offset (i.e. zero relative) 
	anInteger in the receiver."

	^((self sdwordAtOffset: anInteger+4) bitShift: 32) +
		(self dwordAtOffset: anInteger)!

sqwordAtOffset: offset put: value
	"Replace the signed 64-bit integer at the specified <integer> offset (i.e. zero relative)
	in the receiver, with the <integer> argument, value."

	self 
		dwordAtOffset: offset put: (value bitAnd: 16rFFFFFFFF);
		sdwordAtOffset: offset+4 put: (value bitShift: -32)!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler.
	We override because we know we can use a block write here. The format
	of the serialized byte array in the resulting STB stream is the same though."

	| size |
	anSTBOutFiler writePreambleFor: self.
	size := self basicSize.
	anSTBOutFiler writeInteger: size.
	anSTBOutFiler stream 
		next: size
		putAll: self
		startingAt: 1!

storeOn: puttableStream
	"Print the literal string representation of the receiver to the <puttableStream>
	argument."

	self printPrefixOn: puttableStream.
	1 to: self size do: [:i | 
		(self at: i) printDigitsOn: puttableStream base: 10.
		puttableStream nextPut: $ ].
	self printSuffixOn: puttableStream.!

swordAtOffset: anInteger
	"Answer the signed 2 byte integer at offset (i.e. zero relative) anInteger
	in the receiver."

	| answer |
	<primitive: 126>
	answer := self wordAtOffset: anInteger.
	^answer >= 16r8000
		ifTrue: [(16r10000 - answer) negated]
		ifFalse: [answer]!

swordAtOffset: anInteger put: anObject
	"Store a signed 2 byte value at byte offset anInteger within the receiver (which is the 
	same as storing an unsigned value). If anObject is not representable as a 16-bit
	signed (Small)Integer, then raise a 'cannot hold' error.

	Primitive failure results:
		0 -	anInteger is not a SmallInteger
		1 - 	anInteger is out of bounds
		2 -	anObject is not a SmallInteger
		3 -	anObject is not in the range -32768..32767 (i.e. out of signed 16-bit range)."

	<primitive: 127>
	^self retrySWordAtOffset: anInteger put: anObject!

uintPtrAtOffset: anInteger 
	"Answer the machine word sized integer value (i.e. may be 32 or 64-bit, depending on host
	OS) at offset (i.e. zero relative) anInteger in the receiver. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - sizeof(UINT_PTR))."

	| answer |
	<primitive: 180>
	answer := 0.
	VMConstants.IntPtrSize - 1 to: 0
		by: -1
		do: [:i | answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

uintPtrAtOffset: anInteger put: anObject 
	"Store an unsigned 4 byte value at byte offset anInteger 
	within the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - sizeof(UINT_PTR)).
		2 -	anObject is not a SmallInteger or in the representable range."

	<primitive: 181>
	^self retryUIntPtrAtOffset: anInteger put: anObject!

validateOffset: anInteger forUpdate: aBoolean 
	"Private - Primitive failure checking code for validating an offset argument to be
	called immediately after a buffer accessing primitive has failed. Raises an error
	if anInteger is not a valid offset, or the primitive error code."

	| code |
	code := Processor activeProcess primitiveFailureCode.
	code < 2 
		ifTrue: 
			["Erroneous offset parameter"
		^code == 0 
			ifTrue: [Error nonIntegerIndex: anInteger]
				ifFalse: 
					[(aBoolean and: [self isImmutable]) 
						ifTrue: [Processor constWriteSignal signalWith: self]
						ifFalse: [self errorSubscriptBounds: anInteger]]].
	^code!

wordAtOffset: anInteger
	"Answer the unsigned 2 byte integer at offset (i.e. zero relative) anInteger in the receiver. 
	On iX86 the high and low order bytes are reversed; i.e. the bytes are ordered least 
	significant first.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		1 -	anInteger is out of bounds."

	| answer |
	<primitive: 124>
	answer := 0.
	1 to: 0 by: -1 do: [:i |
		answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

wordAtOffset: anInteger put: anObject
	"Store an unsigned 16-bit value at byte offset anInteger within the receiver.
	If anObject is not representable as a 16-bit unsigned (Small)Integer, then 
	raise a 'cannot hold' error.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		1 -	anInteger is out of bounds.
		2 -	anObject is not a SmallInteger
		3 -	anObject is not in the range -32768..32767 (i.e. out of signed 16-bit range)."

	<primitive: 125>
	^self retryWordAtOffset: anInteger put: anObject! !

RunArray comment:
''!
!RunArray class methodsFor!

new
	"Answer a new, empty, instance of the receiver."

	^self runs: Array new values: Array new!

new: anInteger
	"Answer a new instance of the receiver with anInteger nil elements."

	^self new: anInteger withAll: nil!

new: anInteger withAll: anObject
	"Answer a new instance of the receiver with anInteger elements which are all 
	the argument, anObject."

	^anInteger == 0 
		ifTrue: [self new]
		ifFalse: [self runs: (Array with: anInteger) values: (Array with: anObject)]!

runs: runsArray values: valuesArray
	"Answer a new instance of the receiver with the specified runs and values.
	N.B. The two arrays must be the same size."

	^self basicNew
		runs: runsArray values: valuesArray! !

!RunArray methodsFor!

asRunArray
	^self!

at: anInteger
	"Answer the element at index, anInteger, in the receiver."

	| index |
	index := 0.
	1 to: runs size do: [:i |
		index := index + (runs at: i).
		anInteger <= index
			ifTrue: [^values at: i]].
	^self errorSubscriptBounds: anInteger!

at: index put: newElement
	"Replace the element of the receiver at the specified <integer> index with 
	the <Object> argument, newElement. If the index is out of bounds, raise 
	a BoundsError.

	Implementation Note: RunArrays are not mutable."

	^self shouldNotImplement
!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver. In
	the case of a RunArray we need to copy the runs and values arrays."

	super postCopy.
	values := values copy.
	runs := runs copy.
	^self!

resize: anInteger
	"Run arrays are not extensible"

	^self shouldNotImplement
!

runs: runsArray values: valuesArray
	"Private - Set the receiver's instance variables."

	runs := runsArray.
	values := valuesArray!

runsAndValuesDo: operation
	runs with: values do: operation!

runStartAndValueAt: anInteger
	"Private - Answer an association between the <dyadicValuable> 
	operation for the element of the receiver at the specified index 
	and the index of the start of the run in which that element occurs.
	The run-start is the key, the element the value."

	| runStart |
	runStart := 1.
	1 to: runs size do: [:i | | nextRun |
		nextRun := runStart + (runs at: i).
		nextRun > anInteger
			ifTrue: [^runStart -> (values at: i)].
		runStart := nextRun].
	^self errorSubscriptBounds: anInteger!

runStartAt: anInteger
	"Answer the index of the start of the run which includes the index anInteger (i.e. the index of
	the first element in the receiver in the run of elements equal to the element at anInteger)."

	| index |
	index := 1.
	runs do: [:run |
		(index + run) > anInteger
			ifTrue: [ ^index ].
		index := index + run].
	^self errorSubscriptBounds: anInteger
!

size
	"Answer the number of elements in the receiver."

	| tally |
	tally := 0.
	1 to: runs size do: [:i | tally := tally + (runs at: i)].
	^tally!

species
	^Array! !

String comment:
'String is the class of <ArrayedCollection>s whose elements are <Character>s.

N.B. Dolphin Strings are, unlike Smalltalk-80 strings, null terminated. Space for the null terminator is implicity included when a String is allocated, but is not reported when the size of the String is requested.

String complies with the following ANSI protocols:
	Object
	magnitude
	collection
	sequencedReadableCollection
	sequencedCollection
	readableString
	String'!
!String class methodsFor!

elementSize
	"Answer the size of the elements of the receiver in bytes."

	^1!

empty
	"Answer an empty String instance. It is shared and should not be modified.
	N.B. The compiler generates reference to a shared empty string in any case
	so there should never be more than one empty literal string."

	^''!

formatMessage: anIntegerId in: hModule withArguments: arguments
	"Answer a String which is a message formatted from the format String with the
	specified id in the specified module, with arguments substituted from
	argumentCollection."

	^(self fromId: anIntegerId in: hModule) formatWithArguments: arguments!

formatMessage: anIntegerId withArguments: argumentCollection
	"Answer a String which is a message formatted from the format String with the
	specified id in the specified module, with arguments substituted from
	argumentCollection."

	^self 
		formatMessage: anIntegerId
		in: SessionManager current defaultResourceLibrary
		withArguments: argumentCollection!

formatSystemMessage: anIntegerId withArguments: arguments
	"Answer a String which is a message formatted from the format String with the
	specified id in the specified module, with arguments substituted from
	argumentCollection."

	^KernelLibrary default 
		formatMessage: anIntegerId 
		source: 0
		flags: FORMAT_MESSAGE_FROM_SYSTEM
		withArguments: arguments!

fromAddress: anAddress
	"Answer a new String instantiated from the null terminated string at anAddress.
	Implementation note: We can use the external library call primitive to do the 
	job for us by performing a simple nop which returns the original pointer (_strninc()
	has the useful property that it returns NULL for NULL argument too)."

	^VMLibrary default stringFromAddress: anAddress!

fromAddress: anAddress length: anInteger
	"Answer a new String, of length anInteger, copied from the first anInteger
	characters of aString."

	^anAddress isNull 
		ifFalse: [
			anAddress asExternalAddress
				replaceBytesOf: (self new: anInteger)
				from: 1 to: anInteger startingAt: 1 ]
!

fromAtomId: anInteger
	"Answer a new string which is a copy of the atom with id anInteger."

	| atomName |
	^(atomName := String new: 255)
		leftString: (KernelLibrary default getAtomName: anInteger lpBuffer: atomName nSize: atomName basicSize)!

fromId: anInteger
	"Answer a new String loaded from resources."

	^self fromId: anInteger in: SessionManager current defaultResourceLibrary!

fromId: resourceId in: anExternalLibraryOrHandle
	"Answer a new String loaded from the resources of the module with handle, anExternalLibraryOrHandle."

	| answer len |
	answer := self new: 256.
	(len := UserLibrary default 
		loadString: anExternalLibraryOrHandle asParameter 
		uID: resourceId 
		lpBuffer: answer 
		nBufferMax: answer size) isZero
			ifTrue: [UserLibrary default systemError].
	^answer leftString: len!

fromString: aString
	"Answer a new instance of the receiver copied from aString."

	| size |
	size := aString size.
	^aString
		replaceBytesOf: (self new: size)
		from: 1 to: size startingAt: 1!

fromUnicodeString: anAddressOrUnicodeString
	"Answer a single byte String representation of the Unicode string at the specified
	address."

	| answer size lib |
	lib := KernelLibrary default.
	(size := lib
		wideCharToMultiByte: 0
		dwFlags: 0
		lpWideCharStr: anAddressOrUnicodeString
		cchWideChar: -1
		lpMultiByteStr: nil
		cchMultiByte: 0
		lpDefaultChar: nil
		lpUsedDefaultChar: nil) == 0
			ifTrue: [lib systemError].
	answer := self new: size-1.
	lib
		wideCharToMultiByte: 0
		dwFlags: 0
		lpWideCharStr: anAddressOrUnicodeString
		cchWideChar: -1
		lpMultiByteStr: answer
		cchMultiByte: answer basicSize
		lpDefaultChar: nil
		lpUsedDefaultChar: nil.
	^answer!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	LineDelimiter isImmutable: true.
	NullPrintCharacter := $?!

lineDelimiter
	"Answer an immutable instance of the receiver containing the host system 
	end-of-line character sequence (a Cr/Lf pair).
	This is a method of String rather than Character because the answer will 
	always be a String."

	^LineDelimiter!

readFrom: aStream 
	"Answer a <String> read from the <gettableStream>, aStream
	Note that the string is expected to be in Smalltalk literal form, i.e.
	single quoted and with embedded quotes doubled."

	| answer |
	answer := String writeStream: 16.
	aStream skipTo: $'.	"Skip any leading chars up to just after the first quote"
	[aStream atEnd] whileFalse: 
			[| ch |
			ch := aStream next.
			ch == $' 
				ifTrue: 
					[aStream atEnd ifTrue: [^answer contents].
					ch := aStream next.
					ch == $' 
						ifFalse: 
							["Single quote terminates string (else gobble the doubled quote)"

							aStream pop.
							^answer contents]].
			answer nextPut: ch].
	^answer contents!

tab
	"Answer an instance of the receiver containing a tab character."

	^##(self with: Character tab)!

unicodeClass
	"Answer the class of String to use for Unicode."

	^UnicodeString! !

!String methodsFor!

_beginsString: aString
	^(CRTLibrary default 
		strncmp: aString
		string2: self
		count: self size) == 0!

_collate: comparand
	"Private - Answer the receiver's <integer> collation order with respect to 
	the <readableString> argument, comparand. The answer is < 0 if
	the receiver is lexically before the argument, 0 if lexically equivalent, or
	> 0 if lexically after the argument. The comparision is CASE INSENSITIVE.
	The comparison respects the currently configured default locale of the
	host operating system, and the performance may disappoint in some cases."

	<primitive: 56>
	"The primitive simply invokes the case-insensitive string collation method"
	^KernelLibrary default lstrcmpi: self lpString2: comparand

	"If you really don't care about Locale sensitive collation, then this is
	even faster (C collation), especially if the C locale is set."

"	^CRTLibrary default _stricmp: self string2: comparand."
!

_sameAsString: aString 
	"Private - Answer whether the receiver collates the same as argument, aString."

	"Implementation Note: Double dispatched from String>>sameAs:."

	^self == aString or: [(aString _collate: self) == 0]!

_separateSubStringsIn: aReadableString 
	"Private - Answer an Array containing the substrings in aReadableString separated
	by the receiver."

	| start size answer subSize |
	(subSize := self size) == 0 
		ifTrue: [^self error: 'separator must consist of at least one character'].
	subSize == 1 ifTrue: [^(self at: 1) _separateSubStringsIn: aReadableString].
	start := 1.
	size := aReadableString size.
	answer := OrderedCollection new: 10.
	
	[| stop |
	stop := aReadableString findString: self startingAt: start.
	stop == 0 
		ifTrue: 
			[answer addLast: (aReadableString copyFrom: start to: size).
			^answer asArray].
	answer addLast: (aReadableString copyFrom: start to: stop - 1).
	(start := stop + subSize) > size] 
			whileFalse.
	^answer asArray!

< comparand
	"Answer whether the receiver is lexically less than the <readableString>, comparand,
	ignoring case, according to the implementation defined collation sequence (see _collate:)."

	^(self _collate: comparand) < 0!

<= comparand
	"Answer whether the receiver is lexically less than or equal to the <readableString>, 
	comparand, ignoring case, according to the implementation defined collation sequence 
	(see _collate:). Note that this is the equivalent to 
		'self < comparand or: [self sameAs: comparand]'
	and NOT
		'self < comparand or: [self = comparand]
	since String>>= is case sensitive."

	^(self _collate: comparand) <= 0!

= comparand
	"Answer whether the receiver and the <Object> argument, comparand, 
	are both Strings containing identical characters (i.e. case sensitive).

	Primitive failure results:
		0 -	aString is not a byte object of the same class as the receiver."

	<primitive: 55>
	^false!

> comparand
	"Answer whether the receiver is lexically greater than the <readableString>, comparand,
	ignoring case, according to the implementation defined collation sequence 
	(see _collate:)."

	^(self _collate: comparand) > 0!

>= comparand
	"Answer whether the receiver is lexically greater than or equal to the 
	<readableString> comparand, ignoring case, according to the implementation 
	defined collation sequence (see _collate:)."

	^(self _collate: comparand) >= 0!

asByteArray
	"Answer a <ByteArray> containing the Unicode representation of the characters of the
	receiver."

	| size |
	size := self basicSize.
	^self
		replaceBytesOf: (ByteArray new: size) 
		from: 1 to: size startingAt: 1.
!

asLowercase
	"Answer a <readableString> which is a copy of the receiver but
	with the contents converted to lowercase.
	Implementation Note: The Win32 function converts in place, so we 
	must first create a copy."

	| copy |
	copy := self basicCopy.
	UserLibrary default stringLowerA: copy.
	^copy!

asNumber
	"Answer a Number constructed by interpreting the receiver's characters as the
	printString of a Number."

	^Number fromString: self!

asPhrase
	"Answer a <sequencedReadableCollection> of the 'words' in the receiver, as capitalized strings.
	The word boundaries are identified by colons (i.e. keywords) and capital letters."

	| stream last |
	stream := String writeStream: self size + 10.
	self do: 
			[:each | 
			last isNil 
				ifTrue: [each == $: ifFalse: [last := stream nextPut: each asUppercase]]
				ifFalse: 
					[each == $: 
						ifFalse: 
							[last == $: 
								ifTrue: 
									[stream
										space;
										nextPut: each asUppercase]
								ifFalse: 
									[(each isUppercase and: [last isLowercase]) ifTrue: [stream space].
									(each isDigit and: [last isDigit not]) ifTrue: [stream space].
									stream nextPut: each]].
					last := each]].
	^stream contents!

asString
	"Answer a <readableString> containing the same characters as the receiver,
	i.e. the receiver."

	^self!

asSymbol
	"Answer the <symbol> corresponding to the receiver."

	^Symbol intern: self!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	"N.B. Be careful that the receiver is not GC'd until the result is no longer required, or it
	will be a dangling pointer."

	^self yourAddress!

asUnicodeString
	^self class unicodeClass fromString: self!

asUppercase
	"Answer a <readableString> which is a copy of the receiver but with 
	the contents converted to uppercase.
	Implementation Note: The Win32 function converts in place, so we need 
	to create a copy first."

	| copy |
	copy := self basicCopy.
	UserLibrary default stringUpperA: copy.
	^copy!

at: index
	"Answer the <Character> at the <integer> index, in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size)."

	<primitive: 63>
	^self errorAt: index!

at: anInteger put: aCharacter
	"Replace the character at index, anInteger, in the receiver with aCharacter.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size).
		2 -	aCharacter is not a Character."

	<primitive: 64>
	^(aCharacter isKindOf: Character) 
		ifTrue: [self errorAt: anInteger put: aCharacter]
		ifFalse: [self error: 'can''t hold ', aCharacter class name,'''s']
!

basicCopy
	"Private - Answer a copy of the receiver. Not to be overridden
	by subclasses. Should always answer a String."

	^self species fromAddress: self yourAddress
!

beginsWith: comperand
	"Answer whether the receiver starts with the exact characters
	of the argument, comperand."

	^comperand _beginsString: self!

beginsWith: aString ignoreCase: aBoolean 
	"Answer whether the receiver starts with the characters of the argument, aString. The
	comparison may be case sensitive or insensitive, depending on the <Boolean> argument. Note
	that unlike #beginsWith:, the comperand must be a <String>."

	^(aBoolean 
		ifTrue: 
			[CRTLibrary default 
				_strnicmp: self
				string2: aString
				count: aString size]
		ifFalse: 
			[CRTLibrary default 
				strncmp: self
				string2: aString
				count: aString size]) 
			== 0!

between: min and: max
	"Answer whether the receiver is inclusively between the <magnitude> arguments, 
	min and max."

	^self >= min and: [self <= max]!

byteSize
	"Private - Answer the size in bytes of this object, including the null terminator."

	^self basicSize + 1!

capitalized
	"Answer a <readableString> which is a copy of the receiver but with 
	the first character converted to its uppercase equivalent."

	| answer |
	(answer := self basicCopy) notEmpty ifTrue: [answer at: 1 put: self first asUppercase].
	^answer!

displayOn: aStream
	"Append the receiver in end-user form to aStream. Since this message is intended
	for producing end-user text, the receiver is appended to the stream as-is."

	aStream nextPutAll: self!

displayString
	"Answer a String representation of the receiver in a form suitable for
	presentation to an end user.
	Implementation Note: This is implemented purely for performance reasons to
	avoid the Stream overhead when displaying strings because it is such a
	common operation."

	^self!

equals: comperand
	"Answer whether the characters of the receiver are identical to those of 
	the argument, comperand. Should not be overridden by subclasses (a kind of basic=).
	Using this method strings and symbols compare equal if they contain the same
	character sequence - this was not true in releases prior to 3.0."

	| size |
	<primitive: 55>
	(self == comperand or: [self = comperand]) ifTrue: [^true].
	self species == comperand species ifFalse: [^false].
	(comperand size = (size := self size)) ifFalse: [^false].
	1 to: size do: [:i | (self at: i) = (comperand at: i) ifFalse: [^false]].
	^true!

expandMacros
	"Expand the receiver with replacable arguments.
	See #formatWithArguments: for further details."

	^self expandMacrosWithArguments: #()!

expandMacrosWith: anObject 
	"Expand the receiver with replacable arguments.
	See #formatWithArguments: for further details."

	^self expandMacrosWithArguments: (Array with: anObject)!

expandMacrosWith: anObject with: anotherObject 
	"Expand the receiver with replacable arguments.
	See #formatWithArguments: for further details."

	^self expandMacrosWithArguments: (Array with: anObject with: anotherObject)!

expandMacrosWith: anObject with: anotherObject with: thirdObject 
	"Expand the receiver with replacable arguments.
	See #formatWithArguments: for further details."

	^self expandMacrosWithArguments: (Array
			with: anObject
			with: anotherObject
			with: thirdObject)!

expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject 
	"Expand the receiver with replacable arguments.
	See #formatWithArguments: for further details."

	^self expandMacrosWithArguments: (Array
			with: anObject
			with: anotherObject
			with: thirdObject
			with: fourthObject)!

expandMacrosWithArguments: anArray 
	"Expand the receiver with replacable arguments.
	e.g.
		'Hello <D><N><1P> <D>' expandMacrosWithArguments: #('World' 1).
		'Hello <2?Good:Bad> <1S>' expandMacrosWithArguments: #('World' false)

	<nD> expands the nth parameter using it's #displayString
	<nP> expands the nth parameter using it's #printString
	<nS> expands the nth parameter treating it as a <String>
	<N> expands as a newline combination
	<T> expands as a TAB
	<n?xxxx:yyyy> if the nth parameter is true expands to 'xxxx' else 'expands to yyyy'

	If n is omitted the default of 1 is used.	
	"

	| newStream readStream index |
	newStream := WriteStream on: (String new: self size).
	readStream := ReadStream on: self.
	index := 1.
	[readStream atEnd] whileFalse: 
			[| char |
			char := readStream next.
			char == $< 
				ifTrue: 
					[| nextChar |
					nextChar := readStream next asUppercase.
					nextChar == $N ifTrue: [newStream cr].
					nextChar == $T ifTrue: [newStream tab].
					nextChar isDigit 
						ifTrue: 
							[index := nextChar digitValue.
							[readStream atEnd or: [(nextChar := readStream next asUppercase) isDigit not]] 
								whileFalse: [index := index * 10 + nextChar digitValue]].
					nextChar == $? 
						ifTrue: 
							[| trueString falseString |
							trueString := readStream upTo: $:.
							falseString := readStream upTo: $>.
							readStream position: readStream position - 1.
							newStream nextPutAll: ((anArray at: index) ifTrue: [trueString] ifFalse: [falseString]).
							index := index + 1].
					nextChar == $P 
						ifTrue: 
							[(anArray at: index) printOn: newStream.
							index := index + 1].
					nextChar == $D 
						ifTrue: 
							[(anArray at: index) displayOn: newStream.
							index := index + 1].
					nextChar == $S 
						ifTrue: 
							[newStream nextPutAll: (anArray at: index).
							index := index + 1].
					readStream skipTo: $>]
				ifFalse: [newStream nextPut: (char == $% ifTrue: [readStream next] ifFalse: [char])]].
	^newStream contents!

findString: aString 
	"Answer the index of the <String> argument within the receiver. If the receiver does not
	contain aString, answer 0."

	^self findString: aString startingAt: 1!

findString: aString startingAt: anInteger 
	"Answer the index of the <String> argument within the receiver, starting at the <integer>
	argument. If the receiver does not contain aString, answer 0.

	Primitive Failure Reasons:/
		0	- anInteger is not a SmallInteger
		1	- anInteger is out of bounds (not in the range 1..receiver's indexable size) 
		2	- aString is not of the same class as the receiver.

	Implementation Note: The string search primitive is implemented using the 
	Boyer-Moore algorithm unless the receiver is less than 512 bytes long, in which
	case it isn't worth initializing the skip array in most cases, so a simple brute
	force search (much like that of the superclass) is used."

	<primitive: 149>
	^super indexOfSubCollection: aString startingAt: anInteger!

findString: aString startingAt: anInteger ignoreCase: aBoolean 
	"Answer the index of the <String> argument within the receiver, ignoring case differences, starting at the <integer>
	argument. If the receiver does not contain aString, answer 0."

	| meLower subLower |
	#todo.	"More efficient implementation needed."
	aBoolean ifFalse: [^self findString: aString startingAt: anInteger].
	meLower := self asLowercase.
	subLower := aString asLowercase.
	^meLower findString: subLower startingAt: anInteger!

first: anInteger
	"Answer a new string comprising up to the leftmost anInteger characters of the receiver. 
	Implementation Note: Rather than implement in terms of the generic #copyFrom:to: method, 
	we can take advantage of the fact that this selector is specific to Strings, and implement more 
	efficiently."

	^self 
		replaceBytesOf: (self species new: anInteger)
		from: 1 
		to: anInteger
		startingAt: 1!

formatWith: anObject 
	"Answer a <readableString> which is a message formatted from the receiver (assumed to be a
	Win32 format string (see Win32 help)) with substituations from the remaining argument(s).
	See #formatWithArguments: for further details."

	^self formatWithArguments: (Array with: anObject)!

formatWith: anObject1 with: anObject2 
	"Answer a <readableString> which is a message formatted from the receiver (assumed to be a
	Win32 format string (see Win32 help)) with substituations from the remaining argument(s).
	See #formatWithArguments: for further details."

	^self formatWithArguments: (Array with: anObject1 with: anObject2)!

formatWith: anObject1 with: anObject2 with: anObject3 
	"Answer a <readableString> which is a message formatted from the receiver (assumed to be a
	Win32 format string (see Win32 help)) with substituations from the remaining argument(s).
	See #formatWithArguments: for further details."

	^self formatWithArguments: (Array 
				with: anObject1
				with: anObject2
				with: anObject3)!

formatWith: anObject1 with: anObject2 with: anObject3 with: anObject4 
	"Answer a <readableString> which is a message formatted from the receiver (assumed to be a
	Win32 format string (see Win32 help)) with substituations from the remaining argument(s).
	See #formatWithArguments: for further details."

	^self formatWithArguments: (Array 
				with: anObject1
				with: anObject2
				with: anObject3
				with: anObject4)!

formatWithArguments: aCollection 
	"Answer a <readableString> which is a message formatted from the receiver, assumed to be a
	Win32 format string (see
	http://msdn.microsoft.com/library/en-us/debug/base/formatmessage.asp for further
	information), with substitutions from the collection argument.

	For Example:
		'Hello %1!!03u!!' formatWith: 7
		'Hello %1!!s!!' formatWith: 'World'

	N.B. Floating point specifiers are NOT supported."

	"Note that although the #formatWith:&c family of methods have not been deprecated in Dolphin
	6, we recommend that, where possible, you use #expandMacrosXXX by preference."

	^KernelLibrary default 
		formatMessage: 0
		source: self
		flags: FORMAT_MESSAGE_FROM_STRING
		withArguments: aCollection!

hash
	"Hash the characters of the string using a built-in algorithm.
	Do NOT change this as the VM relies on this implementation.
	The primitive should not fail."

	<primitive: 106>
	^VMLibrary default hashBytes: self count: self size!

hashCharacters
	"Private - Use the standard byte hashing algorithm to hash the characters of 
	the receiver. Used for doing lookup by value, e.g. in the Symbol table."

	<primitive: 106>
	^VMLibrary default hashBytes: self count: self size
!

includes: aCharacter 
	"Answer whether the <Character> argument is one of the elements of the receiver."

	"Implementation Note: Override superclass to provide a more efficient implementation."

	^self identityIncludes: aCharacter!

indexOfAnyOf: characters startingAt: start 
	"Answer the one-based integer index of the first encountered element of the receiver which 
	is equal to one of the characters in the <readableString>, characters, starting from the one-based
	<integer> index, start, in the receiver. If no occurrences are found, then answer 0."

	| span |
	span := self strcspn: characters start: start.
	^span + start > self size 
		ifTrue: [0]
		ifFalse: 
			["CRT function will stop if it hits a null embedded in the string, so we must fall back
			on slower superclass implementation in that case."
			^(self basicAt: span + start) == 0 
				ifTrue: [super indexOfAnyOf: characters startingAt: start]
				ifFalse: [span + start]]!

indexOfSubCollection: targetSequence startingAt: start 
	"Answer the <integer> index of the next occurrence within the 
	receiver of the <sequencedReadableCollection> targetSequence,
	starting at the <integer> index start. If there are no such occurrences
	(or the search sequence is empty), answer 0."

	^self findString: targetSequence startingAt: start!

isLiteral
	"Private - Answer whether the receiver can be represented as a literal (i.e. it has a printed
	representation which can be directly understood by the compiler)."

	^true!

isString
	"Answer whether the receiver is a <String>."

	^true!

leftString: anInteger
	"Answer a new string comprising up to the leftmost anInteger characters of the receiver. 
	If the receiver has less than anInteger characters, then copy only those characters in the 
	receiver."

	^self first:( anInteger min: self size).
!

lines
	"Answer a SequenceableCollection containing the lines of the receiver (sequences of Characters
	separated by line delimiters. Blank lines are included.
	N.B. It is assumed that a line delimiter consists of two characters."

	^self subStrings: String lineDelimiter!

match: aString 
	"Answer whether the receiver (which may contain wildcard characters) matches the 
	<readableString> argument, ignoring case differences.
	Note that the pattern matching characters are *, matching any sequence of characters 
	and # matching any single character. The latter differs from the usual ? for historical
	reasons."

	^self match: aString ignoreCase: true!

match: aString ignoreCase: aBoolean 
	"Answer whether the receiver (which may contain wildcard characters) matches the 
	<readableString> argument, aString, ignoring or respecting case differences depending
	on the <Boolean> argument, aBoolean.
	Note that the pattern matching characters are *, matching any sequence of characters 
	and # matching any single character. The latter differs from the usual ? for historical
	reasons."

	^self 
		matchPatternFrom: 1
		in: aString
		from: 1
		ignoreCase: aBoolean!

matchPatternFrom: patternStart in: aString from: sourceStart ignoreCase: aBoolean 
	"Private - Answer whether the receiver matches aString (starting
	at patternStart in the receiver and sourceStart in source).
	The receiver may contain wildcards. Any differences in case between individual
	characters are ignored if the <boolean> argument is true."

	| p sourceSize |
	sourceSize := aString size.
	patternStart > self size 
		ifTrue: 
			["We've processed the whole pattern.
		If there is no more source, then we have a successful match,
		otherwise the match has failed."
			^sourceStart > sourceSize].

	"Get the next character from the pattern."
	p := self at: patternStart.
	p == $* 
		ifTrue: 
			["Handle the $* in the pattern."
			sourceStart to: sourceSize + 1
				do: 
					[:s | 
					(self 
						matchPatternFrom: patternStart + 1
						in: aString
						from: s
						ignoreCase: aBoolean) ifTrue: [^true]].
			^false].
	sourceStart > sourceSize 
		ifTrue: 
			["We've run out of source to be matched by the pattern."
			^false].
	(p == $# or: 
			[p == (aString at: sourceStart) 
				or: [aBoolean and: [p asUppercase == (aString at: sourceStart) asUppercase]]]) 
		ifTrue: 
			[^self 
				matchPatternFrom: patternStart + 1
				in: aString
				from: sourceStart + 1
				ignoreCase: aBoolean].
	"A character has been matched exactly, or matched by a $#."
	^false!

max: operand
	"Answer the greater of the receiver and the <magnitude>, operand.
	 Implementation Note: #< is used since other relational operators are often implemented 
	in terms of it."

	^self < operand
		ifTrue:  [operand]
		ifFalse: [self]!

midString: anIntegerLength from: anIntegerStart
	"Answer a new string comprising the anIntegerLength characters starting
	at anIntegerStart in the receiver."

	^self copyFrom: anIntegerStart to: anIntegerStart + anIntegerLength - 1!

min: operand
	"Answer the lesser of the receiver and the <magnitude>, operand."

	^self < operand
		ifTrue:  [self]
		ifFalse: [operand]!

nextIdentityIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Implementation Note: Override the inherited implementation to make use of the primitive."

	<primitive: 52>
	^anElement class == Character 
		ifTrue: [self basicIdentityIndexOf: anElement asInteger from: start to: stop]
		ifFalse: [0 "Can only contain characters"]!

nextIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver between 
	startIndex and stopIndex inclusive. If there are no such occurrences, answer 0."

	<primitive: 52>
	^self nextIdentityIndexOf: anElement from: start to: stop!

occurrencesOf: anObject 
	"Answer how many of the receiver's elements are equal to anObject.
	Implementation Note: Override for improved performance (superclass
	uses a serial search, which is appropriate where #nextIndexOf:from:to:
	is implemented in the same way, but we have a fast primitive for that."

	^self 
		occurrencesOf: anObject
		from: 1
		to: self size!

occurrencesOf: anObject from: startInteger to: endInteger 
	| current occurrences |
	current := startInteger.
	occurrences := 0.
	[current > endInteger] whileFalse: 
			[| next |
			(next := self 
						nextIndexOf: anObject
						from: current
						to: endInteger) == 0 
				ifTrue: [^occurrences].
			occurrences := occurrences + 1.
			current := next + 1].
	^occurrences!

printOn: aStream 
	"Append the receiver as a quoted string to aStream. Internal quotes are doubled to produce a
	literal String. Null characters are printed as another character to avoid them being treated
	as null terminators by C api's"

	aStream nextPut: $'.
	1 to: self size
		do: 
			[:i | 
			| ch |
			(ch := self at: i) == ##(Character null) 
				ifTrue: [aStream nextPut: NullPrintCharacter]
				ifFalse: [(aStream nextPut: ch) == $' ifTrue: [aStream nextPut: $']]].
	aStream nextPut: $'!

refersToLiteral: anObject 
	"Private - Answer whether the receiver is a reference to the literal argument.
	This assumes that the receiver is in the role of a literal."

	^self = anObject!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:

	Primitive Failure Reasons:
		0 	- fromStart is not a SmallInteger.
		1	- stop is not a SmallInteger.
		2	- start is not a SmallInteger.
		3	- aByteObject is not a byte object
		4	- 'from' or 'to' interval is out-of-bounds
	"

	| fromOffset |
	<primitive: 142>
	fromOffset := fromStart - start.
	stop to: start by: -1 do: [:i | aByteObject at: i put: (self at: i + fromOffset)].
	^aByteObject!

replaceFrom: start to: stop with: replacementElements startingAt: startAt
	"Replace the characters of the receiver at the <integer> index positions 
	start through stop with consecutive characters of the <readableString>
	replacementElements beginning at <integer> index position startAt. 
	Answer the receiver."

	replacementElements replaceBytesOf: self from: start to: stop startingAt: startAt!

reverse
	"Answer a copy of the receiver but with its elements in reverse order.
	Our Strings are null-terminated, so we can use the CRTLibrary (_strrev()
	works in place, so we must get a copy)."

	| copy |
	copy := self basicCopy.
	CRTLibrary default _strrev: copy.
	^copy!

rightString: anInteger
	"Answer a new string comprising the rightmost anInteger characters of the receiver."

	^self last: anInteger!

sameAs: comparand 
	"Answer whether the receiver collates the same as the <sequencedReadableCollection>
	 argument, operand, in the currently configured locale (case insensitively).
	Note that the ANSI standard definition of this function requires that the comparand
	complies with <readableString>, but we relax that to allow any <sequencedReadableCollection>
	although that collection must contain valid character code points, consequently the
	argument need not be the same class as the receiver."

	"Implementation note: Similar to superclass implementation of #=, but we allow different
	species, and we need to use collating of the currently configured locale. This is easiest
	if we first construct a String from the argument, since Win32 provides no simple
	function for comparing two characters, and that is easiest if we double dispatch."

	^comparand _sameAsString: self!

skipOver: aStream ignoreCase: ignoreCase
	"Private - Answer whether the receiver matches the contents of <sequencedStream> stream
	ignoring case differences if <boolean> ignoreCase is true. Answers true if a complete match is
	found, false otherwise. If a match is found then the stream is left pointing to the next character
	following the match. If not, the stream position is left unchanged."

	| originalPosition |
	ignoreCase ifFalse: [^self skipOver: aStream].
	originalPosition := aStream position.
	self do: 
			[:each | 
			(aStream atEnd or: [aStream next asUppercase ~= each asUppercase]) 
				ifTrue: 
					[aStream position: originalPosition.
					^false]].
	^true!

sprintfWith: arg1
	"Answer a String which is a message formatted from the receiver (assumed to be a C-printf
	format String) with substituations from the remaining argument(s).
	e.g.
	  'Hello %s' sprintfWith: 'World'.
	  'Hello %i %s' sprintfWith: 1 with: 'world'.

	Note: This is much faster than formatWith:."

	| n crt buf size |
	crt := CRTLibrary default.
	size := self size + 64.
	
	[buf := String new: size.
	n := crt 
				_snprintf: buf
				count: size
				format: self
				with: arg1.
	n < 0] 
			whileTrue: [size := size * 2].
	^buf copyFrom: 1 to: n!

sprintfWith: arg1 with: arg2
	"Answer a String which is a message formatted from the receiver (assumed to be a C-printf
	format String) with substituations from the arguments.
	e.g.
	  'Hello %s' sprintfWith: 'World'.
	  'Hello %i %s' sprintfWith: 1 with: 'world'.

	Note: This is much faster than formatWith:with:."

	| written lib buf size |
	lib := CRTLibrary default.
	size := self size + 128.
	
	[buf := String new: size.
	written := lib 
				_snprintf: buf
				count: size
				format: self
				with: arg1
				with: arg2.
	written < 0] 
			whileTrue: [size := size * 2].
	^buf copyFrom: 1 to: written!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	self printOn: aStream!

strcspn: aString start: anInteger 
	^CRTLibrary default strcspn: self yourAddress + anInteger - 1 strCharSet: aString!

subStrings
	"Answer an Array containing the substrings of the receiver which are separated by one or 
	more Characters which answer true to #isSeparator."

	| stream answer wordStream |
	answer := OrderedCollection new.
	stream := self readStream.
	wordStream := self species writeStream: 10.
	[stream atEnd] whileFalse: 
			[| word next |
			wordStream reset.
			[stream atEnd or: [(next := stream next) isSeparator]] 
				whileFalse: [wordStream nextPut: next].
			word := wordStream contents.
			word notEmpty ifTrue: [answer add: word]].
	^answer asArray!

subStrings: separator
	"Answer an array containing the substrings of the receiver separated by occurrences
	of the <Character> or <readableString> argument, separator.
	Repeated separators produce empty strings in the array (cf. #subStrings).
	The separators are removed."

	#todo "This does not comply with the current ANSI definition, which requires an Array of separators,
		each of which may individually be used as a separator".
	^separator _separateSubStringsIn: self!

trimBlanks
	"Answer a copy of the receiver with leading and trailing white space removed."

	| size first last |
	size := self size.
	first := 1.
	[first < size and: [(self at: first) isSeparator]]
		whileTrue: [first := first + 1].
	last := size.
	[last >= first and: [(self at: last) isSeparator]]
		whileTrue: [last := last - 1].
	^self copyFrom: first to: last!

trimNulls
	"Answer a copy of the receiver with trailing nulls removed.
	Take advantage of some private knowledge about the implementation of
	#fromAddress:"

	^self species fromAddress: self yourAddress!

trueCompare: comparand
	"Private - Answer the receiver's <integer> collation order with respect to 
	the <readableString> argument, comparand. The answer is < 0 if
	the receiver is lexically before the argument, 0 if lexically equivalent, or
	> 0 if lexically after the argument. The comparision is CASE SENSITIVE.
	Implementation Note: lstrcmp() is used, which is a word based comparison
	which keeps, for example, hyphenated words together with equivalent
	non-hyphenated words. This is useful, but slower than a basic string collation.
	Also the comparison respects the currently configured default locale of the
	host operating system, and the performance may disappoint in some cases."

	<primitive: 51>
	"The primitive simply invokes this OS case sensitive string collation function"
	^KernelLibrary default lstrcmp: self lpString2: comparand!

unescapePercents
	"Answer a copy of the receiver with each %XY substring replaced by 
	the character with hex ASCII value XY and $+'s replaced by spaces."

	| answer pos oldPos |
	answer := self species writeStream: self size.
	oldPos := 1.
	
	[pos := self indexOfAnyOf: '+%' startingAt: oldPos.
	pos > 0] whileTrue: 
				[| char |
				answer 
					next: pos - oldPos
					putAll: self
					startingAt: oldPos.
				char := self at: pos.
				char == $+ 
					ifTrue: [answer nextPut: $ ]
					ifFalse: 
						[(char == $% and: [pos + 2 <= self size]) 
							ifTrue: 
								[| digit1 digit2 |
								digit1 := (self at: pos + 1) asUppercase.
								digit2 := (self at: pos + 2) asUppercase.
								(digit1 isHexDigit and: [digit2 isHexDigit]) ifFalse: [^self].	"not really an escaped string"
								answer nextPut: (Character value: digit1 digitValue * 16 + digit2 digitValue).
								pos := pos + 2]
							ifFalse: [answer nextPut: char]].
				oldPos := pos + 1].
	answer 
		next: self size - oldPos + 1
		putAll: self
		startingAt: oldPos.
	^answer contents!

withNormalizedLineDelimiters
	"Answer a copy of the receiver with any line terminator convention converted to the windows (CR/LF) convention."

	| target cr lf eol stm |
	target := self species writeStream: self size.
	stm := self readStream.
	cr := Character cr.
	lf := Character lf.
	eol := self species lineDelimiter.
	stm do: 
			[:each | 
			each == lf 
				ifTrue: [target nextPutAll: eol]
				ifFalse: 
					[each == cr 
						ifTrue: 
							[stm peekFor: lf.
							target nextPutAll: eol]
						ifFalse: [target nextPut: each]]].
	^target contents! !

WeakArray comment:
''!
!WeakArray class methodsFor!

new: anInteger
	"Answer a new instance of the receiver with anInteger indexed instance variables
	The new instance is registered with the memory manager as a weakling"

	^(super new: anInteger) initialize! !

!WeakArray methodsFor!

add: newElement
	"Add newElement to the receiver by replacing any available Corpses, or failing that by
	appending it."

	self addAnsweringIndex: newElement.
	^newElement
!

addAnsweringIndex: newElement
	"Add newElement to the receiver by overwriting the first corpse. If there are no corpses
	then append it. This is a very useful method in many system support tasks (e.g. the Dependency 
	mechanism)."

	^self replaceIdentity: DeadObject current with: newElement
!

corpsesDo: aBlock 
	"Locate each indexable variable of the receiver which formally housed an Object
	which has sadly expired, and pass its index to aBlock for evaluation. This
	method is non-destructive and may be evaluated repeatedly. Should you require
	to clear the slots formerly occuppied by corpses so that they are not
	subsequently treated as deaths, use the #nilCorpsesAndDo: message"


	| deathAt size corpse |
	size := self basicSize.
	corpse := DeadObject current.
	deathAt := self basicIdentityIndexOf: corpse from: 1 to: size.
	[deathAt > 0] whileTrue: [
		aBlock value: deathAt.
		deathAt := self basicIdentityIndexOf: corpse from: deathAt+1 to: size]!

initialize
	"Initialize the receiver's state.
	By default the receiver only weakly references its elements."

	self beWeak!

nilCorpsesAndDo: aBlock 
	"Locate each indexable variable of the receiver which formally housed an Object
	which has sadly expired, nil the slot, and pass its index to aBlock for evaluation.
	This is destructive, and is suitable for use where each death is to be processed only
	once. Should you not wish to nil out the corpses, use #corpsesDo:.
	N.B. We allow for aBlock to modify the contents of the receiver by continuing the search
	from position of the Corpse we've just nilled, just in case aBlock moves a Corpse
	there. This can be useful behavior and has negligible effect on performance."

	| deathAt size corpse |
	size := self basicSize.
	corpse := DeadObject current.
	deathAt := self basicIdentityIndexOf: corpse from: 1 to: size.
	[deathAt > 0] whileTrue: [
		self at: deathAt put: nil.
		aBlock value: deathAt.
		deathAt := self basicIdentityIndexOf: corpse from: deathAt to: size]!

nonCorpsesDo: aBlock 
	"Evaluate aBlock for all non-Corpse elements of the receiver. Answer the receiver."

	| corpse |
	corpse := DeadObject current.
	1 to: self basicSize
		do: 
			[:index | 
			| element |
			element := self at: index.
			element == corpse ifFalse: [aBlock value: element]]!

remove: oldElement ifAbsent: exceptionHandler
	"Private - Remove the argument, oldElement, as an element of the receiver by overwriting it with 
	the Corpse object, and answer oldElement. If oldElement is not an element of the receiver, then 
	answer the result of evaluating the niladic valuable, exceptionHandler."

	| index |
	index := self basicIdentityIndexOf: oldElement from: 1 to: self basicSize.
	^index == 0 
		ifTrue: [exceptionHandler value]
		ifFalse: [self basicAt: index put: DeadObject current. oldElement]!

species
	"Answer the kind of Collection that should result from enumerations such as #collect:
	and #select: when applied against the receiver"

	^Array! !

ExternalIntegerBytes comment:
''!
!ExternalIntegerBytes class methodsFor!

atAddress: anAddress 
	"Answer a new instance of the receiver with contents copied from
	the external integer pointed at by anAddress."

	^self fromInteger: (self valueAtAddress: anAddress)!

fieldType
	^self subclassResponsibility!

fromAddress: anAddress 
	"Answer a new instance of the receiver with contents *copied* from
	the external integer pointed at by anAddress (this is not a reference object
	and so must copy in response to #fromAddress:)"

	^self atAddress: anAddress!

fromInteger: anInteger
	"Answer a new instance of the receiver with contents copied from anInteger"

	^self new value: anInteger!

initialize
	"Private - Initialize the receiver's class variables.
		DWORDBytes initialize
	"

	self withAllSubclassesDo: [:e | e extraInstanceSpec: self elementSize]!

new
	"Answer a new instance of the receiver of the required size."

	^self newFixed: self elementSize!

valueAtAddress: anAddress 
	^self subclassResponsibility! !

!ExternalIntegerBytes methodsFor!

= anObject
	"Answer whether the receiver is equivalent to anObject."

	^anObject = self asInteger!

asInteger
	^self subclassResponsibility!

asObject
	"Answer the <Object> value represented by the receiver."

	^self value!

asSignedInteger
	^self subclassResponsibility!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^self asInteger!

byteSize
	"Answer the size in bytes of this structure."

	^self size!

clear
	"Initialize the receiver's value to zero."

	self value: 0!

displayOn: aStream
	"Append a textual representation of the receiver to aStream."

	self asInteger printOn: aStream base: 16 showRadix: true!

hash
	"Answer the SmallInteger hash value for the receiver."

	^self asInteger hash!

isNull
	"Answer whether the receiver is Null (i.e. equal to 0). 
	This message is useful way of testing for NULL pointers or handles.
	Implementation Note: The speed of this test is important."

	<primitive: 171>
	^self asInteger == 0!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; display: self; nextPut: $)
!

value
	"Answer the 32-bit unsigned <integer> value stored in the receiver."

	^self asInteger!

value: anObject 
	^self subclassResponsibility! !

DWORDBytes comment:
''!
!DWORDBytes class methodsFor!

elementSize
	"Private - Answer the size of the receiver's constituent elements in bytes."

	^4
!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DWORDField!

valueAtAddress: anAddress 
	^anAddress asExternalAddress dwordAtOffset: 0! !

!DWORDBytes methodsFor!

asDword
	"Answer the receiver in a form suitable for passing/returning as 
	a 32-bit value."

	^self value!

asInteger
	"Answer the 32-bit unsigned <integer> value of the receiver."

	^self dwordAtOffset: 0!

asSignedInteger
	"Answer the 32-bit, 2's complement, signed <integer> value of the receiver."

	^self sdwordAtOffset: 0!

value: anObject
	"Set the 32-bit unsigned <integer> value stored in the receiver."

	self dwordAtOffset: 0 put: anObject! !

UIntPtrBytes comment:
''!
!UIntPtrBytes class methodsFor!

elementSize
	"Private - Answer the size of the receiver's constituent elements in bytes."

	^VMConstants.IntPtrSize!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^UINT_PTRField!

valueAtAddress: anAddress 
	^anAddress asExternalAddress uintPtrAtOffset: 0! !

!UIntPtrBytes methodsFor!

asInteger
	"Answer the unsigned <integer> value of the receiver."

	^self uintPtrAtOffset: 0!

asSignedInteger
	"Answer the 2's complement, signed <integer> value of the receiver."

	^self intPtrAtOffset: 0!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as 
	anLRESULT (could be 32 or 64-bits, depending on host OS)."

	^self value!

highPart
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [self dwordAtOffset: 4] ifFalse: [self wordAtOffset: 2]!

highPart: anObject 
	"Note: The compiler will optimise out the conditional because it is constant."

	VMConstants.IsWin64 
		ifTrue: [self dwordAtOffset: 4 put: anObject]
		ifFalse: [self wordAtOffset: 2 put: anObject]!

highPartSigned
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [self sdwordAtOffset: 4] ifFalse: [self swordAtOffset: 2]!

lowPart
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [self dwordAtOffset: 0] ifFalse: [self wordAtOffset: 0]!

lowPart: anObject 
	"Note: The compiler will optimise out the conditional because it is constant."

	VMConstants.IsWin64 
		ifTrue: [self dwordAtOffset: 0 put: anObject]
		ifFalse: [self wordAtOffset: 0 put: anObject]!

lowPartSigned
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [self sdwordAtOffset: 0] ifFalse: [self swordAtOffset: 0]!

value: anObject 
	"Set the unsigned <integer> value stored in the receiver."

	self uintPtrAtOffset: 0 put: anObject! !

ExternalAddress comment:
''!
!ExternalAddress class methodsFor!

alignment
	"Answer the natural alignment for instances of the receiver when 
	embedded in arrays or other structures."

	^VMConstants.IntPtrSize!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^LPVOIDField!

fromAddress: anAddress
	"Answer a new instance of the receiver with contents *copied* from
	the DWORD pointed at by anAddress (this is not a reference object
	and so must copy in response to #fromAddress:)"

	^self fromInteger: anAddress!

fromBytes: aByteArray
	"Not quite sure what to do here, so assume ByteArray contains an address"

	^self fromInteger: aByteArray!

fromInteger: anInteger
	"Answer a new instance of the receiver with contents copied from anInteger
	Implementation note: Override superclass to make use of the external call
	primitive coercion trick."

	^VMLibrary default addressFromInteger: anInteger! !

!ExternalAddress methodsFor!

approxSize
	"Private - Answer the approximate size of the receiver.
	Implementation Note: As we have no idea how large the item is we are pointing at,
	we revert to the Collection implementation."

	^2!

asExternalAddress
	"Answer the receiver as an ExternalAddress"

	^self!

asInteger
	"Answer the 32-bit unsigned integer value of the receiver. ExternalAddress 
	needs to be careful NOT to return the positive integer value of the first 4 bytes 
	of the object  at which the receiver points, but its own value, so we use the 
	basic version of the accessor."

	^self basicUIntPtrAtOffset: 0!

at: anInteger
	"Answer the byte at index, anInteger, based from the address stored as 
	the contents of the receiver."

	^self byteAtOffset: anInteger-1!

at: anInteger put: anIntegerByteValue
	"Answer the byte at index anIntegerIndex based from the address stored 
	as the contents of the receiver"

	^self byteAtOffset: anInteger-1 put: anIntegerByteValue!

byteAtOffset: anInteger
	"Answer the byte at offset anInteger based from the address stored as the 
	contents of the receiver.
	WARNING: The primitive assumes that the receiver is a byte object of size 4; 
	it does not check that the receiver is of the correct shape. The primitive
	works as specified for ExternalAddress, and any correctly defined subclasses, 
	but may produce unexpected results where used inappropriately (e.g. in the 
	methods of a pointer class).

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger."

	<primitive: 132>
	^self primitiveFailed!

byteAtOffset: anInteger put: anIntegerByteValue
	"Replace the byte at offset anInteger from the base address stored as the 
	contents of the receiver with anIntegerByteValue.
	WARNING: Careless use of this method may result in unexpected behavior similar 
	to the results of 	writing through unprotected pointers in other languages, 
	in particular it is possible to compromise	the VM by corrupting objects and 
	other areas of memory. If a GP Fault directly results, then operation should
	continue normally.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		2 -	anIntegerByteValue is not a SmallInteger.
		3 -	anIntegerByteValue is not in the range 0..255."

	<primitive: 133>
	^self primitiveFailed!

deepCopy
	"ExternalAddresses do not know how to deep copy themselves in general, as they
	do not know the size of the object they point at. In order to deep copy objects
	containing external addresses correctly, you must implement #deepenShallowCopies:trail:
	in the parent/owning/referencing object"

	^self shouldNotImplement!

detach
	"Detach the receiver from the object at which it is pointing, answering the address
	of that object. This is useful where one wishes to take-over ownership of an object
	which would otherwise be cleaned up when the receiver is finalized."

	| address |
	address := self asInteger.
	self value: 0. 
	self beUnfinalizable.	"reduce Memory Manager load"
	^address asExternalAddress!

displayOn: aStream
	"Append a textual representation of the receiver to aStream."

	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: [super displayOn: aStream]!

dwordAtOffset: anInteger
	"Answer the unsigned 4 byte integer at offset (i.e. zero relative) 
	anInteger in the memory pointed at by the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger"

	| answer |
	<primitive: 134>
	answer := 0.
	3 to: 0 by: -1 do: [:i |
		answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

dwordAtOffset: anInteger put: anObject
	"Store an unsigned 4 byte value at byte offset anInteger 
	within the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		2 -	anObject is not a SmallInteger or a 4-byte object
	"
	
	<primitive: 135>
	^self retryDwordAtOffset: anInteger put: anObject!

intPtrAtOffset: anInteger 
	"Answer the machine word sized signed integer value (i.e. may be 32 or 64-bit, depending on
	host OS) at offset (i.e. zero relative) anInteger in the receiver. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - sizeof(INT_PTR))."

	| answer |
	<primitive: 186>
	answer := 0.
	VMConstants.IntPtrSize - 1 to: 0
		by: -1
		do: [:i | answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	answer byteSize > VMConstants.IntPtrSize ifTrue: [answer := answer bitInvert + 1].
	^answer!

intPtrAtOffset: anInteger put: anObject 
	"Store anObject as a signed machine-word sized integer at anInteger offset in the receiver. anInteger must 
	be representable in a machine word. Uses the longPtrAtOffset:put: primitive."

	| value |
	<primitive: 187>
	value := anObject asInteger.
	value byteSize > VMConstants.IntPtrSize ifFalse: [^self errorCantHold: anObject].
	1 to: VMConstants.IntPtrSize do: [:index | self at: anInteger + index put: (value digitAt: index)].
	^anObject!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:.
	Implementation Note: ExternalAddress uses a slightly different primitive for this
	purpose, as it is not the contents of the receiver that get replaced, but the
	object at which the receiver points.
	
	Primitive Failure Reasons:
		0 	- fromStart is not a SmallInteger.
		1	- stop is not a SmallInteger.
		2	- start is not a SmallInteger.
		3	- aByteObject is not a byte object
		4	- 'from' or 'to' interval is out-of-bounds
	"

	| fromOffset |
	<primitive: 143>
	fromOffset := fromStart - start.
	stop to: start by: -1 do: [:i | aByteObject at: i put: (self at: i + fromOffset)].
	^aByteObject!

resize: anInteger
	"Resize the receiver to accomodate anInteger bytes.
	We ignore the request, since we don't know how to resize the object
	pointed at (or even if it is resizable)."!

sdwordAtOffset: anInteger 
	"Answers the signed 4 byte integer at byte offset anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger"

	| answer |
	<primitive: 136>
	answer := self dwordAtOffset: anInteger.
	^answer > 16r7FFFFFFF ifTrue: [(answer bitXor: 16rFFFFFFFF) bitInvert] ifFalse: [answer]!

sdwordAtOffset: anInteger put: anObject 
	"Store anObject as a signed integer at anInteger offset in the receiver. anInteger must 
	be representable in 32-bits. Uses the dwordAtOffset:put: primitive."

	| value |
	<primitive: 137>
	value := anObject asInteger.
	value isSDWORD ifFalse: [^self errorCantHold: anObject].
	1 to: 4 do: [:index | self at: anInteger + index put: (value digitAt: index)].
	^anObject!

species
	"Answer the class of object to be used when copying the contents of the receiver. 
	As we are an untyped pointer, and we want to create a copy of the value pointed at,
	the best we can do is to create a ByteArray."

	^ByteArray!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler.
	Output nil in place of the receiver as the future validity of an external address is uncertain."

	anSTBOutFiler saveObject: self as: nil!

swordAtOffset: anInteger
	"Answer the signed 2 byte integer at offset (i.e. zero relative) 
	anInteger in the memory pointed at by the receiver."

	| answer |
	<primitive: 140>
	answer := self wordAtOffset: anInteger.
	^answer >= 16r8000
		ifTrue: [ (16r10000 - answer) negated ]
		ifFalse: [ answer ]
!

swordAtOffset: anInteger put: anObject
	"Store a signed 2 byte value at byte offset anInteger within the receiver (which is the 
	same as storing an unsigned value, except that the range of acceptable values is different).
	If anObject is not representable as a 16-bit signed (Small)Integer, then raise a 'cannot hold' error.

	Primitive failure results:
		0 -	anInteger is not a SmallInteger
		2 -	anObject is not a SmallInteger
		3 -	anObject is not in the range -32768..32767 (i.e. out of signed 16-bit range)."

	<primitive: 141>
	^self retrySWordAtOffset: anInteger put: anObject!

uintPtrAtOffset: anInteger 
	"Answer the machine word sized integer value (i.e. may be 32 or 64-bit, depending on host
	OS) at offset (i.e. zero relative) anInteger in the memory pointed at by the receiver. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger"

	| answer |
	<primitive: 184>
	answer := 0.
	VMConstants.IntPtrSize - 1 to: 0
		by: -1
		do: [:i | answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

uintPtrAtOffset: anInteger put: anObject 
	"Store an unsigned 4 byte value at byte offset anInteger 
	within the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		2 -	anObject is not a SmallInteger or in the representable range."

	<primitive: 185>
	^self retryUIntPtrAtOffset: anInteger put: anObject!

value
	"Answer the value of the receiver (the address itself)"

	^self!

value: anInteger 
	"Set the receiver's address value to be anInteger. Answer the receiver.
	Use the basic version of the accessor to avoid the implicit indirection."

	self basicUIntPtrAtOffset: 0 put: anInteger!

wordAtOffset: anInteger
	"Answer the unsigned 2 byte integer at offset (i.e. zero relative) anInteger in the 
	memory pointed at by the receiver.
	On iX86 the high and low order bytes are reversed; i.e. the bytes are ordered least 
	significant first. A GP Fault interrupt will occur if an attempt is made to read inaccessible
	memory via this method. This will not affect the stability of the system.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger."

	| answer |
	<primitive: 138>
	answer := 0.
	1 to: 0 by: -1 do: [:i |
		answer := (answer bitShift: 8) + (self byteAtOffset: anInteger + i)].
	^answer!

wordAtOffset: anInteger put: anObject
	"Store an unsigned 2 byte value at byte offset anInteger within the receiver.
	If anObject is not representable as a 16-bit unsigned (Small)Integer, then 
	raise a 'cannot hold' error.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		2 -	anObject is not a SmallInteger.
		3 -	anObject is not in the range 0..65535 (i.e. out of unsigned 16-bit range)."

	<primitive: 139>
	^self retryWordAtOffset: anInteger put: anObject!

yourAddress
	"Answer the address at which the receiver points, rather than the address of 
	the receiver's bytes"

	^self asInteger! !

ExternalHandle comment:
''!
!ExternalHandle class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^HANDLEField! !

!ExternalHandle methodsFor!

asExternalHandle
	"Answer the receiver as an ExternalHandle."

	^self!

handle
	"Private - Please use #asPositiveInteger (or #asInteger) instead"

	^self value!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler.
	Output nil in place of the receiver as the future validity of an external handle is uncertain."

	anSTBOutFiler saveObject: self as: nil! !

ExternalMemory comment:
''!
!ExternalMemory class methodsFor!

Alloc: anInteger
	"Private - Allocate and answer anInteger bytes of memory from the process
	heap."

	^KernelLibrary default 
		heapAlloc: self processHeap asParameter
		dwFlags: 0
		dwBytes: anInteger
!

allocator
	"Private - Answer the appropriate allocator for the receiver.
	The allocator must implement:
		#Alloc:
		#Free:
		#Realloc:cb:"

	^self!

clear: anExternalAddress
	self free: anExternalAddress!

DidAlloc: anAddress
	"Private - Answer whether the specified memory block was allocated from the
	process heap (0 = no, 1 = yes, -1 = don't know).
	Implementation Note: About the best we can do is to attempt to validate the
	heap block. The answer may not be very reliable, and on a debug kernel
	may cause additional unspecified activity!!"

	anAddress isNull ifTrue: [^-1].
	^(KernelLibrary default
		heapValidate: self processHeap asParameter
		dwFlags: 0
		lpMem: anAddress)
			ifTrue: [1]
			ifFalse: [0]!

free: anExternalMemoryAddress
	"Free the memory block (assumed to have been previously allocated via the receiver)
	at anExternalMemoryAddress."

	self assert: [(self allocator DidAlloc: anExternalMemoryAddress) ~~ 0].
	self allocator Free: anExternalMemoryAddress!

Free: anAddress
	"Private - Free the memory at the specified address (which must
	previously have been allocated from the process heap)."

	KernelLibrary default
		heapFree: self processHeap asParameter
		dwFlags: 0
		lpMem: anAddress!

fromInteger: anInteger
	"Answer a new instance of the receiver with contents copied from anInteger
	Implementation note: Override superclass to make use of the external call
	primitive coercion trick."

	^(super fromInteger: anInteger) becomeA: self!

fromString: aString
	"Answer a new instance of the receiver pointing at a memory block containing
	the bytes of the argument, aString. There is no need to null terminate because
	ExternalMemory blocks are initialized with zeros."

	| answer size |
	size := aString byteSize.
	answer := self new: size.
	answer replaceFrom: 1 to: aString basicSize with: aString startingAt: 1.
	^answer!

GetSize: anAddress
	"Private - Answer the size of the specified heap block, or -1
	(actually 16rFFFFFFFF) for failure)."

	^KernelLibrary default 
		heapSize: self processHeap asParameter
		dwFlags: 0
		lpMem: anAddress!

HeapMinimize
	"Private - Minimize the size of the process heap."

	KernelLibrary default
		heapCompact: self processHeap asParameter
		dwFlags: 0!

new
	"Answer a new instance of the receiver of the initially holding a null pointer."

	^(self basicNew: 4)
		beFinalizable; 
		yourself!

new: anInteger
	"Answer a new instance of the receiver of the 
	pointing at a block of memory of size anInteger bytes,
	allocated from a COM IMalloc allocator."

	^self new 
		allocate: anInteger!

newFixed: anInteger
	"Answer a new instance of the receiver of the 
	pointing at an immovable block of memory of size anInteger bytes,
	allocated from an external heap."

	^self new: anInteger!

processHeap
	"Private - Answer an object representing the process heap which
	can be passed to a Win32 HeapXXX() API call."

	^KernelLibrary default getProcessHeap!

Realloc: anAddress cb: anInteger
	"Private - Resize the specified heap block, answering the new address,
	or 0 on failure."

	^(KernelLibrary default
		heapReAlloc: self processHeap asParameter
		dwFlags: 0
		lpMem: anAddress
		dwBytes: anInteger) asInteger! !

!ExternalMemory methodsFor!

allocate: anInteger
	"Allocate anInteger bytes of memory through the receiver's
	allocator, freeing any existing allocation. Answer the receiver."

	self isNull
		ifFalse: [self basicFree].
	self basicAllocate: anInteger!

allocator
	"Private - Answer the appropriate allocator for the receiver.
	The allocator must implement:
		#Alloc:
		#Free:
		#Realloc:cb:"

	^self class allocator!

basicAllocate: anInteger
	"Private - Allocate anInteger bytes of memory through the receiver's
	IMalloc interface. Answer the receiver. The memory is initialized with zeros.
	N.B. Does not free any existing allocation."

	| pBlock |
	pBlock := self allocator Alloc: anInteger.
	pBlock isNull ifTrue: [^OutOfMemoryError signal].
	KernelLibrary default zeroMemory: pBlock length: anInteger.
	self value: pBlock!

basicFree
	"Private - Free external resources held by the receiver."

	self allocator Free: self!

finalize
	"Private - Finalize the affairs of the receiver - certain death imminent.
	As the receiver points at memory allocated using a COM allocator,
	we must free it back using the appropriate IMalloc."

	self basicFree!

free
	"Free external resources held by the receiver, and leave in a clean state."

	self isNull ifTrue: [^self].
	self beUnfinalizable.
	self basicFree.
	self clear!

reallocate: anInteger
	"Resize the memory block pointed at by the receiver (may change the
	receiver's value) through the receiver's IMalloc. Answer the receiver."

	| newAddress |
	newAddress := self allocator Realloc: self cb: anInteger.
	newAddress isNull ifTrue: [^OutOfMemoryError signal].
	self value: newAddress!

resize: anInteger
	"Resize the memory block pointed at by the receiver. Answer the receiver.
	Implementation Note: This works via IMalloc::Realloc()."

	^self reallocate: anInteger!

size
	"Answer the size of the memory block pointed at by the receiver."

	| sz |
	sz := self allocator GetSize: self.
	sz = 16rFFFFFFFF ifTrue: [self error: 'bad heap block'].
	^sz! !

REFGUID comment:
'REFGUID is a pointer class for referencing guids. It is mainly for use in situations where a GUID* pointer is passed back into Smalltalk, e.g. in block callbacks and COM method implementations.

Two distinct classes are provided for guids because, as of version 3.0, all classes in the system have an associated <GUID>. The GUID class is now a standard byte object subclassed directly from Object. The advantage of moving GUID itself out of the ExternalStructure hierarchy is that it avoids doubling the number of objects required to hold the per-class guids. The disadvantage is that GUID instances are no longer able to act as a pointer/references to externally stored guids, and hence we need this class to meet that requirement.

e.g.

REFGUID fromAddress: Object guid yourAddress'!
!REFGUID class methodsFor!

fromInteger: anInteger
	"Answer a new instance of the receiver with contents copied from anInteger"

	^self new 
		basicDwordAtOffset: 0 put: anInteger;
		yourself! !

!REFGUID methodsFor!

_collate: comperand
	"Private - Answer the ordering relationship between the receiver
	and the argument, comperand."

	| status answer |
	status := ByteArray newFixed: 4.
	answer := RPCLibrary default uuidCompare: self uuid2: comperand status: status.
	status := status dwordAtOffset: 0.
	status == 0 ifFalse: [RPCError signalWith: status].
	^answer!

= comperand
	"Answer whether the receiver is equivalent to the <Object>, comperand."

	^self species = comperand species and: [(self _collate: comperand) == 0]!

asString
	"Answer a string representation of the receiver."

	^self value asString!

displayOn: target
	"Append an 'end-user suitable' textual representation of the receiver to the
	<puttableStream> argument, target.
	GUIDs are a fairly technical concept, but they do appear in the registry in a
	certain format, which we use here."

	self value displayOn: target!

hash
	"Answer the SmallInteger hash value for the receiver."

	^self value hash!

printOn: aStream
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		display: self value!

species
	"Answer the preferred class of the receiver - not always the same as the
	answer to #class."

	^GUID!

value
	"Answer the <GUID> at which the receiver points."

	^self species fromAddress: self!

value: guid
	"Set the 16-byte GUID pointed at by the receiver to the <GUID>, guid."

	self replaceFrom: 1 to: 16 with: guid startingAt: 1! !

Symbol comment:
'Symbol is the class of <String>s which are guaranteed to be unique throughout the system.

Symbol complies with the following ANSI protocols:
	Object
	magnitude
	collection
	sequencedReadableCollection
	readableString
	symbol'!
!Symbol class methodsFor!

addUnique: aSymbol 
	"Private - Add the argument aSymbol as a new entry in the Symbol Table. This private method should only be 
	used for adding Symbols not already present in the symbol table. Please use Symbol>>intern: to obtain
	a Symbol from a String (or alternatively String>>asSymbol)."

	| bucket bucketIndex |
	aSymbol isImmutable: true.
	bucketIndex := aSymbol hashCharacters \\ Table basicSize + 1.
	(bucket := Table basicAt: bucketIndex) isNil 
		ifTrue: [Table basicAt: bucketIndex put: (WeakArray with: aSymbol)]
		ifFalse: [bucket replaceIdentity: DeadObject current with: aSymbol].
	^aSymbol!

allInstancesDo: aMonadicValuable 
	"Evaluate the <monadicValuable> argument for each and every interned Symbol."

	Table do: [:eachBucket | eachBucket notNil ifTrue: [eachBucket nonCorpsesDo: aMonadicValuable]]!

findInterned: aString 
	"Answer the unique <Symbol> for aString if already defined, else nil.	
	N.B. This method previously had the selector #symbolAt:, and was private,
	but has been renamed and made public for compatibility with VisualWorks."

	(Table at: aString hashCharacters \\ Table basicSize + 1) ifNotNil: 
			[:bucket | 
			| corpse |
			corpse := DeadObject current.
			"Inline ArrayedCollection>>do: to avoid full block for best performance"
			1 to: bucket size
				do: 
					[:i | 
					| each |
					each := bucket at: i.
					(each == corpse == false and: [(aString trueCompare: each) == 0]) ifTrue: [^each]]].
	^nil!

fromString: aString
	"Answer a unique instance of the receiver whose contents are copied from aString."

	^self intern: aString!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Initialize class variables of the receiver.
	
	Table	-	An Array which is used as a hash table containing WeakArray buckets, in which the currently used
				instances of the receiver are kept."

	Table isNil ifTrue: [Table := Array new: 3989]!

intern: aString
	"Answer the unique Symbol for aString."

	| symbol |
	(symbol := self findInterned: aString) isNil
		ifTrue: [
			symbol := (super new: aString size) initialiseFrom: aString.
			self addUnique: symbol].
	^symbol!

intern: aString cookie: cookie
	"Private - Callback from VM, returns the unique Symbol for aString.
	WARNING: Do not send this message from Smalltalk code. Do not modify or 
	remove this method."

	Processor callback: cookie evaluate: [self intern: aString]!

internCharacter: aCharacter
	"Answer the Character argument, aCharacter, as a single character unique symbol"

	^self intern: aCharacter asString!

isLiteralSymbol: aSymbol 
	"Private - Answer whether the <Symbol> argument is representable
	as an unquoted literal symbol."

	| size binChars |
	size := aSymbol basicSize.
	size == 0 ifTrue: [^false].
	binChars := '!!%&*+,/<=>?@\~|-'.
	(binChars identityIncludes: (aSymbol at: 1)) 
		ifTrue: 
			[aSymbol 
				from: 2
				to: size
				do: [:each | (binChars identityIncludes: each) ifFalse: [^false]]]
		ifFalse: 
			[| includesColon initial |
			initial := true.
			includesColon := false.
			aSymbol 
				from: 1
				to: size
				do: 
					[:each | 
					initial 
						ifTrue: [(each == $_ or: [each isEnglishLetter]) ifTrue: [initial := false] ifFalse: [^false]]
						ifFalse: 
							[each == $: 
								ifTrue: [includesColon := initial := true]
								ifFalse: [(each == $_ or: [each isEnglishLetter or: [each isDigit]]) ifFalse: [^false]]]].
			(includesColon and: [aSymbol last ~~ $:]) ifTrue: [^false]].
	^true!

new
	"Instances of the receiver can only be created by using the #intern: and #internCharacter:
	messages."

	^self shouldNotImplement!

resizeTable
	"Private - Remove unused Symbols from the system - must be done to the exclusion of other processes, e.g:
		[Symbol resizeTable] forkAt: Processor timingPriority.
	By default we select a symbol table bucket size of about 6. This is appropriate for a development image, which
	interns a lot of symbols, but a runtime image could easily accomodate larger buckets to reduce the symbol table
	size. Answers the new size of the table."

	^self resizeTable: 6
!

resizeTable: anInteger
	"Private - Change the size of the Symbol Table so that all of the existing symbols are in buckets
	the average length of which is approximately equal to the <integer> argument.
	N.B. The argument is not the size of the resulting symbol table, which is answered."

	 | newSize insts |
	insts := self allInstances.
	newSize := (Integer primesUpTo: insts size // anInteger) last.
	Table := Array new: newSize.
	insts do: [:symbol | self addUnique: symbol].
	^newSize!

stats
	"Private - Answer a String containing some statistics about the Symbol table
		self stats
	"

	| empty full count maxLen aStream corpses |
	empty := 0.
	full := 0.
	count := 0.
	maxLen := 0.
	corpses := 0.
	1 to: Table basicSize
		do: 
			[:i | 
			| l |
			(l := Table basicAt: i) isNil 
				ifTrue: [empty := empty + 1]
				ifFalse: 
					[| len |
					full := full + 1.
					len := 0.
					l 
						do: [:s | s == DeadObject current ifTrue: [corpses := corpses + 1] ifFalse: [len := len + 1]].
					count := count + len.
					maxLen := maxLen max: len]].
	aStream := String writeStream: 80.
	^aStream
		nextPutAll: 'Empty buckets:	';
		print: empty;
		cr;
		nextPutAll: 'Full buckets:	';
		print: full;
		cr;
		nextPutAll: 'Empty slots:	';
		print: corpses;
		cr;
		nextPutAll: 'Symbols:		';
		print: count;
		cr;
		nextPutAll: 'Max Bkt Len:	';
		print: maxLen;
		cr;
		nextPutAll: 'Avg Bkt Len:	';
		print: count / full asFloat;
		contents!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| stream size answer bytes |
	anSTBInFiler version < 2 ifTrue: [^self stbReadFromProxy: anSTBInFiler].
	stream := anSTBInFiler stream.
	size := stream nextSDWORD.
	bytes := stream next: size.
	answer := self intern: (String fromString: bytes).
	anSTBInFiler register: answer.
	^answer!

stbReadFromProxy: anSTBInFiler 
	"Read and answer a <Symbol> from the binary in-filer argument, which is attached to an old
	format STB stream which used a proxy to store symbols."

	| answer ref |
	anSTBInFiler stream skip: 4.
	"Make a placeholder for the symbol"
	ref := anSTBInFiler register: nil.
	"Then read the string and intern it"
	answer := anSTBInFiler basicNext asSymbol.
	anSTBInFiler fixup: ref to: answer.
	^answer! !

!Symbol methodsFor!

= aSymbol
	"Symbols equality is the same as symbol identity since instances with the same
	characters are unique.
	The primitive should not fail."

	<primitive: 110>
	^self primitiveFailed!

argumentCount
	"Answer the <integer> number of arguments required by a method with the
	receiver as its selector."

	| argCount ch |
	self basicSize == 0 ifTrue: [^0].
	argCount := self occurrencesOf: $:.
	((ch := self at: 1) isLetter or: [ch == $_]) ifFalse: [
		argCount := argCount max: 1].
	^argCount!

asString
	"Answer a new <readableString> containing the characters of 
	the receiver."

	^String fromString: self!

asSymbol
	"Answer the <symbol> containing the characters of the receiver
	(i.e. the receiver, since <symbol>s are unique)."

	^self!

deepCopy
	"Answer the receiver - Symbols are unique, so a copy with the same characters
	must not exist.
	N.B. This implementation may cause problems in generic code which attempts to
	modify copies of Strings!!"
	
	^self!

displayString
	"Answer a String representation of the receiver in a form suitable for
	presentation to an end user.
	Implementation Note: Because our superclass implements #displayString to
	return self (for better performance), we must override back to a suitable
	implementation for Symbols which does not include the hash prefix."

	^self basicCopy!

forwardTo: anObject
	"Send the <Object> argument the receiver as a niladic message,
	answering the result. Assumes the receiver is a unary selector."

	^anObject perform: self!

hash
	"Answer the <integer> hash value for the receiver.
	Override back to the 16-bit identity hash which is temporally invariant,
	and very fast to calculate).
	The primitve should not fail (but must not be used for immediate objects).
	N.B. It is critical that this implementation is not changed."

	<primitive: 75>
	^self primitiveFailed!

initialiseFrom: aString
	"Private - Initialize the receiver to contain the characters of aString.
	Sent to String because replaceFrom:with:startAt: is invalid for symbols"

	aString
		replaceBytesOf: self
		from: 1 to: aString size startingAt: 1
!

isInfix
	"Answer whether the receiver is valid as an infix message selector."

	^(Compiler isAValidInitialIdentifierChar: self first) not!

isSymbol
	"Dolphin doesn't usually include these type tests, but they are used by a number of add-on
	libraries, so we have begrudgingly accepted them into the base."

	^true!

keywords
	"Answer a <sequencedReadableCollection> of the receiver's keywords."

	self isEmpty ifTrue: [^#()].
	^self last == $:
		ifTrue: [(self subStrings: $:) collect: [:keyword | keyword, ':']]
		ifFalse: [Array with: self]!

numArgs
	^self argumentCount!

printArgumentTypeOn: aStream
	"Private - Append a compilable argument type name, which is the receiver, to aStream."

	self displayOn: aStream!

printOn: aStream
	"Append a textual description of the receiver to aStream. If the receiver includes
	embedded spaces, then quote it. This may need to be extended to include other
	whitespace/non-printing characters."

	aStream nextPut: $#.
	(self class isLiteralSymbol: self)
		ifTrue: [aStream nextPutAll: self]
		ifFalse: [super printOn: aStream]!

refersToLiteral: anObject 
	"Private - Answer whether the receiver is a reference to the literal argument.
	This assumes that the receiver is in the role of a literal."

	^self == anObject!

replaceFrom: start to: stop with: replacementCollection startingAt: repStart
	"Symbols are not mutable."

	^self shouldNotImplement
!

shallowCopy
	"Answer the receiver - Symbols are unique, so we must not create a copy
	with the same characters."

	^self!

species
	"Answer the generic type of String and its subclasses. Statically bind to
	the method's class so that subclasses will also answer that class."

	^String!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler
		writePreambleFor: self;
		writeInteger: self size.
	anSTBOutFiler stream nextPutAll: self asByteArray! !

UnicodeString comment:
'UnicodeString is a minimal class to support wide character (16-bit) Unicode strings. Natively Dolphin uses byte-character strings at present.

UnicodeStrings can be constructed from <String>s when needed by sending the #asUnicodeString message, and converted back again by sending the #asString message.'!
!UnicodeString class methodsFor!

elementSize
	"Answer the size of the elements of the receiver in bytes."

	^2!

fromAddress: anAddress
	"Answer a new String instantiated from the null terminated string at anAddress."

	| len |
	len := KernelLibrary default lstrlenW: anAddress.
	^self fromAddress: anAddress length: len!

fromAddress: anAddress length: anInteger
	"Answer a new UnicodeString, of length anInteger, copied from the first anInteger
	characters pointed at by anAddress."

	| answer |
	answer := self new: anInteger.
	anAddress asExternalAddress replaceBytesOf: answer from: 1 to: anInteger*2 startingAt: 1.
	^answer!

fromString: aString
	"Answer a new instance of the receiver containing the same characters as the <String>
	argument.
	Implementation Note: CP_ACP is the only code page supported by Win95."

	| answer |
	answer := self new: aString size.
	(KernelLibrary default 
		multiByteToWideChar: CP_ACP
		dwFlags: 0
		lpMultiByteStr: aString
		cchMultiByte: -1
		lpWideCharStr: answer
		cchWideChar: answer basicSize) == 0 
		ifTrue: [^KernelLibrary default systemError].
	^answer!

new: anInteger
	"Answer an instance of the receiver to accomodate exactly
	anInteger characters (plus a null-term)."

	^super new: anInteger*2!

newFixed: aSmallInteger 
	"Answer an instance of the receiver of size aSmallInteger bytes (this method is 
	only valid for byte objects). The object is allocated from the fixed memory heap
	and will not move in memory (objects allocated with primitive 71 are free to 
	move to assist garbage collection, whereas those allocated with primitive 76 
	are in a traditional fixed heap)."

	^super newFixed: aSmallInteger * 2! !

!UnicodeString methodsFor!

asLowercase
	| copy |
	copy := self basicCopy.
	UserLibrary default stringLowerW: copy.
	^copy!

asString
	"Answer a byte string representation of the receiver."

	| buf size bytes |
	size := self size.
	buf := String new: size+size.
	size == 0 ifTrue: [^buf].	"Avoid 'The Parameter is Incorrect' error"
	bytes := KernelLibrary default
		wideCharToMultiByte: 0
		dwFlags: 0
		lpWideCharStr: self
		cchWideChar: size
		lpMultiByteStr: buf
		cchMultiByte: buf size
		lpDefaultChar: nil
		lpUsedDefaultChar: nil.
	bytes == 0 ifTrue: [^KernelLibrary default systemError].
	buf resize: bytes.
	^buf!

asUnicodeString
	"Answer a wide character String representation of the receiver."

	^self!

asUppercase
	| copy |
	copy := self basicCopy.
	UserLibrary default stringUpperW: copy.
	^copy!

at: anInteger
	"Answer the character at index, anInteger, in the receiver."

	| index |
	index := anInteger+anInteger.
	^Character value: (self basicAt: index) * 256 + (self basicAt: index-1)!

at: anInteger put: aCharacter
	"Replace the character at index, anInteger, in the receiver with aCharacter."

	^super at: anInteger+anInteger-1 put: aCharacter!

beginsWith: aCollection
	"Answer whether the receiver begins with the sequence
	of objects in the <Collection> argument."

	^self basicBeginsWith: aCollection!

byteSize
	"Private - Answer the size in bytes of this object, including the null terminator."

	^self basicSize + 2!

displayOn: aStream
	"Append the receiver in end-user form to aStream.
	We must convert to mbcs for display."

	aStream nextPutAll: self asString!

findString: aString startingAt: anInteger 
	"Answer the index of the <String> argument within the receiver, starting at the <integer>
	argument. If the receiver does not contain aString, answer 0."

	| size subSize firstElement |
	subSize := aString size.
	subSize == 0 ifTrue: [^0].
	firstElement := aString at: 1.
	size := self size.
	subSize == 1 
		ifTrue: 
			[^self 
				nextIndexOf: firstElement
				from: anInteger
				to: size].
	anInteger to: size - subSize + 1
		do: 
			[:i | 
			(self at: i) = firstElement 
				ifTrue: 
					[| j |
					j := 2.
					[(self at: i + j - 1) = (aString at: j)] whileTrue: 
							[j = subSize ifTrue: [^i].
							j := j + 1]]].
	^0!

first: anInteger
	"Answer a copy of the receiver comprising the leftmost anInteger elements."

	^self copyFrom: 1 to: anInteger!

nextIdentityIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Implementation Note: Override the inherited implementation because the byte-character search
	primitives won't work."

	^anElement class == Character 
		ifTrue: [self nextIndexOf: anElement from: start to: stop]
		ifFalse: [0 "Can only contain characters"]!

nextIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver between 
	startIndex and stopIndex inclusive. If there are no such occurrences, answer 0."

	self from: start to: stop keysAndValuesDo: [:i :elem | elem = anElement ifTrue: [^i]].
	^0!

replaceFrom: start to: stop with: replacementElements startingAt: repStart
	"Replace the characters of the receiver at index positions start through stop with 
	consecutive characters of aString beginning at index position startAt. Answer the 
	receiver."

	| offset |
	offset := repStart - start.
	(self == replacementElements and: [repStart < start]) 
		ifTrue: 
			["Move within same object overlaps, so do backwards"

			stop to: start
				by: -1
				do: [:i | self at: i put: (replacementElements at: offset + i)]]
		ifFalse: 
			["Non-overlapping moves are done forwards"

			start to: stop do: [:i | self at: i put: (replacementElements at: offset + i)]]!

resize: anInteger
	^super resize: anInteger * 2!

shallowCopy
	"Implemented here to ensure that copied UnicodeStrings are correctly terminated with a double null"

	^UnicodeString fromAddress: self yourAddress length: self size!

size
	"Answer the number of characters in the receiver."

	^self basicSize bitShift: -1!

strcspn: aString start: anInteger 
	^CRTLibrary default wcscspn: self yourAddress + ((anInteger - 1) * 2)
		strCharSet: aString asUnicodeString! !

MourningWeakArray comment:
''!
!MourningWeakArray class methodsFor!

elementsExpired: anInteger of: aWeakArray
	"Private - At least one of aWeakArray's elements has died, process the Corpses. The default is to
	do nothing but inform dependents. This message is sent to the aWeakArray's pathologist, 
	which is normally the receiver, but only if the receiver is marked as finalizable.
	The reason for making the default pathologist the receiver (i.e. the MourningWeakArray class)
	is to avoid creating a circular references in all MourningWeakArrays."

	aWeakArray trigger: #elementsExpired: with: anInteger!

initialize
	"Initialize the receiver."

	self makeMourner! !

!MourningWeakArray methodsFor!

elementsExpired: anInteger
	"Grieve for the loss of anInteger elements. Only objects marked as weak (see #beWeak) 
	will receive this message, and only then when objects that they are weakly referencing
	have no remaining strong references from objects reachable from the root objects (e.g.
	Smalltalk). By the time this message is received, the weakly referenced
	elements of the receiver will have been lost and replaced by Corpses.
	WeakArrays have no default behaviour for this message, so they forward it to
	their 'pathologist' so that it may perform whatever post mortem actions are necessary - e.g.
	to identify new corpses, and act accordingly (nil them out, or maintain a tally).
	Objects handling this message need to be aware that it is sent asynchronously, so they
	must not modify their contents except in a critical section which protects all access
	to that data from simultaneous access from other processes."

	self pathologist elementsExpired: anInteger of: self!

initialize
	"Private - Initialize the receiver's instance variables."
	
	super initialize.
	pathologist := self class!

pathologist
	"Answer the receiver's 'pathologist'. #elementsExpired: messages sent
	to the receiver by the MemoryManager are forwarded to the pathologist for it to 
	do as it wishes with the receiver's Corpse elements. By default the pathologist 
	is the receiver's class, and the receiver does not expect to receiver any 
	#elementsExpired: messages."

	^pathologist!

pathologist: anObject
	"Set the receiver's 'pathologist' to anObject. See #pathologist."

	pathologist := anObject isNil ifTrue: [self class] ifFalse: [anObject]! !

LinkedList comment:
'LinkedList is a class of <SequencedGrowableCollection> which is sequenced, ordered, contractible, expandable, readable and  writeable. The implementation is as an intrusively, singly, linked list (i.e. the elements hold the pointer to the next element), and requires that the elements of a LinkedList must be a kind of <Link> (or support the same protocol).

N.B. LinkedList is primarily present as an implementation artifact. The fact that it expects its elements to hold the makes it of limited use, since, unlike other SequenceableCollections, it cannot hold any type of object, and each element can only every exist in one linked list.

Instance Variables:
	firstLink		<Link>. Head of the list.
	lastList		<Link>. Tail of the list.'!
!LinkedList methodsFor!

addFirst: aLink
	"Add aLink at the head of the list; answer aLink."

	self isEmpty ifTrue: [lastLink := aLink].
	aLink nextLink: firstLink.
	^firstLink := aLink!

addLast: aLink
	"Add aLink at then end of the list; answer aLink."

	self isEmpty 
		ifTrue: [firstLink := aLink]
		ifFalse: [lastLink nextLink: aLink].
	lastLink := aLink.
	^aLink!

approxSize
	"Private - Answer the approximate size of the receiver.
	Implementation Note: The size of LinkedLists must be calculated (no tally
	is kept), which is expensive, so we revert to the basic collection
	implementation."

	^2!

at: index
	"Answer the element that is the index'th Link of the linked list."

	| i aLink |
	i := 1.
	aLink := firstLink.
	[aLink isNil] whileFalse: [
		i = index ifTrue: [^aLink].
		i := i + 1.
		aLink := aLink nextLink].
	^self errorSubscriptBounds: index
!

at: index put: anObject
	"Store anObject as the index'th element of the receiver.
	Not supported by LinkedLists at present."

	^self shouldNotImplement!

do: operation
	"Evaluate the <monadicValuable> argument, operation, for each of the elements of the 
	receiver. Answers the receiver."

	| aLink |
	aLink := firstLink.
	[aLink isNil] whileFalse: [ 
		operation value: aLink.
		aLink := aLink nextLink]!

isEmpty
	"Answer whether the receiver contains no elements. 
	Implemenation Note: Override superclass to provide a more efficient implementation."

	^firstLink isNil
!

remove: oldElement ifAbsent: exceptionHandler 
	"Remove oldElement from the list and answer it, or evaluate the niladic
	valuable exceptionHandler if it's not found in the list.
	Implemenation Note: We use identity comparison, because the Links
	of a list are unique (necessitated by the 'intrusive' implementation)."

	oldElement == firstLink 
		ifTrue: 
			[firstLink := firstLink nextLink.
			firstLink isNil ifTrue: [lastLink := nil]]
		ifFalse: 
			[| currLink |
			currLink := firstLink.
			
			[currLink isNil ifTrue: [^exceptionHandler value].
			currLink nextLink == oldElement] 
					whileFalse: [currLink := currLink nextLink].
			currLink nextLink: oldElement nextLink.
			oldElement == lastLink ifTrue: [lastLink := currLink]].
	oldElement nextLink: nil.
	^oldElement

	" A slightly neater, but slower (because of the need to use two locals), implementation"
	"	| currLink prevLink |
	currLink := firstLink.
	[ currLink isNil ifTrue: [ ^exceptionHandler value ]. currLink == oldElement ] whileFalse: [
		prevLink := currLink.
		currLink := currLink nextLink ].
	currLink == firstLink 
		ifTrue: [ firstLink := currLink nextLink ]
		ifFalse: [ prevLink nextLink: currLink nextLink ].
	currLink == lastLink ifTrue: [ lastLink := prevLink ].
	oldElement nextLink: nil.
	^oldElement"!

removeAll
	"Empty the receiver of all contents"

	firstLink := lastLink := nil!

removeAtIndex: index
	"Remove, and answer, the element of the receiver at the specified 
	<integer> index, by shuffling elements which succeed it down one slot.
	Raise an BoundsError if there is no element with that index."

	| currLink prevLink i |
	index < 1 ifTrue: [^self errorSubscriptBounds: index].
	currLink := firstLink.
	i := 1.
	[currLink isNil ifTrue: [^self errorSubscriptBounds: index]. 	"ran off the end"
	 i = index] whileFalse: [
		i := i + 1.
		prevLink := currLink.
		currLink := currLink nextLink ].
	currLink == firstLink 
		ifTrue: [firstLink := currLink nextLink]
		ifFalse: [prevLink nextLink: currLink nextLink].
	currLink == lastLink ifTrue: [lastLink := prevLink].
	currLink nextLink: nil.
	^currLink!

removeFirstIfAbsent: exceptionHandler
	"Remove and answer the first element of the receiver, but if the
	receiver is empty answer the result of evaluating the niladic valuable,
	exceptionHandler."

	| aLink |
	self isEmpty ifTrue: [^exceptionHandler value].
	aLink := firstLink.
	firstLink == lastLink
		ifTrue: [firstLink := nil. lastLink := nil]
		ifFalse: [firstLink := aLink nextLink].
	aLink nextLink: nil.
	^aLink
!

removeLastIfAbsent: exceptionHandler 
	"Remove and answer the last element of the receiver, but if the
	receiver is empty answer the result of evaluating the niladic valuable,
	exceptionHandler."

	| aLink |
	self isEmpty ifTrue: [^exceptionHandler value].
	aLink := lastLink.
	firstLink == lastLink 
		ifTrue: 
			[firstLink := nil.
			lastLink := nil]
		ifFalse: 
			["The list is singly linked, so we must iterate through it"

			| temp |
			temp := firstLink.
			[temp nextLink == lastLink] whileFalse: [temp := temp nextLink].
			temp nextLink: nil.
			lastLink := temp].
	^aLink!

size
	"Answer the number of elements in the receiver.
	Implementation Note: We maintain no kind of tally, so we must traverse
	the list to determine this - i.e. it's going to be quite SLOW."

	^self countElements! !

OrderedCollection comment:
'OrderedCollections store an ordered, contiguous sequence of elements. They are much like resizable arrays'!
!OrderedCollection class methodsFor!

new
	"Answer a new instance of the receiver with sufficient capacity (initially)
	for the default number of elements."

	^self new: 5!

new: count
	"Answer a new instance of the receiver with sufficient initial capacity
	to hold the number of elements specified by the <integer> argument,
	count. The instance is initally empty (i.e.it reports 0 when sent #size)."

	^(self basicNew: count) initialize!

ofSize: count
	"Private - Answer a new instance of the receiver with the number of
	nil elements specified by the <integer> argument, count.

	This method differs from OrderedCollection>>new:, as that
	method answers an <OrderedCollection> with the capacity for
	anInteger elements, but which is initially empty (i.e. it
	reports a size of 0)."

	^(self basicNew: count)
		firstIndex: 1
		lastIndex: count! !

!OrderedCollection methodsFor!

add: newElement afterIndex: index
	"Add newElement to the receiver immediately after the element currently at the
	specified <integer> index. index must be between 0 and the receiver's current 
	size (if not raise an exception). Answer newElement."

	| basicIndex |
	basicIndex := index + firstIndex.
	(basicIndex > (lastIndex + 1) or: [basicIndex < firstIndex]) ifTrue: [^self errorSubscriptBounds: index].
	lastIndex == self basicSize ifTrue: [ 
		self makeRoomAtEndFor: 1.
		basicIndex := index + firstIndex].
	"Slide the elements down the collection toward the new end to make room for the insertion"
	lastIndex to: basicIndex by: -1 do: [:i | self basicAt: i + 1 put: (self basicAt: i)].
	lastIndex := lastIndex + 1.
	^self basicAt: basicIndex put: newElement!

addAllFirst: aCollection 
	"Prepend all elements of the <collection> argument to the receiver,
	in the order that they appear in the argument, as determined by
	its implementation of #do:. Answer the new elements."

	"Implementation Note: Override for better performance by
	opening up a space at the front in one operation."

	| extra |
	extra := aCollection size.
	firstIndex <= extra ifTrue: [self makeRoomAtFirstFor: extra - firstIndex + 1].
	firstIndex := firstIndex - extra.
	aCollection inject: firstIndex
		into: 
			[:i :e | 
			self basicAt: i put: e.
			i + 1].
	^aCollection!

addAllLast: newElements
	"Append the elements of the <sequencedCollection>, newElements, to the receiver,
	in the order that they appear in newElements (as defined by its implementation
	of #do:). Answer newElements."

	| size |
	size := newElements size.
	self basicSize - lastIndex < size ifTrue: [self makeRoomAtEndFor: size].
	newElements 
		do: [:each | self basicAt: (lastIndex := lastIndex + 1) put: each].
	^newElements!

addAnsweringIndex: newObject
	"Append newObject as the last element of the receiver. 
	Answer the index at which the object was added."

	self addLast: newObject.
	^lastIndex - firstIndex + 1!

addFirst: newElement
	"Insert newElement as the first element of the receiver.
	Implementation Note: Override for performance."

	firstIndex == 1 ifTrue: [self makeRoomAtFirstFor: self growSize].
	firstIndex := firstIndex - 1.
	^self basicAt: firstIndex put: newElement
!

addLast: newObject
	"Append newObject as the last element of the receiver. Answer newObject.
	Implementation Note: Override for performance."

	lastIndex == self basicSize ifTrue: [self makeRoomAtEndFor: 1].
	lastIndex := lastIndex + 1.
	^self basicAt: lastIndex put: newObject!

asOrderedCollection
	"Answer an OrderedCollection containing the same elements as the receiver.
	No conversion is required in this case."

	^self!

at: index
	"Answer the element at the specified <integer> index of the receiver."

	| basicIndex |
	^(index < 1 or: [ (basicIndex := index + firstIndex - 1) > lastIndex ])
		ifTrue: [self errorSubscriptBounds: index]
		ifFalse: [self basicAt: basicIndex]!

at: index ifAbsent: exceptionBlock
	"Answer an <Object> which is the element of the receiver 
	at the specified index. If the index is out of bounds answer
	the result of evaluating the <niladicValuable> exceptionBlock."

	| basicIndex |
	^(index < 1 or: [ (basicIndex := index + firstIndex - 1) > lastIndex ])
		ifTrue: [exceptionBlock value]
		ifFalse: [self basicAt: basicIndex]!

at: index put: storee
	"Replace the element at the <integer> index of the receiver with
	the <Object> argument, storee.
	Report an error if there is no such element."

	| basicIndex |
	^(index < 1 or: [(basicIndex := index + firstIndex - 1) > lastIndex])
		ifTrue: [self errorSubscriptBounds: index]
		ifFalse: [self basicAt: basicIndex put: storee]!

copyWith: newElement
	"Answer a <sequencedReadableCollection> which is a copy of 
	the receiver that has newElement added in the correct position
	as defined by the receiver's sort order."

	^self copy
		add: newElement;
		yourself!

copyWithout: oldElement
	"Answer a <sequencedReadableCollection> which is a copy of the receiver, but in
	which all occurrences of the <Object> oldElement have been removed."

	| answer |
	answer := self copyEmpty.
	self do: [:element | element = oldElement ifFalse: [answer add: element]].
	^answer!

do: operation 
	"Evaluate monadic value argument, operation, for each of the element of the 
	receiver. Answers the receiver."

	"Implementation Note: Override to avoid error checking in #at: for better performance."

	firstIndex to: lastIndex do: [:i | operation value: (self basicAt: i)]!

firstIndex: first lastIndex: last
	"Private - Initialize the receiver's first and last indices."

	firstIndex := first.
	lastIndex := last
!

includes: target
	"Answer whether the argument, target, is one of the elements of the receiver.
	Implementation Note: Override superclass to provide a more efficient implementation."

	firstIndex to: lastIndex do: [:i | (self basicAt: i) = target ifTrue: [^true]].
	^false!

initialize
	"Initialize the receiver after creation"

	firstIndex := 1.
	lastIndex := 0
!

insert: newElement before: anInteger 
	"Private - Insert the argument, newElement, into the receiver at the basic index
	specified by the argument, anInteger, shuffling any subsequent elements down.
	index must be between 0 and the receiver's current basic size (if not an exception
	is raised), however no check is made to ensure that it lies within the current
	first and last indices. Answer the index at which the element was actually
	inserted."

	| basicIndex |
	basicIndex := lastIndex == self basicSize 
				ifTrue: 
					[| offset |
					offset := anInteger - firstIndex.
					self makeRoomAtEndFor: 1.
					firstIndex + offset]
				ifFalse: [anInteger].

	"Slide the elements down the collection toward the new end to make room for the insertion"
	lastIndex to: basicIndex
		by: -1
		do: [:i | self basicAt: i + 1 put: (self basicAt: i)].
	lastIndex := lastIndex + 1.
	self basicAt: basicIndex put: newElement.
	^basicIndex - firstIndex + 1!

isEmpty
	"Answer whether the receiver contains no elements. 
	Implementation Note: Override superclass to provide a more efficient implementation."

	^firstIndex > lastIndex!

makeRoomAtEndFor: anInteger
	"Private - Make room at the end of the receiver to accomodate at least anInteger
	more elements. If there is insufficient free space in the receiver, then it is expanded 
	to accomodate	more elements."

	| shift capacity |
	capacity := self basicSize.
	(capacity - self size) < anInteger ifTrue: [
		"Too full, increase the receivers capacity. We don't bother shifting" 
		^self resize: capacity + (anInteger roundUpTo: self growSize)].
	shift := 1 - firstIndex.	"N.B. shift < 0"

	"Move tail of collection towards head"
	firstIndex to: lastIndex do: [:i | self basicAt: i + shift put: (self basicAt: i)].
	"Nil out old slots"
	lastIndex + shift + 1 to: lastIndex do: [:i | self basicAt: i put: nil].
	firstIndex := 1.
	lastIndex := lastIndex + shift!

makeRoomAtFirstFor: anInteger
	"Private - Make room at the start of the receiver to accomodate anInteger elements."

	| newOrderedCollection |
	newOrderedCollection := self class new: self basicSize + anInteger.
	firstIndex to: lastIndex do: [:i | newOrderedCollection basicAt: anInteger + i put: (self basicAt: i)].
	newOrderedCollection 
		firstIndex: anInteger + firstIndex
		lastIndex: anInteger + lastIndex.
	^self become: newOrderedCollection!

nextIdentityIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver's indexable
	variables between startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Override the inherited implementation to make use of the primitive as the receiver's elements
	are contiguous between the first and last indices."

	| index offset |
	offset := firstIndex - 1.
	index := self basicIdentityIndexOf: anElement from: start+offset to: stop+offset.
	^index == 0
		ifTrue: [0]
		ifFalse: [index - offset]!

nextIndexOf: anElement from: start to: stop
	"Answer the index of the next occurrence of anElement in the receiver between 
	startIndex and stopIndex inclusive. If there are no such occurrences, answer 0.
	Implementation Note: Override the superclass to provide a more efficient
	inlined implementation (important for serial searches)."

	start to: stop do: [:i | (self basicAt: i+firstIndex-1) = anElement ifTrue: [^i]].
	^0!

removeAll
	"Empty the receiver of all contents"

	#todo "Implement more efficient mechanism (need a basic block write operation)".
	firstIndex to: lastIndex do: [:i | self basicAt: i put: nil].
	firstIndex := 1.
	lastIndex := 0!

removeAtIndex: index
	"Remove, and answer, the element of the receiver at the specified 
	<integer> index, by shuffling elements which succeed it down one slot.
	Raise an BoundsError if there is no element with that index."

	| element basicIndex |
	element := self at: index.
	(basicIndex := index + firstIndex - 1) == firstIndex
		ifTrue: [
			self basicAt: firstIndex put: nil.
			firstIndex := firstIndex + 1]
		ifFalse: [
			basicIndex + 1 to: lastIndex do: [:i | self basicAt: i - 1 put: (self basicAt: i)].
			self basicAt: lastIndex put: nil.
			lastIndex := lastIndex - 1].
	^element!

resize: anInteger
	"Private - Override back to the basic implementation as our elements are contiguously located.
	This changes the capacity of the receiver, but has no other effect."

	<primitive: 101>
	^super resize: anInteger!

reverseDo: aMonadicValuable 
	"Evaluate the <monadicValuable> argument against each of the element of the receiver in reverse
	order, from end to start. Answer the receiver."

	"Implementation Note: Override to avoid error checking in #at: for better performance."

	lastIndex to: firstIndex
		by: -1
		do: [:i | aMonadicValuable value: (self basicAt: i)]!

select: discriminator
	"Evaluate the monadic valuable argument, discriminator, for each of the receiver's elements.
	Answer a new Collection like the receiver containing only those elements for which 
	the discriminator evaluates to true."

	| newCollection |
	newCollection := self copyEmpty.
	self do: [:each | (discriminator value: each) ifTrue: [newCollection add: each]].
	^newCollection!

setSize: anInteger
	| newLast |
	newLast := firstIndex + anInteger - 1.
	"Nil out any slots after the new last index"
	newLast + 1 to: lastIndex do: [:each | self basicAt: each put: nil].
	"Resize if necessary"
	newLast > self basicSize ifTrue: [self makeRoomAtEndFor: newLast - lastIndex].
	"Making room may have shifted elements down so must recalc."
	lastIndex := firstIndex + anInteger - 1.!

size
	"Answer the number of elements in the receiver."

	^lastIndex - firstIndex + 1
!

sortUsing: aSortAlgorithm
	"Perform an in-place sort against the receiver using the specified sort algorithm"
	
	aSortAlgorithm 
		sort: self
		from: firstIndex
		to: lastIndex!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBCollectionProxy forCollection: self)!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: aDyadicValuable 
	"Private - Evaluate the <dyadicValuable> argument for each element of the receiver
	between the specified <integer> indices, inclusive, with the element and its index as
	respectively the second and first arguments. No bounds checks are performed."

	startInteger to: stopInteger
		do: [:i | aDyadicValuable value: i value: (self basicAt: i + firstIndex - 1)]! !

Semaphore comment:
''!
!Semaphore class methodsFor!

boolean
	"Answer a new Boolean Semaphore, initially signalled.
	The communication messages #set, and #pulse are intended for use
	with Boolean Semaphores, rather than #signal."

	^self new signal; yourself!

forMutualExclusion
	"Answer a new instance of the receiver with one excess signal (i.e a Boolean semaphore)."

	^self boolean!

new
	"Answer a new semaphore which will block when the first wait is executed on it 
	(i.e. it's initial value is zero)."

	^self basicNew initialize! !

!Semaphore methodsFor!

= anObject
	"Answer whether the receiver and anObject are considered equivalent.
	An equality comparison based on the list of processes waiting on the
	receiver does not make sense for a Semaphore, so override back to
	the default (identity-based) implementation from Object."

	<primitive: 110> 
	^self primitiveFailed!

add: newElement afterIndex: index
	"Add newElement to the receiver immediately after the element currently at the
	specified <integer> index. index must be between 0 and the receiver's current 
	size (if not raise an exception). Answer newElement."

	^self shouldNotImplement!

critical: aBlock
	"Evaluate aBlock as a critical section - i.e. aBlock is evaluated only when
	no other Blocks are being evaluated under the control of the receiver.
	Ensure semaphore does not remain decremented, even should an exception be thrown by aBlock.
	However note that the critical section will remain 'locked' until the exception is
	actually handled and the stack is unwound past this point.

	Implementation Note: It is possible that the VM may interrupt this process between
	the time that the #wait completes and any subsequent instructions being run
	(in fact it is quite likely in a low priority process). If the interrupt terminates the 
	process, then the Semaphore could be left locked. The simpler
	implementation in 2.1 and earlier (with the #wait outside the #ensure: block)
	thus had a very small window when the Semaphore could be left in an invalid
	state if the process was interrupted. This implementation fixes that bug - it
	is not possible for the process to be interrupted without a value having been
	assigned into the return value holder."

	| retHolder |
	retHolder := Array new: 1.
	^[
		self wait: INFINITE ret: retHolder.
		aBlock value
	] ensure: [
		(retHolder basicAt: 1) == WAIT_OBJECT_0 
			ifTrue: [self signal]]!

critical: aBlock atPriority: anInteger
	"Evaluate aBlock as a critical section - i.e. aBlock is evaluated only when
	no other Blocks are being evaluated under the control of the receiver.
	Ensure semaphore does not remain decremented, even should an exception be thrown by aBlock.
	The active processes priority is temporarily raised to the argument, anInteger,
	during the execution of the critical section.
	The purpose of this message is to avoid the starvation of a high priority process which can occur
	if it shares a critical section with a low priority process which never gets scheduled due to other
	process' activities."

	| activePriority waitResult |
	activePriority := Processor activeProcess priority: anInteger.
	waitResult := Array new: 1.
	^[
		self wait: INFINITE ret: waitResult.
		aBlock value
	] ensure: [
		(waitResult basicAt: 1) == WAIT_OBJECT_0 
			ifTrue: [self signal].
		Processor activeProcess priority: activePriority]!

excessSignals
	"Private - Answer the count of signals in excess of waits to the receiver"

	^signals!

excessSignals: anInteger
	signals := anInteger!

hash
	"Answer the SmallInteger hash value for the receiver. 
	A hash value based on the list of processes waiting on the
	receiver does not make sense for a Semaphore, so override back to
	the default (identity hash) implementation from Object."

	^self identityHash!

initialize
	"Private - Initialize the instance variables of the receiver."

	signals := 0
!

primSetSignals: pulse
	"Private - Set the excess signal count of the receiver to the argument, anInteger,
	starting the first Waiting process, if any.

	Primitive failure reasons:
		0 -	pulse is not a SmallInteger."

	<primitive: 99>
	^self primitiveFailed!

printOn: aStream
	"Print a string representation of self on aStream."

	self excessSignals > 0 
		ifTrue: [aStream basicPrint: self; nextPut: $(; print: self excessSignals; nextPutAll: ' signals)']
		ifFalse: [super printOn: aStream]!

pulse
	"As #set, except that the excess signal count of the receiver is always set to 0.
	This 'pulsing' behaviour is useful for signalling a process only if there is one
	waiting, and otherwise leaving the receiver unsignalled."

	self primSetSignals: 0!

reset
	"Reset the excess signals recorded by the receiver to zero. There is no effect on any waiting processes."

	signals := 0
!

set
	"As #signal, except that if there are no Processes waiting for the receiver
	then the excess signal count is set to one, no matter how many times #set 
	is sent, and no matter what its previous value. This is useful for
	implementing process synchronisation 'Events', whereby one wants to record
	that something has happened, but not how many times it has happened."

	self primSetSignals: 1!

signal
	"Send a signal through the receiver. If one or more Processes are Waiting on the receiver,
	then transition the first of those Processes (on a FIFO basis, independent of priority) 
	from Waiting to Ready. 

	If no Processes are Waiting on the receiver, then the excess signal is remembered so that 
	subsequent #waits will not cause the sending Process to Wait.

	The primitive should not fail.

	N.B. A signalled Process will not normally run immediately unless it is of a higher priority 
	than 	the current active Process (i.e. does not yield), and there are not already Processes at 
	or above its priority which are also Ready (these will run instead)."

	<primitive: 85>
	^self primitiveFailed!

terminateProcess
	"Terminate the first process waiting on the receiver"

	self notEmpty ifTrue: [self first terminate]!

wait
	"The active Process must receiver a signal through the receiver before proceeding.
	Waiting processes may be interrupted, but will return to waiting when they have
	finished processing the interrupt. See #wait: and #wait:ret: for further details."

	| ret |
	ret := Array new: 1.
	self wait: INFINITE ret: ret.
	^ret basicAt: 1!

wait: timeout
	"The active Process must receive a signal through the receiver before 
	proceeding, or be interrupted (i.e. receive an interrupt from the VM), or timeout
	after anInteger milliseconds. See #wait:ret: for further details.

	The answer (written into the first slot of the return value holder by the primitive) could be 
	WAIT_OBJECT_0 if the wait completed successfully (either because the Semaphore had 
	excess signals, or because it was signalled), or WAIT_IO_COMPLETION if the primitive
	was interrupted, or WAIT_TIMEOUT if the wait timed out. BUT, the latter two results are
	not actually possible from this method since 
	1) 	an interrupted process will either not return here (if the Semaphore>>wait is returned 
		over and unwound), or will be resumed when the interrupt complets.
	2)	we request an INFINITE timeout."

	| ret |
	ret := Array new: 1.
	self wait: timeout ret: ret.
	^ret basicAt: 1!

wait: timeout ret: returnValueHolder
	"Private - The active Process must receive a signal through the receiver before proceeding,
	or be interrupted (i.e. receive an interrupt from the VM), or timeout after anInteger
	milliseconds. Answer the argument, returnValueHolder, with its first instance variable
	updated to hold and <integer> return code.

	At present the only valid values for timeout are, INFINITE, meaning wait for ever, and 0,
	meaning don't wait at all. The behaviour of these is as follows: INFINITE- Wait until the
	semaphore is signalled, answering WAIT_OBJECT_O. 0 - If the receiver has excess signals,
	then decrement the count, and answer WAIT_OBJECT_O, otherwise return immediately without
	waiting, but answer WAIT_TIMEOUT. i.e this is a way to 'poll' a Semaphore.

	If no signal has been sent, then the active Process will be transitioned from Running to
	Waiting until one is sent, when it may be returned to the Ready state.

	The purpose the returnValueHolder argument is to allow #wait to atomically wait for the
	availablity of a Semaphore _and_ update a variable in the enclosing context as to the
	outcome of that wait. This is important to the correct implementation of
	Semaphore>>critical:, for example, as otherwise it is not possible to reliably determine in
	unwind handling whether the Semaphore was grabbed or not - one can't rely on a normal return
	value, because the process may not yet have proceeded far enough to assign it back into a
	temporary in the calling context.

	Primitive failure reasons:
		0 -	One or other argument is not a SmallInteger
		1 -	receiver's excess signal count is not a SmallInteger (i.e. receiver corrupt).
		2 -	anInteger is not either INFINITE (-1) or 0.
		3 -   receiver is inactive (already waiting on a list)
		4 -	returnValueHolder is not of an appropriate shape to hold the return value
			(it must be a pointer object with at least one slot, e.g. a one element Array)"

	<primitive: 86>
	^self primitiveFailed! !

SortedCollection comment:
'SortedCollection is a class of <SequencedGrowableCollection>s whose elements are ordered in the sequence specified by a user-definable sort order function (the sort "block", actually a <dyadicValuable>). Note that unlike traditional Smalltalk implementations of SortedCollection, Dolphin''s implementation (as of D6) holds a <SortAlgorithm> instance rather than a <dyadicValuable> sort-order block. This allows the sorting algorithm to be pluggable, as well as the sort ordering. Another advantage is that the default sort order need not use a block at all, allowing for improved performance of the default sort by avoiding the need for block activations to perform element comparisons.

SortedCollection complies with the ANSI protocols:
	Object
	collection
	extensibleCollection
	sequencedCollection
	sequencedContractibleCollection
	sequencedReadableCollection
	SortedCollection

Elements can be added, removed or inserted, and can be accessed using external integer keys. However, it is an error to attempt to insert or replace elements at specific indices using any of the methods such as #at:put:, as this might invalidate the sort order.
 
Instance Variables:
	sortBlock		<dyadicValuable>
	algorithm		<SortAlgorithm>'!
!SortedCollection class methodsFor!

caseSensitiveSortBlock
	"Answer a <dyadicValuable> which can be used to sort <String>s into ascending order on a
	case sensitive basis (String's implementation of the #<= message, used by the default sort
	block, is case-insensitive).."

	^[:a :b | (a trueCompare: b) <= 0]!

defaultSortAlgorithm
	"Answer an instance of the default <SortAlgorithm>."

	^DefaultSortAlgorithm current!

defaultSortBlock
	"Answer a <dyadicValuable> that implements the default sort-order relationship."

	"ANSI standard specifies #< as default sort block comparison, but this is presumably a typo,
	since Smalltalk has historically used #<=, and furthermore it is useful in conjunction with
	stable sort algorithms."

	^[:a :b | a <= b]!

new: anInteger 
	"Answer an instance of the receiver with capacity for the specified <integer> number of
	elements, sorted using the default <SortAlgorithm>."

	^(super new: anInteger)
		setSortAlgorithm: self defaultSortAlgorithm;
		yourself!

sortAlgorithm: aSortAlgorithm 
	"Answer a new instance of the receiver which uses the specified <SortAlgorithm>."

	^(super new)
		setSortAlgorithm: aSortAlgorithm;
		yourself!

sortBlock: aDyadicValuable 
	"Answer a new instance of the receiver which uses the <dyadicValuable> argument (referred to
	as the 'sort block') to sort its elements. When evaluated the sort block should answer
	whether its first parameter should be ordered before the second parameter.

	Note: The discriminator does not need to be a BlockClosure (despite the #sortBlock: message,
	which is historic), it must simply understand the #value:value: message from the
	<dyadicValuable> protocol."

	^self sortAlgorithm: (self defaultSortAlgorithmClass sortBlock: aDyadicValuable)!

value: anObject1 value: anObject2 
	"Private - Implement this part of the <dyadicValuable> protocol in order that the receiver
	can be its own default sort 'block' for historical reasons. This is no longer used in
	Dolphin 6 and will be officially deprecated in a future release."

	^anObject1 <= anObject2!

withNilsSortBlock
	^[:a :b | a isNil ifTrue: [true] ifFalse: [b isNil ifTrue: [false] ifFalse: [a <= b]]]
! !

!SortedCollection methodsFor!

, operand
	"This is the concatenation operation. Answer a copy of the receiver with each element of the
	<sequencedReadableCollection> argument, operand, added, in the receiver's sort order."

	^self copy
		addAll: operand;
		yourself!

add: newElement
	"Add the <Object>, newElement, as a new element of the receiver, inserting it in the correct
	place to maintain the sort ordering of the receiver. Answers newElement."

	self addAnsweringIndex: newElement.
	^newElement!

add: newElement afterIndex: index
	"Add newElement to the receiver immediately after the element currently at the specified
	index. index must be between 0 and the receiver's current size (if not raise an exception).
	Answer newElement. 
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement!

add: newElement beforeIndex: index
	"Add newElement to the receiver immediately before the element currently at the specified
	index (i.e. the newElement will then have that index). index must be between 1 and the
	receiver's current size plus 1 (if not raise an exception). Answer newElement.
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement!

addAll: aCollection 
	"Include all the elements of the <collection> argument as elements of the receiver. Answer
	aCollection."

	aCollection size > (self size // 3) 
		ifTrue: 
			[self addAllWithoutSorting: aCollection.
			self reSort]
		ifFalse: [aCollection do: [:each | self add: each]].
	^aCollection!

addAllFirst: newElements
	"Prepend all elements of the collection newElements to the receiver, in the order that they
	appear in newElements (as determined by its implementation of #do:). Answer newElements.
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement!

addAllLast: aCollection
	"Insert all elements of aCollection as the new first elements of the receiver, in the order
	that they appear in aCollection. Answer aCollection. 
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement!

addAllWithoutSorting: aCollection 
	"Append the elements of the <collection> argument to the receiver without doing any sorting.
	Answer aCollection."

	self makeRoomAtEndFor: aCollection size.
	aCollection do: 
			[:each | 
			lastIndex := lastIndex + 1.
			self basicAt: lastIndex put: each].
	^aCollection!

addAnsweringIndex: anObject 
	"Add anObject as a new element of the receiver, inserting it in the correct place to
	maintain the ascending ordering of the receiver as determined by sortBlock. Answer the index
	at which anObject was added."

	^self insert: anObject before: (self indexForInserting: anObject)!

addFirst: anObject
	"Insert newObject as the first element of the receiver.
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement
!

addLast: anObject
	"Append newObject as the last element of the receiver. Answer newObject.
	SortedCollections maintain their own ordering, so this is not a valid operation."

	^self shouldNotImplement
!

algorithm
	"Answer the SortAlgorithm which the receiver is currently using to sort its elements."

	^algorithm!

algorithm: aSortAlgorithm 
	"Set the <SortAlgorithm> which the receiver uses to sort its elements."

	algorithm := aSortAlgorithm.
	self notEmpty ifTrue: [self reSort]!

asOrderedCollection
	"Answer an OrderedCollection containing the same elements as the receiver. The elements of
	the OrderedCollection will be sorted (at least initially) in the sort order of the
	receiver."

	" Implementation Note: Revert to the Collection implementation."

	^(OrderedCollection new: self size)
		addAll: self;
		yourself!

asSortedCollection
	"Answer a <SortedCollection> containing the same elements as the receiver with the same sort
	block (i.e the receiver)."

	^self!

at: index put: newElement 
	"Replace the element at the specified index of the receiver with newElement. Raise an
	exception if there is no such element. 
	This is not a valid operation for SortedCollections, as they are not writeable via index."

	^self shouldNotImplement!

binaryIncludes: anObject 
	"Answer whether the receiver includes the specified <Object>. Unlike #includes:, which is a
	serial search, this is a fast binary search performed using the receiver's sort block, and
	consequently the argument must be compatible with the receiver's sort block."

	| index |
	index := (self indexForInserting: anObject) - 1.
	^(index between: firstIndex and: lastIndex) and: [(self basicAt: index) = anObject]!

collect: transformer 
	"Evaluate the <monadicValuable> argument, transformer, for each of the receiver's elements.
	Answer a new collection like the receiver containing the values returned by the transformer
	on each evaluation."

	"Implementation Note: Override to return an <sequencedCollection> (in fact an
	OrderedCollection). We can't use the #species/#copyLike mechanism, because in general we
	want our copies to remain sorted in the current order."

	| answer |
	answer := OrderedCollection new: self size.
	self do: [:each | answer add: (transformer value: each)].
	^answer!

copyEmpty: anInteger 
	"Private - Answer an empty copy of the receiver, with enough space for anInteger
	number of elements."

	"Implementation Note: We must override in order to preserve the algorithm."

	^(super copyEmpty: anInteger) setSortAlgorithm: algorithm!

copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at index start, until
	element at index stop."

	"Implementation Note: We must reimplement, because we disallow a number of the methods used
	by the superclass implementation."

	| answer offset size |
	stop < start ifTrue: [^self copyEmpty: stop - start + 1].
	start < 1 ifTrue: [^self errorSubscriptBounds: start].
	stop > self size ifTrue: [^self errorSubscriptBounds: stop].
	size := stop - start + 1.
	answer := self copyLikeOfSize: size.
	"We assume the copy sorts in the same order"
	offset := start + firstIndex - 2.
	1 to: size do: [:i | answer basicAt: i put: (self basicAt: i + offset)].
	^answer!

copyLikeOfSize: anInteger 
	"Private - Answer an new collection of the same species as the receiver but with anInteger
	nil elements - i.e. not just with sufficient capacity for, but actually holding, anInteger
	nil elements."

	^(super copyLikeOfSize: anInteger) setSortAlgorithm: algorithm!

indexForInserting: anObject 
	"Private - Answer the index at which anObject would be added. This is located using a binary
	chop."

	| index low high |
	low := firstIndex.
	high := lastIndex.
	
	[index := (high + low) // 2.
	low > high] whileFalse: 
				[(algorithm compare:  (self basicAt: index) with: anObject) 
					ifTrue: [low := index + 1]
					ifFalse: [high := index - 1]].
	^low!

reSort
	"Resort the entire contents of the receiver in the order specified by the current
	<SortAlgorithm>."

	self sortFrom: firstIndex to: lastIndex!

reverse
	"Answer a copy of the receiver but with its elements in reverse order."

	" Implementation Note: Refine in order to answer an OrderedCollection because obviously
	reversing the receiver's elements would require inverting the sort block if the answer was
	to remain a sorted collection."

	| answer |
	answer := OrderedCollection new: self size.
	self reverseDo: [:element | answer add: element].
	^answer!

setSortAlgorithm: aSortAlgorithm 
	algorithm := aSortAlgorithm!

sortBlock
	"Answer a <dyadicValuable> (not necessarily a block) which implements the sort order
	comparison in use by the receiver's current <SortAlgorithm>. Note that the SortAlgorithm
	might not actually be using this sort block, but it will perform comparisons in the same
	way."

	^algorithm sortBlock!

sortBlock: aDyadicValuable 
	"Set the <dyadicValuable> which is evaluated to sort elements of the receiver to the
	argument, and then resort the receiver if necessary."

	self algorithm: (algorithm copyWithSortBlock: aDyadicValuable)!

sortFrom: startInteger to: stopInteger 
	"Private - Sort the receiver's indexed instance variables between the two <integer> indices,
	startInteger and stopInteger, using the receiver's current <SortAlgorithm>."

	algorithm 
		sort: self
		from: startInteger
		to: stopInteger!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	algorithm ~~ self class defaultSortAlgorithm
		ifTrue: [^anSTBOutFiler saveObject: self as: (STBSortedCollectionProxy forCollection: self)].

	super stbSaveOn: anSTBOutFiler

	! !

Dictionary comment:
'Class Dictionary represents a set of associations between keys and values. The values can be randomly accessed using the associated key. 

The elements of a Dictionary are instances of <Association>, a simple data structure for storing and retrieving the members of a key-value pair.

Conforms to the following ANSI protocols:
	collection
	abstractDictionary
	Dictionary'!
!Dictionary class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!Dictionary methodsFor!

_deepCopyElementsInto: aDictionary trail: anIdentityDictionary 
	self 
		associationsDo: [:element | aDictionary uncheckedAdd: (element _deepCopy: anIdentityDictionary)]!

add: anAssociation
	"Add anAssociation to the receiver. Answer anAssociation.
	Although very similar to at:put:, we store the actual association passed
	as an argument here in order to maintain its references."

	| index element |
	index := self findKeyOrNil: anAssociation key.
	element := self basicAt: index.
	element isNil
		ifTrue: [self privateAt: index put: anAssociation]
		ifFalse: [element value: anAssociation value].
	^anAssociation!

asSet
	"Answer a Set whose elements are the values stored in the receiver (any 
	duplicates are therefore eliminated).
	Revert to the Collection implementation."

	^(Set new: self size) 
		addAll: self; 
		yourself!

associationAt: key 
	"Answer the association named by the argument, key.  If key is not found,
	raise an exception."

	| assoc |
	assoc := self associationAt: key ifAbsent: [AbsentCookie].
	^assoc == AbsentCookie ifTrue: [self errorKeyNotFound: key] ifFalse: [assoc]!

associationAt: key ifAbsent: exceptionHandler 
	"Answer the association named by the argument, key. If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler."

	^(self basicAt: (self findKeyOrNil: key)) ifNil: [exceptionHandler value]!

associationAt: key ifPresent: operation 
	"Answer the result of evaluating the monadic valuable, operation, if
	the argument, key, is the key of an element in the receiver, with that
	key and element pair as its argument. If the key is not present, then 
	answer nil."

	| assoc |
	assoc := self associationAt: key ifAbsent: [AbsentCookie].
	^assoc == AbsentCookie ifFalse: [operation value: assoc]!

associationClass
	"Private - Answer the class of association to be used for holding
	key-value pairs in the receiver. Must respond to the Association protocol."
	
	^Association!

associations
	"Answer an OrderedCollection containing the receiver's associations"

	| answer |
	answer := OrderedCollection new: self size.
	self associationsDo: [:assoc | answer add: assoc].
	^answer!

associationsDo: operation
	"Evaluate the monadic valuable, operation, for each of the receiver's 
	key/value mappings."

	super do: [:assoc | operation value: assoc]!

associationsDo: aMonadicValuable separatedBy: aNiladicValuable 
	"Evaluate the <monadicValuable> operation argument for each of the 
	{key,value} associations in the receiver, interspersed with evaluations of 
	the <niladicValuable> separator argument. The separator is first evaluated after the first
	association, and is not evaluated after the last association (i.e. it is not evaluated
	at all if there are less than two associations)."

	| separator |
	separator := [separator := aNiladicValuable].	"Switch to the real separator after first eval."
	self associationsDo: 
			[:each | 
			separator value.
			aMonadicValuable value: each]!

at: anObject 
	"Answer the value at the specified <Object> key in the receiver, or if the key
	is not found raise a <NotFoundError>."

	"Implementation Note: This is not the obvious implementation, but is ~20% 
	faster since it the ifAbsent: argument is a static rather than a copying block.
	This is a worthwhile gain in such a commonly used method."

	| answer |
	answer := self at: anObject ifAbsent: [AbsentCookie].
	^answer == AbsentCookie ifTrue: [self errorKeyNotFound: anObject] ifFalse: [answer]!

at: key ifAbsent: operation 
	"Answer the value named by the <Object> argument, key.  If key is not found,
	answer the result of evaluating the <niladicValuable>, operation."

	^(self basicAt: (self findKeyOrNil: key)) 
		ifNil: [operation value]
		ifNotNil: [:element | element value]!

at: key ifAbsentPut: operation 
	"Answer the value of the receiver keyed by the <Object> argument, key.
	If key is not one of the receiver's keys, then add the result of evaluating 
	the <niladicValuable>, operation, at key, and answer that result."

	"Implementation Note: The operation might modify the collection, therefore we can't optimize
	but must perform the hash key lookup twice."

	| preexisting |
	preexisting := self at: key ifAbsent: [AbsentCookie].
	^preexisting == AbsentCookie ifTrue: [self at: key put: operation value] ifFalse: [preexisting]!

at: key ifPresent: operation 
	"Answer the result of evaluating the monadic valuable, operation, if
	the argument, key, is the key of an element in the receiver, with that
	element as its argument. If the key is not present, then answer nil."

	| value |
	value := self at: key ifAbsent: [AbsentCookie].
	^value == AbsentCookie ifFalse: [operation value: value]!

at: key put: newElement 
	"Store the <Object> argument newElement at the <Object>
	key, in the receiver. Answer newElement."

	| index |
	key isNil ifTrue: [^self error: 'key cannot be nil'].
	index := self findKeyOrNil: key.
	(self basicAt: index) 
		ifNil: [self privateAt: index put: (self newAssociation: key value: newElement)]
		ifNotNil: [:element | element value: newElement].
	^newElement!

atAll: keys put: newElement
	"Replace the elements of the receiver at each of the keys in the <collection> 
	argument, keys, with the <Object> argument, newElement."

	keys do: [:key | self at: key put: newElement]!

bestSlotFor: element boundedBy: capacity
	^self hash: element key max: capacity!

bindingFor: asString 
	"Answer the association whose key is equal to the argument in
	the receiver, or nil if the key is not present. Used by the Compiler"

	^self associationAt: asString ifAbsent: []!

changeKey: key to: newKey 
	"Private - Change the key of the element of the receiver with key, key, to
	newKey (e.g. rename a variable). Answer the <Association> whose
	whose key was changed."

	| assoc |
	assoc := self associationAt: key.
	self removeKey: key.
	assoc whileMutableDo: [assoc key: newKey].
	"We want to preserve the association of the element we're renaming, so we must
	 remove any existing element with the same name"
	self removeKey: newKey ifAbsent: [].
	self add: assoc.
	^assoc!

collect: transformer
	"Evaluate the monadic valuable argument, transformer, for each of the receiver's values.
	Answer a new collection like the receiver containing the same keys, and the values returned 
	by the transformer on each evaluation.
	N.B. Most Smalltalks implement this differently (each with their own, inconsistent, approaches)
	This is the ANSI Smalltalk definition."

	| answer |
	answer := self copyLike.
	self 
		keysAndValuesDo: [:key :value | answer at: key put: (transformer value: value)].
	^answer!

copyElementsInto: newMe
	"Private - Add the receiver's elements into the argument, newMe.
	Part of the implementation of hashed collection resizing. Override
	to use associationsDo: to preserve the existing associations."

	self associationsDo: [:element | newMe uncheckedAdd: element]!

do: operation 
	"Evaluate <monadicValuable> argument, operation, for each of the element of the 
	receiver. Answers the receiver.
	Implementation Note: Could use #associationsDo: (or keysAndValuesDo:), but 
	performance important here."

	1 to: self basicSize
		do: 
			[:i | 
			| element |
			(element := self basicAt: i) isNil ifFalse: [operation value: element value]]!

errorKeyNotFound: aKey
	"Private - Report that an attempt was made to look up a key which was not in the receiver"

	^self errorNotFound: aKey
!

errorValueNotFound: aValue
	"Private - Report that an attempt was made to look up the key for a value which was not
	in receiver"

	^self error: 'value not found: ', aValue printString
!

findElementOrNil: anAssociation
	"Private - Answer the index of the element with the a key equivalent to that
	of anAssociation. The elements of the receiver are Associations, so we look up
	by anAssociation's key."

	^self findKeyOrNil: anAssociation key!

findKeyOrNil: anObject 
	"Private - Answer the index of the given key in the receiver, or, if not found,
	the index of the first empty slot including and after that to which the key hashes"

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [anObject = element key]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

identityIncludes: anObject 
	"Answer whether the argument, anObject, is one of the receiver's elements."

	"Implementation Note: Set implementation will not work because the elements 
	are <Association>s, and we want to find an identitcal value."

	^self anySatisfy: [:each | anObject == each]!

includes: anObject 
	"Answer whether the argument, target, is one of the elements of the receiver."

	"Implementation Note: Set implementation will not work because the elements 
	are <Association>s, and we want to find an equal value."

	^self anySatisfy: [:each | anObject = each]!

includesAssociation: anAssociation 
	"Answer whether the receiver has an element (association between a key
	and a value) that is equal to the argument, anAssociation"

	| assoc |
	assoc := self associationAt: anAssociation key ifAbsent: [AbsentCookie].
	^assoc ~~ AbsentCookie and: [assoc value = anAssociation value]!

includesKey: anObject 
	"Answer whether the receiver has a key equal to the <Object>
	argument."

	^(self basicAt: (self findKeyOrNil: anObject)) notNil!

keyAtEqualValue: anObject ifAbsent: aNiladicValuable 
	"Answer the key of the <Object> value argument. If there is no such value, answer
	the result of evaluating the <niladicValuable> argument.
	Equality is used for comparison of the values (this increases the chances of 
	returning any duplicates the Dictionary might contain)."

	self keysAndValuesDo: [:eachKey :eachValue | anObject = eachValue ifTrue: [^eachKey]].
	^aNiladicValuable value!

keyAtValue: value 
	"Answer the <Object> key of the <Object> argument, value. 
	If there is no such value, send #errorValueNotFound: to the receiver with 
	value as its argument.
	N.B. Since values are not necessarily unique, answer the name of the first 
	one encountered in the search."

	| key |
	key := self keyAtValue: value ifAbsent: [AbsentCookie].
	^key == AbsentCookie ifTrue: [self errorValueNotFound: value] ifFalse: [key]!

keyAtValue: anObject ifAbsent: aNiladicValuable 
	"Answer the <Object> key of the <Object> value argument. 
	If there is no such value, answer the result of evaluating the 
	<niladicValuable> argument.
	N.B. Identity is used for comparison of the values, but see also
	#keyAtEqualValue:ifAbsent:"

	#todo.	"ANSI standard states that #= be used rather than #==, but long established standard is the latter"
	self keysAndValuesDo: [:eachKey :eachValue | eachValue == anObject ifTrue: [^eachKey]].
	^aNiladicValuable value!

keys
	"Answer a <collection> containing the receiver's keys.
	Implementation Note: We answer a <Set>, but that should
	not be relied upon in portable code."

	| aSet |
	aSet := self keysClass new: self size.
	self keysDo: [:key | aSet add: key].
	^aSet!

keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each key/value pair in the receiver.
	The key/values pairs are visited in an arbitray order.
	Implementation Note: Could use #associationsDo:, but performance important here."

	1 to: self basicSize
		do: 
			[:i | 
			| element |
			(element := self basicAt: i) isNil 
				ifFalse: [operation value: element key value: element value]]!

keysClass
	"Private - Answer the class of Collection to be used for collecting the keys of the receiver"
	
	^Set!

keysDo: operation
	"Evaluate the <monadicValuable>, operation, for each of the receiver's keys."

	self keysAndValuesDo: [:key :value | operation value: key]!

newAssociation: keyObject value: valueObject 
	^self associationClass key: keyObject value: valueObject!

occurrencesOf: anObject 
	"Answer the number of the receiver's values which are equal to the argument."

	"Implementation Note: Override back to the Collection implementation as 
	dictionaries can contain duplicate values."

	| count |
	count := 0.
	self do: [:element | element = anObject ifTrue: [count := count + 1]].
	^count!

printOn: aStream
	"Print a string representation of self on aStream. 
	We must override because we'd like to print out the associations as this
	is more useful, otherwise this is the same as the superclass implementation."

	| printed |
	printed := Processor activeProcess _alreadyPrinted.
	(printed includes: self) ifTrue: [^self printCyclicRefOn: aStream].
	printed add: self.
	
	[| tooMany |
	tooMany := aStream position + self maxPrint.
	aStream
		basicPrint: self;
		nextPut: $(.
	self associationsDo: 
			[:each | 
			aStream position > tooMany 
				ifTrue: 
					[aStream nextPutAll: '... etc ...'.
					^self].
			each printOn: aStream]
		separatedBy: [aStream space].
	aStream nextPut: $)] 
			ensure: [printed remove: self ifAbsent: []]!

remove: anObject ifAbsent: aBlock
	"Elements of Dictionaries must be removed by key."

	^self shouldNotImplement
!

removeAllKeys: keys
	"Remove any elements from the receiver with the keys in the <collection> argument, keys.
	If any of the keys are not present in the receiver, or there are duplicates in
	keys, then raise an exception."

	keys do: [:k | self removeKey: k]!

removeAllKeys: keys ifAbsent: operation
	"Remove any elements from the receiver with the keys in the <collection>
	argument, keys. If any of the keys are not present in the receiver, or there 
	are duplicates in keys, then evaluate the <niladicValuable> argument, 
	operation, but do not stop the enumeration."

	keys do: [:k | self removeKey: k ifAbsent: operation]!

removeAssociation: anAssociation
	"Remove the key and value association, anAssociation, from the receiver. Answer anAssociation."

	self removeKey: anAssociation key.
	^anAssociation
!

removeAssociation: anAssociation ifAbsent: aNiladicValuable
	"Remove the <association> from the receiver with the same key as the <association> argument.
	Answer anAssociation. If there is no such association in the receiver, answer the result of
	evaluating the <niladicValuable>, operation."

	self removeKey: anAssociation key ifAbsent: [^aNiladicValuable value].
	^anAssociation
!

removeKey: key 
	"Remove the <Object> key (and its associated value), from the receiver. 
	If key is not in the receiver, report an error. Otherwise, answer the value 
	named by key."

	| removed |
	removed := self removeKey: key ifAbsent: [AbsentCookie].
	^removed == AbsentCookie ifTrue: [self errorKeyNotFound: key] ifFalse: [removed]!

removeKey: key ifAbsent: operation 
	"Remove the <Object> key (and its associated value), from the receiver. If key is
	not in the receiver, answer the result of evaluating the <niladicValuable>,
	operation. Otherwise, answer the value named by key."

	| index |
	index := self findKeyOrNil: key.
	^(self basicAt: index) 
		ifNil: [operation value]
		ifNotNil: 
			[:element | 
			self removeIndex: index.
			element value]!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^SearchPolicy equality!

select: discriminator
	"Evaluate the monadic valuable argument, discriminator, for each of the receiver's elements.
	Answer a new Collection like the receiver containing only those elements for which 
	the discriminator evaluates to true.
	Implementation Note: Override to maintain both keys and values, and to use the same
	Associations where possible."

	| answer |
	answer := self newSelection.
	self associationsDo: 
			[:assoc | 
			(discriminator value: assoc value) ifTrue: [answer add: assoc]].
	^answer!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler
		saveObject: self
		as: (STBCollectionProxy
			class: self class
			array: self associations asArray)!

storeOn: aStream 
	"Append to the <puttableStream> argument, target, an expression which when 
	evaluated will answer a collection similar to the receiver."

	| first |
	aStream nextPutAll: '(('.
	self class storeOn: aStream.
	aStream nextPutAll: ' new)'.
	first := true.
	self keysAndValuesDo: [:key :value |
		first
			ifTrue: [first := false]
			ifFalse: [aStream nextPut: $;].
		aStream nextPutAll: ' at: '.
		key storeOn: aStream.
		aStream nextPutAll: ' put: '.
		value storeOn: aStream].
	first ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)!

values
	"Answer a <collection> containing the receiver's values (includes any duplicates)."

	| answer |
	answer := OrderedCollection new: self size.
	self do: [:value | answer addLast: value].
	^answer! !

IdentitySet comment:
''!
!IdentitySet methodsFor!

findElementOrNil: anObject 
	"Private - Answer the index of the given object in the receiver, or, if not found,
	the index of the first empty slot including and after that to which the object hashes.
	Implementation Note: This is a clone of Set>>findElementOrNil: except for the comparison of the elements
	which use identity (#identityHash and #==) instead of equality (#hash and #=). 
	The entire method is copied for performance reasons. 	We scale the hash value 
	for large collections to avoid excessive collisions caused by the small identity hash
	range (0..65535)."

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [anObject == element]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]! !

PluggableSet comment:
'PluggableSet is the class of <Set>s which support a pluggable <searchPolicy>, and which can thus be configured to behave in the same way as either standard <Set>s (equality search) or <IdentitySet>s (identity search), or indeed any user-defined search policy.

Instance Variables:
	searchPolicy		<searchPolicy>. The policy used to hash and compare elements of the receiver.'!
!PluggableSet class methodsFor!

defaultSearchPolicy
	"Answer the default <searchPolicy> used by instances of the receiver."

	^SearchPolicy equality!

new: anInteger searchPolicy: aSearchPolicy
	"Answer a new instance of the receiver with an initial capacity of at least 
	<integer> count elements (i.e. the size is a hint), and with the specified <searchPolicy>."

	^(self new: anInteger) setSearchPolicy: aSearchPolicy!

searchPolicy: policy
	"Answer a new, empty, instance of the receiver with the specified <searchPolicy>."

	^self new setSearchPolicy: policy! !

!PluggableSet methodsFor!

copyEmpty: anInteger
	"Private - Answer an empty copy of the receiver, with enough space for anInteger
	number of elements. 
	Implementation Note: We must override in order to preserve the searchPolicy."

	^(super copyEmpty: anInteger) setSearchPolicy: self searchPolicy!

findElementOrNil: anObject 
	"Private - Answer the index of the given object in the receiver, or, if not found,
	the index of the first empty slot including and after that to which the object hashes.
	A pluggable <searchPolicy> is used for key comparisons and hashing."

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [searchPolicy compare: element with: anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^searchPolicy hash: anObject max: anInteger!

initialize
	"Private - Instance variable initialization. The tally records the number of elements."

	super initialize.
	searchPolicy := self class defaultSearchPolicy
!

newSelection
	"Private - Answer a new empty collection like the receiver to 
	contain a selection of the receiver's elements."

	^self class searchPolicy: self searchPolicy!

preResize: newMe
	"This message is sent by the receiver when resizing, before the
	receiver's elements are added to newMe. We must assign across the
	search policy."

	newMe setSearchPolicy: self searchPolicy!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^searchPolicy!

searchPolicy: aSearchPolicy 
	"Set the receiver's <searchPolicy>."

	self setSearchPolicy: aSearchPolicy.
	self notEmpty ifTrue: [self rehash]!

setSearchPolicy: aSearchPolicy
	"Private - Set the receiver's <searchPolicy>. Answer the receiver."

	searchPolicy := aSearchPolicy.
	^self!

species
	"Answer the class of object to be used when copying the receiver with #collect:, etc."

	^Set
! !

SharedSet comment:
'SharedSet is a process safe subclass of <Set>, which has the same behavior. It''s instances make use of a <Mutex> (a mutual exclusion lock) to prevent more than one process from accessing their elements at the same time. Although process safe to the extent   that the invariants of the data structure are maintained, further synchronisation mechanisms will almost certainly be required if a <SharedSet> is used to buffer information between processes (e.g. see <SharedQueue>).

The following methods of Set are, or are not, overridden for the reasons given:

	add:		Overridden, public entry point
	addAll:		Implmented using #add:
	asArray		Overridden because must ensure size does not change between instantiating the 			new Array and the #do: loop.
	asByteArray	ditto
	asBag		Bags size affects capacity only, so not overridden.
	asOrderedCollection	ditto
	asSet		atomic (answers self)
	asSortedCollection	Size affects capacity only, so not overridden
	asSortedCollection:	ditto
	at:		Not permitted on sets
	at:put:		Ditto
	capacity		atomic
	collect:		Implemented in terms of #do:. Result will be a Set.
	copyElementsInto:	ditto
	do:		Overridden, public entry point
	findElementOrNil:	private, used only within methods protected by mutex (e.g. add:)
	find:ifAbsent:	Overidden, public entry point
	fixCollisionsFrom: 	ditto
	grow		ditto (sent only from maintainLoadFactor)
	identityIncludes:	Overridden, public entry point
	includes:		Overridden, public entry point
	initialize		overridden, but to instantiate the mutex, not for mutual exclusion
	isEmpty		uses #size, which is atomic
	moveFrom:to:	ditto
	occurrencesOf:	uses #includes: and otherwise accesses no shared data
	postResize:	private, used only within methods protected by mutex
	preResize:		ditto
	privateAt:put:	ditto
	rehash		uses #resize:, and otherwise accesses no shared data
	relocateElement:from: 	private, used only within methods protected by mutex
	remove:ifAbsent:	Overridden, public entry point
	removeIndex:	private, used only within methods protected by mutex
	resize:		Overridden, public entry point
	shrink		Overridden, public entry point
	size		atomic
	tally		atomic
	uncheckedAdd:	private, used only within methods protected by mutex

Instance Variables:
	mutex		<Mutex> for ensuring mutually exclusive access to the collection.

Class Variables:
	AbsentCookie	<Object>. Unique cookie used internally to signal element absence.

'!
!SharedSet methodsFor!

add: newObject
	"Include newObject as one of the elements of the receiver. Answer newObject."

	^mutex critical: [super add: newObject]!

addAll: newElements
	"Include all the elements of the <collection> argument, newElements, as the receiver's elements. 
	Answer newElements. 
	Implementation Note: Override to avoid overhead of acquiring mutex for each addition."

	mutex critical: [newElements do: [:each | super add: each]].
	^newElements!

asArray
	"Answer an Array whose elements are those of the receiver (ordering is possibly arbitrary).
	Must implement as critical section as otherwise Array size might be wrong."

	^mutex critical: [super asArray]!

asByteArray
	"Answer a ByteArray whose elements are those of the receiver (ordering is possibly arbitrary).
	Must implement as critical section as otherwise the ByteArray size might be wrong."

	^mutex critical: [super asByteArray]!

do: operation
	"Evaluate monadic value argument, operation, for each of the elements (non-nil members) 
	of the receiver. Answers the receiver.
	N.B. It is important that operation does not put the active process to sleep (i.e.
	wait on some Semaphore) as this will prevent other Smalltalk processes from accessing
	the receiver for a potentially long time, and if a weak subclass, may prevent the
	removal of Corpses from taking place. In the case of weak subclasses, if the putting the
	active process to sleep is unavoidable, then the weak status should be removed until
	the end of the critical block (e.g. send #beStrong at the start of the block, and
	#beWeakWithNotify at the end of the block)."

	mutex critical: [super do: operation]!

find: target ifAbsent: exceptionHandler
	"Answer the actual element of the receiver which matches (however 'match' is defined)
	the argument, target. If there is no such element, then the result of evaluating the
	niladic valuable, exceptionHandler, is answered."

	| answer |
	answer := mutex critical: [super find: target ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

identityIncludes: target
	"Answer whether the <Object> argument, target, is one of the receiver's elements."

	^mutex critical: [super identityIncludes: target]!

includes: target
	"Answer whether the argument, target, is equal to one of the elements of the receiver."

	^mutex critical: [super includes: target]!

initialize
	"Instance variable initialization. The mutex protects against concurrent access from multiple
	processes, but permits the same process to make multiple entries."

	super initialize.
	mutex := Mutex new!

mutex
	"Private - Answer the receiver's mutual exclusion object"
	
	^mutex!

mutex: aMutex
	"Private - Set the receiver's mutual exclusion object to the argument, aMutex"

	mutex := aMutex!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver. In
	the case of a SharedSet we need a new mutex."

	super postCopy.
	mutex := Mutex new.
	^self!

preResize: newMe
	"This message is sent by the receiver when resizing, before the receiver's elements are added to newMe. 
	We must assign across the mutex so that process synchronisation is correctly preserved."

	newMe mutex: mutex!

printOn: aStream
	"Print a string representation of the receiver on aStream."

	mutex critical: [super printOn: aStream]!

remove: oldElement ifAbsent: exceptionHandler
	"If oldElement is one of the receiver's elements, then remove it from the 
	receiver and answer it (as Sets cannot contain duplicates, only one element is
	ever removed). If oldElement is not an element of the receiver (i.e.
	no element of the receiver is #= to oldObject) then answer the 
	result of evaluating the niladic valuable, exceptionHandler."

	| answer |
	answer := mutex critical: [super remove: oldElement ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

resize: anInteger
	"Private - Resize the receiver to have a capacity suitable for accomodating
	at least anInteger elements."

	mutex critical: [super resize: anInteger]!

shrink
	"Rebuild the collection with the optimal size for its current number of elements,
	as #rehash, but doesn't resize if already correct size."

	mutex critical: [super shrink]!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	mutex critical: [super stbSaveOn: anSTBOutFiler]! !

LookupTable comment:
'A LookupTable is a form of <Dictionary> that does not actually store <Assocation>s, but instead maintains parallel vectors of keys and values. This has the advantage of consuming less space and generally offering higher performance. 

Dictionary behaviour involving <Assocation>s (e.g. #associationsDo:, #associationAt:) is implemented by dynamically generating associations as required. This may adversely affect performance where such behaviour is used extensively, and the transient nature of the associations may not always be appropriate. In these (rare) cases a standard Dictionary should be used.

LookupTable itself uses equality-based hashing and comparisons. The subclass IdentityDictionary and its subclasses employ identity-based hashing and comparisons.

Instance Variables:
	values	<Array> of values associated with the same numbered keys in the indexable instance variables of the LookupTable.'!
!LookupTable methodsFor!

add: anAssociation
	"Add anAssociation to the receiver. Answer anAssociation. Unlike Dictionaries, 
	LookupTables do not actually store Associations, therefore we must 
	reimplement this in terms of #at:put:."

	self at: anAssociation key put: anAssociation value.
	^anAssociation
!

associationAt: anObject ifAbsent: aNiladicValuable 
	"Answer a new <Association> between the key and value of the receiver at the first argument.
	If the key is not found, answer the result of evaluating the <niladicValuable> exception
	handler."

	"Implementation Note: LookupTables do not actually store key-value pairs in Associations, so
	the answer is not state information."

	| value |
	value := self at: anObject ifAbsent: [AbsentCookie].
	^value == AbsentCookie 
		ifTrue: [aNiladicValuable value]
		ifFalse: [self newAssociation: anObject value: value]!

associationsDo: operation
	"Evaluate the monadic valuable, operation, for each of the receiver's 
	key/value associations.
	Implemenation Note: We must override because the receiver does not 
	actually contain Associations."

	self keysAndValuesDo: [:k :v | 
		operation value: (self associationClass key: k value: v)]!

at: anObject ifAbsent: aNiladicValuable 
	"Answer the value named by the key argument, anObject.  If the key is not found, 
	answer the result of evaluating the <niladicValuable> argument."

	| index |
	index := self findKeyOrNil: anObject.
	^(self basicAt: index) isNil ifTrue: [aNiladicValuable value] ifFalse: [values at: index]!

at: key put: newElement 
	"Store the argument newElement with the external key, key,
	in the receiver. Answer newElement."

	| index |
	key isNil ifTrue: [^self error: 'key cannot be nil'].
	index := self findKeyOrNil: key.
	"We must store the value first, as a resize may occur during privateAt:put:"
	values at: index put: newElement.
	(self basicAt: index) isNil ifTrue: [self privateAt: index put: key].
	^newElement!

basicValues
	"Private - Answer the <ArrayedCollection> of values in the receiver."

	^values!

bestSlotFor: element boundedBy: capacity
	^self hash: element max: capacity!

copyElementsInto: newMe
	"Private - Add the receiver's elements into the argument, newMe.
	Private part of the implementation of hashed collection resizing. Override
	to use keysAndValuesDo: to enumerate through the keys as well as the values."

	self keysAndValuesDo: [:key :value | newMe uncheckedAt: key put: value]
!

do: aMonadicValuable 
	"Evaluate <monadicValuable> argument, for each of the elements (values) 
	of the receiver. Answers the receiver."

	"Implementation Note: We could implement in terms of #keyAndValuesDo:, but 
	performance is important here."

	1 to: self basicSize
		do: [:i | (self basicAt: i) isNil ifFalse: [aMonadicValuable value: (values at: i)]]!

findElementOrNil: anObject
	"Private - Answer the index of the specified key object in the receiver, 
	or nil if not present.
	Implementation Note: The directly held elements of a LookupTable
	are the keys. The values are held in a separate values <Array>."

	^self findKeyOrNil: anObject!

findKeyOrNil: anObject 
	"Private - Answer the index of the given key in the receiver, or, if not found,
	the index of the first empty slot including and after that to which 
	the key hashes."

	"Implementation Note: Similar to Dictionary>>findKeyOrNil:, except that the 
	private elements of the receiver are not associations, but the keys themselves.
	Subclasses which use identity for key comparison and hashing MUST override this method."

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| key |
	(key := self basicAt: index) isNil or: [key = anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

identityIncludes: comperand
	"Answer whether the <Object> argument, comperand, is one of the receiver's elements.
	Implementation Note: Override for improved performance."

	^values identityIncludes: comperand!

includesAssociation: anAssociation
	"Answer whether the receiver contains the key/value pair in anAssociation"

	| index |
	index := self findKeyOrNil: anAssociation key.
	^(self basicAt: index) notNil
		and: [(values at: index) = anAssociation value]
!

initialize
	"Private - Initialize the receiver."

	super initialize.
	values := self valuesClass new: self basicSize
!

isImmutable: aBoolean 
	values isImmutable: aBoolean.
	^super isImmutable: aBoolean!

keyAtEqualValue: value ifAbsent: exceptionHandler
	"Answer the name of the argument, value. If there is no such value, answer
	the result of evaluating the niladic valuable, exceptionHandler.
	Equality is used for comparison of the values (this increases the chances of 
	returning any duplicates the Dictionary might contain).
	Implementation Note: Override the superclass implementation which is
	slow for LookupTables as they don't actually contain Associations.
	Lookup tables are implemented as a pair of parallel arrays, so we can
	do much better by a fast serial search through the value array."

	| i |
	i := values indexOf: value.
	^i == 0
		ifTrue: [exceptionHandler value]
		ifFalse: [self basicAt: i]!

keyAtValue: value ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value. 
	If there is no such value, answer the result of evaluating the 
	<niladicValuable>, operation. Identity is used for comparison of the values.
	Implementation Note: Override superclass implementation to use the fast
	primitive identity search search through the values Array. This makes keyAtValue:
	several times faster in LookupTables than it is in Dictionaries."

	| index |
	index := values basicIdentityIndexOf: value from: 1 to: values basicSize.
	^index == 0
		ifTrue: [operation value]
		ifFalse: [self basicAt: index]!

keysAndValuesDo: operation 
	"Evaluate the dyadic valuable, operation, for each key/value pair in the receiver.
	Implementation Note: As LookupTables do not store Associations, we must
	override superclass implementation."

	1 to: self basicSize
		do: [:i | (self basicAt: i) ifNotNil: [:key | operation value: key value: (values at: i)]]!

keysDo: operation 
	"Evaluate the <monadicValuable>, operation, for each of the receiver's keys."

	1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [:key | operation value: key]]!

moveFrom: fromIndex to: toIndex
	"Private - Destructively move the element at index, fromIndex, over
	the element (normally nil) at index, toIndex. Overridden to
	move both key and value which are stored separately in LookupTables"

	self basicAt: toIndex put: (self basicAt: fromIndex).
	values at: toIndex put: (values at: fromIndex).
	self basicAt: fromIndex put: nil.
	values at: fromIndex put: nil
!

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver. In
	the case of a LookupTable we need to copy the values array too."

	super postCopy.
	values := values copy.
	^self!

removeKey: key ifAbsent: exceptionHandler 
	"Remove the key (and its associated value), from the receiver. If key is not in the 
	receiver, answer the result of evaluating the niladic valuable, exceptionHandler.
	Otherwise, answer the value named by key."

	| index |
	index := self findKeyOrNil: key.
	^(self basicAt: index) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: 
			[| value |
			value := values at: index.
			values at: index put: nil.
			self removeIndex: index.
			value]!

select: discriminator
	"Evaluate the monadic valuable argument, discriminator, for each of the receiver's elements.
	Answer a new <collection> like the receiver (i.e. an <abstractDictionary>) containing only 
	those elements for which the discriminator evaluates to true.
	Implementation Note: Override for better performance (#associationsDo: is slow against
	LookupTables)."

	| answer |
	answer := self newSelection.
	self 
		keysAndValuesDo: [:k :v | (discriminator value: v) ifTrue: [answer at: k put: v]].
	^answer!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler saveObject: self as: (STBIdentityDictionaryProxy forCollection: self)!

uncheckedAdd: newObject 
	"Private - Add newObject to the receiver, without checking to see if it is already present.
	We also assume the receiver is large enough to accommodate the new element, and so do not
	attempt to maintain the load factor."

	self uncheckedAt: newObject key put: newObject value!

uncheckedAt: key put: anObject
	"Private - Store the argument anObject with the external key, key, in the 
	receiver without checking to see if it is already an element of the receiver.
	Also, does not attempt to maintain the optimal load factor. Answer anObject.
	This is part of the implementation of resizing of hashed collections."

	| index |
	index := self findKeyOrNil: key.
	tally := tally + 1.
	self basicAt: index put: key.
	^values at: index put: anObject.
!

valuesClass
	"Answer the class of Collection to use to hold the values of the receiver's elements
	(N.B. This is a different concept from #keysClass, which is used for copying the keys of 
	the receiver)."

	^Array! !

PoolDictionary comment:
''!
!PoolDictionary class methodsFor!

named: aSymbol 
	^(self new)
		name: aSymbol;
		yourself! !

!PoolDictionary methodsFor!

add: anAssociation
	"Add anAssociation to the receiver. Answer anAssociation.
	Although very similar to at:put:, we store the actual association passed
	as an argument here in order to maintain its references.
	The keys of associations stored in pool dictionaries must be strings."

	anAssociation key class == String
		ifFalse: [self error: 'Pools are keyed with Strings'].
	^super add: anAssociation!

associationClass
	"Private - Answer the class of association to be used for holding
	key-value pairs in the receiver. Must respond to the Association protocol."
	
	^VariableBinding!

at: key ifAbsent: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler.
	The keys of pools are Strings."

	^super at: key asString ifAbsent: exceptionHandler
!

at: key put: anObject
	"Store the argument anObject with the external key, aKey,
	in the receiver. Answer anObject. Ensure the key is a String."

	^super at: key asString put: anObject!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	self name displayOn: aStream
!

environment
	"Answer the receiver's controlling name space."

	^Smalltalk
!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutName
	"Answer the receiver's default file name for file outs (<name>.st)."

	| path package |
	path := File composeStem: self name extension: Package sourceGlobalExtension.
	package := Package manager packageOfGlobalNamed: self name asSymbol.
	package notNil ifTrue: [
		path := File replacePath:  path with: package path ].
	^path!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self!

includesKey: key
	"Answer whether the receiver has a key equal to the argument, key.
	Override superclass to permit symbolic/string keys."

	^super includesKey: key asString!

isChanged
	"Answer true if the receiver or any of it's contents have been changed since
	their changed flag was last reset."

	^self propertyAt: #isChanged ifAbsent: [false]!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	"Note that we don't test the existing value of the change flag here, because
	 we want to inform the package regardless (in case it isn't currently changed
	 for some reason)"
	aBoolean 
		ifTrue: [ | package |
			self propertyAt: #isChanged put: true.
			(package := self owningPackage) notNil ifTrue: [
				package isChanged: true]]
		ifFalse: [self removePropertyAt: #isChanged ifAbsent: []]!

name
	"Answer the receiver's name."

	^self environment keyAtValue: self ifAbsent: ['Anon']!

name: aSymbol 
	!

owningPackage
	"Answers the package that owns the receiver or nil if it is not yet owned
	by any package"

	^Package manager packageOfGlobalNamed: self name!

owningPackage: aPackage
	"Set the receiver's <Package> to be the argument. Any current package association is lost."

	aPackage addGlobalNamed: self name!

removeKey: key ifAbsent: exceptionHandler
	"Remove the key (and its associated value), from the receiver. If key is
	not in the receiver, answer the result of evaluating the niladic valuable,
	exceptionHandler. Otherwise, answer the value named by key.
	Override in order to accept Symbols/Strings."

	^super removeKey: key asString ifAbsent: exceptionHandler! !

SystemDictionary comment:
'Class of the root of the system. SystemDictionary''s single instance (Smalltalk) 
provides associative access to all global objects in the system.'!
!SystemDictionary class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!SystemDictionary methodsFor!

add: anAssociation
	"Add anAssociation to the receiver. Answer anAssociation.
	Although very similar to at:put:, we store the actual association passed
	as an argument here in order to maintain its references.
	The keys of associations stored in pool dictionaries must be strings."

	((anAssociation key isKindOf: Symbol) and: [anAssociation key notEmpty])
		ifFalse: [self error: 'SystemDictionaries are keyed with non-empty Symbols'].
	^super add: anAssociation!

allBehaviors
	"Private - Answer a <sequencedReadableCollection> of all of the Behaviors 
	contained in the system in breadth first order, with instance classes preceeding
	metaclasses."

	| answer |
	answer := OrderedCollection new: 4000.
	self allBehaviorsDo: [:behavior | answer addLast: behavior].
	^answer!

allBehaviorsDo: operation
	"Private - Evaluate the monadic valuable, operation, for each of the Behaviors in the system.
	N.B. No guarantee is made about ordering, except that the operation is evaluated
	for a subclass after its superclass."

	self allClasses do: [ :class |
		operation value: class.
		operation value: class class]!

allClasses
	"Answer a <sequencedReadableCollection> of all of the classes in the system, in breadth-first order.
	There is no particular ordering at a particular depth."

	allClasses isNil ifTrue: [allClasses := Class allClasses].
	^allClasses!

allClassesDo: operation
	"Private - Evaluate the monadic valuable, operation, for each of the classes in the system.
	N.B. No guarantee is made about ordering, except that the block is evaluated
	for a subclass after its superclass."

	self allClasses do: operation!

allRoots
	"Answer a <sequencedReadableCollection> of all global root classes - ie. those that are subclasses of nil."

	allRoots isNil ifTrue: [allRoots := Class allRoots].
	^allRoots!

associationAt: key ifAbsent: exceptionHandler
	"Answer the association named by the argument, key. If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler."

	^super associationAt: key asSymbol ifAbsent: exceptionHandler!

associationClass
	"Private - Answer the class of association to be used for holding
	key-value pairs in the receiver. Must respond to the Association protocol."
	
	^VariableBinding!

at: key ifAbsent: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler.
	The keys of pools are Strings."

	^super at: key asSymbol ifAbsent: exceptionHandler!

at: key put: anObject
	"Store the argument anObject with the external key, aKey,
	in the receiver. Answer anObject. Ensure the key is a String."

	key isEmpty ifTrue: [self error: 'Invalid global name'].
	^super at: key asSymbol put: anObject!

bindingFor: aString 
	"Answer the association whose key is equal to the argument in
	the receiver, or nil if the key is not present. Used by the Compiler."

	^super bindingFor: aString asSymbol!

classAdded: class
	"Private - The new <Class>, class, has been added to the receiver.
	Clear down the all class cache and inform observers."

	self clearCachedClasses.
	^self trigger: #classAdded: with: class.
!

classRemoved: aClass
	"Private - The <Class> argument has been removed from the system.
	Clear down the class caches and inform observers."

	self clearCachedClasses.
	self trigger: #classRemoved: with: aClass!

classUpdated: aClass
	"Private - The <Class>, aClass, has been updated. 
	Clear down the class caches and inform observers."

	self clearCachedClasses.
	^self trigger: #classUpdated: with: aClass!

clearCachedClasses
	"Private - Clear down the all class cache."

	allRoots := allClasses := nil!

developmentSystem
	"Answer the current instance of <SmalltalkSystem> if installed, otherwise 
	a <DeafObject>."

	| devSys |
	devSys := self at: #SmalltalkSystem ifPresent: [:c | c current].
	^devSys ifNil: [DeafObject current]!

getEvents
	"Private - Answer the EventsCollection belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^events!

includesKey: key
	"Answer whether the receiver has a key equal to the argument, key.
	Override superclass to permit symbolic/string keys."

	^super includesKey: key asSymbol!

postResize: oldMe
	"Private - This message is sent by the receiver when resizing, after the
	receiver's elements have been added to a new collection and the
	receiver has become that collection. It is a chance for the receiver
	to perform any final state changes needed."

	self setEvents: oldMe getEvents!

removeClass: aClass
	"Private - Remove aClass from the receiver. Report an error if there are any subclasses or
	instances of the receiver, or if the class is a standard system class."

	self removeKey: aClass name asSymbol ifAbsent: [].
	aClass removeFromSuper.
	"At this point it would be a good idea to make the class become:
	a special error reporting class"
	self classRemoved: aClass!

removeGlobalNamed: aSymbol
	"Remove the global identified by the <Symbol> argument 
	from this system dictionary."

	^self removeKey: aSymbol!

removeKey: key ifAbsent: exceptionHandler
	"Remove the key (and its associated value), from the receiver. If key is
	not in the receiver, answer the result of evaluating the niladic valuable,
	exceptionHandler. Otherwise, answer the value named by key.
	Implementation Note:  	Override in order to accept Symbols/Strings,
	and to trigger an event so that observers know that the global has been
	removed. Also #unitialize it if it directly implements #uninitialize and
	is not a class (or alias for a class)."

	| index element globalName |
	globalName := key asSymbol.
	index := self findKeyOrNil: globalName.
	^(element := self basicAt: index) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: 
			[| global isClass |
			self removeIndex: index.
			global := element value.
			isClass := global class isMeta.
			(isClass not or: [global name ~~ globalName]) 
				ifTrue: 
					[self trigger: #globalRemoved: with: element.
					"Uninitialize any global which is not a class name alias"
					(isClass not and: [global respondsTo: #uninitialize]) ifTrue: [global uninitialize]].
			global]!

renameGlobal: oldName to: newName
	"Rename the global, informing the system of the change."

	| oldSymbol binding |
	oldSymbol := oldName asSymbol.
	self noEventsDo: [binding := self changeKey: oldSymbol to: newName asSymbol].
	self triggerGlobalRenamed: binding from: oldSymbol!

setEvents: anEventsCollectionOrNil
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	events := anEventsCollectionOrNil!

triggerGlobalRenamed: anAssociation from: oldSymbol
	"Private - Inform observers that a  system global object has been renamed."

	self 
		trigger: #globalRenamed:from:
		with: anAssociation
		with: oldSymbol! !

IdentityDictionary comment:
'IdentityDictionaries are <LookupTable>s which use identity (#== and #identityHash) for key comparison.

IdentityDictionary conforms to the following ANSI protocols:
	Object
	collection
	abstractDictionary
	IdentityDictionary'!
!IdentityDictionary methodsFor!

findKeyOrNil: anObject 
	"Private - Answer the index of the given key in the receiver, or, if not found,
	the index of the first empty slot including and after that to which 
	the key hashes."

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| key |
	(key := self basicAt: index) isNil or: [key == anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]!

keysClass
	"Answer the class of <collection> to be used for collecting the keys of the receiver"
	
	^IdentitySet!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^SearchPolicy identity! !

PluggableLookupTable comment:
'PluggableLookupTable is the class of <LookupTable>s which support a pluggable <searchPolicy>, and which can thus be configured to behave in the same way as either standard <LookupTable>s (equality search) or <IdentityDictionary>s (identity search), or indeed any user-defined search policy.

Instance Variables:
	searchPolicy		<searchPolicy>. The policy used to hash and compare elements of the receiver.

'!
!PluggableLookupTable class methodsFor!

defaultSearchPolicy
	"Answer the default <searchPolicy> used by instances of the receiver."

	^SearchPolicy equality!

new: anInteger searchPolicy: aSearchPolicy
	"Answer a new instance of the receiver with an initial capacity of at least 
	<integer> count elements (i.e. the size is a hint), and with the specified <searchPolicy>."

	^(self new: anInteger) setSearchPolicy: aSearchPolicy!

searchPolicy: policy
	"Answer a new, empty, instance of the receiver with the specified <searchPolicy>."

	^self new setSearchPolicy: policy! !

!PluggableLookupTable methodsFor!

copyEmpty: anInteger
	"Private - Answer an empty copy of the receiver, with enough space for anInteger
	number of elements. 
	Implementation Note: We must override in order to preserve the searchPolicy."

	^(super copyEmpty: anInteger) setSearchPolicy: self searchPolicy!

findKeyOrNil: anObject 
	"Private - Answer the <integer> index of the given key in the receiver, or, if not found,
	the index of the first empty slot including and after that to which 
	the key hashes. A pluggable <searchPolicy> is used for key comparisons and hashing."

	| capacity index |
	capacity := self basicSize.
	index := self searchPolicy hash: anObject max: capacity.
	
	[| key |
	(key := self basicAt: index) isNil or: [self searchPolicy compare: key with: anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^self searchPolicy hash: anObject max: anInteger!

initialize
	"Private - Instance variable initialization. The tally records the number of elements."

	super initialize.
	self setSearchPolicy: self class defaultSearchPolicy
!

newSelection
	"Private - Answer a new empty collection like the receiver to 
	contain a selection of the receiver's elements."

	^self class searchPolicy: self searchPolicy!

preResize: newMe
	"This message is sent by the receiver when resizing, before the
	receiver's elements are added to newMe. We must assign across the
	search policy."

	newMe setSearchPolicy: self searchPolicy!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^searchPolicy!

searchPolicy: aSearchPolicy 
	"Set the receiver's <searchPolicy>."

	self setSearchPolicy: aSearchPolicy.
	self notEmpty ifTrue: [self rehash]!

setSearchPolicy: policy
	"Private - Set the receiver's <searchPolicy>. Answer the receiver."

	searchPolicy := policy.
	^self!

species
	"Answer the class of object to be used when copying the receiver with #collect:, etc."

	^LookupTable
! !

PoolConstantsDictionary comment:
''!
!PoolConstantsDictionary class methodsFor!

named: aSymbol 
	^(self new)
		name: aSymbol;
		yourself!

uninitialize
	VMLibrary default registryAt: self name put: nil! !

!PoolConstantsDictionary methodsFor!

associationClass
	"Private - Answer the class of association to be used for holding
	key-value pairs in the receiver. Must respond to the Association protocol."
	
	^VariableBinding!

at: key ifAbsentPut: operation 
	"Answer the value of the receiver keyed by the <Object> argument, key.
	If key is not one of the receiver's keys, then add the result of evaluating 
	the <niladicValuable>, operation, at key, and answer that result."

	^super at: key asString
		ifAbsentPut: 
			[self isChanged: true.
			operation value]!

at: key put: anObject 
	"Store the argument anObject with the external key, aKey,
	in the receiver. Answer anObject. Ensure the key is a String.
	If the key already exists in the receiver, raise an exception
	because the receiver is supposed to contain constants."

	| value keyString |
	keyString := self keyString: key.
	value := self at: keyString
				ifAbsent: 
					["New element added"
					self isChanged: true.
					^super at: keyString put: anObject].
	^value = anObject 
		ifTrue: [anObject	"No attempt was made to change the value"]
		ifFalse: [self errorModify: keyString value: anObject]!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

classesReferencing
	^self environment allClasses select: [:c | c allSharedPools includes: self]!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	self name displayOn: aStream
!

environment
	"Answer the receiver's controlling name space."

	^Smalltalk
!

errorModify: key value: value 
	"Private - An attempt was made to modify the value of the constant named, key."

	MessageBox 
		confirm: ('Would you like to recompile references to <1p><n>to reflect the new value <2d> (currently <3d>)' 
				expandMacrosWith: key
				with: value
				with: (self at: key))
		onYes: 
			[super at: key put: value.
			self recompileReferencesTo: key.
			self isChanged: true]
		onNo: [super at: key put: value]
		onCancel: 
			["Ignore the modification request"
			]!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutName
	"Answer the receiver's default file name for file outs (<name>.st)."

	| path package |
	path := File composeStem: self name extension: Package sourceGlobalExtension.
	package := Package manager packageOfGlobalNamed: self name asSymbol.
	package notNil ifTrue: [
		path := File replacePath:  path with: package path ].
	^path!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self!

findKeyOrNil: anObject 
	"Private - Answer the index of the given key in the receiver, or, if not found,
	the index of the first empty slot including and after that to which 
	the key hashes."

	"Implementation Note: By overriding this to convert the key to a string we
	can avoid the need to override all the key lookup methods such as #at:ifAbsent:,
	#includesKey:, etc ."

	^super findKeyOrNil: anObject asString!

isChanged
	"Answer true if the receiver or any of it's contents have been changed since
	their changed flag was last reset."

	^self propertyAt: #isChanged ifAbsent: [false]!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	"Note that we don't test the existing value of the change flag here, because
	 we want to inform the package regardless (in case it isn't currently changed
	 for some reason)"
	aBoolean 
		ifTrue: [ | package |
			self propertyAt: #isChanged put: true.
			(package := self owningPackage) notNil ifTrue: [
				package isChanged: true]]
		ifFalse: [self removePropertyAt: #isChanged ifAbsent: []]!

isValidKey: aString 
	| initial |
	initial := true.
	^aString allSatisfy: 
			[:each | 
			initial 
				ifTrue: 
					[initial := false.
					each == $_ or: [each isLetter]]
				ifFalse: [each == $_ or: [each isAlphaNumeric]]]!

keyString: anObject 
	| answer |
	answer := anObject asString.
	(self isValidKey: answer) ifFalse: [^self error: 'Invalid key: ' , answer].
	^answer!

name
	"Answer the receiver's name."

	^name ifNil: [self environment keyAtValue: self ifAbsent: ['Anon']]!

name: aSymbol 
	name := aSymbol asSymbol!

newAssociation: keyObject value: valueObject 
	^(super newAssociation: keyObject value: valueObject)
		isImmutable: true;
		yourself!

owningPackage
	"Answers the package that owns the receiver or nil if it is not yet owned
	by any package"

	^Package manager packageOfGlobalNamed: self name!

owningPackage: aPackage
	"Set the receiver's <Package> to be the argument. Any current package association is lost."

	aPackage addGlobalNamed: self name!

preResize: newMe 
	"Private - This message is sent by the receiver when resizing, before the
	receiver's elements are added to newMe. We must assign across the
	search policy."

	name isNil ifFalse: [newMe name: name]!

recompileReferencesTo: keyString 
	"Private - Recompile any methods which references the named key, assumed to
	be a variable name from the receiver."

	Notification 
		signal: ('Recompiling references to <1p> in <2s>' expandMacrosWith: keyString with: self name).
	(self environment allClasses select: [:c | c allSharedPools includes: self]) do: 
			[:c | 
			self
				recompileReferencesTo: keyString in: c;
				recompileReferencesTo: keyString in: c class]!

recompileReferencesTo: keyString in: aBehavior
	"Private - Recompile any methods which references the named key, assumed to
	be a variable name from the receiver, in the specified Behavior's method dictionary."

	aBehavior methodDictionary do: [:m | 
		(m containsSource: keyString) ifTrue: [
			Notification signal: 'Recompiling ', m printString.
			m recompile]]
!

referencesTo: keyString 
	"Answer the collection of any methods which references the named key, assumed to
	be a variable name from the receiver."

	| refs |
	refs := OrderedCollection new.
	self classesReferencing do: 
			[:c | 
			c methodDictionary do: [:m | (m containsSource: keyString) ifTrue: [refs add: m]].
			c class methodDictionary do: [:m | (m containsSource: keyString) ifTrue: [refs add: m]]].
	^refs!

removeIndex: anInteger
	"Private - Remove the element at index, anInteger, in the receiver. Does not
	check that the element is empty."

	super removeIndex: anInteger.
	self isChanged: true! !

SharedLookupTable comment:
'SharedLookupTable is the class of <LookupTable>s which permits only a single process to access its contents at any one time (it uses a <Mutex> object for this purpose). 

Instance Variables:
	mutex			<Mutex>. Protection lock to guard contents.

Class Variables:
	AbsentCookie		<Object>. Used to identity evaluation of exception handling block.

Certain methods are not overridden for the following reasons:

	add:			Immediate superclass implementation use #at:put:
	associationAt:		Implemented in terms of #assocationAt:ifAbsent:
	associationAt:ifAbsent:	Implemented in terms of #at:ifAbsent:
	associations		Implemented in terms of associationsDo:
	associationsDo:		Implemented in terms of keysAndValuesDo:
	at:			Implemented in terms of #at:ifAbsent:
	at:ifAbsent:		Overridden
	at:ifAbsentPut:		Overridden
	at:put:			ditto
	basicValues		atomic
	capacity			atomic
	collect:			Implemented in terms of #do:, result will be a LookupTable
	copyElementsInto:		private, uses only within critical sections
	copyEmpty		Implemented in terms of #copyEmpty:
	copyEmpty:		Private, used only within critical sections
	countElements		Implemented in terms of #do:
	detect:			Implemented in terms of #detect:ifNone:
	detect:ifNone:		Implemented in terms of #do:
	do:			Overridden, public entry point. Revokes weak status for duration of enumeration.
	emptyCheck		implemented in terms of #isEmpty
	errorNotFound, errorNotKeyed 	Don''t access shared data apart from print (uses do:)
	findElementOrNil:		private, used only within methods protected by mutex (e.g. add:)
	findKeyOrNil:		ditto
	fixCollisionsFrom: 		ditto
	grow			ditto (sent only from Set>>privateAt:put:)
	growSize			Private, used only within critical section (not used for Set''s?)
	identityIncludes:		Overridden
	includes:			Implemented in terms of #do:
	includesAssociation:		Overridden
	includesKey:		Overridden
	initialize			Overridden, but to instantiate the mutex, not for mutual exclusion
	inject:into:			Implemented in terms of do:
	inspect			Debug only
	intersection:		Implemented in terms of select:
	isEmpty			uses #size == 0, which is atomic
	keyAtEqualValue:ifAbsent:	Overridden
	keyAtValue:		Implemented in terms of keyAtValue:ifAbsent:
	keyAtValue:ifAbsent:		Overridden
	keysAndValuesDo:		Overridden. Revokes weak status for duration of enumeration.
	keysClass			Answers constant
	keys			Implemented in terms of #do:
	keysDo:			Implemented in terms of #keysAndValuesDo:
	lookupKey:		For private use of compiler
	maxPrint			Atomic
	moveFrom:to:		Private, used only within critical sections
	occurrencesOf:		Implemented in terms of #do
	printOn:			Overridden
	postResize:		private, used only within methods protected by mutex
	preResize:			ditto, but must override to maintain mutex
	privateAt:put:		private, used only within critical sections
	rehash			uses #resize:, and otherwise accesses no shared data
	reject:			Implemented in terms of #select:
	relocateElement:from:	private, used only within methods protected by mutex
	remove:			Not valid for dictionaries
	remove:ifAbsent:		ditto
	removeAssociation:		Implemented in terms of removeKey:
	removeIndex:		private, used only within methods protected by mutex
	removeKey:		Implemented in terms of removeKey:ifAbsent:
	removeKey:ifAbsent:		Overridden
	resize:			Overridden, public entry point
	shrink			Overridden, public entry point
	select:			Implemented in terms of keysAndValuesDo:
	size			atomic
	storeOn:			Overridden
	tally			atomic
	uncheckedAdd:		Not used by dictionaries.
	uncheckedAt:put:		Private, used only within critical sections
	values			Implemented in terms of #do:
	valuesClass	`	Answers constant'!
!SharedLookupTable methodsFor!

asArray
	"Answer an Array whose elements are those of the receiver (ordering is possibly arbitrary).
	Must implement as critical section as otherwise Array size might be wrong."

	^mutex critical: [super asArray]!

asByteArray
	"Answer a ByteArray whose elements are those of the receiver (ordering is possibly arbitrary).
	Must implement as critical section as otherwise the ByteArray size might be wrong."

	^mutex critical: [super asByteArray]!

at: key ifAbsent: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler.
	Implementation Note: We avoid evaluating the exceptionHandler valuable
	inside the mutex to minimize the chances of throwing an exception
	with the mutex locked (#critical:'s ensure block would handle the case
	where the exceptionHandler performs a far return), HOWEVER this does
	mean it is not entirely safe to add a new item in the ifAbsent handler
	(#at:ifAbsentPut: should be used in this case)."

	| answer |
	answer := mutex critical: [super at: key ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

at: key ifAbsentPut: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	then add and answer the result of evaluating the niladic valuable,
	exceptionHandler.
	Implementation Note: If exceptionHandler is a block, it should not include 
	an explicit return (if it does then no value will be inserted).
	Note also that in this case we evaluate the exception handler within
	the mutex so that the particular key remains absent!!"

	^mutex critical: [super at: key ifAbsentPut: exceptionHandler]!

at: key put: newElement
	"Store the argument, newElement, with the external key, key,
	in the receiver. Answer newElement."

	key isNil ifTrue: [^self error: 'key cannot be nil'].
	^mutex critical: [super at: key put: newElement]!

changeKey: key to: newKey
	"Private - Change the key of the element of the receiver with key, key, to
	newKey (e.g. rename a variable). Answer the value of the element
	whose key was changed"

	^mutex critical: [super changeKey: key to: newKey]!

do: operation
	"Evaluate monadic value argument, operation, for each of the elements (values) of the 
	receiver. Answers the receiver.
	If aBlock contains an explicit return, then the mutex will be unlocked by the #ensure:
	block in #critical:."

	mutex critical: [super do: operation]
!

identityIncludes: comperand
	"Answer whether the <Object> argument, comperand, is one of the receiver's elements."

	^mutex critical: [super identityIncludes: comperand]!

includesAssociation: anAssociation
	"Answer whether the receiver contains the key/value pair in anAssociation"

	^mutex critical: [super includesAssociation: anAssociation]!

includesKey: key
	"Answer whether the receiver contains the specified key."

	^mutex critical: [super includesKey: key]!

initialize
	"Private - Initialize the state of the receiver."

	mutex := Mutex new.
	super initialize.!

keyAtEqualValue: value ifAbsent: exceptionHandler
	"Answer the name of the argument, value. If there is no such value, answer
	the result of evaluating the niladic valuable, exceptionHandler.
	Equality is used for comparison of the values (this increases the chances of 
	returning any duplicates the Dictionary might contain).
	Implementation Note: We avoid evaluating the exceptionHandler valuable
	inside the mutex to minimize the chances of throwing an exception
	with the mutex locked (#critical:'s ensure block would handle the case
	where the exceptionHandler performs a far return)."

	| answer |
	answer := mutex critical: [super keyAtEqualValue: value ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

keyAtValue: value ifAbsent: exceptionHandler
	"Answer the key of the first value in the receiver identical
	to the argument, value. If the receiver contains no such element,
	answer the result of evaluating the monadic valuable, exceptionHandler.
	Implementation Note: We avoid evaluating the exceptionHandler valuable
	inside the mutex to minimize the chances of throwing an exception
	with the mutex locked (#critical:'s ensure block would handle the case
	where the exceptionHandler performs a far return)."

	| answer |
	answer := mutex critical: [super keyAtValue: value ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

keysAndValuesDo: operation
	"Evaluate the dyadic valuable, operation, for each key/value pair in the receiver,
	to the exclusion of other threads."

	mutex critical: [super keysAndValuesDo: operation]!

keysDo: operation 
	"Evaluate the <monadicValuable>, operation, for each of the receiver's keys, to the exclusion of other threads."

	mutex critical: [super keysDo: operation]!

mutex
	"Private - Answer the receiver's mutual exclusion object"

	^mutex!

mutex: aMutex
	"Private - Set the receiver's mutual exclusion object to the argument, aMutex"

	mutex := aMutex !

postCopy
	"Apply any final flourish to the copy that may be required in order to ensure that the copy
	does not share any state with the original, apart from the elements. Answer the receiver. In
	the case of a SharedLookupTable we need a new mutex."

	super postCopy.
	mutex := Mutex new.
	^self!

preResize: newMe
	"This message is sent by the receiver when resizing, before the
	receiver's elements are added to newMe. We must assign across the
	mutex so that process synchronisation is correctly preserved."

	newMe mutex: mutex!

printOn: aStream
	"Print a string representation of self on aStream."

	mutex critical: [super printOn: aStream]!

removeKey: key ifAbsent: exceptionHandler
	"Remove the key (and its associated value), from the receiver. If key is
	not in the receiver, answer the result of evaluating the niladic valuable
	exceptionHandler. Otherwise, answer the value named by key.
	Implementation Note: Avoid evaluating the exceptionHandler valuable
	inside the mutex to minimize the chances of throwing an exception
	with the mutex locked (#critical:'s ensure block would handle the case
	where the exceptionHandler performs a far return)."

	| answer |
	answer:= mutex critical: [super removeKey: key ifAbsent: [AbsentCookie]].
	^answer == AbsentCookie
		ifTrue: [exceptionHandler value]
		ifFalse: [answer]!

resize: anInteger
	"Private - Resize the receiver to a capacity suitable for anInteger elements.
	We'll lose the mutex since this involves creating a new copy of the receiver
	and becoming it. Obviously we must restore the current mutex, or process
	synchronisation will be lost."

	mutex critical: [super resize: anInteger]!

shrink
	"Rebuild the collection with the optimal size for its current number of elements,
	as #rehash, but doesn't resize if already correct size."

	mutex critical: [super shrink]!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler."

	mutex critical: [super stbSaveOn: anSTBOutFiler]! !

MethodDictionary comment:
'MethodDictionary is a specialized form of <IdentityDictionary> designed for ease and speed of access by the execution machinery. As the name implies, method dictionaries are used to map method selectors to the corresponding compiled method in a particular class.

The primary difference from an ordinary identity dictionary in the current implementation is that method dictionaries are a power of 2 in size to speed up the masking of hash values to the permissible range during method lookup.

You should not rely on the implementation details of this class, and nor should you change them or the instance shape.'!
!MethodDictionary class methodsFor!

sizeFor: capacity
	"Answer the <integer> size of collection that should be created to hold 
	the number of elements specified by the <integer> argument, capacity.
	Implementation Note: Round up to the nearest 	power of 2, as required 
	by the VM, and avoid any dependency on the superclass sizing scheme."

	^capacity < 2
		ifTrue: [2]
		ifFalse: [1 bitShift: (((capacity - 1 * 100 // 75)+1) highBit)]! !

!MethodDictionary methodsFor!

hash: anObject max: anInteger
	"Implementation Note: This must match the selector hashing implementation used by the VM."

	^(anObject hash bitAnd: anInteger - 1) + 1!

removeKey: key ifAbsent: exceptionHandler 
	"Remove the key (and its associated value), from the receiver. If key is not in the 
	receiver, answer the result of evaluating the niladic valuable, exceptionHandler.
	Otherwise, answer the value named by key.
	Implementation Note: Override to perform the update in a copy which is then
	swapped with the receiver. This is to avoid any problems with removing methods
	from the Dictionary hierarchy causing the method dictionaries of these classes
	to become temporarily invalid."

	| index |
	index := self findKeyOrNil: key.
	^(self basicAt: index) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: 
			[| newMe value |
			value := values basicAt: index.
			newMe := self copy.
			newMe basicValues basicAt: index put: nil.
			newMe removeIndex: index.
			self become: newMe.
			value]! !

DeferredValueTable comment:
'A DeferredValueTable is a <LookupTable> specialised to hold <DeferredValue>s. '!
!DeferredValueTable methodsFor!

at: key ifAbsent: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	answer the result of evaluating the niladic valuable, exceptionHandler."

	^(super at: key ifAbsent: [exceptionHandler]) value!

at: key ifAbsentPut: exceptionHandler
	"Answer the value named by the argument, key.  If key is not found,
	then add and answer the result of evaluating the niladic valuable,
	exceptionHandler."

	^(super at: key ifAbsentPut: [exceptionHandler deferredValueAt: priority]) value!

at: anObject put: aNiladicValuable 
	"Store the <niladicValuable> argument under the specified <Object> key
	in the receiver. The <niladicValuable> is expected to evaluate to the 
	eventual required value. Answer the <DeferredValue>."

	^super at: anObject put: (aNiladicValuable deferredValueAt: priority)!

do: operation
	"Evaluate monadic value argument, operation, for each of the elements (values) of the 
	receiver. Answers the receiver."

	#todo "Provide more efficient implementation".
	super keysAndValuesDo: [:k :v | operation value: v value]!

initialize
	"Private - Initialize the state of the receiver."

	super initialize.
	priority := Processor activePriority!

keyAtEqualValue: value ifAbsent: exceptionHandler
	"Answer the name of the argument, value. If there is no such value, answer
	the result of evaluating the niladic valuable, exceptionHandler.
	Equality is used for comparison of the values (this increases the chances of 
	returning any duplicates the Dictionary might contain).
	Implementation Note: Optimized superclass implementation must be overridden
	back to one implemented in terms of keysAndValuesDo:"

	self keysAndValuesDo: [:k :v | value = v value ifTrue: [^k]].
	^exceptionHandler value!

keyAtValue: value ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value. 
	If there is no such value, answer the result of evaluating the 
	<niladicValuable>, operation. Identity is used for comparison of the values."

	self keysAndValuesDo: [:k :v | v value == value ifTrue: [^k]].
	^operation value!

keysAndValuesDo: operation
	"Evaluate the dyadic valuable, operation, for each key/value pair in the receiver,
	to the exclusion of other threads."

	super keysAndValuesDo: [:k :v | operation value: k value: v value]!

priority
	"Answer the <Process> priority at which the deferred values will be calculated."

	^priority!

priority: anInteger
	"Set the <Process> priority at which the deferred values will be calculated."

	priority := anInteger! !

SharedIdentityDictionary comment:
''!
!SharedIdentityDictionary methodsFor!

findKeyOrNil: anObject 
	"Private - This method is a copy of IdentityDictionary>>findKeyOrNil:"

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| key |
	(key := self basicAt: index) isNil or: [key == anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]!

keysClass
	"Answer the class of Collection to be used for collecting the keys of the receiver"
	
	^IdentitySet!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^SearchPolicy identity! !

WeakLookupTable comment:
''!
!WeakLookupTable class methodsFor!

initialize
	"Initialize the receiver.
	The receiver's instances need bereavement notifications to repair themselves."

	self makeMourner!

new: anInteger
	"Answer a new instance of the receiver sufficient capacity for anInteger elements. Both keys and values
	can be weakly referenced. By default instances of the receiver have strong key and weak value references."

	^self newWithWeakValues: anInteger!

newWithWeakKeys: anInteger
	"Answer a new instance of the receiver sufficient capacity for anInteger elements. The keys are weakly
	referenced, but the values have normal strong references. This can be changed later by sending the instance
	a message."

	^(super new: anInteger)
		haveWeakKeys;
		haveStrongValues;
		yourself
!

newWithWeakValues: anInteger
	"Answer a new instance of the receiver sufficient capacity for anInteger elements. The values are weakly
	referenced, but the keys have normal strong references. This can be changed later by sending the instance
	a message."

	^super new: anInteger
! !

!WeakLookupTable methodsFor!

copyEmpty: anInteger
	"Private - Answer an empty copy of the receiver, with enough space for anInteger
	number of elements. 
	Implementation Note: We must override in order to copy the weak/strong state of 
	the receiver and its values."

	| answer |
	answer := super copyEmpty: anInteger.
	answer setSpecialBehavior: self getSpecialBehavior.
	answer basicValues setSpecialBehavior: self basicValues getSpecialBehavior.
	^answer!

do: operation
	"Evaluate monadic value argument, operation, for each of the elements (values) of the 
	receiver. Answers the receiver.
	Implementation Note: Override in order to revoke the weak status of the receiver	
	for the duration of the enumeration."

	mutex critical: [ | keysMask valuesMask |
		keysMask := self beStrong.
		valuesMask := self basicValues beStrong.
		[super do: operation]
			ensure: [
				self setSpecialBehavior: keysMask.
				self basicValues setSpecialBehavior: valuesMask]]!

elementsExpired: losses 
	"Private - Handle the loss of <integer>, losses, keys from the receiver. We must repair the hash 
	table to maintain the set invariants, and we also nil out the corresponding values to allow them 
	to expire if they've no other references. Similar to WeakSet>>elementsExpired:.
	N.B. It is possible for the receiver to lose values AND keys during the same finalization cycle. It 
	is even possible that the key corresponding to a value may be lost at the same time as that 
	value. This means we cannot rely on the argument telling us the correct number of losses, since 
	some of these may overlap with value losses (which might already have been dealt with)."

	mutex critical: 
			[| deathAt capacity corpse |
			corpse := DeadObject current.
			capacity := self basicSize.
			deathAt := self 
						basicIdentityIndexOf: corpse
						from: 1
						to: capacity.
			losses > (self size // 4) 
				ifTrue: 
					["Rehash the collection if a large number of losses (don't need to nil values)..."

					[deathAt > 0] whileTrue: 
							[tally := tally - 1.
							self basicAt: deathAt put: nil.
							deathAt := self 
										basicIdentityIndexOf: corpse
										from: deathAt + 1
										to: capacity].
					self rehash]
				ifFalse: 
					["... otherwise remove the losses individually"

					[deathAt > 0] whileTrue: 
							[tally := tally - 1.
							self basicAt: deathAt put: nil.
							values basicAt: deathAt put: nil.	"nil the corresponding value too"
							self fixCollisionsIgnoringCorpsesFrom: deathAt.
							deathAt := self 
										basicIdentityIndexOf: corpse
										from: deathAt + 1
										to: capacity]]]!

elementsExpired: losses of: aWeakArray 
	"Private - Handle the loss of <integer>, losses, values from the receiver (values are stored 
	externally). We must remove the corresponding keys and repair the hash table to maintain the 
	set invariants. Similar to WeakSet>>elementsExpired:.
	N.B. It is possible for the receiver to lose values AND keys during the same finalization cycle, so 
	aWeakArray may no longer be the receiver's value array (if the #elementsExpired: message 
	informing of the loss of keys was received first). It is even possible that the key corresponding to 
	a value may be lost at the same time as that value. This means we cannot rely on either 
	argument to be terribly useful."

	mutex critical: 
			[losses > (self size // 4) 
				ifTrue: 
					["Rehash the collection if a large number of losses (don't need to nil values)..."

					self basicValues nilCorpsesAndDo: 
							[:deathAt | 
							tally := tally - 1.
							self basicAt: deathAt put: nil].
					self rehash]
				ifFalse: 
					["... otherwise remove the losses individually"

					self basicValues nilCorpsesAndDo: 
							[:deathAt | 
							tally := tally - 1.
							self basicAt: deathAt put: nil.
							self fixCollisionsIgnoringCorpsesFrom: deathAt]]]!

fixCollisionsIgnoringCorpsesFrom: index 
	"Private - Rehashes objects in the collection after index to see if any of
	them hash to index.  If so, that object is copied to index, and the
	process repeats with that object's index, until a nil is encountered.
	Corpse objects are not relocated, on the assumption that these will
	be nilled and fixed up later themselves."

	| slotIndex capacity element corpse |
	slotIndex := index.
	capacity := self basicSize.
	corpse := DeadObject current.
	
	[slotIndex := slotIndex \\ capacity + 1.
	(element := self basicAt: slotIndex) isNil] 
			whileFalse: 
				[element == corpse 
					ifFalse: 
						[| hashIndex |
						hashIndex := self findElementOrNil: element.
						(self basicAt: hashIndex) isNil ifTrue: [self moveFrom: slotIndex to: hashIndex]]]!

hasWeakKeys
	"Answer whether the receiver has weak references to its keys (the default)."

	^self isWeak!

hasWeakValues
	"Answer whether the receiver has weak references to its values (the default)."

	^self basicValues isWeak!

haveStrongKeys
	"Mark the receiver as having strong references to its keys. Answer the receiver."

	self beStrong!

haveStrongValues
	"Mark the receiver as having strong references to its values. Answer the receiver."

	self basicValues beStrong!

haveWeakKeys
	"Mark the receiver as having weak references to its keys (the default).
	Answer the receiver."

	self beWeak!

haveWeakValues
	"Mark the receiver as having weak references to its values (the default).
	Answer the receiver."

	self basicValues beWeak!

initialize
	"Private - Initialize the receiver's state."

	super initialize.
	self basicValues pathologist: self!

keysAndValuesDo: operation
	"Evaluate the dyadic valuable, operation, for each key/value pair in the receiver,
	to the exclusion of other threads.
	Implementation Note: Override in order to revoke the weak status of the receiver	
	for the duration of the enumeration."

	mutex critical: [ | keysMask valuesMask |
		keysMask := self beStrong.
		valuesMask := self basicValues beStrong.
		[super keysAndValuesDo: operation]
			ensure: [
				self setSpecialBehavior: keysMask.
				self basicValues setSpecialBehavior: valuesMask]]!

keysDo: operation
	"Evaluate the <monadicValuable>, operation, for each of the receiver's keys."

	self keysAndValuesDo: [:key :value | operation value: key]!

postResize: oldMe
	"Private - This message is sent by the receiver when resizing, after the receiver's elements have 
	been added to a new Collection and the receiver has become that collection. It is a chance for the 
	receiver to perform any final state changes needed. In this case we must ensure that the new value
	array has the correct pathologist - because of the use of a two way become:, it would otherwise keep
	the oldMe as it's pathologist."

	self basicValues pathologist: self!

species
	"Answer the class of object to be used when copying the receiver. There isn't much
	point answering a weak collection, as elements may expire after selection/collection, etc, 
	which is less than useful."

	^LookupTable!

valuesClass
	"Answer the class of Collection to use to hold the values of the receiver's elements
	(N.B. This is a different concept from #keysClass, which is used for copying the keys of 
	the receiver). For a WeakIdentityDictionary we always use a MourningWeakArray to hold the values,
	but we may turn off its weakness if the dictionary only has weak values. The MourningWeakArray
	is configured to inform the receiver when it suffers losses."

	^MourningWeakArray! !

EventsCollection comment:
''!
!EventsCollection methodsFor!

addEvent: aSymbol action: aValuable 
	"Private - Adds the <valuable> argument as the action for 
	aSymbol, but only if it is not already present."

	mutex critical: 
			[| messages |
			messages := self at: aSymbol ifAbsent: [EventMessageSequence new].
			"Check for existing registration"
			(messages includes: aValuable) 
				ifFalse: 
					[messages add: aValuable.
					self at: aSymbol put: messages]]!

asMinimumRepresentation
	"Private - Answers nil if the receiver is empty, otherwise self."

	^self notEmpty ifTrue: [self]!

hasActionsForEvent: aSymbol 
	^mutex critical: [(self at: aSymbol ifAbsent: [#()]) notEmpty]!

removeActionsForEvent: aSymbol 
	^mutex critical: [self removeKey: aSymbol ifAbsent: []]!

removeEventsTriggeredFor: anObject 
	"Private - Removes all events where the target is anObject. If the receiver becomes empty,
	answers nil, otherwise answers self."

	^mutex critical: 
			[| empty |
			empty := IdentitySet new.
			self keysAndValuesDo: 
					[:eachKey :eachValue | 
					eachValue isNil 
						ifFalse: 
							[eachValue removeMessagesFor: anObject.
							eachValue isEmpty ifTrue: [empty add: eachKey]]].
			self removeAllKeys: empty.
			self asMinimumRepresentation]!

shrink
	"Private - Removes all empty message sequences."

	mutex critical: 
			[| empty |
			empty := IdentitySet new.
			self 
				keysAndValuesDo: [:eachKey :eachValue | (eachValue isNil or: [eachValue isEmpty]) ifTrue: [empty add: eachKey]].
			self removeAllKeys: empty]!

triggerEvent: anEventSymbol
	"Private - Evaluate the sequence of MessageSends registered for the event, 
	anEventSymbol.  Answer the result of the last evaluation, or nil if none."

	^(self at: anEventSymbol ifAbsent: [[]]) value
!

triggerEvent: aSymbol with: anObject 
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with a single argument, anObject..
	 Answer the result of the last evaluation, or nil if none."

	^(self at: aSymbol ifAbsent: [[:arg | nil]]) valueWithArguments: (Array with: anObject)!

triggerEvent: aSymbol with: anObject with: anotherObject 
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with the pair of arguments, anObject, and, anotherObject.
	 Answer the result of the last evaluation, or nil if none."

	^(self at: aSymbol ifAbsent: [[:arg1 :arg2 | nil]]) 
		valueWithArguments: (Array with: anObject with: anotherObject)!

triggerEvent: aSymbol withArguments: anArray
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with the <Array> of arguments, anArray.
	with the specified arguments. Answer the result of the last evaluation, or nil if none."

	^(self at: aSymbol ifAbsent: [^nil]) valueWithArguments: anArray! !

NullEventsCollection comment:
'NullEventsCollection is a special events collection used when a receiver has no event subscriptions. Its purpose is to increase performance for this common case.'!
!NullEventsCollection class methodsFor!

current
	^Current!

initialize
	Current := self new! !

!NullEventsCollection methodsFor!

asMinimumRepresentation
	"Private - Answers nil if the receiver is empty, otherwise self."

	^nil!

hasActionsForEvent: aSymbol 
	^false!

initialize
	super initialize.
	"Mark the receiver as read-only, as this avoids the need to override a lot of inherited methods with error traps"
	self isImmutable: true.!

removeActionsForEvent: aSymbol 
	^nil!

removeEventsTriggeredFor: anObject 
	"Private - Removes all events where the target is anObject. If the receiver becomes empty,
	answers nil, otherwise answers self."

	^nil!

shrink
	"Private - Removes all empty message sequences."

	!

triggerEvent: anEventSymbol 
	"Private - Evaluate the sequence of MessageSends registered for the event, 
	anEventSymbol.  Answer the result of the last evaluation, or nil if none."

	^nil!

triggerEvent: aSymbol with: anObject 
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with a single argument, anObject..
	 Answer the result of the last evaluation, or nil if none."

	^nil!

triggerEvent: aSymbol with: anObject with: anotherObject 
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with the pair of arguments, anObject, and, anotherObject.
	 Answer the result of the last evaluation, or nil if none."

	^nil!

triggerEvent: aSymbol withArguments: anArray
	"Private - Evaluate the sequence of MessageSends registered for the event named by
	the <Symbol> argument, with the <Array> of arguments, anArray.
	with the specified arguments. Answer the result of the last evaluation, or nil if none."

	^nil! !

WeakIdentityDictionary comment:
''!
!WeakIdentityDictionary class methodsFor!

initialize
	"Initialize the receiver.
	Class initialize methods are ignored by the SourceManager unless directly implemented
	so we must implement to get the bereavement notifications."

	super initialize!

new: anInteger
	"Answer a new instance of the receiver sufficient capacity for anInteger elements. Both keys and values
	are weakly referenced. By default WeakIdentityDictionaries have both weak key and weak value references."

	^(super new: anInteger)
		haveWeakKeys;
		yourself! !

!WeakIdentityDictionary methodsFor!

findKeyOrNil: anObject 
	"Private - This method is a copy of IdentityDictionary>>findKeyOrNil:"

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| key |
	(key := self basicAt: index) isNil or: [key == anObject]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]!

keysClass
	"Answer the class of Collection to be used for collecting the keys of the receiver"
	
	^IdentitySet!

searchPolicy
	"Answer the receiver's <searchPolicy>."

	^SearchPolicy identity!

species
	"Answer the class of object to be used when copying the receiver. There isn't much
	point answering a weak collection, as elements may expire after selection/collection, etc, 
	which is less than useful."

	^IdentityDictionary! !

SharedIdentitySet comment:
''!
!SharedIdentitySet methodsFor!

findElementOrNil: anObject 
	"Private - This method is a copy of IdentitySet>>findElementOrNil:"

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [anObject == element]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]! !

WeakSet comment:
'A WeakSet is a <Set> which only weakly references the elements that it contains. That is, subject to the <MemoryManager>s intervention, if any of a weak set''s elements have only weak references remaining, then they may be garbage collected, in which case that weak set will receive a bereavement notification, and be given a chance to adjust to it''s loss(es), which it does by nilling out the corpses
and rehashing. Bereavement notification is performed asynchronously by separate (high priority) process, and WeakSet is accordingly a subclass of <SharedSet>.'!
!WeakSet class methodsFor!

initialize
	"Initialize the receiver.
	Bereavement notifications are required by the receiver's instances to
	effect repairs."

	self makeMourner! !

!WeakSet methodsFor!

copyEmpty: anInteger
	"Private - Answer an empty copy of the receiver, with enough space for anInteger
	number of elements. 
	Implementation Note: We must override in order to copy the weak/strong state of 
	the receiver."

	^(super copyEmpty: anInteger)
		setSpecialBehavior: self getSpecialBehavior;
		yourself!

do: operation 
	"Evaluate monadic value argument, operation, for each of the element of the 
	receiver. Answers the receiver.
	Implementation Note: We override this message because if the user supplied operation
	puts the active process to sleep (i.e. wait on some Semaphore) a GC may occur, losses may be 
	suffered, and because the mutex prevents the undertaker from entering the critical section in 
	#elementsExpired: we may subsequently enumerate over Corpses and treat them as elements. 
	In order to guard against this we temporarily revoke the receiver's status as a weak
	object. Note that GC's which nil weak references can only be initiated from idle time, so
	there is no danger of corpses appearing in the receiver if operation does not put the active
	process to sleep."

	mutex critical: 
			[| mask |
			mask := self beStrong.
			[super do: operation] ensure: [self setSpecialBehavior: mask]]!

elementsExpired: anInteger 
	"Private - Handle the bereavement(s) that the receiver suffered by maintaing 
	the <Set> invariants (mainly that collision chains are terminated by nils)."

	mutex critical: 
			[| deathAt capacity corpse |
			corpse := DeadObject current.
			capacity := self basicSize.
			tally := tally - anInteger.
			deathAt := self 
						basicIdentityIndexOf: corpse
						from: 1
						to: capacity.
			anInteger > (self size // 4) 
				ifTrue: 
					["Rehash the collection if a large number of losses..."

					[deathAt > 0] whileTrue: 
							[self basicAt: deathAt put: nil.
							deathAt := self 
										basicIdentityIndexOf: corpse
										from: deathAt + 1
										to: capacity].
					self rehash]
				ifFalse: 
					["... otherwise remove the losses individually"

					[deathAt > 0] whileTrue: 
							[self basicAt: deathAt put: nil.
							self fixCollisionsIgnoringCorpsesFrom: deathAt.
							deathAt := self 
										basicIdentityIndexOf: corpse
										from: deathAt + 1
										to: capacity]]].

	"Inform any dependents"
	self trigger: #elementsExpired: with: anInteger!

fixCollisionsIgnoringCorpsesFrom: index 
	"Private - Rehashes objects in the collection after index to see if any of
	them hash to index.  If so, that object is copied to index, and the
	process repeats with that object's index, until a nil is encountered.
	Corpse objects are not relocated, on the assumption that these will
	be nilled and fixed up later themselves."

	| slotIndex capacity element corpse |
	slotIndex := index.
	capacity := self basicSize.
	corpse := DeadObject current.
	
	[slotIndex := slotIndex \\ capacity + 1.
	(element := self basicAt: slotIndex) isNil] 
			whileFalse: 
				[element == corpse 
					ifFalse: 
						[| hashIndex |
						hashIndex := self findElementOrNil: element.
						(self basicAt: hashIndex) isNil ifTrue: [self moveFrom: slotIndex to: hashIndex]]]!

initialize
	"Private - Instance variable initialization. Ensure the receiver is weak."

	super initialize.
	self beWeak!

species
	"Answer the class of object to be used when copying the receiver. There isn't much
	point answering <WeakSet>, as elements may expire after selection/collection, etc, 
	which is less than useful, so we answer <Set>."

	^Set! !

WeakIdentitySet comment:
''!
!WeakIdentitySet class methodsFor!

initialize
	"Initialize the receiver.
	Class initialize methods are ignored by the SourceManager unless directly implemented
	so we must implement to get the bereavement notifications."

	super initialize! !

!WeakIdentitySet methodsFor!

findElementOrNil: anObject 
	"Private - This method is a copy of IdentitySet>>findElementOrNil:"

	| capacity index |
	capacity := self basicSize.
	index := self hash: anObject max: capacity.
	
	[| element |
	(element := self basicAt: index) isNil or: [anObject == element]] 
			whileFalse: [index := index \\ capacity + 1].
	^index!

hash: anObject max: anInteger
	^anInteger < 8192 
		ifTrue: [anObject identityHash \\ anInteger + 1]
		ifFalse: [anObject identityHash * (anInteger bitShift: -12) \\ anInteger + 1]! !

CompiledExpression comment:
'CompiledExpression is the class of CompiledCode objects representing unbound compiled expressions, i.e. compiled code resulting from the compilation of arbitrary code segments, rather than actual methods of objects (see also CompiledMethod).

'!
!CompiledExpression methodsFor!

evaluate: aString for: anObject evaluationPools: anArrayOfPools
	"Evaluate the receiver (whose source is aString), with the receiver, anObject, 
	within the additional compilation context, anArrayOfPools.
	N.B. This message is sent by the compiler to evaluate constant expressions
	DO NOT REMOVE IT."

	self storeSourceString: aString evaluationPools: anArrayOfPools logged: false.
	^self value: anObject!

evaluationPools
	"Answer the evaluation pools used to compiler the receiver, or nil if none."

	| descrip |
	descrip := self sourceDescriptor.
	^descrip isString ifFalse: [descrip at: 2]!

getDebugInfo
	"Private - Invoke the compiler to answer a compilation result containing a 
	recompilation of the receiver, a map between IP ranges and expressions 
	in the source, and a map between IP ranges 	and an OrderedCollection of 
	Associations between IP positions and temporaries up to that position in 
	the receiver, ordered by IP."

	^self compilerClass 
		debugInfoForExpression: self getSource 
		in: self methodClass
		evaluationPools: self evaluationPools
		debug: self isDebugMethod!

getSource
	"Answer the source of the receiver."

	| descrip |
	descrip := self sourceDescriptor.
	^descrip isString ifTrue: [descrip] ifFalse: [descrip at: 1]!

isExpression
	"Private - Answer whether the receiver is a standalone (unbound) expression as opposed to 
	a method."

	^true!

owningPackage
	^self methodClass owningPackage!

storeSourceString: aString evaluationPools: anArray logged: aBoolean 
	"Private - Ask the receiver's source manager to record its expression 
	source, aString, logging the evaluation to the change log if requested."

	| pools |
	aBoolean ifTrue: [self class sourceManager logEvaluate: aString].
	pools := anArray notNil 
				ifTrue: 
					[| nonEmptyPools |
					nonEmptyPools := anArray reject: [:each | each isEmpty].
					nonEmptyPools notEmpty ifTrue: [nonEmptyPools]].
	self 
		sourceDescriptor: (pools isNil ifTrue: [aString] ifFalse: [Array with: aString with: pools])!

value: anObject
	"Evaluate the receiver with the argument, anObject, 
	as its receiver, answering the result."

	^self value: anObject withArguments: #()! !

CompiledMethod comment:
'CompiledMethod is the class of CompiledCode objects representing actual methods of objects, as opposed to unbound expressions (see CompiledExpression).

'!
!CompiledMethod class methodsFor!

defaultSortBlock
	"Private - Answer a dyadic valuable (sort block) suitable for comparing two instances
	of the receiver"

	^[:x :y | (x methodClass==y methodClass)
		ifTrue: [x selector <= y selector]
		ifFalse: [x methodClass <= y methodClass]] !

fromString: aString
	"Answers the CompiledMethod identified by aString or nil if none is found."

	| className selector stream theClass isMeta |
	stream := aString readStream.
	className := stream upToAll: '>>'.
	stream atEnd ifTrue: [^nil].
	(isMeta := className endsWith: ' class') 
		ifTrue: [className := className allButLast: ' class' size].
	theClass := self environment at: className ifAbsent: [^nil].
	isMeta ifTrue: [theClass := theClass class].
	selector := stream upToEnd asSymbol.
	^theClass compiledMethodAt: selector ifAbsent: []!

icon
	"Answer an Icon representing the receiver."

	^##(self) defaultIcon! !

!CompiledMethod methodsFor!

categories
	"Answer a <Collection> of all the method categories in which the receiver is
	included."

	^self methodClass categoriesOfMethod: self!

categories: categories
	"Private - Set the categories of the receiver to the <Collection> of
	<methodCategory>s, categories. Remove the receiver from any method 
	categories it is currently associated with. If the set of method categories
	has changed, then triggers a #methodCategorized: event.
	Implementation Note: The receiver has no knowledge of categories, so fires
	this request straight off to the category system."

	(self methodClass methodCategoryClass setMethod: self categories: categories) 
		ifTrue: [self methodClass environment trigger: #methodCategorized: with: self]!

changeManager
	"Private - Answer the receiver's change manager.
	At present change management is purely change log based."

	^self class sourceManager!

changePosition
	"Private - Answer the position in the change log of the receiver's source. N.B. This is a
	logical indication of the time at which the receiver was changed, it it not used for
	accessing the source but merely to determine whether the receiver has been changed relative
	to a particular point. The answer is only valid for instances that answer true to
	#isChanged."

	^self changeManager changePositionOf: self!

displayOn: aStream 
	aStream
		print: self methodClass;
		nextPutAll: '>>';
		nextPutAll: self selector!

getDebugInfo
	"Private - Invoke the compiler to answer a compilation result containing a 
	recompilation of the receiver, a map between IP ranges and expressions 
	in the source, and a map between IP ranges and an OrderedCollection of 
	Associations between IP positions and temporaries up to that position in 
	the receiver, ordered by IP."

	^self compilerClass 
		debugInfoFor: self getSource 
		in: self methodClass 
		debug: self isDebugMethod!

getSource
	"Answer the source of the receiver.
	This task is delegated to the SourceManager."

	^self class sourceManager getSourceOfMethod: self!

hasChanged
	"Private - Answer whether the receiver has been 'changed' (i.e. it has source in
	the change log)."

	^self changeManager hasMethodChanged: self!

icon
	"Answers an Icon that can be used to represent this object."

	self isDeprecated ifTrue: [^self class deprecatedIcon].

	^self isPrivate
		ifTrue: [self class privateIcon]
		ifFalse: [self class publicIcon]
!

infoTip
	"Private - Answer a suitable 'info tip' for the receiver."

	| stream |
	stream := String writeStream: 32.
	stream
		display: self;
		nextPutAll: ' ('.
	self realCategories asSortedCollection asArray 
		, (self protocols asSortedCollection: [:a :b | a asSymbol < b asSymbol]) 
			do: [:each | stream display: each]
			separatedBy: [stream nextPutAll: ', '].
	stream nextPut: $).
	^stream contents!

isChanged
	"Private - Answer whether the receiver is 'changed' (i.e. its class has unsaved changes)."

	^self changeManager isMethodChanged: self!

isClassMethod	
	"Answer true if the receiver is a class method."

	^self methodClass isMeta!

isDeprecated
	"Answer whether the receiver is marked as being deprecated.
	This is based on whether a reference to the symbol, #deprecated, is found
	in the method, for which we use a ReferencesCategory."

	^MethodCategory deprecatedMethods includesMethod: self!

isExpression
	"Private - Answer whether the receiver is a standalone (unbound) expression as opposed to 
	a method."

	^false!

isExternalCall
	"Private - Answer whether the receiver is an external library call (foreign function invocation)."

	^false!

isGetter
	"Answer true if the receiver is an instance variable getter method."

	^self extraIndex == 6!

isLoose
	"Answer whether the receiver is owned by a package different from that of its class."

	^Package manager isLooseMethod: self!

isOverridden
	"Answer whether the receiver is overridden in a subclass."

	| sel |
	sel := self selector.
	self methodClass allSubclassesDo: [:sub | (sub includesSelector: sel) ifTrue: [^true]].
	^false!

isOverride
	"Answer whether the receiver is overriding a method in a superclass."

	| methodSuper |
	methodSuper := self methodClass superclass.
	^methodSuper notNil and: [methodSuper canUnderstand: self selector]
!

isUnbound
	"Answer whether the receiver is unbound (i.e. not linked into a class' method dictionary)."

	^(self methodClass compiledMethodAt: self selector ifAbsent: [^true])	
		sourceDescriptor ~= self sourceDescriptor!

loseSource
	"Private - Set the source object of the receiver to a suitable message informing
	that the source data for the receiver has been lost. This is typically from saving
	an image from an executable, as the executable will have no associated .sml
	file."

	self sourceDescriptor: '"Source unavailable for this method"' !

name
	^self methodClass name -> self selector!

owningPackage
	"Answers the package that owns the receiver or nil if it is not yet owned
	by any package"

	^Package manager packageOfMethodOrItsClass: self!

owningPackage: aPackage
	"Set the receiver's <Package> to be the argument. Any current package association is lost."

	aPackage addMethod: self!

owningPackageIfLoose
	"Answers the package that owns the receiver as a loose method,
	or nil if it is not loose."

	^Package manager packageOfMethod: self!

printOn: aStream 
	"Append a textual description of the receiver to aStream."

	self displayOn: aStream!

privacyCategory
	^self isPrivate 
		ifTrue: [self methodClass methodCategoryClass private]
		ifFalse: [self methodClass methodCategoryClass public]!

protocols
	"Answer a <Collection> of all the method protocols in which the receiver is included."

	^self methodClass allProtocols select: [:p | p includesSelector: self selector]
!

realCategories
	"Answer a <Collection> of all the 'real' (i.e. non-virtual) method categories in which 
	the receiver is included. Note that this does include the public/private categories."

	^self methodClass whichCategoriesIncludeSelector: self selector!

recompile
	"Private - Recompile the receiver."

	self methodClass recompile: self selector!

storeCategories
	"Private - Record the categories of the receiver.
	The job is simply delegated to the receiver's source manager."

	self class sourceManager storeCategoriesForMethod: self.!

storeSourceString: aString
	"Private - Record aString as the source for the receiver. Delegate to the receiver's source manager"

	self class sourceManager storeSourceString: aString forMethod: self! !

CompileFailedMethod comment:
'In certain situations (package loading, method dropping etc) a method compilation will fail and yet a stub CompileFailedMethod is still installed in the class. This stub is useful since it allows the original method source to be accessible via the browsers and allows category information to be maintained for the failed method.

If you want to locate all of these compilation failures remaining in your image siimply evaluate:

SmalltalkSystem current browseCompileFailedMethods'!
!CompileFailedMethod class methodsFor!

buildSourceForSelector: aSymbol class: aBehavior 
	"Private - Construct a method with a correct message pattern for the <Symbol>, aSelector, in the
	class, aBehavior, but which, when invoked, raises an exception to the effect that the original 
	method source failed to compile."

	| argc stream |
	stream := String writeStream: 128.
	argc := aSymbol argumentCount.
	argc == 0 
		ifTrue: [stream nextPutAll: aSymbol]
		ifFalse: 
			[(argc == 1 and: [aSymbol isInfix]) 
				ifTrue: 
					["Assume a binary selector"
					stream
						nextPutAll: aSymbol;
						nextPutAll: ' operand']
				ifFalse: 
					[| inUse |
					inUse := Set withAll: aBehavior allInstVarNames.
					aSymbol keywords do: 
							[:keyword | 
							| x argName |
							stream
								nextPutAll: keyword;
								space.
							x := 1.
							
							[argName := 'arg' , (x := x + 1) displayString.
							inUse includes: argName] whileTrue.
							inUse add: argName.
							stream
								nextPutAll: argName;
								space]]].
	stream
		crtab;
		nextPutAll: ' self error: ''This method did not compile'''.
	^stream contents!

icon
	"Answer an Icon representing the receiver."

	^##(self) defaultIcon! !

!CompileFailedMethod methodsFor!

getDebugInfo
	"Private - Invoke the compiler to answer a compilation result containing a 
	recompilation of the receiver, a map between IP ranges and expressions 
	in the source, and a map between IP ranges and an OrderedCollection of 
	Associations between IP positions and temporaries up to that position in 
	the receiver, ordered by IP."

	| answer |
	answer := self compilerClass 
				debugInfoFor: (self class buildSourceForSelector: selector class: methodClass)
				in: self methodClass
				debug: self isDebugMethod.
	^answer!

icon
	"Answers an Icon that can be used to represent this class"

	^self class icon
!

isCompilationFailure
	^true! !

ExternalMethod comment:
'ExternalMethod is the class of primitive <CompiledMethod>s which represent native, or external, function calls, such as those in the Win32 API. ExternalMethods mediate between the dynamically typed Smalltalk world of objects and the static value based world of C prevailing elsewhere.

The first literal of each ExternalMethod holds a <ByteArray> which contains a descriptor for the function call. The byte array format is understood by the <ExternalDescriptor> class, but essentially there are details of the return and argument types, the name of function, and space to cache the procedure address.
'!
!ExternalMethod class methodsFor!

initialize
	"Private - Initialize the receiver's class variables.

		ExternalMethod initialize.

	The format of the descriptor is:
		
		Proc								Return				ArgN			...	(Arg1)			External
		Address		Calling		Args	Literal	Return		Literal	ArgN	...	(Literal)	Arg1	Function
		Cache		Convention	Length	Index		Type		Index		Type	...	(Index)	Type	Name

		00 00 00 00	00			00		00		00		00		00	...	(00)		00	AAAAAAAAAAA00

	The literal indices referred to are the indices of the (optional) argument types stored in the literal frame.
	The standard, built-in, types (such as #lpvoid, #dword) do not have these indices, or entries in the literal
	frame, but the types for passing/returning structures by value (#struct:) and by reference (#lp:) do - the
	entry in the literal frame is the relevant ExternalStructure class.
	Note that the arguments/return type are stored in reverse order for easier and faster processing by the VM
	external call primitives.
	"

	CallingConventionIndex := 5.
	ArgsLenIndex := 6.				"index of size of arguments descriptions (i.e. offset of proc. name string)"
	ReturnTypeIndex := 8.
	ReturnParmIndex := 7.
	ArgumentStartIndex := 9! !

!ExternalMethod methodsFor!

argsLen
	"Private - Answer the size of the argument description bytes in the receivers descriptor."

	^self descriptorLiteral at: ArgsLenIndex!

argumentTypes
	"Private - Answer a Collection of the names of the argument types in the receiver
	in left to right order."

	^self descriptor argumentTypes!

clear
	"Private - Clear down temporary information cached in the receiver.
	Here we clear down the proc. address cache."

	self descriptorLiteral replaceFrom: 1 to: 4 withObject: 0!

descriptor
	"Private - Answer an ExternalDescriptor generated from the receivers descriptor literal (which has
	a more compact, but more complex, format)."

	| descriptor typeinfo i descriptorClass size |
	descriptor := self descriptorLiteral.
	i := self argsLen.
	size := i + 4.
	typeinfo := ByteArray new: size.
	typeinfo
		at: 1 put: (descriptor at: CallingConventionIndex);
		at: 2 put: self argumentCount;
		at: 3 put: (descriptor at: ReturnTypeIndex);
		at: 4 put: (descriptor at: ReturnParmIndex);
		replaceFrom: 5
			to: size
			with: descriptor
			startingAt: ArgumentStartIndex.
	descriptorClass := self descriptorClass.
	i := size.
	[i > 4] whileTrue: 
			[| type |
			type := typeinfo at: i.
			i := i - 1.
			(descriptorClass typeHasArgument: type) 
				ifTrue: 
					[typeinfo at: i + 1 put: (typeinfo at: i).
					typeinfo at: i put: type.
					i := i - 1]].
	^descriptorClass descriptor: typeinfo literals: self literals

	"
(UserLibrary compiledMethodAt: #childWindowFromPoint:point:) descriptor

descriptorLiteral at: 11
"!

descriptorClass
	"Private - Answer the class of descriptor to use for the receiver."

	^ExternalDescriptor!

descriptorLiteral
	"Private - Answer the argument type descriptor literal from the receiver's 'literal frame'.
	The VM considers the descriptor part of the literal frame (for performance and VM simplicity
	a fixed offset is assumed for the literal frame), but we know better - all ExternalMethods 
	must have a descriptor, so it is an inst. var."

	^self at: 1!

functionName
	"Private - Answer the functionName."

	| bytes |
	bytes := self descriptorLiteral.
	^String fromAddress: bytes yourAddress + ArgumentStartIndex + self argsLen - 1!

isExternalCall
	"Private - Answer whether the receiver is an external library call (foreign function invocation)."

	^true!

isVirtualFunction
	^self primitiveIndex = 80!

printOn: aStream
	"Append a textual description of the receiver to aStream."

	super printOn: aStream.
	aStream nextPut: $(; print: self functionName; nextPut: $)
!

procAddress
	"Private - Answer the receiver's proc. address. The cache will hold zero
	if a call has not yet been made through the function, so we detect this
	and use the appropriate KernelLibrary function."

	| address |
	address := self descriptorLiteral addressAtOffset: 0.
	^address isNull
		ifTrue: [self methodClass default getProcAddress: self functionName]
		ifFalse: [address]
!

returnType
	"Private - Answer the return type for the receiver."

	^self descriptor returnType!

stbSaveOn: anSTBOutFiler
	"Output the receiver to anSTBOutFiler. We must ensure that the cached proc. address is cleared."

	| descriptor |
	descriptor := self descriptorLiteral.
	anSTBOutFiler override: descriptor with: (descriptor copy replaceFrom: 1 to: 4 withObject: 0; yourself).
	super stbSaveOn: anSTBOutFiler.

! !

Error comment:
''!
!Error class methodsFor!

mbIconId
	^MB_ICONERROR!

nonIntegerIndex: anObject
	"Private - Raise an Error to the effect that anObject was used as an 
	integer index, but it isn't!!"

	^self signal: 'Index: ', anObject printString, ' is not an integer'!

notIndexable: anObject
	"Private - Raise an error that some attempt was made to index a non-indexable Object."

	^self signal: 'not indexable'!

notYetImplemented
	"Private - Raise an error that some method is not implemented yet but should 
	be in future."

	^self signal: 'Not implemented yet'
!

perform: selector failedFor: receiver withArgs: arguments 
	"Private - A primitive perform call failed, generate an appropriate error."

	^(selector isMemberOf: Symbol) 
		ifTrue: 
			[(arguments isMemberOf: Array) 
				ifTrue: 
					["This should not fail, because if not understood does not fail primitive"
					| argCount |
					argCount := selector argumentCount.
					argCount = arguments size 
						ifTrue: [receiver primitiveFailed	"unrecognised failure"]
						ifFalse: 
							[receiver error: 'Incorrect number of arguments: ' , arguments size displayString , ', expected ' 
										, argCount displayString]]
				ifFalse: [receiver error: 'Arguments not Array: ' , arguments printString]]
		ifFalse: [receiver error: 'Invalid selector ' , selector printString]!

severityClass
	"Answer an exception class describing the severity of the notification."

	^Error!

subclassResponsibility: selector
	"Private - Raise an error that some message was sent to an abstract class."

	^SubclassResponsibilityError signal: selector printString, ' is the responsibility of the subclass'! !

!Error methodsFor!

asWarning
	"Private - Answer the receiver as a generic Warning message."

	^Warning new 
		messageText: self description!

defaultAction
	"Perform the default action for the receiver if it is not handled
	(forward to the SessionManager for application specific handling."

	^SessionManager current onUnhandledError: self!

isUserResumable
	"Answer whether the user should be given the option of resuming when prompted with regard to
	this exception."

	"Implementation Note: We want to avoid the user being given the option to resume errors in a
	runtime system, as it is almost certainly not desired (e.g. if they hit OK in response to a
	MessageNotUnderstood, then they will almost certainly get a knock on error occurring)."

	^false!

notify
	"Signal a <Notification> with the receiver's description. Generally used to provide
	a trace showing that an error has been suppressed."

	^Notification signal: 'Error: ', self description!

resignalAsWarning
	"Private - Resignal the receiver as if it had originally been raised as a generic Warning.
	This should be used only to get out of sticky situations (e.g. recursive walkbacks)."

	self resignalAs: self asWarning!

warningClass
	"Private - Answer the class of Warning to which the receiver is converted by #asWarning."
	
	^Warning! !

Notification comment:
'Notification is the class of exceptional conditions which are not considered errors.'!
!Notification class methodsFor!

deprecated
	"Raise a warning to the effect that the sender is a deprecated method."

	| sender |
	sender := Processor activeProcess topFrame sender.
	^self signal: 'Deprecated message sent: ', sender method printString, ' from: ', sender sender method printString!

mbIconId
	^MB_ICONINFORMATION!

severityClass
	"Answer an exception class describing the severity of the notification."

	^Notification! !

!Notification methodsFor!

defaultAction
	"The receiver is an unhandled notification, perform the default action
	(forward to the SessionManager for application customisation).
	N.B. The ANSI standard states that no action is taken, which seems a little
	lacking in imagination."

	^SessionManager current 
		ifNil: [KernelLibrary default outputDebugString: self description , String lineDelimiter]
		ifNotNil: [:session | session onUnhandledNotification: self]!

hresult
	"Answer the <HRESULT> error/status code associated with the receiver."

	^HRESULT ok!

isResumable
	"Answer whether the receiver represents a resumable exception. 
	Notifications are almost always resumable."

	^true! !

ProcessTermination comment:
''!
!ProcessTermination methodsFor!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."
	
	^'Terminating %2'!

defaultAction
	"The receiver is an unhandled notification, perform the default action.
	In the case of ProcessTermination signals, we'll only get here on attempts to
	terminate processes which have no base handler, which will only happen if
	the process has not yet completed its initialization, or if it has been
	incompletely terminated. The defaultAction here is to do nothing, and
	if the process is still running, it will shut itself down."
! !

StackOverflow comment:
'Exception signalled when the VM detects an unrecoverable stack overflow in a process. Note that this is not a subclass of <Error> in order that it is not trapped by generic error handlers.'!
!StackOverflow methodsFor!

_descriptionArguments
	"Answer the arguments to be substituted into the receiver's Win32 description format String."

	^Array with: self hresult displayString!

defaultAction
	"Perform the default action for the receiver if it is not handled
	(forward to the SessionManager for application specific handling."

	^SessionManager current onUnhandledError: self!

hresult
	"Answer the <HRESULT> error/status code associated with the receiver."

	^HRESULT win32Error: ERROR_STACK_OVERFLOW! !

ArithmeticError comment:
''!
BoundsError comment:
''!
!BoundsError methodsFor!

_descriptionFormat
	"Answer the description format string for the receiver."

	^'Index %2 is out of bounds'!

receiver
	"Answer the object which generated the bounds error."
	
	^receiver!

receiver: anObject
	"Set the object which generated the bounds error to be anObject"
	
	receiver := anObject! !

ClassRemovalError comment:
''!
!ClassRemovalError methodsFor!

isResumable
	"Answer whether the receiver represents a resumable error. 
	An individual problem removing a class is not considered fatal, 
	so allow resumption to attempt so the class can be removed regardless."

	^true!

originalError
	"Answer the original <Error>, or nil if none."

	^originalError!

originalError: anError
	"Set the original <Error> which occurred when attempting to remove the class
	in the receivers tag field."

	originalError := anError! !

CRTError comment:
''!
!CRTError methodsFor!

_descriptionArguments
	"Answer the arguments to be substituted into the receiver's Win32 description format String."

	^Array 
		with: self errno
		with: self messageText 
		with: self strerror
!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'%2 (16r%1!!X!!: %3)'!

errno
	"Answer the <integer> C-runtime library error number."

	^self tag!

initialize
	"Private - Initialize the receiver's instance variables.
	Set the details to be the last error code reported
	by a system library (i.e. that retried by KernelLibrary>>getLastError)."

	self tag: CRTLibrary default errno
!

messageText
	"Answer the <readableString> message text supplied when the receiver was signalled,
	or nil if none was provided."

	(messageText isNil or: [messageText isEmpty])
		ifTrue: [messageText := self strerror].
	^messageText!

strerror
	"Answer a <readableString> description of the receiver's error number."

	^CRTLibrary default strerror: self errno! !

HRESULTError comment:
''!
!HRESULTError class methodsFor!

fromInteger: anInteger 
	| hr |
	hr := HRESULT fromInteger: anInteger.
	^((FacilityClasses at: hr facilityCode ifAbsent: [self]) new)
		tag: hr;
		yourself!

initialize
	"Private - Initialize the receiver's class variables.
		HRESULTError initialize
	"

	FacilityClasses := 
		IdentityDictionary new
			at: FACILITY_NULL put: Win32Error;
			at: FACILITY_WIN32 put: Win32Error;
			yourself!

registerFacility: anInteger class: anExceptionClass
	"Register the specified exception class as the exception type
	to be raised for HRESULTs with the facility code, anInteger.
	Normally anExceptionClass will be a subclass of the receiver."

	FacilityClasses at: anInteger put: anExceptionClass!

signal: messageText with: anInteger
	"Raise a new instance of the receiver, with the error message, msg, initiating a search for an 
	ExceptionHandler prepared to handle instances of the receiver. This method will not return to its 
	sender, unless the new instance is resumable, and the handler which catches it directs that it 
	should be resumed."

	self signalHRESULT: (HRESULT fromInteger: anInteger)!

signalCode: statusCode facility: facilityCode
	"Raise a new instance of the receiver, with the error message, msg, initiating a search for an 
	ExceptionHandler prepared to handle instances of the receiver. This method will not return to its 
	sender, unless the new instance is resumable, and the handler which catches it directs that it 
	should be resumed."

	^self signalHRESULT: (HRESULT status: statusCode facility: facilityCode)!

signalHRESULT: anInteger 
	"Raise a new Error subinstance, with the specified error code, of an appropriate type 
	(depending on the facility of that code)."

	^(self fromInteger: anInteger) signal!

unregisterFacilityClass: anExceptionClass
	"Unregister the specified exception class, if registered."

	FacilityClasses removeKey: (FacilityClasses keyAtValue: anExceptionClass ifAbsent: [^self])
! !

!HRESULTError methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	| hresult |
	hresult := self hresult.
	^Array 
		with: hresult
		with: self messageText
		with: hresult facility!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'HRESULT Error: %2 (%3)'!

hresult
	"Answer the HRESULT error code associated with the receiver."

	^tag ifNil: [HRESULT fail]!

hresult: hr
	"Set the HRESULT error code associated with the receiver to the <integer>
	argument, hr."

	^self tag: (HRESULT fromInteger: hr)!

messageText
	"Answer the <readableString> message text supplied when the receiver was signalled,
	or nil if none was provided."

	messageText isNil ifTrue: [
		errorInfo notNull ifTrue: [messageText := errorInfo description trimBlanks]].
	(messageText isNil or: [messageText isEmpty])
		ifTrue: [messageText := self osErrorMessage].
	^messageText!

osErrorMessage
	"Answer a String representation of the OS error code."

	^self hresult displayString!

statusCode
	"Answer the error status code from the receiver's details."

	^self hresult statusCode! !

InvalidExternalCall comment:
'Exception to represent an invalid attempt to invoke an external procedure call, perhaps because of passing an invalid object type as an argument.

See <ExternalDescriptor>''s class comment for a description of the argument types supported by Dolphin.'!
!InvalidExternalCall class methodsFor!

invalidArgument: anInteger got: anObject expected: type
	"Private - Validate the attempted invocation of the ExternalMethod in
	the StackFrame argument, raising an appropriate Error if validation of an 
	argument fails."

	##(ExternalDescriptor initialize).	"cause ExternalDescriptor to be initialized during boot"

	^self new
		argument: anObject;
		type: type;
		signalWith: anInteger! !

!InvalidExternalCall methodsFor!

_descriptionArguments
	"Answer the set of arguments to be substitued into the receiver's descriptionFormat
	String."

	^super _descriptionArguments, 
		(Array 
			with: argument basicPrintString
			with: type displayString)!

_descriptionFormat
	"Private - Answer a string which is the message format for the receiver's description.
	Implementation Note: Parameter 1 is the message text, which we don't use in this
	case, 2 is the index of the offending argument, 3 the object passed, and 4 the type
	expected."

	^'Invalid arg %2: Cannot coerce %3 to %4'!

argument: anObject
	"Private - Set the arguments passed to the invalid call which the receiver represents to anArray."

	argument := anObject!

type: anObject
	"Private - Set the type expected by the argument for which the receiver represents an
	invalid call to anObject."

	type := anObject! !

InvalidFormat comment:
''!
!InvalidFormat methodsFor!

_descriptionFormat
	"Private - Answer a string which is the message format for the receiver's description."

	^'Invalid format for %2'! !

MessageNotUnderstood comment:
''!
!MessageNotUnderstood class methodsFor!

receiver: anObject message: aMessage
	"Raise a new instance of the receiver reporting that the <object>, anObject, did not understand
	the <failedMessage>, aMessage."

	^super new
		receiver: anObject;
		tag: aMessage;
		signal! !

!MessageNotUnderstood methodsFor!

_descriptionArguments
	"Answer an string describing the extra information supplied when the receiver
	was raised. Here we answer the classic does not understand error."

	^Array with: self receiver basicClass name with: self selector printString!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver.
	We answer the classic does not understand error format."

	^'%1 does not understand %2'!

isResumable
	"Answer whether the receiver represents a resumable error. Message not understood errors are
	considered resumable, as there are a number of circumstances in which we might want to
	perform #doesNotUnderstand: handling and continue."

	^true!

message
	"Answer the <failedMessage> associated with the receiver."

	^self tag!

receiver
	"Answer the object which did not understand the receiver's
	<failedMessage>."
	
	^receiver!

receiver: anObject
	"Set the object which did not understand the message to be anObject"
	
	receiver := anObject!

selector
	"Answer the selector that was not understood from the receiver's
	<failedMessage>."

	^self message selector! !

NotFoundError comment:
''!
!NotFoundError methodsFor!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'Not found: %2'!

receiver
	"Answer the object which generated the error."
	
	^receiver!

receiver: anObject
	"Set the object which generated the error to be anObject"
	
	receiver := anObject! !

OperationAborted comment:
'Generic exception that can be signalled when the user aborts an operation, for example in response to pressing the cancel button in a dialog.'!
!OperationAborted methodsFor!

messageText
	"Answer the <readableString> message text for the receiver."

	^messageText ifNil: ['Operation aborted']! !

RaisedSignal comment:
''!
!RaisedSignal methodsFor!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver -
	we delegate this back to the Signal instance we are representing."

	^self signalType description!

defaultAction
	"The receiver is an unhandled notification, perform the default action
	(forward to the SessionManager for application customisation)."

	^self signalType defaultAction: self!

isResumable
	"Answer whether the receiver represents a resumable error. This depends on the originating Signal."

	^self signalType isResumable!

messageText
	^messageText ifNil: [signalType description]!

signalType
	"Private - Answer the instance of Signal for which the receiver is representing
	a raise event."

	^signalType!

signalType: aSignal
	"Private - Set the instance of Signal for which the receiver is representing
	a raise event."

	signalType := aSignal! !

STBError comment:
''!
!STBError methodsFor!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'STBFiler - %1'! !

SubclassResponsibilityError comment:
''!
!SubclassResponsibilityError methodsFor!

hresult
	"Answer the <HRESULT> error code associated with the receiver.
	Overridden by subclasses to answer more specified HRESULT codes."

	^HRESULT notImplemented!

initialize
	"Private - Initialize the receiver's instance variables"

	messageText := 'Not implemented'! !

FloatingPointException comment:
''!
!FloatingPointException methodsFor!

_descriptionArguments
	"Answer the arguments to be subsituted into the receiver's description 
	format string."

	^super _descriptionArguments copyWith: self _ieeeRecord causeNames!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'Floating point error: %3'!

_ieeeRecord
	"Private - Answer the IEEE exception record associated with the receiver."

	^self tag!

isOverflow
	"Answer whether receiver represents a floating point overflow error."

	^self tag isOverflow
!

isUnderflow
	"Answer whether receiver represents a floating point underflow error."

	^self tag isUnderflow
! !

ZeroDivide comment:
'ZeroDivide is the class of <Error> for representing attempts at integer division by zero.
Floating point division by zero exceptions are raised as instances of <FloatingPointException>.

For an example of ZeroDivide in action, evaluate the following:
	1/0'!
!ZeroDivide class methodsFor!

dividend: argument
	"Signal the occurrence of an integer division by zero."

	^self signalWith: argument! !

!ZeroDivide methodsFor!

_descriptionFormat
	"Answer the description format string for the receiver."

	^'Division by zero of %2'!

dividend
	"Answer the <number> that was divided by zero."

	^self tag!

isResumable
	"Answer whether the receiver represents a resumable error. 
	Division by zero is not considered fatal, so allow resumption."

	^true! !

Win32Error comment:
''!
!Win32Error class methodsFor!

signal: messageText with: anInteger 
	"Raise a new instance of the receiver, with the error message, msg, initiating a search for an 
	ExceptionHandler prepared to handle instances of the receiver. This method will not return to its 
	sender, unless the new instance is resumable, and the handler which catches it directs that it 
	should be resumed."

	self signalHRESULT: (HRESULT win32Error: anInteger)! !

!Win32Error methodsFor!

_descriptionArguments
	"Answer the arguments to be substituted into the receiver's Win32 description format String."

	^Array 
		with: self statusCode 
		with: self messageText 
		with: self osErrorMessage
!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'%2 (16r%1!!X!!: %3)'!

initialize
	"Private - Initialize the receiver's instance variables.
	Set the details to be the last error code reported
	by a system library (i.e. that retried by KernelLibrary>>getLastError)."

	self tag: (HRESULT status: KernelLibrary default getLastError facility: FACILITY_WIN32)! !

FileException comment:
''!
!FileException class methodsFor!

on: aFile 
	"Answer an instance of the receiver detailing an operating system error
	on the given file."

	^self on: aFile resumable: false!

on: aFile resumable: aBoolean 
	^(self new)
		setFile: aFile resumable: aBoolean;
		yourself!

signalOn: aFile 
	"Signal an instance of the receiver detailing an operating system error
	on the given file."

	^self signalOn: aFile resumable: false!

signalOn: aFile resumable: aBoolean 
	^(self on: aFile resumable: aBoolean) signal! !

!FileException methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	^super _descriptionArguments copyWith: file name!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'''%4'' - %3'!

file
	"Answer the receiver's file instance var."

	^file
!

isResumable
	"Answer whether the receiver represents a resumable error."

	^resumable!

setFile: aFile resumable: aBoolean 
	file := aFile.
	resumable := aBoolean! !

OutOfMemoryError comment:
''!
!OutOfMemoryError class methodsFor!

signal: messageText with: anObject

	^self shouldNotImplement! !

!OutOfMemoryError methodsFor!

initialize
	"Private - Initialize the receiver's instance variables."

	self tag: (HRESULT fromInteger: E_OUTOFMEMORY)! !

RPCError comment:
'Exception class for errors associated with the RPCLibrary'!
Win32Fault comment:
''!
!Win32Fault class methodsFor!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	ExceptionNames := LookupTable new.
	ExceptionNames 
		at: 16rC0000005 put: (HRESULT fromInteger: ERROR_NOACCESS) displayString;
		at: 16r80000002 put: (ExceptionNames at: 16rC0000005);
		at: 16rC0000017 put: (HRESULT fromInteger: 8) displayString;
		at: 16rC000008C put: 'Array subscript out of bounds';
		at: 16rC0000092 put: 'Floating point stack underflow/overflow';
		at: 16rC0000095 put: (HRESULT fromInteger: 534) displayString;
		at: 16rC0000096 put: 'Priviledged instruction';
		at: 16rC0000006 put: (HRESULT fromInteger: 999) displayString;
		at: 16rC000001D put: 'Illegal instruction';
		at: 16rC0000026 put: 'Invalid disposition';
		at: 16rC0000008 put: (HRESULT fromInteger: 6) displayString;
		shrink!

signal: messageText with: anEXCEPTION_RECORD
	"Raise a new instance of the receiver, representing an invalid attempt to access
	the memory at the location, anAddress."

	^self new 
		exceptionRecord: anEXCEPTION_RECORD;
		signal! !

!Win32Fault methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	^super _descriptionArguments , (Array 
				with: self exceptionName
				with: exceptionRecord ExceptionAddress
				with: exceptionRecord moduleFileName)!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'%4 at IP 0x%5!!X!! (%6)'!

exceptionCode
	"Answer the <integer> Win32 exception code associated with the receiver."

	^exceptionRecord ExceptionCode!

exceptionName
	"Answer the <readableString> name of the Win32 exception code associated with the receiver."

	^ExceptionNames
		at: self exceptionCode ifAbsent: [self exceptionCode hex]!

exceptionRecord
	"Answer an <EXCEPTION_RECORD> detailing the original Win32 structured exception."

	^exceptionRecord!

exceptionRecord: anEXCEPTION_RECORD
	"Private - Set the EXCEPTION_RECORD from the Win32 exception."

	exceptionRecord := anEXCEPTION_RECORD.
	self tag: (self tagFromExceptionCode: anEXCEPTION_RECORD ExceptionCode)
!

initialize
	"Override the superclass implementation as we don't need to do any initialization."
!

tagFromExceptionCode: anInteger
	"Private - Answer the HRESULT tag for the receiver from the Win32 exception
	code, anInteger."

	^HRESULT ntStatusCode: anInteger! !

GPFault comment:
''!
!GPFault methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	| info |
	info := exceptionRecord information.
	^super _descriptionArguments 
		, (Array with: ((info at: 1) == 0 ifTrue: ['Reading'] ifFalse: ['Writing'])
				with: (info at: 2) asExternalAddress)
	"7"
	"8"!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'%4 %7 0x%8!!X!!, IP 0x%5!!X!! (%6)'! !

CompilerNotification comment:
'CompilerNotification is the abstract class of <Notification>s used to represent lexical, syntax, and semantic errors and warnings detected by the Dolphin <Compiler>, <SmalltalkParser>, and <StSemanticChecker>.

Instance Variables:
	position		<integer>. Position in source text at which error detected. Not necessarily the same as range start.
	range		<Interval>. Range of the source text to which the error applies (e.g. used to select offending text in browser)
	line			<integer>. Line number on which error detected.
	extras		<Array> of <Object>. Extra values used to parameterise the error message text
	methodClass	<ClassDescription>. Class in the context of which the method is being compiled.
	source		<String>. Method/expression source code
	selector		<Symbol>. Selector of the method being compiled, if available

N.B. The inherited''''tag'''' instance variable is used to hold the <integer> error code, but the inherited ''''messageText'''' instance variable is unused.'''!
!CompilerNotification class methodsFor!

beep
	"Sound a beep describing the severity of the notification."

	self severityClass beep!

classForCode: anInteger 
	^anInteger < CWarnFirst 
		ifTrue: [CompilerErrorNotification]
		ifFalse: 
			[(Compiler isWarningDisabled: anInteger) 
				ifTrue: [DeafObject current]
				ifFalse: 
					[anInteger < CInfoFirst ifTrue: [CompilerWarningNotification] ifFalse: [CompilerInfoNotification]]]!

code: codeInteger in: aString for: aClass selector: aSymbol position: posInteger line: lineInteger range: anInterval extras: anArray 
	^self 
		code: codeInteger
		in: aString
		for: aClass
		selector: aSymbol
		position: posInteger
		line: lineInteger
		ranges: (Array with: anInterval)
		extras: anArray!

code: codeInteger in: aString for: aClass selector: aSymbol position: posInteger line: lineInteger ranges: aCollectionOfInterval extras: anArray 
	^((self classForCode: codeInteger) new)
		code: codeInteger
			in: aString
			for: aClass
			selector: aSymbol
			position: posInteger
			line: lineInteger
			ranges: aCollectionOfInterval
			extras: anArray;
		yourself!

errorFormats
	^ErrorFormats ifNil: [ErrorFormats := LookupTable new]!

icon
	"Answer the default icon for the receiver and its instances."

	^self severityClass icon!

initialize
	"
	self initialize
	"

	| codes |
	ErrorFormats := LookupTable new.
	ErrorFormats
		at: LErrBadChar put: 'illegal character ''<1d>''';
		at: LErrCommentNotClosed put: 'comment not closed';
		at: LErrStringNotClosed put: 'literal string not closed';
		at: LErrExpectConst put: 'constant expected';
		at: LErrExpectExtendedLiteral put: 'extended literal expected';
		at: LErrExpectMetaVariable put: 'meta variable expected';
		at: LErrExpectChar put: 'character expected';
		at: LErrInvalidQualifier put: 'invalid identifier in qualified reference';
		at: LErrQualifiedRefNotClosed put: 'qualified reference not closed';
		at: LErrBadNumber put: 'illegal number'.

	"'Unmatched ' in string literal.'"
	ErrorFormats
		at: CErrTempListNotClosed put: 'temporary list not closed';
		at: CErrInvalExprStart put: 'invalid expression start';
		at: CErrNonsenseAtMethodEnd put: 'nonsense at end of method';
		at: CErrNonsenseAtExprEnd put: 'nonsense at end of expression';
		at: CErrBraceNotClosed put: 'expecting ''}''';
		at: CErrParenNotClosed put: 'expecting '')''';
		at: CErrExpectMessage put: 'expecting message';
		at: CErrUnterminatedStatement put: 'no period at end of statement';
		at: CErrExpectVariable put: 'variable name expected';
		at: CErrBlockArgListNotClosed put: 'block argument list not closed';
		at: CErrBlockNotClosed put: 'expecting '']''';
		at: CErrExpectPrimIdx put: 'primitive index expected';
		at: CErrBadPrimIdx put: 'primitive index <1s> out of range';
		at: CErrExpectCloseTag put: 'expecting ''>''';
		at: CErrBadPrimCallType put: 'invalid primitive call type <1p>';
		at: CErrUnsupportedCallConv put: 'unsupported calling convention <1p>';
		at: CErrExpectFnName put: 'function name or ordinal expected';
		at: CErrExpectExtType put: 'external type expected';
		at: CErrArgTypeCannotBeVoid put: 'argument type can''t be void';
		at: CErrNotIndirectable put: 'too many indirections for type <2d>';
		at: CErrUndefinedClass put: 'undefined class <1p>';
		at: CErrInvalidStructArg put: 'invalid structure class type <1p>';
		at: CErrBadExtTypeQualifier put: 'invalid external type qualifier';
		at: CErrInsufficientArgTypes put: 'insufficient argument types';
		at: CErrTooManyArgTypes put: 'too many argument types';
		at: CErrBadVfn put: 'virtual function index out of range (1..1024)';
		at: CErrExpectVfn put: 'virtual function number expected';
		at: CErrBadTokenInArray put: 'illegal text <1p> in literal array';
		at: CErrBadValueInByteArray put: 'illegal value <1p> in byte array';
		at: CErrByteArrayNotClosed put: 'literal byte array not closed';
		at: CErrArrayNotClosed put: 'literal array not closed';
		at: CErrErrorInStaticExpression put: 'error evaluating static expression';
		at: CErrTooManyIfNotNilBlockArgs put: '#ifNotNil: block must have 0 or 1 arguments';
		at: CErrInternal put: 'Internal Error, see debug output. Please report to Object Arts support';
		at: CErrAssignmentToArgument put: 'illegal assignment to argument <2p>';
		at: CErrTooManyArgs put: 'too many arguments';
		at: CErrTooManyTemps put: 'too many temporaries';
		at: CErrRedefiningPseudoVar put: 'cannot redefine pseudo variable';
		at: CErrUndeclared put: 'undeclared <1p>';
		at: CErrAssignConstant put: 'illegal assignment to constant <2p>';
		at: CErrBadSelector put: 'illegal message selector <1p>';
		at: CErrBadContext put: 'invalid compilation context';
		at: CErrIncorrectBlockArgCount put: 'incorrect number of arguments for optimized block';
		at: CErrExpectLiteralBlock put: 'expecting literal block';
		at: CErrMethodTooLarge put: 'method too large';
		at: CErrTooManyLiterals put: 'too many literals';
		at: CErrBlockNestingTooDeep put: 'maximum block nesting exceeded';
		at: CErrBlockArgMissing put: 'block argument name expected';
		at: CErrBadPools put: 'The workspace pools array is invalid';
		at: CErrDuplicateTempName put: 'duplicate temporary variable name <1p>';
		at: CErrDuplicateArgName put: 'duplicate argument name <1p>';
		at: CErrRedefiningArg put: 'redefining argument <1p>';
		at: CErrStaticExprNotClosed put: 'static expression not closed';
		yourself.
	ErrorFormats
		at: CWarnRedefiningArg put: 'redefining argument <1p>';
		at: CWarnRedefiningTemp put: 'redefining temporary variable <1p>';
		at: CWarnRedefiningInstVar put: 'redefining instance variable <1p>';
		at: CWarnRedefiningStatic put: 'redefining static variable <1p>';
		at: CWarnMsgUnimplemented put: 'message sent to <3s> is not understood by <4p>: <2p>';
		at: CWarnUndefinedSelector put: 'undefined selector <2p>';
		at: CWarnRestrictedSelector
			put: 'overridding or redefining an optimized selector may have no effect';
		at: CWarnExpectNiladicBlockArg put: 'can''t optimize <2p> (requires niladic block argument)';
		at: CWarnExpectMonadicBlockArg put: 'can''t optimize <2p> (requires monadic block argument)';
		at: CWarnExpectMonadicOrNiladicBlockArg put: '<2p> expects niladic or monadic block argument';
		at: CWarnUnreferencedTemp put: 'unreferenced temporary <1p>';
		at: CWarnExpectNiladicBlockReceiver put: 'niladic block expected as receiver of <2p>';
		at: CWarnReadBeforeWritten put: 'temporary <1p> is possibly read before written';
		at: CWarnReadNotWritten put: 'temporary <1p> is read but not written';
		at: CWarnWrittenNotRead put: 'temporary <1p> is assigned but never used';
		at: CWarnUnreachable put: 'unreachable code';
		at: CWarnUnimplementedAbstractMethod put: 'subclass <4p> does not implement <3p>';
		at: CWarnUsesBooleanClass put: 'references boolean class <1p> rather than its instance <2p>';
		yourself.
	ErrorFormats
		at: CInfoUnreferencedArg put: 'unreferenced argument <1p>';
		at: CInfoSupersendsOther put: 'supersends other message <2p>';
		at: CInfoHardBreakpoint put: 'contains hardcoded breakpoint';
		yourself.
	codes := Smalltalk at: #SmalltalkParseErrorCodes.
	codes keysAndValuesDo: [:eachKey :each | self assert: [ErrorFormats includesKey: each]].
	ErrorFormats keysDo: [:each | self assert: [codes includes: each]]! !

!CompilerNotification methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	^Array 
		with: self severityName
		with: self methodClass displayString
		with: self selector
		with: self line
		with: self errorMessage!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'%1: %2>>%3 at line %4!!d!!: %5'!

code: anInteger in: aString for: aClass selector: aSymbol position: posInteger line: lineInteger ranges: aCollectionOfInterval extras: anArray 
	"Private - Initialize the receiver's instance variables. Answer the receiver."

	self tag: anInteger.
	source := aString.
	methodClass := aClass.
	selector := aSymbol.
	position := posInteger.
	line := lineInteger.
	ranges := aCollectionOfInterval.
	extras := anArray.
	offset := 0!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self severityName;
		nextPutAll: ': ';
		nextPutAll: self errorMessage!

errorCode
	^self tag!

errorMessage
	"Answer a <String> describing the nature of the notification."

	^(self class errorFormats at: self errorCode ifAbsent: []) 
		ifNil: ['Unknown Compiler <1d>: <2d>' expandMacrosWith: self severityName with: self errorCode]
		ifNotNil: 
			[:format | 
			format 
				expandMacrosWithArguments: (Array with: (self source copyFrom: self range start to: self range stop)) 
						, extras]!

extra
	#deprecated.
	^extras isEmpty ifFalse: [extras any]!

extras
	^extras!

line
	"Answer the line in the text from where the notification originated."

	^line!

methodClass
	"Answer the Class context which the code was being compiled in."

	^methodClass!

offset
	"Anwser the offset of the start of the receiver's error range relative to the original
	method source code. This is zero in all cases except for errors arising parsing a static
	expression, i.e. ##(<static expression>)"

	^offset!

offset: anInteger 
	"Set the offset of the start of the receiver's error range relative to the original
	method source code."

	offset := anInteger!

okToContinue
	"Throw up an OK/Cancel message box with the receiver's compilation error/warning
	message, answering true if the user pressed OK to contine the compilation."

	| mb severity |
	severity := self severityClass.
	mb := (MessageBox new)
				caption: 'Compilation ' , self severityName;
				text: ('line <1d>: <2s>' expandMacrosWith: self line with: self errorMessage);
				iconStyleFlag: severity mbIconId;
				yourself.
	^severity == Error 
		ifTrue: 
			[mb
				ok;
				open.
			false]
		ifFalse: 
			[mb buttonStyle: #okCancel.
			mb open == #ok]!

position
	^position!

range
	"Answer the <Interval> of character positions in the original source code in respect of
	which the notification was raised."

	| range |
	range := ranges first start to: ranges last stop.
	range stop isNil ifTrue: [range stop: range start].
	"The range always specifies from the start of the source text, regardless of expression offset"
	^range!

ranges
	"Answer an <sequencedReadableCollection> of <Interval> being the ranges of character
	positions in the original source code in respect of which the notification was raised."

	^ranges!

selector
	"Answer the selector of the code which raised the notification."

	^selector!

severityName
	^self severityClass name!

source
	"Answer the <readableString> of code which caused this notification to be raised while it
	was being compiled."

	^source ifNil: ['']! !

HRESULTNotification comment:
''!
!HRESULTNotification methodsFor!

_descriptionArguments
	"Answer the arguments to be substitued into the receiver's Win32 description format String."

	| hresult |
	hresult := self hresult.
	^Array with: hresult with: hresult displayString with: hresult facility!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver."

	^'HRESULT Success: %2 (%3)'!

hresult
	"Answer the HRESULT error code associated with the receiver."

	^self tag! !

MethodCompileFailed comment:
'A MethodCompileFailed notification is signalled when a method compilation fails. Handlers can trap this if they wish to replace the original failed compilation with a stub method. This is useful so that the failed method source can be seen in the browsers or to retain category information. To install a stub method the handler should call #resumeWithStubMethod.'!
!MethodCompileFailed class methodsFor!

new
	"Private - Use #with:"

	self shouldNotImplement!

with: aCompilerErrorNotification
	"Answer an instance of the receiver that indicates that a method compilation failed
	due to aCompilerErrorNotification"

	^super new compilerErrorNotification: aCompilerErrorNotification
! !

!MethodCompileFailed methodsFor!

compilerErrorNotification: aCompilerErrorNotification
	"Private - Set the value of the receiver's instance variable compilerErrorNotification to 
	aCompilerErrorNotification."

	compilerErrorNotification := aCompilerErrorNotification.!

defaultAction
	"The receiver is an unhandled notification, perform the default action
	which is nothing but to answer a nil method"

	^nil!

resumeWithStubMethod
	"Create a stub method which causes an error if evaluated but has the source of the
	proposed method that did not compile. Answer this as the result of resuming the
	notification"

	| selector methodClass result |
	selector := compilerErrorNotification selector asSymbol.
	selector isEmpty ifTrue: [^nil].
	methodClass := compilerErrorNotification methodClass.
	result := methodClass compilerClass 
				compile: (CompileFailedMethod buildSourceForSelector: selector class: methodClass)
				in: methodClass
				flags: methodClass defaultCompilationFlags.
	result method becomeA: CompileFailedMethod.

	"Resume with this stub"
	self resume: result! !

RaisedNotificationSignal comment:
'RaisedNotificationSignal is the class of Error whose instances are used to represent NotificationSignal instances when raised. That is it enables instance based notifications (NotificationSignals) to be raised within Dolphin''s class based exception framework.

Instances Variables:
	signalType		<Signal>. The signal instance which originated this exception.'!
!RaisedNotificationSignal methodsFor!

_descriptionFormat
	"Answer the Win32 format String to be used to format the description for the receiver -
	we delegate this back to the Signal instance we are representing."

	^self signalType description!

defaultAction
	"The receiver is an unhandled notification, perform the default action
	(forward to the SessionManager for application customisation)."

	^self signalType defaultAction: self!

isResumable
	"Answer whether the receiver represents a resumable error. This depends on the originating Signal."

	^self signalType isResumable!

signalType
	"Private - Answer the instance of Signal for which the receiver is representing
	a raise event."

	^signalType!

signalType: aSignal
	"Private - Set the instance of Signal for which the receiver is representing
	a raise event."

	signalType := aSignal! !

Warning comment:
'Warning is the class of <Notification>s which represent exceptional conditions that are not considered errors, but which should still be reported to the user with the option to continue or abort the computation.'!
!Warning class methodsFor!

mbIconId
	^MB_ICONWARNING!

severityClass
	"Answer an exception class describing the severity of the notification."

	^Warning! !

!Warning methodsFor!

defaultAction
	"Perform the default action for the receiver if it is not handled
	(forward to the SessionManager for application specific handling).
	N.B. The ANSI standard states that the user should be given the option to
	either continue or abort the computation, and indeed that is what the
	standard SessionManager implementation does.	"

	"Will not return unless execution is to be resumed"
	^SessionManager current onUnhandledWarning: self! !

CompilerErrorNotification comment:
'CompilerErrorNotification is a resumable exception used to represent lexical, syntax, and semantic errors detected by the <SmalltalkParser> and Dolphin <Compiler>.'!
!CompilerErrorNotification class methodsFor!

severityClass
	"Answer an exception class describing the severity of the notification."

	^Error! !

CompilerInfoNotification comment:
'CompilerInfoNotification is a resumable exception used to represent low-severity semantic warnings detected by the <StSemanticChecker>'!
!CompilerInfoNotification methodsFor!

severityName
	^#Note! !

CompilerWarningNotification comment:
'CompilerWarningNotification is a resumable exception used to represent semantic warnings detected by the Dolphin <Compiler>, <SmalltalkParser>, and (mainly) <StSemanticChecker>'!
!CompilerWarningNotification class methodsFor!

severityClass
	"Answer an exception class describing the severity of the notification."

	^Warning! !

ExceptionHandler comment:
''!
!ExceptionHandler methodsFor!

actionFor: exception
	"Private - Answer a <monadicBlock> handler for the <exceptionDescription> 
	argument, exception or nil if the receiver has no appropriate handler."

	^(selector handles: exception) ifTrue: [handler]!

on: exceptionSelector do: monadicBlock
	"Private - Record the <exceptionSelector> and <monadicBlock> to be
	used as the receivers exception selector and handler block respectively."

	selector := exceptionSelector.
	handler := monadicBlock
! !

ExceptionHandlerSet comment:
''!
!ExceptionHandlerSet class methodsFor!

new
	"Answer a new, initialized, instance of the receiver."

	^super new initialize! !

!ExceptionHandlerSet methodsFor!

actionFor: exception
	"Private - Answer a <monadicBlock> handler for the <exceptionDescription> 
	argument, exception or nil if the receiver has no appropriate handler."

	^(handlers detect: [:h | h key handles: exception] ifNone: [^nil]) value!

initialize
	"Private - Initialize the instance variables of the receiver."

	handlers := OrderedCollection new!

on: exceptionSelector do: monadicBlock
	"Private - Record the <exceptionSelector> and <monadicBlock> to be
	used as the receivers exception selector and handler block respectively."

	handlers addLast: (exceptionSelector -> monadicBlock)
! !

BlockCallback comment:
''!
!BlockCallback methodsFor!

block: aBlockClosure
	"Private - Record the block to be evaluated when the callback represented
	by the receiver is entered.
	N.B. The argument really must be a BlockClosure - other valuables are not
	acceptable."

	block := aBlockClosure!

printOn: aStream
	"Append, to aStream, a String whose characters are a description of the receiver."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: block;
		space;
		print: self argumentTypes;
		nextPut: $)!

valueWithArgumentsAt: anAddress
	"Private - Evaluate the receiver with arguments instantiated from the raw data at anAddress.
	For performance and consistency (with outbound external calls) reasons, we use a VM supplied
	primitive to instantiate and push the arguments and perform the message, but there is no reason
	that this cannot be done in Smalltalk if different argument conversions are required. The standard
	conversions are the same as those performed for return types by the external call primitive (see
	the ExternalLibrary class)."

	^block valueWithArgumentsAt: anAddress descriptor: descriptor! !

MessageCallback comment:
''!
!MessageCallback methodsFor!

closure
	"Answer the user supplied 'closure' object supplied when the receiver was created.
	This can be anything appropriate to the callbacks purposes."

	^closure!

closure: anObject
	"Set the user supplied 'closure' object. 
	This can be anything appropriate to the callbacks purposes.
	Answer the receiver."

	closure := anObject!

printOn: aStream
	"Append, to aStream, a String whose characters are a description of the receiver."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: receiver;
		space;
		print: selector;
		space;
		print: self argumentTypes;
		nextPut: $)!

receiver: anObject
	"Private - Record the receiver of the callback."

	receiver := anObject!

selector: aSymbol
	"Private - Set the selector to send when the receiver is evaluated."

	selector := aSymbol!

valueWithArgumentsAt: anAddress
	"Private - Evaluate the receiver with arguments instantiated from the raw data at anAddress."

	^receiver perform: selector withArgumentsAt: anAddress descriptor: descriptor! !

AdvApiLibrary comment:
'AdvApiLibrary is the <ExternalLibrary> class to represent the Win32 system DLL, ADVAPI32.DLL.

This DLL contains functions mainly to do with accessing the registry, high-level access to which is available via Dolphin''s RegKey classes.
'!
!AdvApiLibrary class methodsFor!

fileName
	"Answer the host system file name for the library"

	^'ADVAPI32'! !

!AdvApiLibrary methodsFor!

deregisterEventSource: anExternalHandle 
	<stdcall: bool DeregisterEventSource handle>
	^self invalidCall!

getUserName: buffer nSize: pBufSize 
	"Retrieve the user name of the current thread. This is the name of the user currently 
	logged onto the system. 
		BOOL GetUserName(
  			LPTSTR lpBuffer,	// address of name buffer 
			LPDWORD nSize 		// address of size of name buffer 
		);"

	<stdcall: bool GetUserNameA lpstr DWORD*>
	^self invalidCall!

regCloseKey: hKey
	"Release the handle of the specified registry key.

		LONG RegCloseKey( 
			HKEYhKey 	// handle of key to close 
		);"

	<stdcall: sdword RegCloseKey handle>
	^self invalidCall!

regConnectRegistry: lpMachineName hKey: hKey phkResult: phkResult
	"
		LONG RegConnectRegistry( 
			LPTSTRlpMachineName,	// address of name of remote computer 
			HKEYhKey,			// predefined registry handle 
			PHKEYphkResult 		// address of buffer for remote registry handle);
	"

	<stdcall: sdword RegConnectRegistryA lpstr handle lpvoid>
	^self invalidCall!

regCreateKeyEx: hKey lpSubKey: lpSubKey reserved: reserved lpClass: lpClass dwOptions: dwOptions samDesired: samDesired lpSecurityAttributes: lpSecurityAttributes phkResult: phkResult lpdwDisposition: lpdwDisposition 
	"Create or opens the specified registry key. Answers appropriate Win32 extended error code.

		LONG RegCreateKeyEx( 
			HKEY hKey, 			// handle of an open key 
			LPCTSTR lpSubKey, 		// address of subkey name 
			DWORD Reserved, 		// reserved 
			LPTSTR lpClass, 			// address of class string 
			DWORD dwOptions,		// special options flag 
			REGSAM samDesired, 		// desired security access 
			LPSECURITY_ATTRIBUTES lpSecurityAttributes, // address of key security structure 
			PHKEY phkResult, 		// address of buffer for opened handle 
			LPDWORD lpdwDisposition	// address of disposition value buffer 
		); "

	<stdcall: sdword RegCreateKeyExA handle lpstr dword lpstr dword dword lpvoid lpvoid DWORD*>
	^self invalidCall!

regDeleteKey: hKey lpSubKey: lpSubKey
	"Delete the specified sub-key of the key whose handle is hKey.

	Note that the exact behaviour depends on the host OS:
		Windows 95:	The RegDeleteKeyfunction deletes a subkey and all its descendants. 
		Windows NT:	The RegDeleteKeyfunction deletes the specified subkey. 
				The subkey to be deleted must not have subkeys. 

		LONG RegDeleteKey( 
			HKEYhKey, 		// handle of open key 
			LPCTSTRlpSubKey	// address of name of subkey to delete 
		);"

	<stdcall: sdword RegDeleteKeyA handle lpstr>
	^self invalidCall!

regDeleteValue: hKey lpValueName: lpValueName
	"Delete the specified registry value of the key whose handle is hKey.

		LONG RegDeleteValue(
			HKEYhKey,			// handle of key 
			LPCTSTRlpValueName	// address of value name 
		);"

	<stdcall: sdword RegDeleteValueA handle lpstr>
	^self invalidCall!

regEnumKeyEx: hKey dwIndex: dwIndex lpName: lpName lpcbName: lpcbName lpReserved: lpReserved lpClass: lpClass lpcbClass: lpcbClass lpftLastWriteTime: lpftLastWriteTime 
	"Get details for the sub-key of hKey with the specified index.

		LONG RegEnumKeyEx(
			HKEY hKey, 			// handle of key to query 
			DWORD dwIndex, 		// index of subkey to query 
			LPTSTR lpName, 			// address of buffer for subkey name 
			LPDWORD lpcbName, 		// address for size of subkey buffer 
			LPDWORD lpReserved,
			LPTSTR lpClass,			// address of buffer for class string 
			LPDWORD lpcbClass, 		// address for size of class buffer 
			PFILETIME lpftLastWriteTime	// address for time key last written to 
		);"

	<stdcall: sdword RegEnumKeyExA handle sdword lpstr DWORD* DWORD* lpstr DWORD* FILETIME*>
	^self invalidCall!

regEnumValue: hKey dwIndex: dwIndex lpValueName: lpValueName lpcbValueName: lpcbValueName lpReserved: lpReserved lpType: lpType lpData: lpData lpcbData: lpcbData 
	"
		LONG RegEnumValue( 
			HKEY hKey, 			// handle of key to query 
			DWORD dwIndex, 		// index of value to query 
			LPTSTR lpValueName, 		// address of buffer for value string 
			LPDWORD lpcbValueName,	// address for size of value buffer 
			LPDWORD lpReserved, 		// reserved 
			LPDWORD lpType, 		// address of buffer for type code 
			LPBYTE lpData, 			// address of buffer for value data 
			LPDWORD lpcbData 		// address for size of data buffer 
		); "

	<stdcall: sdword RegEnumValueA handle dword lpstr DWORD* DWORD* DWORD* lpvoid DWORD*>
	^self invalidCall!

registerEventSource: stringUNCServerName lpSourceName: stringSourceName 
	"HANDLE RegisterEventSource(
		LPCTSTR lpUNCServerName,	// server name for source 
		LPCTSTR lpSourceName 	// source name for registered handle  
	);"

	<stdcall: handle RegisterEventSourceA lpstr lpstr>
	^self invalidCall!

regOpenKeyEx: hKey lpSubKey: lpSubKey ulOptions: ulOptions samDesired: samDesired phkResult: phkResult 
	"Opens the specified registry key. Answers appropriate Win32 extended error code.
		LONG RegOpenKeyEx(
  			HKEY hKey,		// handle of open key 
			LPCTSTR lpSubKey,	// address of name of subkey to open 
			DWORD ulOptions,	// reserved 
			REGSAM samDesired,	// security access mask 
			PHKEY phkResult 	// address of handle of open key 
		);"

	<stdcall: sdword RegOpenKeyExA handle lpstr dword dword lpvoid>
	^self invalidCall!

regQueryInfoKey: hKey lpClass: lpClass lpcbClass: lpcbClass lpReserved: lpReserved lpcSubKeys: lpcSubKeys lpcbMaxSubKeyLen: lpcbMaxSubKeyLen lpcbMaxClassLen: lpcbMaxClassLen lpcValues: lpcValues lpcbMaxValueNameLen: lpcbMaxValueNameLen lpcbMaxValueLen: lpcbMaxValueLen lpcbSecurityDescriptor: lpcbSecurityDescriptor lpftLastWriteTime: lpftLastWriteTime 
	"Answer (a lot of) information about a specified registry key. 

		LONG RegQueryInfoKey ( 
			HKEY hKey, 					// handle of key to query 
			LPTSTR lpClass, 					// address of buffer for class string 
			LPDWORD lpcbClass, 				// address of size of class string buffer 
			LPDWORD lpReserved, 				// reserved 
			LPDWORD lpcSubKeys, 			// address of buffer for number of subkeys 
			LPDWORD lpcbMaxSubKeyLen,	// address of buffer for longest subkey name length 
			LPDWORD lpcbMaxClassLen,			// address of buffer for longest class string length 
			LPDWORD lpcValues, 				// address of buffer for number of value entries 
			LPDWORD lpcbMaxValueNameLen,	// address of buffer for longest value name length 
			LPDWORD lpcbMaxValueLen, 		// address of buffer for longest value data length 
			LPDWORD lpcbSecurityDescriptor,// address of buffer for security descriptor length 
			PFILETIME lpftLastWriteTime			// address of buffer for last write time 
	 ); "

	<stdcall: sdword RegQueryInfoKeyA handle lpstr DWORD* DWORD* DWORD* DWORD* DWORD* DWORD* DWORD* DWORD* DWORD* FILETIME*>
	^self invalidCall!

regQueryValueEx: kKey lpValueName: lpValueName lpReserved: lpReserved lpType: lpType lpData: lpData lpcbData: lpcbData 
	"Retrieves the type and data for a specified value name associated with an open registry key.
		LONG RegQueryValueEx(
			HKEY hKey,			// handle of key to query 
			LPTSTR lpValueName,		// address of name of value to query 
			LPDWORD lpReserved,		// reserved 
			LPDWORD lpType,		// address of buffer for value type 
			LPBYTE lpData,			// address of data buffer 
			LPDWORD lpcbData 		// address of data buffer size 
		);"

	<stdcall: sdword RegQueryValueExA handle lpstr DWORD* DWORD* lpvoid DWORD*>
	^self invalidCall!

regSetValueEx: kKey lpValueName: lpValueName reserved: dwReserved dwType: dwType lpData: lpData cbData: cbData 
	"Store the type and data for a specified value name associated with an open registry key.
		LONG RegSetValueEx( 
			HKEY hKey,		// handle of key
			LPTSTR lpValueName,	// address of name of value
			DWORD lpReserved,	// reserved 
			DWORD lpType,		// value type 
			CONST BYTE *lpData, 	// address of data buffer 
			DWORD lpcbData 	// data buffer size 
		);"

	<stdcall: sdword RegSetValueExA handle lpstr dword dword lpvoid dword>
	^self invalidCall!

reportEvent: hEventLog wType: wType wCategory: wCategory dwEventId: dwEventId lpUserSid: lpUserSid wNumStrings: wNumStrings dwDataSize: dwDataSize lpStrings: lpStrings lpRawData: lpRawData 
	"
		BOOL ReportEvent(
			HANDLE hEventLog,	// handle returned by RegisterEventSource 
			WORD wType,		// event type to log 
			WORD wCategory,	// event category 
			DWORD dwEventID,	// event identifier 
			PSID lpUserSid,		// user security identifier (optional) 
			WORD wNumStrings,	// number of strings to merge with message  
			DWORD dwDataSize,	// size of binary data, in bytes
			LPCTSTR *lpStrings,	// array of strings to merge with message 
			LPVOID lpRawData 	// address of binary data 
		);"

	<stdcall: bool ReportEventA handle word word dword lpvoid word dword lpvoid lpvoid>
	^self invalidCall! !

CompilerLibrary comment:
'CompilerLibrary is the <ExternalLibrary> to represent the Dolphin Smalltalk compiler.

In versin 3.0 the compiler is actually implemented as a COM object, but to avoid the necessity of making the OLE COM package part of the base image, the VM exposes some simple wrapper functions which have the same signature as the 2.x compiler API.'!
!CompilerLibrary class methodsFor!

fileName
	"Answer the host system file name of the external library which
	the receiver represents."

	^VMLibrary default compilerFileName! !

!CompilerLibrary methodsFor!

compile: aCompiler source: aString in: aClass flags: anInteger notifying: notifier
	"Private - Compiler the method source, aString, in the context of the class, aClass,
	on behalf of the compiler, aCompiler, parameterized by the flags, anInteger,
	notifying, notifier, of any errors or warnings which are detected."

	<stdcall: oop CompileForClass ote lpstr ote sdword oop>
	^self invalidCall!

compileForEvaluation: aCompiler source: aString in: aClass evaluationPools: anArray flags: anInteger notifying: notifier
	"Private - Compiler the expression source, aString, in the context of the class, aClass,
	on behalf of the compiler, aCompiler, parameterized by the flags, anInteger,
	notifying, notifier, of any errors or warnings which are detected."

	<stdcall: oop CompileForEval oop lpstr ote ote sdword oop>
	^self invalidCall! !

ExternalResourceLibrary comment:
'ExternalResourceLibrary is a generic type of <ExternalLibrary>, instance of which can be used to access resources (e.g. icons, bitmaps, strings) from arbitrary modules (DLLs and EXES). A registry of open resource libraries is maintained so that each module is represented by a single instance, and aliasing of the library names is supported to map old Dolphin resources to new libraries should the latter be renamed.'!
!ExternalResourceLibrary class methodsFor!

aliasFor: libraryNameString 
	"Answer the name of the resource file which should actually be opened in place
	of the named library. Generally the argument will be answered, but on occassion, e.g
	after a product upgrade, the resource file name has changed and so we can use
	this facility to remap old resources to the new resource file."

	| libName |
	libName := libraryNameString asLowercase.
	^(Libraries at: (File splitStemFrom: libName) ifAbsent: [^libName]) fileName!

defaultLoadFlags
	"Private - Answer the default LoadLibraryEx() flags to be used when loading
	instances of the receiver.
	Note: There appears to be a bug in Windows that results in a GPF in User32.dll if 
	one attempts to use a dialog template from a DLL loaded as a data file, therefore
	the development resources (for example) must be loaded without these flags."

	^##(LOAD_LIBRARY_AS_DATAFILE|DONT_RESOLVE_DLL_REFERENCES)
!

initialize
	"Private - Initialize the receiver's class variables, &c.
		ExternalResourceLibrary initialize
	"

	Libraries := WeakLookupTable new!

onPreStripImage
	"Private - The image is about to be stripped, close down defaults to allow unused
	subclasses to be stripped."

	self closeAllDefaults!

open: aString
	"Answer an instance of the receiver which references the external
	library with the <readableString> external file path argument."

	^self open: aString withAliases: #()!

open: pathString withAlias: aliasString
	"Register the <readableString>, aliasString, as an alias for the external resource
	library with the <readableString> path, pathString. Answer the aliased external
	resource library instance.
	N.B. The register of instances is weak. If the library instance is not referenced
	from elsewhere, then the alias will be lost and will need to be re-registered."

	^self open: pathString withAliases: (Array with: aliasString)!

open: aString withAliases: aCollection
	"Register the <collection> of <readableString>s, aCollection, as aliases for the 
	external resource library with the <readableString> path, aString. Answer the 
	new (or existing) external resource library instance.
	N.B. The register of instances is weak. If the library instance is not referenced
	from elsewhere, then the alias will be lost and will need to be re-registered."

	^self 
		open: aString
		withAliases: aCollection
		flags: self defaultLoadFlags!

open: aString withAliases: aCollection flags: anInteger
	"Register the <collection> of <readableString>s, aCollection, as aliases for the 
	external resource library with the <readableString> path, aString, using the
	LoadLibraryEx() flags in the <integer> argument if a new library needs to be
	opened. Answer the new (or existing) external resource library instance.
	N.B. The register of instances is weak. If the library instance is not referenced
	from elsewhere, then the alias will be lost and will need to be re-registered."

	| lib path |
	path := File default: aString asLowercase extension: 'dll'.
	lib := Libraries at: path
				ifAbsentPut: 
					[(self new)
						loadFlags: anInteger;
						open: path;
						initialize;
						yourself].
	aCollection 
		do: [:alias | Libraries at: (File default: alias extension: 'dll') put: lib].
	^lib!

stbConvertFrom: anSTBClassFormat 
	"Convert from version 1 ExternalResourceLibrary (adds loadFlags inst. var)"

	^
	[:data | 
	| newInstance |
	newInstance := self basicNew.
	1 to: data size do: [:i | newInstance instVarAt: i put: (data at: i)].
	newInstance loadFlags: 0.
	newInstance]!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^1! !

!ExternalResourceLibrary methodsFor!

attemptToOpen: aString
	^
	[self basicOpen: aString.
	true] on: Win32Error do: [:ex | false]!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^fileName!

loadFlags
	^loadFlags!

loadFlags: anInteger
	loadFlags := anInteger!

open: aString
	"Private - Open the external library with the external file name, aString,
	as the library referenced by the receiver. Answer the receiver.
	Implementation Note: Any errors are suppressed, although a notification
	is written to the log device. If the resource library cannot be found at
	the specified path, then a number of attempts are made to open the
	lib in the order - working directory, image relative, install relative."

	| name |
	fileName := aString.
	name := self class aliasFor: aString.
	[self basicOpen: name] on: Win32Error
		do: 
			[:e1 | 
			"Supplied path didn't work"

			| filename |
			((File splitPathFrom: name) notEmpty and: 
					["previously pathed, so try stem only"

					self attemptToOpen: (File splitStemFrom: name)]) 
				ifTrue: [^self].
			filename := File splitFilenameFrom: name.
			"Try the current image path"
			(self attemptToOpen: (FileLocator imageRelative localFileSpecFor: filename)) 
				ifTrue: [^self].
			"Finally try the installation path"
			(self attemptToOpen: (FileLocator installRelative localFileSpecFor: filename)) 
				ifTrue: [^self].
			"No luck, report the original error as a notification"
			Notification 
				signal: 'Resource library ' , fileName , ' could not be opened (' , e1 description , ')'].
	^self!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler.
	Use a special proxy in order to share a common instance on reload."

	anSTBOutFiler
		saveObject: self
		as: (STBExternalResourceLibraryProxy forLibrary: self)! !

PermanentLibrary comment:
'PermanentLibrary is the class of <ExternalLibrary>s which are expected to remain permanently open in order for the system to continue functioning. The set of permanent libraries includes all of the basic Win32 system DLLs, the C runtime library, and the Virtual Machine itself. In addition these are not opened lazily to avoid the overhead when accessing the default instance.'!
!PermanentLibrary class methodsFor!

clear
	"Private - Clear down cached external function addresses from previous runs." 

	self clearMethodDictionary: self methodDictionary.!

closeDefault
	"Private - Close the default instance of the receiver (if there is one).
	In the case of the receiver, we ignore this request because the default 
	is not lazily opened."!

default
	"Answer the default instance of the receiver. Override because the PermanentLibraries
	must always be open, and because speed of access to it is important to overall system
	performance."

	^default!

default: anExternalLibrary
	"Set the default instance of the receiver.
	The 'default' instance of permanent libraries cannot be changed."!

onStartup
	"Private - Perform system startup processing for all subclasses.
	Implementation Note: The permanent libraries must be cleared down
	before they are re-opened, otherwise invalid function addresses
	may get called."

	KernelLibrary clear.			"This has to be opened first"
	self allSubclasses do: [:s |
		s == KernelLibrary ifFalse: [s clear]]!

onStartup2
	"Private - Perform system startup processing for all subclasses.
	Implementation Note: The permanent libraries must be cleared down
	before they are re-opened, otherwise invalid function addresses
	may get called."

	self allSubclasses do: [:c | c openDefault]! !

!PermanentLibrary methodsFor!

close
	"Release the reference the receiver has to the External Library it represents. This may
	not cause the library to be unloaded, so it may still function.
	It is really not a good idea to do this for the default instances of permanent libraries 
	because it will break the VM and everything else."

	^self ~~ self class default and: [super close]! !

RPCLibrary comment:
''!
!RPCLibrary class methodsFor!

fileName
	"Answer the host system file name of the external library which the receiver represents"

	^'RPCRT4'! !

!RPCLibrary methodsFor!

rpcStringFree: lppstr
	"Free a character string allocated by the RPC library.
		RPC_STATUS RPC_ENTRY RpcStringFree( 
			unsigned char * *  String	
		);"

	<stdcall: sdword RpcStringFreeA char**>
	^self invalidCall!

uuidCompare: uuid1 uuid2: uuid2 status: status
	"Answer an <integer> order between the  <GUID>, uuid1, is equal to the <GUID>, uuid2,
	with error status reported through the <DWORD> argument, status.
		int UuidCompare(
			UUID * Uuid1,
			UUID * Uuid2,
			RPC_STATUS * Status
		);"

	<stdcall: sdword UuidCompare void* void* dword*>
	^self invalidCall!

uuidCreate: uuidBuf
	"Create a new UUID.

		RPC_STATUS RPC_ENTRY UuidCreate( 
			UUID *  Uuid  
		);"
 
	<stdcall: sdword UuidCreate void*>
	^self invalidCall!

uuidFromString: uuid uuid: lppstr
	"Converts a string to a UUID.

		RPC_STATUS RPC_ENTRY UuidFromString( 
			unsigned char*  StringUuid, 	
			UUID *  Uuid	
		);"

	<stdcall: sdword UuidFromStringA char* void*>
	^self invalidCall!

uuidHash: uuid status: status
	"
		unsigned short RPC_ENTRY UuidHash( 
			UUID *  Uuid, 	
			RPC_STATUS *  Status	
		);"

	<stdcall: word UuidHash void* dword*>
	^self invalidCall!

uuidToString: uuid stringUuid: lppstr
	"Converts a UUID to a string.
		RPC_STATUS RPC_ENTRY UuidToString( 
			UUID *  Uuid, 	
			unsigned char **  StringUuid	
		);"

	<stdcall: sdword UuidToStringA void* char**>
	^self invalidCall! !

ShlwapiLibrary comment:
'ShlwapiLibrary is the <ExternalLibrary> class to represent the Win32 "Shell Lightweight API Library", SHLWAPI.DLL.'!
!ShlwapiLibrary class methodsFor!

fileName
	"Answer the host system file name for the library"

	^'SHLWAPI'! !

!ShlwapiLibrary methodsFor!

colorHLSToRGB: wHue wLuminance: wLuminance wSaturation: wSaturation 
	"Invoke the ColorHLSToRGB() function of the module wrapped by the receiver.
	Helpstring: Converts colors from hue-luminance-saturation (HLS) format to RGB format.

	COLORREF ColorHLSToRGB(      
		WORD wHue,
		WORD wLuminance,
		WORD wSaturation
		);"

	<stdcall: dword ColorHLSToRGB word word word>
	^self invalidCall!

colorRGBToHLS: clrRGB pwHue: pwHue pwLuminance: pwLuminance pwSaturation: pwSaturation
	"Invoke the ColorRGBToHLS() function of the module wrapped by the receiver.
	Helpstring: Converts colors from RGB to hue-luminance-saturation (HLS) format

		void __stdcall ColorRGBToHLS(
			COLORREF clrRGB,
			WORD* pwHue,
			WORD* pwLuminance,
			WORD* pwSaturation);"

	<stdcall: void ColorRGBToHLS dword word* word* word*>
	^self invalidCall!

pathCombine: szDest lpszDir: lpszDir lpszFile: lpszFile
	"Invoke the PathCombine() function of the module wrapped by the receiver.
	Helpstring: Concatenates two strings that represent properly formed paths into one path, as well as any relative path pieces

		LPCSTR __stdcall PathCombine(
			LPSTR szDest,
			LPCSTR lpszDir,
			LPCSTR lpszFile);"

	<stdcall: lpstr PathCombineA lpstr lpstr lpstr>
	^self invalidCall!

pathCommonPrefix: pszFile1 pszFile2: pszFile2 achPath: achPath
	"Invoke the PathCommonPrefix() function of the module wrapped by the receiver.
	Helpstring: Compares two paths to determine if they share a common prefix. A prefix is one of these types: 'C:', '.', '..', '..'. 

		int __stdcall PathCommonPrefix(
			LPCSTR pszFile1,
			LPCSTR pszFile2,
			LPSTR achPath);"

	<stdcall: sdword PathCommonPrefixA lpstr lpstr lpstr>
	^self invalidCall!

pathCompactPath: hdc pszPath: pszPath dx: dx
	"Invoke the PathCompactPath() function of the module wrapped by the receiver.
	Helpstring: Truncates a file path to fit within a given pixel width by replacing path components with ellipses

		BOOL __stdcall PathCompactPath(
			HDC HDC,
			LPSTR pszPath,
			UINT dx);"

	<stdcall: bool PathCompactPathA handle lpstr dword>
	^self invalidCall!

pathCompactPathEx: pszOut pszSrc: pszSrc cchMax: cchMax dwFlags: dwFlags
	"Invoke the PathCompactPathEx() function of the module wrapped by the receiver.
	Helpstring: Truncates a path to fit within a certain number of characters by replacing path components with ellipses

		BOOL __stdcall PathCompactPathEx(
			LPSTR pszOut,
			LPCSTR pszSrc,
			UINT cchMax,
			DWORD dwFlags);"

	<stdcall: bool PathCompactPathExA lpstr lpstr dword dword>
	^self invalidCall!

pathFindNextComponent: pszPath
	"Invoke the PathFindNextComponent() function of the module wrapped by the receiver.
	Helpstring: Parses a path for the next path component. Paths are delimited by backslashes or by the NULL at the end of the path

		LPCSTR __stdcall PathFindNextComponent(
			LPCSTR pszPath);"

	<stdcall: lpstr PathFindNextComponentA lpstr>
	^self invalidCall!

pathIsRelative: pszPath
	"Invoke the PathIsRelative() function of the module wrapped by the receiver.
	Helpstring: Searches a path and determines if it is relative

		BOOL __stdcall PathIsRelative(
			LPCSTR pszPath);"

	<stdcall: bool PathIsRelativeA lpstr>
	^self invalidCall!

pathIsRoot: pszPath
	"Invoke the PathIsRoot() function of the module wrapped by the receiver.
	Helpstring: Parses a path to determine if a root directory path part exists

		BOOL __stdcall PathIsRoot(
			LPCSTR pszPath);"

	<stdcall: bool PathIsRootA lpstr>
	^self invalidCall!

pathIsURL: pszPath
	"Invoke the PathIsURL() function of the module wrapped by the receiver.
	Helpstring: Tests a given string to determine if it conforms to the URL format. This function does not verify that the path points to an existing site only that it is a legal URL format

		BOOL __stdcall PathIsURL(
			LPCSTR pszPath);"

	<stdcall: bool PathIsURLA lpstr>
	^self invalidCall!

pathParseIconLocation: pszIconFile
	"Invoke the PathParseIconLocation() function of the module wrapped by the receiver.
	Helpstring: Parses a file location string for its file component and icon index

		int __stdcall PathParseIconLocation(
			LPSTR pszIconFile);"

	<stdcall: sdword PathParseIconLocationA lpstr>
	^self invalidCall!

pathRelativePathTo: pszPath pszFrom: pszFrom dwAttrFrom: dwAttrFrom pszTo: pszTo dwAttrTo: dwAttrTo
	"Invoke the PathRelativePathTo() function of the module wrapped by the receiver.
	Helpstring: Creates a relative path from two paths

		BOOL __stdcall PathRelativePathTo(
			LPSTR pszPath,
			LPCSTR pszFrom,
			DWORD dwAttrFrom,
			LPCSTR pszTo,
			DWORD dwAttrTo);"

	<stdcall: bool PathRelativePathToA lpstr lpstr dword lpstr dword>
	^self invalidCall!

pathRemoveExtension: pszPath
	"Invoke the PathRemoveExtension() function of the module wrapped by the receiver.
	Helpstring: Removes the file extension from a path, if there is one

		void __stdcall PathRemoveExtension(
			LPSTR pszPath);"

	<stdcall: void PathRemoveExtensionA lpstr>
	^self invalidCall!

pathSetDlgItemPath: hDlg id: id pszPath: pszPath
	"Invoke the PathSetDlgItemPath() function of the module wrapped by the receiver.
	Helpstring: Sets the text of a child control in a window or dialog box, using PathCompactPath to make sure the path fits in the control

		void __stdcall PathSetDlgItemPath(
			HWND hDlg,
			int id,
			LPCSTR pszPath);"

	<stdcall: void PathSetDlgItemPathA handle sdword lpstr>
	^self invalidCall!

shMessageBoxCheck: hwnd pszText: pszText pszTitle: pszTitle uType: uType iDefault: iDefault pszRegVal: pszRegVal
	"Invoke the SHMessageBoxCheck() function of the module wrapped by the receiver.
	Helpstring: Displays a message box that gives the user the option of suppressing further occurrences

		int __stdcall SHMessageBoxCheck(
			[in]HWND HWND,
			[in]LPCSTR pszText,
			[in]LPCSTR pszTitle,
			[in]UINT uType,
			[in]int iDefault,
			[in]LPCSTR pszRegVal);"

	<stdcall: sdword 185 handle lpstr lpstr dword sdword lpstr>
	^self invalidCall! !

VersionLibrary comment:
'VersionLibrary is the <ExternalLibrary> class to represent the Win32 version library, VERSION.DLL.

The version libraries API is somewhat esoteric and best accessed via the services of the VersionInfo class.
'!
!VersionLibrary class methodsFor!

fileName
	"Answer the file name of the external library which the receiver represents."

	^'Version'
! !

!VersionLibrary methodsFor!

getFileVersionInfo: lpstrFilename 
	"Private - Answer file version info for the specified file."

	| dwHandle size buf |
	dwHandle := DWORDBytes new.
	size := self getFileVersionInfoSize: lpstrFilename lpdwHandle: dwHandle.
	size == 0 ifTrue: [^self systemError].
	buf := ByteArray newFixed: size.
	(self 
		getFileVersionInfo: lpstrFilename
		dwHandle: dwHandle asParameter
		dwLen: size
		lpData: buf) ifFalse: [^self systemError].
	^buf!

getFileVersionInfo: lpstrFilename dwHandle: dwHandle dwLen: dwLen lpData: lpData
	"Returns version information about the specified file.
		BOOL GetFileVersionInfo( 
			LPTSTRlptstrFilename,	// pointer to filename string	
			DWORDdwHandle,	// ignored	
			DWORDdwLen,	// size of buffer	
			LPVOIDlpData	// pointer to buffer to receive file-version info.	
		);"

	<stdcall: bool GetFileVersionInfoA lpstr dword dword lpvoid>
	^self invalidCall
!

getFileVersionInfoSize: lpstrFilename lpdwHandle: aDWORD
	"Answer the size of the version information reported by the host OS.

		DWORD GetFileVersionInfoSize( 
			LPTSTRlptstrFilename,	// pointer to filename string	
			LPDWORDlpdwHandle	// pointer to variable to receive zero	
		);"

	<stdcall: dword GetFileVersionInfoSizeA lpstr DWORD* >
	^self invalidCall
!

verQueryValue: pBlock lpSubBlock: lpstrSubBlock lplpBuffer: lplpBuffer puLen: puLen
	"Query selected version information from the specified version information resource
		BOOL VerQueryValue( 
			const LPVOIDpBlock,	// address of buffer for version resource	
			LPTSTRlpSubBlock,	// address of value to retrieve	
			LPVOID*lplpBuffer,	// address of buffer for version value pointer	
			PUINTpuLen	// address of length buffer	
		);" 

	<stdcall: bool VerQueryValueA lpvoid lpstr lppvoid DWORD* >
	^self invalidCall

! !

WinMMLibrary comment:
''!
!WinMMLibrary class methodsFor!

fileName
	"Answer the file name of the external library which the receiver represents."

	^'WinMM'! !

!WinMMLibrary methodsFor!

mciGetErrorString: code lpszErrorText: returnString cchErrorText: retsize
	"Convert an MCI error code into a String.
	Answer whether the conversion succeeded.
  		BOOL mciGetErrorString(DWORD fdwError, LPTSTR lpszErrorText, UINT cchErrorText);"

	<stdcall: bool mciGetErrorStringA dword lpvoid dword>
	^self invalidCall!

mciSendString: commandString
	"Send an MCI command, ignoring any return."

	^self mciSendString: commandString lpszReturnString: nil cchReturn: 0 hwndCallback: nil!

mciSendString: commandString lpszReturnString: returnString cchReturn: retsize hwndCallback: hWnd
	"Send a command string to an MCI device.
	Answers zero or an error encoded in the low-word (generic) or
	high-word (device specific).
	
	MCIERROR mciSendString(LPCTSTR lpszCommand, LPTSTR lpszReturnString,
		UINT cchReturn, HANDLE hwndCallback);"

	<stdcall: dword mciSendStringA lpvoid lpvoid dword handle>
	^self invalidCall!

playSound: aString hmod: anExternalHandle fdwSound: anInteger
	"Plays a sound specified by the given filename, resource, or system event. 
	A system event may be associated with a sound in the registry. 
	Answers whether successful.
			
		BOOL PlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);"

	<stdcall: bool PlaySoundA lpvoid handle dword>
	^self invalidCall!

timeGetDevCaps: ptc cbtc: anInteger
	"Query the timer device to determine its capabilities (resoluation and maximum)
  
		MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);"

	<stdcall: dword timeGetDevCaps void* dword>
	^self invalidCall!

timeGetTime

	<stdcall: dword timeGetTime>
	^self invalidCall! !

CRTLibrary comment:
'CRTLibrary is the <ExternalLibrary> class to represent the MS C run-time library, MSVCRT.DLL.

The C runtime library is linked with the VM and is therefore permanently available. It provides many useful services (some of which are not wrapped at present) and is used quite extensively by the base image to avoid re-inventing the wheel and to keep the image size down.

If there is a function of the C runtime library which you wish to make use of then you should add it using the existing methods as a guide. It is possible to call vararg functions, but you may need to add a number of methods with increasing numbers of arguments. Note that all the functions use the cdecl calling convention.'!
!CRTLibrary class methodsFor!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^File splitStemFrom: (self default fileName)!

open
	"Answer a new instance of the receiver to represent the CRT DLL."

	^(self fromHandle: VMLibrary default crtHandle) initialize! !

!CRTLibrary methodsFor!

__iscsym: aCharacter
	"Answer whether the argument is a letter, underscore, or digit.
		int __iscsym(int c)"

	<cdecl: bool __iscsym char>
	^self invalidCall
!

__iscsymf: aCharacter
	"Answer whether the argument is a letter or underscore.
		int __iscsymf(int c)"

	<cdecl: bool __iscsymf char>
	^self invalidCall
!

_chdir: aDirectoryString
	"Change the cuyrrent working directoryto aDirectoryNameString

		int _chdir( const char *dirname);"

	<cdecl: sdword _chdir lpstr>
	^self invalidCall!

_chmod: aFilenameString pmode: aModeInteger
	"Change the file-permission settings of aFilenameString to aModeInteger

		int _chmod( const char *filename, int pmode );"

	<cdecl: sdword _chmod lpstr sdword>
	^self invalidCall!

_clearfp 
	"Clear and return the floating point status word

		unsigned int _clearfp( void );"

	<cdecl: dword _clearfp>
	^self invalidCall!

_controlfp: newInteger mask: maskInteger
	"Get and set the floating-point control word.

		unsigned int _controlfp( unsigned int new, unsigned int mask );"

	<cdecl: dword _controlfp dword dword>
	^self invalidCall!

_dup: anInteger
	"Duplicate a file handle
		int_dup( int handle );"

	<cdecl: sdword _dup sdword>
	^self invalidCall
!

_dup2: anInteger handle2: anInteger2
	"Duplicate a file handle
		int _dup2(int handle1, int handle2);"

	<cdecl: sdword _dup2 sdword sdword>
	^self invalidCall
!

_ecvt: aFloat count: anInteger dec: decInteger sign: signInteger
	"Answer a String representation of the argument, aFloat, with anInteger significant figures.
	decInteger and signInteger receive the position of the decimal point and the sign of
	aFloat respectively.

		char *_ecvt( double value, int count, int *dec, int *sign );"
  
	<cdecl: lpstr _ecvt double sdword SDWORD* SDWORD* >
	^self invalidCall!

_eof: handleInteger
	<cdecl: sdword _eof sdword>
	^self invalidCall!

_errno
	"Answer a pointer to the errno variable."

	<cdecl: sdword _errno>
	^self invalidCall!

_fcvt: aFloat count: anInteger dec: decInteger sign: signInteger
	"Answer a String representation of the argument, aFloat, with anInteger decimal places.
	decInteger and signInteger receive the position of the decimal point and the sign of
	aFloat respectively.

		char *_fcvt( double value, int count, int *dec, int *sign );"
  
	<cdecl: lpstr _fcvt double sdword SDWORD* SDWORD* >
	^self invalidCall!

_fdopen: anInteger mode: aString
	"Associate a stream with an open file handle.
		FILE *_fdopen( int handle, const char *mode );
	Note that we treat the stdio FILE* pointer as an opaque handle, as these
	are automatically nulled on image load."

	<cdecl: handle _fdopen sdword lpstr>
	^self invalidCall!

_filelength: handleInteger
	<cdecl: sdword _filelength sdword>
	^self invalidCall!

_fileno: aFILE
	"Answer the <integer> file number of a CRT FILE stream."

	<cdecl: sdword _fileno handle>
	^self invalidCall!

_gcvt: aFloat count: anInteger buffer: aString
	"Answer a String representation of the argument, aFloat, with anInteger significant
	figures. Includes a sign (if negative) and decimal point. Exponential format may be used.
	Buffer size should be sufficient to accommodate signed exponential representation with
	decimal point. aString is overwritten with the printable representation, but the answer
	is a new String of the correct size.

		char *_gcvt( double value, int count, char* buffer)"
  
	<cdecl: char* _gcvt double sdword char*>
	^self invalidCall!

_getcwd: buffer maxlen: maxlen
	"Copy up to <integer>, maxlen>, characters of the the current working directory 
	path to the <String> buffer."
  
	<cdecl: lpstr _getcwd lpstr sdword>
	^self invalidCall!

_i64toa: aSmallInteger string: aString radix: anInteger
	"Answer the String representation of a 64-bit Integer."

	<cdecl: lpstr _i64toa sqword lpstr sdword>
	^self invalidCall!

_isnan: aFloat
	"Answer whether the argument is NaN (Not a Number)."

	<cdecl: bool _isnan double>
	^self invalidCall!

_logb: aFloat
	"Answer the exponent of the argument, aFloat."

	<cdecl: double _logb double>
	^self invalidCall!

_ltoa: aSmallInteger string: aString radix: anInteger
	"Answer the String representation of a 32-bit Integer."

	<cdecl: lpstr _ltoa sdword lpstr sdword>
	^self invalidCall!

_makepath: path drive: drive dir: dir fname: fname ext: ext
	"Compose a path name from its constituent components.

		void _makepath(char* path, const char* drive, const char* dir, const char* fname, const char* ext);
	"

	<cdecl: void _makepath char* char* char* char* char*>
	^self invalidCall!

_open_osfhandle: osfhandle flags: flags
	<cdecl: sdword _open_osfhandle handle sdword>
	^self invalidCall!

_putenv: aString
	<cdecl: sdword _putenv lpstr>
	^self invalidCall
!

_rotl: anUnsignedlInteger shift: anInteger
	"Answer anUnsignedInteger bit rotated left by anInteger bits."

	<cdecl: dword _rotl dword sdword>
	^self invalidCall!

_rotr: anUnsignedlInteger shift: anInteger
	"Answer anUnsignedInteger bit rotated right by anInteger bits."

	<cdecl: dword _rotr dword sdword>
	^self invalidCall!

_setmode: fd mode: modeFlag
	<cdecl: sdword _setmode sdword sdword>
	^self invalidCall!

_snprintf: buffer count: maxbuf format: format with: arg
	"Private - Write data formatted by the format string into the buffer.
	see _snprintf:count:format:with:with:with: for further information."

	<cdecl: sdword _snprintf lpvoid intptr lpstr lpvoid>
	^self invalidCall!

_snprintf: buffer count: maxbuf format: format with: arg1 with: arg2
	"Private - Write data formatted by the format string into the buffer.
	see _snprintf:count:format:with:with:with: for further information."

	<cdecl: sdword _snprintf lpvoid intptr lpstr lpvoid lpvoid>
	^self invalidCall!

_spawnvp: mode cmdname: aString argv: argv
	"Spawn a new process.

		int _spawnv( int mode, const char *cmdname, const char *const *argv );

	Implementation Note: Overlapped so as to block only the calling process, as the
	spawned external process may run for a lengthy time.
	"

	<overlap cdecl: sdword _spawnvp sdword lpstr lpvoid>
	^self invalidCall

"
[CRTLibrary default _spawnvp: 0 cmdname: 'command.com' argv: DWORD new.0] fork
"!

_splitpath: path drive: drive dir: dir fname: fname ext: ext
	"Break a path name into its constituent components.

		void _splitpath(const char* path, char* drive, char* dir, char* fname, char* ext);

	Any of the output components (drive, dir, fname, ext), can be nil if that components
	is not required.
	"

	<cdecl: void _splitpath char* char* char* char* char*>
	^self invalidCall!

_stricmp: string1 string2: string2
	"Answer the result of a case insensitive string comparison between string1 and string2,
	answer <0, 0, or >0 according to whether string1 is lexicographically less than, 
	equal to, or greater than string2."

	<cdecl: sdword _stricmp lpstr lpstr>
	^self invalidCall!

_stricoll: string1 string2: string2
	"Answer the result of a case insensitive string comparison between string1 and string2,
	answer <0, 0, or >0 according to whether string1 is lexicographically less than, 
	equal to, or greater than string2."

	<cdecl: sdword _stricoll lpstr lpstr>
	^self invalidCall!

_strnicmp: string1 string2: string2 count: count 
	"Answer the result of a case insensitive string comparison between string1 and
	string2,comparing only the first, count, characters. Answer <0, 0, or >0 according to
	whether the first count characters of are lexicographically less than, equal to, or greater
	than the first count characters of string2."

	<cdecl: sdword _strnicmp lpstr lpstr intptr>
	^self invalidCall!

_strrev: aString
	"Answer aString, reversed.

		char *_strrev( char *string );

	N.B. We ignore the return value, as it will be a pointer to the argument,
	and the functions works 'in-place'"

	<cdecl: void _strrev lpstr>
	^self invalidCall
!

acos: aFloat
	"Answer the arccosine of the argument, aFloat.

		double acos( double x );"

	<cdecl: double acos double>
	^self invalidCall!

argc
	"Answer the number of arguments passed to the host executable at startup"

	^(self getProcAddress: '__argc') sdwordAtOffset: 0!

argv
	"Answer the array of strings which constitute the command line arguments, 
	starting with the host executable's full path."

	^((self getProcAddress: '__argv') dwordAtOffset: 0) asExternalAddress!

asin: aFloat
	"Answer the arcsine of the argument, aFloat.

		double asin( double x );"

	<cdecl: double asin double>
	^self invalidCall!

atan: aFloat
	"Answer the arctangent of the argument, aFloat.

		double atan( double x );"

	<cdecl: double atan double>
	^self invalidCall!

atan: yFloat x: xFloat
	"Answer the arctangent of the argument, aFloat.

		double atan2( double y, double x );"

	<cdecl: double atan2 double double>
	^self invalidCall!

atoi: aString
	"Convert a String to an integer.

		int atoi( const char *string );"

	<cdecl: sdword atoi lpstr>
	^self invalidCall!

ceil: aFloat
	"Answer the integer nearest the aFloat toward positive infinity.

		double floor( double x );"

	<cdecl: double ceil double>
	^self invalidCall!

close
	"The C-runtime library cannot be closed."

	^false!

connectDescriptor: fdInteger toWinStdHandle: stdHandleInteger mode: modeString
	"Private - Connect the CRT FILE with the descriptor/index, fdInteger, to the standard Win32 OS file
	handle identified by the constant, stdHandleInteger. Answer the handle of the CRT file stream.
	This is necessary to correctly associate CRT stdin/stdout streams with the correct OS file handles after 
	allocating a console in a GUI app. See MSDN article Q105305."

	| fd2 hFile |
	fd2 := CRTLibrary default
				_open_osfhandle: (KernelLibrary default getStdHandle: stdHandleInteger)
				flags: 0.
	fd2 < 0 ifTrue: [CRTError signal].
	hFile := CRTLibrary default _fdopen: fd2 mode: modeString.
	"It seems a bit of a hack to overwrite the CRT structure in this way, but this is what the code in the MSDN
	 article does (a structure assignment)"
	CRTLibrary default 
		memcpy: (self getStdHandle: fdInteger) asInteger 
		src: hFile asInteger 
		count: self sizeofFILE.
	^hFile
!

cos: aFloat
	"Answer the cosine of the argument, aFloat.

		double cos( double x );"

	<cdecl: double cos double>
	^self invalidCall!

decimalSeparator
	"Private - Answer the decimal separator String used by the CRT in the current locale."

	^decimalSeparator!

errno
	"Answer the <integer> value of the last recorded CRT error."

	^self _errno asExternalAddress sdwordAtOffset: 0!

exp: aFloat
	"Answer the exponential of the argument, aFloat.

		double exp( double x );"

	<cdecl: double exp double>
	^self invalidCall!

fabs: aFloat
	"Answer the absolute value of the double precision floating-point argument, aFloat
		double fabs( double x );"

	<cdecl: double fabs double>
	^self invalidCall!

fclose: anAddress
	"Closes the specified stream. Answers 0 if successful.
			int fclose( FILE *stream );"

	<cdecl: sdword fclose handle>
	^self invalidCall!

feof: stream
	<cdecl: sdword feof handle>
	^self invalidCall!

fflush: anExternalAddress 
	<cdecl: sdword fflush handle>
	^self invalidCall!

fgetc: aFILE 
	<overlap cdecl: sdword fgetc handle>
	^self invalidCall!

fgets: buf n: bufsize stream: aFILE
	<overlap cdecl: lpstr fgets lpstr sdword handle>
	^self invalidCall!

floor: aFloat
	"Answer the integer nearest the aFloat toward negative infinity.

		double floor( double x );"

	<cdecl: double floor double>
	^self invalidCall!

fopen: nameString mode: modeString
	"Open the specified file with the specified mode.
	Note that we treat the stdio FILE* pointer as an opaque handle, as these
	are automatically nulled on image load.

			FILE *fopen( const char *filename, const char *mode );"

	<cdecl: handle fopen lpstr lpstr>
	^self invalidCall
!

fputc: charValue stream: aFILE
	<cdecl: sdword fputc sdword handle>
	^self invalidCall!

fread: buffer size: size count: count stream: aFILE
	<overlap cdecl: sdword fread lpvoid intptr intptr handle>
	^self invalidCall!

frexp: x expptr: expptr

	<cdecl: double frexp double sdword*>
	^self invalidCall!

fseek: aFILE offset: offsetInteger origin: originInteger
	<cdecl: sdword fseek handle sdword sdword>
	^self invalidCall!

ftell: aFILE
	"Answer the <integer> position (zero-based) of the CRT FILE stream."

	<cdecl: sdword ftell handle>
	^self invalidCall!

fwrite: data size: sizeInteger count: countInteger stream: aFILE 
	<cdecl: sdword fwrite lpvoid intptr intptr handle>
	^self invalidCall!

getenv: varname
	"Answer a string containing the named environment variable setting, or nil
	if no such environment variable exists. The name comparison is case insensitive.

		char *getenv( const char *varname );"

	<cdecl: lpstr getenv lpstr>
	^self invalidCall
!

getStdHandle: fdInteger
	"Private - Answer the CRT stream (FILE*) handle of the standard file stream with the specified index
	(0 = stdin, 1 = stdout, 2 = stderr)."

	^((CRTLibrary default getProcAddress: '_iob') asInteger
		+ (fdInteger * self sizeofFILE)) asExternalHandle!

initialize
	"Private - Initialize and answer the receiver."

	self synchronizeLocale.
	^self!

iswcntrl: aCharacter
	"Answer whether the argument is a control character.
		int iswcntrl( wint_t c )"

	<cdecl: bool iswcntrl char>
	^self invalidCall
!

iswprint: aCharacter
	"Answer whether the argument is a printable character.
		int iswprint( wint_t c )"

	<cdecl: bool iswprint char>
	^self invalidCall
!

iswpunct: aCharacter
	"Answer whether the argument is a punctuation character.
		int iswpunct( wint_t c )"

	<cdecl: bool iswpunct char>
	^self invalidCall
!

iswspace: aCharacter
	"Answer whether the argument is a white space character.
		int iswspace( wint_t c )"

	<cdecl: bool iswspace char>
	^self invalidCall
!

ldexp: aFloat exp: anInteger
	"Answer xFloat * (2 ** exp)

		double ldexp( double x, int exp );"

	<cdecl: double ldexp double sdword>
	^self invalidCall!

log: aFloat
	"Answer the natural logarithm of the argument, aFloat."

	<cdecl: double log double>
	^self invalidCall!

log10: aFloat
	"Answer the base 10 logarithm of the double precision
	floating point argument, aFloat."

	<cdecl: double log10 double>
	^self invalidCall!

memcmp: buf1 buf2: buf2 count: count
	"Compare the first count bytes in two buffers, answering <0 if buf1 is < buf2, 0 if equal,
	and >0 if buf2 > buf1.

		int memcmp( const void *buf1, const void *buf2, size_t count );"

	<cdecl: sdword memcmp lpvoid lpvoid intptr>
	^self invalidCall!

memcpy: dest src: src count: count
	<cdecl: lpvoid memcpy lpvoid lpvoid intptr>
	^self invalidCall!

memmove: dest src: src count: count
	<cdecl: void* memmove void* void* intptr>
	^self invalidCall!

memset: dest c: c count: count
	"Fill a block of memory.
				void *memset( void *dest, int c, size_t count );
	"

	<cdecl: sdword memset lpvoid sdword intptr>
	^self invalidCall!

modf: aFloat intptr: intFloatOut
	"Splits aFloat into fractional and integer parts. Answer the fractional part.

		double modf( double x, double *intptr );"

	<cdecl: double modf double lpvoid>
	^self invalidCall
!

pow: xFloat y: yFloat
	"Answer xFloat raised to the power of yFloat."

	<cdecl: double pow double double>
	^self invalidCall!

rand
	<cdecl: sdword rand>
	^self invalidCall!

rewind: aFILE
	"Rewind to the beginning of the CRT FILE*.
	Implementation Note: As with other FILE routines, treat the stream argument as an opaque handle."

	<cdecl: void rewind handle>
	^self invalidCall!

setlocale: category locale: localeString
	"Set a specified locale category.

		char *setlocale( int category, const char *locale );	"

	<cdecl: lpstr setlocale sdword lpstr>
	^self invalidCall
!

sin: aFloat
	"Answer the Sine of the argument, aFloat."

	<cdecl: double sin double>
	^self invalidCall!

sizeofFILE
	"Private - Answer the size, in bytes, of the CRT FILE structure."

	^32
!

sqrt: aFloat
	"Answer the square root of the argument, aFloat."

	<cdecl: double sqrt double>
	^self invalidCall!

srand: anInteger 
	<cdecl: void srand dword>
	^self invalidCall!

strcat: strDestination strSource: strSource 
	"Be careful: Buffer overruns a distinct possibility if you use this function!!"

	<cdecl: lpstr strcat lpstr lpstr>
	^self invalidCall!

strcmp: string1 string2: string2 
	"Answer the order between the <String> arguments, string1 and string2.

		int strcmp( const char *string1, const char *string2);
	"

	<cdecl: sdword strcmp lpstr lpstr>
	^self invalidCall!

strcspn: string strCharSet: strCharSet
	<cdecl: dword strcspn lpvoid char*>
	^self invalidCall!

strerror: errno
	"Answer a <readableString> description of the specified <integer> CRT error number."

	<cdecl: lpstr strerror sdword>
	^self invalidCall!

strncmp: string1 string2: string2 count: count
	"Answer the order between the <String> arguments, string1 and string2,
	considering up to <integer>, count, characters.

		int strncmp( const char *string1, const char *string2, size_t count );
	"

	<cdecl: sdword strncmp lpstr lpstr intptr>
	^self invalidCall!

strncpy: strDest strSource: strSource count: count
	"Copy up to count characters of the <String> strSource to the <String> strDest 
	and answer strDest. A null appended if there is sufficient space in the destination 
	buffer. The source and destination must not overlap.

		char *strncpy( char *strDest, const char *strSource, size_t count );
	"

	<cdecl: lpvoid strncpy lpvoid lpvoid intptr>
	^self invalidCall
!

strpbrk: string strCharSet: strCharSet
	"Answer a pointer to the first occurrence of any of the characters
	from the <String>, strCharSet, in the <String>, string.

		char *strpbrk( const char *string, const char *strCharSet 
	"

	<cdecl: char* strpbrk char* char*>
	^self invalidCall
!

synchronizeLocale
	"Private - Synchronize the CRT's locale with the OS locale setting."

	| buf |
	self setlocale: 0 locale: ''.
	buf := String new: 10.
	buf := self _gcvt: Float zero count: 2 buffer: buf.
	decimalSeparator := buf copyFrom: 2

!

tan: aFloat
	"Answer the Tangent of the argument, aFloat."

	<cdecl: double tan double>
	^self invalidCall!

thread_errno
	<overlap cdecl: sdword _errno>
	^self invalidCall!

ungetc: c stream: stream
	"Pushes the character with integer code point, c, back onto the FILE*, stream."

	<cdecl: sdword ungetc sdword handle>
	^self invalidCall!

wcscspn: aUnicodeString strCharSet: strCharSet
	<cdecl: dword wcscspn lpvoid lpwstr>
	^self invalidCall! !

KernelLibrary comment:
'KernelLibrary is the <ExternalLibrary> which represents the Win32 System DLL, KERNEL32.DLL. 

The default instance of this class provides access to most of the base operating system services. New functions may be added as required, but the external function naming convention should be followed.

KernelLibrary is a special case in that its handle is cached by the VM on startup into the VM registry, and it is the means by which all other libraries are opened.

All functions in this library use the stdcall calling convention.'!
!KernelLibrary class methodsFor!

clear
	"Private - Clear down cached external function addresses and any default 
	instances of the receiver from previous runs. etc."

	super clear.
	OSVERSIONINFO clear
!

fileName
	"Answer the host system file name of the external library which
	the receiver represents."

	^'KERNEL32'!

open
	"Answer a new instance of the receiver to represent the Kernel32 DLL. Special handling 
	is required for this library because opening a library is normally done through the 
	receiver's singleton instance. The VM stores the current Kernel32 handle into the 
	VM object registry on startup."

	^self fromHandle: VMLibrary default kernelHandle! !

!KernelLibrary methodsFor!

addAtom: aString
	"The AddAtom function adds a character string to the local atom table and returns a unique value (an atom) identifying the string. 
	Answer the value is the newly created atom or zero if the function fails.

		ATOM AddAtom(
			LPCTSTR  lpString 	// address of string to add 
		);"

	<stdcall: word AddAtomA lpstr>
	^self invalidCall!

allocConsole
	"Allocate a new console.
		BOOL AllocConsole(VOID)"

	<stdcall: bool AllocConsole>
	^self invalidCall!

beep: anInteger dwDuration: dwDuration
	"Generates simple tones on the speaker. 
		BOOL Beep(
  			DWORD dwFreq,	// sound frequency, in hertz 
			DWORD dwDuration 	// sound duration, in milliseconds 
		);
	Implementation Note:  One might be tempted to make this an overlapped
	call, and that might indeed be usful when buzzing for long durations, however
	that would reduce the usefulness of Sound>>bell as a debugging aid by
	slowing it down and introducing the complication of process switching.
	It would also make it unsuitable for use from the idle process, which really
	shouldn't be made to wait on Semaphores (which causes a VM idle panic
	interrupt, handled by starting a new idle process). Of course you can always
	add a new overlapped entry point if you wish."

	<stdcall: bool Beep dword dword>
	^self invalidCall!

beginUpdateResource: fileNameString bDeleteExistingResources: aBoolean
	"BeginUpdateResource returns a handle that can be used by the UpdateResource
	function to add, delete, or replace resources in an executable file. 

	HANDLE BeginUpdateResource(
		LPCTSTR pFileName <>,             // executable file name
		BOOL bDeleteExistingResources <>  // deletion option
		);"

	<stdcall: handle BeginUpdateResourceA lpstr bool>
	^self invalidCall!

close
	"The kernel library cannot be closed."

	^false!

closeHandle: aHandle
	"Close an open Win32 object handle, freeing any resources held by it.
	Once closed a handle is no longer valid. Answer whether the function
	succeeds.	 See Win32 SDK help for more information.

	BOOL CloseHandle(
		HANDLE  hObject 	// handle of object to close  
	);"

	<stdcall: bool CloseHandle handle>
	^self invalidCall
!

copyFile: fromString lpNewFileName: toString bfailIfExists: fail
	"Copies the file named fromString to a file named toString. If
	toString already exists then the copy will only proceed if fail
	is false.

	BOOL	CopyFileA(
		LPCSTR lpExistingFileName,
		LPCSTR lpNewFileName,
		BOOL bFailIfExists
		);"

	<overlap stdcall: bool CopyFileA lpstr lpstr bool>
	^self invalidCall!

createDirectory: path lpSecurityAttributes: aSECURITYATTRIBUTES 
	"Create a new directory with the specified <String> path, 
	answering whether successful.

		BOOL CreateDirectory(
			LPCTSTR lpPathName,
			LPSECURITY_ATTRIBUTES lpSecurityAttributes
		);"

	<stdcall: bool CreateDirectoryA lpstr lpvoid>
	^self invalidCall!

createEvent: aSECURITYATTRIBUTES bManualReset: aBoolManual bInitialState: aBoolState lpName: aStringPathName
	"Answer a new Win32 Event object (for thread synchronisation), with the specified
	security attributes (if aSECURITYATTRIBUTES is nil then the default security 
	attributes are used), mode (manual or automatic), initial state 
	(signalled/not-signalled), and name (if aStringPathName is nil, then unnamed).
	Please see Win32 SDK help for more information."

	"HANDLE CreateEvent(
		LPSECURITY_ATTRIBUTES  lpEventAttributes,	// address of security attributes  
		BOOL  bManualReset,	// flag for manual-reset event 
		BOOL  bInitialState,	// flag for initial state 
		LPCTSTR  lpName 	// address of event-object name  
	);"

	<stdcall: handle CreateEventA lpvoid bool bool lpstr>
	^self invalidCall!

createFile: aStringFileName dwDesiredAccess: anIntegerAccessMode dwSharedMode: anIntegerShareMode 
		lpSecurityAttributes: aSECURITYATTRIBUTES dwCreationDistribution: anIntegerCreateMode 
		dwFlagsAndAttributes: anIntegerAttributeFlag hTemplateFile: aHandle
	"The CreateFile function creates, opens, or truncates a file, pipe, communications resource, disk device,
	or console. Answer a handle that can be used to access the object. It can also open and return a handle to a directory.

	HANDLE CreateFile(
		LPCTSTR lpFileName, // address of name of the file 
		DWORD dwDesiredAccess, // access (read-write) mode 
		DWORD dwShareMode, // share mode 
		LPSECURITY_ATTRIBUTES lpSecurityAttributes, // address of security descriptor 
		DWORD dwCreationDistribution, // how to create 
		DWORD dwFlagsAndAttributes, // file attributes 
		HANDLE hTemplateFile // handle of file with attributes to copy  
	);
	Please see Win32 SDK help for more information."

	<stdcall: handle CreateFileA lpstr dword dword lpvoid dword dword handle>
	^self invalidCall!

createMutex: lpMutexAttributes bInitialOwner: bInitialOwner lpName: lpName
	"Invoke the CreateMutex() function of the module wrapped by the receiver.
	Helpstring: Creates a named or unnamed mutex object

		HANDLE __stdcall CreateMutex(
			[in]void* lpMutexAttributes,
			BOOL bInitialOwner,
			LPSTR lpName);"

	<stdcall: handle CreateMutexA void* bool lpstr>
	^self invalidCall!

createProcess: aStringFileName lpCommandLine: cl lpProcessAttributes: pa lpThreadAttributes: ta
	bInheritsHandles: ih dwCreationFlags: flags lpEnvironment: env lpCurrentDirectory: cd
	lpStartupInfo: si lpProcessInformation: pi

	"The CreateProcess function creates a new process and its primary thread. 
	The new process runs the specified executable file. 

	BOOL CreateProcess(
		LPCTSTR lpApplicationName,  // name of executable module
		LPTSTR lpCommandLine,       // command line string
		LPSECURITY_ATTRIBUTES lpProcessAttributes,  // process security attributes
		LPSECURITY_ATTRIBUTES lpThreadAttributes,   // thread security attributes
		BOOL bInheritHandles,  // handle inheritance flag
		DWORD dwCreationFlags, // creation flags
		LPVOID lpEnvironment,  // pointer to new environment block
		LPCTSTR lpCurrentDirectory,   // pointer to current directory name
		LPSTARTUPINFO lpStartupInfo,  // pointer to STARTUPINFO
		LPPROCESS_INFORMATION lpProcessInformation  // pointer to PROCESS_INFORMATION
	);

 	Please see Win32 SDK help for more information."

	<stdcall: bool CreateProcessA lpstr lpstr SECURITY_ATTRIBUTES* SECURITY_ATTRIBUTES*
		bool dword lpvoid lpstr STARTUPINFO* PROCESS_INFORMATION*>

	^self invalidCall!

debugBreak
	"Invoke the DebugBreak() function of the module wrapped by the receiver.
	Helpstring: Break into a debugger

		void __stdcall DebugBreak();"

	<stdcall: void DebugBreak>
	^self invalidCall!

deleteFile: aStringFileName
	"The DeleteFile function deletes an existing file. Answer true if the function succeeds.

	BOOL DeleteFile(
		LPCTSTR lpFileName // address of name of file to delete  
	);

	If the file does not exist, the DeleteFile function fails.
	Windows 95:
		This function deletes a file even if it is open for normal I/O or as a memory-mapped file.
		To prevent loss of data, close files before attempting to delete them.

	Windows NT:
		This function fails if an application attempts to delete a file that is open for normal I/O or as a memory-mapped file."

	<stdcall: bool DeleteFileA lpstr>
	^self invalidCall!

duplicateHandle: sourceProcHandle hSourceHandle: sourceHandle hTargetProcessHandle: targetProcHandle 
	lpTargetHandle: targetHandle dwDesiredAccess: accessFlagsInteger bInheritHandle: inheritBool
	dwOptions: optionsFlagInteger
		"Duplicate a Win32 handle, sourceHandle, belonging to a Win32 Process, 
		sourceProcHandle, for another Win32 Process, targetProcHandle, writing
		the result into targetHandle, with the specified access (accessFlagsInteger),
		inheritance (inheritBool), and options (optionsFlagInteger). Answer whether
		the functions succeeds or fails. See Win32 SDK help for more information.
		BOOL DuplicateHandle(
			HANDLE  hSourceProcessHandle,	// handle of process with handle to duplicate 
			HANDLE  hSourceHandle,	// handle to duplicate 
			HANDLE  hTargetProcessHandle,	// handle of process to duplicate to 
			LPHANDLE  lpTargetHandle,	// address of duplicate handle 
			DWORD  dwDesiredAccess,	// access for duplicate handle 
			BOOL  bInheritHandle,	// handle inheritance flag
			DWORD  dwOptions 	// optional actions 
		);"
	<stdcall: bool DuplicateHandle handle handle handle lpvoid dword bool dword>
	^self invalidCall
!

endUpdateResource: hUpdate fDiscard: aBoolean
	"EndUpdateResource ends a resource update in an executable file. 
	
	BOOL EndUpdateResource(
		HANDLE hUpdate <>, // update-file handle
		BOOL fDiscard <>   // write option 
		);"

	<stdcall: bool EndUpdateResourceA handle bool>
	^self invalidCall!

enumDateFormats: aCallbackThunk locale: locale dwFlags: dwFlags
	"Enumerates the long or short date formats that are available for the specified locale, including 
	date formats for any alternate calendars. The argument, dwFlags, determines whether the long 
	or short date formats are enumerated. The function enumerates the date formats by passing 
	date format string pointers, one at a time, to the callback thunk, aCallbackThunk, continuing
	until all date formats are enumerated, or the callback returns false.

		BOOL EnumDateFormats(
			DATEFMT_ENUMPROC lpDateFmtEnumProc,	// pointer to enumeration callback function
			LCID Locale,						// locale whose date formats are of interest
			DWORD dwFlags 						// date formats to enumerate
		);"

	<stdcall: bool EnumDateFormatsA lpvoid dword dword>
	^self invalidCall!

enumSystemLocales: aCallbackThunk dwFlags: dwFlags
	"Enumerates the locales that are either installed on or supported by a system, depending on the 
	dwFlags parameter. The callback is invoked repeatedly until all locales are exhausted, or the
	callback function returns false.

		BOOL EnumSystemLocales(
			LOCALE_ENUMPROC lpLocaleEnumProc,	// pointer to enumeration callback function
			DWORD dwFlags 	// indicates which locales to enumerate
		);"

	<stdcall: bool EnumSystemLocalesA lpvoid dword>
	^self invalidCall!

enumTimeFormats: aCallbackThunk locale: locale dwFlags: dwFlags
	"Enumerates the time formats that are available for the specified locale. The function passes
	the time format strings, one at a time, to the callback thunk, aCallbackThunk, continuing
	until all time formats are enumerated, or the callback returns false.

		BOOL EnumTimeFormats(
			TIMEFMT_ENUMPROC lpTimeFmtEnumProc,	// pointer to enumeration callback function
			LCID Locale,						// locale whose time formats are of interest
			DWORD dwFlags 						// unused
		);"

	<stdcall: bool EnumTimeFormatsA lpvoid dword dword>
	^self invalidCall!

expandEnvironmentStrings: aString 
	"Answer the <String> result of replacing environment-variable references of the form
	%VariableName% with their defined values."

	| answer size |
	aString isEmpty ifTrue: [^aString].
	size := self 
				expandEnvironmentStrings: aString
				lpDst: nil
				nSize: 0.
	size = 0 ifTrue: [self systemError].
	"If the function succeeds, the return value is the number of TCHARs stored in the
	destination buffer, including the terminating null character, but in fact it is off by one."
	answer := String newFixed: size-2.
	(self 
		expandEnvironmentStrings: aString
		lpDst: answer
		nSize: size) = 0 
		ifTrue: [self systemError].
	^answer!

expandEnvironmentStrings: lpSrc lpDst: lpDst nSize: bufSize
	"Replace environment-variable strings with their defined values. 
		DWORD ExpandEnvironmentStrings(
			LPCTSTR lpSrc,
			LPTSTR lpDst,
			DWORD nSize);"

	<stdcall: dword ExpandEnvironmentStringsA lpstr lpstr dword>
	^self invalidCall!

fileTimeToLocalTime: lpFileTime lpLocalFileTime: lpLocalFileTime
	"Convert a UTC FILETIME to a local FILETIME, answering whether the conversion succeeded.
		BOOL FileTimeToLocalTime(
  			CONST FILETIME *lpFileTime,	// pointer to UTC file time to convert 
			LPFILETIME lpLocalFileTime		// pointer to structure to receive local time  
		);
	Implenentation Note: In order to prevent FILETIME>>displayOn: acting as the root of a 
	dependency tree which keeps FILETIME and SYSTEMTIME in the image regardless of
	whether they are referenced elsewhere, we have to use void* arguments here to break
	the  dependencies."

	"<stdcall: bool FileTimeToLocalFileTime FILETIME* FILETIME*>"
	<stdcall: bool FileTimeToLocalFileTime void* void*>
	^self invalidCall
!

fileTimeToSystemTime: lpFileTime lpSystemTime: lpSystemTime
	"Convert a FILETIME to a SYSTEMTIME, answering whether the conversion succeeded.
		BOOL FileTimeToSystemTime(
  			CONST FILETIME *lpFileTime,	// pointer to file time to convert 
			LPSYSTEMTIME lpSystemTime 		// pointer to structure to receive system time  
		);

	Implenentation Note: In order to prevent FILETIME>>displayOn: acting as the root of a 
	dependency tree which keeps FILETIME and SYSTEMTIME in the image regardless of
	whether they are referenced elsewhere, we have to use void* arguments here to break
	the  dependencies."

	"<stdcall: bool FileTimeToSystemTime FILETIME* SYSTEMTIME*>"
	<stdcall: bool FileTimeToSystemTime void* SYSTEMTIME*>
	^self invalidCall!

findClose: hFindFile
	"Close the specified find file handle returned by a previous call to FindFirstFile().

		BOOL FindClose( 
			HANDLE hFindFile
		);"

	<stdcall: bool FindClose handle>
	^self invalidCall!

findFirstFile: lpFileName lpFindFileData: aWIN32_FIND_DATA
	"Search a directory for a file or subdirectory whose name matches the specified filename.

		HANDLE FindFirstFile( 
			LPCTSTR lpFileName, 
			LPWIN32_FIND_DATA lpFindFileData 
		);"

	<stdcall: handle FindFirstFileA lpstr WIN32_FIND_DATA* >
	^self invalidCall!

findNextFile: hFindFile lpFindFileData: aWIN32_FIND_DATA
	"Continue a file search initiated by a previous call to FindFirstFile()
	which returned the handle, hFindFile. Answer whether the call succeeded.
	No more files is determined by a false return value with GetLastError()
	returning ERROR_NO_MORE_FILES.

		BOOL FindNextFile( 
			HANDLE hFindFile, 
			LPWIN32_FIND_DATA lpFindFileData 
		);"

	<stdcall: bool FindNextFileA handle WIN32_FIND_DATA* >
	^self invalidCall!

findResource: anInstanceHandle lpName: anIntegerId lpType: anIntegerType
	"Determine the location of a resource with the specified type and name in the specified module. 
		HRSRC FindResource(
  			HMODULE hModule,	// resource-module handle 
			LPCTSTR lpName,	// pointer to resource name  
			LPCTSTR lpType 	// pointer to resource type 
		);"

	<stdcall: handle FindResourceA handle lpvoid lpvoid>
	^self invalidCall
!

flushFileBuffers: aHandle
	"The FlushFileBuffers function clears the buffers for the specified file
	and causes all buffered data to be written to the file. 
	Answer a boolean indicating if the operation was successful.

	BOOL FlushFileBuffers(
		HANDLE hFile // open handle to file whose buffers are to be flushed 
		);"

	<stdcall: bool FlushFileBuffers handle>
	^self invalidCall

!

formatMessage: dwFlags lpSource: aStringOrHandleOrNil dwMessageId: dwMessageId dwLanguageId: dwLanguageId lpBuffer: aBufString nSize: nBufSize arguments: vaArgs 
	"Format a message string from a message definition, from the format string or module handle specified
	by the argument, aStringOrHandleOrNil. If the flags specify a system message, aStringOrHandle may be nil,
	and the function finds the appropriate message in the system message table resource.
	The function copies the formatted message text to an output buffer, populating any embedded insert 
	sequences with arguments from vaArgs if requested.
		DWORD FormatMessage(
			DWORD dwFlags,	// source and processing options 
			LPCVOID lpSource,	// pointer to  message source 
			DWORD dwMessageId,	// requested message identifier 
			DWORD dwLanguageId,	// language identifier for requested message 
			LPTSTR lpBuffer,	// pointer to message buffer 
			DWORD nSize,	// maximum size of message buffer 
			va_list *Arguments 	// address of array of message inserts 
		);"

	<stdcall: dword FormatMessageA dword lpvoid dword dword lpvoid dword lpvoid>
	^self invalidCall!

formatMessage: messageId source: aHandleOrString flags: dwFlag withArguments: arguments 
	"Answer a <readableString> which is a message formatted from the specified Win32 format
	string (see Win32 help) and the arguments in the <sequencedReadableCollection>, arguments,
	which will be substitued for the argument identified as %1..%n in the format string."

	| ptr len msg args |
	ptr := ExternalMemory new.
	args := ByteArray new: arguments size * VMConstants.IntPtrSize.
	arguments keysAndValuesDo: 
			[:i :a | 
			args uintPtrAtOffset: (i - 1) * VMConstants.IntPtrSize
				put: (a isInteger ifTrue: [a] ifFalse: [a yourAddress])].
	len := self
				setLastError: 0;
				formatMessage: (dwFlag bitOr: ##(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY))
					lpSource: aHandleOrString
					dwMessageId: messageId
					dwLanguageId: 0
					lpBuffer: ptr basicYourAddress
					nSize: 0
					arguments: args.	"To enable us to distinguish the error case from the empty string case"

	"FormatMessage() unhelpfully treats the empty string result as an error, so we must handle specially."
	len == 0 
		ifTrue: 
			[| err |
			err := self getLastError.
			err ~~ 0 ifTrue: [self systemError: err].
			msg := String new]
		ifFalse: 
			[msg := String fromAddress: ptr length: len.
			ptr free].
	^msg

	"
'Blah %1 blah %2!!d!!' formatWithArguments: #('abc' 123)
"!

freeConsole
	"Detach from the current console.
		BOOL FreeConsole(VOID)"
  
	<stdcall: bool FreeConsole>
	^self invalidCall!

freeLibrary: anExternalHandle
	<stdcall: bool FreeLibrary handle>
	^self invalidCall!

getACP
	"Invoke the GetACP() function of the module wrapped by the receiver.
	Helpstring: Retrieves the current ANSI code-page identifier for the system

		UINT __stdcall GetACP();"

	<stdcall: dword GetACP>
	^self invalidCall!

getAtomName: id lpBuffer: aString nSize: anInteger
	"The GetAtomName function retrieves a copy of the character string associated with the specified local atom.
	This function replaces the GetAtomHandle function. 

		UINT GetAtomName(
			ATOM  nAtom,		// atom identifying character string 
			LPTSTR  lpBuffer,	// address of buffer for atom string  
			int  nSize 		// size of buffer 
			);	

	Return Value
	If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.
	If the function fails, the return value is zero. To get extended error information, call GetLastError."

	<stdcall: dword GetAtomNameA word lpstr sdword>
	^self invalidCall
!

getCommandLine
	"Answer a pointer to the command-line string.

		LPTSTR GetCommandLine(VOID)"
  
	<stdcall: lpstr GetCommandLineA>
	^self invalidCall!

getComputerName: buffer nSize: pBufSize
	"Retrieves the computer name of the current system into the argument, buffer (which must be large
	enough to contain MAX_COMPUTERNAME_LENGTH+1 characters). Answers whether the name
	was successfully retrieved. If successful then the value of pBufSize will be the number of characters
	in the name.

		BOOL GetComputerName(
			LPTSTR lpBuffer,	// address of name buffer 
			LPDWORD nSize 		// address of size of lpBuffer
		);"

	<stdcall: bool GetComputerNameA lpstr DWORD* >
	^self invalidCall

!

getCPInfo: codepage lpCPInfo: lpCPInfo
	"Invoke the GetCPInfo() function of the module wrapped by the receiver.
	Helpstring: Retrieves the current original equipment manufacturer (OEM) code-page identifier for the system

		BOOL __stdcall GetCPInfo(
			UINT codepage,
			CPINFO* lpCPInfo);"

	<stdcall: bool GetCPInfo dword CPINFO*>
	^self invalidCall!

getCurrentProcess
	"Answer handle of the Dolphin process.

		HANDLE GetCurrentProcess()"

	<stdcall: handle GetCurrentProcess>
	^self invalidCall
 !

getCurrentThread
	"Answer the handle of the current thread

		DWORD GetCurrentThread()"

	<stdcall: handle GetCurrentThread>
	^self invalidCall
 !

getCurrentThreadId
	"Answer thread identifier of the currently executing thread (like Processor activeProcess).

		DWORD GetCurrentThreadId(VOID)"

	<stdcall: dword GetCurrentThreadId>
	^self invalidCall
 !

getDateFormat: locale dwFlags: dwFlags lpDate: aWinSYSTEMTIME lpFormat: formatString lpDateStr: outputStringOutput cchDate: anInteger
	"Format a date as a date string for a specified locale. If formatString is null then the current locale 
	is used. If aWinSYSTEMTIME is null then the current local date is used.

		int GetDateFormat(
			LCID  Locale,	// locale for which date is to be formatted 
			DWORD  dwFlags,	// flags specifying function options 
			CONST SYSTEMTIME *  lpDate,	// date to be formatted 
			LPCTSTR  lpFormat,	// date format string 
			LPTSTR  lpDateStr,	// buffer for storing formatted string 
			int  cchDate 	// size of buffer 
		);"

	"Avoid creating indirect ref. to SYSTEMTIME from its own #displayOn: by using void* parm instead"
	<stdcall: sdword GetDateFormatA dword dword void* lpstr lpstr sdword>
	^self invalidCall

!

getDiskFreeSpace: lpRootPathName
	lpSectorsPerCluster: lpSectorsPerCluster
	lpBytesPerSector: lpBytesPerSector
	lpNumberOfFreeClusters: lpNumberOfFreeClusters
	lpTotalNumberOfClusters: lpTotalNumberOfClusters
	"
		BOOL GetDiskFreeSpace( 
			LPCTSTR lpRootPathName,
			LPDWORD lpSectorsPerCluster,
			LPDWORD lpBytesPerSector,
			LPDWORD lpNumberOfFreeClusters,
			LPDWORD lpTotalNumberOfClusters
		);
	"

	<stdcall: bool GetDiskFreeSpaceA lpstr dword* dword* dword* dword*>
	^self invalidCall!

getDiskFreeSpaceEx: lpDirectoryName
	lpFreeBytesAvailable: lpFreeBytesAvailable
	lpTotalNumberOfBytes: lpTotalNumberOfBytes
	lpTotalNumberOfFreeBytes: lpTotalNumberOfFreeBytes
	"
		BOOL GetDiskFreeSpaceEx( 
			LPCTSTR lpDirectoryName,
			LPQWORD  lpFreeBytesAvailable,
			LPQWORD lpTotalNumberOfBytes,
			LPQWORD lpTotalNumberOfFreeBytes
		);
	"

	<stdcall: bool GetDiskFreeSpaceExA lpstr qword* qword* qword*>
	^self invalidCall!

getEnvironmentVariable: nameString lpBuffer: bufString nSize: bufSize
	"Populate bufString with the value of the specified environment variable.
		DWORD GetEnvironmentVariable(
			LPCTSTR lpName,	// address of environment variable name 
			LPTSTR lpBuffer,	// address of buffer for variable value 
			DWORD nSize 	// size of buffer, in characters 
		);"

	<stdcall: dword GetEnvironmentVariableA lpstr lpstr dword>
	^self invalidCall!

getFileAttributes: aFileName
	"Answer attributes for the specified file or directory. 
		DWORD GetFileAttributes(
			LPCTSTR  lpFileName 	// address of the name of a file or directory  
		);"

	<stdcall: sdword GetFileAttributesA lpstr>
	^self invalidCall!

getFileSize: aHandle lpFileSizeHigh: aDWORD
	"Answers the low-order dword of the size, in bytes, of the specified file. 

		DWORD GetFileSize(
			HANDLE hFile, // handle of file to get size of
			LPDWORD lpFileSizeHigh, // address of high-order word for file size if required.
		);"

	<stdcall: dword GetFileSize handle lpvoid >
	^self invalidCall!

getFileTime: hFile 
		lpCreationTime: lpCreationTime 
		lpLastAccessTime: lpLastAccessTime 
		lpLastWriteTime: lpLastWriteTime
	"Answer file times for the File with the specified handle.
		BOOL GetFileTime(
			HANDLE hFile, // 
			LPFILETIME lpCreationTime, 
			LPFILETIME lpLastAccessTime, 
			LPFILETIME lpLastWriteTime 
		);"

	<stdcall: bool GetFileTime handle FILETIME* FILETIME* FILETIME*>
	^self invalidCall!

getFullPathName: fname nBufferLength: anInteger lpBuffer: path lpFilePart: aDWORD
	"Retrieves the full path and filename of the file with name fname, into the buffer, path.

		DWORD GetFullPathName(
  			LPCTSTR  lpFileName,	// address of name of file to find path for 
			DWORD  nBufferLength,	// size, in characters, of path buffer 
			LPTSTR  lpBuffer,		// address of path buffer 
			LPTSTR  *lpFilePart 	// address of filename in path 
		);"

	<stdcall: dword GetFullPathNameA lpstr dword lpstr lpvoid>
	^self invalidCall!

getLastError
	"Answer the last Win32 error code which occurred.
		DWORD GetLastError(VOID)"
  
	<stdcall: dword GetLastError>
	^self invalidCall!

getLocaleInfo: locale lCType: lcType lpLCData: outputStringOutput cchData: anInteger
	"Answer information about a locale. 
		int GetLocaleInfo(
	  		LCID  Locale,		// locale identifier 
			LCTYPE  LCType,	// type of information 
			LPTSTR  lpLCData,	// address of buffer for information 
			int  cchData 		// size of buffer 
		);"

	<stdcall: sdword GetLocaleInfoA dword dword lpstr sdword>
	^self invalidCall!

getLocalTime: aWinSYSTEMTIME
	"Retrieve the current local date and time.
		VOID GetLocalTime(
  			LPSYSTEMTIME  lpSystemTime 	// address of system time structure  
		);"

	<stdcall: void GetLocalTime SYSTEMTIME* >
	^self invalidCall!

getModuleFileName: aHandle lpFilename: aString nSize: anInteger
	"Retrieve the full path and filename for the executable file containing the specified module.

		DWORD GetModuleFileName(
  			HMODULE  hModule,		// handle to module to find filename for 
			LPTSTR  lpFilename,	// pointer to buffer for module path 
			DWORD  nSize 			// size of buffer, in characters 
		);"

	<stdcall: dword GetModuleFileNameA handle lpstr dword>
	^self invalidCall


!

getModuleHandle: aString

	<stdcall: handle GetModuleHandleA lpstr>
	^self invalidCall


!

getProcAddress: aHandle lpProcName: aString
	"Answer the address of an exported function with name, aString, in the
	module with handle, aHandle. If the function fails, NULL is returned,
	and #getLastError should be used to retrieve extended error information.

		FARPROC GetProcAddress(
			HMODULE  hModule,	// handle to DLL module  
			LPCSTR  lpProcName 	// name of function 
		);"

	<stdcall: lpvoid GetProcAddress handle lpvoid>
	^self invalidCall!

getProcAddressDWORD: aHandle lpProcName: aString
	"Private - As #getProcAddress:name:, but answers the result as a Windows DWORD (unsigned
	double word). This is useful in conjunction with SetWindowLong() etc."

	<stdcall: dword GetProcAddress handle lpvoid>
	^self invalidCall!

getProcessHeap
	"Answer the handle of the heap of the calling process for use with other
	memory management functions.

		HANDLE GetProcessHeap()"

	<stdcall: handle GetProcessHeap>
	^self invalidCall

  
!

getShortPathName: lpszLongPath lpszShortPath: lpszShortPath cchBuffer: cchBuffer
	"Answers the short pathname form of lpszLongPath in lpszShortPath"

	<stdcall: dword GetShortPathNameA lpstr lpstr dword>
	^self invalidCall!

getStdHandle: nStdHandle
	"Get the handle for the standard input, standard output, or standard error device.
		HANDLE GetStdHandle(
  			DWORD nStdHandle,	// input, output, or error device 
		);"

	<stdcall: handle GetStdHandle dword>
	^self invalidCall!

getSystemDefaultLCID
  	"Answer the system default locale identifier. 

			LCID GetSystemDefaultLCID(VOID)"
  
	<stdcall: dword GetSystemDefaultLCID>
	^self invalidCall!

getSystemDirectory: lpBuffer uSize: uSize
  	"Answer the path of the windows system directory.

		UINT GetSystemDirectory(
			LPTSTR lpBuffer, 
			UINT uSize);"
  
	<stdcall: dword GetSystemDirectoryA lpstr dword>
	^self invalidCall!

getSystemTime: lpSystemTime
	"Invoke the GetSystemTime() function of the module wrapped by the receiver.
	Helpstring: Gets the current system time and date

		void __stdcall GetSystemTime(
			SYSTEMTIME* lpSystemTime);"

	<stdcall: void GetSystemTime SYSTEMTIME*>
	^self invalidCall!

getSystemWindowsDirectory: lpBuffer uSize: uSize 
	"	UINT GetSystemWindowsDirectory(
			LPTSTRlpBuffer, 
			UINTuSize); "

	<stdcall: dword GetSystemWindowsDirectoryA lpstr dword>
	^self invalidCall!

getTempFileName: pathString lpPrefixString: prefixString uUnique: anInteger lpTempFileName: bufferString
	"Generate a temporary file name by concatenating the specified path and prefix strings, and a hexadecimal string formed from 
	the Integer, unique, and the .TMP extension. If anInteger is zero, the function generates a suitable value and creates
	the temporary file in the specified directory, otherwise the function generates the name (using the specified value) but does
	not create the file.

		UINT GetTempFileName(
  			LPCTSTR  lpPathName,		// address of directory name for temporary file 
			LPCTSTR  lpPrefixString,	// address of filename prefix 
			UINT  uUnique,	// number used to create temporary filename 
			LPTSTR  lpTempFileName 	// address of buffer that receives the new filename 
		);"

	<stdcall: dword GetTempFileNameA lpstr lpstr dword lpstr>
	^self invalidCall!

getTempPath: nBufferLength lpBuffer: lpBuffer
	"Populate the <String> buffer, lpBuffer, with the system directory designated for temporary files.
	Answers the number of characters written to the buffer."

	<stdcall: dword GetTempPathA dword lpstr>
	^self invalidCall!

getThreadTimes: hThread lpCreationTime: creationFILETIME lpExitTime: exitFILETIME lpKernelTime: kernelFILETIME lpUserTime: userFILETIME
	"
		BOOL GetThreadTimes(
			HANDLE hThread, 		// handle to thread 
			LPFILETIME lpCreationTime,	// thread creation time 
			LPFILETIME lpExitTime,	// thread exit time 
			LPFILETIME lpKernelTime,	// thread kernel-mode time 
			LPFILETIME lpUserTime	// thread user-mode time );
	"

	<stdcall: bool GetThreadTimes handle FILETIME* FILETIME* FILETIME* FILETIME*>
	^self invalidCall!

getTimeFormat: locale dwFlags: dwFlags lpTime: aWinSYSTEMTIME lpFormat: formatString lpTimeStr: outputStringOutput cchBuf: anInteger
	"Format a time as a date string for a specified locale. If formatString is null then the current locale 
	is used. If aWinSYSTEMTIME is null then the current local time is used.

		int GetTimeFormat(
			LCID  Locale,					// locale for which time is to be formatted 
			DWORD  dwFlags,				// flags specifying function options 
			CONST SYSTEMTIME *  lpTime,	// time to be formatted 
			LPCTSTR  lpFormat,				// time format string 
			LPTSTR  lpTimeStr,				// buffer for storing formatted string 
			int  cchTime					// size of buffer 
		);"

	"Avoid creating indirect ref. to SYSTEMTIME from its own #displayOn: by using void* parm instead"
	<stdcall: sdword GetTimeFormatA dword dword void* lpstr lpstr sdword>
	^self invalidCall

!

getTimeZoneInformation: lpTimeZoneInformation
	"Populate the fields of lpTimeZoneInformation with the current
	time-zone parameters. These parameters control the translations between 
	Coordinated Universal Time (UTC) and local time. Answers an integer from 
	the TIME_ZONE_XXXX enumeration.

		DWORD GetTimeZoneInformation(
			LPTIME_ZONE_INFORMATION lpTimeZoneInformation
		);

	Implementation Note: The error return value is 0xFFFFFFFF so to make stay
	within SmallInteger range we declare a signed integer return type so that the
	error return is instead -1."

	<stdcall: sdword GetTimeZoneInformation TIME_ZONE_INFORMATION*>
	^self invalidCall!

getUserDefaultLCID
  	"Answer the user default locale identifier. 

		LCID GetUserDefaultLCID(VOID)"
  
	<stdcall: dword GetUserDefaultLCID>
	^self invalidCall!

getVersionEx: anOSVERSIONINFO
	"Populate the argument with extended OS version information. Answers whether the request succeeded.
		BOOL GetVersionEx(
			LPOSVERSIONINFO lpVersionInformation 
		);"

	<stdcall: bool GetVersionExA OSVERSIONINFO* >
	^self invalidCall!

getVolumeInformation: lpRootPathName
	lpVolumeNameBuffer: lpVolumeNameBuffer
	nVolumeNameSize: nVolumeNameSize
	lpVolumeSerialNumber: lpVolumeSerialNumber
	lpMaximumComponentLength: lpMaximumComponentLength
	lpFileSystemFlags: lpFileSystemFlags
	lpFileSystemNameBuffer: lpFileSystemNameBuffer
	nFileSystemNameSize: nFileSystemNameSize

	"
		BOOL GetVolumeInformation(
			LPCTSTR lpRootPathName,
			LPTSTR lpVolumeNameBuffer,
			DWORD nVolumeNameSize,
			LPDWORD lpVolumeSerialNumber, 
			LPDWORD lpMaximumComponentLength,
			LPDWORD lpFileSystemFlags,
			LPTSTR lpFileSystemNameBuffer,
			DWORD nFileSystemNameSize);
	"

	<stdcall: bool GetVolumeInformationA lpstr lpstr dword dword* dword* dword* lpstr dword>
	^self invalidCall!

getWindowsDirectory: lpBuffer uSize: uSize
  	"Answer the path of the windows directory.

		UINT GetWindowsDirectory(
			LPTSTRlpBuffer, 
			UINTuSize); "
  
	<stdcall: dword GetWindowsDirectoryA lpstr dword>
	^self invalidCall!

globalAlloc: uFlags dwBytes: dwBytes
	"Allocates the specified number of bytes from the heap.

		HGLOBAL GlobalAlloc( 
			UINTuFlags, 		// object allocation attributes 
			DWORDdwBytes 	// number of bytes to allocate 
		);"

	<stdcall: handle GlobalAlloc dword dword>
	^self invalidCall!

globalLock: hGlobal
	"Answer a pointer to a block of global memory object that was allocated 
	by the GlobalAlloc(...GMEM_MOVEABLE flag), incrementing its lock count."

	<stdcall: lpvoid GlobalLock handle>
	^self invalidCall!

globalUnlock: hGlobal
	"Decrement the lock count of a global memory object that was allocated 
	by the GlobalAlloc(...GMEM_MOVEABLE flag)."

	<stdcall: bool GlobalUnlock handle>
	^self invalidCall!

heapAlloc: aHandle dwFlags: flagsInteger dwBytes: byteSizeInteger
	"Allocate a block of memory from a heap.

		LPVOID HeapAlloc(
			HANDLE hHeap,	// handle to the private heap block 
			DWORD dwFlags,	// heap allocation control flags 
			DWORD dwBytes 	// number of bytes to allocate 
		);"

	<stdcall: lpvoid HeapAlloc handle dword dword>
	^self invalidCall!

heapCompact: aHandle dwFlags: anInteger
	"Minimize the size of the specified heap. Answer the size of the largest
	available free block (fairly meaningless), or zero on failure.
		UINT HeapCompact(
			HANDLE hHeap,	// handle to the heap to compact
			DWORD dwFlags 	// control flags
		);"

	<stdcall: dword HeapCompact handle dword>
	^self invalidCall!

heapFree: aHandle dwFlags: flagsInteger lpMem: byteSizeInteger
	"Free a block of memory to a heap, answering whether it succeeed.
	N.B. There is no distinction under Win32 between memory blocks allocated
	with GlobalAlloc(), LocalAlloc(), or from the default process heap using
	HeapAlloc(). We therefore standardise on the HeapXXX() set of functions
	(which are more powerful and allow multiple heaps), and use HeapFree() to
	free memory blocks where LocalFree()/GlobalFree() are specified.

		LPVOID HeapFree(
			HANDLE hHeap,	// handle to the heap
			DWORD dwFlags,	// heap freeing flags 
			LPVOID lpMem 	// pointer to the memory to free
		);"

	<stdcall: bool HeapFree handle dword lpvoid>
	^self invalidCall!

heapReAlloc: aHandle dwFlags: flagsInteger lpMem: anAddress dwBytes: byteSizeInteger
	"Resize an block of heap memory, answering the new block address (which may or may not change).

		LPVOID HeapReAlloc(
			HANDLE hHeap,	// handle of a heap 
			DWORD dwFlags,	// heap reallocation flags 
			LPVOID lpMem,	// pointer to the memory to reallocate 
			DWORD dwBytes 	// number of bytes to reallocate 
		);"

  
	<stdcall: lpvoid HeapReAlloc handle dword lpvoid dword>
	^self invalidCall!

heapSize: aHandle dwFlags: flagsInteger lpMem: anAddress
	"Answer the size of the block of memory allocated at the specified address.
  
		DWORD HeapSize(
			HANDLE hHeap,	// handle to a heap
			DWORD dwFlags,	// heap size control flags
			LPCVOID lpMem,	// pointer to the memory block of interest
		);"

  
	<stdcall: dword HeapSize handle dword lpvoid>
	^self invalidCall!

heapValidate: aHandle dwFlags: anInteger lpMem: anAddress
	"Answer whether the specified heap/memory block in a heap, is valid.

		BOOL HeapValidate(
			HANDLE hHeap,	// handle to the heap of interest
			DWORD dwFlags,	// bit flags that control heap access during function operation
			LPCVOID lpMem 	// optional pointer to individual memory block to validate
		);"

	<stdcall: bool HeapValidate handle dword lpvoid>
	^self invalidCall!

isDBCSLeadByte: testChar
	"Invoke the IsDBCSLeadByte() function of the module wrapped by the receiver.
	Helpstring: uses the ANSI code page to determine whether a specified byte is potentially a lead byte that is, the first byte of a two-byte character in a double-byte character set (DBCS)

		BOOL __stdcall IsDBCSLeadByte(
			BYTE TestChar);"

	<stdcall: bool IsDBCSLeadByte byte>
	^self invalidCall!

isDBCSLeadByteEx: codepage testChar: testChar
	"Invoke the IsDBCSLeadByteEx() function of the module wrapped by the receiver.
	Helpstring: determines whether a specified byte is a lead byte, that is, the first byte of a two-byte character in a double-byte character set (DBCS) for the specified code page

		BOOL __stdcall IsDBCSLeadByteEx(
			UINT codepage,
			BYTE TestChar);"

	<stdcall: bool IsDBCSLeadByte dword byte>
	^self invalidCall!

loadLibraryEx: aString hFile: reserved dwFlags: anInteger
	"Map the specified executable module into the address space of the calling process, and answer the module
	handle. If the function fails, the return value is nil.

		HINSTANCE LoadLibraryEx(
			LPCTSTR lpLibFileName,	// points to name of executable module
			HANDLE hFile,	// reserved, must be NULL 
			DWORD dwFlags 	// entry-point execution flag 
		);
	
	The library is loaded from either the directory from which Dolphin was loaded, the current directory, 
	the Windows system directory, the Windows directory, or a directory on the path (in that order)."

	<stdcall: handle LoadLibraryExA lpstr handle dword>
	^self invalidCall!

loadResource: anInstanceHandle hResInfo: aResourceHandle
	"Load the specified resource into global memory. 
		HGLOBAL LoadResource(
  			HMODULE hModule,	// resource-module handle  
			HRSRC hResInfo 	// resource handle 
		);"

	<stdcall: handle LoadResource handle handle>
	^self invalidCall!

localFileTimeToFileTime: lpLocalFileTime lpFileTime: lpFileTime
	"Convert a UTC FILETIME to a local FILETIME, answering whether the conversion succeeded.
		BOOL LocalFileTimeToFileTime(
  			CONST FILETIME *lpLocalFileTime,	// pointer to UTC file time to convert 
			LPFILETIME lpFileTime			// pointer to structure to receive UTC
		);"

	<stdcall: bool LocalFileTimeToFileTime FILETIME* FILETIME* >
	^self invalidCall!

lockResource: anExternalHandle
	"Lock the specified resource in memory. 
		LPVOID LockResource(
  			HGLOBAL hResData 	// handle to resource to lock 
		);"

	<stdcall: dword LockResource handle>
	^self invalidCall!

lstrcmp: aString1 lpString2: aString2
  	"Answer -1, 0 or 1 depending on whether aString collates before, the same as, 
	or after aString2 sensitive to case (respectively).
		int lstrcmp(
  			LPCTSTR lpString1,	// address of first string 
			LPCTSTR lpString2 	// address of second string 
		);

	N.B. If you need more flexibility, implement the CompareStrings() call (which
	this probably just layers on top of anyway)."

	<stdcall: sdword lstrcmpA lpstr lpstr>
	^self invalidCall!

lstrcmpi: aString1 lpString2: aString2
  	"Answer -1, 0 or 1 depending on whether aString collates before, the same as, 
	or after aString2 ignoring case (respectively).
		int lstrcmpi(
  			LPCTSTR lpString1,	// address of first string 
			LPCTSTR lpString2 	// address of second string 
		);

	N.B. If you need more flexibility, implement the CompareStrings() call (which
	this probably just layers on top of anyway)."

	<stdcall: sdword lstrcmpiA lpstr lpstr>
	^self invalidCall!

lstrlenW: aUnicodeString
	"Answer the length in characters of the parameter (assumed to point
	at a null-terminated unicode String."

	<stdcall: sdword lstrlenW lpvoid>
	^self invalidCall!

moveFile: aStringOldFileName lpNewFileName: aStringnewFileName
	"The MoveFile function will move (rename) either a file or a directory (including all its children)
	either in the same directory or across directories. The one caveat is that the MoveFile function will
	fail on directory moves when the destination is on a different volume. 
	Answer true if the function succeeds. 

	BOOL MoveFile(
		LPCTSTR lpExistingFileName, // address of name of the existing file  
		LPCTSTR lpNewFileName // address of new name for the file 
		);"

	<stdcall: bool MoveFileA lpstr lpstr>
	^self invalidCall!

moveFileEx: aStringOldFileName lpNewFileName: aStringnewFileName dwFlags: flags
	"The MoveFileEx function will move (rename) either a file or a directory (including all its children)
	either in the same directory or across directories. The one caveat is that the MoveFile function will
	fail on directory moves when the destination is on a different volume. 
	Answer true if the function succeeds. 

	BOOL MoveFile(
		LPCTSTR lpExistingFileName, // address of name of the existing file  
		LPCTSTR lpNewFileName // address of new name for the file 
		DWORD dwFlags <> // move options 
		);"

	<stdcall: bool MoveFileExA lpstr lpstr dword>
	^self invalidCall!

multiByteToWideChar: intCP dwFlags: intFlags lpMultiByteStr: aStringIn 
	cchMultiByte: intLenIn
	lpWideCharStr: aUnicodeStringOut
	cchWideChar: intLenOut

	"Maps a string to a wide-character (Unicode) string. 
	Despite the name, aStringIn, need not contain MBCS characters.

		int MultiByteToWideChar(
			UINT CodePage,	// code page 
			DWORD dwFlags,	// character-type options 
			LPCSTR lpMultiByteStr,	// address of string to map 
			int cchMultiByte,	// number of characters in string 
			LPWSTR lpWideCharStr,	// address of wide-character buffer 
			int cchWideChar 	// size of buffer 
		);"

	<stdcall: sdword MultiByteToWideChar dword dword lpstr sdword lpstr sdword>
	^self invalidCall!

openProcess: dwDesiredAccess bInheritHandle: bInheritHandle dwProcessId: dwProcessId 
	"Invoke the OpenProcess() function of the module wrapped by the receiver.
	Helpstring: Given a process ID number, returns handle of existing process

		long __stdcall OpenProcess(
			EPROCESSACCESS dwDesiredAccess,
			long bInheritHandle,
			unsigned long dwProcessId);"

	<stdcall: sdword OpenProcess sdword sdword dword>
	^self invalidCall!

outputDebugString: aString
	"Send aString to the debugger.

		VOID OutputDebugString(
  			LPCTSTR  lpOutputString 	// address of string to be displayed  
		);"

	<stdcall: void OutputDebugStringA lpstr>
	^self invalidCall!

pulseEvent: aHandle
	"Set to its 'signalled' state the Win32 Event identified by aHandle, 
	then reset it to its 'non-signalled' state. Answer whether the function 
	succeeded or failed. Manual reset Events release all waiting threads when
	pulsed, auto-reset events release a single waiting thread. If no threads
	are waiting for the event, then the effect is to reset the Event to its
	non-signalled state."

	"BOOL PulseEvent(
		HANDLE  hEvent 	// handle of event object 
	);"

	<stdcall: bool PulseEvent handle>
	^self invalidCall!

queryPerformanceCounter: aLargeInteger
	"The QueryPerformanceCounter function retrieves the current value of the high-resolution performance counter, if one exists. 
		BOOL QueryPerformanceCounter(
			LARGE_INTEGER *lpPerformanceCount 	// address of current counter value
		);"

	<stdcall: bool QueryPerformanceCounter LARGE_INTEGER* >
	^self invalidCall

!

queryPerformanceFrequency: aLargeInteger
	"The QueryPerformanceFrequency function retrieves the frequency of the high-resolution performance counter, if one exists. 
		BOOL QueryPerformanceFrequency(
  			LARGE_INTEGER *lpFrequency 	// address of current frequency
		);"

	<stdcall: bool QueryPerformanceFrequency LARGE_INTEGER*>
	^self invalidCall!

raiseException: dwExceptionCode dwExceptionFlags: dwExceptionFlags nNumberOfArguments: nNumberOfArguments lpArguments: lpArguments
	"Invoke the RaiseException() function of the module wrapped by the receiver.
	Helpstring: Raises an exception in the calling thread.

		void __stdcall RaiseException(
			[in]unsigned long dwExceptionCode,
			[in]unsigned long dwExceptionFlags,
			[in]unsigned long nNumberOfArguments,
			[in]ULONG_PTR* lpArguments);"

	<stdcall: void RaiseException dword dword dword uintptr*>
	^self invalidCall!

readFile: aHandle lpBuffer: anAddress nNumberOfBytesToRead: anIntegerBytesToRead
		lpNumberOfBytesRead: anAddressBytesRead lpOverlapped: anOVERLAPPED
	"The ReadFile function reads data from a file, starting at the position indicated by the file pointer.
	After the read operation has been completed, the file pointer is adjusted by the number of bytes actually read,
	unless the file handle is created with the overlapped attribute. If the file handle is created for overlapped
	input and output (I/O), the application must adjust the position of the file pointer after the read operation. 

	BOOL ReadFile(
		HANDLE hFile, // handle of file to read 
		LPVOID lpBuffer, // address of buffer that receives data  
		DWORD nNumberOfBytesToRead, // number of bytes to read 
		LPDWORD lpNumberOfBytesRead, // address of number of bytes read 
		LPOVERLAPPED lpOverlapped // address of structure for data 
		);

	Answer a boolean indicating whether the function succeeds. If successful and bytesRead is left set to zero,
	the file pointer was beyond the current end of the file at the time of the read operation."

	<stdcall: bool ReadFile handle lpvoid dword lpvoid lpvoid>
	^self invalidCall!

releaseMutex: hMutex
	"Invoke the ReleaseMutex() function of the module wrapped by the receiver.
	Helpstring: Releases the Mutex once

		BOOL __stdcall ReleaseMutex(
			HANDLE hMutex);"

	<stdcall: bool ReleaseMutex handle>
	^self invalidCall!

removeDirectory: aStringFileName
	<stdcall: bool RemoveDirectoryA lpstr>
	^self invalidCall!

resetEvent: aHandle
	"Set the specified Win32 Event object to its 'signalled' state.
	Answer whether the function succeeded or failed. Manual reset
	Events remain in the signalled state until explicitly reset (e.g.
	using #resetEvent:), auto-reset events remain in the signalled state
	until a single thread waiting for the event is released.

		BOOL ResetEvent(
			HANDLE  hEvent 	// handle of event object 
		);"

	<stdcall: bool ResetEvent handle>
	^self invalidCall!

setConsoleCtrlHandler: pHandlerRoutine add: aBoolean
	"Set the handler function which receives console control events."

	<stdcall: bool SetConsoleCtrlHandler void* bool>
	^self invalidCall!

setEndOfFile: anExternalHandle
	<stdcall: bool SetEndOfFile handle>
	^self invalidCall!

setEnvironmentVariable: lpName lpValue: lpValue
	"Sets the value of an environment variable for the current process. Answer whether the
	request was successful.
		BOOL SetEnvironmentVariable(
			LPCTSTR lpName,	// address of environment variable name  
  			LPCTSTR lpValue 	// address of new value for variable 
		);"

	<stdcall: bool SetEnvironmentVariableA lpstr lpstr>
	^self invalidCall!

setEvent: aHandle
	"Set the specified Win32 Event object to its 'signalled' state.
	Answer whether the function succeeded or failed. Manual reset
	Events remain in the signalled state until explicitly reset (e.g.
	using #resetEvent:), auto-reset events remain in the signalled state
	until a single thread waiting for the event is released.

		BOOL SetEvent(
			HANDLE  hEvent 	// handle of event object 
		);"

	<stdcall: bool SetEvent handle>
	^self invalidCall!

setFilePointer: aHandle lDistanceToMove: loInteger lpDistanceToMoveHigh: anAddress dwMoveMethod: senseOfMove
	"Moves the file pointer of an open file. 

	DWORD SetFilePointer(
		HANDLE hFile, 					// handle of file 
		LONG lDistanceToMove, 			// number of bytes to move file pointer 
		PLONG lpDistanceToMoveHigh, 	// address of high-order word of distance to move  
		DWORD dwMoveMethod 			// how to move 
		);"

	"Implementation Note: The lDistanceToMove parameter is treated as an unsigned integer
	as we always treat it as the low 32-bits of a 64-bit integer."

	<stdcall: dword SetFilePointer handle dword lpvoid dword>
	^self invalidCall!

setLastError: anInteger
	"Set the last Win32 error code which occurred.
		VOID SetLastError(DWORD dwErrCode)"
  
	<stdcall: void SetLastError dword>
	^self invalidCall!

setStdHandle: nStdHandle hHandle: aHandle
	"Set the handle for the standard input, standard output, or standard error device.
		BOOL SetStdHandle(
  			DWORD nStdHandle,	// input, output, or error device 
			HANDLE hHandle 	// handle to be a standard handle  
		);"

	<stdcall: bool SetStdHandle dword handle>
	^self invalidCall!

setVolumeLabel: lpRootPathName lpVolumeName: lpVolumeName
	"Set the label of a a file system volume. Answer whether the operation succeeded.
		BOOL SetVolumeLabel( 
			LPCTSTR lpRootPathName,
			LPCTSTR lpVolumeName
		);"

	<stdcall: bool SetVolumeLabelA lpstr lpstr>
	^self invalidCall!

sizeOfResource: anExternalHandleInstance hResInfo: anExternalHandleResource
	"Answer the byte size of the specified resource. 
		DWORD SizeofResource(
			HMODULE hModule,	// resource-module handle  
			HRSRC hResInfo 	// resource handle 
		);"

	<stdcall: dword SizeofResource handle handle>
	^self invalidCall!

sleep: anInteger
	"Put the calling Win32 thread to sleep for anInteger milliseconds.
		void Sleep(
			DWORD dwMilliseconds	// sleep duration in millisecs
		);
	N.B. This is an overlapped call, and will not interrupt the execution
	of Dolphin's background threads since it is performed on a separate
	thread. Only the calling Process will be delayed.!!
	"

	<overlap stdcall: void Sleep dword>
	^self invalidCall!

sleepEx: anInteger bAlertable: aBoolean
	<stdcall: void SleepEx dword bool>
	^self invalidCall!

systemTimeToFileTime: lpSystemTime lpFileTime: lpFileTime
 	"Convert a SYSTEMTIME to a FILETIME, answering whether the conversion succeeded.
		BOOL SystemTimeToFileTime(
			CONST SYSTEMTIME *lpSystemTime,	// address of system time to convert 
			LPFILETIME lpFileTime 	// address of buffer for converted file time 
		);"

	<stdcall: bool SystemTimeToFileTime SYSTEMTIME* FILETIME* >
	^self invalidCall!

terminateProcess: aProcessHandle exitCode: anUnsignedInteger
	"The TerminateProcess function terminates the specified process and all of its threads. 

	BOOL TerminateProcess(
						HANDLE hProcess, // handle to the process
						UINT uExitCode   // exit code for the process
						);
	Parameters
		hProcess  [in]		Handle to the process to terminate. 
						Windows NT/2000: The handle must have PROCESS_TERMINATE
										access. For more information, see Process
										Security and Access Rights. 
		uExitCode [in]		Specifies the exit code for the process and for all threads terminated
						as a result of this call. Use the GetExitCodeProcess function to
						retrieve the process's exit value. Use the GetExitCodeThread
						function to retrieve a thread's exit value."

	<stdcall: bool TerminateProcess handle dword>
	^self invalidCall!

terminateProcessId: anInteger 
	| hProcess |
	hProcess := self 
				openProcess: PROCESS_TERMINATE
				bInheritHandle: false asParameter
				dwProcessId: anInteger.
	hProcess isNull ifTrue: [self systemError].
	[(self terminateProcess: hProcess exitCode: 0) ifFalse: [self systemError]] 
		ensure: [self closeHandle: hProcess]!

threadGetLastError
	"Answer the last Win32 error code which last occurred in the overlapped call thread
	associated with the current <Process>."

	<overlap stdcall: dword GetLastError>
	^self invalidCall!

threadSetLastError: anInteger 
	"Set the last Win32 error code which occurred for the overlapped call thread associated with
	the calling <Process>"

	<overlap stdcall: void SetLastError dword>
	^self invalidCall!

updateResource: hUpdate lpType: resTypeString lpName: resName wLanguage: langId lpData: pData cbData: dataSize
	"UpdateResource adds, deletes, or replaces a resource in an executable file. 

	BOOL UpdateResource(
		HANDLE hUpdate <>, // update-file handle
		LPCTSTR lpType <>, // resource type
		LPCTSTR lpName <>, // resource name
		WORD wLanguage <>, // language identifier
		LPVOID lpData <>,  // resource data
		DWORD cbData <>    // length of resource data
		);"

	<stdcall: bool UpdateResourceA handle lpvoid lpvoid word lpvoid dword>
	^self invalidCall!

updateResourcesOf: aString do: aMonadicValuable 
	| hUpdate |
	hUpdate := self beginUpdateResource: aString bDeleteExistingResources: false.
	[aMonadicValuable value: hUpdate] ifCurtailed: [self endUpdateResource: hUpdate fDiscard: true].
	(self endUpdateResource: hUpdate fDiscard: false) ifFalse: [self systemError]!

virtualAlloc: lpAddress dwSize: dwSize flAllocationType: flAllocationType flProtect: flProtect
	"Invoke the VirtualAlloc() function of the module wrapped by the receiver.
	Helpstring: Reserves or commits a region of pages in the virtual address space

		LPVOID __stdcall VirtualAlloc(
			LPVOID lpAddress,
			DWORD dwSize,
			DWORD flAllocationType,
			DWORD flProtect);"

	<stdcall: void* VirtualAlloc void* dword dword dword>
	^self invalidCall!

virtualFree: lpAddress dwSize: dwSize dwFreeType: dwFreeType
	"Invoke the VirtualFree() function of the module wrapped by the receiver.
	Helpstring: Releases or decommits (or both) a region of pages within the virtual address space

		BOOL __stdcall VirtualFree(
			LPVOID lpAddress,
			DWORD dwSize,
			DWORD dwFreeType);"

	<stdcall: bool VirtualFree void* dword dword>
	^self invalidCall!

virtualProtect: lpAddress dwSize: dwSize flNewProtect: flNewProtect lpflOldProtect: lpflOldProtect
	"Invoke the VirtualProtect() function of the module wrapped by the receiver.
	Helpstring: Changes the access protection on a region of committed pages in the virtual address space

		BOOL __stdcall VirtualProtect(
			LPVOID lpAddress,
			DWORD dwSize,
			DWORD flNewProtect,
			DWORD* lpflOldProtect);"

	<stdcall: bool VirtualProtect void* dword dword dword*>
	^self invalidCall!

virtualQuery: lpAddress lpBuffer: lpBuffer dwLength: dwLength
	"Invoke the VirtualQuery() function of the module wrapped by the receiver.
	Helpstring: Provides information about a range of pages in the virtual address space

		DWORD __stdcall VirtualQuery(
			LPVOID lpAddress,
			MEMORY_BASIC_INFORMATION* lpBuffer,
			DWORD dwLength);"

	<stdcall: dword VirtualQuery void* MEMORY_BASIC_INFORMATION* dword>
	^self invalidCall!

wideCharToMultiByte: codePage
	dwFlags: dwFlags
	lpWideCharStr: lpWideCharStr
	cchWideChar: cchWideChar
	lpMultiByteStr: lpMultiByteStr
	cchMultiByte: cchMultiByte
	lpDefaultChar: lpDefaultChar
	lpUsedDefaultChar: lpUsedDefaultChar

	"Maps a Unicode string to a multi-byte character string. 
	Despite the name, aStringOut, need not contain MBCS characters.

		int WideCharToMultiByte(
			UINT CodePage,			// code page 
			DWORD dwFlags,			// performance and mapping flags 
			LPCWSTR lpWideCharStr,	// address of wide-character string 
			int cchWideChar,		// number of characters in string 
			LPSTR lpMultiByteStr,	// address of buffer for new string 
			int cchMultiByte,		// size of buffer 
			LPCSTR lpDefaultChar,	// address of default for unmappable characters  
			LPBOOL lpUsedDefaultChar// address of flag set when default char. used 
		);"

	<stdcall: sdword WideCharToMultiByte dword dword UnicodeString* sdword lpstr sdword lpstr lpvoid>
	^self invalidCall!

winExec: lpstrCmdLine uCmdShow: nCmdShow
	"Spawn the specified application. 
		UINT WinExec(
  			LPCSTR lpCmdLine,	// address of command line 
			UINT uCmdShow 	// window style for new application 
		);
	Note that this is run as an overlapped call to avoid delaying the entire
	Smalltalk image."

	<overlap stdcall: dword WinExec lpstr dword>
	^self invalidCall!

writeFile: aHandle lpBuffer: anAddress nNumberOfBytesToWrite: anIntegerBytesToWrite 
		lpNumberOfBytesWritten: anAddressBytesWritten lpOverlapped: anOVERLAPPED
	"The WriteFile function writes data to a file and is designed for both synchronous and asynchronous operation.
	The function starts writing data to the file at the position indicated by the file pointer. After the write
	operation has been completed, the file pointer is adjusted by the number of bytes actually written, except when
	the file is opened with FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped input and output
	(I/O), the application must adjust the position of the file pointer after the write operation is finished. 

	BOOL WriteFile(
		HANDLE hFile, // handle of file to write to 
		LPCVOID lpBuffer, // address of data to write to file 
		DWORD nNumberOfBytesToWrite, // number of bytes to write 
		LPDWORD lpNumberOfBytesWritten, // address of number of bytes written 
		LPOVERLAPPED lpOverlapped // addr. of structure needed for overlapped I/O  
		);

	Answer a boolean indicating whether the function succeeds."

	<stdcall: bool WriteFile handle lpvoid dword lpvoid lpvoid>
	^self invalidCall!

writePrivateProfileString: lpszSection lpszEntry: lpszEntry lpszString: lpszString lpszFileName: lpszFileName 
	"Invoke the WritePrivateProfileString() function of the module wrapped by the receiver.
	Helpstring: Writes given string value to given entry within given section of INI file

		BOOL__stdcall WritePrivateProfileString(
			LPSTR lpszSection,
			LPSTR lpszEntry,
			LPSTR lpszString,
			LPSTR lpszFileName);"

	<stdcall: bool WritePrivateProfileStringA lpstr lpstr lpstr lpstr>
	^self invalidCall!

zeroMemory: pvDest length: cBytes
	<stdcall: void RtlZeroMemory void* dword>
	^self invalidCall! !

UserLibrary comment:
'UserLibrary is the <ExternalLibrary> class to represent the Windows system DLL, User32.DLL.

The default instance of this class provides access to most of the Win32 window management API. New functions may be added as required, but the external function naming convention should be followed.

All functions in this library use the stdcall calling convention.'!
!UserLibrary class methodsFor!

clear
	"Private - Clear down cached external function addresses and any default 
	instances of the receiver from previous runs. etc."

	super clear.
	#(#SystemMetrics) 
		do: [:each | self environment at: each ifPresent: [:c | c reset]]!

fileName
	"Answer the host system file name of the external library which 
	the receiver represents."

	^'USER32'! !

!UserLibrary methodsFor!

charLower: aCharacter
	"Answer the lowercase equivalent of aCharacter. This will be dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
	N.B. We ignore the return value as it will be a pointer to the argument.

		LPTSTR CharLower(LPTSTR  lpsz); 	// single character or pointer to string"

	<stdcall: char CharLowerA char>
	^self invalidCall!

charUpper: aCharacter
	"Answer the uppercase equivalent of aCharacter. This will be dependent on the semantics 
	of the language selected by the user during setup or by using Control Panel.

		LPTSTR CharUpper(LPTSTR  lpsz); 	// single character or pointer to string "

	<stdcall: char CharUpperA char>
	^self invalidCall!

copyImage: hImage uType: uType cxDesired: cxDesired cyDesired: cyDesired fuFlags: fuFlags 
	"The CopyImage function creates a new image (icon, cursor, or bitmap) and copies the attributes of
	the specified image to the new one. If necessary, the function stretches the bits to fit the desired size
	of the new image.
	
	HANDLE CopyImage(      
		HANDLE hImage,
		UINT uType,
		int cxDesired,
		int cyDesired,
		UINT fuFlags
		);"

	<stdcall: handle CopyImage handle dword sdword sdword dword>
	^self invalidCall!

createDialog: hInstance lpTemplate: template hWndParent: hParent lpDialogFunc: dlgProc dwInitParam: lParam
	"Create a modeless dialog box from a dialog box template resource. 
		HWND CreateDialog(
  			HINSTANCE hInstance,		// handle of module containing template
			LPCTSTR lpTemplate,		// resource identifier
			HWND hWndParent,			// handle of owner window
			DLGPROC lpDialogFunc, 		// address of dialog proc
			LPARAM dwInitParam 		// value passed to wmInitDialog:
		);"

	<stdcall: sdword CreateDialogParamA handle lpvoid handle lpvoid sdword>
	^self invalidCall!

defDlgProc: hWnd msg: msg wParam: wParam lParam: lParam
	"Call the default dialog procedure to provide default processing for 
	any window messages that an application does not process. 

		LRESULT DefDlgProc(
			HWND hDlg,	// handle to dialog box
			UINT Msg,	// message
			WPARAM wParam,	// first message parameter
			LPARAM lParam 	// second message parameter
		);"


	<stdcall: uintptr DefDlgProcA handle dword uintptr uintptr>
	^self invalidCall!

defWindowProc: hWnd msg: msg wParam: wParam lParam: lParam
	"Call the default window procedure to provide default processing for 
	any window messages that an application does not process. 
	
		LRESULT DefWindowProc(
			HWND hWnd,	// handle to window
			UINT Msg,	// message identifier
			WPARAM wParam,	// first message parameter
			LPARAM lParam 	// second message parameter
		);"

	<stdcall: uintptr DefWindowProcA handle dword uintptr uintptr>
	^self invalidCall!

destroyIcon: hIcon
	"Destroy the specified icon.
		BOOL DestroyIcon(
  			HICON hIcon 	// handle to icon to destroy
		);"

	<stdcall: bool DestroyIcon handle>
	^self invalidCall!

destroyWindow: aWindowHandle
	"Destroys the specified window. WM_DESTROY and WM_NCDESTROY messages are sent
	to the window to deactivate it, and remove the keyboard focus. The window's menu
	is destroyed, the owning threads message queue flushed, outstanding timers are 
	destroyed, clipboard ownership is revoked, the clipboard viewer chain is broken 
	(if the window is at the top of the viewer chain). All owned and child windows
	are also destroyed. Can also be used to destroys modeless dialog boxes created 
	by the CreateDialog function. 
		BOOL DestroyWindow(
			HWND  hWnd 	// handle of window to destroy  
		);"

	<stdcall: bool DestroyWindow handle>
	^self invalidCall!

dispatchMessage: aMSG
	"Dispatch a message to a window procedure.
		LONG DispatchMessage(
  			CONST MSG *lpmsg 	// pointer to structure with message
		);"

	<stdcall: sdword DispatchMessageA MSG* >
	^self invalidCall!

enableWindow: aWindowHandle bEnable: aBoolean
	"Enable or disable mouse and keyboard input to the specified window.
		BOOL EnableWindow(
			HWND hWnd,	// handle to window
			BOOL bEnable 	// flag for enabling or disabling input
		);"

	<stdcall: bool EnableWindow handle bool>
	^self invalidCall

!

enumWindows: aCallbackThunk lParam: lParam
	"Enumerate all top-level windows on the screen by passing the handle of each window, in turn, to 
	the callback function thunk aCallbackThunk. EnumWindows continues until the last top-level window 
	is enumerated or the callback function returns false.

		BOOL EnumWindows(
			WNDENUMPROC lpEnumFunc,	// pointer to callback function
			LPARAM lParam 	// application-defined value
		);"

	<stdcall: bool EnumWindows lpvoid dword>
	^self invalidCall!

getActiveWindow
	"Answer the handle of Dolphin's active window (nil if none active)."

	<stdcall: handle GetActiveWindow>
	^self invalidCall!

getAncestor: hwnd gaFlags: gaFlags
	"Invoke the GetAncestor() function of the module wrapped by the receiver.
	Helpstring: Retrieves a handle to an ancestor of the specified window.

		HWND __stdcall GetAncestor(
			[in]HWND HWND,
			[in]UINT gaFlags);"

	<stdcall: handle GetAncestor handle dword>
	^self invalidCall!

getAsyncKeyState: virtualKeyCodeInteger
	<stdcall: sword GetAsyncKeyState sdword>
	^self invalidCall!

getCursor
	"Retrieve the handle of the current system cursor.
		HCURSOR GetCursor(VOID)."

	<stdcall: handle GetCursor>
	^self invalidCall!

getDC
	"Answer a DC for drawing on the desktop.
	N.B. This is one half of the <dcSource> protocol, and must be matched with 
	a call to #releaseDC: to delete the DC.
		dc := self getDC.
		self releaseDC: dc.
	"

	^self getWindowDC: self getDesktopWindow!

getDesktopWindow
	"Answer the handle of the desktop (ultimate parent) window. Answer that handle. 
	N.B. Although the desktop window is logically the parent
	of all top-level windows, its handle is not, sadly, that answered by GetParent()
	for such windows. View>>parentView does, however, return the desktop window as the
	parent of top level windows."

	<stdcall: handle GetDesktopWindow>
	^self invalidCall!

getDlgItem: aWindowHandle nIDDlgItem: anIntegerId
	"Retrieves the handle of a control in a dialog box. 
  
		HWND GetDlgItem(
  			HWND  hDlg,		// handle of dialog box
			int  nIDDlgItem 	// identifier of control
		);"

	<stdcall: handle GetDlgItem handle sdword>
	^self invalidCall!

getKeyboardLayout: anInteger
	<stdcall: sdword GetKeyboardLayout sdword>
	^self invalidCall!

getKeyboardState: a256ByteArray
	"Copies the status of the 256 virtual keys to the specified buffer. 
		BOOL GetKeyboardState(
			PBYTE lpKeyState 	// address of array to receive status data
		);"

	<stdcall: bool GetKeyboardState lpvoid>
	^self invalidCall!

getKeyNameText: lParam lpString: aString nSize: anInteger
	"Populate a string with the name of a virtual key code
		int GetKeyNameText( 
			LONGlParam,	// second parameter of keyboard message	
			LPTSTRlpString,	// address of buffer for key name	
			intnSize	// maximum length of key-name string length	
		);"

	<stdcall: sdword GetKeyNameTextA dword lpstr sdword>
	^self invalidCall
!

getKeyState: virtualKeyCodeInteger
	"Answer the status of the virtual key, virtualKeyCodeInteger. See the Keyboard class.

		SHORT GetKeyState(int  nVirtKey);"

	<stdcall: sword GetKeyState sdword>
	^self invalidCall!

getMessage: aMSG hWnd: aWindowHandle wMsgFilterMin: anIntFilterMin wMsgFilterMax: anIntFilterMax
	"Retrieves the next message from the Win32 input queue in the range integerFilterMin
	integerFilterMax, for the window with handle aWindowHandle (if Null then for all windows)
	into the Win32 MSG structure, aMSG.

	BOOL GetMessage(
		LPMSG  lpMsg,	// address of structure with message
		HWND  hWnd,	// handle of window
		UINT  wMsgFilterMin,	// first message
		UINT  wMsgFilterMax 	// last message
	);	

	Answers 1 if a message was retrieved, 0 if WM_QUIT was retrieved, or -1 if some
	error occurred. N.B. Though Win32 declares GetMessage() as returning a BOOL,
	it doesn't really (because of the error return value) so to avoid errors, as
	suggested in the help), we have it return a signed integer)"

	<stdcall: sdword GetMessageA MSG* handle dword dword>
	^self invalidCall!

getParent: hWnd
	"Answer the handle of the parent window of the specified window.
	If the window is a top level window (whose parent is really the Desktop
	window) then answer 0 (which is not the handle of the real Desktop window, but
	is the handle of the Dolphin Desktop window). Confused? Me too."

	<stdcall: dword GetParent handle>
	^self invalidCall!

getQueueStatus: integerFlags
	"Answer a 32-bit set of flags which indicates the type of messages currently present in
	the in the calling thread's message queue. 
		DWORD GetQueueStatus(
			UINT  flags 	// queue-status flags
		);
	See MSDN for further details."

	<stdcall: dword GetQueueStatus dword>
	^self invalidCall!

getSysColor: index
	"Answer the current color of the specified display element. Display elements are 
	the parts of a window and the Windows display that appear on the system display screen
	(configurable from DisplayProperties/Appearance)
		DWORD GetSysColor(
			int nIndex 	// display element
		);"

	<stdcall: dword GetSysColor sdword>
	^self invalidCall!

getSysColorBrush: anInteger
	"Answer the handle of one of the standard system colour brushes
		HBRUSH GetSysColorBrush(
  			int index
		);"

	<stdcall: handle GetSysColorBrush sdword>
	^self invalidCall!

getSystemMetrics: index
	"Answer the dimension of some display elememnt (in pels) or system configuration setting.
		int GetSystemMetrics(
			int nIndex 	// system metric or configuration setting to retrieve  
		);"

	<stdcall: sdword GetSystemMetrics sdword>
	^self invalidCall!

getWindowDC: aWindowHandle
	"Answer the handle of a display device context (DC) which can be used to draw
	in the entire non-client area of the specified window. GetWindowDC assigns 
	default attributes to the window device context each time it retrieves the 
	device context. Previous attributes are lost. 

		HDC GetWindowDC(HWND hWnd);"

	<stdcall: handle GetWindowDC handle>
	^self invalidCall!

getWindowLong: aWindowHandle nIndex: zeroBasedIntegerOffset 
	"Answer various signed 32-bit integer values retrieved from the window with handle, aWindowHandle.
	If an unsigned value is required, use getWindowULong:nIndex:

		LONG GetWindowLong(
			HWND hWnd, // handle of window 
			int nIndex // offset of value to retrieve 
		);

	Valid offsets are in the range 0 to the number of bytes of extra window memory, minus the
	size of an int (4), or one of the following values: 

		GWL_EXSTYLE Extended window styles (WS_EX_XXX) 
		GWL_STYLE Window styles (WS_XXX) 

	Answers 0 if the function fails."

	<stdcall: sdword GetWindowLongA handle sdword>
	^self invalidCall!

inSendMessage
	<stdcall: bool InSendMessage>
	^self invalidCall!

isCharAlpha: aCharacter
	"Answer whether a character is an alphabetic character. This will dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
		BOOL IsCharAlpha(
			TCHAR  ch 	// character to test  
		);"

	<stdcall: bool IsCharAlphaA char>
	^self invalidCall!

isCharAlphaNumeric: aCharacter
	"Answer whether a character is an alphabetic character or a digit. This will dependent on the 
	semantics of the language selected by the user during setup or by using Control Panel.
		BOOL IsCharAlphaNumeric(
			TCHAR  ch 	// character to test  
		);"

	<stdcall: bool IsCharAlphaNumericA char>
	^self invalidCall!

isCharLower: aCharacter
	"Answer whether a character is a lowercase letter. This will dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
		BOOL IsCharLower(
			TCHAR  ch 	// character to test  
		);"

	<stdcall: bool IsCharLowerA char>
	^self invalidCall!

isCharUpper: aCharacter
	"Answer whether a character is an uppercase letter. This will dependent on the semantics of 
	the language selected by the user during setup or by using Control Panel.
		BOOL IsCharUpper(
			TCHAR  ch 	// character to test  
		);"

	<stdcall: bool IsCharUpperA char>
	^self invalidCall!

isChild: hWndParent hWnd: hWnd
	"Answer whether the window identified by the handle, hWnd, is 
	a child of the window identified by the handle, hWndParent."

	<stdcall: bool IsChild handle handle>
	^self invalidCall!

isIconic: aWindowHandle
	"Answer whether the specified window is iconic (minimized). 
		BOOL IsIconic(
			HWND hWnd 	// handle of window
		);"

	<stdcall: bool IsIconic handle>
	^self invalidCall!

isWindow: hWnd
	"Answer whether the window handle, hWnd, is currently valid"

	<stdcall: bool IsWindow handle>
	^self invalidCall!

isWindowEnabled: hWnd
	"Answer whether the window with handle, hWnd, is currently enabled (i.e.
	prepared to accept user input"

	<stdcall: bool IsWindowEnabled handle>
	^self invalidCall!

isWindowVisible: hWnd
	"Answer whether the window with handle, hWnd, is currently visible (i.e. not hidden)."

	<stdcall: bool IsWindowVisible handle>
	^self invalidCall!

isZoomed: aWindowHandle
	"Answer wether a window is zoomed (maximized). See also #isIconic:.
		BOOL IsZoomed(
			HWND hWnd 	// handle of window
		);"

	<stdcall: bool IsZoomed handle>
	^self invalidCall!

killTimer: aWindowHandle uIDEvent: anInteger
	"Destroy the specified timer. Any pending wmTimer: messages for the receiver
	are also removed.
		BOOL KillTimer(
			HWND hWnd,	// handle of window that installed timer
			UINT uIDEvent 	// timer identifier
		);"

	<stdcall: bool KillTimer handle dword>
	^self invalidCall!

loadCursor: anInstanceHandle lpCursorName: anIntegerID
	"Loads the specified cursor resource from the module with the specified handle
	Under Win32 it is not necessary to destroy cursors loaded in this manner.

		HCURSOR LoadCursor(
  			HINSTANCE  hInstance,	// handle of application instance
			LPCTSTR  lpCursorName 	// name string or cursor resource identifier  
		);"

	<stdcall: handle LoadCursorA handle lpvoid>
	^self invalidCall!

loadImage: hInst lpszName: filename uType: type cxDesired: w cyDesired: h fuLoad: flags
	"Load an icon, cursor, or bitmap.
		HANDLE LoadImage(
			HINSTANCE hinst, 	// handle of the instance that contains the image
			LPCTSTR lpszName,	// name or identifier of image
			UINT uType,		// type of image
			int cxDesired,		// desired width
			int cyDesired,		// desired height
			UINT fuLoad		// load flags
		);"

	<stdcall: handle LoadImageA handle lpvoid dword sdword sdword dword>
	^self invalidCall!

loadString: anExternalHandle uID: anIntegerID lpBuffer: aString nBufferMax: anIntegerLength
	"Load a string resource from the executable file associated with 
	the specified module, into the specified buffer appending
	a terminating null character. Answer the length of the string, or 0 
	if it does not exist.
		int LoadString(
			HINSTANCE hInstance,	// handle of module containing string resource 
			UINT uID,				// resource identifier 
			LPTSTR lpBuffer,		// address of buffer for resource 
			int nBufferMax 		// size of buffer
		);"

	<stdcall: sdword LoadStringA handle dword lpstr sdword>
	^self invalidCall!

mapVirtualKey: keyCode uMapType: mapType
	"Map a virtual-key code into a scan code or character value, or translate a scan code into a virtual-key code. 

	The Meaning of keycode and the result of the translation depends on the maptype:

		keyCode					Answer
	0	virtual key code		->	scan code
	1	scan code				->	virtual key code
	2	virtual key code		->	character value
	3	scan code				->	virtual key code	

		UINT	MapVirtualKey(
			UINT uCode,
			UINT uMapType);"

	<stdcall: dword MapVirtualKeyA dword dword>
	^self invalidCall!

messageBeep: anInteger
	"Plays a waveform identified by the argument, anInteger, in the registry.
			BOOL MessageBeep(
			UINT uType 	// sound type  
			);"
	
	<stdcall: bool MessageBeep dword>
	^self invalidCall!

messageBox: anExternalHandle text: textString caption: captionString style: styleInteger icon: iconIdentifier instance: hInstance 
	| iconId struct wasDisabled hWnd response isTaskModal osver dwStyle |
	osver := OSVERSIONINFO current.
	isTaskModal := styleInteger allMask: MB_TASKMODAL.
	hWnd := isTaskModal 
				ifTrue: [0]
				ifFalse: 
					["#2107: getActiveWindow may return nil, e.g. in a headless app with no windows"
					anExternalHandle ifNil: [UserLibrary default getActiveWindow ifNil: [0]]].
	struct := MSGBOXPARAMS new.
	dwStyle := styleInteger.
	struct lpszText: textString.
	struct lpszCaption: captionString.
	iconId := iconIdentifier.
	iconId isNil 
		ifTrue: 
			["Vista no longer supports MB_ICONQUESTION, so set it as a user icon instead."
			(osver isWinV6OrLater and: [styleInteger allMask: MB_ICONQUESTION]) 
				ifTrue: 
					[struct lpszIcon: IDI_QUESTION.
					dwStyle := (dwStyle maskClear: MB_ICONMASK) maskSet: MB_USERICON]]
		ifFalse: 
			["#1633: On NT systems if the icon has a string resource identifier it must
			be passed as a Unicode string even though we are calling the ANSI version of
			the MessageBoxIndirect() function!!. This is obviously a Windows bug which we
			need to work around."
			(iconId isInteger not and: [osver isNT]) ifTrue: [iconId := iconId asUnicodeString].
			struct lpszIcon: iconId asUIntPtr.
			hInstance notNil ifTrue: [struct hInstance: hInstance asParameter]].
	struct dwStyle: dwStyle.
	struct hwndOwner: hWnd.
	isTaskModal 
		ifTrue: 
			["If taskModal, then the owner will be the desktop so we need to get actual active view"
			hWnd := self getActiveWindow.
			"Ensure owner is (temporarily) enabled to prevent losing activation when box is closed"
			(wasDisabled := (self isWindowEnabled: hWnd) not) ifTrue: [self enableWindow: hWnd bEnable: true].
			response := 
					[SessionManager inputState startIdleTimer: hWnd.
					"Task modal only disables windows in the calling thread, so we can't use an
					overlapped call here."
					self messageBoxIndirect: struct] 
							ensure: [SessionManager inputState stopIdleTimer: hWnd]]
		ifFalse: 
			[wasDisabled := (self isWindowEnabled: hWnd) not.
			"MessageBoxIndirect is called using an overlapped call on a separate thread to avoid
			losing control of the message loop. If the initiating process is the UI process then its
			priority is boosted so that the operation requested by the user completes more quickly 
			when the dialog is closed."
			Processor forkMainIfMain 
				ifTrue: 
					[| proc |
					proc := Processor activeProcess.
					proc priority: proc priority + 1].
			response := self overlappedMsgBoxIndirect: struct].

	"The message box will unhelpfully re-enable the window regardless of whether previously disabled"
	wasDisabled ifTrue: [self enableWindow: hWnd bEnable: false].
	response == 0 ifTrue: [self systemError].
	^response!

messageBoxIndirect: aMSGBOXPARAMS
	"Open a message box with the details specified in the structure.

		int MessageBox(
			LPMSGBOXPARRAMS lpMsgBoxParams;
		);"

	<stdcall: sdword MessageBoxIndirectA MSGBOXPARAMS*>
	^self invalidCall!

msgWaitForMultipleObjects: countInteger pHandles: handles fWaitAll: aBoolean 
		dwMilliseconds: millisecsInteger dwWakeMask: maskInteger
	"Waits until when one of the following occurs: 
			either any one of, or all of (the number of handles being specified 
			by the argument, countInteger, and whether to wait for a single object
			or all of the objects being specified by the argument, waitBoolean), 
			the objects whose handles are specified by the argument, handles 
			(which may be a single handle, or an (TBD) ExternalHandleArray) are 
			in the signaled state; or
			A Win32 message of a type which matches the type mask specified by
			the argument, maskInteger, becomes available in the message queue (
			uses the same flags as #getQueueStatus:); or
			the number of milliseconds specified by the argument, millisecsInteger,
			elapses.

	MsgWaitForMultipleObjects should only be called when there are no further messages
	waiting in the input queue, because it only detects the arrival of new messages.

	N.B. Under NT, the handles in the argument, handles, must have SYNCHRONIZE access.

	If successful, answer the event that cause the function to return. See Win32 documentation
	for specific return values. If the function fails, answers -1. KernelLibrary>>getLastError
	can be used to get extended error information

		DWORD MsgWaitForMultipleObjects(
			DWORD  nCount,				// number of handles in handle array  
			LPHANDLE  pHandles,			// address of object-handle array 
			BOOL  fWaitAll,				// wait for all or wait for one 
			DWORD  dwMilliseconds,		// time-out interval in milliseconds 
			DWORD  dwWakeMask 			// type of input events to wait for 
		);"

	<stdcall: sdword MsgWaitForMultipleObjects dword lpvoid bool dword dword>
	^self invalidCall!

msgWaitForMultipleObjectsEx: countInteger pHandles: handles 
		dwMilliseconds: millisecsInteger 
		dwWakeMask: maskInteger
		dwFlags: aBoolean 
	"Waits until when one of the following occurs: 
			either any one of, or all of (the number of handles being specified 
			by the argument, countInteger, and whether to wait for a single object
			or all of the objects being specified by the argument, waitBoolean), 
			the objects whose handles are specified by the argument, handles 
			(which may be a single handle, or a DWORDArray) are 
			in the signaled state; or
			A Win32 message of a type which matches the type mask specified by
			the argument, maskInteger, becomes available in the message queue (
			uses the same flags as #getQueueStatus:); or
			the number of milliseconds specified by the argument, millisecsInteger,
			elapses.

	MsgWaitForMultipleObjects should only be called when there are no further messages
	waiting in the input queue, because it only detects the arrival of new messages (this is fixed
	in Win98 and NT5 with the addition of the MWMO_INPUTAVAILABLE flag).

	N.B. Under NT, the handles in the argument, handles, must have SYNCHRONIZE access.

	If successful, answer the event that cause the function to return. See Win32 documentation
	for specific return values. If the function fails, answers -1. KernelLibrary>>getLastError
	can be used to get extended error information

		DWORD MsgWaitForMultipleObjectsEx(
			DWORD nCount,
			LPHANDLE pHandles,
			DWORD dwMilliseconds,
			DWORD dwWakeMask,
			DWORD dwFlags)
	"

	<stdcall: sdword MsgWaitForMultipleObjectsEx dword lpvoid dword dword dword>
	^self invalidCall!

overlappedMsgBoxIndirect: aMSGBOXPARAMS
	"Private - Open a message box with the details specified in the structure
	as an overlapped call (i.e. on a separate thread).
	N.B. Don't use for MB_TASKMODAL message boxes.

		int MessageBox(
			LPMSGBOXPARRAMS lpMsgBoxParams;
		);"

	<overlap stdcall: sdword MessageBoxIndirectA MSGBOXPARAMS* >
	^self invalidCall!

peekMessage: aMSG hWnd: aWindowHandle uMsgFilterMin: anIntFilterMin uMsgFilterMax: uMsgFilterMax wRemoveMsg: anIntFlags
	"Check the threads message queue for messages for the Window with
	handle aWindowHandle (all windows if nil/0, app messages if -1) in the range
	anIntFilterMin..anIntFilterMax (all messages if 0..0), retrieving 
	the first (if any) of such messages into aMSG, answering whether 
	a message was found. The message is optionally removed from the 
	queue depending on the value of the argument, anIntFlags (PM_REMOVE/
	PM_NOREMOVE). The flag value PmNoYield is obsolete, and has no effect
	in Win32.

		BOOL PeekMessage(
			LPMSG  lpMsg,			// address of structure for message
			HWND  hWnd,			// handle of window
			UINT  uMsgFilterMin,	// first message
			UINT  uMsgFilterMax,	// last message
			UINT  wRemoveMsg 		// removal flags
		);"

	<stdcall: bool PeekMessageA MSG* handle dword dword dword>
	^self invalidCall!

postMessage: aWindowHandle msg: msg wParam: wParam lParam: lParam
	"Post a message to aWindowHandle.

	LRESULT PostMessage(
		HWND hWnd, 		// handle of destination window
		UINT Msg, 		// message to send
		WPARAM wParam, 	// first message parameter
		LPARAM lParam 		// second message parameter
	   );"

	<stdcall: intptr PostMessageA handle dword uintptr intptr>
	^self invalidCall !

postQuitMessage: anInteger
	"Post a WM_QUIT message to the current thread, initiating system shutdown.
		VOID PostQuitMessage(
			int  nExitCode 	// exit code
		);"

	<stdcall: void PostQuitMessage sdword>
	^self invalidCall !

postThreadMessage: anIntegerId msg: msg wParam: wParam lParam: lParam
	"Post a message to the message queue of the specified thread for asynchronous processing.
		BOOL PostThreadMessage(
  			DWORD  idThread,	// thread identifier
			UINT  Msg,		// message to post
			WPARAM  wParam,	// first message parameter
			LPARAM  lParam 	// second message parameter);"

	<stdcall: bool PostThreadMessageA handle dword uintptr uintptr>
	^self invalidCall !

registerHotKey: aWindowHandle id: anIntegerId fsModifiers: anIntegerFlags vk: anIntegerVk
	"Define a hot key for the current thread.
		BOOL RegisterHotKey(
		  	HWND  hWnd,		// window to receive hot-key notification
			int  id,			// identifier of hot key
			UINT  fsModifiers,	// key-modifier flags
			UINT  vk 			// virtual-key code
		);"

	<stdcall: bool RegisterHotKey handle sdword dword dword>
	^self invalidCall!

releaseDC: hDC
	"Release the specified device context. This is the second half of the 'DC source' protocol,
	and is intended to release the desktop DCs created by the receiver's implementation of #getDC.
	Answer whether the DC was indeed released."

	^(self 
		releaseDC: self getDesktopWindow
		hDC: hDC asParameter) == 1!

releaseDC: hWnd hDC: hDC
	"Releases a device context (DC) (if a common or window device context -
	class and private DCs are unaffected).

		int ReleaseDC(
			HWND hWnd,	// handle of window 
			HDC hDC 		// handle of device context  
		);"

	<stdcall: sdword ReleaseDC handle handle>
	^self invalidCall
!

sendMessage: aWindowHandle msg: msg wParam: wParam lParam: lParam
	"The SendMessage function sends the specified message to a window or windows.
	The function calls the window procedure for the specified window and does not
	return until the window procedure has processed the message. The PostMessage
	function, in contrast, posts a message to a thread's message queue and returns
	immediately. 

	Implementation Note: Although LPARAM is defined as a signed parameter, more often
	than not it is used to pass an unsigned 32-bit value. As we have a strict definition
	of what can be passed to a signed integer parameter (i.e. only valid two's complement 
	values that fit within the required size), we used the slightly more relaxed unsigned 
	specification. This allows LargeIntegers > the maximum positive signed value for
	the machine word size to be passed.

	LRESULT SendMessage(
		HWND hWnd, 		// handle of destination window
		UINT Msg, 		// message to send
		WPARAM wParam, 	// first message parameter
		LPARAM lParam 		// second message parameter
	   );"

	<stdcall: intptr SendMessageA handle dword uintptr uintptr>
	^self invalidCall !

sendMessage: aWindowHandle msg: msg wParam: wParam lpParam: lParam
	"As sendMessage:msg:wParam:lParam, but implicit conversion of lParam
	to pointer."

	<stdcall: sdword SendMessageA handle dword dword lpvoid>
	^self invalidCall !

sendMessage: aWindowHandle msg: msg wpParam: wParam lpParam: lParam
	"As sendMessage:msg:wParam:lParam, but implicit conversion of lParam
	and wParam to pointers."

	<stdcall: sdword SendMessageA handle dword lpvoid lpvoid>
	^self invalidCall !

setActiveWindow: aHandle
  	"Makes the specified top-level window associated with the current thread the active window. 
		HWND SetActiveWindow( HWND hWnd);"

	<stdcall: handle SetActiveWindow handle>
	^self invalidCall!

setCursor: aWindowHandle
	"Set the current system cursor to the argument. N.B. This has only a temporary effect, as the system will
	change the cursor whenever it moves over a window which either has a class Cursor set, or responds to the
	the WM_SETCURSOR message. See the Cursor class.

		HCURSOR SetCursor(
  			HCURSOR  hCursor 	// handle of cursor
		);"

	<stdcall: handle SetCursor handle>
	^self invalidCall!

setDlgItemText: aWindowHandle nIDDlgItem: anIntegerId lpString: aString
	"Sets the title or text of a control in a dialog box. 
		BOOL SetDlgItemText(
  			HWND  hDlg,		// handle of dialog box
			int  nIDDlgItem,	// identifier of control
			LPCTSTR  lpString 	// text to set
			);"

	<stdcall: bool SetDlgItemTextA handle sdword lpvoid>
	^self invalidCall!

setKeyboardState: a256ByteArray
	"Copy the specified 256-byte array of keyboard key states into the 
	keyboard-input state table (also accessed by the GetKeyboardState and 
	GetKeyState functions). Changes made to the table affect only the calling
	thread.
		BOOL SetKeyboardState(
  			LPBYTE lpKeyState 	// address of array with virtual-key codes
		   );"

	<stdcall: bool SetKeyboardState lpvoid>
	^self invalidCall!

setTimer: aWindowHandle nIDEvent: anIntegerId uElapse: anInteger lpTimerFunc: callbackProc
	"Create a timer with the specified time-out value.
	N.B. The preferred method of performing time triggered activities in Dolphin is to make
	use of Delays in conjunction with Processes. These are more portable, powerful, flexible, 
	and have a higher resolution capability.
		UINT SetTimer(
			HWND hWnd,	// handle of window for timer messages
			UINT nIDEvent,	// timer identifier
			UINT uElapse,	// time-out value
			TIMERPROC lpTimerFunc 	// address of timer procedure
		);"

	<stdcall: dword SetTimer handle dword dword lpvoid>
	^self invalidCall
!

setWindowDWORD: aWindowHandle nIndex: offset dwNewDWORD: value 
	"See #setWindowLong:nIndex:dwNewLong: value, but note this expects an unsigned 32-bit
	integer as its last argument, and always returns a positive integer constructed by treating
	the return value as unsigned."

	<stdcall: dword SetWindowLongA handle sdword dword>
	^self invalidCall!

setWindowText: aWindowHandle lpString: aString
	"Set the 'text' of the specified window.
		BOOL SetWindowText(
			HWND hWnd,	// handle of window or control
			LPCTSTR lpString 	// address of string
		);"

	<stdcall: bool SetWindowTextA handle lpvoid>
	^self invalidCall!

showWindow: aWindowHandle nCmdShow: flags
	"Set the specified window's show state. 
		BOOL ShowWindow(
			HWND hWnd,	// handle of window
			int nCmdShow 	// show state of window
		);"

	<stdcall: bool ShowWindow handle sdword>
	^self invalidCall!

stringLower: aString
	"Convert aString to lower case IN PLACE. This will be dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
	N.B. We ignore the return value as it will be a pointer to the argument.

		LPTSTR CharLower(LPTSTR  lpsz); 	// single character or pointer to string "

	<stdcall: void CharLowerA lpvoid>
	^self invalidCall!

stringLowerA: aString 
	"Convert aString to lower case IN PLACE. This will be dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
	N.B. We ignore the return value as it will be a pointer to the argument.

		LPTSTR CharLower(LPTSTR  lpsz); 	// single character or pointer to string "

	<stdcall: void CharLowerA lpvoid>
	^self invalidCall!

stringLowerW: aUnicodeString 
	"Convert a <UnicodeString> to lower case IN PLACE. This will be dependent on the semantics
	of the language selected by the user during setup or by using Control Panel. N.B. We ignore
	the return value as it will be a pointer to the argument.

	LPWSTR CharLower(LPWSTR lpsz); // single character or pointer to string "

	<stdcall: void CharLowerW lpvoid>
	^self invalidCall!

stringUpper: aString
	"Convert aString to uppercase IN PLACE. This will be dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
	N.B. We ignore the return value as it will be a pointer to the argument.

		LPTSTR CharUpper(LPTSTR  lpsz); 	// single character or pointer to string "

	<stdcall: void CharUpperA lpvoid>
	^self invalidCall!

stringUpperA: aString 
	"Convert aString to uppercase IN PLACE. This will be dependent on the semantics of the 
	language selected by the user during setup or by using Control Panel.
	N.B. We ignore the return value as it will be a pointer to the argument.

		LPTSTR CharUpper(LPTSTR  lpsz); 	// single character or pointer to string "

	<stdcall: void CharUpperA lpvoid>
	^self invalidCall!

stringUpperW: aUnicodeString 
	"Convert a <UnicodeString> to uppercase IN PLACE. This will be dependent on the semantics of
	the language selected by the user during setup or by using Control Panel. N.B. We ignore the
	return value as it will be a pointer to the argument.

	LPTWTR CharUpper(LPWSTR lpsz);"

	<stdcall: void CharUpperW lpvoid>
	^self invalidCall!

systemParametersInfo: uiAction uiParam: param1 pvParam: param2 fWinIni: update
	"
	BOOL SystemParametersInfo(
		UINT uiAction,	// system parameter to query or set
		UINT uiParam,	// depends on action to be taken
		PVOID pvParam,	// depends on action to be taken
		UINT fWinIni 	// user profile update flag
	);"

	<stdcall: bool SystemParametersInfoA dword dword lpvoid dword>
	^self invalidCall!

translateMessage: aMSG
	"Translates virtual-key messages into character messages, posting them to the message queue to
	be read by subsequent calls to #getMessage:etc or #peekMessage:etc.

		BOOL TranslateMessage(
			CONST MSG *lpMsg 	// address of structure with message
		);"

	<stdcall: bool TranslateMessage MSG* >
	^self invalidCall!

unregisterHotKey: aWindowHandle id: anIntegerId
	<stdcall: bool UnregisterHotKey handle sdword>
	^self invalidCall!

updateWindow: hWnd
	"Repaint the client area of the specified window by sending a wmPaint: directly to
	the window if its update region is not empty.
		BOOL UpdateWindow(
			HWND hWnd 	// handle of window  
		);"

	<stdcall: bool UpdateWindow handle>
	^self invalidCall!

vkKeyScan: aChar
	"Translate a character to the corresponding virtual-key code 
	and shift state for the current keyboard.
		SHORT VkKeyScan(
			TCHAR ch 	// character to translate
	   );"

	<stdcall: sword VkKeyScanA char>
	^self invalidCall

! !

VMLibrary comment:
'VMLibrary is an <ExternalLibrary> to represent the Dolphin Smalltalk Virtual Machine (VM). 

The VM contains, for example, a number of exports to implement pseudo-primitive operations, in particular to simplify the interface to other external library functions, and external call methods to access these exported functions are implemented here.

Instance Variables:
	wndProc 		- <Integer> address of the VM''s window procedure.
	dlgProc 		- <ExternalAddress>. Pointer to the VM''s dialog procedure.
	genericCallback 	- <Integer> address of the VM''s common callback entry point.
	vtable		- <ExternalAddress>. Pointer to the VM''s common virtual table (for implementing C++/COM objects).

Class Variables:
	Registry		- <Array> of <Object>s shared between the VM and the image. 	N.B. It is not possible to modify this object directly, as it is read-only.
	RegistryKeys	- <LookupTable> mapping symbolic names to the <Integer> indices of objects in the VM registry.
'!
!VMLibrary class methodsFor!

fileName
	"Answer the host system file name of the library. This may vary."

	^self shouldNotImplement!

initialize
	"Private - Initialize the receiver's class variables - see class comment for further details.

		VMLibrary initialize
	"

	"Registry := DO NOT ASSIGN ME."

	RegistryKeys := (IdentityDictionary new)
				at: #Smalltalk put: 9;
				at: #Processor put: 10;
				at: #arithmeticSelectors put: 16;
				at: #commonSelectors put: 31;
				at: #Metaclass put: 81;
				at: #Character put: 82;
				at: #Array put: 83;
				at: #String put: 84;
				at: #Symbol put: 85;
				at: #SmallInteger put: 86;
				at: #Process put: 87;
				at: #CompiledMethod put: 88;
				at: #Context put: 89;
				at: #BlockClosure put: 90;
				at: #Message put: 91;
				at: #ByteArray put: 92;
				at: #UnicodeString put: 93;
				at: #CompiledExpression put: 94;
				at: #ExternalMethod put: 95;
				at: #Float put: 96;
				at: #UndefinedObject put: 97;
				at: #VariableBinding put: 98;
				at: #Semaphore put: 99;
				at: #ExternalAddress put: 100;
				at: #ExternalHandle put: 101;
				at: #Dispatcher put: 102;
				at: #LPVOID put: 103;
				at: #PoolConstantsDictionary put: 105;
				at: #LargeInteger put: 107;
				at: #VARIANT put: 108;
				at: #BSTR put: 109;
				at: #DATE put: 110;
				at: #Corpse put: 111;
				at: #InputSemaphore put: 112;
				at: #FinalizeSemaphore put: 113;
				at: #BereavementSemaphore put: 114;
				at: #FinalizeQueue put: 118;
				at: #BereavementQueue put: 119;
				at: #GUID put: 120;
				at: #KernelHandle put: 121;
				at: #VMHandle put: 122;
				at: #DolphinHandle put: 123;
				at: #IUnknown put: 124;
				at: #WakeupEvent put: 125;
				at: #MsgWndHandle put: 127;
				at: #IDispatch put: 128;
				at: #ImageVersionMajor put: 129;
				at: #ImageVersionMinor put: 130;
				at: #CRTHandle put: 132;
				at: #MemoryManager put: 133;
				at: #BYTE put: 134;
				at: #SBYTE put: 135;
				at: #WORD put: 136;
				at: #SWORD put: 137;
				at: #DWORD put: 138;
				at: #SDWORD put: 139;
				at: #FLOAT put: 140;
				at: #DOUBLE put: 141;
				at: #VARIANT_BOOL put: 142;
				at: #CURRENCY put: 143;
				at: #DECIMAL put: 144;
				at: #LPBSTR put: 145;
				at: #ULARGE_INTEGER put: 146;
				at: #LARGE_INTEGER put: 147;
				at: #UINT_PTR put: 148;
				at: #INT_PTR put: 149;
				shrink;
				yourself!

maxBlockNesting
	^VMConstants.MaxBlockNesting!

maxLiterals
	^VMConstants.MaxLiterals!

maxMessageArguments
	^VMConstants.MaxMessageArgs!

maxTemps
	^VMConstants.MaxTemps!

open
	"Answer the singleton instance of the receiver (it cannot be re-opened)"

	^default!

registryKeys
	"Private - Answer the map between symbolic names and VM registry indices."

	^RegistryKeys! !

!VMLibrary methodsFor!

addressFromInteger: anInteger
	"Private - Answer a new ExternalAddress instantiated from the argument.
	Implementation Note: AnswerDWORD() is a simple function which returns its 32-bit argument.
	By appropriately specifying the argument and return types, we can use external call
	primitive's argument coercion and return object instantiation, to perform useful type
	conversions very quickly."

	<stdcall: lpvoid AnswerDWORD dword>
	^self invalidCall!

applicationHandle
	"Answer the handle of the Dolphin application instance."

	^Registry at: 123!

basePatchLevel
	"Private - Answer the base patch level of this image. We can assume that the image already
	incorporates patches to this level so we don't allow patches below this to be installed"

	^0!

bytecodeVersion
	"Answer the <integer> bytecode version number.
		VMLibrary default bytecodeVersion
	"

	^Integer fromString: (self versionInfo at: 'PrivateBuild')!

compilerFileName
	"Private - Answer the name of the compiler library."

	^self fileName!

crashDump: message 
	"Private - Write a full VM state log to the crash dump file with the <readableString>,
	message, as an exception argument which will appear in the dump.
	This can be handy for debugging in run-time systems when you detect an
	unexpected situation and want the sort of information available in the crash
	dump (the stack state at the time, etc), but you don't actually want to raise a
	non-continuable exception.
		VMLibrary default crashDump: 'Hello'
	N.B. In order for a crash dump to be produced the registry on the machine
	must be appropriately configured."

	| parms |
	parms := ByteArray new: VMConstants.IntPtrSize.
	parms intPtrAtOffset: 0 put: message yourAddress.
	KernelLibrary default 
		raiseException: 16r20000002
		dwExceptionFlags: 0
		nNumberOfArguments: 1
		lpArguments: parms	"Special exception code recognised by the VM"!

crtHandle
	"Private - Answer the handle of the CRTLibrary. This cannot be obtained in the normal way
	as we do not necessarily know which CRT library the VM is itself using."

	^self registryAt: #CRTHandle!

debugDump: msgString
	"Write a VM state log with unconstrained stack and walkback dumps to 
	the OS debug trace device with <readableString> message, 
	msgString, as the header description"

	<stdcall: void DebugDump lpstr>
	^self invalidCall
!

defaultProductDetails
	"Private - Answers an eight element<Array> describing the default
	 version of the development environment as based on the VM version.

	1. <readableString> Product name 
	2. <readableString> Short product name
	3. <Float> Version number
	4. <readableString> Version special
	5. <Integer> Image patch level
	6 <readableString> Very short name
	7 <readableString> Serial number
	8 <readableString> Boot source version information"

	| version |
	version := self versionInfo.
	^(Array new: 8)
		at: 1 put: (version formatVersionString: '%1 %2!!d!!');
		at: 2 put: (version formatVersionString: '%1');
		at: 3 put: (Float fromString: (version formatVersionString: '%3!!d!!.%4!!d!!'));
		at: 4 put: version specialBuild;
		at: 5 put: self basePatchLevel;
		at: 6 put: 'D7';
		at: 7 put: nil; "Serial #"
		at: 8 put: nil; "Boot info"
		yourself!

displayDesktopMessage: aString 
	<stdcall: handle DisplayDesktopMessage lpstr>
	^self invalidCall
!

dump: msgString path: pathString stackDepth: slotsInteger walkbackDepth: framesInteger
	"Write a VM state log to the file with <readableString> path, pathString, with the 
	<readableString> message, msgString, as the header description, and with the
	stack and walkback depths constrained to the depths specified by the <integer>s, 
	slotInteger and framesInteger, respectively (-1 can be used for unconstrained
	dumps). If either depth is less than that required to dump the entire stack, then
	stack slots or frames (respectively) will be omitted from the dump. In the case of
	the raw stack dump, slots are omitted from the middle of the stack. In the case
	of the walkback, frames are omitted at the bottom of the stack.
	This method can be handy for debugging in run-time systems when you detect an
	unexpected situation and want the sort of information available in the crash
	dump (the stack state at the time, etc), but you don't actually want to raise a
	non-continuable exception, and you want want to output a crash dump using
	parameters (such as the log file) other than those in the registry."

	<stdcall: void Dump lpstr lpstr sdword sdword>
	^self invalidCall
!

errorIntegerMoreThan32Bits: anInteger
	"Private - Raise an exception to the effect that anInteger cannot be represented
	as a 32-bit two's complement integer (it's too 'large')."

	^self error: anInteger displayString, ' is too large for 32-bit two''s complement representation.'!

fullVersion
	"Answer a String which describes the full name and version number of the VM."

	^self versionInfo formatVersionString: '%1 %2!!d!! release %3!!d!!.%4!!d!!%5!!d!!'!

getDlgProc
	"Private - Answer a pointer to the VM's dialog window procedure.
	The dialog window procedure does nothing except return 0. It's purpose is to act
	as the target of a CallDefaultProc() in order to regularize the interface
	so that there is no difference in handling between dialogs and non-dialogs."

	dlgProc isNil ifTrue: [ dlgProc := self getProcAddress: 'DlgProc' ].
	^dlgProc!

getGenericCallback
	"Private - Answer a pointer to the VM's generic callback function."

	genericCallback isNil ifTrue: [ 
		genericCallback := KernelLibrary default 
				getProcAddressDWORD: self asParameter lpProcName: 'GenericCallback'].
	^genericCallback!

getVTable
	"Private - Answer a pointer to the VM's vtable (a fixed size virtual
	function pointer table for use in conjunction with the COM implementation)."

	vtable isNil ifTrue: [vtable := self getProcAddress: 'VTable'].
	^vtable!

getWndProc
	"Answer a pointer to the VM's window procedure. The VM's window procedure does very little
	except forward messages to Smalltalk for dispatching to the appropriate Window. It
	calls the windows default proc (either the proc. before the window was subclassed by Dolphin
	or the DefWindowProc if a Dolphin Window) if a non-integer value is returned to it."

	"There is not point throwing an error here if it fails, because that will be terminal anyway."
	wndProc isNil ifTrue: [ 
		wndProc := KernelLibrary default 
			getProcAddressDWORD: self asParameter lpProcName: 'WndProc' ].
	^wndProc!

handleFromInteger: anInteger
	"Private - Answer a new ExternalHandle instantiated from the argument.
	Implementation Note: AnswerDWORD() is a simple function which returns its 32-bit argument.
	By appropriately specifying the argument and return types, we can use external call
	primitive's argument coercion and return object instantiation, to perform useful type
	conversions very quickly."

	<stdcall: handle AnswerDWORD dword>
	^ExternalHandle new value: anInteger asInteger!

hashBytes: bytes count: count
	"Private - Hash the specified number of bytes at the specified address using the
	function which implements the standard byte hashing primitive (106).
	Implementation Notes: The algorithm is from Aho, Sethi, and Ullman. 
	The Smalltalk code is included for documentary purposes only."

	| hash |
	<cdecl: sdword HashBytes lpvoid dword>

	hash := 0.
	1 to: count do: [:i |
		hash := (hash bitShift: 4) + (bytes basicAt: i).
		hash > 16rFFFFFFF ifTrue: [
			hash := (hash bitAnd: 16rFFFFFFF) bitXor: ((hash bitShift: -24) bitAnd: 16rF0)]].
	^hash!

highBit: anInteger
	"Answer the index of the high bit of the argument."

	<stdcall: sdword highBit dword>
	^self invalidCall!

indexOfSpecialSelector: aSymbol ifAbsent: exceptionHandler
	"Private - Answer the index of the special selector, aSymbol, or 
	the result of evalating the niladic valuable, exceptionHandler,
	if aSymbol is not a Special Selector."

	| index |
	index := Registry 
				nextIdentityIndexOf: aSymbol
				from: specialSelectorStart
				to: specialSelectorStart + 31.
	^index == 0 
		ifTrue: [exceptionHandler value]
		ifFalse: [index - specialSelectorStart + 1]!

isSlowMachine
	"Answer true if this machine is judged to be slow."

	^(UserLibrary default getSystemMetrics: SM_SLOWMACHINE) ~~ 0

"
	VMLibrary default isSlowMachine
"!

kernelHandle
	"Private - Answer the handle of the KernelLibrary. This cannot be obtained in the normal way
	because there is a bit of a chicken and egg problem."

	^self registryAt: #KernelHandle!

largeSignedFromUnsigned: anInteger
	"Private - Answer a 64-bit signed integer value instantiated from the unsigned integer
	argument. Use the VM's external call primitive to perform the conversion very quickly."

	<stdcall: sqword AnswerQWORD qword>
	^self invalidCall!

largeUnsignedFromSigned: anInteger
	"Private - Answer a 64-bit signed integer value instantiated from the signed integer
	argument. Use the VM's external call primitive to perform the conversion very quickly."

	<stdcall: qword AnswerQWORD sqword>
	^self invalidCall!

makeLargeSigned: aLARGE_INTEGER
	"Private - Answer an Integer (a SmallInteger or a LargeInteger, whichever is the minimum
	representation) instantiated from the 64-bit signed integer argument.
	This routine is used by the external call primitives, and is exported from the VM
	for reuse from Smalltalk or external primitives."

	<stdcall: sqword AnswerQWORD qword>
	^self invalidCall!

makeLargeSigned: highSDWORD highPart: lowSDWORD
	"Private - Answer an Integer of up to 64 bits, as necessary, to represent the signed
	integer formed from the high and low order DWORD arguments. The result will be zero
	if highSDWORD has its high bit set.
	This routine is an example of a function returing a signed 8-byte integer (sqword)."

	<stdcall: sqword AnswerQWORD sdword dword>
	^self invalidCall!

makeLargeUnsigned: eightBytes
	"Private - Answer a positive Integer (i.e. a SmallInteger or a LargeInteger)
	instantiated from the 64-bit argument."

	<stdcall: qword AnswerQWORD qword>
	^self invalidCall!

makeLargeUnsigned: lowDWORD highPart: highDWORD
	"Private - Answer an Integer of up to 64 bits, as necessary, to represent the unsigned
	integer formed from the high and low order DWORD arguments.
	This routine is an example of a qword (8-byte Integer) return type."

	<stdcall: qword AnswerQWORD dword dword>
	^self invalidCall!

onStartup
	"Initialize the receiver immediately following system startup.
	THIS MUST BE DONE FIRST."

	handle := Registry at: 122.
	specialSelectorStart :=  RegistryKeys at: #arithmeticSelectors.
	wndProc := dlgProc := vtable := genericCallback := nil!

primRegistryAt:  anInteger put: anObject
	"Private - Generic VM object registering primitive. Used to register cookies, Semaphores,
	the Corpse object, etc.

	Equivalent to 'Registry at: anInteger put: anObject', but allows the VM to reload any
	information it caches.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of the bounds of the registry
		2 -	anObject is not of the appropriate class for the object being registered."

	<primitive: 93>
	^self primitiveFailed!

productName
	"Answer the localised name for Dolphin."

	^self versionInfo productName
!

registerEventSource: aString
	<stdcall: handle RegisterAsEventSource lpstr>
	^self invalidCall
!

registry
	"Private - Answer the VM registry of objects."

	^Registry!

registryAt: aSymbol
	"Private - Answer the VM registered object with the name, aSymbol."

	^Registry at: (RegistryKeys at: aSymbol)!

registryAt: aSymbol put: anObject
	"Private - Register the argument, anObject, as the VM registered object with the name,
	aSymbol."

	self primRegistryAt: (RegistryKeys at: aSymbol) put: anObject.
	^anObject!

removeDesktopMessage: anExternalHandle
	<stdcall: void RemoveDesktopMessage handle>
	^self invalidCall!

shortName
	"Answer the localised short name for Dolphin."

	^String fromId: 129 in: self!

signedFromUnsigned: anInteger
	"Private - Answer a 32-bit signed integer value instantiated from the unsigned 32-bit integer
	argument. Use the VM's external call primitive to perform the conversion very quickly."

	<stdcall: sdword AnswerDWORD dword>
	^anInteger isInteger
		ifTrue: [self errorIntegerMoreThan32Bits: anInteger]
		ifFalse: [self invalidCall]!

specialSelectors
	"Private - Answer the 32 special selectors.
		VMLibrary default specialSelectors
	"

	^self registry copyFrom: specialSelectorStart to: specialSelectorStart+31!

stringFromAddress: pointer 
	"Private - Answer a new String instantiated from the null-terminated String pointed 
	at by the argument.
	Implementation Note: AnswerDWORD() is a simple function which returns its 32-bit argument.
	By appropriately specifying the argument and return types, we can use external call
	primitive's argument coercion and return object instantiation, to perform useful type
	conversions very quickly."

	| addr len |
	<stdcall: lpstr AnswerDWORD lpvoid>
	addr := pointer isInteger ifTrue: [pointer asExternalAddress] ifFalse: [pointer].
	len := addr indexOf: 0.
	^addr copyStringFrom: 1 to: len - 1!

unlockVM: productId expireAfter: months flags: flags
	"Private - Attempts to unlock the image. Registers the given <Integer> productId within the image
	and extends the expiry period by <Integer> months. If months is zero then the expiry period is
	extended indefinitely. The <integer>, flags, specifies various flags. At present the only flag is
	16r1, meaning that the image is to be machine locked (i.e. a fixed rather than floating license)."

	<primitive: 93>
	^self error: 'Unable to unlock image - please contact Dolphin Support'!

unregisterObject: anObject 
	| i |
	i := self registry identityIndexOf: anObject.
	i > 0 ifTrue: [
		Notification signal: 'Unregistering VM ref ', anObject printString.
		self primRegistryAt: i put: nil]!

unsignedFromSigned: anInteger
	"Private - Answer a 32-bit unsigned integer value instantiated from the signed 32-bit integer
	argument.
	Implementation Note: AnswerDWORD() is a simple function which returns its 32-bit argument.
	By appropriately specifying the argument and return types, we can use external call
	primitive's argument coercion and return object instantiation, to perform useful type
	conversions very quickly."

	<stdcall: dword AnswerDWORD sdword>
	^anInteger isInteger
		ifTrue: [self errorIntegerMoreThan32Bits: anInteger]
		ifFalse: [self invalidCall]!

versionFormatString
	"Private - Answer a String containing the version format used by the receiver."

	^'%3!!d!!.%4!!d!!%5!!d!!'! !

_FPIEEE_RECORD comment:
'_FPIEEE_RECORD is an <ExternalStructure> class to represent the Win32 structure of the same name. _FPIEEE_RECORD is used in the reporting of IEEE compliant floating point exceptions.'!
!_FPIEEE_RECORD class methodsFor!

defineFields
	"Define the fields of the _FPIEEE_RECORD 'structure'. The _FPIEEE_RECORD is a
	rather complex structure containing details of a floating point exception.

		self compileDefinition
	"

	self
		defineField: #flags type: DWORDField readOnly;
		defineField: #cause type: DWORDField readOnly;
		defineField: #enable type: DWORDField readOnly;
		defineField: #status type: DWORDField readOnly beUncompiled;
		defineField: #operand1 type: (StructureField type: _FPIEEE_VALUE) beReadOnly;
		defineField: #operand2 type: (StructureField type: _FPIEEE_VALUE) beReadOnly;
		defineField: #result type: (StructureField type: _FPIEEE_VALUE) beFiller!

exceptionFlags
	^#(#Inexact #Underflow #Overflow #ZeroDivide #InvalidOperation)!

operationCodes
	^#(#Add #Subtract #Multiply #Divide #SquareRoot #Remainder #Compare #Convert #Round #Truncate #Floor #Ceil #Acos #Asin #Atan #Atan2 #Cabs #Cos #Cosh #Exp #Fabs #Fmod #Frexp #Hypot #Ldexp #Log #Log10 #Modf #Pow #Sin #Sinh #Tan #Tanh #Y0 #Y1 #Yn #Logb #Nextafter #Negate #Fmin #Fmax #ConvertTrunc #Addps #Addss #Subps #Subss #Mulps #Mulss #Divps #Divss #Sqrtps #Sqrtss #Maxps #Maxss #Minps #Minss #Cmpps #Cmpss #Comiss #UComiss #Cvtpi2ps #Cvtsi2ss #Cvtps2pi #Cvtss2si #Cvttps2pi #Cvttss2si #Addsubps #Haddps #Hsubps #Roundps #Roundss #Dpps #Addpd #Addsd #Subpd #Subsd #Mulpd #Mulsd #Divpd #Divsd #Sqrtpd #Sqrtsd #Maxpd #Maxsd #Minpd #Minsd #Cmppd #Cmpsd #Comisd #UComisd #Cvtpd2pi #Cvtsd2si #Cvttpd2pi #Cvttsd2si #Cvtps2pd #Cvtss2sd #Cvtpd2ps #Cvtsd2ss #Cvtdq2ps #Cvttps2dq #Cvtps2dq #Cvttpd2dq #Cvtpd2dq #Addsubpd #Haddpd #Hsubpd #Roundpd #Roundsd #Dppd #Fma #FmaSingle #FmaDouble #Fms #FmsSingle #FmsDouble #Fnma #FnmaSingle #FnmaDouble #Famin #Famax)!

precisionModes
	^#(#Full 53 24 64 113)!

roundingModes
	^#(#Nearest #MinusInfinity #PlusInfinity #Chopped)! !

!_FPIEEE_RECORD methodsFor!

cause
	"Answer the receiver's cause field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #cause)!

causeNames
	"Answer the symbolic names of the type of floating point exception the receiver
	represents, separated by vertical bars."

	| stream |
	stream := String writeStream.
	self class printFlags: self cause on: stream.
	^stream contents!

flags
	"Answer the receiver's flags field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

isDivide
	"Answer whether a division operation was being attemped when the exception occurred."

	^self operation == 4!

isOverflow
	"Answer whether this IEEE FP exception record represents a floating point
	underflow error."

	^self cause isBitSet: 3!

isUnderflow
	"Answer whether this IEEE FP exception record represents a floating point
	underflow error."

	^self cause isBitSet: 2!

isZeroDivide
	"Answer whether this IEEE FP exception record represents a floating point
	division by zero error.
	Implementation Note: Division by zero is signalled as either a ZeroDivide
	or InvalidOperation, the latter cause identifying 0 is divided by 0.
	When dividing by integer 0, it appears that the value of the second
	operand is not reliably set up, so we assume that any invalid divide
	of zero is a division by zero."

	^(self cause isBitSet: 4) or: [self isDivide and: [self operand1 value isZero]]!

operand1
	"Answer the receiver's operand1 field as a Smalltalk object."

	^_FPIEEE_VALUE fromAddress: bytes yourAddress + ##(self offsetOf: #operand1)!

operand2
	"Answer the receiver's operand2 field as a Smalltalk object."

	^_FPIEEE_VALUE fromAddress: bytes yourAddress + ##(self offsetOf: #operand2)!

operation
	"Answer an <integer> which identifies the type of operation being attemped when the exception
	occurred. See fpieee.h in the MS Win32 SDK for further information."

	^(self flags bitShift: -5) bitAnd: 16rFFF!

operationName
	"Answer the symbolic name of the operation being attemped when the exception
	occurred. See fpieee.h in the MS Win32 SDK for further information."

	^self class operationCodes at: self operation ifAbsent: [#Unspecified]!

precision
	"Answer an <integer> which identifies the precision configured at the time of the exception."

	^(self flags bitShift: -2) bitAnd: 2r111!

precisionName
	"Answer a the symbolic name of the precision setting at the time of the exception."

	^self class precisionModes at: self precision + 1 ifAbsent: [#Unknown]!

printFieldsOn: aStream limit: anInteger 
	self isNull 
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	aStream
		display: #roundingMode;
		nextPut: $=;
		print: self roundingModeName;
		space;
		display: #precision;
		nextPut: $=;
		print: self precisionName;
		space;
		display: #operation;
		nextPut: $=;
		print: self operationName;
		space.
	#(#cause #enable #status) do: 
			[:each | 
			aStream
				display: each;
				nextPut: $=.
			self printFlags: (self getField: each) on: aStream]
		separatedBy: [aStream space].
	#(#operand1 #operand2) do: 
			[:each | 
			| value |
			value := self getField: each.
			value isValid 
				ifTrue: 
					[aStream
						space;
						display: each;
						nextPut: $=;
						print: value]]!

printFlags: anInteger on: aStream 
	| first |
	anInteger == 0 
		ifTrue: 
			[aStream nextPut: 0.
			^self].
	first := true.
	self class exceptionFlags inject: 1
		into: 
			[:mask :each | 
			(anInteger anyMask: mask) 
				ifTrue: 
					[first ifTrue: [first := false] ifFalse: [aStream nextPut: $|].
					aStream display: each].
			mask << 1]!

roundingMode
	"Answer an <integer> which identifies the rounding mode configured at the time of the exception."

	^self flags bitAnd: 2r11!

roundingModeName
	"Answer the symbolic name of the rounding mode configured at the time of the exception."

	^self class roundingModes at: self roundingMode + 1 ifAbsent: [#Unknown]! !

_FPIEEE_VALUE comment:
'_FPIEEE_VALUE is an <ExternalStructure> class to represent the Win32 structure of the same name. _FPIEEE_VALUE is used in the reporting of IEEE compliant floating point exceptions. It is essentially a discriminated union that can hold the various types of operand that can be used in floating point operations.'!
!_FPIEEE_VALUE class methodsFor!

defineFields
	"Define the fields of the _FPIEEE_VALUE 'structure'.

		self compileDefinition
	"

	self
		defineField: #value type: (FillerField byteSize: 16);
		defineField: #flags type: DWORDField readOnly;
		defineField: #filler type: DWORDField filler!

formatCodes
	^#(#Fp32 #Fp64 #Fp80 #Fp128 #I16 #I32 #I64 #U16 #U32 #U64 #Bcd80 #Compare #String #Fp82)! !

!_FPIEEE_VALUE methodsFor!

flags
	"Answer the receiver's flags field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #flags)!

format
	"Answer an <integer> which identifies the type of value stored in the receiver."

	^(self flags bitAnd: 16r1E) bitShift: -1!

formatName
	"Answer the symbolic name of the operation being attemped when the exception
	occurred. See fpieee.h in the MS Win32 SDK for further information."

	^self class formatCodes at: self valueType + 1 ifAbsent: [#Unknown]!

isValid
	^(self flags allMask: 1)!

printFieldsOn: aStream limit: anInteger 
	self isNull 
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	self isValid 
		ifTrue: 
			[aStream
				display: #format;
				nextPut: $=;
				print: self formatName;
				space;
				display: #value;
				nextPut: $=;
				print: self value]
		ifFalse: [aStream nextPutAll: '<invalid>']!

value
	"Answer the <Number> value stored in the receiver, of nil if the receiver is not a valid value
	or is of an unsupported format."

	^self isValid ifTrue: [
	    bytes 
		perform: (#(
			floatAtOffset: 
			doubleAtOffset:
			longDoubleAtOffset:	"80-bit float"
			dwordAtOffset:		"128-bit float - not supported on Intel h/w"
			swordAtOffset:
			sdwordAtOffset:
			sqwordAtOffset:
			wordAtOffset:
			dwordAtOffset:
			qwordAtOffset:
			dwordAtOffset: "BCD"
			dwordAtOffset: "compare?"
			dwordAtOffset: "string?")
				at: (self format + 1))
		with: 0]! !

CPINFO comment:
'<CPINFO> is an <ExternalStructure> class to wrap the struct ''Win32.CPINFO'' from type information in the ''Win32 API (ANSI). Derived from Bruce McKinneys Hardcore Visual Basic Type Library'' library.

The type library contains no documentation for this struct

Warning: This comment was automatically generated from the struct''s type information, but any changes made here will not be overwritten if the wrapper class is regenerated.

IDL definition follows:

typedef [uuid(00C3C027-FA7E-43CB-B7CC-39D358049048)]
struct tagCPINFO {
	[helpstring("max length (bytes) of a char")] UINT MaxCharSize;
	BYTE DefaultChar[2];
	BYTE LeadByte[12];
} CPINFO;
'!
!CPINFO class methodsFor!

defineFields
	"Define the fields of the CPINFO structure.

	CPINFO  compileDefinition

		typedef [uuid(00C3C027-FA7E-43CB-B7CC-39D358049048)]
		struct tagCPINFO {
			[helpstring('max length (bytes) of a char')] UINT MaxCharSize;
			BYTE DefaultChar[2];
			BYTE LeadByte[12];
		} CPINFO;
"

	self
		defineField: #MaxCharSize type: DWORDField readOnly;
		defineField: #DefaultChar type: (ArrayField type: ByteArray length: 2) beReadOnly;
		defineField: #LeadByte type: (ArrayField type: ByteArray length: 12) beReadOnly! !

!CPINFO methodsFor!

DefaultChar
	"Answer the receiver's DefaultChar field as a Smalltalk object."

	^ByteArray fromAddress: bytes yourAddress + ##(self offsetOf: #DefaultChar) length: 2!

LeadByte
	"Answer the receiver's LeadByte field as a Smalltalk object."

	^ByteArray fromAddress: bytes yourAddress + ##(self offsetOf: #LeadByte) length: 12!

MaxCharSize
	"Answer the receiver's MaxCharSize field as a Smalltalk object."

	^bytes dwordAtOffset: 0! !

DOUBLE comment:
'DOUBLE is an <ExternalStructure> class to represent double precision (64-bit) floating point numbers in native format'!
!DOUBLE class methodsFor!

defineFields
	"Define the fields of the DOUBLE 'structure'.

		DOUBLE compileDefinition
	"

	self defineField: #value type: DOUBLEField new!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DOUBLEField!

icon
	"Answer a suitable iconic representation for the receiver."

	^Float icon!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!DOUBLE methodsFor!

asFloat
	"Answer a <Float> of the same value as the receiver's contents."

	^(bytes doubleAtOffset: 0)!

displayOn: target
	"Append a textual representation of the receiver onto the <puttableStream> argument,
	target, in the format that an end-user might want to see it."

	target display: (self isNull ifFalse: [self value])!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes doubleAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes doubleAtOffset: 0 put: anObject! !

ExternalArray comment:
'ExternalArray is a specialized class of <ExternalStructure> to represent contiguous heterogeneous arrays of external types, be they scalar of structured. The various subclasses can be used for external interfacing tasks such as where C arrays are expected.

StructureArray is the most general of the subclasses in that it supports arbitrary element types (represented by other ExternalStructures), and can in fact perform the task of the other subclasses such as DWORDArray. The more specialized subclasses do, however, offer much greater efficiency where they are applicable.

Specialized subclasses are provided for most standard intrinsic types; signed and unsigned integers of 16 and 32-bits, single and double precision floating point numbers, etc. Note that there is no subclass for arrays of bytes, since the standard ByteArray class already fulfills that requirement.

Instance Variables:
	length		<integer>. Number of elements in the instance.

'!
!ExternalArray class methodsFor!

alignment
	"Answer the alignment required for instances of the receiver when embedded in arrays or
	other structures. This is the alignment of the elements of the array in most cases."

	^self elementSize!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^BYTE!

elementSize
	"Private - Answer the size of the receiver's instances' constituent 
	elements in bytes."

	^self elementClass elementSize!

fromAddress: anAddress
	"The receiver needs to know how long the array is to avoid
	reading or writing off its end."

	^self shouldNotImplement !

fromAddress: anAddress length: anInteger
	"Answer a new instance of the receiver that points at an
	array of anInteger elements of type elementClass at anAddress.
	Implementation Note: If the length is zero, then we ignore the address (even if invalid).
	If the length is non-zero then we answer nil if the address is the Null pointer."

	^anInteger == 0 
		ifTrue: [self basicNew basicLength: 0]
		ifFalse: [
			anAddress isNull ifFalse: [
				self basicNew
					initializeAtAddress: anAddress;
					basicLength: anInteger]]!

icon
	"Answers an Icon that can be used to represent this class"

	^Array icon!

length: count elementSize: bytes
	"Private - Answer a new instance of the receiver allocated 
	with space for count elements of bytes size."

	^(super new: count*bytes)
		basicLength: count!

new: anInteger
	"Answer a new instance of the receiver allocated at an immovable location."

	^self length: anInteger elementSize: self elementSize!

with: element1
	"Answer a new instance of the receiver containing the single 
	<Object> element, element1."

	^(self new: 1)
		at: 1 put: element1;
		yourself!

withAll: newElements
	"Answer a new instance of the receiver containing all of the 
	elements of the <collection> newElements.
	An error will be raised if any of the elements of newElements
	cannot be stored in instances of the receiver."

	| answer |
	answer := self new: newElements size.
	newElements inject: 1 into: [:i :elem | answer at: i put: elem. i + 1].
	^answer! !

!ExternalArray methodsFor!

appendToStream: puttableStream
	"Private - Append the receiver's elements to the argument, puttableStream.
	We can be able to do a fast block copy. Answer the receiver.
	Implementation note: Double dispatched from puttableStream>>nextPutAll:."

	puttableStream next: self byteSize putAll: bytes startingAt: 1!

asArray
	"Answer an <Array> containing the constituent elements of the receiver."

	^self collect: [:each | each]!

asByteArray
	"Answer a ByteArray containing the constituent elements of the receiver."

	^self copy: ByteArray from: 1 to: self byteSize!

asOrderedCollection
	"Answer an <OrderedCollection> whose elements are those of the receiver
	The ordering is that of the #do: operation as implemented by the receiver,
	and the answer will normally be the same size as the receiver.
	Implementation Note: Although we might be able to perform this operation 
	faster for collections which keep a tally of their size (or can otherwise 
	access it without calculation) we must be careful NOT to provide a default 
	implementation which will cause a double enumeration for collections which must
	count their elements to determine their size, which may be very slow."

	| answer |
	answer := OrderedCollection new: self size.
	self do: [:elem | answer addLast: elem].
	^answer!

at: anInteger 
	"Answer the element of the receiver at the specified index.
	Raise an error if the index if out of bounds."

	(anInteger < 1 or: [anInteger > self size]) 
		ifTrue: [^self errorSubscriptBounds: anInteger].
	^self uncheckedAt: anInteger!

at: index ifAbsent: exceptionBlock 
	"Answer an <Object> which is the element of the receiver 
	at the specified index. If the index is out of bounds answer
	the result of evaluating the <niladicValuable> exceptionBlock."

	^(index > 0 and: [index <= self size]) 
		ifTrue: [self uncheckedAt: index]
		ifFalse: [exceptionBlock value]!

at: anInteger put: newValue 
	"Set the element of the receiver at the specified index.
	Raise an error if the index is out of bounds."

	(anInteger < 1 or: [anInteger > self size]) 
		ifTrue: [self errorSubscriptBounds: anInteger].
	^self uncheckedAt: anInteger put: newValue!

basicLength: anInteger
	"Private - Set the length (in elements, not bytes) of the receiver."
	
	length := anInteger!

binarySearchFor: anObject using: searchBlock 
	"Private - Answer the index at which anObject is located using a binary chop search based on searchBlock"

	^SequenceableCollection 
		binarySearch: self
		for: anObject
		using: searchBlock!

byteSize
	"Answer the total size in bytes of this array."

	^self elementSize * self length!

collect: transformer 
	"Evaluate the <monadicValuable> argument, transformer, for each of the receiver's elements
	in the order defined by the receiver's implementation of #do:. Answer a new collection like
	the receiver containing the values returned by transformer on each evaluation."

	"Implementation Note: We use the special instance creation method #copyLikeOfSize: because
	the transformation block may evaluate to objects which cannot be stored as elements of this
	type of array and therefore we must store them in an <Array>."

	| answer size |
	size := self size.
	answer := self copyLikeOfSize: size.
	self 
		uncheckedFrom: 1
		to: size
		keysAndValuesDo: [:i :each | answer at: i put: (transformer value: each)].
	^answer!

copyLikeOfSize: anInteger
	"Private - Answer a new collection of the same species as the receiver but with
	anInteger nil elements - i.e. not just with sufficient capacity for, but actually holding, 
	anInteger	elements. Subclasses should override to preserve additional instance variables.
	Note: This message differs from #copyEmpty: since an instance of the receivers species
	(rather than exact class, although this is usually the same) is returned which does not
	just have sufficient capacity for anInteger elements, but actually has that many elements."

	^self species ofSize: anInteger!

detect: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements
	in the order defined by the receiver's implementation of #do:.
	Answer the first element for which discriminator evaluates to true. If none evaluates to true,
	report an error."

	^self detect: discriminator ifNone: [self errorNotFound: discriminator]!

detect: discriminator ifNone: exceptionHandler
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's 
	elements.  Answer the first element (in the #do: order) for which discriminator evaluates 
	to true. If none evaluates to true answer the result of evaluating the <niladicValuable> 
	argument, exceptionHandler.
	Implementation Note: It is important for Shared subclasses that the exceptionHandler is 
	not evaluated inside the enumeration in case it is a niladic block containing an explicit 
	return (we try to avoid explicit returns from critical sections, as these require an unwind)."

	self do: [:each | (discriminator value: each) ifTrue: [^each]].
	^exceptionHandler value!

displayOn: target
	"Append a textual representation of the receiver onto the <puttableStream> argument,
	target, in the format that an end-user might want to see it."

	target
		nextPut: $(.
	self isNull ifFalse: [
		self 
			do: [:element | target display: element]
			separatedBy: [target nextPut: $,; space]].
	target  nextPut: $).!

do: operation
	"Evaluate monadic value argument, operation, for each of the elements of the 
	receiver. Answers the receiver. The elements are evaluated in index order.
	Implementation Note: Implemented in terms of keysAndValuesDo: to reduce
	the burden of subclassing. Where performance is an issue subclasses may 
	want to override this."

	self keysAndValuesDo: [:i :elem | operation value: elem]!

do: operation separatedBy: separator
	"Evaluate the <monadicValuable> argument, operation, for each of the 
	receiver's elements, interspersed with evaluations of the <niladicValuable>
	argument, separator. The separator is first evaluated after the first
	element, and is not evaluated after the last element (i.e. it is not evaluated
	at all if there are less than two elements)."

	| sep |
	sep := [sep := separator].	"Switch to the real separator after first eval."
	self do: [:e |
		sep value.
		operation value: e]!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^self class elementClass!

elementSize
	"Private - Answer the size of the receiver's instances' constituent 
	elements in bytes."

	^self elementClass elementSize!

first
	^self at: 1!

from: start do: operation
	"Evaluate the <monadicValuable>, operation, for each element of the receiver
	from start, inclusive."

	self 
		from: start
		keysAndValuesDo: [:i :each | operation value: each]!

from: start keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	from the element with <integer> index, start, inclusive. A BoundsError will be
	raised if either start or stop is out of bounds."

	self 
		from: start
		to: self size
		keysAndValuesDo: operation!

from: startInteger to: stopInteger keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments."

	"Implementation Note: Do the bounds check up front to avoid the need to check
	on each access."

	startInteger < 1 ifTrue: [self errorSubscriptBounds: startInteger].
	stopInteger > self size ifTrue: [self errorSubscriptBounds: stopInteger].
	self 
		uncheckedFrom: startInteger
		to: stopInteger
		keysAndValuesDo: operation!

includes: target
	"Answer whether the argument, target, is one of the elements of the receiver.
	Implementation Note: Override superclass to revert to element search."

	1 to: self size do: [:i | target = (self at: i) ifTrue: [^true]].
	^false!

includesKey: anInteger
	^anInteger between: 1 and: self size!

inject: initialValue into: operation
	"Evaluate the <dyadicValuable> argument, operation, once for each element in the receiver, with
	that element as the second argument; and with the first argument as the value of the previous 
	evaluation, starting with the <Object> argument, initialValue. The operation must answer the value
	it wishes to have passed as its first argument the next time it is evaluated. The traversal is in the #do: 
	order. Answer the final value of the operation.
	This enumeration is particularly useful for performing summations and other statistical operations."

	| nextValue |
	nextValue := initialValue.
	self do: [:each | nextValue := operation value: nextValue value: each].
	^nextValue!

isEmpty
	"Answer whether the receiver contains no elements."

	^self size == 0
!

keys
	"Answer a <collection> containing the receiver's keys."

	^1 to: self size!

keysAndValuesDo: operation 
	"Evaluate the <dyadicValuable>, operation, for each element of the receiver
	with the index of that element and the element itself as the arguments.
	Implementation Note: Subclasses should override #from:to:keysAndValuesDo: rather 
	than this method, unless they have a slow implementation of #size."

	self 
		uncheckedFrom: 1
		to: self size
		keysAndValuesDo: operation!

last
	^self at: self size!

length
	"Answer the number of elements in the receiver."

	^length!

length: anInteger
	"Set the length (in elements, not bytes) of the receiver, resizing the
	bytes of the receiver to accomodate the new length.
	This is not private as it can be used to adjust the length of 
	pointer instances after creation."
	
	self basicLength: anInteger.
	self bytes resize: self byteSize!

notEmpty
	"Answer whether the receiver contains any elements."

	^self isEmpty not!

printOn: aStream
	"Print a string representation of self on aStream."

	| tooMany |
	tooMany := aStream position + #() maxPrint.
	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: 
			[self do: 
					[:each | 
					aStream position > tooMany 
						ifTrue: 
							[aStream nextPutAll: '... etc ...'.
							^self].
					each printOn: aStream]
				separatedBy: [aStream space]].
	aStream nextPut: $)!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:"

	^bytes replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart-1*self elementSize+1!

replaceFrom: start to: stop  with: aByteObject startingAt: fromStart
	"Standard method for transfering bytes from one variable
	byte object to another. See String>>replaceFrom:to:with:startingAt:"

	| elemSize offset |
	elemSize := self elementSize.
	offset := start-1 * elemSize.
	aByteObject 
		replaceBytesOf: self bytes 
		from: 1+offset
		to: stop * elemSize
		startingAt: fromStart!

select: discriminator
	"Evaluate the <monadicValuable> argument, discriminator, for each of the receiver's elements.
	Answer a new <collection> like the receiver containing only those elements for which 
	the discriminator evaluates to true."

	| aStream |
	aStream := self species writeStream.
	self keysAndValuesDo: [:i :elem | 
		(discriminator value: elem) ifTrue: [aStream nextPut: elem]].
	^aStream contents!

size
	"Answer the number of elements in the receiver."
	
	^self length!

species
	"Answer the class of object to be used when copying the receiver."

	^Array!

uncheckedAt: anInteger 
	"Private - Answer an 16-bit unsigned <SmallInteger> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes byteAtOffset: anInteger - 1!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 16-bit unsigned integer value at the specified index in the receiver
	with the <integer> argument. No bounds checks are performed on the subscript."

	^bytes byteAtOffset: indexInteger - 1 put: valueInteger!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: operation 
	"Private - Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the <integer> indices, start and stop, inclusive with the element and its
	index as respectively the second and first arguments. No bounds checking is
	performed. "

	"Subclasses should override this method in order to replace all #do: family enumerators 
	(#do:, #keysAndValuesDo:, #from:to:do:, and,	of course, #from:to:keysAndValuesDo:)."

	startInteger to: stopInteger do: [:i | operation value: i value: (self uncheckedAt: i)]! !

ExternalInteger comment:
'ExternalInteger is an abstract class of ExternalStructures to represent machine native integer formats. Various subclasses are defined to represent the signed and unsigned forms with varying numbers of bits:

8-bit
	signed	SBYTE
	unsigned	BYTE
16-bit
	signed	SWORD
	unsigned	WORD
32-bit
	signed	SDWORD
	unsigned	DWORD
64-bit
	signed	LARGE_INTEGER
	unsigned	ULARGE_INTEGER
'!
!ExternalInteger class methodsFor!

decompileDefinition
	"Don't allow the receiver and its subclasses to be decompiled since they are
	required by fundamental aspects of the system such as streaming"
	!

defineFields
	"Define the fields of the ExternalInteger 'structure'. ExternalInteger subclasses
	have a single value."

	self defineField: #value type: self fieldType new beOverride!

definesNewFields
	^self ~= ##(self) and: [self class includesSelector: #fieldType]!

defineTemplate
	"Initialize the receiver class' structure template."

	super defineTemplate.
	alignment := self elementSize!

fromInteger: anInteger
	"Answer a new instance of the receiver with contents copied from anInteger"

	^self new value: anInteger!

icon
	"Answer a suitable iconic representation for the receiver."

	^Integer icon! !

!ExternalInteger methodsFor!

= anObject
	"Answer whether the receiver is equivalent to anObject."

	^anObject = self value!

asInteger
	"Answer the Integer value of the receiver, signed or
	unsigned depending on the subclass"

	^self value!

asSignedInteger
	"Answer the signed 32-bit Integer value of the receiver.
	This can be useful where functions return values declared as unsigned, but with signed
	values in them (a typical C programmers' trick for notifying error conditions).
	Implementation Note: This should really be a subclass responsibility,
	but this saves some space."

	^self value!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^self value!

asUnsignedInteger
	"Answer the unsigned Integer value of the receiver.
	This can be useful where unsigned values are stored in signed values.
	Implementation Note: This should really be a subclass responsibility,
	but this saves some space."

	^self value!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	self value displayOn: aStream!

hash
	"Answer the SmallInteger hash value for the receiver."

	^self value hash!

isNull
	"Answer whether the receiver is Null (i.e. equal to 0). 
	This message is useful way of testing for NULL pointers or handles."

	^super isNull or: [self value == 0]!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	| hex |
	hex := self isNull
			ifTrue: ['0']
			ifFalse: [self value printStringRadix: 16].
	aStream
		basicPrint: self;
		nextPut: $(; display: hex; nextPut: $)!

value
	"Answer the receiver's value as a Smalltalk <Integer>.
	Note: All subclasses defining this as a structure member named #value
	must mark that field as an override (send it #beOverride) as otherwise
	the necessary accessor will not be generated."

	^self subclassResponsibility!

value: anObject
	"Set the receiver's value field to the value of anObject."

	^self subclassResponsibility! !

FLOAT comment:
'FLOAT is an <ExternalStructure> class to represent single precision (32-bit) floating point numbers in native format.

Single precision floats can be used to represent numbers with magnitudes between 1.17549e-038 and 3.40282e+038, but only with about 6 digits of precision.'!
!FLOAT class methodsFor!

defineFields
	"Define the fields of the FLOAT 'structure'.

		FLOAT  compileDefinition
	"

	self defineField: #value type: FLOATField new!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^FLOATField!

fileOutStem
	"Private - Answer standard file name stem for the class to file out on."

	^'FLOAT2'
!

icon
	"Answer a suitable iconic representation for the receiver."

	^Float icon!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

maximum
	^self fromBytes: #[255 255 127 127]!

minimum
	^self fromBytes: #[0 0 128 0]
!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!FLOAT methodsFor!

asFloat
	"Answer a <Float> of the same value as the receiver's contents."

	^(bytes floatAtOffset: 0)!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes floatAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes floatAtOffset: 0 put: anObject! !

LPVOID comment:
'LPVOID is an <ExternalStructure> class useful for representing pointers to arbitrary external memory blocks. In most respects LPVOID behaves like <ExternalAddress>, except that instances may be allocated using #newBuffer which can be passed to #lpvoid arguments without the VM implicitly dereferencing the address (i.e. the behaviour will be the same as if an ExternalAddress had been passed to an lppvoid parameter). LPVOID is also a pointer object, and can thus add instance variables to hold additional state.

LPVOID is useful, for example, where references to pointers (i.e. VOID**) are required, an example being COM [out] pointer parameters. The VM also passes instances of LPVOID as lpvoid input parameters to callbacks and COM method implementations.

It is important to realise that LPVOID (and subclasses) are unlike other ExternalStructures in that they are already pointers, and therefore they already incorporate one level of indirection. Thus:
1) #value answers the pointed at address in the case of doubly-indirect (reference) instances, or the address itself for internal buffer instances.
2) The class method #fromAddress: will answer a pointer to a pointer, i.e. a double-indirection. This means that, for example, the subclass LPWSTR is useful as an element class for a <StructureArray> of LPWSTR pointers (as expected), but that ''LPWSTR fromAdddress: aUnicodeString yourAddress'' is not valid.'!
!LPVOID class methodsFor!

defineFields
	"Define the fields of the LPVOID 'structure'.
		LPVOID compileDefinition
	"

	self defineField: #value type: LPVOIDField new!

new
	"Answer a new instance of the receiver.
	Implementation Note: LPVOID and its subclasses represent pointers, and are typically
	used for double indirections, thus a reference is normally required."

	^self newPointer! !

!LPVOID methodsFor!

asExternalAddress
	"Answer the address contained in or referenced by the receiver."

	^self value!

value
	"Answer the receiver's value field as a Smalltalk object."

	^(bytes uintPtrAtOffset: 0) asExternalAddress!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes uintPtrAtOffset: 0 put: anObject! !

StructurePointer comment:
''!
!StructurePointer class methodsFor!

byteSize
	^VMConstants.IntPtrSize!

elementClass: elementClass
	"Answer a new instance of the receiver that will contain a pointer to
	an <ExternalStructure> or the specified type."

	^self new
		elementClass: elementClass;
		yourself!

fromAddress: anAddress elementClass: elementClass
	"Answer a new instance of the receiver that contains a pointer to
	an <ExternalStructure> of the specified type."

	^anAddress isNull ifFalse: [
		self basicNew
			initializeAtAddress: anAddress;
			elementClass: elementClass;
			yourself]!

newNull: pointerClass elementClass: elementClass
	"Answer a new instance of the receiver that contains an
	initially null memory pointer of the specified class pointer to 
	an <ExternalStructure> of the specified type."

	^self basicNew
		initializeAtAddress: pointerClass new;
		elementClass: elementClass;
		yourself! !

!StructurePointer methodsFor!

elementClass
	"Private - Answer the value of the receiver's ''elementClass'' instance variable."

	^elementClass!

elementClass: anObject
	"Private - Set the value of the receiver's ''elementClass'' instance variable to the argument, anObject."

	elementClass := anObject!

printOn: aStream
	"Print a string representation of self on aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: [aStream print: self value].
	aStream nextPut: $).!

value
	"Answer the receiver's value field as a Smalltalk object."

	^self elementClass fromAddress: bytes! !

VOID comment:
'VOID is an <ExternalStructure> class to represent unspecified, null, or opaque types. 

VOID is only useful in pointer form, and mainly intended to provided a unified type scheme for auto-generation of structures from type libraries.'!
!VOID class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures. VOID is of course only valid when indirected."

	^self shouldNotImplement!

new
	"Answer a new instance of the receiver.
	Implementation Note: VOID and its are intended to represent pointers
	thus a reference is always required."

	^self newPointer! !

Win32Structure comment:
'Win32Structure is the abstract superclass of all classes that describe <ExternalStructure>s that are a part of the Win32 API. For the most part, these structures hold a <DWORD> byte size as the first field which Windows can use as version information to determine how the structure is to be interpreted. Where available,  this is set using #dwSize:.
'!
!Win32Structure methodsFor!

dwSize: anInteger
	"Store the size of the structure into itself (a common feature of Win32 structures,
	but unfortunately not all, so the default is to do nothing)"!

initialize: anInteger
	"Private - Initialize the state of the receiver."

	super initialize: anInteger.
	self dwSize: anInteger! !

DOUBLEArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of double-precision (64-bit) floating point numbers.'!
!DOUBLEArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^DOUBLE! !

!DOUBLEArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer a <Float> representing the 64-bit double-precision 
	IEEE float at the specified <integer> index in the receiver. No bounds 
	checks are performed on the subscript."

	^bytes doubleAtOffset: (anInteger - 1) * VMConstants.DoubleSize!

uncheckedAt: anInteger put: aFloat 
	"Private - Replace the double-precision floating point value at the specified index in the receiver
	with the <Float> argument."

	^bytes doubleAtOffset: (anInteger - 1) * VMConstants.DoubleSize put: aFloat! !

DWORDArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of 32-bit unsigned integers.'!
!DWORDArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^DWORD! !

!DWORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 32-bit unsigned <integer> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes dwordAtOffset: (anInteger - 1) * 4!

uncheckedAt: indexInteger put: valueInteger 
	^bytes dwordAtOffset: (indexInteger - 1) * 4 put: valueInteger! !

FLOATArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of single-precision (32-bit) floating point numbers.'!
!FLOATArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^FLOAT! !

!FLOATArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer a <Float> representing the 32-bit single-precision 
	IEEE float at the specified <integer> index in the receiver. No bounds 
	checks are performed on the subscript."

	^bytes floatAtOffset: (anInteger - 1) * VMConstants.FloatSize!

uncheckedAt: anInteger put: aFloat 
	"Private - Replace the single-precision floating point value at the specified index in the receiver
	with the Float argument.."

	^bytes floatAtOffset: (anInteger - 1) * VMConstants.FloatSize put: aFloat! !

GenericExternalArray comment:
'GenericExternalArray is an abstract class of <ExternalArray>s that can be used to represent single-dimensioned arrays of more than one type.

Instance Variables:
	elementClass	<Class> of element, typically an <ExternalStructure>.
	owner		<Object>. Object responsible for freeing the underlying array. Typically nil, in which case the receiver is responsible.
'!
!GenericExternalArray class methodsFor!

length: length elementClass: elementClass 
	"Answer a new vector (single dimensioned) array that 
	contains <integer>, length, elements of type, elementClass."

	^self subclassResponsibility!

withAll: aCollection elementClass: structClass 
	"Answer a new instance of the receiver containing all of the elements of the <collection> 
	argument, represented in the format of the <ExternalStructure> class argument.  An error 
	will be raised if any of the elements cannot be represented as instances of the element class."

	| answer |
	answer := self length: aCollection size elementClass: structClass.
	aCollection inject: 1
		into: 
			[:i :elem | 
			answer at: i put: elem.
			i + 1].
	^answer! !

!GenericExternalArray methodsFor!

asArray
	"Answer an <Array> containing the constituent elements of the receiver."

	^self collect: [:each | each asObject]!

base
	^self yourAddress!

elementClass
	"Answer the class of <ExternalStructure> used to represent the receiver's elements."

	^elementClass!

elementClass: aClass 
	"Private - Set the class of Smalltalk object used to represent the elements	of the receiver."

	elementClass := aClass!

needsFree
	"Private - Answer whether the receiver requires freeing of any external resources.
	In most cases we don't want to free if this object is a reference to an array of
	structures held elsewhere, since that that would be rather rude."

	^self notNull and: [owner isNil]!

newElementAt: anAddress 
	"Answer a new reference instance of the receiver's element class, pointing at the element
	at the specified memory address."

	^self elementClass atAddress: anAddress!

owner: arrayOwner
	"Set the object responsible for managing the storage allocated for the underlying elements.
	This is used both to keep that object alive while the receiver is alive, and to determine
	who should free the elements. If nil then the receiver frees the elements by passing them
	back to their class' #free: method, otherwise it is assumed that the owner will free them
	when it no longer requires them."

	(arrayOwner isNil or: [arrayOwner == self])
		ifTrue: [owner := nil. self beFinalizable]
		ifFalse: [owner := arrayOwner. self beUnfinalizable]!

packing
	"Private - Answer the number of bytes between individual elements of the receiver.
	This is the receiver's elementSize plus any padding necessary."

	^self elementSize!

uncheckedAt: anInteger 
	"Private - Answer an instance of the receiver's elementClass which is a reference to the
	element of the receiver at the specified <integer> index. No bounds checks are performed on
	the subscript."

	^self newElementAt: self base + ((anInteger - 1) * self packing)!

uncheckedFrom: startInteger to: stopInteger keysAndValuesDo: operation 
	"Private - Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the specified, inclusive, <integer> indices with the element and its index as
	respectively the second and first arguments. No bounds checking is performed. "

	"Implementation Note: Override for improved performance (reduction of address calculations).
	By overriding this one method, we improve the performance of all enumerators."

	| address spacing |
	spacing := self packing.
	address := self base + ((startInteger - 1) * spacing).
	startInteger to: stopInteger
		do: 
			[:i | 
			operation value: i value: (self newElementAt: address).
			address := address + spacing]! !

INT_PTRArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of machine word sized signed integers.'!
!INT_PTRArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^INT_PTR! !

!INT_PTRArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 32-bit unsigned <integer> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes intPtrAtOffset: (anInteger - 1) * VMConstants.IntPtrSize!

uncheckedAt: indexInteger put: valueInteger 
	^bytes intPtrAtOffset: (indexInteger - 1) * VMConstants.IntPtrSize put: valueInteger! !

SDWORDArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of 32-bit signed integers.'!
!SDWORDArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^SDWORD! !

!SDWORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 32-bit signed <integer> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes sdwordAtOffset: (anInteger - 1) * 4!

uncheckedAt: indexInteger put: valueInteger 
	^bytes sdwordAtOffset: (indexInteger - 1) * 4 put: valueInteger! !

SWORDArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of 16-bit signed integers.'!
!SWORDArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^SWORD! !

!SWORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 16-bit signed <SmallInteger> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes swordAtOffset: anInteger + anInteger - 2!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 16-bit signed integer value at the specified index in the receiver
	with the <integer> argument. No bounds checks are performed on the subscript."

	^bytes swordAtOffset: indexInteger + indexInteger - 2 put: valueInteger! !

UINT_PTRArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of machine word sized unsigned integers.'!
!UINT_PTRArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^UINT_PTR! !

!UINT_PTRArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 32-bit unsigned <integer> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes uintPtrAtOffset: (anInteger - 1) * VMConstants.IntPtrSize!

uncheckedAt: indexInteger put: valueInteger 
	^bytes uintPtrAtOffset: (indexInteger - 1) * VMConstants.IntPtrSize put: valueInteger! !

WORDArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of 16-bit unsigned integers.'!
!WORDArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^WORD! !

!WORDArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer an 16-bit unsigned <SmallInteger> representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^bytes wordAtOffset: anInteger + anInteger - 2!

uncheckedAt: indexInteger put: valueInteger 
	"Private - Replace the 16-bit unsigned integer value at the specified index in the receiver
	with the <integer> argument. No bounds checks are performed on the subscript."

	^bytes wordAtOffset: indexInteger + indexInteger - 2 put: valueInteger! !

StructureArray comment:
'Generic <ExternalArray> class which can represent single-dimensioned arrays of any class of <ExternalStructure>. Packing and alignment rules are respected.

Note that although StructureArray is capable of fulfilling the tasks of other more specialized <ExternalArray> classes such as <DWORDArray> and <FLOATArray>, it is far less efficient and marginally more inconvenient as indexed access always yields an <ExternalStructure> rather than a fundamental Smalltalk object.

Instance Variables:
	elementSpacing	<integer>. Distance (in bytes) between adjacent elements, there may be padding.

'!
!StructureArray class methodsFor!

fromAddress: anAddress length: anInteger elementClass: elementClass
	"Answer a new instance of the receiver that points at an
	array of anInteger elements of type elementClass at anAddress.
	Implementation Note: If the length is zero, then we ignore the address (even if invalid).
	If the length is non-zero then we answer nil if the address is the Null pointer."

	^anInteger == 0 
		ifTrue: [self basicNew basicLength: 0; elementClass: elementClass]
		ifFalse: [
			anAddress isNull ifFalse: [
				self basicNew
					initializeAtAddress: anAddress;
					elementClass: elementClass;
					basicLength: anInteger]]!

length: anInteger elementClass: elementClass
	"Answer a new instance of the receiver that contains a buffer
	of sufficient size to contain anInteger elements of type, elementClass."

	^(self length: anInteger elementSize: elementClass elementSize)
		elementClass: elementClass!

stbConvertFrom: anSTBClassFormat
	"Convert from earlier version models.
		1: Added 'owner' instance variable, default to nil."

	^[:data | | newInstance |
		newInstance := self basicNew.
		1 to: data size do: [:i | newInstance instVarAt: i put: (data at: i)].
		"Ensure the elementSpacing is set correctly in case importing data from 2.1"
		newInstance elementClass: newInstance elementClass.
		newInstance]!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^1! !

!StructureArray methodsFor!

alignment
	"Answer the alignment required for instances of the receiver when 
	embedded in arrays or other structures. For an array this is the 
	alignment requirement of the elements."

	^elementClass alignment!

basicFree
	"Private - Free external resources owned by the receiver.
	We must ask the elementClass to free each of the structures
	embedded in the receiver (should only be invoked for value instances
	not reference (pointer) instances."

	| elemClass addr spacing |
	elemClass := self elementClass.
	addr := self yourAddress.
	spacing := self packing.
	self size timesRepeat: 
			[elemClass clear: addr asExternalAddress.
			addr := addr + spacing]!

copyFrom: start to: stop 
	"Private - Answer an object of the same species as the receiver
	containing a copy of the elements of the receiver starting at index start, 
	until index stop, inclusive."

	| len |
	len := stop - start + 1.
	^(self species length: len elementClass: elementClass) 
		replaceFrom: 1
		to: len
		with: self
		startingAt: start!

elementClass: elemClass 
	"Private - Set the class to be used for accessing elements of the receiver.
	Answer the receiver."

	super elementClass: elemClass.
	elementSpacing := self elementSize roundUpTo: self alignment!

initialize
	"Private - Perform any initialization required for the receiver
	which is specific to the value form. Answer the receiver.
	To perform reference specific initialization, override #initializePointer."

	self owner: nil!

initializePointer
	"Private - Perform any initialization required for the receiver
	which is specific to the reference form. Answer the receiver.
	Implementation Note: Set up the address object as the owner (even
	if it isn't) to suppress the receiver's desire to free its elements
	on finalization."

	self owner: bytes!

packing
	"Private - Answer the number of bytes between individual elements of the receiver.
	This is the receiver's elementSize plus any padding necessary."

	^elementSpacing!

rawDo: operation 
	"Private - Evaluate the <dyadicValuable>, operation, for each element of the receiver
	between the specified, inclusive, <integer> indices with the element and its index as
	respectively the second and first arguments. No bounds checking is performed. "

	"Implementation Note: Override for improved performance (reduction of address calculations).
	By overriding this one method, we improve the performance of all enumerators."

	| address spacing elem |
	spacing := self packing.
	address := self base.
	elem := elementClass newPointer.
	self length timesRepeat: 
			[elem initializeAtAddress: address.
			operation value: elem.
			address := address + spacing]!

uncheckedAt: anInteger put: anObject 
	"Private - Replace the element of the receiver at the specified <integer> index
	with the <Object> argument. No bounds checks are performed on the subscript."

	| offset |
	offset := (anInteger - 1) * self packing.
	anObject 
		replaceBytesOf: bytes
		from: 1 + offset
		to: offset + self elementSize
		startingAt: 1.
	^anObject!

with: otherCollection do: operation
	"Private - Evaluate the <dyadicValuable> argument, operation, with each of 
	the receiver's elements along with the corresponding element from the 
	<sequencedReadableCollection> argument, otherCollection.
	N.B. This is private because the element passed to the operation must
	not be captured since it is shared. StructureArrays are often initialized
	from Smalltalk arrays, and the elements passed are only transient references
	anyway."

	| elem addr spacing |
	addr := self yourAddress.
	spacing := self packing.
	elem := elementClass newPointer.
	1 to: self size do: [:i |
		elem initializeAtAddress: addr.
		operation
			value: elem
			value: (otherCollection at: i).
		addr := addr + spacing]! !

HandleArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of handles. Note that these could be 32 or 64-bit, depending on the host OS.'!
!HandleArray class methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent elements of the receiver."

	^ExternalHandle! !

!HandleArray methodsFor!

uncheckedAt: anInteger 
	"Private - Answer a machine-word sized handle representing the element of the 
	receiver at the specified <integer> index. No bounds checks are performed on the subscript."

	^(super uncheckedAt: anInteger) asExternalHandle!

uncheckedAt: indexInteger put: anExternalHandle 
	super uncheckedAt: indexInteger put: anExternalHandle asInteger.
	^anExternalHandle! !

PointerArray comment:
'Specialized <ExternalArray> to represent contiguous single-dimensioned arrays of pointers to arbitrary <ExternalStructure>s.

Instance Variables:
	elementClass	<ExternalStructure>. Class to represent elements of the array.

'!
!PointerArray class methodsFor!

fromAddress: anAddress length: anInteger elementClass: elementClass
	"Answer a new instance of the receiver that points at an
	array of anInteger elements of type elementClass at anAddress.
	Implementation Note: If the length is zero, then we ignore the address (even if invalid).
	If the length is non-zero then we answer nil if the address is the Null pointer."

	^anInteger == 0 
		ifTrue: [self basicNew basicLength: 0; elementClass: elementClass]
		ifFalse: [
			anAddress isNull ifFalse: [
				self basicNew
					initializeAtAddress: anAddress;
					elementClass: elementClass;
					basicLength: anInteger]]!

length: anInteger elementClass: elementClass 
	"Answer a new instance of the receiver that contains a buffer
	of sufficient size to contain anInteger elements of type, elementClass."

	^(self length: anInteger elementSize: self elementSize) elementClass: elementClass! !

!PointerArray methodsFor!

elementClass
	"Answer the class of <ExternalStructure> used to represent the receiver's elements."

	^elementClass!

elementClass: elemClass
	"Private - Set the class to be used for accessing elements of the receiver.
	Answer the receiver."

	elementClass := elemClass!

uncheckedAt: anInteger 
	"Private - Answer an instance of the receiver's elementClass (a type of pointer) wrapping the 
	address at the specified <integer> index in the receiver. No bounds checks are performed on 
	the subscript."

	^elementClass fromAddress: (super uncheckedAt: anInteger)!

uncheckedAt: anInteger put: newValue 
	super uncheckedAt: anInteger put: newValue yourAddress.
	^newValue! !

BYTE comment:
'<BYTE> is an <ExternalStructure> class to wrap the Win32 type of the same name.

BYTE is used to represent unsigned 8-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	0 to: (2**8)-1	(i.e. 0 to: 255).'!
!BYTE class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in other
	structures."

	^BYTEField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!BYTE methodsFor!

asSignedInteger
	"Answer the signed 8-bit Integer value of the receiver."

	^bytes sbyteAtOffset: 0!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes byteAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes byteAtOffset: 0 put: anObject! !

DWORD comment:
'<DWORD> is an <ExternalStructure> class to wrap the Win32 type of the same name.

DWORD is used to represent unsigned 32-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	0 to: (2**32)-1'!
!DWORD class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DWORDField!

fromPoint: aPoint
	"Private - Answer a new instance of the receiver with high and low
	words set from aPoint assuming its co-ordinates to be 16-bit signed
	integer values, with X in the low-word. This instantiator is somewhat
	similar to the Windows MAKEPOINT macro."

	^(self new)
		lowSWord: aPoint x;
		highSWord: aPoint y;
		yourself!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!DWORD methodsFor!

asSignedInteger
	"Answer the signed 32-bit Integer value of the receiver."

	^bytes sdwordAtOffset: 0!

highSWord
	"Answer the high-order signed word of the receiver. Assumes little-endian
	ordering."

	^bytes swordAtOffset: 2!

highSWord: anInteger
	"Set the high-order signed word of the receiver. Assumes little-endian
	ordering. Answer the receiver."

	bytes swordAtOffset: 2 put: anInteger!

highWord
	"Answer the high-order word of the receiver. Assumes little-endian
	ordering."

	^bytes wordAtOffset: 2!

highWord: anInteger
	"Set the high-order word of the receiver. Assumes little-endian
	ordering. Answer the receiver."

	bytes wordAtOffset: 2 put: anInteger!

lowSWord
	"Answer the low-order signed word of the receiver. Assumes little-endian
	ordering."

	^bytes swordAtOffset: 0!

lowSWord: anInteger
	"Answer the low-order signed word of the receiver. Assumes little-endian
	ordering. Answer the receiver."

	bytes swordAtOffset: 0 put: anInteger!

lowWord
	"Answer the low-order word of the receiver. Assumes little-endian
	ordering."

	^bytes wordAtOffset: 0!

lowWord: anInteger
	"Answer the low-order word of the receiver. Assumes little-endian
	ordering. Answer the receiver."

	bytes wordAtOffset: 0 put: anInteger!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject! !

QWORD comment:
'<QWORD> is an abstract superclass for the two Win32 64-bit integer structures, LARGE_INTEGER (signed), and ULARGE_INTEGER (unsigned).

This class of structures is useful for communication with Win32 services that require 64-bit integer parameters. They also provide for easy access to the high and low 32-bit constituents of the integer''s native representation (Intel format 2''s complement).'!
!QWORD class methodsFor!

defineFields
	"Define the fields of the QWORD/ULARGE_INTEGER 'structure'.

		struct {
			DWORD LowPart;
			DWORD HighPart;
		};

		QWORD compileDefinition
	"

	super defineFields.
	self
		defineField: #lowPart
			type: DWORDField new
			offset: 0;
		defineField: #highPart
			type: DWORDField new
			offset: 4!

defineTemplate
	"Initialize the receiver class' structure template.

		QWORD compileDefinition.
	"

	super defineTemplate.
	self assert: [self alignment = 8]!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^QWORDField! !

!QWORD methodsFor!

asString
	"Answer the String representation of the receiver."

	^self asInteger displayString!

displayOn: aStream
	"Append a text representation of the receiver to aStream."

	aStream nextPutAll: self asString!

highPart
	"Answer the receiver's highPart field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #highPart)!

highPart: anObject 
	"Set the receiver's highPart field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #highPart) put: anObject!

lowPart
	"Answer the receiver's lowPart field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

lowPart: anObject 
	"Set the receiver's lowPart field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject!

printOn: aStream
	"Append a debug text representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; display: self; nextPut: $)
!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes qwordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes qwordAtOffset: 0 put: anObject! !

UINT_PTR comment:
''!
!UINT_PTR class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^UINT_PTRField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!UINT_PTR methodsFor!

asSignedInteger
	"Answer the signed 32-bit Integer value of the receiver."

	^bytes intPtrAtOffset: 0!

highPart
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [bytes dwordAtOffset: 4] ifFalse: [bytes wordAtOffset: 2]!

highPart: anObject 
	"Note: The compiler will optimise out the conditional because it is constant."

	VMConstants.IsWin64 
		ifTrue: [bytes dwordAtOffset: 4 put: anObject]
		ifFalse: [bytes wordAtOffset: 2 put: anObject]!

highPartSigned
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [bytes sdwordAtOffset: 4] ifFalse: [bytes swordAtOffset: 2]!

lowPart
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [bytes dwordAtOffset: 0] ifFalse: [bytes wordAtOffset: 0]!

lowPart: anObject 
	"Note: The compiler will optimise out the conditional because it is constant."

	VMConstants.IsWin64 
		ifTrue: [bytes dwordAtOffset: 0 put: anObject]
		ifFalse: [bytes wordAtOffset: 0 put: anObject]!

lowPartSigned
	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [bytes sdwordAtOffset: 0] ifFalse: [bytes swordAtOffset: 0]!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes uintPtrAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes uintPtrAtOffset: 0 put: anObject! !

WORD comment:
'<WORD> is an <ExternalStructure> class to wrap the Win32 type of the same name.

WORD is used to represent unsigned 16-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	0 to: (2**16)-1'!
!WORD class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^WORDField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!WORD methodsFor!

asSignedInteger
	"Answer the signed 16-bit Integer value of the receiver."

	^bytes swordAtOffset: 0!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes wordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes wordAtOffset: 0 put: anObject! !

SBYTE comment:
'<SBYTE> is an <ExternalStructure> class to wrap the Win32 type of the same name.

SBYTE is used to represent signed 8-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	(-2**7) to: (2**7)-1	(i.e. -128 to: 127)
'!
!SBYTE class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SBYTEField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!SBYTE methodsFor!

asUnsignedInteger
	"Answer the unsigned 16-bit Integer value of the receiver."

	^bytes byteAtOffset: 0!

unsignedValue: anUnsigned
	"Set the receiver's value field to the value of the unsigned positive
	integer, anUnsigned."

	bytes byteAtOffset: 0 put: anUnsigned!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes sbyteAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes sbyteAtOffset: 0 put: anObject! !

SDWORD comment:
'<SDWORD> is an <ExternalStructure> class to wrap the Win32 type of the same name.

SDWORD is used to represent signed 32-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	(-2**31) to: (2**31)-1
'!
!SDWORD class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SDWORDField!

fromUnsignedInteger: anUnsignedInteger
	"Answer a new instance of the receiver with contents copied from anInteger"

	^self new unsignedValue: anUnsignedInteger!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!SDWORD methodsFor!

asUnsignedInteger
	"Answer the unsigned 32-bit Integer value of the receiver."

	^bytes dwordAtOffset: 0!

unsignedValue: anUnsigned
	"Set the receiver's value field to the value of the unsigned positive
	integer, anUnsigned."

	bytes dwordAtOffset: 0 put: anUnsigned!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes sdwordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes sdwordAtOffset: 0 put: anObject! !

BOOL comment:
'<BOOL> is an <ExternalStructure> class to represent the Win32 BOOL (integer boolean) type.

Possible values are: 
	0 (defined as FALSE), equivalent to Smalltalk ''false'' object.
	1 (defined as TRUE), or indeed any other non-zero value, equivalent to Smalltalk ''true'' object.'!
!BOOL class methodsFor!

defineFields
	"Define the fields of the BOOL structure.
		BOOL compileDefinition
	
		typedef [uuid(73888634-0C5B-4D09-83DC-C52101C10BA3), 
			helpstring('An integer representing a boolean value (0 if FALSE, any other value TRUE)')]
		struct tagBOOL {
			long value;
		} BOOL;
	"

	self defineField: #value
		type: ((BOOLField new)
				beOverride;
				yourself)!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^BOOLField!

icon
	"Answers an Icon that can be used to represent this class"

	^Boolean icon! !

!BOOL methodsFor!

value
	"Answer the receiver's value field as a Smalltalk object."

	^(bytes dwordAtOffset: 0) asBoolean!

value: anObject
	"Set the receiver's value field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject asParameter! !

HRESULT comment:
''!
!HRESULT class methodsFor!

fail
	"Answer the generic failure HRESULT."

	^Fail!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	Fail := self fromInteger: E_FAIL.
	Facilities := LookupTable new.
	FacilityCodes keysAndValuesDo: [:eachKey :eachValue | Facilities at: eachValue put: eachKey]!

notImplemented
	"Answer the 'not implemented' HRESULT."

	^self fromInteger: E_NOTIMPL!

ntStatusCode: anInteger
	"Make and answer an HRESULT from the NT status code, anInteger."

	^self fromUnsignedInteger: (anInteger bitOr: FACILITY_NT_BIT)!

ok
	"Answer the 'OK' HRESULT."

	^self fromInteger: S_OK!

registerFacility: anInteger name: aString 
	"Register the specified facility code name for the specified facility code"

	Facilities at: anInteger put: aString!

severity: sev facility: fac code: code
	"Private - Make and answer an HRESULT from the arguments."

	^self fromUnsignedInteger: (
		((sev bitAnd: 1) bitShift: 31) bitOr:
			(((fac bitAnd: 16r1FFF) bitShift: 16) bitOr: (code bitAnd: 16rFFFF)))
!

status: code facility: fac
	"Private - Make and answer an HRESULT from the arguments."

	^self severity: SEVERITY_ERROR facility: fac code: code!

unregisterFacility: anInteger 
	"Unregister the specified facility code name for the specified facility code"

	Facilities removeKey: anInteger ifAbsent: []!

win32Error: anInteger 
	^self 
		severity: SEVERITY_ERROR
		facility: FACILITY_WIN32
		code: anInteger! !

!HRESULT methodsFor!

displayOn: aStream 
	"Append a textual representation of the receiver to aStream."

	| buf len |
	buf := String new: 255.
	len := KernelLibrary default 
				formatMessage: ##(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS)
				lpSource: 0
				dwMessageId: self asInteger
				dwLanguageId: 0
				lpBuffer: buf
				nSize: buf basicSize
				arguments: 0.
	len == 0 
		ifTrue: 
			[aStream
				nextPutAll: 'Unrecognised HRESULT - ';
				nextPutAll: (self asUnsignedInteger printStringRadix: 16)]
		ifFalse: 
			["Windows appends trailing line delimiter, and breaks up the text into lines too, 
			so we remove them."
			| lines |
			lines := buf lines.
			lines 
				from: 1
				to: lines size - 1
				do: 
					[:l | 
					aStream
						nextPutAll: l;
						space].
			aStream pop]!

errorCode
	"Answer the Win32 status code extracted from the receiver's code."

	^self asUnsignedInteger maskClear: ##(8191 bitShift: 16)!

facility
	"Answer a string describing the facility of the receiver's HRESULT code."

	^Facilities at: self facilityCode ifAbsent: ['Unknown facility']!

facilityCode
	"Answer the Win32 facility code extracted from the receiver's code.

		#define HRESULT_FACILITY(hr)  (((hr) >> 16) & 0x1fff)"

	^(self asUnsignedInteger bitShift: -16) bitAnd: 16r1FFF!

failed
	"Answer whether the receiver represents the result of a failed operation
	(named for compatibility with the C/C++ FAILED macro)."

	^self asUnsignedInteger anyMask: 16r80000000!

isSeverityError
	"Answer whether the receiver is a SEVERITY_ERROR code."

	^self severity == SEVERITY_ERROR!

printOn: aStream
	"Append a debug textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPutAll: '(0x'.
	self asUnsignedInteger printOn: aStream base: 16 showRadix: false.
	aStream
		nextPutAll: ' - ';
		display: self;
		nextPut: $)!

severity
	"Answer the severity of the HRESULT (1 for errors, otherwise 0)."

	^(self asInteger bitShift: -31) bitAnd: 16r1!

statusCode
	"Answer the Win32 status code extracted from the receiver.

		#define HRESULT_CODE(hr)	((hr) & 0xFFFF)"

	^self asUnsignedInteger bitAnd: 16rFFFF!

succeeded
	"Answer whether the receiver represents the result of a successful operation
	(named for compatibility with the C/C++ SUCCEEDED macro)."

	^self failed not! !

LARGE_INTEGER comment:
'<LARGE_INTEGER> is an <ExternalStructure> class to wrap the Win32 structure of the same name.

LARGE_INTEGER is used to represent signed 64-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	(-2**63) to: (2**63)-1

'!
!LARGE_INTEGER class methodsFor!

defineFields
	"Define the fields of the LARGE_INTEGER 'structure'.

		struct {
			DWORD LowPart;
			LONG HighPart;
		};

		LARGE_INTEGER compileDefinition
	"

	super defineFields.
	self
		defineField: #lowPart
			type: DWORDField new
			offset: 0;
		defineField: #highPart
			type: DWORDField new
			offset: 4

!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SQWORDField! !

!LARGE_INTEGER methodsFor!

highPart
	"Answer the receiver's highPart field as a Smalltalk object."

	^bytes sdwordAtOffset: ##(self offsetOf: #highPart)!

highPart: anObject 
	"Set the receiver's highPart field to the value of anObject."

	bytes sdwordAtOffset: ##(self offsetOf: #highPart) put: anObject!

lowPart
	"Answer the receiver's lowPart field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

lowPart: anObject 
	"Set the receiver's lowPart field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes sqwordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes sqwordAtOffset: 0 put: anObject! !

ULARGE_INTEGER comment:
'<ULARGE_INTEGER> is an <ExternalStructure> class to wrap the Win32 structure of the same name.

ULARGE_INTEGER is used to represent unsigned 64-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	0 to: (2**64)-1
'!
INT_PTR comment:
''!
!INT_PTR class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^INT_PTRField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!INT_PTR methodsFor!

asUnsignedInteger
	"Answer the unsigned machined-word sized integer value of the receiver."

	^bytes uintPtrAtOffset: 0!

unsignedValue: anUnsigned 
	"Set the receiver's value field to the value of the unsigned positive
	integer, anUnsigned."

	bytes uintPtrAtOffset: 0 put: anUnsigned!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes intPtrAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes intPtrAtOffset: 0 put: anObject! !

SWORD comment:
'<SWORD> is an <ExternalStructure> class to wrap the Win32 type of the same name.

SWORD is used to represent signed 16-bit integers in conjunction with Win32 APIs. 

The range of integer values that can be represented by instances of this class is defined by the interval:
	(-2**15) to: (2**15)-1'!
!SWORD class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SWORDField!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize
	"

	VMLibrary default registryAt: self name put: self!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil! !

!SWORD methodsFor!

asUnsignedInteger
	"Answer the unsigned 16-bit Integer value of the receiver."

	^bytes wordAtOffset: 0!

unsignedValue: anUnsigned
	"Set the receiver's value field to the value of the unsigned positive
	integer, anUnsigned."

	bytes dwordAtOffset: 0 put: anUnsigned!

value
	"Answer the receiver's value field as a Smalltalk object."

	^bytes swordAtOffset: 0!

value: anObject 
	"Set the receiver's value field to the value of anObject."

	bytes swordAtOffset: 0 put: anObject! !

ExternalPointer comment:
'ExternalPointer is a class to represent pointers to arbitrary blocks of externally allocated memory where the size of the block is known and can be associated with the pointer.'!
!ExternalPointer methodsFor!

byteSize
	"Answer the size of the memory block at which the receiver is pointing."

	^byteSize
	!

byteSize: anInteger
	"Record the size of the memory block at which the receiver is pointing."

	byteSize := anInteger
	!

initialize: anInteger
	"Initialize the receiver to be a pointer to the specified size of memory block."

	super initialize: anInteger.
	byteSize := anInteger!

size
	"Answer the size of the memory block at which the receiver is pointing."

	^byteSize
	! !

LPSTR comment:
'LPSTR is a class to represent pointers to single-byte strings. It is useful where an external function returns a pointer to a character string through a pointer argument, or where a callback function passes in a pointer to a string as an output parameter to be populated.

LPSTR implicitly converts to the referenced string when asked for its value, rather than answering the pointer value itself.'!
!LPSTR methodsFor!

asString
	"Answer a String composed of the characters of the receiver, or
	the empty string if the receiver is a null pointer."
	
	^self value!

value
	"Answer the UnicodeString pointed at by the receiver (N.B. it is copied into Smalltalk space)"

	^String fromAddress: super value! !

LPWSTR comment:
'LPWSTR is a class to represent pointers to Unicode strings. It is useful where an external function (or COM method call) returns a pointer to a wide character string through a pointer argument. An example being the IEnumString interface.

LPWSTR implicitly converts to the referenced Unicode string when asked for its value, rather than answering the pointer value itself.

'!
!LPWSTR methodsFor!

asString
	"Answer a String composed of the characters of the receiver, or
	the empty string if the receiver is a null pointer."
	
	^self value asString!

value
	"Answer the UnicodeString pointed at by the receiver (N.B. it is copied into Smalltalk space)"

	^UnicodeString fromAddress: super value! !

EXCEPTION_RECORD comment:
''!
!EXCEPTION_RECORD class methodsFor!

defineFields
	"Define the fields of the Win32 EXCEPTION_RECORD structure.

		EXCEPTION_RECORD compileDefinition

		struct {
			DWORD ExceptionCode;
			DWORD ExceptionFlags;
			EXCEPTION_RECORD* ExceptionRecord;
			PVOID ExceptionAddress;
			DWORD NumberParameters;
			ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
		} EXCEPTION_RECORD;"

	self
		defineField: #ExceptionCode type: DWORDField readOnly;
		defineField: #ExceptionFlags type: DWORDField readOnly beUncompiled;
		defineField: #ExceptionRecord type: DWORDField filler;
		defineField: #ExceptionAddress type: LPVOIDField readOnly;
		defineField: #NumberParameters type: DWORDField readOnly;
		defineField: #ExceptionInformation
			type: (ArrayField type: ByteArray length: EXCEPTION_MAXIMUM_PARAMETERS * VMConstants.IntPtrSize) 
					beFiller! !

!EXCEPTION_RECORD methodsFor!

ExceptionAddress
	"Answer the receiver's ExceptionAddress field as a Smalltalk object."

	^(bytes uintPtrAtOffset: ##(self offsetOf: #ExceptionAddress)) asExternalAddress!

ExceptionCode
	"Answer the receiver's ExceptionCode field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

information
	"Answer the receiver's ExceptionInformation as an <Array> of <Integer>."

	info isNil 
		ifTrue: 
			[| cParms |
			cParms := self NumberParameters.
			info := (0 to: (cParms - 1) * VMConstants.IntPtrSize by: VMConstants.IntPtrSize) 
						collect: [:offset | bytes uintPtrAtOffset: offset + 20]].
	^info!

moduleFileName
	"Answer the file name of the module within which the exception occurred."

	^(MEMORY_BASIC_INFORMATION forAddress: self ExceptionAddress) moduleFileName!

NumberParameters
	"Answer the receiver's NumberParameters field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #NumberParameters)! !

FILETIME comment:
'FILETIME is an ExternalStructure class to represent the Win32 FILETIME structure.

A FILETIME is a 64-bit integer count of the number of 100 nanosecond intervals since 01:00:00, 01 January 1601 UTC (i.e. not local time).

FILETIMEs are typically used to mark file creation/modification/access times with very high accurracy in a time zone independent manner.'!
!FILETIME class methodsFor!

defineFields
	"Define the fields of the Win32 FILETIME structure.

		typedef struct _FILETIME 
			DWORD dwLowDateTime;
			DWORD dwHighDateTime;
		 FILETIME, *PFILETIME, *LPFILETIME;

		FILETIME compileDefinition
	"

	self
		defineField: #dwLowDateTime type: DWORDField filler;
		defineField: #dwHighDateTime type: DWORDField filler!

fromInteger: anInteger 
	"Answer an instance of the receiver for the specified <integer> number
	of 100 nanosecond intervals since 01:00:00, 01 January 1601."

	^self new integerValue: anInteger!

fromLocalTime: aLocalFILETIME 
	"Answer a UTC file time from the specified local file time."

	| answer |
	answer := self new.
	(KernelLibrary default localFileTimeToFileTime: aLocalFILETIME lpFileTime: answer) 
		ifFalse: [^KernelLibrary default systemError].
	^answer!

fromSYSTEMTIME: aSYSTEMTIME 
	"Answer a file time from the specified SYSTEMTIME (assumed to be in
	local time)."

	^(LocalFILETIME fromSYSTEMTIME: aSYSTEMTIME) asUTC!

fromUnixTime: time_t 
	"Answer a file time from the specified time_t, where the argument is the number
	of seconds elapsed since midnight (00:00:00), January 1, 1970, coordinated
	universal time."

	^self fromInteger: UnixEpoch + (time_t * 10000000)!

initialize
	"Private - Initialize the receiver's class variables.
		FILETIME initialize
	"

	| baseFiletime |
	baseFiletime := (SYSTEMTIME 
				day: 1
				month: 1
				year: 1970) asFILETIME.
	UnixEpoch := baseFiletime bytes qwordAtOffset: 0!

now
	"Answer the current FILETIME. 
	Use the OLELibrary function if it is available.

		FILETIME now
	"

	^(Smalltalk at: #OLELibrary ifAbsent: []) 
		ifNil: [LocalFILETIME now asUTC]
		ifNotNil: [:lib | lib default now]! !

!FILETIME methodsFor!

asFILETIME
	"Answer the receiver as a FILETIME (which it is already)."

	^self!

asInteger
	"Answer a 64-bit integer specifying the number of 100 nanosecond intervals since the
	FILETIME epoch (01:00:00, 01 January 1601 UTC)."

	^bytes qwordAtOffset: 0!

asLocalTime
	"Answer the receiver converted to a local time (from UTC).
	N.B. There is no way of knowing if the receiver is already in local time
	(though this will always be the case for FILETIMEs provided by the OS)."

	| lib answer |
	answer := LocalFILETIME new.
	lib := KernelLibrary default.
	(lib fileTimeToLocalTime: self lpLocalFileTime: answer) ifFalse: [lib systemError].
	^answer!

asSYSTEMTIME
	"Answer the receiver converted to a SYSTEMTIME (first of
	all converting to local time)."

	"Implementation Note: Reproduce a little code to avoid
	creating a circular dependency on the subclass."

	| local |
	local := self class new.
	(KernelLibrary default fileTimeToLocalTime: self lpLocalFileTime: local) 
		ifFalse: [^KernelLibrary default systemError].
	^local basicAsSYSTEMTIME!

asUTC
	"Answer the receiver as a UTC FILETIME (which it is already)."

	^self!

basicAsSYSTEMTIME
	"Private - Answer the receiver converted to a <SYSTEMTIME>."

	| lib answer |
	answer := SYSTEMTIME new.
	lib := KernelLibrary default.
	(lib fileTimeToSystemTime: self lpSystemTime: answer) ifFalse: [lib systemError].
	^answer!

displayOn: aStream 
	"Append a textual representation of the receiver to aStream, suitable for an end user."

	aStream display: self asSYSTEMTIME!

integerValue: anInteger 
	"Set the number of 100-nanosecond intervals the receiver represents since the
	FILETIME epoch."

	bytes qwordAtOffset: 0 put: anInteger!

printOn: aStream 
	"Append a debug representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: self;
		nextPut: $)! !

MEMORY_BASIC_INFORMATION comment:
''!
!MEMORY_BASIC_INFORMATION class methodsFor!

defineFields
	"Define the fields of the Win32 MEMORY_BASIC_INFORMATION structure.

		MEMORY_BASIC_INFORMATION compileDefinition

		struct {
			PVOID BaseAddress;
			PVOID AllocationBase;
			DWORD AllocationProtect;
			DWORD RegionSize;
			DWORD State;
			DWORD Protect;
			DWORD Type;
		} MEMORY_BASIC_INFORMATION;"

	self 
		defineField: #BaseAddress		type: LPVOIDField readOnly;
		defineField: #AllocationBase		type: LPVOIDField readOnly;
		beUncompiled;
		defineField: #AllocationProtect	type: DWORDField readOnly;
		defineField: #RegionSize		type: DWORDField readOnly;
		defineField: #State				type: DWORDField readOnly;
		defineField: #Protect			type: DWORDField readOnly;
		defineField: #Type				type: DWORDField readOnly		
		

!

forAddress: anAddress
	"Answer a new instance of the receiver describing the memory region
	in which anAddress resides."

	| answer |
	answer := self new.
	KernelLibrary default virtualQuery: anAddress lpBuffer: answer dwLength: answer size.
	^answer! !

!MEMORY_BASIC_INFORMATION methodsFor!

AllocationBase
	"Answer the receiver's AllocationBase field as a Smalltalk object."

	^(bytes uintPtrAtOffset: ##(self offsetOf: #AllocationBase)) asExternalAddress!

BaseAddress
	"Answer the receiver's BaseAddress field as a Smalltalk object."

	^(bytes uintPtrAtOffset: 0) asExternalAddress!

moduleFileName
	"Answer the filename of the module to which the receiver's region
	maps. Only relevant for text segments."

	^ExternalLibrary moduleFileName: self AllocationBase! !

MSG comment:
'MSG is an <ExternalStructure> to wrap the Win32 structure of the same name.

MSG is an represents the state associated with a Windows message retrieved via GetMessage().'!
!MSG class methodsFor!

defineFields
	"Define the fields of the Win32 MSG structure.

		MSG compileDefinition
	
		typedef 		struct tagMSG {
			HWND hwnd;
			UINT message;
			ULONG_PTR wParam;
			LONG_PTR lParam;
			ULONG time;
			POINT pt;
		} MSG;
	"

	self
		defineField: #hwnd type: UINT_PTRField readOnly;
		defineField: #message type: DWORDField readOnly;
		defineField: #wParam type: UINT_PTRField readOnly;
		defineField: #lParam type: UINT_PTRField readOnly;
		beUncompiled;
		defineField: #time type: DWORDField readOnly;
		defineField: #x type: SDWORDField readOnly;
		defineField: #y type: SDWORDField readOnly
	"The real structure has a POINT here, but that is not part of the base Dolphin package any more so we 'inline' it"! !

!MSG methodsFor!

hwnd
	"Answer the receiver's hwnd field as a Smalltalk object."

	^bytes uintPtrAtOffset: 0!

isInput
	"Answer whether the receiver represents an input event."

	| msg |
	msg := self message.
	^(msg >= WM_KEYFIRST and: [ msg <= WM_KEYLAST ]) or: [
		msg >= WM_MOUSEFIRST and: [ msg <= WM_MOUSELAST ]]
!

isKeyboardInput
	"Answer whether the receiver represents a keyboard event (e.g. a WM_KEYDOWN)."

	| msg |
	msg := self message.
	^msg >= WM_KEYFIRST and: [msg <= WM_KEYLAST]!

isMouseInput
	"Answer whether the receiver represents a mouse event (e.g. a WM_MOUSEMOVE)."

	| msg |
	msg := self message.
	^msg >= WM_MOUSEFIRST and: [msg <= WM_MOUSELAST]!

lParam
	"Answer the receiver's lParam field as a Smalltalk object."

	^bytes uintPtrAtOffset: ##(self offsetOf: #lParam)!

message
	"Answer the receiver's message field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #message)!

swParam
	"Answer the <integer> value of the receiver's wParam field, treating
	it as a signed integer."

	^bytes intPtrAtOffset: 8!

wParam
	"Answer the receiver's wParam field as a Smalltalk object."

	^bytes uintPtrAtOffset: ##(self offsetOf: #wParam)! !

MSGBOXPARAMS comment:
'MSGBOXPARAMS is an <ExternalStructure> class which represents the Windows structure of the same name.

MSGBOXPARAMS is used to contain configuration details for Message Boxes.

Instance Variables:
	iconId	<integer> or <String> id of icon to be displayed in the box
	text	<String> Text to be display in box (address stored in struct, so need to prevent premature GC)
	caption 	<String> Caption of box (ditto)
	owner	<ExternalHandle>. Handle of owner view'!
!MSGBOXPARAMS class methodsFor!

defineFields
	"Define the fields of the Win32 MSGBOXPARAMS structure.

		MSGBOXPARAMS compileDefinition

	typedef struct {
			UINT cbSize;
			HWND hwndOwner;
			HINSTANCE hInstance;
			LPCSTR lpszText;
			LPCSTR lpszCaption;
			DWORD dwStyle;
			LPCSTR lpszIcon;
			DWORD dwContextHelpId;
			MSGBOXCALLBACK lpfnMsgBoxCallback;
			DWORD dwLanguageId;
		} MSGBOXPARAMS, *PMSGBOXPARAMS, FAR *LPMSGBOXPARAMS; 
	"

	self
		defineField: #dwSize type: DWORDField writeOnly beOverride;
		defineField: #hwndOwner type: DWORDField writeOnly;
		defineField: #hInstance type: DWORDField writeOnly;
		defineField: #lpszText type: (PointerField type: String) beWriteOnly;
		defineField: #lpszCaption type: (PointerField type: String) beWriteOnly;
		defineField: #dwStyle type: DWORDField writeOnly;
		defineField: #lpszIcon type: DWORDField writeOnly;
		beUncompiled;
		defineField: #dwContextHelpId type: DWORDField filler;
		defineField: #lpfnMsgBoxCallback type: DWORDField filler;
		defineField: #dwLanguageId type: DWORDField writeOnly
	"This field can hold a string, or an integer resource id"! !

!MSGBOXPARAMS methodsFor!

dwSize: anObject 
	"Set the receiver's dwSize field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject!

dwStyle: anObject 
	"Set the receiver's dwStyle field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwStyle) put: anObject!

hInstance: anObject 
	"Set the receiver's hInstance field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #hInstance) put: anObject!

hwndOwner: anObject 
	"Set the receiver's hwndOwner field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #hwndOwner) put: anObject!

lpszCaption: anObject 
	"Set the receiver's lpszCaption field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #lpszCaption) put: anObject yourAddress!

lpszIcon: anObject 
	"Set the receiver's lpszIcon field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #lpszIcon) put: anObject!

lpszText: anObject 
	"Set the receiver's lpszText field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #lpszText) put: anObject yourAddress! !

OSVERSIONINFO comment:
'OSVERSIONINFO is an ExternalStructure class to represent the Win32 OSVERSIONINFOEX structure.

OSVERSIONINFO is used to retrieve version information about the host OS on which an application is running. It is used in conjunction with .

This class adds various tests for common Windows variants (e.g. #isWin2k) and also an #osName method which answers a symbolic name for the host OS.
'!
!OSVERSIONINFO class methodsFor!

clear
	"Private - Reinitialize the receiver."

	Current := nil!

current
	"Answer the current instance of the receiver."

	Current isNil ifTrue: [Current := self getCurrent].
	^Current!

defineFields
	"Define the fields of the Win32 OSVERSIONINFO structure.

		OSVERSIONINFO compileDefinition

		typedef struct _OSVERSIONINFOEX{  
			DWORD dwOSVersionInfoSize; 
			DWORD dwMajorVersion; 
			DWORD dwMinorVersion; 
			DWORD dwBuildNumber; 
			DWORD dwPlatformId; 
			TCHAR szCSDVersion[128]; 
			WORD  wServicePackMajor;
			WORD  wServicePackMinor;
			WORD  wSuiteMask;
			BYTE  wProductType;
			BYTE  wReserved
		} OSVERSIONINFOEX;"

	self
		defineField: #dwSize type: DWORDField writeOnly beOverride;
		defineField: #dwMajorVersion type: DWORDField readOnly;
		defineField: #dwMinorVersion type: DWORDField readOnly;
		defineField: #dwBuildNumber type: DWORDField readOnly;
		defineField: #dwPlatformId type: DWORDField readOnly;
		defineField: #szCSDVersion type: (StringField length: 128) beReadOnly;
		defineField: #wServicePackMajor type: WORDField readOnly;
		defineField: #wServicePackMinor type: WORDField readOnly;
		defineField: #wSuiteMask type: WORDField readOnly;
		defineField: #wProductType type: BYTEField readOnly;
		defineField: #wReserved type: BYTEField filler!

getCurrent
	"Private - Get the current OSVERSIONINFO."

	| current |
	current := self new.
	KernelLibrary default getVersionEx: current.
	^current!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self clear.
! !

!OSVERSIONINFO methodsFor!

calculateOsName
	| major minor type |
	self assert: [self dwPlatformId = VER_PLATFORM_WIN32_NT].
	major := self dwMajorVersion.
	minor := self dwMinorVersion.
	type := self wProductType.
	major > 5 
		ifTrue: 
			["Vista or later"
			minor > 0 
				ifTrue: 
					[^type == VER_NT_WORKSTATION ifTrue: [#win7] ifFalse: [#win2k8r2].
					^type == VER_NT_WORKSTATION ifTrue: [#winVista] ifFalse: [#win2k8]]].
	minor > 1 ifTrue: [^#win2k3].
	minor > 0 ifTrue: [#winXP].
	^#win2k!

dwBuildNumber
	"Answer the receiver's dwBuildNumber field as a Smalltalk object."

	^(bytes dwordAtOffset: 12)!

dwMajorVersion
	"Answer the receiver's dwMajorVersion field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwMajorVersion)!

dwMinorVersion
	"Answer the receiver's dwMinorVersion field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwMinorVersion)!

dwPlatformId
	"Answer the receiver's dwPlatformId field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwPlatformId)!

dwSize: anObject 
	"Set the receiver's dwSize field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject!

hasThemes
	^self isWinXPOrLater!

isNT
	"Answer whether the host OS is NT (4 or 2000).
		OSVERSIONINFO current isNT
	"

	^self dwPlatformId == VER_PLATFORM_WIN32_NT!

isWin2K
	"Answer whether the host OS is Windows 2000.
		OSVERSIONINFO current isWin2K
	"

	^self osName == #win2k!

isWin2K3
	"Answer whether the host OS is Windows Server 2003 specifically."

	^self osName = #win2k3!

isWin2K3OrLater
	"Answer whether the host OS is Windows Server 2003, or some later version."

	^self dwPlatformId == VER_PLATFORM_WIN32_NT 
		and: [self dwMajorVersion > 5 or: [self dwMajorVersion == 5 and: [self dwMinorVersion >= 2]]]!

isWin95
	"Answer whether the host OS is Windows 95.
		OSVERSIONINFO current isWin95
	"

	"Dolphin no longer supports the pre-NT Windows OSs"

	^false!

isWin9X
	"Answer whether the host OS is Windows 95/98 or ME."

	"Dolphin no longer supports the pre-NT Windows OSs"

	^false!

isWinV5
	#deprecated.	"Use isWinV5OrLater, or test for specific versions"
	^#(#win2k #winXP #win98 #winMe) identityIncludes: self osName!

isWinV5OrLater
	"Answer whether the host OS is Windows 98 or Windows 2000 or later. These OSs added certain
	UI features such as menus with images.
		OSVERSIONINFO current isWinV5OrLater 
	"

	| major |
	major := self dwMajorVersion.
	^self dwPlatformId = VER_PLATFORM_WIN32_NT 
		ifTrue: [major >= 5]
		ifFalse: [major > 4 or: [major == 4 and: [self dwMinorVersion > 0]]]!

isWinV6OrLater
	"Answer whether the host OS is Windows Vista or later."

	^self dwMajorVersion >= 6!

isWinVista
	"Answer whether the host OS is Windows Vista or later."

	^self dwMajorVersion = 6!

isWinXP
	"Answer whether the host OS is Windows XP specifically."

	^self osName == #winXP!

isWinXPOrLater
	"Answer whether the host OS is Windows XP, Windows Server 2003, or some later version."

	^self dwPlatformId == VER_PLATFORM_WIN32_NT 
		and: [self dwMajorVersion > 5 or: [self dwMajorVersion == 5 and: [self dwMinorVersion >= 1]]]!

osName
	"Answer a symbolic name which indicates which is the host operating system, this will be one
	of #win7 #win28kr2, #win2k8, #win2k3, #winXP, #win2k. Dolphin no longer supports NT4 or the
	pre-NT generation of OSs such as Windows 98."

	osName isNil ifTrue: [osName := self calculateOsName].
	^osName!

szCSDVersion
	"Answer the receiver's szCSDVersion field as a Smalltalk object."

	^String fromAddress: bytes yourAddress + ##(self offsetOf: #szCSDVersion)!

wProductType
	"Answer the receiver's wProductType field as a Smalltalk object."

	^bytes byteAtOffset: ##(self offsetOf: #wProductType)!

wServicePackMajor
	"Answer the receiver's wServicePackMajor field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wServicePackMajor)!

wServicePackMinor
	"Answer the receiver's wServicePackMinor field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wServicePackMinor)!

wSuiteMask
	"Answer the receiver's wSuiteMask field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wSuiteMask)! !

PROCESS_INFORMATION comment:
''!
!PROCESS_INFORMATION class methodsFor!

defineFields
	"Define the fields of the Win32 PROCESS_INFORMATION structure.

		PROCESS_INFORMATION compileDefinition

	typedef struct _PROCESS_INFORMATION { // pi 
		HANDLE hProcess; 
		HANDLE hThread; 
		DWORD dwProcessId; 
		DWORD dwThreadId; 
	} PROCESS_INFORMATION; "

	self 
		beUncompiled;
		defineField: #hProcess type: DWORDField readOnly;
		defineField: #hThread type: DWORDField readOnly;
		defineField: #dwProcessId type: DWORDField readOnly;
		defineField: #dwThreadId type: DWORDField readOnly
! !

SECURITY_ATTRIBUTES comment:
''!
!SECURITY_ATTRIBUTES class methodsFor!

defineFields
	"Define the fields of the SECURITY_ATTRIBUTES structure:

		SECURITY_ATTRIBUTES compileDefinition.

	typedef struct _SECURITY_ATTRIBUTES { // sa 
		DWORD nLength; 
		LPVOID lpSecurityDescriptor; 
		BOOL bInheritHandle; 
	} SECURITY_ATTRIBUTES; "

	self
		defineField: #dwSize type: DWORDField writeOnly beOverride;
		beUncompiled;
		defineField: #lpSecurityDescriptor type: LPVOIDField new;
		defineField: #bInheritHandle type: BOOLField new
! !

!SECURITY_ATTRIBUTES methodsFor!

dwSize: anObject 
	"Set the receiver's dwSize field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject! !

STARTUPINFO comment:
''!
!STARTUPINFO class methodsFor!

defineFields
	"Define the layout of the Win32 STARTUPINFO structure.

		STARTUPINFO compileDefinition

	typedef struct _STARTUPINFO { 
	    DWORD   cb; 
	    LPTSTR  lpReserved; 
	    LPTSTR  lpDesktop; 
	    LPTSTR  lpTitle; 
	    DWORD   dwX; 
	    DWORD   dwY; 
	    DWORD   dwXSize; 
	    DWORD   dwYSize; 
	    DWORD   dwXCountChars; 
	    DWORD   dwYCountChars; 
	    DWORD   dwFillAttribute; 
	    DWORD   dwFlags; 
	    WORD    wShowWindow; 
	    WORD    cbReserved2; 
	    LPBYTE  lpReserved2; 
	    HANDLE  hStdInput; 
	    HANDLE  hStdOutput; 
	    HANDLE  hStdError; 
	} STARTUPINFO, *LPSTARTUPINFO;"

	self
		defineField: #dwSize type: DWORDField writeOnly beOverride;
		defineField: #lpReserved type: (PointerField type: String) beFiller;
		defineField: #lpDesktop type: (PointerField type: String) beWriteOnly;
		defineField: #lpTitle type: (PointerField type: String);
		defineField: #dwX type: DWORDField new;
		defineField: #dwY type: DWORDField new;
		defineField: #dwXSize type: DWORDField new;
		defineField: #dwYSize type: DWORDField new;
		defineField: #dwXCountChars type: DWORDField new beUncompiled;
		defineField: #dwYCountChars type: DWORDField new beUncompiled;
		defineField: #dwFillAttribute type: DWORDField new beUncompiled;
		defineField: #dwFlags type: DWORDField new;
		defineField: #wShowWindow type: WORDField new;
		defineField: #cbReserved2 type: WORDField filler;
		defineField: #lpReserved2 type: LPVOIDField filler;
		defineField: #hStdInput type: UINT_PTRField writeOnly;
		defineField: #hStdOutput type: UINT_PTRField writeOnly;
		defineField: #hStdError type: UINT_PTRField writeOnly! !

!STARTUPINFO methodsFor!

desktop: aString
	"Set the desktop identifier for the receiver to aString. We store down the String
	in an instance variable to prevent it being GC'd"

	desktop := aString.
	self lpDesktop: aString!

dwFlags
	"Answer the receiver's dwFlags field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwFlags)!

dwFlags: anObject 
	"Set the receiver's dwFlags field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwFlags) put: anObject!

dwSize: anObject 
	"Set the receiver's dwSize field to the value of anObject."

	bytes dwordAtOffset: 0 put: anObject!

dwX
	"Answer the receiver's dwX field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwX)!

dwX: anObject 
	"Set the receiver's dwX field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwX) put: anObject!

dwXSize
	"Answer the receiver's dwXSize field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwXSize)!

dwXSize: anObject 
	"Set the receiver's dwXSize field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwXSize) put: anObject!

dwY
	"Answer the receiver's dwY field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwY)!

dwY: anObject 
	"Set the receiver's dwY field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwY) put: anObject!

dwYSize
	"Answer the receiver's dwYSize field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwYSize)!

dwYSize: anObject 
	"Set the receiver's dwYSize field to the value of anObject."

	bytes dwordAtOffset: ##(self offsetOf: #dwYSize) put: anObject!

hStdError: anObject 
	"Set the receiver's hStdError field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #hStdError) put: anObject!

hStdInput: anObject 
	"Set the receiver's hStdInput field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #hStdInput) put: anObject!

hStdOutput: anObject 
	"Set the receiver's hStdOutput field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #hStdOutput) put: anObject!

lpDesktop: anObject 
	"Set the receiver's lpDesktop field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #lpDesktop) put: anObject yourAddress!

lpTitle
	"Answer the receiver's lpTitle field as a Smalltalk object."

	^String fromAddress: (bytes intPtrAtOffset: ##(self offsetOf: #lpTitle))!

lpTitle: anObject 
	"Set the receiver's lpTitle field to the value of anObject."

	bytes uintPtrAtOffset: ##(self offsetOf: #lpTitle) put: anObject yourAddress!

stderr: aFile
	"Set the hStdError descriptor to aFile. We store down the File
	in an instance variable to prevent it being GC'd"

	stderr := aFile.
	self hStdError: stderr asParameter!

stdin: aFile
	"Set the hStdInput descriptor to aFile. We store down the File
	in an instance variable to prevent it being GC'd"

	stdin := aFile.
	self hStdInput: stdin asParameter!

stdout: aFile
	"Set the hStdOutput descriptor to aFile. We store down the File
	in an instance variable to prevent it being GC'd"

	stdout := aFile.
	self hStdOutput: stdout asParameter!

title: aString
	"Set the title for the receiver to aString. We store down the String
	in an instance variable to prevent it being GC'd"

	title := aString.
	self lpTitle: aString!

wShowWindow
	"Answer the receiver's wShowWindow field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wShowWindow)!

wShowWindow: anObject 
	"Set the receiver's wShowWindow field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wShowWindow) put: anObject! !

SYSTEMTIME comment:
''!
!SYSTEMTIME class methodsFor!

day: day month: month year: year
	"Private - Answer a new instance of the receiver for the specified day, month, and year."

	^self new wDay: day; wMonth: month; wYear: year!

defineFields
	"Define the fields of the Win32 SYSTEMTIME structure

		SYSTEMTIME compileDefinition
	"

	self defineField: #wYear type: WORDField new;
		defineField: #wMonth type: WORDField new;
		defineField: #wDayOfWeek type: WORDField new;
		defineField: #wDay type: WORDField new;
		defineField: #wHour type: WORDField new;
		defineField: #wMinute type: WORDField new;
		defineField: #wSecond type: WORDField new;
		defineField: #wMilliseconds type: WORDField new	!

fromFILETIME: aFILETIME
	"Answer a new instance of the receiver instantiated from aFILETIME (which may be
	in local or UTC form).
	We double dispatch this back to the argument, aFILETIME, so that it can perform
	conversion from UTC if necessary."

	^aFILETIME asSYSTEMTIME!

now
	"Private - Answer the current Windows local time"
	
	| answer |
	answer := self new.
	KernelLibrary default getLocalTime: answer.
	^answer!

nowUTC
	"Answer the current time in UTC"

	| answer |
	answer := self new.
	KernelLibrary default getSystemTime: answer.
	^answer! !

!SYSTEMTIME methodsFor!

asFILETIME
	"Answer a FILETIME corresponding to the receiver."

	^FILETIME fromSYSTEMTIME: self!

asTimeStamp
	"Answer a TimeStamp corresponding to the receiver."

	^TimeStamp fromSYSTEMTIME: self!

displayOn: aStream
	"Append a displayable representation of the receiver to aStream.
	Use the same display format as the system does, e.g. in Explorer, which is
	date followed by time separated by a space."

	| lc |
	lc := Locale default.
	aStream 
		nextPutAll: (lc printSysDate: self format: nil flags: 0);
		space;
		nextPutAll: (lc printTime: self format: nil flags: 0)
!

printOn: aStream
	"Append a debugging representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		nextPut: $(; 
		display: self; 
		nextPut: $)
!

wDay
	"Answer the receiver's wDay field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wDay)!

wDay: anObject 
	"Set the receiver's wDay field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wDay) put: anObject!

wDayOfWeek
	"Answer the receiver's wDayOfWeek field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wDayOfWeek)!

wDayOfWeek: anObject 
	"Set the receiver's wDayOfWeek field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wDayOfWeek) put: anObject!

wHour
	"Answer the receiver's wHour field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wHour)!

wHour: anObject 
	"Set the receiver's wHour field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wHour) put: anObject!

wMilliseconds
	"Answer the receiver's wMilliseconds field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wMilliseconds)!

wMilliseconds: anObject 
	"Set the receiver's wMilliseconds field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wMilliseconds) put: anObject!

wMinute
	"Answer the receiver's wMinute field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wMinute)!

wMinute: anObject 
	"Set the receiver's wMinute field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wMinute) put: anObject!

wMonth
	"Answer the receiver's wMonth field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wMonth)!

wMonth: anObject 
	"Set the receiver's wMonth field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wMonth) put: anObject!

wSecond
	"Answer the receiver's wSecond field as a Smalltalk object."

	^bytes wordAtOffset: ##(self offsetOf: #wSecond)!

wSecond: anObject 
	"Set the receiver's wSecond field to the value of anObject."

	bytes wordAtOffset: ##(self offsetOf: #wSecond) put: anObject!

wYear
	"Answer the receiver's wYear field as a Smalltalk object."

	^bytes wordAtOffset: 0!

wYear: anObject 
	"Set the receiver's wYear field to the value of anObject."

	bytes wordAtOffset: 0 put: anObject! !

TIME_ZONE_INFORMATION comment:
''!
!TIME_ZONE_INFORMATION class methodsFor!

defineFields
"Define the fields of the Win32 TIME_ZONE_INFORMATION structure
		self compileDefinition

	typedef struct _TIME_ZONE_INFORMATION
	{
		LONG Bias;
		WCHAR StandardName[ 32 ];
		SYSTEMTIME StandardDate;
		LONG StandardBias;
		WCHAR DaylightName[ 32 ];
		SYSTEMTIME DaylightDate;
		LONG DaylightBias;
	} TIME_ZONE_INFORMATION;"


	self 
		defineField: #bias type: SDWORDField readOnly;
		defineField: #standardName type: (ArrayField type: UnicodeString length: 32) beReadOnly;
		defineField: #standardDate type: (StructureField type: SYSTEMTIME) beReadOnly;
		defineField: #standardBias type: SDWORDField readOnly;
		defineField: #daylightName type: (ArrayField type: UnicodeString length: 32) beReadOnly;
		defineField: #daylightDate type: (StructureField type: SYSTEMTIME) beReadOnly;
		defineField: #daylightBias type: SDWORDField readOnly! !

!TIME_ZONE_INFORMATION methodsFor!

bias
	"Answer the receiver's bias field as a Smalltalk object."

	^bytes sdwordAtOffset: 0!

daylightBias
	"Answer the receiver's daylightBias field as a Smalltalk object."

	^bytes sdwordAtOffset: ##(self offsetOf: #daylightBias)!

daylightDate
	"Answer the receiver's daylightDate field as a Smalltalk object."

	^SYSTEMTIME fromAddress: bytes yourAddress + ##(self offsetOf: #daylightDate)!

daylightName
	"Answer the receiver's daylightName field as a Smalltalk object."

	^UnicodeString fromAddress: (bytes yourAddress + 88)!

standardBias
	"Answer the receiver's standardBias field as a Smalltalk object."

	^bytes sdwordAtOffset: ##(self offsetOf: #standardBias)!

standardDate
	"Answer the receiver's standardDate field as a Smalltalk object."

	^SYSTEMTIME fromAddress: bytes yourAddress + ##(self offsetOf: #standardDate)!

standardName
	"Answer the receiver's standardName field as a Smalltalk object."

	^UnicodeString fromAddress: (bytes yourAddress + 4)! !

VS_FIXEDFILEINFO comment:
'VS_FIXEDFILEINFO is an ExternalStructure class to represent the Win32 structure of the same name.

This structure is used in conjunction with the Windows version information library (Version.DLL) to access standard version information such as the product major and minor version numbers from the resources of exes and dlls.

See also the VersionInfo and VersionLibrary classes.'!
!VS_FIXEDFILEINFO class methodsFor!

defineFields
	"Private - Define the layout of the Win32 VS_FIXEDFILEINFO structure.
	
		VS_FIXEDFILEINFO compileDefinition
 
	typedef struct _VS_FIXEDFILEINFO   // vsffi 
		DWORD dwSignature; 
		DWORD dwStrucVersion; 
		DWORD dwFileVersionMS; 
		DWORD dwFileVersionLS; 
		DWORD dwProductVersionMS; 
		DWORD dwProductVersionLS; 
		DWORD dwFileFlagsMask; 
		DWORD dwFileFlags; 
		DWORD dwFileOS; 
		DWORD dwFileType; 
		DWORD dwFileSubtype; 
		DWORD dwFileDateMS; 
		DWORD dwFileDateLS; 
	} VS_FIXEDFILEINFO;"

	self
		defineField: #dwSignature type: DWORDField filler;
		defineField: #dwStrucVersion type: DWORDField readOnly beUncompiled;
		defineField: #dwFileVersionMS type: DWORDField readOnly;
		defineField: #dwFileVersionLS type: DWORDField readOnly;
		defineField: #dwProductVersionMS type: DWORDField readOnly;
		defineField: #dwProductVersionLS type: DWORDField readOnly;
		beUncompiled;
		defineField: #dwFileFlagsMask type: DWORDField readOnly;
		defineField: #dwFileFlags type: DWORDField readOnly;
		defineField: #dwFileOS type: DWORDField readOnly;
		defineField: #dwFileType type: DWORDField readOnly;
		defineField: #dwFileSubtype type: DWORDField readOnly;
		defineField: #dwFileDateMS type: DWORDField readOnly;
		defineField: #dwFileDateLS type: DWORDField readOnly
! !

!VS_FIXEDFILEINFO methodsFor!

dwFileVersionLS
	"Answer the receiver's dwFileVersionLS field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwFileVersionLS)!

dwFileVersionMS
	"Answer the receiver's dwFileVersionMS field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwFileVersionMS)!

dwProductVersionLS
	"Answer the receiver's dwProductVersionLS field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwProductVersionLS)!

dwProductVersionMS
	"Answer the receiver's dwProductVersionMS field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #dwProductVersionMS)!

fileVersionString
	"Answer a String in the form N.N.N.N which specifies the version number of the product."

	^self formatFileVersionString: '%1!!d!!.%2!!d!!.%3!!d!!.%4!!d!!'!

formatFileVersionString: format
	"Answer a version string formatted as per the Win32 format string, format."

	| major minor |
	major := self dwFileVersionMS.
	minor := self dwFileVersionLS.
	^format formatWithArguments: (Array 
				with: major highWord
				with: major lowWord
				with: minor highWord
				with: minor lowWord)!

formatProductVersionString: format
	"Answer a version string formatted as per the Win32 format string, format."

	| major minor |
	major := self dwProductVersionMS.
	minor := self dwProductVersionLS.
	^format formatWithArguments: (Array 
				with: major highWord
				with: major lowWord
				with: minor highWord
				with: minor lowWord)!

productVersionString
	"Answer a String in the form N.N.N.N which specifies the version number of the product."

	^self formatProductVersionString: '%1!!d!!.%2!!d!!.%3!!d!!.%4!!d!!'!

versionAtOffset: anInteger put: anArray 
	(1 to: 4 by: 2) do: 
			[:i | 
			| offset |
			offset := anInteger + ((i - 1) * 2).
			(self bytes)
				wordAtOffset: offset put: (anArray at: i + 1);
				wordAtOffset: offset + 2 put: (anArray at: i)]! !

WIN32_FIND_DATA comment:
'WIN32_FIND_DATA is an <ExternalStructure> to wrap the Win32 structure of the same name. WIN32_FIND_DATA is used in conjunction with the kernel library API functions FindFirstFile() and FindNextFile().

See File class for example usage.'!
!WIN32_FIND_DATA class methodsFor!

defineFields
	"Define the layout of the Win32 WIN32_FIND_DATA structure. 
	Currently to avoid wasting space, the structure is defined as mostly filler 
	fields.

		WIN32_FIND_DATA compileDefinition

		struct {
			DWORD dwFileAttributes; 
			FILETIME ftCreationTime; 
			FILETIME ftLastAccessTime; 
			FILETIME ftLastWriteTime; 
			DWORD    nFileSizeHigh; 
			DWORD    nFileSizeLow; 
			DWORD    dwReserved0; 
			DWORD    dwReserved1; 
			TCHAR    cFileName[ MAX_PATH ]; 
			TCHAR    cAlternateFileName[ 14 ]; 
		} WIN32_FIND_DATA;"

	self 
		defineField: #dwFileAttributes type: DWORDField readOnly;
		defineField: #ftCreationTime type: (StructureField type: FILETIME) beReadOnly;
		defineField: #ftLastAccessTime type: (StructureField type: FILETIME) beReadOnly;
		defineField: #ftLastWriteTime type: (StructureField type: FILETIME) beReadOnly;
		defineField: #nFileSizeHigh type: DWORDField readOnly;
		defineField: #nFileSizeLow type: DWORDField readOnly;
		defineField: #dwReserved0 type: DWORDField filler;
		defineField: #dwReserved1 type: DWORDField filler;
		defineField: #cFileName type: (StringField length: File maxPath) beReadOnly;
		defineField: #cAlternateFileName type: (StringField length: 14) beReadOnly! !

!WIN32_FIND_DATA methodsFor!

cAlternateFileName
	"Answer the receiver's cAlternateFileName field as a Smalltalk object."

	^String fromAddress: bytes yourAddress + ##(self offsetOf: #cAlternateFileName)!

cFileName
	"Answer the receiver's cFileName field as a Smalltalk object."

	^String fromAddress: bytes yourAddress + ##(self offsetOf: #cFileName)!

directory
	^directory!

directory: aString
	directory := aString!

dwFileAttributes
	"Answer the receiver's dwFileAttributes field as a Smalltalk object."

	^bytes dwordAtOffset: 0!

fileName
	"Answer the full filename from the receiver."

	^self cFileName!

fileSize
	"Answer the <integer> size of the file."

	^(self nFileSizeHigh bitShift: 32) + self nFileSizeLow!

ftCreationTime
	"Answer the receiver's ftCreationTime field as a Smalltalk object."

	^FILETIME fromAddress: bytes yourAddress + ##(self offsetOf: #ftCreationTime)!

ftLastAccessTime
	"Answer the receiver's ftLastAccessTime field as a Smalltalk object."

	^FILETIME fromAddress: bytes yourAddress + ##(self offsetOf: #ftLastAccessTime)!

ftLastWriteTime
	"Answer the receiver's ftLastWriteTime field as a Smalltalk object."

	^FILETIME fromAddress: bytes yourAddress + ##(self offsetOf: #ftLastWriteTime)!

isDirectory
	"Answer whether the receiver describes a directory (as opposed to a file) 
	in the host file system."

	^self dwFileAttributes allMask: FILE_ATTRIBUTE_DIRECTORY!

isReadOnly
	"Answer whether the receiver describes a read only file."

	^self dwFileAttributes allMask: FILE_ATTRIBUTE_READONLY
!

nFileSizeHigh
	"Answer the receiver's nFileSizeHigh field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #nFileSizeHigh)!

nFileSizeLow
	"Answer the receiver's nFileSizeLow field as a Smalltalk object."

	^bytes dwordAtOffset: ##(self offsetOf: #nFileSizeLow)!

path
	"Answer the path of the file described by the receiver (assuming the 
	directory has been set correctly)."

	^File composePath: self directory subPath: self fileName!

shortFileName
	"Answer the 8.3 filename from the receiver."

	| answer |
	answer := self cAlternateFileName.
	answer isEmpty ifTrue: [answer := self cFileName].
	^answer!

stem
	"Answer the stem (name sans extension) of the file described by the receiver."

	^File splitStemFrom: self fileName! !

LocalFILETIME comment:
'LocalFILETIME is an ExternalStructure class to represent the Win32 FILETIMEs that are in local time, as opposed to the usual UTC of normal FILETIMEs. See <FILETIME> for further details.'!
!LocalFILETIME class methodsFor!

fromSYSTEMTIME: aSYSTEMTIME
	"Answer a file time from the specified SYSTEMTIME (assumed to be in
	local time)."

	| answer |
	answer := self new.
	(KernelLibrary default systemTimeToFileTime: aSYSTEMTIME lpFileTime: answer) 
		ifFalse: [^KernelLibrary default systemError].
	^answer!

now
	"Answer the current LocalFILETIME.
	Use the OLELibrary function if it is available.

		LocalFILETIME now
	"

	^self fromSYSTEMTIME: SYSTEMTIME now! !

!LocalFILETIME methodsFor!

asLocalTime
	"Answer the receiver in local time (which it is already)."

	^self!

asSYSTEMTIME
	"Answer the receiver converted to a SYSTEMTIME."

	^self basicAsSYSTEMTIME!

asUTC
	"Answer the receiver as a UTC FILETIME."

	^FILETIME fromLocalTime: self
! !

AbsoluteFileLocator comment:
'An AbsoluteFileLocator is used to indicate the location of an external file that may be referenced within the image. 
Instances of this class always locate files by their full absolute path.

Try the following examples:

relativePath := FileLocator absolute relativePathTo: SessionManager current imageFileName. "Display It"
FileLocator absolute localFileSpecFor: relativePath. "Display It"'!
!AbsoluteFileLocator class methodsFor!

current
	"Answer the singleton instance of the receiver"

	Current isNil ifTrue: [ Current := self new ].
	^Current!

onPreStripImage
	"Private -  Assist in the image stripping process by clearning down any
	lazily initialized variables held by the receiver."

	self uninitialize!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self current.
	anSTBInFiler register: singleton.
	^singleton!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Current := nil! !

!AbsoluteFileLocator methodsFor!

localFileSpecFor: aStringFilename
	"Answer a filespec for aStringFilename, which is expected to be an absolute path already."

	^aStringFilename

!

relativePathTo: aFilename
	"Answer a minimal <readableString> relative path to the resource with the 
	specified <readableString> path, which the receiver can map back to a full
	path via its #localFileSpecFor: method. In this case we need an absolute path."

	^File fullPathOf: aFilename
!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self! !

ClassLocator comment:
'A ClassLocator is used to find a class for an object being read from an external serialized stream (such as STB). The locator first tries to match an exsiting class already in the image and, if this fails, it is then used to indicate the location of an external binary class that may be loaded into the image. To do this, the locator holds the code base where the external BinaryPackage file resides and a key (usually the class name) that can be used to identify a particular class within the package.  The standard ClassLocator is used when the binary package file can be found on a UNC file system.  If the class is part of an applet and is to be located by a URL then a URLClassLocator should be used instead.

Instance Variables:
	packageName 	<readableString> indicating the name of the package containing the required class.
	codeBase		<readableString> indicating the base directory from which a BinaryPackage should be loaded.
	key		<readableString> indicating the name of a class to load from the package.

Class Variables:
	ImportedClasses		<WeakLookupTable> holding the imported classes looked up by their full class keys.
	DefaultFileLocator		<ClassLocator> which is the default locator to use when loading external resource files.
	ImportedClassesMutex	<Mutex> to use when resolving imported classes.
	Aliases			<WeakLookupTable> mapping old class names to existing class.

'!
!ClassLocator class methodsFor!

addAlias: aSymbol forClass: aClass
	"Record the symbolic name, aSymbol, as an alias for the class name, aClass.
	This is useful where, for example, previously binary filed classes have been renamed, and one
	does not wish to keep a global variable for that alias. It can be useful to have the global variable
	as well to permit loading subclasses, but such globals may be removed by the image stripper, so
	some mechanism is needed to maintain backwards compatibility with old binary files."

	Aliases at: aSymbol asSymbol put: aClass!

binaryPackageExtension
	"Answers the standard file extension String used for binary package files."

	^'pak'!

codeBase: codeBaseString 
	"Answer an instance of the receiver with a codeBase of codeBaseString and nil key. Such an instance
	is only useful when it also has a key."

	^self codeBase: codeBaseString packageName: nil key: nil!

codeBase: codeBaseString packageName: packageString
	"Answer an instance of the receiver with a codeBase of  codeBaseString and nil key. Such an instance
	is only useful when it also has a key."

	^self codeBase: codeBaseString packageName: packageString key: nil!

codeBase: codeBaseString packageName: packageString key: keyString
	"Answer an instance of the receiver with a codeBase of  codeBaseString and  keyString class key."

	^(super new)
		 codeBase: codeBaseString;
		 packageName: packageString;
		 key: keyString!

default
	"Answers an instance of the receiver that can be used to locate external files
	relative to the current installation directory."

	^self new
!

importedClasses
	"Answer the LookupTable of classes that have been imported into this image."

	^ImportedClasses!

importedClassesMutex
	"Private - Answer the mutex used to provide mutual exclusion to the locateClass
	method."

	^ImportedClassesMutex!

initialize
	"Private - Initialize the class variables.

		self initialize
	"

	ImportedClasses := WeakLookupTable new haveWeakValues.
	ImportedClassesMutex := Mutex new.
	SessionManager current 
		when: #sessionStarted
		send: #onStartup
		to: self.
	Aliases := WeakLookupTable new haveWeakValues!

new
	"Answer a new, initialized, instance of the receiver."

	^super new initialize!

onStartup
	"Private - The session has started. Clear down the cached file locators"

	DefaultFileLocator := nil.
	InstallationFileLocator := nil.
	ImportedClasses := WeakLookupTable new haveWeakValues.
!

removeAlias: aSymbol
	"Remove the symbolic name, aSymbol, a previously established class alias.
	Note that it is not strictly necessary to do this because the Aliases collection
	is weak, and the alias will disappear if the class is removed."

	Aliases removeKey: aSymbol asSymbol ifAbsent: []!

stbConvertFrom: anSTBClassFormat 
	"Convert from earlier version models.
	1: Added 'packageName' instance variable."

	^
	[:data | 
	| newInst |
	newInst := self basicNew.
	data keysAndValuesDo: [:i :v | newInst instVarAt: i + 1 put: v].
	newInst]!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^1!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	ImportedClasses := ImportedClassesMutex := nil.
	SessionManager current removeEventsTriggeredFor: self.

! !

!ClassLocator methodsFor!

codeBase
	"Answer the receiver's codeBase. This is used to complete a relative key."

	^codeBase!

codeBase: aString
	"Private - Sets the receiver's codeBase instVar to aString. 
	This is used to complete a relative key."

	codeBase := aString.
!

copyWithCodeBase
	"Private - Answer a instance of the same class as the receiver with the same codeBase.
	This allows both the codeBase and the mechanism for using it to be propagated."

	^(self class codeBase: codeBase) packageName: self packageName
!

errorClassCircularityDetected
	"Private - Signal an error indicating there exists a circular class dependency
	in involving the class identified by the receiver."

	self error: 'A circular class dependency has been encountered involving class ', key!

errorClassNotFound
	"Private - Signal an error indicating that a particular was not found in the image and 
	could not be dynamically loaded"

	self error: ('The class <1s> could not be found in the image' expandMacrosWith: key)!

findAvailableClass
	"Answer the class referred to by the receiver if the class is either resident or a loaded foreign
	import. If the class referred to by the receiver is a foreign class that has not yet been imported
	then answer nil."

	| class |
	(class := self findResidentClass) isNil
		ifTrue: [class := ImportedClasses at: self fullClassKey ifAbsent: []].
	^class!

findResidentClass
	"Private - Answer the class referred to by the receiver if it is
	fully resident in the image."

	| className |
	className := key asSymbol.
	^Smalltalk at: className ifAbsent: [Aliases at: className ifAbsent: []]!

fullClassKey
	"Answer the full specification of the class identified by the receiver."

	^ self codeBase, self key
!

fullPackageKey
	"Answer the full specification of any package identified by the receiver or nil
	if there is none."

	^self hasPackageName ifTrue: [ self codeBase, self packageName ]!

hasPackageName
	"Private - Answer true if the receiver has a package name specified"

	^self packageName notNil!

initialize
	"Private - Initialize the receiver's identity instance variables."

	codeBase := ''!

installImportedClass: aClass
	"Private - Install aClass, an imported class into the system"

	| classKey |
	classKey := self codeBase, aClass name asString.
	ImportedClasses at: classKey ifAbsent: [
		ImportedClasses at: classKey put: aClass ]
!

key
	"Answer the receiver's key inst var."

	^key!

key: aString
	"Private - Set the receiver's key inst var to aString."

	key := aString!

localFileSpecFor: aStringFilename
	"Answer a filespec for aStringFilename relative to the current installation
	directory and codebase."

	| filename |
	filename := aStringFilename.
	self codeBase notNil ifTrue: [
		filename := File composePath: codeBase subPath: filename ].
	^super localFileSpecFor: filename
!

localFileSpecForPackage
	"Private - Answer a local filespec based on the fullPackageKey."

	^self localFileSpecFor: self binaryPackageFilename!

locateClass
	"Answer the class referred to by the receiver."

	| class |
	(class := self findResidentClass) isNil ifTrue: [
		class := self findOrImportForeignClass ].
	^class!

packageName
	"Answer the receiver's  package name <readableString>."

	^packageName!

packageName: aString
	"Private - Set the receiver's package name to aString."

	packageName := aString!

printOn: aStream
	"Append, to aStream, a String whose characters are a description of the receiver as a developer
	would want to see it."

	super printOn: aStream.
	aStream
		nextPut: $(;
		print: packageName;
		nextPutAll: ', ';
		print: codeBase;
		nextPutAll: ', ';
		print: key;
		nextPut: $)! !

RelativeFileLocator comment:
'RelativeFileLocator is the abstract class of <FileLocator>s that can be used to map between an absolute path and a path relative to a certain base directory.
RelativeFileLocators use absolute paths for files outside the local directory hierarchy below the base directory, and relative paths within their local directory hierarchy.'!
!RelativeFileLocator methodsFor!

relativePathTo: aString 
	"Answer a minimal <readableString> relative path to the resource with the 
	specified <readableString> path from the receiver's base path."

	^self relativePathIfSubPath: aString! !

ValidatingClassLocator comment:
'A ValidatingClassLocator is an extension to the standard ClassLocator which can be used to validate classes of objects being read from an external serial stream (such as STB).  STB is inherently an insecure format since it can contain any objects, including blocks of code which may be malicious in nature.  By plugging a ValidatingClassLocator into an STBInFiler then one is able to check the classes of objects in the input stream before they are allowed into the image.

The validation is controlled by a #validationBlock which is passed the symbolic class names of objects being loaded.  The block should return true if the load is to be permitted.  If the block returns false then an STBError exception is signalled.

Typically, ValidatingClassLocator can be considered a private class only instantiated as part of an STBValidatingInFiler.'!
!ValidatingClassLocator methodsFor!

copyWithCodeBase
	"Private - Answer a instance of the same class as the receiver with the same codeBase.
	This allows both the codeBase and the mechanism for using it to be propagated."

	^super copyWithCodeBase validationBlock: self validationBlock!

findResidentClass
	"Private - Answer the class referred to by the receiver if it is fully resident in the image. 
	First see if the requested class is valid."

	(self validationBlock value: self key asSymbol) 
		ifFalse: [STBValidatingInFiler errorInvalidClass: self key].
	^super findResidentClass!

initialize
	"Private - Initialize the receiver"

	super initialize.
	self validationBlock: [:className | true]!

validationBlock
	"Answer the monadic valuable (usually a block) that when passed a class name symbol will answer true if objects
	of this class are valid for loading into the image from the input stream associated with the receiver."

	^validationBlock!

validationBlock: aMonadicValuable 
	"Set the monadic valuable (usually a block) that when passed a class name symbol will answer true if objects
	of this class are valid for loading into the image from the input stream associated with the receiver."

	validationBlock := aMonadicValuable.
! !

FolderRelativeFileLocator comment:
'FolderRelativeFileLocator is the class of <FileLocator>s that can be used to map between an absolute path and a path relative to a configurable base directory.
FolderRelativeFileLocators use absolute paths for files outside the local directory hierarchy below the base directory, and relative paths within their local directory hierarchy.

Instance Variables:
	basePath		<String>. Base folder path.

'!
!FolderRelativeFileLocator class methodsFor!

basePath: aString 
	"Answer a new instance of the receiver for the specified base path."

	^(self new)
		basePath: aString;
		yourself! !

!FolderRelativeFileLocator methodsFor!

basePath
	^basePath!

basePath: aString 
	basePath := aString!

printOn: aStream 
	"Append, to aStream, a String whose characters are a description of the receiver as a developer
	would want to see it."

	aStream
		display: self class name;
		space;
		nextPutAll: #basePath:;
		space;
		print: self basePath! !

ImageRelativeFileLocator comment:
'An ImageRelativeFileLocator is used to indicate the location of an external file that may be referenced within the image. 
Instances of this class always locate files relative to the image directory, unless the file is outside the local directory hierarchy below the image directory, in which case an absolute path is used.

Note that the ''image'' directory may dynamically change between image restarts, and in the case of a deployed application the ''image'' directory is the folder in which the executable resides.

Try the following examples:

relativePath := FileLocator imageRelative relativePathTo: SessionManager current imageFileName. "Display It - should be ''.\dolphin.img''"
FileLocator imageRelative localFileSpecFor: relativePath. "Display It - should be the full image path"'!
!ImageRelativeFileLocator class methodsFor!

current
	"Answer the singleton instance of the receiver"

	Current isNil ifTrue: [ Current := self new ].
	^Current!

onPreStripImage
	"Private -  Assist in the image stripping process by clearning down any
	lazily initialized variables held by the receiver."

	self uninitialize!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self current.
	anSTBInFiler register: singleton.
	^singleton!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Current := nil! !

!ImageRelativeFileLocator methodsFor!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self! !

InstallRelativeFileLocator comment:
'An ImageRelativeFileLocator is used to indicate the location of an external file that may be referenced within the image. 
Instances of this class always locate files relative to the image directory, unless the file is outside the local directory hierarchy below the install directory, in which case an absolute path is used.
'!
!InstallRelativeFileLocator class methodsFor!

current
	"Answer the singleton instance of the receiver"

	Current isNil ifTrue: [ Current := self new ].
	^Current!

onPreStripImage
	"Private -  Assist in the image stripping process by clearning down any
	lazily initialized variables held by the receiver."

	self uninitialize!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self current.
	anSTBInFiler register: singleton.
	^singleton!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	Current := nil! !

!InstallRelativeFileLocator methodsFor!

basePath
	^SessionManager current installationDirectory!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self! !

PackageRelativeFileLocator comment:
'PackageRelativeFileLocator is a <RelativeFileLocator> that can be used to map between an absolute path and a path relative to a certain package''s directory. At runtime (i.e. in a deployed application from which packages have been stripped) PackageRelativeFileLocator''s behave in the same way as <ImageRelativeFileLocator>s.

Thanks to Chris Uppal for the original idea behind this class.'!
!PackageRelativeFileLocator class methodsFor!

package: aPackage 
	"Answer a new instance of the receiver for locating files relative to the folder containing
	the specified <Package>. Should the package be unloaded subsequently, then the instance will
	behave as if it were an ,ImageRelativeFileLocator>."

	^self packageNamed: aPackage name!

packageNamed: aString 
	"Answer a new instance of the receiver for locating files relative to the folder containing
	the named package. If the package is not loaded, then the instance will behave as if it were
	an <ImageRelativeFileLocator>."

	^(super new)
		setPackageName: aString;
		yourself! !

!PackageRelativeFileLocator methodsFor!

basePath
	^self package ifNil: [super basePath] ifNotNil: [:pkg | pkg path]!

package
	"Answer the <Package> who's folder is used as the base path, or nil if the package is not loaded."

	^Smalltalk at: #Package ifPresent: [:class | class manager packageNamed: packageName ifNone: []]!

packageName
	"Answer the <readableString> name of the Package who's folder is used as the base path."

	^packageName!

setPackageName: aString 
	packageName := aString! !

MessageSendCollector comment:
'MessageSendCollector is an <InstructionInterpreter> that evaluates user supplied blocks against all the message send instructions it is dispatched. It is typically used to collect all the message sends in a method, hence the name.

Instance Variables:
	messageBlock			<monadicValuable>
	superMessageBlock		<monadicValuable>

'!
!MessageSendCollector methodsFor!

dispatchNext
	dispatcher dispatchNext!

initialize
	superMessageBlock := messageBlock := [:selector | ]!

messagesDo: aBlockClosure 
	superMessageBlock := messageBlock := aBlockClosure.
	self interpret!

sendSelector: aSymbol args: anObject 
	messageBlock value: aSymbol!

sendSelfSelector: aSymbol args: anObject 
	messageBlock value: aSymbol!

shortSpecialSend: offset 
	"Interpret a Short Special Send instruction."

	"Implementation Note: This override is not strictly needed, but since we don't need the argument count 
	we can avoid the cost of asking a selector for its argument count."

	| selector |
	selector := dispatcher selectorOfSpecialSend: offset.
	self sendSelector: selector args: -1!

superMessagesDo: aBlockClosure 
	superMessageBlock := aBlockClosure.
	self interpret!

supersendSelector: aSymbol 
	superMessageBlock value: aSymbol! !

Process comment:
'A Process represents an individual thread of execution in the image.

Note that the name "Process" is historic - a Smalltalk Process is much more similar to a "thread" than a true process, since all Processes share the same execution context (the image). Dolphin''s processes do not map directly onto native threads, but are "green" threads. The multi-threading system is implemented internally by the VM and image, with all "green" threads running within a single Win32 thread. This means that a call to a long running (or blocking) external API call will block the entire system, so a facility is provided to "overlap" such calls. This is done by marking the external method with the "overlap" annotation, in which case the VM will perform the call on a separate native thread. For the duration of the overlapped operation the calling Process is blocked, but other Processes in the image will continue to run. 

A Process can in any of the following states:
	- active		The Process is actually running. Usually you will only be able to catch the main UI process in this state.
	- debug		The Process is currently being debugged.
	- ready		The Process is ready to run, but currently suspended on one of the Processors priority queues.
	- suspended	The Process has been suspended (see #suspend), and will not run again until sent #resume.
				Note that a suspended process with no active references will be garbage collected.
	- waiting	The Process is waiting on a <Semaphore>, i.e. it has sent #wait to a Semaphore with no excess signals.
				A Process remains waiting on a Semaphore until it reaches the front of that Semaphores queue of
				waiting Processes and the Semaphore is sent a #signal message.
	- dead		The Process has been terminated, or has run to completion.

A Process in any state other than #dead is considered alertable, and may be sent an interrupt by the VM at any time. See<ProcessorScheduler> for more details.

In general it is not a good idea to manipulate the contents of a live process directly (e.g. in an Inspector). For performance reasons the VM tends to assume that a Process'' state is consistent, and it does not perform much error checking. Hence it is quite easy to crash the system by modification of instance variables and the stack. It is quite safe to view the contents, but if a live Process is inspected you may find that the snapshot is invalidated by the stack growing and shrinking to meet requirements, which could cause errors in the inspector when trying to access non-existant stack slots.

Instance Variables:
	suspendedFrame 		<Integer> address of suspendedFrame when in states ready, waiting, or suspended, otherwise nil.
	priority 					<Integer> priority level (see ProcessorScheduler).
	myList 					<LinkedList> on which the process is currently queued if in states ready or waiting, otherwise nil.
	callbackDepth 			<Integer> number of callbacks which have not yet been returned from (i.e. nested depth).
	primitiveFailureCode		<Integer> code reported by last primitive failure.
	primitiveFailureData 		<Object> argument supplied by last primitive failure. Value depends on primitive and failure reason.
	fpeMask 				<Integer> floating point exception mask specifying which FP exceptions to mask. See Intel/CRT docs.
	tls 						Reserved for future use.
	thread 					Pointer to overlapped call control block. For VM use only.
	exceptionEnvironment	List of active exception frames <ExceptionHandler> in LIFO order.
	_alreadyPrinted			<IdentitySet> of objects which have already printed in a recursive #printOn:
	errno					<integer>. C runtime library error code recorded after last overlapped external call
	debugger 				<debugEventHandler> associated with the Process, if any. Used as a destination for debug events.
	name 					The <Object> ''name'' of the process. Usually a <String> or <CompiledMethod>.
	lastError 				<integer>. Win32 GetLastError() code recorded after last overlapped external call.

Class Variables:
	DefaultFPEMask			<Integer> default floating point exception mask used to initialize fpeMask instance variable.
	DefaultMaxStack 		<Integer> maximum stack depth (size up to which a Process may grow - virtual memory reserved).
	DefaultStack				<Integer> initial stack depth (initial virtual memory committed).'!
!Process class methodsFor!

forContext: aBlockClosure priority: anInteger 
	"Private - Answer a suspended instance of the receiver that will execute the block,
	aBlockClosure, at the priority, anInteger.
	N.B. There are certain requirements which must be met by the launch block, aBlockClosure,
	if the new process is to die quietly without causing a GPF:
		1) It must be a zero argument BlockClosure (not just any old niladic valuable)
		2) It must have a null home stack frame (i.e. its home context is marked as having
		already returned).
		3) It must catch ProcessTermination notifications, and proceed through to its 
		shutdown code (e.g. [...] on: ProcessTermination do: [:pt | pt return]).
		4) It must send #shutdown to the active process so that it is properly terminated.
		5) It must perform a ^-return as its last action.
	Items (2) and (5) ensure that any attempt to drop off the bottom of the process stack
	is trapped by the VM and results in a 'Context Expiry' walkback rather than an
	unrecoverable GPF."

	^self new
		launchBlock: aBlockClosure;
		priority: anInteger;
		yourself.!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Initialize the class variables of the receiver:
		DefaultStack		-	The initial stack size of new Processes. This should be relatively
							small so as not to waste space, and to reduce instantiation overhead,
							but not so small that it causes a stack fault and growth. A default
							value which corresponds to less than one OS page (normally 4k bytes, 
							or 1024 object pointers) will be rounded up to one OS page. The
							actual stack size will be slightly less than the number of pointers
							which fit on one OS page, because the VM adjusts it to account for 
							Process' fixed instance variables, and overhead.
		DefaultMaxStack	-	The maximum size to which the stack of new Processes can grow before
							the VM signals a stack overflow. Processes grow by a page each time 
							a stack overflow occurs, from the initial size, up to this maximum.
							This value should be large enough to allow useful work to be done by 
							recursive methods, but not so large that programming errors go 
							undetected, It is unlikely that a stack need be large than 32768, 
							and for those instances, specific instantiation is recommended.

	Evaluate me to initialize:
		Process initialize
	"

	DefaultStack := 1.			"Let the VM work out the minimum size (will be an OS page)"
	DefaultMaxStack := (128*4*1024)/4. 	"Grow to 128K slots (512Kb) before overflow."

	"Floating point Inexact and Underflow exceptions will be masked (i.e. not raised) by default"
	DefaultFPEMask := _EM_INEXACT | _EM_UNDERFLOW.!

new
	"Private - Answer a new instance of the receiver. In order to create a runnable process,
	the suspendedFrame and priority must be set. The normal way to create a process
	is to use one of the #forkXX methods of BlockClosure."

	^(self new: DefaultStack max: DefaultMaxStack) initialize! !

!Process methodsFor!

_alreadyPrinted
	^_alreadyPrinted!

at: anInteger 
	"Answer the receiver's indexed instance variable at the argument index.
	As basicAt:, but may be reimplemented.

	Primitive Failure Reasons:
		0	- index is not a SmallInteger
		1	- index out of bounds (not in the range 1..receiver's indexable size)."

	<primitive: 49>
	^self errorAt: anInteger!

at: anInteger ifAbsent: exceptionBlock 
	"Answer an <Object> which is the element of the receiver 
	at the specified <SmallInteger> index. If the index is out of bounds 
	answer the result of evaluating the <niladicValuable> exceptionBlock."

	^(anInteger > 0 and: [anInteger <= self size]) 
		ifTrue: [self at: anInteger]
		ifFalse: [exceptionBlock value]!

at: anInteger put: anObject 
	"Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value.

	Primitive Failure Reasons:
		0	- index is not a <SmallInteger>
		1	- index is out of bounds (not in the range 1..receiver's indexable size)."

	<primitive: 176>
	^self errorAt: anInteger put: anObject!

basicAt: anInteger put: anObject 
	"Private - Replace the receivers indexed instance variable at the argument,
	index, with the argument, value. Answer value. 

	Primitive Failure Reasons:
		0	- index is not a SmallInteger
		1	- index out of bounds (not in the range 1..receiver's indexable size) 

	MUST not be reimplemented (except by classes whose instances have special representations
	such as SmallInteger)."

	<primitive: 176>
	^self errorAt: anInteger put: anObject!

basicSuspendedFrame
	"Private - Answer the SmallInteger pointer into the stack of the suspended frame. If nil then
	the process has terminated (or is not yet initialized)."

	^suspendedFrame!

callbackDepth
	"Private - Answer the depth of outstanding callbacks from the VM in the receivers stack.
	An example of a callback is an entry from the Smalltalk window procedure to
	View>>dispatchMessage:. Recursive callbacks (callbacks which occur during the
	processing of another callback, e.g. sending a Win32 message in the handler for
	another Win32 message) will increase the callback depth to a figure greater than one.
	The Main (user interface) process will always have a callback depth >= 1 when
	examined.

	Whether a Process' stack contains callbacks affects the way it must be unwound
	on termination, or when handling an exception, since the callbacks from the 
	VM must themselves be properly unwound, not just the Smalltalk stack."

	^callbackDepth!

canDebug
	"Answer whether the receiver can be debugged (this requires that a debugger
	be available)."

	^self respondsTo: #debuggerClass!

debugger
	"Private - Answer the object which is currently claiming to be the 'debugger' on this
	process. This object will receiver debug events as and when they occur in the receiver
	(it need not be an actual <Debugger>). The answer will be nil if there is no debugger."

	^debugger!

debugger: anObject
	"Private - anObject is claiming to be the debugger for the receiver, so save it so
	that it can later be sent debug events which occur in the receiver. Any 
	existing debugger is disconnected."

	debugger := anObject!

errno
	"Answer the value of the C runtime 'errno' global variable saved on completion of the last
	overlapped call made from the receiver."

	^CRTLibrary default thread_errno asExternalAddress sdwordAtOffset: 0!

exceptionEnvironment
	"Private - Answer the receiver's exception environment (a LIFO stack of ExceptionHandlers).
	A linked list of ExceptionHandlers is maintained to expedite the search for handlers 
	when an exception occurs."

	^exceptionEnvironment!

exceptionEnvironment: anExceptionHandler
	"Private - Set the receiver's exception environment to be the argument,
	anExceptionHandler. N.B. Use with care, the previous exception environment
	should be linked to the new exception environment."

	exceptionEnvironment := anExceptionHandler!

finalize
	"Private - Ensure the receiver is properly terminated.
	This method should only be invoked if the process dies because there
	are no outstanding references to it. If normally terminated, then
	it will not be finalized."

	self terminate!

fpeMask
	"Answer the current floating point exception mask for the receiver.
	This mask is set whenever the process is running (by the VM).
	Note that the mask determines which exceptions are masked out, rather
	than generated."

	^fpeMask!

fpeMask: anInteger
	"Set the current floating point exception mask for the receiver.
	Answer the old mask (not the receiver as is normal for a set method).
	If the receiver is the current active process, then the current
	FP exception mask is established. The mask is recorded for future
	switching by the VM on context switches.
	Note that the mask determines which exceptions are masked out, rather
	than generated."

	| oldMask |
	oldMask := fpeMask.
	fpeMask := anInteger.
	self isActive ifTrue: [Float reset].
	^oldMask!

frameAtAddress: spInteger
	"Private - Answer a frame representing the real stack frame at the specified SP (a
	SmallInteger address/2 in the receiver), or nil if the address is not within this process."

	^self frameAtIndex: (self indexOfSP: spInteger)!

frameAtIndex: anInteger
	"Private - Answer a StackFrame represent a real frame in the receiver at the specified index,
	or nil if the index is out of bounds."

	^self frameClass process: self index: anInteger!

frameClass
	"Private - Answer the class of object to use to represent the receiver's activation records"

	^StackFrame!

id
	"Answer an id which is unique for the lifetime of the process within
	this particular session. Should the process be terminated in the session
	then the id may be re-used, i.e. this is really only useful to help with debugging."

	^self yourAddress bitShift: -16!

indexOfSP: anInteger
	"Private - Answer the index into the receiver of the VM stack pointer value, anInteger
	(which is a pointer, bitshifted right one position, although this is an implementation
	detail which may be changed)."

	<primitive: 175>
	^((anInteger bitShift: -1) - (self yourAddress bitShift: -2)) - self class instSize + 1!

initialize
	"Private - Initialize the instance variables of the receiver to default values.
	Certain properties are inherited from the forking process (e.g. floating point
	exception mask). Also mark the receiver as finalizable so that the stack can be 
	correctly unwound if the receiver is not explicitly terminated.
	Answer the receiver."

	_alreadyPrinted := IdentitySet new.
	callbackDepth := priority := 0.
	(fpeMask := Processor activeProcess fpeMask) isNil ifTrue: [fpeMask := DefaultFPEMask].
	self beFinalizable!

interruptWith: aBlock
	"Private - Interrupt the receiver with the specified block. The block is evaluated regardless of
	the receiver's current state (unless dead). On completion of the block, the receiver resumes whatever
	it was doing before, including waiting on a Semaphore, etc."

	"Implementation Note: aBlock is evaluated with asynchronous process switching disabled!!"

	^self queueInterrupt: Processor genericInterrupt with: aBlock!

isActive
	"Answer whether the receiver is the current active process."

	^Processor activeProcess == self
	
	!

isAlive
	"Answer whether the receiver is either ready, waiting, or active."

	^self isActive or: [self suspendingList notNil]	!

isAlive: aSemaphore 
	"Private - Answer whether the receiver is either ready, waiting on the specified 
	Semaphore, or active."

	| state |
	state := self state.
	^state == #ready 
		or: [state == #running or: [state == #waiting and: [self suspendingList == aSemaphore]]]!

isDead
	^suspendedFrame isNil!

isDebuggee
	"Private - Answer whether the receiver is currently being debugged."

	^debugger notNil!

isInCallback
	"Private - Answer whether the receiver is processing a callback from the VM.

	Whether a Process' stack contains callbacks affects the way it must be unwound
	on termination, or when handling an exception, since the callbacks from the 
	VM must themselves be properly unwound (and in the same order in which they
	were made), not just the Smalltalk stack."

	^self callbackDepth > 0!

isMain
	"Answer whether the receiver is the main user I/F process (i.e. it
	manages the input queue)."

	^SessionManager inputState main == self	
	!

isReady
	"Answer whether the receiver is Ready to run but inactive"

	^self state == #ready	!

isSuspended
	"Answer whether the receiver is Suspended/Terminated."

	^self state == #suspended
	
	!

isTerminated
	"Answer whether the receiver has Terminated."

	^self state == #dead
	
	!

isWaiting
	"Answer whether the receiver is waiting on a Semaphore."

	^self state == #waiting	!

kill
	"Terminate the receiver with extreme prejudice. Any outstanding unwind blocks
	will not be run. It is necessary, however, to correctly maintain the VM's callback stack,
	so all outstanding callbacks are unwound. Finally, the receiver is put to sleep, permanently.
	N.B. This should not be sent to a process which is not the active process if it has callbacks."

	self isDead ifTrue: [^self].
	self isActive 
		ifTrue: [self shutdown]
		ifFalse: 
			["As the receiver is not active, we queue an interrupt which will
				cause the VM to activate the receiver (even if Waiting or Suspended)."

			self queueInterrupt: Processor killInterrupt]!

lastError
	"Answer the value of the Win32 error code (i.e. the result of GetLastError()) run in the
	context of the overlapped external call thread associated with the receiver."

	^KernelLibrary default threadGetLastError!

launchBlock: aBlockClosure 
	"Private - Install aBlockClosure as the launch frame of the receiver (which must be
	a new process). The VM needs a correctly established frame in order to start running
	a process."

	| baseFrame |
	self at: 1 put: aBlockClosure receiver.
	"Note that we must allow space for the block's stack temps"
	baseFrame := self frameClass new setProcess: self index: (2 + aBlockClosure localCount).
	baseFrame
		basicSender: 0;
		basicIP: aBlockClosure initialIP + MemoryManager current objectHeaderSize - 1;
		sp: baseFrame frameSize+1;
		method: aBlockClosure method;
		environment: aBlockClosure.
	baseFrame bp: 2.
	self suspendedFrame: baseFrame!

name
	"Answer the 'name' of the Process. This is usually defined by the creator of the process.
	The default name is the home method (which allows access to the source of the forking block, 
	even for immediate expressions). The name need not be a String (all Objects respond to #displayString)"

	^name!

name: anObject
	"Set the name of the Process to the argument, anObject (see #name)"

	name := anObject!

primitiveFailureCode
	"Private - Answer the SmallInteger failure code set by the last primitive which failed 
	when executed by the receiver. This should be retrieved as soon as possible following a 
	failure so that it is not overwritten by a subsequent failure - remember that not all
	primitive failures are errors, and they are a faily common occurrence in SmallInteger arithmetic.
	Some primitives may not set a failure code when they fail.
	Currently each primitive defines its own failure codes (documented in the primitive call method), 
	and additional information of any type may also be present in 'primitiveFailureData'.
	The failure code/data are not normally affected by primitives which succeed."

	^primitiveFailureCode!

primitiveFailureData
	"Private - Answer the extra failure data set by the last primitive which failed (and
	which had extra information to supply about the failure over and above the failure code).
	See #primitiveFailureCode for additional information."

	^primitiveFailureData!

primTerminate
	"Private - Transition the receiver from its current state to the Terminated state. Once
	Terminated, a Process cannot (easily) be resumed or restarted.

	Primitive Failure Reasons:

	0 - Not used
	1 - The receiver is the last running process, so it cannot be terminated until another
	process has been started (an Idle Panic interrupt will also be generated). Assuming correct
	recovery after the idle panic, a second attempt at termination should succeed."

	"Implementation Note: This primitive is approximately equivalent to:

		self suspendUnconditionally. 
		suspendedFrame := nil

	except that the primitive can correctly terminate any process, even the active process. The
	active process cannot terminate itself correctly in this way in Smalltalk without the
	assistance of another process, because as soon as it suspends itself, it will obviously stop
	running, and so will be unable to nil out its suspended context. It is considered that the
	use of a simple primitive to terminate processes is both less error prone, and consumes less
	resources, than the alternative of dedicating another process to this task."

	<primitive: 91>
	^Processor activeProcess primitiveFailureCode == 1 
		ifTrue: [false	"Please try again"]
		ifFalse: [self primitiveFailed]!

printOn: aStream
	"Append a short debug description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: self name;
		nextPutAll: ', id: ';
		print: self id;
		nextPutAll: ', priority: ';
		print: self priority;
		nextPutAll: ', state: ';
		print: self state;
		nextPut: $)!

priority
	"Answer the receiver's priority (see ProcessorScheduler)"

	^priority
!

priority: anInteger 
	"Set the receiver's priority to anInteger and Answer the previous priority. Note that 
	if the receiver is the currently active process, the new priority is lower, and there 
	are higher-priority processes ready to run, the active process will be preempted.
	If the receiver is not the active process, and its priority is increased above that of
	the active process, then the active process will be preempted.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		1 -	anInteger is not in the range of permissible priorities (1..highest priority)."

	<primitive: 92>
	^((anInteger isMemberOf: SmallInteger) 
		and: [anInteger between: 1 and: Processor highestPriority]) 
			ifTrue: [self primitiveFailed]
			ifFalse: [self error: 'Invalid Process priority ' , priority printString]!

queueInterrupt: anInteger
	"Queue an interrupt with the specified number for the receiver (which can be in any resumable state)
	and a nil argument."

	^self queueInterrupt: anInteger with: nil!

queueInterrupt: anInteger with: anObject
	"Queue an interrupt with the specified number for the receiver (which can be in any resumable state).
	The argument is passed to the interrupted process and can be of any type as necessary.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger.
		1 -	the receiver is dead (i.e. not runnable)."

	<primitive: 98>
	^self primitiveFailed!

resume
	"Change the state of the receiver from Suspended to Ready (by placing
	it at the end of the Processor's queue for the receiver's priority).
	Fail if the receiver is already waiting in a queue (in a Semaphore 
	or the Processor). See #resume: for further details (sending this message
	is equivalent to sending #resume: with nil as the argument)."

	<primitive: 87>
	^self primitiveFailed!

resume: suspendingListOrNil
	"Change the state of the receiver from Suspended to Ready/Waiting 
	by placing it at the end of the Processor's queue for the receiver's priority
	if suspendingListOrNil is nil, otherwise returning it to the queue associated
	with suspendingListOrNil. Fail if the receiver is already waiting in a queue 
	(in a Semaphore or the Processor) - i.e. it is only appropriate to send this message to
	previously #suspend'd Processes, it is not the means by which to start
	currently Waiting or Ready processes (which have to wait either for the Semaphore
	on which they are Waiting to be signalled, or their turn to run after
	higher priority processes, and in a round robin fashion with respect to
	Processes of the same priority if they are Ready to run).

	Primitive failure reasons:
		0 -	the receiver is not suspended on a scheduler or semaphore list.
		1 - 	the receiver has been terminated (or not properly initialized)."

	<primitive: 87>
	^self primitiveFailed!

resumeUnconditionally
	"Change the state of the receiver to Ready to run regardless of its current
	state (unless terminated)."

	<primitive: 87>
	myList isNil ifTrue: [^self primitiveFailed]!

setPriority: anInteger 
	priority := anInteger!

shutdown
	"Private - Terminate the receiver with extreme prejudice. Any outstanding unwind blocks
	will not be run. It is necessary, however, to correctly maintain the VM's callback stack,
	so all outstanding callbacks ARE unwound. Finally, the receiver is put to sleep, permanently.
	N.B. This should not be sent to a process which is not the active process if it has callbacks.
	Sending this method directly is not recommended (send either #kill or #terminate instead)."

	"Inform any debugger so that it can close.
	You will not be able to debug past this point."
	debugger notNil ifTrue: [debugger perform: #onTerminate].

	"Unwind any outstanding callbacks."
	Processor unwindCallbacks.
	self beUnfinalizable.
	[self primTerminate == true] whileFalse!

size
	"Answer the number of indexed variables in the receiver (0 for non-indexable objects,
	as the named instance variables are not included)."

	"Implementation Note: Access thisContext to get the process size saved down as the
	processes dynamically change size to accomodate their stack. Normally the process
	size is only recorded from the SP on process switches, when thisContext is accessed,
	on GC's, on invocations of the #allReferences primitive, and on image save."

	Processor activeProcess == self ifTrue: [thisContext].
	^super size!

spOfIndex: anInteger
	"Private - Answer a VM stack pointer value (SmallInteger) for the specified index of the
	receiver."

	^(self yourAddress bitShift: -1) + ((anInteger + self class instSize - 1) * 2)!

stackFramesFrom: startFrame depth: anInteger 
	"Private - Answer a <sequencedReadableCollection> containing up to the first anInteger stack 
	frames below the <StackFrame>, startFrame, in the receiver's stack (inclusive)."

	| answer |
	answer := OrderedCollection new: (anInteger min: 50).
	self 
		stackFramesFrom: startFrame
		depth: anInteger
		do: [:frame | answer addLast: frame].
	^answer!

stackFramesFrom: aStackFrame depth: depth do: operation 
	"Private - Evaluate the <monadicValuable> operation for each of the receiver's stack frames
	up to a depth of <integer> depth (inclusive, maximum), below aStackFrame."

	| frame i |
	frame := aStackFrame.
	i := 0.
	[i < depth and: [frame notNil and: [frame method selector notNil]]] whileTrue: 
			[operation value: frame.
			frame := frame sender.
			i := i + 1]!

stackTrace: anInteger
	"Private - Answer a <readableString> containing a stack trace to the depth specified by the <integer>
	argument."

	^self stackTraceFrom: self topFrame depth: anInteger!

stackTraceFrom: aStackFrame depth: anInteger 
	"Private - Answer a <readableString> containing a stack trace up to the <integer> depth, anInteger,
	or 50 frames, whichever is the smaller."

	| stackStream |
	stackStream := String writeStream: 25 * (anInteger min: 50).
	
	[(self stackFramesFrom: aStackFrame depth: anInteger) 
		do: [:frame | frame displayOn: stackStream]
		separatedBy: [stackStream cr]] 
			on: Error
			do: [:e | e notify].
	^stackStream contents!

state
	"Private - Answer a symbol identifying the receiver's state."

	^self isActive 
		ifTrue: [#running]
		ifFalse: 
			["The state may change, so minimize chance of getting
			it wrong by storing suspendingList in a temporary"

			| list |
			list := self suspendingList.
			list isNil 
				ifTrue: 
					[self isDebuggee 
						ifTrue: [#debug]
						ifFalse: [self basicSuspendedFrame isNil ifTrue: [#dead] ifFalse: [#suspended]]]
				ifFalse: [(list isKindOf: Semaphore) ifTrue: [#waiting] ifFalse: [#ready]]]!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler. 
	Processes cannot be saved and restored correctly so output them as 
	nil by default"

	anSTBOutFiler saveObject: self as: nil.!

suspend
	"Transition the receiver from Running (if active), Waiting (if waiting on a Semaphore) 
	or Ready (if waiting to be scheduled by the Processor) states to the Suspended state 
	(i.e. not runnable). If the receiver is the activeProcess, suspend it and schedule another, 
	otherwise remove the receiver from the list of Ready processes in the Processor, or the 
	list of Waiting processes in a Semaphore, and nil out its suspending list backpointer. 
	The receiver may be transitioned back to the Ready state at any time by sending it #resume 
	(but remember that resuming a Process that was waiting on a Semaphore when it was suspended 
	may upset process synchronisation because it will not return to the Semaphores waiting list).
	Report an error if the receiver is already Suspended (which is recognised by a null backpointer, 
	as this indicates that the process is not waiting in a list).

	Suspended processes have a 'nil' suspending list, are not the active process, and have
	a non-zero suspendedFrame address (which distinguishes them from terminated processes).
	If the process is the last runnable process, then answer false, otherwise answer the receiver 
	(when resumed).

	Primitive failure results:
		0 -	the process is already suspended.
		1 -	the process is the active process and could not be suspended because
			it is the only runnable process remaining."

	| failureCode |
	<primitive: 88>
	failureCode := Processor activeProcess primitiveFailureCode.
	^failureCode == 1 ifTrue: [false] ifFalse: [self primitiveFailed]!

suspendedFrame
	"Private - Answer a stack frame for the receiver's suspended context, nil if the receiver is dead."

	| frameAddress |
	frameAddress := self basicSuspendedFrame.
	^frameAddress isNil ifFalse: [self frameAtAddress: frameAddress]!

suspendedFrame: aStackFrameOrIndex
	"Private - Set the suspended frame index of the receiver."

	suspendedFrame := self spOfIndex: aStackFrameOrIndex asInteger!

suspendingList
	"Private - Answer the list (semaphore or Processor queue) on which the receiver has been 
	suspended. A Process which has been suspended, or which is currently active,
	will answer nil."

	^myList!

suspendUnconditionally
	"As #suspend, but fails silently attempts at suspending processes which are already Suspended.
	Answers the receiver.

	Primitive failure results:
		0 -	the process is already suspended.
		1 -	the process is the active process and could not be suspended because
			it is the only runnable process remaining.
		2-	the process is pending termination

	The first two failure codes are ignored. Any other failure code is unexpected, and will result in 
	normal failure handling."

	| failureCode |
	<primitive: 88>
	failureCode := Processor activeProcess primitiveFailureCode.
	^failureCode == 1 
		ifTrue: [false]
		ifFalse: [failureCode == 0 ifTrue: [self] ifFalse: [self primitiveFailed]]!

terminate
	"Transition the receiver from its current state to the Terminated state. Once Terminated, 
	a Process cannot be resumed or restarted.

	Implementation note: In order to ensure that all unwind blocks (see BlockClosure>>andFinally:
	and BlockClosure>>ifCurtailed:) are run, termination is achieved by raising a ProcessTermination 
	exception which is caught and handled by the launch block of the receiver (see 
	BlockClosure>>newProcess). The launch block handler for ProcessTermination #return:'s, dropping
	all later stack frames, and thus causing any unwind blocks to be executed. As its last action the launch
	block sends #shutdown message to the Process for final cleanup."

	self isDead ifTrue: [^self].
	self isActive 
		ifTrue: 
			[ProcessTermination signalWith: self.
			"Won't get this far unless the process hasn't completed its initialization,
			 and established a based handler block for the ProcessTermination signal."
			self shutdown]
		ifFalse: 
			["Exceptions can only be raised in active processes (and a process must be active
			 to terminate itself), so as the receiver is not active, we must queue an interrupt 
			 which will cause the VM to activate the receiver (even if Waiting or Suspended)."

			self queueInterrupt: Processor terminateInterrupt]!

topFrame
	"Private - Answer a frame representing the top activation record of the receiver's stack.
	We deliberately answer a frame for the sender if the receiver is the active
	process, as the current context will be invalidated immediately this method
	returns. Of course that frame will also be invalidated should the sender
	subsequently return too."

	^self isActive 
		ifTrue: [(self frameAtAddress: thisContext) sender]
		ifFalse: [self suspendedFrame]! !

ArithmeticValue comment:
''!
!ArithmeticValue class methodsFor!

one
	"Answer the receiver's representation of one."

	^self subclassResponsibility!

zero
	"Answer the receiver's representation of zero."

	^self subclassResponsibility! !

!ArithmeticValue methodsFor!

- operand
	"Answer the difference between the receiver and the <number>
	argument, operand."

	^self + operand negated!

% anArithmeticValue
	"Answer the remainder defined by division with truncation toward zero."

	^self rem: anArithmeticValue!

* operand
	"Answer the result of multiplying the receiver by the <number>
	argument, operand."

	^self subclassResponsibility!

** aNumber 
	"Answer the receiver raised to the power of the argument, aNumber."
	
	^self raisedTo: aNumber!

/ operand
	"Answer the result of dividing the receiver by <number> argument, 
	operand. Raise a <ZeroDivide> exception if the operand is zero."

	^self subclassResponsibility!

// operand
	"Answer the <integer> quotient defined by division with truncation toward negative infinity
	of the receiver by the <number> operand;
		e.g. 7 // 2 = 3, -7 // 2 = -4. 
	Raise a <ZeroDivide> exception if the operand is zero."

	^(self / operand) floor!

\\ operand
	"Answer the remainder defined by division of the receiver by the <number>, operand,
	with truncation toward negative infinity; e.g. 7 \\ 2 = 1, -7 \\ 2 = 1, 7 \\ -2 = -1. 
	This is the modulo operation, but it is not the same as C modulo (%) which truncates 
	towards zero (but see #rem:). 
	Raise a ZeroDivide exception if the operand is zero."

	^self - (self // operand * operand)!

_expandRectangle: rect
	"Private - Expand the <Rectangle>, rect, by the magnitude of the receiver.
	 All sides of the rectangle are expanded by the specified amount.
	Double-dispatched from the Rectangle itself."

	^rect species
		origin: (rect origin - self)
		corner: (rect corner + self)!

_insetRectangle: aRectangle 
	"Private - Inset the <Rectangle> argument by the magnitude of the receiver. All sides of the
	rectangle are inset by the specified amount. Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + self corner: aRectangle corner - self!

_offsetRectangle: aRectangle 
	"Private - Offset the <Rectangle> argument by the magnitude of the receiver.
	Double-dispatched from the Rectangle itself."

	^aRectangle species origin: aRectangle origin + self corner: aRectangle corner + self!

+ operand
	"Answer the sum of the receiver and the <number> argument, 
	operand."

	^self subclassResponsibility!

= comparand
	"Answer whether the receiver is numerically equivalent to the <Object>, 
	comparand - i.e. whether the difference between the receiver and comparand
	is zero.
	Implementation Note: #isZero is used to test the difference instead of the 
	infinitely recursive '= 0'"

	^comparand understandsArithmetic 
		and: [(self - comparand) isZero]!

abs
	"Answer a <number> that is the absolute value (positive magnitude) of the receiver."

	^self negative
		ifTrue: [self negated] 
		ifFalse: [self]!

addToFloat: aFloat
	"Private - Answer the result of adding the receiver to the known Float, aFloat, by coercing 
	the less general of it and the receiver. Overridden by subclasses which can implement 
	more efficiently."

	^aFloat retry: #+ coercing: self
!

addToFraction: aFraction
	"Private - Answer the result of adding the receiver to the known fraction, aFraction,
	by coercing the less general of it and the receiver. Overridden by subclasses 
	which can implement more efficiently."

	^aFraction retry: #+ coercing: self!

addToInteger: anInteger
	"Private - Answer the result of adding the receiver to the known integer, anInteger, by	
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^anInteger retry: #+ coercing: self!

addToPoint: aPoint
	"Private - Answer the result of adding the receiver to the known Point, aPoint, by coercing 
	the less general of it and the receiver. Overridden by subclasses which can implement 
	more efficiently."

	^aPoint retry: #+ coercing: self
!

addToPoint3D: aPoint3D
	"Private - Answer the result of adding the receiver to the known Point3D, aPoint3D, by coercing 
	the less general of it and the receiver. Overridden by subclasses which can implement 
	more efficiently."

	^aPoint3D retry: #+ coercing: self
!

addToScaledDecimal: operand
	"Private - Answer the result of adding the receiver to the known <ScaledDecimal>, operand."

	^operand retry: #+ coercing: self!

ceiling
	"Answer the integer nearest the receiver toward positive infinity."

	^self subclassResponsibility!

coerce: anArithmeticValue
	"Private - Coerce anArithmeticValue (which must be of a lower generality than the receiver) to be the 
	same type as a anArithmeticValue."

	^self subclassResponsibility!

divideIntoFloat: aFloat
	"Private - Answer the result of dividing the receiver into the known Float, aFloat, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^aFloat retry: #/ coercing: self!

divideIntoFraction: aFraction
	"Private - Answer the result of dividing the receiver into the known fraction, aFraction,
	by coercing the less general of it and the receiver. Overridden by subclasses 
	which can implement more efficiently."

	^aFraction retry: #/ coercing: self!

divideIntoInteger: anInteger
	"Private - Answer the result of dividing the receiver into the known integer, anInteger, 
	by coercing the less general of it and the receiver. Overridden by subclasses 
	which can implement more efficiently."

	^anInteger retry: #/ coercing: self!

divideIntoPoint: aPoint
	"Private - Answer the result of dividing the receiver into the known Point, aPoint, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^aPoint retry: #/ coercing: self!

divideIntoPoint3D: aPoint3D
	"Private - Answer the result of dividing the receiver into the known Point3D, aPoint3D, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^aPoint3D retry: #/ coercing: self!

divideIntoScaledDecimal: operand
	"Private - Answer the result of dividing the known <ScaledDecimal>, operand, by the receiver."

	^operand retry: #/ coercing: self!

floor
	"Answer the integer nearest the receiver toward negative infinity."

	^self subclassResponsibility!

generality
	"Private - Answer the Smalltalk generality of the receiver, used for performing type conversions"

	^self subclassResponsibility!

greaterThanFloat: aFloat
	"Private - Answer whether the receiver is greater than the known Float, aFloat, by coercing 
	the less general of it and the receiver. Overridden by subclasses which can implement 
	more efficiently."

	^aFloat retry: #< coercing: self!

greaterThanFraction: aFraction
	"Private - Answer whether the receiver is greater than the known Fraction, aFraction, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^aFraction retry: #< coercing: self!

greaterThanInteger: anInteger
	"Private - Answer whether the receiver is greater than the known integer, anInteger, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^anInteger retry: #< coercing: self!

greaterThanScaledDecimal: operand
	"Private - Answer whether the receiver is greater than the known <ScaledDecimal>, operand."

	^operand retry: #< coercing: self!

isZero
	"Answer whether the receiver is zero. Many subclasses cannot be zero, since
	there is a more compact representation for zero in SmallInteger (e.g. 
	Fraction and LargeIntegers)"

	^self = self class zero!

multiplyByFloat: aFloat
	"Private - Answer the result of multiplying the known Float, aFloat,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^aFloat retry: #* coercing: self!

multiplyByFraction: aFraction
	"Private - Answer the result of multiplying the known fraction, aFraction,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^aFraction retry: #* coercing: self!

multiplyByInteger: anInteger
	"Private - Answer the result of multiplying the known integer, anInteger,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^anInteger retry: #* coercing: self!

multiplyByPoint: aPoint
	"Private - Answer the result of multiplying the known Point, aPoint,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^aPoint retry: #* coercing: self!

multiplyByPoint3D: aPoint3D
	"Private - Answer the result of multiplying the known Point3D, aPoint3D,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^aPoint3D retry: #* coercing: self!

multiplyByScaledDecimal: operand
	"Private - Answer the result of multiplying the known <ScaledDecimal>, operand, by receiver."

	^operand retry: #* coercing: self!

negated
	"Answer a <number> of the same type of the receiver
	which is its negation."

	^self class zero - self!

negative
	"Answer whether the receiver is negative."

	^self < self class zero!

positive
	"Answer whether the receiver is positive or zero."

	^self negative not!

quo: operand
	"Answer the <number> quotient resulting from by division of the receiver
	by the argument, operand, with truncation toward zero.
	(i.e. 'C' like integer division);  e.g. 6 quo: 2 = 3, 7 quo: 2 = 3, -7 quo: 2 = -3 
	(whereas -7 // 3 = -4).
	Signal a ZeroDivide exception if operand is zero."

	^(self / operand) truncated!

quoAndRem: aNumber
	"Private- Answer a two element array containing the integer quotient of 
	the receiver divided by aNumber with truncation toward zero (i.e. like C 
	integer division), and the corresponding remainder.
	As both quotient and remainder are typically calculated by a single division
	operation, if both are needed it is often more efficient to use this 
	method (assuming that the particular subclass implements it more efficiently!!)"

	^Array with: (self quo: aNumber) with: (self rem: aNumber)!

quoAndRemFromInteger: anInteger 
	"Private - Answer the quotient and remainder resulting from division of 
	the argument, anInteger, by the receiver, with truncation towards zero."

	| quo |
	quo := self quotientFromInteger: anInteger.
	^Array with: quo with: (anInteger - (quo * self))
	
!

quotientFromInteger: anInteger 
	"Private - Answer the quotient resulting from division of the argument, anInteger, by
	the receiver, with truncation towards zero."

	^(anInteger / self) truncated!

raisedTo: operand
	"Answer an <ArithmeticValue> which is the receiver raised to the power of 
	the <number> argument, operand.
	Raise a FloatingPointException for overflow if the answer must be
	a <Float> and exceeds the representable range of a double precision
	floating point number."

	^self subclassResponsibility	!

raisedToInteger: operand
	"Answer the receiver raised to the <integer> power, operand."
 
	| i answer |
	operand == 0 ifTrue: [^self class one].
	operand == 1 ifTrue: [^self].
	operand isInteger
		ifFalse: [ ^self error: 'expected integer argument' ].
	operand negative ifTrue: [^(self raisedToInteger: operand negated) reciprocal].
	i := 2.
	[i < operand] whileTrue: [i := i + i].
	answer := self class one.
	[i > 0] whileTrue: [
		answer := answer * answer.
		(operand bitAnd: i) == 0 ifFalse: [answer := answer * self].
		i := i bitShift: -1].
	^answer!

reciprocal
	"Answer a <number> which is the reciprocal of the receiver (i.e. 1/receiver).
	Raise a <ZeroDivide> exception if the receiver is zero."

	^self class one / self!

rem: operand
	"Answer the <number> remainder resulting from division of the receiver by
	the <number>, operand, with truncation toward zero; 
		e.g. 7 rem: 2 = 1, -7 rem: 2 = -1 (whereas -7 \\ 2 = 1)"

	^self - ((self quo: operand) * operand)!

retry: aSymbol coercing: anArithmeticValue
	"Private - The binary selector, aSymbol, was attempted with a receiver and argument 
	of different type, and	could not be performed directly. This method requests
	the ArithmeticValue of higher generality to coerce (type convert) the ArithmeticValue 
	of lower generality to its generality, and then the message is retried. Equivalence, #=, 
	is special cased to answer false if the argument is not a number (since non-anArithmeticValue
	cannot be coerced). The method reports an error if both receiver and argument, 
	aNumber, have the same generality. "

	| selfGen argGen |
	selfGen := self generality.
	argGen := anArithmeticValue generality.
	selfGen > argGen
		ifTrue: [^self perform: aSymbol with: (self coerce: anArithmeticValue)].
	selfGen < argGen
		ifTrue: [^(anArithmeticValue coerce: self) perform: aSymbol with: anArithmeticValue].
	^self error: 'cannot coerce ArithmeticValues of same generality'!

roundDownTo: anArithmeticValue 
	"Answer the nearest multiple of the <ArithmeticValue> argument which
	is less than or equal to the receiver."

	^(self / anArithmeticValue) floor * anArithmeticValue!

rounded
	"Answer the <integer> nearest the receiver according to the following rule:
		N rounded = the nearest integer I = N + (N sign * (1/2)) truncated toward zero"

	^((self class zero + self sign)/2 + self) truncated!

roundTo: factor
	"Answer the multiple of the <number> argument, factor, that is nearest the receiver"

	^factor * (self / factor) rounded!

roundUpTo: anArithmeticValue 
	"Answer the nearest multiple of the <ArithmeticValue> argument which
	is greater than or equal to the receiver."

	^(self / anArithmeticValue) ceiling * anArithmeticValue!

sign
	"Answer the <integer> sign of the receiver:
		1 if the receiver is greater than 0, 
		-1 if less than 0
		0 if equal to 0."

	^self negative 
		ifTrue: [-1]
		ifFalse: [
			self isZero
				ifTrue: [0]
				ifFalse: [1]]!

squared
	"Answer a <number> that is the receiver multiplied by itself."

	^self * self!

strictlyPositive
	"Answer whether the receiver is greater than zero."

	^self > self class zero!

subtractFromFloat: aFloat
	"Private - Answer the result of subtracting the receiver from the known Float,
	aFloat, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^aFloat retry: #- coercing: self
!

subtractFromFraction: aFraction
	"Private - Answer the result of subtracting the receiver from the known fraction, aFraction,
	by coercing the less general of it and the receiver. Overridden by subclasses 
	which can implement more efficiently."

	^aFraction retry: #- coercing: self!

subtractFromInteger: anInteger
	"Private - Answer the result of subtracting the receiver from the known integer,
	 anInteger, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^anInteger retry: #- coercing: self!

subtractFromPoint: aPoint
	"Private - Answer the result of subtracting the receiver from the known Point,
	aPoint, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^aPoint retry: #- coercing: self
!

subtractFromPoint3D: aPoint3D
	"Private - Answer the result of subtracting the receiver from the known Point3D,
	aPoint3D, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^aPoint3D retry: #- coercing: self
!

subtractFromScaledDecimal: operand
	"Private - Answer the result of subtracting the receiver from the 
	known <ScaledDecimal>, operand."

	^operand retry: #- coercing: self!

truncated
	"Answer the <integer> nearest the receiver toward zero"

	^self quo: 1!

truncateTo: factor
	"Answer the next multiple of the <number> argument, factor, that is nearest the receiver 
	toward zero."

	^((self quo: factor) * factor)
!

understandsArithmetic
	"Answer whether the receiver understands basic arithmetic (+, -, etc). 
	All Numbers do."

	^true! !

Association comment:
'Association is a simple class to encapsulate the relationship between
a key and a value. It is used for the elements of Dictionaries.'!
!Association class methodsFor!

key: aKey value: aValue 
	"Answer a new instance of the receiver whose key is aKey and
	value is aValue."

	<primitive: 157>
	^self new key: aKey value: aValue! !

!Association methodsFor!

< anAssociation 
	"Answer whether the receiver is considered 'less than' the argument."

	^key < anAssociation key!

= anAssociation 
	"Answer whether the receiver is equal to the argument."

	^self species == anAssociation species 
		and: [key = anAssociation key
		and: [value = anAssociation value]]!

displayOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		display: key;
		nextPutAll: ' -> ';
		display: value!

hash
	"Answer the hash value of the receiver's key."

	^key hash
!

key
	"Answer the lookup key of the receiver."

	^key
!

key: aKey
	"Set the lookup key of the receiver."

	key := aKey
!

key: aKey value: aValue
	"Set the instance variables of the receiver to aKey->aValue"

	key := aKey.
	value := aValue
!

owningPackage: aPackage
	aPackage addGlobalNamed: self key!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream 
		print: key;
		nextPutAll: ' -> ';
		print: value!

value
	"Answer the 'value' of the receiver."

	^value!

value: aValue
	"Set the 'value' of the receiver. N.B. The meaning of #value: to an Association 
	is not the same as that defined by the ANSI monadic valuable protocol."

	value := aValue
! !

Character comment:
'Character is the class of objects which serve as the elemental values of Smalltalk Strings. There is a finite set of Characters (256 in the current Dolphin implementation). Characters have a literal syntax which is the $ symbol followed by the normal printed representation of the character.

Note that the ANSI standard does not require that Characters be identity objects, but they are in Dolphin.
'!
!Character class methodsFor!

backspace
	"Answer the backspace Character"

	^##(self value: 8)
!

basicNew
	"Characters are immediate objects, and cannot be instantiated directly, they
	can only be created by literal references, by operations on other Characters,
	or with the Character>>value: message."

	^self shouldNotImplement!

byteCharacterSet
	"Answer the first 256 characters"
	
	^CharacterSet!

codePoint: integer
	"Answer an instance of the receiver with the <integer> encoding, integer.

	Note that at present the encodings are limited to 0..255, but in a future
	release the Unicode character set will be supported, and the encoding
	range will then be 0..65535."

	^self value: integer!

cr
	"Answer the carriage return <Character>."

	^##(self value: 13)!

digitValue: anInteger
	"Answer the Character that corresponds to anInteger.  0-9 map to $0-$9,
	10-35 map to $A-$Z. If anInteger is not in the range
	0..35, then the String #at: will fail with a bounds error."

	^'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: anInteger+1!

eof
	"Answer the EOF (Ctrl+Z) character.
	DOS interprets this character as marking the end of a file."

	^##(self value: 26)!

esc
	"Answer the escape Character"

	^##(self value: 27)
!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	CharacterSet isImmutable: true.
	"Marking binding as constant causes compiler to inline refs"
	(self bindingFor: 'CharacterSet') isImmutable: true.
	self class recompileAll!

lf
	"Answer the linefeed <Character>."

	^##(self value: 10)!

new
	"Characters are immediate objects, and cannot be instantiated directly, they
	can only be created by literal references, by extraction from Strings, or
	from a code point."

	^self shouldNotImplement
!

newPage
	"Answer the new page Character."

	^##(self value: 12)
!

nl
	"Answer the new line <Character> (synonym for lf)"

	^self lf!

null
	"Answer the NULL-terminator character"

	^##(self value: 0)
!

space
	"Answer the space <Character>."

	^$ .!

tab
	"Answer the tab <Character>."

	^##(self value: 9)!

value: anInteger
	"Answer the character with ascii value, anInteger. If anInteger is not in the range 0..255, 
	then #at: primitive will fail"

	^CharacterSet at: anInteger + 1
! !

!Character methodsFor!

_beginsString: aString 
	^aString first == self!

_separateSubStringsIn: tokens
	"Private - Answer the sub-strings of the <readableString> argument
	 separated by the receiver.
	Implementation Note: Although this routine is rather more complex than
	it need be, the performance of #subStrings(:) is important, so it pays
	to optimize this routine. In particular we try to avoid performing any
	work in the common cases where the string is either empty, or does not
	contain the separator at all. However, we must be careful not to over 
	optimize and prevent correct operation for wide (Unicode) strings."

	| start answer size end |
	size := tokens size.
	size == 0 ifTrue: [^Array new].
	end := tokens nextIndexOf: self from: 1 to: size.
	end == 0 ifTrue: [^Array with: tokens].
	answer := Array writeStream: 5.
	start := 1.
	[
		answer nextPut: (tokens copyFrom: start to: end - 1).
		start := end + 1.
		end := tokens nextIndexOf: self from: start to: size.
		end == 0
	] whileFalse.
	"Copy any remaining chars after the last separator"
	start <= size ifTrue: [answer nextPut: (tokens copyFrom: start to: size)].
	^answer contents
!

< aCharacter
	"Answer whether the receiver is less than the parameter aCharacter."

	^self asInteger < aCharacter asInteger
!

= comperand
	"Answer whether the receiver is the sames as the parameter, comperand.
	There is a unique Character instance for each possible value, so equality
	between characters is the same as object identity in Dolphin.
	The object identity primitive should not fail."

	<primitive: 110>
	^self primitiveFailed!

> aCharacter
	"Answer whether the receiver is greater than the parameter aCharacter."

	^self asInteger > aCharacter asInteger
!

appendToStream: puttableStream
	"Private - Append the receiver's elements to the argument, puttableStream.
	Answer the receiver.
	Implementation note: Double dispatched from streams."

	puttableStream nextPut: self!

asciiValue
	"Answers the ascii character value of the receiver."

	"Retained for ST-80 compatibility only, as specific to ASCII char set, and will be obsolete when we go Unicode. 
	Use #codePoint instead."

	^asciiValue!

asInteger
	"Answer the receiver's character code as an Integer. 
	For standard 8-byte characters, this is the ASCII value"

	^asciiValue!

asLowercase
	"Answer a <Character> which is the lowercase equivalent of the receiver.
	If the receiver is already lowercase, then answer the receiver unchanged.
	Implementation Note: Apart from the ANSI asLowercase character mappings
	(basically all the uppercase letters are mapped to lowercase letters), this
	implementation will map other characters, depending on the configured
	locale of the host OS."

	^UserLibrary default charLower: self!

asString
	"Answer a new <String> whose sole element is the receiver."

	^String with: self
!

asSymbol
	"Answer the Symbol representation of the receiver."

	^Symbol internCharacter: self!

asUppercase
	"Answer a <Character> which is the uppercase equivalent of the receiver.
	If the receiver is already uppercase, then answer the receiver unchanged.
	Implementation Note: Apart from the ANSI asUppercase character mappings
	(basically all the lowercase letters are mapped to uppercase letters), this
	implementation will map other characters, depending on the configured
	locale of the host OS."

	^UserLibrary default charUpper: self!

basicShallowCopy
	"Answer the receiver, as Characters have a unique representation for
	each possible value."

	^self!

basicSize
	"Private - We must override the primitive implementation in Object,
	which does not expect to be invoked for immediate receivers."

	^0!

codePoint
	"Answers the receiver's <integer> encoding value."

	^self asInteger!

deepCopy
	"Answer the receiver, as Characters are immutable"

	^self!

digitValue
	"Answer the digit representation of the receiver.
	'digit' is defined as either 0-9, or uppercase A-Z (for 10-35).
	Note: In versions of Dolphin prior to 3.0 this raised an error if the character
	was not a valid digit character, but for compatibility with VW it now returns
	-1. The method is now optimized for improved performance too."

	^asciiValue > 127 
		ifTrue: [-1]
		ifFalse: [(#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] at: asciiValue+1) - 1]!

displayOn: aStream
	"Append the end-user display representation of the receiver to aStream."

	aStream nextPut: self!

hash
	"Answer the SmallInteger hash value for the receiver."

	^self asInteger!

identityHash
	"Answer the <integer> identity hash value for the receiver."

	^self asInteger!

isAlphaNumeric
	"Answer whether the receiver is a letter or a digit."

	^UserLibrary default isCharAlphaNumeric: self!

isControl
	"Answer whether the receiver is a control character."

	^CRTLibrary default iswcntrl: self!

isDigit
	"Answer whether the receiver is a representation of a decimal-digit character
	(i.e. it is one of $0 $1 $2 $3 $4 $5 $6 $7 $8 $9)."

	^self codePoint >= ##($0 codePoint) and: [self codePoint <= ##($9 codePoint)]!

isEnglishLetter
	"Answer whether the receiver is a letter from the English alphabet."

	^(self between: $a and: $z) or: [self between: $A and: $Z]!

isHexDigit
	"Answer whether the receiver is a valid Smalltalk hexadecimal digit (i.e. digits and the
	uppercase characters A through F)."

	^self isDigit or: [self codePoint >= ##($A codePoint) and: [self codePoint <= ##($F codePoint)]]!

isImmediate
	"Answer whether the receiver has an immediate representation."

	^true!

isLetter
	"Answer whether the receiver is an alphabetic character."

	^UserLibrary default isCharAlpha: self
!

isLinefeed
	"Answer whether the receiver is the line-feed character."

	^asciiValue = 10!

isLiteral
	"Private - Answer whether the receiver has a literal representation
	which is directly recognised by the Compiler."

	^true!

isLowercase
	"Answer whether the receiver is a lowercase letter."

	^UserLibrary default isCharLower: self
!

isLowerCase
	"Answer whether the receiver is a lowercase letter."

	^self isLowercase!

isPrintable
	"Answer whether the receiver is a printable character."

	^CRTLibrary default iswprint: self!

isPunctuation
	"Answer whether the receiver is a punctuation character."

	^CRTLibrary default iswpunct: self!

isSeparator
	"Answer whether the receiver is a separator character (i.e. whitespace)."

	^asciiValue == 32 or: [asciiValue >= 9 and: [asciiValue <= 13]]!

isUppercase
	"Answer whether the receiver is an uppercase letter."

	^UserLibrary default isCharUpper: self!

isUpperCase
	"Answer whether the receiver is an uppercase letter."

	^self isUppercase
!

isVowel
	"Answer whether the receiver is an English vowel (a, e, i, o, or u).
	This test is case insensitive."

	^'aAeEiIoOuU' includes: self!

isWhitespace
	"Answer whether the receiver is a white space character.
	This is a synonym for #isSeparator as currently defined."

	^self isSeparator!

printOn: aStream
	"Append the ASCII representation of the receiver to aStream as a 
	developer would want to see it."

	aStream nextPut: $$; nextPut: self!

shallowCopy
	"Answer the receiver, as Characters have a unique representation for
	each possible value."

	^self!

size
	"Private - We must override the primitive implementation in Object,
	which does not expect to be invoked for immediate receivers."

	^0!

species
	"Answer the 'species' of the receiver.
	Implementation Note: The primitive superclass implementation
	will fail for immediate classes, so we must override here."

	^Character! !

Date comment:
'Date is the class whose instances represent days of the year. The base date (day 0) is 1st January 1901.

Instance Variables:
	days				<integer>. Days since 1st Jan 1901

Class Variables:
	DefaultLongPicture	<boolean>. Controls whether or not the Date prints by default using the locale''s long or short representations.
	DaysUntilMonth		<Array>
	YearPivot			<integer>. Pivot year for 2 digit years. See #yearPivot
	DaysInMonth		<Array>

'!
!Date class methodsFor!

dateAndTimeNow 
	"Answer an Array whose first element is the current local Date and whose
	second element is the current local Time."

	^Time dateAndTimeNow!

dateOrderFromFormat: aFormatString
	"Private - Answers a String giving the component order in aFormatString (e.g. 'DMY' or 'MDY')"
	
	^aFormatString asUppercase copyWithoutDuplicates select: [:each | each isLetter]!

day: daysSinceBase inYear: anInteger
	"Private - Answer the julian day index of the argument, daysSinceBase, in the year, anInteger."

	"Day 0 is 1 Jan in base year, so we add 1"
	^daysSinceBase - (self yearAsDays: anInteger) + 1!

dayOfWeek: dayName
	"Answer the index in a week, 1, 2, 3, ..., 7, of the day named by the argument, dayName."

	^Locale default dayNames at: dayName asLowercase!

daysInMonth: monthName forYear: yearInteger
	"Answer the number of days in the month whose name is, monthName, in the year, yearInteger"

	^self daysInMonthIndex: (self indexOfMonth: monthName) forYear: yearInteger!

daysInMonthIndex: monthIndex forYear: yearInteger
	"Private - Answer the number of days in the month whose index is, monthIndex,
	in the year, yearInteger"

	| days |
	days := DaysInMonth at: monthIndex.
	monthIndex == 2 ifTrue: [ days := days + (self leapYear: yearInteger) ].
	^days
!

daysInYear: yearInteger
	"Answer the number of days in the year, yearInteger."

	^365 + (self leapYear: yearInteger)
!

daysUntilMonth: monthIndex inYear: yearInteger
	"Private - Answer the number of days in year, yearInteger, which elapse before the
	first day of the month whose index (1..12), is monthIndex."

	| days |
	days := DaysUntilMonth at: monthIndex.
	monthIndex > 2 ifTrue: [ days := days + (self leapYear: yearInteger) ].
	^days!

defaultLongFormat
	"Answer the default long date format."

	^Locale default longDateFormat!

defaultLongPicture: aBoolean
	"Private - Set whether the default printing for dates uses long or short pictures."

	DefaultLongPicture := aBoolean!

defaultShortFormat
	"Answer the default short date format."

	^Locale default dateFormat!

defaultYearPivot
	"Answer the default year pivot to use when converting date strings with 2 digit years."

	^30!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed
	because the some input was in the wrong format."

	^InvalidFormat signalWith: self!

fromDays: dayCount 
	"Answer a new instance of the receiver that is dayCount days from (before or after depending on 
	the sign of dayCount) January 1, 1901."

	<primitive: 157>
	^(self basicNew)
		setDays: dayCount;
		yourself!

fromSeconds: anInteger 
	"Answer a new instance of the receiver that incorporates the second which is anInteger
	seconds after the epoch."

	"Implementation Note: Ensure that SmallInteger arithmetic is used to perform the calculation
	when possible."

	^self fromDays: (anInteger bitShift: -7) // ##(60 * 60 * 24 bitShift: -7)!

fromString: aString
	"Answer an instance of the receiver constructed from the string,
	aString, using the default conversion format."

	| stream answer |
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer
!

fromString: aString format: aFormatStringOrNil
	"Answer an instance of the receiver constructed from the string,
	aString, using aFormatStringOrNil."

	^self readFrom: aString readStream format: aFormatStringOrNil!

fromSYSTEMTIME: aSYSTEMTIME
	"Private - Answer a new instance of the receiver instantiated from the argument, aSYSTEMTIME."
	
	^self newDay: aSYSTEMTIME wDay monthIndex: aSYSTEMTIME wMonth year: aSYSTEMTIME wYear!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

indexOfMonth: monthName
	"Answer the index in a year (1 .. 12) of the month named by the argument, 
	monthName, where monthName is the full locale specific name, or its abbreviated form,
	in upper or lower case."

	^Locale default monthNames at: monthName asLowercase!

initialize
	"Private - Initialize the class variables of the receiver

	Evaluate me to initialize:
		Date initialize
	"

	self defaultLongPicture: true.
	self yearPivot: self defaultYearPivot.

	"Days indices are for non-leap years"
	DaysInMonth := #(31 28 31 30 31 30 31 31 30 31 30 31).
	DaysUntilMonth := #(0 31 59 90 120 151 181 212 243 273 304 334 ).!

leapYear: yearInteger
	"Answer 1 if, yearInteger, is a leap year, otherwise answer 0. The Royal
	Observatory in Greenwich assure us that a year is a leap year if it is 
	divisible by 4, but not by 100, unless by 400, e.g: 1896 was a leap year, 
	but 1900 was not, but 2000 will be."

	^(yearInteger \\ 4 ~= 0 or: [yearInteger \\ 100 == 0 and: [yearInteger \\ 400 ~= 0]])
		ifTrue: [ 0 ]
		ifFalse: [ 1 ]!

longFormats
	"Answer a collection of the long date formats for the user locale.
	This list could be used, for example, to populate a drop-down."

	^Locale default longDateFormats!

monthIndexOfDay: dayInteger inYear: yearInteger 
	"Private - Answer the index of the month of the specified julian day number in the specified year."

	| leap |
	leap := self leapYear: yearInteger.
	1 to: 12
		do: 
			[:monthIndex | 
			| daysUntil |
			daysUntil := (DaysUntilMonth at: monthIndex) 
						+ (monthIndex > 2 ifTrue: [leap] ifFalse: [0]).
			daysUntil >= dayInteger ifTrue: [^monthIndex - 1]].
	^12!

nameOfDay: dayIndex
	"Answer a String that is the localised name of the day whose index is the argument, dayIndex, 
	where Monday is 1 and Sunday is 7."

	^Locale default nameOfDay: dayIndex abbrev: false!

nameOfMonth: monthIndex
	"Answer a localised String name for the month whose index is the argument, monthIndex, where 
	January is month 1, and December is month 12."

	^Locale default nameOfMonth: monthIndex abbrev: false!

new
	"Answer an instance of the receiver representing the current system date."

	^self today!

newDay: day month: monthName year: year
	"Answer a new instance of the receiver that is the <integer> day numbered, day, 
	of the <readableString> month named, monthName in the <integer> year, year."

	^self newDay: day monthIndex: (self indexOfMonth: monthName) year: year!

newDay: day monthIndex: month year: year
	"Answer a new instance of the receiver that is the <integer> day numbered, 
	day, of the <integer> month index (1..12), monthIndex in the year, 
	<integer> year, year."

	^self newDay: day + (self daysUntilMonth: month inYear: year) year: year!

newDay: day monthNumber: month year: year
	"For compatibility with VisualWorks..."

	^self newDay: day monthIndex: month year: year!

newDay: dayCount year: yearInteger
	"Answer a new instance of the receiver that is the day numbered, day, of the year, yearInteger"

	^self fromDays: dayCount + (self yearAsDays: yearInteger) - 1
!

readDayFrom: aStream 
	"Private - Answer a day index read from aStream"

	aStream peek isDigit 
		ifTrue: 
			[| day |
			day := Integer readFrom: aStream radix: 10.
			((1 to: 31) includes: day) ifTrue: [^day]].
	^self errorInvalidFormat!

readFrom: aStream
	"Answers an new instance of the receiver read from aStream with a format determined
	by the current locale"
	
	^self readFrom: aStream format: nil!

readFrom: aStream format: aFormatStringOrNil 
	"Answers a new instance of the receiver read from aStream according to aFormatString"

	| dd mm yy dateOrder format |
	format := aFormatStringOrNil ifNil: [self defaultShortFormat].
	dateOrder := self dateOrderFromFormat: format.
	dateOrder do: 
			[:each | 
			aStream skipWhile: [:c | c isAlphaNumeric not].
			aStream atEnd ifTrue: [self errorInvalidFormat].
			each = $D ifTrue: [dd := self readDayFrom: aStream].
			each = $M ifTrue: [mm := self readMonthFrom: aStream].
			each = $Y ifTrue: [yy := self readYearFrom: aStream]].
	((1 to: (self daysInMonthIndex: mm forYear: yy)) includes: dd) ifFalse: [self errorInvalidFormat].
	^self 
		newDay: dd
		monthIndex: mm
		year: yy!

readMonthFrom: aStream 
	"Private - Answer a month index read from aStream. The stream may be positioned at,
	either a month number or a month name"

	aStream peek isDigit 
		ifTrue: 
			[| month |
			month := Integer readFrom: aStream radix: 10.
			((1 to: 12) includes: month) ifFalse: [self errorInvalidFormat].
			^month].
	1 to: 12
		do: 
			[:mm | 
			| shortName |
			shortName := (self shortNameOfMonth: mm) copyWithout: $..
			(shortName skipOver: aStream ignoreCase: true) 
				ifTrue: 
					[aStream skipWhile: [:c | c isLetter].
					^mm]].
	^self errorInvalidFormat!

readYearFrom: aStream 
	"Private - Answer a year read from aStream"

	aStream peek isDigit 
		ifTrue: 
			[| yy |
			yy := Integer readFrom: aStream radix: 10.
			yy < 100 
				ifTrue: 
					["Two digit date"

					| offset |
					offset := Date today year roundTo: 100.
					yy >= self yearPivot ifTrue: [offset := offset - 100].
					yy := yy + offset].
			^yy].
	^self errorInvalidFormat!

shortFormats
	"Private - Answer a collection of the short date formats for the user locale."

	^Locale default shortDateFormats!

shortNameOfDay: dayIndex
	"Answer a String that is the localised name of the day whose index is the argument, dayIndex, where Monday is 1 
	and Sunday is 7."

	^Locale default nameOfDay: dayIndex abbrev: true!

shortNameOfMonth: monthIndex
	"Answer a localised abbreviated String name for the month whose index is the argument, monthIndex, where January 
	is month 1, and December is month 12."

	^Locale default nameOfMonth: monthIndex abbrev: true!

today
	"Answer an instance of the receiver representing the current system date."

	^self fromSYSTEMTIME: SYSTEMTIME now!

tomorrow
	^self today addDays: 1!

yearAsDays: yearInteger
	"Private - Answer the number of days between January 1, 1901 and
	the first day of the year, yearInteger"
	
	| year |
	year := yearInteger - 1901.
	^year * 365
		+ (year // 4)
		- (year // 100)
		+ (year + ##(1901-1601) // 400)!

yearPivot
	"Answers the pivot point for two digit years. Years greater or equal to this will be assumed to be
	in the current century. Years less than the pivot will be assumed to be in the next century"

	^YearPivot!

yearPivot: anInteger
	"Sets the pivot point for two digit years to be anInteger. 
	Years greater or equal to this will be assumed to be in the current century. 
	Years less than the pivot will be assumed to be in the next century"

	YearPivot := anInteger!

yesterday
	^self today subtractDays: 1! !

!Date methodsFor!

< aDate 
	"Answer whether the receiver precedes the argument, aDate"

	^self asDays < aDate asDays!

= aDate 
	"Answer whether the receiver is the same data as the argument, aDate"

	^self species == aDate species and: [self asDays = aDate asDays]!

addDays: dayCount
	"Answer a new Date that is dayCount days after the receiver."

	^self class fromDays: self asDays + dayCount!

addMonths: monthCount
	"Answer a new Date that is monthCount months before/after the receiver (monthCount can be negative).
	If the receiver's current day is not valid in the destination month and year, then the day is truncated:
	i.e. 31 Jan becomes 30 Mar if 2 months added."

	^self addMonths: monthCount desiredDay: 0!

addMonths: monthCount desiredDay: desiredDay 
	"Answer a new Date that is monthCount months before/after the receiver (monthCount can be negative). If the receiver's 
	current day is not valid in the destination month and year, then the day is truncated. i.e. 31 Jan becomes 30 Mar if 2 
	months added. If desiredDay is non-zero then this day is set (this allows the caller to retain a particular day number 
	even should it be truncated by intermediate arithmetic operations."

	^self evaluateYYMMDD: 
			[:yy :mm :dd | 
			| dayOfMonth daysInMonth monthIndex year |
			monthIndex := mm + monthCount.
			year := yy.
			[monthIndex < 1] whileTrue: 
					[monthIndex := monthIndex + 12.
					year := year - 1].
			[monthIndex > 12] whileTrue: 
					[monthIndex := monthIndex - 12.
					year := year + 1].
			dayOfMonth := desiredDay == 0 ifTrue: [dd] ifFalse: [desiredDay].
			daysInMonth := self class daysInMonthIndex: monthIndex forYear: year.
			dayOfMonth := dayOfMonth min: daysInMonth.
			self class 
				newDay: dayOfMonth
				monthIndex: monthIndex
				year: year]!

addYears: yearCount
	"Answer a new Date that is yearCount years before/after the receiver (yearCount can be negative). If the receiver's 
	current day is not valid in the destination month and year, then the day is truncated. i.e. 31 Jan becomes 30 Mar
	if 2 months added."

	^self addYears: yearCount desiredDay: 0!

addYears: yearCount desiredDay: desiredDay 
	"Answer a new Date that is yearCount years before/after the receiver (yearCount can be negative). 
	If the receiver's current day is not valid in the destination month and year, then the day is truncated:
	 i.e. 31 Jan becomes 30 Mar if 2 months added. If desiredDay is non-zero then this day is set (this allows
	the caller to retain a particular day number even should it be truncated by intermediate arithmetic operations."

	^self evaluateYYMMDD: 
			[:yy :mm :dd | 
			| dayOfMonth year daysInMonth |
			year := yy + yearCount.
			dayOfMonth := desiredDay == 0 ifTrue: [dd] ifFalse: [desiredDay].
			daysInMonth := self class daysInMonthIndex: mm forYear: year.
			dayOfMonth := dayOfMonth min: daysInMonth.
			self class 
				newDay: dayOfMonth
				monthIndex: mm
				year: year]!

asDays
	"Answer the number of days since 1901 which the receiver represents. As Dolphin dates are
	stored in this format internally, this is a simple accessor."

	^days!

asMilliseconds
	"Answer the number of milliseconds between a Time on January 1, 1901, and the same time in 
	the receiver's day (this will probably be a LargeInteger). Can be used to perform 
	arithmetic with Dates and Times."

	^self asSeconds * 1000!

asParameter
	"Answer the receiver in external system representation for passing to an external function call."

	| struct |
	struct := SYSTEMTIME new.
	self evaluateYYMMDD: 
			[:yy :mm :dd | 
			struct
				wYear: yy;
				wMonth: mm;
				wDay: dd].
	^struct!

asSeconds
	"Answer the number of seconds between a Time on January 1, 1901, and the same time in the receiver's
	day (this could well be a LargeInteger). Can be used to perform arithmetic with Dates and
	Times."

	^self asDays * ##(24*60*60)
!

asTimeStamp
	"Answer the receiver as <TimeStamp>."

	^TimeStamp date: self
!

day
	"Answer the day of the year represented by the receiver."

	^self class day: self asDays inYear: self year!

dayOfMonth
	"Answer the day of the month represented by the receiver."

	| year julianDay monthIndex |
	year := self year.
	julianDay := self class day: self asDays inYear: self year.
	monthIndex := self class monthIndexOfDay: julianDay inYear: year.
	^julianDay - (self class daysUntilMonth: monthIndex inYear: year)!

evaluateYYMMDD: aTriadicValuable 
	"Evaluate the the triadic valuable argument passing it the day, month, and year of the date
	represented by the receiver, answering the result."

	| year julianDay monthIndex |
	year := self year.
	julianDay := self class day: self asDays inYear: year.
	monthIndex := self class monthIndexOfDay: julianDay inYear: year.
	^aTriadicValuable 
		value: year
		value: monthIndex
		value: julianDay - (self class daysUntilMonth: monthIndex inYear: year)!

firstDayOfMonth
	"Answer the julian day number of the first day of the receiver's month in the receiver's year."

	^self firstDayOfMonthIndex: self monthIndex!

firstDayOfMonthIndex: monthIndex 
	"Private - Answer the julian day number of the first day of the given month at
	monthIndex in the receiver's year."

	^(DaysUntilMonth at: monthIndex)
		+ (monthIndex > 2
				ifTrue: [self class leapYear: self year]
				ifFalse: [0])
		+ 1
!

hash
	"Answer the SmallInteger hash value for the receiver"

	^self asDays hash!

monthIndex
	"Answer the one-based index of the month represented by the receiver; 1 for January, 2 for
	February, and so on."

	| year julianDay |
	year := self year.
	julianDay := self class day: self asDays inYear: year.
	^self class monthIndexOfDay: julianDay inYear: year!

monthName
	"Answer the name of the month represented by the receiver (as a Symbol)."

	^self class nameOfMonth: self monthIndex!

monthsSince: aDate
	"Answer the number of elapsed months Since the receiver and aDate.
	This methods adjusts correctly (for all cases I've tried) for part years
	and for part months, i.e. 28th Jan to 28th Feb is considered to be one month, 
	as is 29th Jan to 28th Feb, but 29th March to 28th April is 0 months. It correctly
	accounts for leap years."
	
	| calMonths |
	self evaluateYYMMDD: [ :y1 :m1 :d1 |
		aDate evaluateYYMMDD: [ :y2 :m2 :d2 |
			calMonths := (y1 - y2) * 12 + (m1 - m2).
			calMonths == 0 ifFalse: [
				"Adjust for part months, but take account of the length of the month so that
				29, Jan to 28, Feb is one month, but 29 Jun to 28 Jul is not."
				calMonths > 0
					ifTrue: [
						(d1 < d2 and: [ d1 < (self class daysInMonthIndex: m1 forYear: y1) ])
							ifTrue: [ calMonths := calMonths - 1 ]]
					ifFalse: [
						(d2 < d1 and: [ d2 < (self class daysInMonthIndex: m2 forYear: y2) ])
							ifTrue: [ calMonths := calMonths + 1 ]]]]].
	^calMonths
!

printOn: aStream
	"Append a default string representation of the receiver to aStream."

	self printOn: aStream longPicture: DefaultLongPicture!

printOn: aStream format: aString
	"Append a short textual description of the receiver to the <puttableStream> argument,
	aStream. The format is defined by the <readableString> argument, aString, the format 
	characters of which are as described in the Control Panel help for Windows Regional 
	Options/Date settings (e.g. dd/MM/yyyy, formats to, for example, 27/11/2001). If the
	format argument is nil then the receiver is printed to the stream in the currently
	configured default format of the host OS."

	self 
		printOn: aStream
		locale: Locale default
		flags: 0
		format: aString!

printOn: aStream locale: locale flags: dwFlags format: aStringOrNil
	"Private - Append a locale specific string representation of the receiver to aStream, using the specified
	format String (the default is used if it is nil). The format is as described in the Control Panel help 	
	for Windows Regional Options/Date 	settings (e.g. dd/MM/yyyy, formats to, for example, 27/11/2001)."

	aStream nextPutAll: (locale 
				printDate: self
				format: aStringOrNil
				flags: dwFlags)!

printOn: aStream locale: locale format: aStringOrNil
	"Private - Append a locale specific string representation of the receiver to aStream, using the specified
	format String (the default is used if it is nil). The format is as described in the Control Panel help for
	Windows regional Time settings (e.g. hh:mm tt, formats to, for example, 10:15 pm)."

	self printOn: aStream locale: locale flags: 0 format: aStringOrNil!

printOn: aStream longPicture: aBoolean
	"Private - Append an string representation of the receiver to aStream in default locale long/short
	formats depending on aBoolean."

	self 
		printOn: aStream 
		locale: Locale default 
		flags: (aBoolean ifTrue: [DATE_LONGDATE] ifFalse: [DATE_SHORTDATE])
		format: nil!

setDays: dayCount
	"Private - Initialize the receiver to be dayCount days after January 1, 1901"

	days := dayCount
!

storeOn: aStream 
	aStream
		display: self class;
		nextPutAll: ' fromString: '.
	self displayString printOn: aStream!

subtractDate: aDate
	"Answer the difference in days between the receiver and aData, as an Integer"

	^self asDays - aDate asDays
!

subtractDays: dayCount
	"Answer a new Date that is dayCount days before the receiver."

	^self class fromDays: self asDays - dayCount
!

weekday
	"Answer the day of the week represented by the receiver."

	^self class nameOfDay: self weekdayIndex!

weekdayIndex
	"Answer the index of the receiver's day of the week (1..7)"

	^(self asDays + 1) \\ 7 + 1!

year
	"Answer the year represented by the receiver."

	| temp q400 r400 q100 r100 q4 r4 |
	"Number of days since start of year 1600"
	temp := self asDays + ##(301*365+(301//4)-(301//100)+(301//400)).
	"Number of 400 year periods."
	q400 := temp // ##(400*365+(400//4)-(400//100)+(400//400)).
	r400 := temp \\ ##(400*365+(400//4)-(400//100)+(400//400)).
	"Number of remaining centuries"
	q100 := r400 // ##(100*365+(100//4)-(100//100)+(100//400)).
	r100 := r400 \\ ##(100*365+(100//4)-(100//100)+(100//400)).
	"Number of remaining leap year cycles"
	q4 := r100 // ##(4*365+(4//4)-(4//100)+(4//400)).
	r4 := r100 \\ ##(4*365+(4//4)-(4//100)+(4//400)).
	^(q400*400) + (q100*100) + (q4*4) + (r4//365)+1600!

yearsSince: aDate
	"Answer the number of actual elapsed years since aDate."
	
	^(self monthsSince: aDate) // 12! !

Time comment:
'Time is the class whose instances represent a time of day as the number of seconds since midnight.'!
!Time class methodsFor!

amMarker
	"Answer the marker used to signify AM when using 12 hour format"

	^Locale default amDesignator!

dateAndTimeNow 
	"Answer an Array whose first element is the current local Date and whose
	second element is the current local Time."

	| localTime |
	localTime := SYSTEMTIME now.
	^Array with: (Date fromSYSTEMTIME: localTime)
		with: (self fromSYSTEMTIME: localTime)!

defaultFormat
	"Private - Answer a collection of the time formats for the default user locale."

	^Locale default timeFormat!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed
	because the some input was in the wrong format."

	^InvalidFormat signalWith: self!

formats
	"Private - Answer a collection of the time formats for the default user locale."

	^Locale default timeFormats!

fromMilliseconds: anInteger 
	"Answer a new instance of the receiver anInteger milliseconds since midnight."

	<primitive: 157>
	^self basicNew setMilliseconds: anInteger!

fromSeconds: anInteger
	"Answer a new instance of the receiver anInteger seconds since midnight."

	^self fromMilliseconds: anInteger * 1000!

fromString: aString
	"Answer an instance of the receiver constructed from the string,
	aString, using the default conversion format."

	| stream answer |
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer
!

fromSYSTEMTIME: aSYSTEMTIME
	"Private - Answer a new instance of the receiver instantiated from the argument,
	aWinSYSTEMTIME."

	^self fromMilliseconds: aSYSTEMTIME wHour * 60 + 
							aSYSTEMTIME wMinute * 60 + 
								aSYSTEMTIME wSecond * 1000 + 
									aSYSTEMTIME wMilliseconds!

hours: hoursInteger minutes: minutesInteger seconds: secondsInteger 
	"Answer a new instance of the receiver representing the specified 
	number of hours, minutes, and seconds since midnight."

	^self fromSeconds: hoursInteger * 3600 + (minutesInteger * 60) + secondsInteger!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

microsecondClockValue
	"Answer the current value of the microsecond clock."

	| mus freq |
	mus := LargeInteger new64.
	KernelLibrary default queryPerformanceCounter: mus yourAddress.

	freq := LargeInteger new64.
	(KernelLibrary default queryPerformanceFrequency: freq yourAddress)
		ifFalse: [ self error: 'performance counter not available' ].
	^mus * 1000000 // freq normalize!

microsecondsToRun: timedBlock 
	"Answer the number of microseconds consumed by the evaluation of timedBlock
	(including the overhead)."

	| freq |
	freq := LargeInteger new64.
	(KernelLibrary default queryPerformanceFrequency: freq yourAddress) 
		ifFalse: [self error: 'performance counter not available'].
	^((self ticksToRun: timedBlock) - (self ticksToRun: [self])) * 1000000 // freq normalize!

millisecondClockValue
	"Answer the current value of the system millisecond clock."

	"Implementation Note: Primitive 174 is actually just a call to the WinMM function timeGetTime()
	which should be accurate to 1mS (unlike GetTickCount() which is only accurate to 10mS)."

	<primitive: 174>
	^self primitiveFailed!

millisecondsToRun: timedBlock
	"Answer the number of milliseconds consumed by the evaluation of timedBlock
	(including the overhead)."

	| startTime|
	startTime := self millisecondClockValue.
	timedBlock value.
	^self millisecondClockValue - startTime
!

new
	"Answer a new instance of the receiver representing the current Time."

	^self now!

now
	"Answer a new instance of the receiver representing the current Time."

	^self fromSYSTEMTIME: SYSTEMTIME now!

pmMarker
	"Answer the marker used to signify PM when using 12 hour format"

	^Locale default pmDesignator!

readFrom: aStream 
	"Answers a new instance of the receiver read from aStream according to
	aFormatStringOrNil"

	| hours minutes seconds milliseconds separator am rounded |
	minutes := 0.
	seconds := 0.
	milliseconds := 0.
	hours := Integer readFrom: aStream radix: 10.
	separator := aStream peek.
	rounded := 0.
	(separator isNil or: [separator isLetter]) 
		ifFalse: 
			[aStream next.
			minutes := Integer readFrom: aStream radix: 10.
			(aStream peekFor: separator) 
				ifTrue: 
					[seconds := Integer readFrom: aStream radix: 10.
					(aStream peekFor: separator) 
						ifTrue: [milliseconds := Integer readFrom: aStream radix: 10]
						ifFalse: 
							[(aStream peekFor: $.) 
								ifTrue: 
									[| start |
									start := aStream position.
									milliseconds := Integer readFrom: aStream radix: 10.
									milliseconds isNil 
										ifTrue: 
											["Actually just seconds with a trailing full stop"
											milliseconds := 0.
											aStream pop]
										ifFalse: 
											[| precision |
											precision := aStream position - start - 3.
											milliseconds == 0 
												ifFalse: 
													[milliseconds := (milliseconds / (10 raisedToInteger: precision)) asInteger.
													rounded := 1]]]]]].
	aStream skipWhile: [:c | c = Character space].
	am := self amMarker.
	(am notEmpty and: [am skipOver: aStream ignoreCase: true]) 
		ifTrue: 
			[((0 to: 12) includes: hours) ifFalse: [^self errorInvalidFormat].
			hours := hours % 12]
		ifFalse: 
			[| pm |
			pm := self pmMarker.
			(pm notEmpty and: [pm skipOver: aStream ignoreCase: true]) 
				ifTrue: 
					[((0 to: 12) includes: hours) ifFalse: [^self errorInvalidFormat].
					hours < 12 ifTrue: [hours := hours + 12]]].
	((0 to: 23) includes: hours) ifFalse: [^self errorInvalidFormat].
	((0 to: 59) includes: minutes) ifFalse: [^self errorInvalidFormat].
	((0 to: 59) includes: seconds) ifFalse: [^self errorInvalidFormat].
	"Note that milliseconds may legitimately be rounded up to 1000, so to avoid having to carry this through we treat it as valid"
	((0 to: 999 + rounded) includes: milliseconds) ifFalse: [^self errorInvalidFormat].
	^Time fromMilliseconds: (60 * (60 * hours + minutes) + seconds) * 1000 + milliseconds!

secondClock
	"Private - Answer the current value of the second clock (seconds since midnight)."
	
	^self now asSeconds!

ticksToRun: timedBlock 
	"Answer the number of performance counter ticks consumed by the evaluation of timedBlock
	(including the overhead)."

	| startTime endTime |
	startTime := LargeInteger new64.
	endTime := LargeInteger new64.
	KernelLibrary default queryPerformanceCounter: startTime yourAddress.
	timedBlock value.
	KernelLibrary default queryPerformanceCounter: endTime yourAddress.
	^endTime normalize - startTime normalize!

totalSeconds
	"Answer the total seconds since Jan. 1, 1901 (as an Integer) in local time."
	
	| dateAndTime |
	dateAndTime := self dateAndTimeNow.
	^(dateAndTime at: 1) asSeconds + (dateAndTime at: 2) asSeconds! !

!Time methodsFor!

< aTime
	"Answer whether the receiver precedes (assuming the same date) the argument, aTime."

	^self asMilliseconds < aTime asMilliseconds!

= aTime
	"Answer whether the receiver represent the same time of day as the argument, aTime."

	^self species == aTime species and: [ self asMilliseconds = aTime asMilliseconds ]!

addTime: aTimeOrDate
	"Answer a new Time, aTimeOrDate after the receiver."

	^self class fromMilliseconds: self asMilliseconds + aTimeOrDate asMilliseconds!

asMilliseconds
	"Answer the number of milliseconds since midnight represented by the receiver."

	^milliseconds!

asParameter
	"Answer the host system representation of the receiver."

	^SYSTEMTIME new
		wHour: self hours; 
		wMinute: self minutes; 
		wSecond: self seconds;
		yourself!

asSeconds
	"Answer the number of seconds since midnight represented by the receiver."

	^milliseconds // 1000
!

asTimeStamp
	"Answer the receiver as TimeStamp"

	^TimeStamp time: self!

hash
	"Answer the SmallInteger hash value for the receiver."

	^self asMilliseconds hash!

hours
	"Answer the hour of the day represented by the receiver (24 hour clock)"

	^(milliseconds // ##(60*60*1000)) \\ 24
!

milliseconds
	"Answer the millisecond of the second of the minute of the hour of the day represented by
	the receiver."

	^milliseconds \\ 1000!

minutes
	"Answer the minute of the hour of the day represented by the receiver."

	^(milliseconds // ##(60*1000)) \\ 60
!

printOn: aStream
	"Append a short textual description of the receiver to aStream. The format is
	defined by the default User locale (i.e. it can be reconfigured using the
	Windows control panel)."

	self printOn: aStream locale: Locale default flags: 0 format: nil!

printOn: aStream format: aString
	"Append a short textual description of the receiver to the <puttableStream> argument,
	aStream. The format is defined by the <readableString> argument, aString, the format 
	characters of which are as described in the Control Panel help for Windows	Regional 
	Options/Time settings (e.g. hh:mm tt, formats to, for example, 10:15 pm). If the format 
	argument is nil then the receiver is printed to the stream in the currently configured default 
	format of the host OS."

	self 
		printOn: aStream
		locale: Locale default
		flags: 0
		format: aString!

printOn: aStream locale: locale flags: dwFlags format: aStringOrNil
	"Private - Append a locale specific string representation of the receiver to
	aStream, using the specified format String (the default is used if it is nil).
	The format is as described in the Control Panel help for Windows Regional 
	Options/Time settings (e.g. hh:mm tt, formats to, for example, 10:15 pm)."

	aStream nextPutAll: (locale printTime: self format: aStringOrNil flags: dwFlags)


!

seconds
	"Answer the second of the minute of the hour of the day represented by 
	the receiver."

	^(milliseconds // 1000) \\ 60
!

setMilliseconds: anInteger
	"Private - Set the number of milliseconds since midnight represented by the receiver."

	milliseconds := anInteger!

storeOn: aStream 
	aStream
		display: self class;
		nextPutAll: ' fromString: '.
	self displayString printOn: aStream!

subtractTime: aTimeOrDate
	"Answer a new Time, aTimeOrDate seconds before the receiver."

	^self class fromMilliseconds: self asMilliseconds - aTimeOrDate asMilliseconds
! !

TimeStamp comment:
'TimeStamp is the class whose instances represent times of a particular day (i.e. a combination of a Date and Time).
This class is likely to be replaced by the forthcoming ANSI compliant DateAndTime class.'!
!TimeStamp class methodsFor!

current
	"Answer a new instance of the receiver representing the current
	date and time"

	^self fromSYSTEMTIME: SYSTEMTIME now!

currentUTC
	"Answer a new instance of the receiver representing the current UTC date and time"

	^self fromSYSTEMTIME: SYSTEMTIME nowUTC!

date: aDate
	"Answer a new instance of the receiver based on aDate."

	^self date: aDate time: (Time fromSeconds: 0)!

date: aDate time: aTime
	"Answer a new instance of the receiver based on aDate and aTime"

	<primitive: 157>
	^super new
		date: aDate;
		time: aTime;
		yourself!

fromMilliseconds: anInteger 
	| date msInDay |
	date := Date fromSeconds: anInteger // 1000.
	msInDay := anInteger - (date asSeconds * 1000).
	^self date: date time: (Time fromMilliseconds: msInDay)!

fromSeconds: anInteger
	"Answer a new instance of the receiver representing the point in time
	anInteger seconds after the epoch."

	| date |
	date := Date fromSeconds: anInteger.
	^self 
		date: date 
		time: (Time fromSeconds: anInteger - date asSeconds)!

fromString: aString 
	| stream time date |
	stream := aString readStream.
	
	[time := Time readFrom: stream.
	stream next.
	date := Date readFrom: stream] on: InvalidFormat
			do: 
				[:x | 
				stream reset.
				date := Date readFrom: stream.
				stream next.
				time := Time readFrom: stream].
	^TimeStamp date: date time: time!

fromSYSTEMTIME: aSYSTEMTIME
	"Answer a new instance of the receiver representing the current
	date and time"

	^self 
		date: (Date fromSYSTEMTIME: aSYSTEMTIME) 
		time: (Time fromSYSTEMTIME: aSYSTEMTIME)!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new instance of the receiver representing the current Time."

	^self current!

time: aTime
	"Answer a new instance of the receiver based on aTime."

	^self date: (Date fromDays: 0) time: aTime! !

!TimeStamp methodsFor!

< aTimeStamp
	"Answer whether the receiver precedes the argument, aTimeStamp."

	^self date < aTimeStamp date
		or: [self date = aTimeStamp date and: [self time < aTimeStamp time]]!

= aTimeStamp
	"Answer whether the receiver represents the same time and date as the argument."

	^self species == aTimeStamp species 
		and: [self date = aTimeStamp date and: [self time = aTimeStamp time]]!

asMilliseconds
	"Answer the number of milliseconds between January 1, 1901, and the time and date
	represented by the receiver (this will likely be a LargeInteger). Can be used to perform 
	arithmetic with Dates and Times."

	^self date asMilliseconds + self time asMilliseconds!

asParameter
	"Answer the receiver in external system representation for passing to an external function call."

	| timeStampSt timeSt |
	timeStampSt := self date asParameter.
	timeSt := self time asParameter.
	timeStampSt
		wHour: timeSt wHour; 
		wMinute: timeSt wMinute; 
		wSecond: timeSt wSecond.
	^timeStampSt!

asSeconds
	"Answer the number of seconds between January 1, 1901, and the time and date
	represented by the receiver (this will likely be a LargeInteger). Can be used to perform 
	arithmetic with Dates and Times."

	^self date asSeconds + self time asSeconds!

asTimeStamp
	"Answer the receiver as <TimeStamp>."

	^self!

date
	"Answer the Date of the receiver."

	^date
!

date: aDate
	"Set the Date of the receiver. Answer the receiver."

	date := aDate
!

dateAndTime
	"Answer a two element Array containing the date and time."

	^Array with: self date with: self time
!

hash
	"Answer the SmallInteger hash value for the receiver."

	^(self date hash bitShift: 2) bitXor: self time hash!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		print: self time;
		nextPutAll: ', ';
		print: self date!

printOn: aStream locale: aLocale flags: anInteger timeFormat: timeString dateFormat: dateString
	aStream
		nextPutAll: (aLocale 
					printTime: self time
					format: timeString
					flags: anInteger);
		space;
		nextPutAll: (aLocale 
					printDate: self date
					format: dateString
					flags: anInteger)!

printOn: aStream timeFormat: timeString dateFormat: dateString
	"Append a short textual description of the receiver to the <puttableStream> argument,
	aStream. The format is defined by the <readableString> argument, aString, the format 
	characters of which are as described in the Control Panel help for Windows 	Regional 
	Options/Time & Date settings. If the format argument is nil then the receiver is printed 
	to the stream in the currently configured default date and time formats of the host OS."

	self 
		printOn: aStream
		locale: Locale default
		flags: 0
		timeFormat: timeString
		dateFormat: dateString!

storeOn: aStream 
	aStream
		display: self class;
		nextPutAll: ' fromString: '.
	self displayString printOn: aStream!

time
	"Answer the Time of the receiver."

	^time
!

time: aTime
	"Set the Time of the receiver. Answer the receiver."

	time := aTime
! !

Number comment:
'Number is the abstract class which defines the common protocol of all numeric objects.

Its messages support standard arithmetic operations and comparisons, which are mostly implemented by subclasses.'!
!Number class methodsFor!

errorInvalidFormat
	"Private - Raise an error that some attempt to create an instance of the receiver failed
	because the some input was in the wrong format."

	^InvalidFormat signalWith: self!

fromString: aString 
	"Instantiate a new instance of the receiver from the <readableString> argument."

	| stream answer |
	#todo.	"Should be separate fromDisplayString: version which converts from locale specific format (this method from Smalltalk format)"
	stream := aString readStream.
	answer := self readFrom: stream.
	stream atEnd ifFalse: [^self errorInvalidFormat].
	^answer!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new instance of the receiver.
	Numbers are either immutable, or require more specific instantiation
	methods, therefore the standard instance creation protocol is not supported."

	^self shouldNotImplement!

one
	"Answer the receiver's representation of one. For many Numbers this 
	is the SmallInteger 1"

	^1!

readDecimalIntegerFrom: aStream allowPlus: aBoolean 
	"Private - Read a positive or negative decimal integer from the <gettableStream>, aStream, which
	has neither radix nor exponent. Return nil if there is no integer at the current position in
	the stream."

	| isNegative plus |
	isNegative := aStream peekFor: $-.
	plus := aBoolean and: [isNegative not and: [aStream peekFor: $+]].
	^(self readIntegerFrom: aStream radix: 10) 
		ifNil: 
			[(isNegative or: [plus]) ifTrue: [aStream pop].
			nil]
		ifNotNil: [:value | isNegative ifTrue: [value negated] ifFalse: [value]]!

readExponentIntegerFrom: aStream initialInteger: anInteger 
	"Private - A partially recognised exponentInteger has been read from the <gettableStream>, aStream,
	which is positioned immediately after the $r. Read the rest of the Integer and answer its value,
	or if not an exponentInteger, pop the $r and answer anInteger. Note that the exponent is always
	considered to be expressed in base 10."

	"Allow plus prefix on exponent, e.g. 1.0e+16, although not strictly Smalltalk syntax."

	^(self readDecimalIntegerFrom: aStream allowPlus: true) 
		ifNil: 
			[aStream pop.
			anInteger]
		ifNotNil: [:exponent | anInteger * (10 raisedToInteger: exponent)]!

readFractionFrom: aStream initialInteger: anInteger 
	"Private - A partially recognised Fraction has been read from the <gettableStream>, aStream,
	which is positioned immediate after the $/. Read the rest of the Fraction and answer its value,
	or if not a Fraction (determined by the immediate presence of an integer denominator), pop the 
	$/ and answer anInteger."

	^(self readDecimalIntegerFrom: aStream allowPlus: false) 
		ifNil: 
			[aStream pop.
			anInteger]
		ifNotNil: [:denominator | Fraction numerator: anInteger denominator: denominator]!

readFrom: aStream
	"Instantiate a new sub-instance of the receiver from aStream and answer it.
	Any numbers in the stream are expected to obey Smalltalk syntax 
	rather than any locale specific formatting, i.e. this is not intended for reading
	user input. For convenience the set of recognised Number types is expanded
	from just the Smalltalk literal types to also include Fractions."

	| value |
	^(value := self readSmalltalkSyntaxFrom: aStream) isNil 
		ifTrue: [0]
		ifFalse: [
			(value isInteger and: [aStream peekFor: $/]) 
				ifTrue: [self readFractionFrom: aStream initialInteger: value]
				ifFalse: [value]]
!

readIntegerFrom: aStream radix: radix
	"Private - Answer a positive <integer> instantiated from the text representation on aStream 
	using the specified radix. If no integer is found, then answer nil.
	Note: This is intended for reading Integer's obeying Smalltalk syntax, not locale specific
	formats, and therefore it does not handle NLS characters (e.g. thousand separators)."

	| value accumulator |
	accumulator := 0.
	[aStream atEnd] whileFalse: [ | char digit |
		char := aStream next.
		((digit := char digitValue) < radix and: [digit >= 0])
			ifTrue: [value := accumulator := accumulator * radix + digit]
			ifFalse: [aStream pop. ^value]].
	^value
!

readRadixIntegerFrom: aStream initialInteger: anInteger
	"Private - A partially recognised radixInteger has been read from the <gettableStream>, aStream,
	which is positioned immediately after the $r. Read the rest of the Integer and answer its value,
	or if not a radixInteger, pop the $r and answer anInteger."

	| radixInteger |
	^(anInteger < 2 or: [anInteger > 36 or: [(radixInteger := self readIntegerFrom: aStream radix: anInteger) isNil]])
		ifTrue: [aStream pop. anInteger]
		ifFalse: [
			(aStream peekFor: $e) 
				ifTrue: [self readExponentIntegerFrom: aStream initialInteger: radixInteger]
				ifFalse: [radixInteger]]!

readScaledDecimalFrom: aStream mantissa: aNumber precision: anInteger
	"Private - A partially recognised ScaledDecimal has been read from the <gettableStream>, aStream,
	which is positioned immediate after the $s. Read the rest of the ScaledDecimal (which will just
	be the explict scale, if there is one) and answer it."

	| scale |
	(scale := self readIntegerFrom: aStream radix: 10) isNil ifTrue: [
		"Implied precision, .e.g. 2.50s"
		scale := anInteger].
	^ScaledDecimal
		newFromNumber: aNumber
		scale: scale!

readSmalltalkRealFrom: aStream initialInteger: anInteger 
	"Private - Answer a new, positive, <Float> or <ScaledDecimal>, read from the
	<gettableStream>, aStream. The <integer>, integerPart, has already been read from the stream
	and we are currently positioned immediately after the decimal point."

	| nextChar precision fractionalPart start mantissa |
	start := aStream position.
	"Attempt to read positive fractional part"
	(fractionalPart := self readIntegerFrom: aStream radix: 10) isNil 
		ifTrue: 
			["Actually just an Integer with a trailing full stop, which we must pop back
			 onto the stream"
			aStream pop.
			^anInteger].
	precision := aStream position - start.

	"So as to not accumulate round off errors the mantissa is kept in integer form."
	fractionalPart = 0 
		ifTrue: 
			[mantissa := anInteger.
			precision := 0]
		ifFalse: [mantissa := anInteger * (10 raisedToInteger: precision) + fractionalPart].

	"Process any exponent..."
	((nextChar := aStream peek) == $e or: [nextChar == $d or: [nextChar == $q]]) 
		ifTrue: 
			[| exponent |
			aStream next.	"Skip the exponent character"
			"Allow plus prefix on the exponent, although not ANSI Smalltalk syntax"
			(exponent := self readDecimalIntegerFrom: aStream allowPlus: true) notNil 
				ifTrue: 
					[^exponent >= precision 
						ifTrue: [(mantissa * (10 raisedToInteger: exponent - precision)) asFloat]
						ifFalse: 
							["Note that the fraction does not need to be
							 normalized before #asFloat conversion,
							 which will be faster than Integer>>gcd: "
							(Fraction numerator: mantissa denominator: (10 raisedToInteger: exponent negated + precision)) 
								asFloat]].

			"Found Float with trailing exponent character which is not part of the
			number, e.g. 1.5e From ANSI standard p 28: 'An exponentLetter must be
			followed by an explicit exponent'"
			aStream pop]
		ifFalse: 
			[nextChar == $s 
				ifTrue: 
					[aStream next.	"Skip the $s"
					^self 
						readScaledDecimalFrom: aStream
						mantissa: mantissa / (10 raisedToInteger: precision)
						precision: precision]].

	"Normal Float, such as 2.5 (perhaps with trailing exponent character)"
	^precision = 0 
		ifTrue: [mantissa asFloat]
		ifFalse: 
			["Again the fraction does not need to be normalized before conversion"
			(Fraction numerator: mantissa denominator: (10 raisedToInteger: precision)) asFloat]!

readSmalltalkSyntaxFrom: aStream 
	"Private - Instantiate a new sub-instance of the receiver from aStream and answer it.
	If no Number is found at the streams current position then answer nil.
	Any numbers in the stream are expected to obey Smalltalk syntax 
	rather than any locale specific formatting, i.e. this is not intended for reading
	user input.  
	WARNING: If you modify this method you may break the compiler.
	Implementation Note: The basic idea is to read the initial integer part and
	then proceed to read a Float if a decimal point is found, a ScaledDecimal if a
	$s is found, etc. Note that Fractions are not a literal type, as otherwise the
	meaning of expressions such as '1+3/4' would not be consistent with the
	normal language semantics (Smalltalk has no operator precedence)."

	| isNegative integerPart answer |
	isNegative := aStream peekFor: $-.
	(integerPart := self readIntegerFrom: aStream radix: 10) isNil 
		ifTrue: 
			["There's nothing for you here"

			isNegative ifTrue: [aStream pop].
			^nil].

	"The type of number is determined by what we find next"
	answer := aStream atEnd 
				ifTrue: [integerPart]
				ifFalse: 
					[| nextChar |
					nextChar := aStream next.
					answer := nextChar == $. 
								ifTrue: [self readSmalltalkRealFrom: aStream initialInteger: integerPart]
								ifFalse: 
									[nextChar == $r 
										ifTrue: [self readRadixIntegerFrom: aStream initialInteger: integerPart]
										ifFalse: 
											[nextChar == $s 
												ifTrue: 
													[self 
														readScaledDecimalFrom: aStream
														mantissa: integerPart
														precision: 0]
												ifFalse: 
													[nextChar == $e 
														ifTrue: [self readExponentIntegerFrom: aStream initialInteger: integerPart]
														ifFalse: 
															[aStream pop.
															integerPart]]
											"Also support St-80 format integer of the form 1e5, not valid ANSI syntax though"]]].
	^isNegative ifTrue: [answer negated] ifFalse: [answer]!

zero
	"Answer the receiver's representation of zero. For many Numbers this 
	is the SmallInteger 0"

	^0! !

!Number methodsFor!

@ yCoord 
	"Answer a Point with the receiver as X and the argument as Y.
	The traditional Make Point primitive is present because this operation may be
	performed a few thousand times when opening a complex window (for example).
	The primitive is simply a VM level implementation of #x:y:, and does not fail."

	^Point x: self y: yCoord!

arcCos
	"Answer a <Float> which is the inverse cosine of the receiver in radians"

	^self asFloat arcCos!

arcSin
	"Answer a <Float> which is the inverse sine of the receiver in radians"

	^self asFloat arcSin!

arcTan
	"Answer a <Float> which is the inverse tangent of the receiver in radians"

	^self asFloat arcTan!

asFloat
	"Answer the receiver represented as the nearest possible <Float>.
	 Implementation Note: Dolphin only supports double precision floating 
	point numbers, so the answer will be such (i.e. a FloatD) even if a smaller 
	representation is possible."

	^self subclassResponsibility!

asFloatD
	"Answer a 'd' precision floating-point number approximating the receiver."

	^self asFloat!

asFloatE
	"Answer an 'e' precision floating-point number approximating the receiver.
	 Implementation Note: Dolphin only suppots double precision floating 
	point numbers, so the answer will be such (i.e. a FloatD)."

	^self asFloat!

asFloatQ
	"Answer a 'q' precision floating-point number approximating the receiver.
	 Implementation Note: Dolphin only suppots double precision floating 
	point numbers, so the answer will be such (i.e. a FloatD)."

	^self asFloat!

asFraction
	"Answer an <integer> or <fraction> approximating the receiver."

	^self subclassResponsibility!

asInteger
	"Answer the nearest <integer> value to the receiver."

	^self rounded!

asPoint
	"Answer a Point with the receiver as both co-ordinates."

	^self @ self!

asPoint3D
	"Answer a Point with the receiver as all three co-ordinates."

	^self @ self @ self!

asScaledDecimal: scale
	"Answer a <ScaledDecimal> number, with the fractional precision 
	specified by the <integer>, scale, which most nearly approximates
	the receiver."

	^ScaledDecimal
		newFromNumber: self
		scale: scale
!

ceiling
	"Answer the <integer> nearest the receiver toward positive infinity
	(i.e. the smallest <integer> greater than or equal to the receiver)."

	| anInteger |
	anInteger := self // 1.
	^anInteger = self 
		ifTrue: [anInteger]
		ifFalse: [anInteger + 1]!

copy
	"Answer a copy of the receiver (by default a copy which shares the receiver's 
	instance variables). Numbers are immutable, so we answer the receiver itself."

	^self!

cos
	"Answer a <Float> which is the cosine of the receiver, 
	which is treated as an angle in radians"

	^self asFloat cos!

degreesToRadians
	"Answer a <Float> representing the receiver converted from degrees to radians."
	
	^self * ##(Float pi / 180.0)!

denominator
	"Answer the <integer> denominator of the receiver."

	^1!

divideByZero
	"Private - Generate a division by zero error"

	^ZeroDivide dividend: self!

even
	"Answer whether the receiver is an even number. Zero is considered even"

	^(self \\ 2) isZero!

exp
	"Answer a <Float> which is the natrual exponential value of the 
	receiver (i.e. 'e' raised to the power of the receiver).
	This is the inverse of #ln."

	^self asFloat exp!

floor
	"Answer the <integer> nearest the receiver toward negative infinity
	(i.e. the largest integer less than or equal to the receiver)."

	^self // 1!

floorLog: operand
	"Answer an <integer> which is the logarithm to the <number> base, operand,
	of the receiver, truncated towards negative infinity."
	
	^(self log: operand) floor!

fractionPart
	"Answer a <number> of the same type as the receiver, representing the 
	fractional part of  the receiver."

	^self - self truncated
!

hashBits
	"Private - Answer the maximum number of bits in a <Number>s hash value."

	"Implementation Note: We want hash values to fit within the positive SmallInteger range"

	^##(VMConstants.SmallIntegerMax highBit)!

integerPart
	"Answer an <integer>  representing the whole integer part of 
	the receiver."

	^self truncated!

isLiteral
	"Answer whether the receiver the receiver has a literal representation which
	is recognised by the Compiler"

	^true!

ln
	"Answer a <Float> which is the natural logarithm of the receiver."

	^self asFloat ln!

log
	"Answer the log to the base 10 of the receiver"

	^self asFloat log!

log: operand
	"Answer a <Float> which is the logarithm to the <number> base, 
	operand, of the receiver."

	^self ln / operand ln!

numerator
	"Answer the <integer> numerator of the receiver. Default is the receiver which can be 
	overridden by the subclasses (e.g. Fraction)."

	^self!

odd
	"Answer whether the receiver is an odd number."

	^self even not!

radiansToDegrees
	"Answer a <Float> which is the receiver converted from radians to degrees."

	^self * ##(180.0 / Float pi)!

raisedTo: operand
	"Answer a <number> which is the receiver raised to the power of 
	the <number> argument, operand.
	Raise a FloatingPointException for overflow if the answer must be
	a <Float> and exceeds the representable range of a double precision
	floating point number."

	self isZero 	ifTrue: [
		^operand <= 0
			ifTrue: [self error: 'Invalid operands']
			ifFalse: [self]].
	self = self class one ifTrue: [^self].
	operand isInteger ifTrue: [^self raisedToInteger: operand].
	^(self asFloat ln * operand) exp!

sin
	"Answer a <Float> which is the sine of the receiver, 
	which is treated as an angle in radians."

	^self asFloat sin!

sqrt
	"Answer a <number> which is the positive square root of the receiver."
	
	^self asFloat sqrt!

tan
	"Answer a <Float> which is the tangent of the receiver, 
	which is treated as an angle in radians."

	^self asFloat tan!

to: stop
	"Answer an <interval> from the receiver up to the argument, stop, with an interval of 1 
	between elements."

	^Interval from: self to: stop!

to: stop by: step
	"Answer an <interval> from the receiver up to the argument, stop, with an interval of 
	the argument, step, between elements."

	^Interval from: self to: stop by: step!

to: stop by: step do: operation
	"Evaluate the <monadicBlock> argument, operation, for each <number> between the 
	receiver and the <number> argument, stop, in increments of the <number> argument, step."

	"Implementation Note:  This message is inlined by the compiler for all cases where the step is
	a numeric literal (i.e. most of the time), so this implementation is not much used."

	(self to: stop by: step) do: operation!

to: stop do: operation
	"Evaluate the <monadicBlock> operation passing it the <number> sequence beginning 
	with the receiver, and incrementing by one until the <number> argument, stop, is reached, 
	inclusive. 
	Implementation Note: This method is critical to overall system performance, and is normally inlined by 
	the compiler, so this implementation is used only when #perform:'ed."

	(self to: stop) do: operation! !

Point comment:
'A Point represents an x-y pair of numbers usually indicating a point on a two-dimensional Cartesian coordinate plane. Points are often used to designate the location of pixels within a Bitmap or on the display screen. By Smalltalk convention, x increases to the right and y down, consistent with the layout of text on a page and with pixels in Windows'' bitmaps. This "left-handed" coordinate system is the convention for Points used within the standard Smalltalk image (in classes such as Rectangle) but there is nothing in the Point class itself that prohibits the implied use of a "right-handed" coordinate system in which y increases in the upward direction.

A Point is typically created using the binary message @ to a Number:

150 @ 200

Arithmetic operations can be carried out between two Points or between a Point and a Number. Each of the arithmetic messages returns a new Point as the result. Note the need to make use of parentheses in the expressions below due to the equal precedence assigned to all binary messages (such as @ and +).

(150 @ 200) + (50 @ 50) "Addition of Points"
(150 @ 200) + 100 "Addition of scalar"
(150 @ 200) * 3 "Scaling"'!
!Point class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new
	"Answer a new instance of the receiver equal to zero."

	^self zero!

one
	"Answer the receiver's representation of one."

	^self x: 1 y: 1!

x: xCoord y: yCoord 
	"Answer a new instance of the receiver with the specified
	x and y coordinates"

	<primitive: 157>
	^self basicNew x: xCoord y: yCoord!

zero
	"Answer the receiver's representation of zero."

	^self x: 0 y: 0! !

!Point methodsFor!

- anArithmeticValue
	"Answer the receiver minus anArithmeticValue as a Point."

	^anArithmeticValue subtractFromPoint: self!

* anArithmeticValue
	"Answer a Point with the receiver's coordinates multiplied by anArithmeticValue."

	^anArithmeticValue multiplyByPoint: self!

/ operand
	"Answer a Point with the receiver's coordinates divided by the <number>, 
	operand. If the operand is zero then a <ZeroDivide> is raised."

	^operand divideIntoPoint: self!

+ anArithmeticValue
	"Answer the sum of receiver and aPoint as a Point."

	^anArithmeticValue addToPoint: self!

< anArithmeticValue
	"Answer whether the receiver is above and to the left of anArithmeticValue.
	N.B. No double dispatch, as would need to do for more than just #<."

	| aPoint |
	aPoint := anArithmeticValue asPoint.
	^x < aPoint x and: [ y < aPoint y ]!

<= anArithmeticValue
	"Answer whether the receiver is neither below nor to the right of anArithmeticValue.
	A double dispatch of #< with the superclass implementation of #<= would not work here."

	| aPoint |
	aPoint := anArithmeticValue asPoint.
	^x <= aPoint x and: [ y <= aPoint y ]!

= comperand
	"Answer whether the receiver is considered equivalent to the
	<Object> argument, comperand."

	^self species == comperand species
		ifTrue: [x = comperand x and: [y = comperand y]]
		ifFalse: [super = comperand]!

> anArithmeticValue
	"Answer whether the receiver is below and to the right of anArithmeticValue.
	A double dispatch of #< with the superclass implementation of #> would not work here."

	| aPoint |
	aPoint := anArithmeticValue asPoint.
	^x > aPoint x and: [y > aPoint y]
!

>= anArithmeticValue
	"Answer whether the receiver is neither above nor to the left of anArithmeticValue.
	A double dispatch of #< with the superclass implementation of #>= would not work here."
	
	| aPoint |
	aPoint := anArithmeticValue asPoint.
	^x >= aPoint x and: [ y >= aPoint y ]
!

abs
	"Answer a <Point> that is the absolute value (positive magnitude) of the receiver."

	^x abs @ y abs!

addToPoint: aPoint
	"Private - Answer the result of adding the receiver to the known Point,
	aPoint, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^(aPoint x + x) @ (aPoint y + y)!

asDword
	"Answer the receiver in a form suitable for returning as the result of a window
	procedure (or passing to a function expecting a 32-bit value)."

	^(DWORD fromPoint: self) value!

asPoint
	"Answer the receiver"

	^self!

asPoint3D
	"Answer a Point3D with the receiver."

	^self x @ self y @ 0!

asUIntPtr
	"Answer the receiver in a form suitable for passing/returning as a Windows LRESULT
	(32 or 64-bit, depending on host OS) return value. The default is self (which will cause the
	default window proc. of the window to be called for most objects other than Integers when
	used as a return value)."

	^(self x bitAnd: VMConstants.HalfPtrMask) 
		bitOr: ((self y bitAnd: VMConstants.HalfPtrMask) bitShift: VMConstants.HalfPtrBits)!

ceiling
	"Answer a new Point with the x and y values of the receiver truncated
	toward positive infinity."

	^x ceiling @ y ceiling!

coerce: anArithmeticValue
	"Private - Answer the lower generality ArithmeticValue, anArithmeticValue, 
	converted to a Point."

	^anArithmeticValue asPoint!

corner: aPoint
	"Answers a Rectangle defined by the receiver and aPoint."

	^Rectangle origin: self corner: aPoint!

degrees
	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."

	x = 0 
		ifTrue: [y >= 0 ifTrue: [^90.0] ifFalse: [^270.0]]
		ifFalse: 
			[| tan theta |
			tan := y asFloat / x asFloat.
			theta := tan arcTan.
			x >= 0 
				ifTrue: [y >= 0 ifTrue: [^theta radiansToDegrees] ifFalse: [^360.0 + theta radiansToDegrees]]
				ifFalse: [^180.0 + theta radiansToDegrees]]!

dist: aPoint 
	"Answer the distance between aPoint and the receiver."

	^(aPoint - self) r!

divideIntoPoint: aPoint
	"Private - Answer the result of dividing the receiver into the known Point, aPoint, by 
	coercing the less general of it and the receiver. Overridden by subclasses which 
	can implement more efficiently."

	^(aPoint x / x) @ (aPoint y / y)!

dotProduct: aPoint 
	"Answer a Number that is the sum of the product of the x coordinates
	and the product of the y coordinates of the receiver and aPoint"

	^(x * aPoint x) + (y * aPoint y)!

extent: aPoint
	"Answers a Rectangle whose origin is the receiver and whose
	extent is the argument aPoint"

	^Rectangle origin: self extent: aPoint!

floor
	"Answer a new Point with the x and y values of the receiver truncated
	toward negative infinity."

	^x floor @ y floor!

generality
	"Private - Answer the Smalltalk generality of the receiver, used for performing type conversions"

	^50!

hash
	"Answer the <integer> hash value for the receiver."

	^(x hash bitShift: 2) bitXor: y hash!

max: aPoint
	"Answer a new Point with the maximum of the x coordinates
	and the maximum of the y coordinates of the receiver and aPoint"

	^(x max: aPoint x) @ (y max: aPoint y)!

min: aPoint
	"Answer a new Point with the maximum of the x coordinates
	and the maximum of the y coordinates of the receiver and aPoint"

	^(x min: aPoint x) @ (y min: aPoint y)!

multiplyByPoint: aPoint
	"Private - Answer the result of multiplying the known Point, aPoint,
	by the receiver, by coercing the less general of it and the recever.
	Overridden by subclasses which can implement more efficiently."

	^(x * aPoint x) @ (y * aPoint y)!

printOn: target
	"Append a short textual description of the receiver to the
	<puttableStream>, target."

	target 
		print: x;
		nextPut: $@;
		print: y!

r
	"Answer the receiver's radius (magnitude) in a polar coordinate 
	system."

	^(self dotProduct: self) sqrt!

raisedTo: operand
	"Answer an <ArithmeticValue> which is the receiver raised to the power of 
	the <number> argument, operand."

	^(x raisedTo: operand) @ (y raisedTo: operand)!

rounded
	"Answer a new Point with the x and y values of the receiver rounded.
	Implementation Note: Superclass implemenation works, but we can do it more efficiently."

	^x rounded @ y rounded!

roundTo: aNumber 
	"Answer a new Point3D with the x, y values of the receiver rounded."

	^(x roundTo: aNumber) @ (y roundTo: aNumber)!

subtractFromPoint: aPoint
	"Private - Answer the result of subtracting the receiver from the known Point,
	aPoint, by coercing the less general of it and the receiver. Overridden by 
	subclasses which can implement more efficiently."

	^(aPoint x - x) @ (aPoint y - y)!

transpose
	"Answer a new Point with the x and y coordinates of the receiver
	reversed"

	^y @ x!

truncated
	"Answer a new Point with the x and y values of the receiver truncated toward zero"

	^x truncated @ y truncated!

x
	"Answer the receiver's x coordinate"

	^x!

x: aNumber
	"Set the receiver's x coordinate"

	x := aNumber!

x: xCoord y: yCoord
	"Private - Set the x and y coordinates of the receiver.
	Primarily intended for instance creation. Answer the receiver."

	x := xCoord.
	y := yCoord!

y
	"Answer the receiver's y coordinate"

	^y!

y: aNumber
	"Set the receiver's y coordinate"

	y := aNumber! !

Float comment:
'Float is the class of double precision floating point Numbers (64-bit) in IEEE-754 format. Note that the original Smalltalk-80 definition of Float, was only single precision, but this is considered somewhat outdated. Rather than introduce the complexity of multiple classes to represent floating point numbers, we have chosen to standardise on double precision.

Class Variables:
	SignificantDifference	<Float>. Difference between two Floats which is considered sufficient to deem them unequal. The smallest this can be is Float class>>epsilon.
	DefaultSigFigs	<SmallInteger>. Default digits of precision displayed.

'!
!Float class methodsFor!

denormalized
	"Answer whether the characterized floating point representation allows denormalized
	values."

	^Processor activeProcess fpeMask allMask: (_EM_DENORMAL bitOr: _EM_UNDERFLOW)
!

e
	"Answer a <Float> representing the irrational number, 'e'
		Float e
	"

	^##(1 exp)!

emax
	"Answer an <integer> representing the largest exponent
	of the characterized floating point representation."

	"Implementation Note: This value is that needed tocorrectly calculate 
	#fmax by the expression on p141 of the ANSI Smalltalk standard, 
	but the IEEE 754 double-precision value for emax is +1023."

	^1024!

emin
	"Answer an <integer> representing the smallest exponent
	of the characterized floating point representation."

	"Implementation Note: This value is that needed tocorrectly calculate 
	#fminNormalized by the expression on p142 of the ANSI Smalltalk standard, 
	but the IEEE 754 double-precision value for emin is -1022."

	^-1021!

epsilon
	"Answer a <Float> representing the minimum relative spacing
	in the characterized floating point representation.

		Float epsilon = (self radix asFloat raisedTo: (1 - self precision))
	"

	^2.2204460492503131e-016
!

fmax
	"Answer a <Float> representing the largest value
	allowed by the characterized floating point representation."

	^FMax!

fmin
	"Answer a <Float> representing the smallest value
	allowed by the characterized floating point representation."

	^self denormalized
		ifTrue: [self fminDenormalized]
		ifFalse: [self fminNormalized]!

fminDenormalized
	"Answer a <Float> representing the smallest denormalized value
	allowed by the characterized floating point representation."

	^self radix asFloat raisedTo: self emin - self precision!

fminNormalized
	"Answer a <Float> representing the smallest normalized value
	allowed by the characterized floating point representation."

	^FMin!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Private - Initialize the class variables of the receiver
		Float initialize
	"

	"There are only just over 15 digits of precision in a 64-bit IEEE float, but not 16 digits."

	DefaultSigFigs := 15.
	SignificantDifference := 1.0e-009.
	self assert: [SignificantDifference >= self epsilon].
	FMax := ((1 - (self radix raisedTo: self precision negated)) 
				* (self radix raisedTo: self emax)) asFloat.
	FMin := self radix asFloat raisedTo: self emin - 1.
	#(#FloatD #FloatE #FloatQ) do: [:each | Smalltalk at: each ifAbsentPut: [self]]!

new
	"Answer a new instance of the receiver."

	^self basicNew: 8
!

one
	"Answer the receiver's representation of one."

	^1.0!

onStartup
	"Private - Re-initialize the receiver on session startup"

	self reset!

pi
	"Answer a <Float> representing 'pi'."

	^##(-1.0 arcCos)!

precision
	"Answer an <integer> representing the precision (the number of bits in the mantissa) 
	of the characterized floating point representation. Note that the actual number of
	bits stored is 52. The normalized representation means that the high bit is always one
	and need not be stored."

	^53!

radix
	"Answer an <integer> representing the radix
	of the characterized floating point representation."

	^2!

readFrom: aStream
	"Instantiate a new instance of the receiver from aStream and answer it.
	Handles negative integers with a leading minus sign.
	Does not handle NLS characters (e.g. thousand separators and decimal separators
	other than $.)."

	^(super readFrom: aStream) asFloat!

reset
	"Reset the floating point support. Win32 resets the exception mask to a standard value
	every time an exception occurs, so this must be sent after each FloatingPointException."

	CRTLibrary default _clearfp.
	self setExceptionMask: Processor activeProcess fpeMask!

setExceptionMask: anInteger
	"Private - Set the current floating point exception mask
	to anInteger. Answer the previous mask."

	^CRTLibrary default _controlfp: anInteger mask: _MCW_EM!

zero
	"Answer the receiver's representation of zero."

	^0.0! !

!Float methodsFor!

- aNumber
	"Answer the result of subtracting the argument, aNumber, from the receiver.

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float.

	May also raise a floating point exception."

	<primitive: 161>
	^aNumber subtractFromFloat: self!

* aNumber
	"Answer the result of multiplying the receiver by the argument, aNumber.

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float.

	May also raise a floating point exception."

	<primitive: 164>
	^aNumber multiplyByFloat: self!

/ operand
	"Answer the result of dividing the receiver by the <number>, operand.
	Raise a <ZeroDivide> exception if the operand is zero.

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float."

	<primitive: 165>
	^operand divideIntoFloat: self!

+ aNumber
	"Answer the result of adding aNumber to the receiver.

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float.

	May also raise a floating point exception."

	<primitive: 160>
	^aNumber addToFloat: self!

< aNumber
	"Answer true if the receiver is less than aNumber. This relational operator is 
	implemented as a primitive, and >, <=, and >= are expressed in terms of it.

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float.

	May also raise a floating point exception."

	<primitive: 162>
	^aNumber greaterThanFloat: self
!

= comperand
	"Answer whether the receiver is numerically equivalent to the argument,
	comperand (e.g. 1 = 1.0 is true).

	Primitive failure reasons:
		0 -	aNumber is not a SmallInteger or a Float.

	May also raise a floating point exception."

	<primitive: 163>
	^super = comperand!

abs
	"Answer a Number that is the absolute value - positive magnitude - of the receiver."

	^CRTLibrary default fabs: self
	!

addToFloat: aFloat
	"Private - Answer the result of adding the receiver to the known Float, aFloat.
	If we get here, then the floating point subtraction must have failed due to some 
	floating point exception."

	^self primitiveFailed!

addToFraction: aFraction
	"Private - Answer the result of adding the receiver to the known fraction, aFraction, 
	by coercing the less general of it and the receiver."

	^aFraction asFloat + self!

addToInteger: anInteger
	"Private - Add the known integer, anInteger, to the receiver, converting anInteger 
	to a Float. Answer the result"

	^anInteger asFloat + self!

arcCos
	"Answer a <Float> which is the inverse cosine of the receiver in radians. If the receiver is not in the 
	range -1 .. 1 (non-inclusive) then a FloatingPointException will be raised."

	^CRTLibrary default acos: self!

arcSin
	"Answer a <Float> which is the inverse sine of the receiver in radians. If the receiver is not in the 
	range -1 .. 1 (non-inclusive) then a FloatingPointException will be raised."

	^CRTLibrary default asin: self!

arcTan
	"Answer a <Float> which is the inverse tangent of the receiver in radians."

	^CRTLibrary default atan: self!

arcTan: aFloat
	"Answer the arc-tangent of the receiver/aFloat in radians."

	^CRTLibrary default atan: self x: aFloat!

asApproximateFraction
	"Answer a <rational> (e.g. Fraction or Integer) approximating the receiver.
	This conversion uses the continued fraction method to approximate a 
	floating point number."

	| numerator1 denominator1 numerator2 denominator2 integerPart fractionPart |
	numerator1 := self truncated.
	denominator1 := 1.
	numerator2 := 1.
	denominator2 := 0.
	integerPart := numerator1.
	fractionPart := self fractionPart.
	[fractionPart = 0] whileFalse: 
			[| newD temp |
			newD := 1.0 / fractionPart.
			integerPart := newD truncated.
			fractionPart := newD fractionPart.
			temp := numerator2.
			numerator2 := numerator1.
			numerator1 := numerator1 * integerPart + temp.
			temp := denominator2.
			denominator2 := denominator1.
			denominator1 := integerPart * denominator1 + temp.
			"Is ratio past float precision?"
			1.0e14 < denominator1 
				ifTrue: 
					[^numerator2 = 0.0 
						ifTrue: [Fraction numerator: numerator1 denominator: denominator1]
						ifFalse: [Fraction numerator: numerator2 denominator: denominator2]]].
	^denominator1 = 1 
		ifTrue: [numerator1]
		ifFalse: [Fraction numerator: numerator1 denominator: denominator1]!

asFloat
	"Answer the receiver as a floating point number"

	^self
!

asFraction
	"Answer an <integer> or <fraction> approximating the receiver."

	^self asApproximateFraction!

asTrueFraction
	"Answer a <rational> that precisely represents the binary fractional value of the receiver
	using all available bits of the double precision IEEE floating point representation. Note
	that because <Float> is an imprecise representation, the result may have more precision than
	appropriate. For example the decimal number 0.1 cannot be represented precisely as a binary
	floating point number, and hence the <Float> representation is itself only approximate. When
	<Float> representation of 0.1 is converted using this method the result is a precisely
	equivalent Fraction that is very close to (1/10), but not actually equal to 0.1."

	" Extract the bits of an IEEE double float "

	| shifty sign expPart exp fraction fractionPart |
	shifty := VMLibrary default makeLargeUnsigned: self.

	" Extract the sign and the biased exponent "
	sign := (shifty bitShift: -63) == 0 ifTrue: [1] ifFalse: [-1].
	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.

	" Extract fractional part; answer 0 if this is a true 0.0 value "
	fractionPart := shifty bitAnd: 16r000FFFFFFFFFFFFF.
	(expPart == 0 and: [fractionPart = 0]) ifTrue: [^0].

	"Add implied leading 1 into fraction"
	fraction := expPart = 0 
				ifTrue: [fractionPart bitShift: 1]
				ifFalse: [fractionPart bitOr: 16r0010000000000000].

	"Unbias exponent: 16r3FF is bias; 52 is fraction width"
	exp := ##(16r3FF + 52) - expPart.

	"Form the result. When exp>52, the exponent is adjusted by the number of trailing zero bits
	in the fraction to minimize the (huge) time otherwise spent in #gcd:. "
	^exp negative 
		ifTrue: [sign * fraction bitShift: exp negated]
		ifFalse: 
			[| zeroBitsCount |
			zeroBitsCount := fraction lowBit - 1.
			exp := exp - zeroBitsCount.
			exp <= 0 
				ifTrue: 
					[zeroBitsCount := zeroBitsCount + exp.
					sign * fraction bitShift: zeroBitsCount negated]
				ifFalse: 
					[Fraction numerator: (sign * fraction bitShift: zeroBitsCount negated) denominator: (1 bitShift: exp)]]!

ceiling
	"Answer the integer nearest the receiver toward positive infinity."

	^(CRTLibrary default ceil: self) truncated
!

coerce: anArithmeticValue
	"Private - Answer the lower generality ArithmeticValue, anArithmeticValue, 
	converted to a Float."

	^anArithmeticValue asFloat
!

cos
	"Answer a <Float> which is the cosine of the receiver, which is treated as an angle in radians.
	May raise a FloatingPointException in the case of underflow."

	^CRTLibrary default cos: self!

divideIntoFloat: aFloat
	"Private - Answer the result of dividing the receiver by the known Float, aFloat. 
	If we get here, then the floating point multiplication must have failed due to some floating
	point exception."

	^self shouldNotImplement!

divideIntoFraction: aFraction
	"Private - Answer the result of dividing the receiver into the known fraction, aFraction, 
	by coercing the less general of it and the receiver."

	^aFraction asFloat / self!

divideIntoInteger: anInteger
	"Private - Answer the result of dividing the receiver into the known integer, anInteger, 
	by coercing the less general of it and the receiver."

	^anInteger asFloat / self!

equals: aNumber
	"Answer whether the receiver is numerically equivalent to aNumber, within the
	default numerical precision."

	| max |
	^(max := self abs max: aNumber abs) <= SignificantDifference
		or:  [(self - aNumber) abs < (SignificantDifference * max)]
!

exp
	"Answer the exponential of the receiver. The primitive should not fail."

	^CRTLibrary default exp: self!

exponent
	"Answer the SmallInteger which is the exponent part of the receiver as a Float."

	^(CRTLibrary default _logb: self) truncated!

floor
	"Answer the integer nearest the receiver toward negative infinity."

	^(CRTLibrary default floor: self) truncated
!

floorLog10
	"Answer the base 10 exponent of the receiver (an Integer between -308 and 308)."

	^self log floor!

fractionPart
	"Answer a <Float> representing the fractional part of the receiver."

	^CRTLibrary default modf: self intptr: Float new!

generality
	"Private - Answer the generality of the receiver. Floats are the highest generality numbers 
	(though they do not offer infinite precision)."

	^40
!

greaterOrEquals: aNumber 
	"Answer whether the receiver is numerically greater than or equal to aNumber, within the
	default numerical precision."

	(self equals: aNumber) ifTrue: [^true].
	^self > aNumber!

greaterThanFraction: aFraction
	"Private - Answer whether the receiver is greater than the known Fraction, aFraction."

	^aFraction asFloat < self!

greaterThanInteger: anInteger
	"Private - Answer whether the receiver is greater than the known Integer, anInteger."

	^anInteger asFloat < self!

hash
	"Answer the <SmallInteger> hash value for the receiver. If the receiver is a whole
	number, then the hash of the integer part is used, otherwise the integerPart is
	bitXor'd with the bits of the fractionPart."

	| integerPart fractionPart |
	integerPart := Float new.
	fractionPart := CRTLibrary default modf: self intptr: integerPart.
	fractionPart isZero ifTrue: [^integerPart truncated hash].
	fractionPart := (##(VMConstants.SmallIntegerMax + 1.0) * 
			fractionPart timesTwoPower: (fractionPart exponent abs truncated + 1)).
	^(integerPart truncated bitXor: fractionPart truncated) bitAnd: VMConstants.SmallIntegerMax!

integerPart
	"Answer a <Float> representing the whole integer part of the receiver.
	Implementation Note: Avoid truncaction to integer which can be time
	consuming if the receiver is very large."

	| intPart |
	intPart := Float new.
	CRTLibrary default modf: self intptr: intPart.
	^intPart
!

lessOrEquals: aNumber 
	"Answer whether the receiver is numerically less than or equal to aNumber, within the
	default numerical precision."

	(self equals: aNumber) ifTrue: [^true].
	^self < aNumber!

ln
	"Answer the a Float which is the natural logarithm of the receiver.
	May raise FloatingPointException (e.g. if the receiver is negative)."

	^CRTLibrary default log: self!

log
	"Answer a <Float> which is the base 10 logarithm of the receiver.
	May raise a FloatingPointException (e.g. if the receiver is negative).

	Implementation Note: Although we could implement this in terms of #ln,
	that tends to lead to unfortunate precision errors such as '1000.0 log truncated'
	evaluating to 2. It is also faster to use the log10() function directly."

	^CRTLibrary default log10: self!

multiplyByFloat: aFloat
	"Private - Answer the result of multiplying the known Float, aFloat, by the receiver. 
	If we get here, then the floating point multiplication must have failed due to some floating
	point exception."

	^self primitiveFailed!

multiplyByFraction: aFraction
	"Private - Multiply the receiver by the known fraction, aFraction, by converting anInteger 
	to a Float. Answer the result"

	^aFraction asFloat * self!

multiplyByInteger: anInteger
	"Private - Multiply the receiver by the known integer, anInteger, by converting anInteger 
	to a Float. Answer the result"

	^anInteger asFloat * self!

negative
	"Answer whether the receiver is negative.
	Implementation Note: High-bit of IEEE float is sign bit."

	^(self basicAt: 8) anyMask: 128!

printOn: target
	"Append the ASCII representation of the receiver to the <puttableStream>, target.

	The representation we use is a valid literal representation for floating point
	numbers, recognised by the Smalltalk compiler."

	self printOn: target significantFigures: DefaultSigFigs!

printOn: aStream decimalPlaces: anInteger 
	"Append the printed representation of the receiver to the <puttableStream>,
	aStream, rounded	to the <integer> number of decimal places, anInteger.
	Implementation Note: fcvt() is a jolly quirky function, hence the
	complexity. This seemed preferable to reinventing the wheel, but
	now I'm not so sure!!"

	| sign ptPos digits |
	anInteger < 1 ifTrue: [^self rounded printOn: aStream].
	ptPos := SDWORD new.
	sign := SDWORD new.
	digits := CRTLibrary default 
				_fcvt: self
				count: anInteger
				dec: ptPos
				sign: sign.
	sign asInteger = 0 ifFalse: [aStream nextPut: $-].
	ptPos := ptPos asInteger.
	ptPos <= 0 ifTrue: [aStream nextPut: $0].
	ptPos < 0 
		ifTrue: 
			[aStream
				nextPut: $.;
				next: (ptPos negated min: anInteger) put: $0;
				nextPutAll: digits]
		ifFalse: 
			[aStream
				next: ptPos
					putAll: digits
					startingAt: 1;
				nextPut: $.;
				next: digits size - ptPos
					putAll: digits
					startingAt: ptPos + 1]!

printOn: aStream significantFigures: anInteger 
	"Append the printed representation of the receiver to aStream with
	anInteger significant figures. Ensure that there is always a digit
	following the decimal point.
	Implementation Note: Make use of the CRT to avoid reinventing the
	wheel. #printOn:decimalPlaces: may be more convenient when printing
	reports, formatting output fields, etc, as it does not drop into
	exponential format."

	| buf ptPos |
	buf := String new: (anInteger bitShift: 1) + 10.
	buf := CRTLibrary default 
				_gcvt: self
				count: anInteger
				buffer: buf.

	"Ensure decimal separator is always a $. for printOn:, which outputs Smalltalk real syntax"
	ptPos := buf findString: CRTLibrary default decimalSeparator.
	ptPos == 0 
		ifTrue: 
			[aStream
				nextPutAll: buf;
				nextPutAll: '.0']
		ifFalse: 
			[| size |
			aStream
				next: ptPos - 1
					putAll: buf
					startingAt: 1;
				nextPut: $..
			size := buf size.
			ptPos = size 
				ifTrue: 
					["Smalltalk requires a trailing zero to follow decimal points"
					aStream nextPut: $0]
				ifFalse: 
					[(buf at: ptPos + 1) == $e ifTrue: [aStream nextPut: $0].
					aStream 
						next: buf size - ptPos
						putAll: buf
						startingAt: ptPos + 1]]!

raisedTo: operand 
	"Answer a <Float> which is the receiver raised to the power of the <number>
	argument, operand.
	Note: ANSI standard says that it is an error for the receiver to be negative, but I 
	think that is bogus (unless the operand is non-integral). This implementation will, 
	however, raise an error (a ZeroDivide in fact, but ANSI doesn't specify the precise 
	exception) if the receiver is zero and the argument not strictly positive)."

	^operand strictlyPositive 
		ifTrue: [CRTLibrary default pow: self y: operand asFloat]
		ifFalse: [CRTLibrary default pow: self reciprocal y: operand abs asFloat]!

rounded
	"Answer the <integer> nearest the receiver."

	^(self < 0.0 ifTrue: [self - 0.5] ifFalse: [self + 0.5]) truncated!

sin
	"Answer a <Float> which is the sine of the receiver, 
	which is treated as an angle in radians.
	May raise FloatingPointException."

	^CRTLibrary default sin: self!

sqrt
	"Answer the Float which is the square root of the receiver.
	Raises a FloatingPointExceptoin if the receiver is negative."

	^CRTLibrary default sqrt: self!

subtractFromFloat: aFloat
	"Private - Answer the result of subtracting the receiver from the known Float, aFloat. 
	If we get here, then the floating point subtraction must have failed due to some floating
	point exception."

	^self primitiveFailed!

subtractFromFraction: aFraction
	"Private - Answer the result of subtracting the receiver from the known fraction, aFraction."

	^aFraction asFloat - self!

subtractFromInteger: anInteger
	"Private - Subtract the known integer, anInteger, from the receiver, converting anInteger 
	to a Float. Answer the result"

	^anInteger asFloat - self!

tan
	"Answer a <Float> which is the tangent of the receiver, 
	which is treated as an angle in radians.
	May raise a FloatingPointException."

	^CRTLibrary default tan: self!

timesTwoPower: aNumber
	"Answer the receiver times two to the power of the argument, aNumber."

	| int |
	int := aNumber asInteger.
	^int class == SmallInteger
		ifTrue: [CRTLibrary default ldexp: self exp: int]
		ifFalse: [self * (2 raisedToInteger: int) asFloat]!

truncated
	"Answer the <integer> nearest the receiver toward zero.
	Note that for many large floats the answer may be reported
	to more digits of precision that the floating point receiver
	was capable of representing (there are only about 15 digits 
	of precision in a double).
	Implementation Note: Rather than calculate the integer approximation
	by a series of divisions (as in versions of Dolphin prior to 3.02), a
	process which was both very slow for large Floats and also prone
	to error, we use precise #asTrueFraction.

	Primitive failure results:
		0 -	the receiver is not finite.
		1 -	more than 64-bits are required to represent the receiver 
			as an Integer.
	May also raise a floating point exception."

	<primitive: 166>
	^self asTrueFraction truncated
! !

Fraction comment:
'Instances of class Fraction represent rational numbers which are not integers, e.g. 3/4. They are always represented in the most reduced form possible. Fractions are usually created by a division operation between two integers where the numerator cannot be divided exactly the denominator. Unlike Float, Fraction has effectively limitless precision, and thus calculations involving Fractions do not suffer from rounding errors. This can be useful where absolute accuracy is required, but Fraction arithmetic is not supported directly by the CPU, and thus calculations are orders of magnitude slower.

Instance Variables:
	numerator		<integer>
	denominator	<integer>

'!
!Fraction class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

numerator: top denominator: bottom
	"Answer a <Fraction> with numerator and denominator,
	initialised to the <integer> arguments, top, and, bottom.
	It is assumed that the arguments are such that a normalised
	<Fraction> will result - use #normalisedNumerator:denominator if
	you're not sure and require the smallest possible denominator."

	^self basicNew numerator: top denominator: bottom!

rationalisedNumerator: numInteger denominator: divInteger
	"Answer a Fraction which is the rationalised form of numInteger
	divided by divInteger."

	| gcd denominator numerator |
	denominator := divInteger truncated abs.
	numerator := divInteger negative
		ifTrue: [numInteger truncated negated]
		ifFalse: [numInteger truncated].
	gcd := numerator gcd: denominator.
	denominator = gcd ifTrue: [^numerator // gcd].
	gcd == 1 ifTrue: [^self basicNew numerator: numerator denominator: denominator].
	^self basicNew numerator: numerator // gcd denominator: denominator // gcd!

readFrom: aStream
	"Instantiate a new instance of the receiver from aStream and answer it.
	Handles negative fractions with a leading minus sign.
	Does not handle NLS characters (e.g. thousand separators)"

	^(super readFrom: aStream) asFraction! !

!Fraction methodsFor!

- aNumber
	"Answer the difference between the receiver and aNumber."

	^aNumber subtractFromFraction: self!

* aNumber
	"Answer the result of multiplying the receiver by aNumber."

	^aNumber multiplyByFraction: self!

/ operand
	"Answer the result of dividing the receiver by the <number>, operand.
	Raise a <ZeroDivide> exception if the operand is zero."

	^operand divideIntoFraction: self!

// aNumber
	"Answer the integer quotient after dividing the receiver by aNumber
	with truncation towards negative infinity."

	^(numerator * aNumber denominator) //
		(denominator * aNumber numerator)!

+ aNumber
	"Answer sum of the receiver and aNumber."

	^aNumber addToFraction: self!

< aNumber
	"Answer whether the receiver is less than the argument, aNumber"

	^aNumber greaterThanFraction: self!

addToFloat: aFloat
	"Private - Add the receiver to the known Float, aFloat."

	^aFloat + self asFloat
!

addToFraction: aFraction
	"Private - Add the known Fraction, aFraction, to the receiver. This is obviously fastest
	if the receiver and aFraction have the same denominator"

	^denominator = aFraction denominator
		ifTrue: [ 
			Fraction
				rationalisedNumerator: numerator + aFraction numerator
				denominator: denominator ]
		ifFalse: [
			Fraction
				rationalisedNumerator: numerator * aFraction denominator + (aFraction numerator * denominator)
				denominator: denominator * aFraction denominator ]!

addToInteger: anInteger 
	"Private - Add the known integer, anInteger, to the receiver. There is no need
	to rationalise the result."

	^Fraction
		numerator: anInteger * denominator + numerator
		denominator: denominator!

asFloat
	"Answer a <Float> approximating the receiver. Note that some precision may be lost - the
	result will be the closest floating point number to the receiver calculated using the IEEE
	754 round-to-nearest-even mode."

	| a b q r exponent floatExponent nBits ha hb hq q1 |
	a := numerator abs.
	b := denominator abs.
	ha := a highBit.
	hb := b highBit.

	"If both numerator and denominator can be represented exactly, then fastest thing to do is
	to use hardwired float division."
	nBits := Float precision + 1.
	(ha < nBits and: [hb < nBits]) ifTrue: [^numerator asFloat / denominator asFloat].

	"Try and obtain a mantissa with 54 bits by integer division. This is 53 bits of IEEE 754
	mantissa plus 1 bit for rounding. First guess is rough, we might get one more bit or one
	less."
	exponent := ha - hb - nBits.
	exponent > 0 ifTrue: [b := b bitShift: exponent] ifFalse: [a := a bitShift: exponent negated].
	q := a quo: b.
	r := a - (q * b).
	hq := q highBit.

	"Check for gradual underflow, in which case we should use less bits"
	floatExponent := exponent + hq.
	floatExponent >= Float emin ifFalse: [nBits := nBits + floatExponent - Float emin].

	"Use exactly nBits."
	hq > nBits 
		ifTrue: 
			[exponent := exponent + hq - nBits.
			r := (q bitAnd: (1 bitShift: hq - nBits) - 1) * b + r.
			q := q bitShift: nBits - hq].
	hq < nBits 
		ifTrue: 
			[exponent := exponent + hq - nBits.
			q1 := (r bitShift: nBits - hq) quo: b.
			q := (q bitShift: nBits - hq) bitAnd: q1.
			r := (r bitShift: nBits - hq) - (q1 * b)].


	"Check if we should round upward. The case of exact half (q bitAnd: 1) = 1 & (r isZero) will
	be handled by Integer>>asFloat."
	((q bitAnd: 1) isZero or: [r isZero]) ifFalse: [q := q + 1].

	"Finally build the float"
	^(self positive ifTrue: [q asFloat] ifFalse: [q asFloat negated]) timesTwoPower: exponent!

asFraction
	"Answer a Fraction approximating the receiver."

	^self
!

coerce: anArithmeticValue
	"Private - Answer the lower generality <ArithmeticValue>, anArithmeticValue,
	converted to a Fraction"

	^Fraction numerator: anArithmeticValue denominator: 1
!

denominator
	"Answer the smallest <integer> denominator of the receiver."

	^denominator!

displayOn: aStream
	"Append to the <puttableStream>, aStream, a <readableString> whose characters are 
	a representation of the receiver as a user would want to see it (in this case sans parenthesis)."
	
	aStream 
		print: numerator;
		nextPut: $/;
		print: denominator!

divideIntoFloat: aFloat
	"Private - Divide the receiver into the known Float, aFloat.
	Answer the result."

	^aFloat / self asFloat!

divideIntoFraction: aFraction
	"Private - Divide the receiver into the known Fraction, aFraction.
	Answer the result."

	^Fraction
		rationalisedNumerator: denominator * aFraction numerator
		denominator: numerator * aFraction denominator!

divideIntoInteger: anInteger
	"Private - Divide the receiver into the known integer, anInteger.
	Answer the result."

	^Fraction
		rationalisedNumerator: anInteger * denominator
		denominator: numerator!

generality
	"Private - Answer the generality of the receiver."

	^30
!

greaterThanFloat: aFloat
	"Private - Answer whether the receiver is greater than the known Float, aFloat"

	^aFloat < self asFloat!

greaterThanFraction: aFraction
	"Private - Answer whether the receiver is greater than the known Fraction, aFraction"

	| negative |
	negative := aFraction negative.
	negative = self negative ifFalse: [ ^negative ].
	^aFraction numerator * denominator < 
		(numerator * aFraction denominator)!

greaterThanInteger: anInteger
	"Private - Answer whether the receiver is greater than the known integer, anInteger"

	^anInteger * denominator < numerator!

hash
	"Answer the <integer> hash value for the receiver."

	"Implementation Note: This should be the same hash value as the equivalent <Integer> of <Float>"

	^denominator = 1 
		ifTrue: [numerator hash]
		ifFalse: 
			[[self asFloat hash] on: FloatingPointException
				do: [:ex | numerator hash bitXor: denominator hash]]!

isFraction
	"Answer true if receiver is an instance of class Fraction, else answer false."

	^true
!

isLiteral
	"Answer whether the receiver the receiver has a literal representation which
	is recognised by the Compiler"

	^false!

isZero
	"Answer whether the receiver is equal to its class' zero"

	^numerator isZero!

multiplyByFloat: aFloat
	"Private - Multiply the receiver by the known Float, aFloat.
	Answer the result."

	^aFloat * self asFloat!

multiplyByFraction: aFraction
	"Private - Multiply the receiver by the known Fraction, aFraction.
	Answer the result."

	^Fraction
		rationalisedNumerator: numerator * aFraction numerator
		denominator: denominator * aFraction denominator
!

multiplyByInteger: anInteger
	"Private - Multiply the receiver by the known integer, anInteger.
	Answer the result."

	^Fraction
		rationalisedNumerator: anInteger * numerator
		denominator: denominator!

negated
	"Answer an instance of class Fraction which is the negative of the receiver."

	^Fraction
		numerator: self numerator negated
		denominator: self denominator
!

numerator
	"Answer the <integer> numerator of the receiver reduced to its lowest common denominator."

	^numerator!

numerator: num denominator: div
	"Private - The numerator and denominator of the receiver are set to the num and div
	arguments respectively. Intended for instance initialisation."

	div = 0 ifTrue: [^num divideByZero].
	div negative
		ifTrue: 
			[numerator := num negated.
			denominator := div negated]
		ifFalse: 
			[numerator := num.
			denominator := div].
	self isImmutable: true!

printOn: aStream
	"Append a short textual description of the receiver to aStream."
	
	"The ANSI standard states that the printString of a Fraction is not bracketed, but historically it has been.
	 We provide displayString for end-user format."

	aStream 
		nextPut: $(;
		print: numerator;
		nextPut: $/;
		print: denominator;
		nextPut: $)
!

reciprocal
	"Answer the reciprocal of the receiver by dividing the denominator by the numerator."

	| n d |
	n := numerator positive 
				ifTrue: 
					[d := numerator.
					denominator]
				ifFalse: 
					[d := numerator negated.
					denominator negated].
	d == 1 ifTrue: [^n] ifFalse: [^self class numerator: n denominator: d]!

squared
	"Answer the receiver multiplied by the receiver."

	^self class
		numerator: numerator squared denominator: denominator squared
!

subtractFromFloat: aFloat
	"Private - Subtract the receiver from the known Float, aFloat."

	^aFloat - self asFloat
!

subtractFromFraction: aFraction
	"Private - Subtract the receiver from the known Fraction, aFraction. This is obviously fastest
	if the receiver and aFraction have the same denominator"

	^denominator = aFraction denominator
		ifTrue: [ 
			Fraction
				rationalisedNumerator: aFraction numerator - numerator
				denominator: denominator ]
		ifFalse: [
			Fraction
				rationalisedNumerator: aFraction numerator * denominator - (numerator * aFraction denominator)
				denominator: denominator * aFraction denominator ]!

subtractFromInteger: anInteger 
	"Private - Subtract the receiver from the known integer, anInteger.
	There is no need to rationalise the result."

	^Fraction
		numerator: anInteger * denominator - numerator
		denominator: denominator!

truncated
	"Answer the receiver as a kind of Integer truncating the fraction part."

	^numerator quo: denominator! !

Integer comment:
''!
!Integer class methodsFor!

primesUpTo: aNumber 
	"Answer a <sequencedReadableCollection> of all primes less than or equal to the <integer> argument."

	| limit flags prime primes |
	limit := aNumber asInteger - 1.
	flags := ByteArray new: limit withAll: 1.
	primes := OrderedCollection new.
	1 to: limit
		do: 
			[:i | 
			(flags at: i) == 1 
				ifTrue: 
					[| k |
					prime := i + 1.
					k := i + prime.
					[k <= limit] whileTrue: 
							[flags at: k put: 0.
							k := k + prime].
					primes addLast: prime]].
	^primes!

readFrom: aStream
	"Instantiate a new subinstance of the receiver from aStream and answer it.
	Handles negative integers with a leading minus sign. Also allows for bases
	other than 10 (with leading nnr format) with digits greater than 10 being
	represented by characters A-Z.
	Does not handle NLS characters (e.g. thousand separators)."

	| neg answer |
	neg := aStream peekFor: $-.
	answer := self readFrom: aStream
				initialInteger: (self readPositiveFrom: aStream radix: 10).
	^neg ifTrue: [answer negated] ifFalse: [answer]!

readFrom: aStream initialInteger: initialInteger
	"Private - Instantiate a new instance of the receiver from aStream and answer it.
	The <integer>, initialInteger, has already been read from the stream.
	All we need to do is to check whether initialInteger is in fact a radix prefix, and
	proceed accordingly."

	^(aStream peekFor: $r) 
		ifTrue: [self readPositiveFrom: aStream radix: initialInteger]
		ifFalse: [initialInteger]!

readFrom: aStream radix: anInteger
	"Instantiate a subinstance of the receiver from aStream using the specified
	radix, and answer it. 
	Note: This is intended for reading Integer's obeying Smalltalk syntax, not locale specific
	formats, and therefore it does not handle NLS characters (e.g. thousand separators)."

	| neg value |
	neg := aStream peekFor: $-.
	value := self readPositiveFrom: aStream radix: anInteger.
	^neg ifTrue: [value negated] ifFalse: [value]!

readPositiveFrom: aStream radix: anInteger
	| value |
	value := 0.
	[aStream atEnd] whileFalse: 
			[| char digit |
			char := aStream next.
			((digit := char digitValue) < anInteger and: [digit >= 0]) 
				ifTrue: [value := value * anInteger + digit]
				ifFalse: 
					[aStream pop.
					^value]].
	^value! !

!Integer methodsFor!

- operand
	"Answer a <number> which is the difference between the receiver and the argument, operand."

	^operand subtractFromInteger: self!

& anInteger
	"Answer the result of a bitwise AND between the receiver and the argument, anInteger.
	N.B. Use of #bitAnd: is preferred (even though it is more typing) because it is
	a special selector (i.e. it is more compact and faster), and is portable."

	^self bitAnd: anInteger!

* aNumber
	"Answer the result of multiplying the receiver by aNumber."

	^aNumber multiplyByInteger: self!

/ operand
	"Answer the <number> which is the result of dividing the receiver by <number>, operand. 
	If their is any remainder, then the result will be a <Fraction>. Raise a <ZeroDivide> 
	exception if the operand is zero."

	^operand divideIntoInteger: self!

// aNumber
	"Answer the quotient resulting from dividing the receiver by aNumber with 
	truncation towards negative infinity."

	| quo |
	self isZero ifTrue: [^self].
	quo := self quo: aNumber.
	(quo negative	
		ifTrue: [quo * aNumber ~= self]
		ifFalse: [quo isZero and: [self negative ~= aNumber negative]])
				ifTrue: [^quo - 1]
				ifFalse: [^quo].
!

| anInteger
	"Answer the result of a bitwise OR between the receiver and the argument, 
	anInteger.
	N.B. Use of #bitOr: is preferred (even though it is more typing) because it is
	a special selector (i.e. it is more compact and faster), and is portable."

	^self bitOr: anInteger!

+ aNumber
	"Answer a Number which is the sum of the receiver and aNumber."

	^aNumber addToInteger: self!

< aNumber
	"Answer whether the receiver is less than the argument, aNumber."

	^aNumber greaterThanInteger: self!

<< anInteger
	"Answer the result of shifting the receiver left anInteger bits.
	N.B. Use of #bitShift: is preferred (even though it is more typing) because it is
	a special selector (i.e. it is more compact and faster), and is portable."

	^self bitShift: anInteger!

>> anInteger
	"Answer the result of shifting the receiver right anInteger bits.
	N.B. Use of #bitShift: (with a negative argument) is preferred (even 
	though it is more typing) because it is a special selector (i.e. it is 
	more compact and faster), and is portable."

	^self bitShift: anInteger negated!

addToFloat: aFloat
	"Private - Add the receiver from the known Float, aFloat."

	^aFloat + self asFloat!

addToFraction: aFraction
	"Private - Add the receiver to the known Fraction, aFraction.
	There is no need to normalise the result."

	^Fraction
		numerator: self * aFraction denominator + aFraction numerator
		denominator: aFraction denominator!

allMask: mask
	"Answer whether all of the bits that are set in the <integer> mask are also set in 
	the receiver."

	^(self bitAnd: mask) = mask!

anyMask: mask
	"Answer whether any of the bits that are set in the <integer> mask are also set 
	in the receiver."

	^(self bitAnd: mask) ~= 0!

asBoolean
	"Answer whether the receiver is non-zero."

	^self ~= 0
!

asCharacter
	"Answer the character whose Unicode code is the receiver."

	^Character value: self
!

asDword
	"Answer the receiver as an unsigned double word value. Assumes the receiver is 
	a 32 bit integer.
	Implementation Note: LargeInteger constant receiver 
	to avoid always failing the SmallInteger bitAnd: primitive."

	^16rFFFFFFFF bitAnd: self!

asExternalAddress
	"Answer the receiver as an ExternalAddress."

	^VMLibrary default addressFromInteger: self!

asExternalHandle
	"Answer the receiver as an ExternalHandle.
	Implementation Note: Use the external call primitive coercion trick for speed."

	^VMLibrary default handleFromInteger: self!

asFraction
	"Answer the normalized fractional representation of the receiver, in this
	case an exact representation."

	^self!

asInteger
	"Answer the integer value of the receiver."

	^self
!

asScaledDecimal: anInteger 
	"Answer a <ScaledDecimal> number, with the fractional precision 
	of 0 (i.e. the argument is effectively ignored). See ANSI 5.6.5.3 p127."

	^ScaledDecimal newFromNumber: self scale: 0!

asSDword
	"Answer the receiver as an signed double word value. Assumes the receiver is 
	a 32 bit integer.
	Implementation Note: Get the external library primitive to perform the coercion
	for us."

	^VMLibrary default signedFromUnsigned: self!

asUIntPtr
	"Answer the receiver as an unsigned double word value. Assumes the receiver is 
	a 32 bit integer.
	Implementation Note: LargeInteger constant receiver 
	to avoid always failing the SmallInteger bitAnd: primitive."

	^VMConstants.IntPtrMask bitAnd: self!

at: anInteger 
	"Integer's do not support indexed instance variables."

	^self shouldNotImplement!

basicPrintDigitsOn: aStream base: anInteger 
	"Private - Print the digits of the receiver in base anInteger to aStream. N.B. The receiver
	MUST be positive for this to work correctly."

	| quotient digits index |
	quotient := self.
	index := self digitLength * 8.
	digits := String new: index.
	[quotient < anInteger] whileFalse: 
			[| quoRem |
			quoRem := quotient quoAndRem: anInteger.
			digits at: index put: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: (quoRem at: 2) + 1).
			index := index - 1.
			quotient := quoRem at: 1].
	digits at: index put: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: quotient + 1).
	aStream 
		next: digits size - index + 1
		putAll: digits
		startingAt: index!

bitAnd: operand
	"Answer an <integer> whose bits are the logical AND of the
	receiver's bits and those of the <integer> argument, operand."

	^self subclassResponsibility!

bitAt: index
	"Answer the <integer> 0 or 1 which is the binary value of the bit at 
	the <integer> position, index, in the receiver's 2's complement binary representation."

	^(self bitAnd: (1 bitShift: index - 1)) == 0
		ifTrue: [0]
		ifFalse: [1]!

bitAt: index put: value
	"Set the binary value of the bit at the <integer> position, index, in the 
	receiver's 2's complement binary representation to the low-order bit
	of the <integer> argument, value.
	Note: Integers are immutable, so there is no effect on the receiver and the
	answer is a new integer."

	^(self bitAnd: (1 bitShift: index-1) bitInvert)
		bitOr: ((value bitAnd: 1) bitShift: index - 1)!

bitInvert
	"Answer an integer whose bits are the complement of the receiver."

	^-1 - self!

bitOr: operand
	"Answer an integer whose bits are the logical OR of the
	receiver's bits and those of the <integer> argument, operand."

	^self subclassResponsibility!

bitShift: shift
	"Answer an <integer> which is the receiver shifted left by the
	<integer>, shift, number of bit positions if the operand is positive, 	
	or shifted right for shift negated number of bit positions if the operand
	is negative."

	shift isInteger
		ifFalse: [self error: 'non-integer argument'].
	shift >= 0
		ifTrue: [^self * (2 raisedToInteger: shift)].
	^self // (2 raisedToInteger: shift negated)!

bitXor: operand
	"Answer an <integer> whose bits are the logical XOR of the
	receiver's bits and those of the <integer> argument, operand"

	^self subclassResponsibility!

byteAt: anInteger 
	"Private - Answer the byte at index, index, of the absolute value of the
	receiver (i.e. magnitude  only representation)."

	^anInteger > 0 
		ifTrue: [(self abs bitShift: (1 - anInteger) * 8) bitAnd: 16rFF]
		ifFalse: [self errorSubscriptBounds: anInteger]!

byteSize
	"Private - Answer the number of bytes in the receiver's 2's complement
	representation."

	^self subclassResponsibility!

ceiling
	"Answer the integer nearest the receiver toward positive infinity."

	^self
!

clearBit: index
	"Answer the Integer which results from clearing the index'th bit of the receiver,
	where the least significant bit is considered to have index 1."

	^self maskClear: (1 bitShift: index-1)!

coerce: anArithmeticValue
	"Private - Answer the Integer representation of anArithmeticValue."

	^anArithmeticValue asInteger!

digitAt: anInteger 
	"Answer the index'th byte of 2's complement representation of the receiver. e.g. 1 at: 1 =
	1, -1 at: 1 = 255 (see also #byteAt:). Report an error if index is not greater than 0, but
	answer 0/255 if index is greater than the size of the receiver as this is a sensible action
	for Integers."

	^anInteger > 0 
		ifTrue: [(self bitShift: (1 - anInteger) * 8) bitAnd: 16rFF]
		ifFalse: [self errorSubscriptBounds: anInteger]!

digitLength
	"Answer the number of significant radix-256 digits in the receiver."

	^((self abs bitOr: 1) highBit - 1 bitShift: -3) + 1!

displayString
	"Answer a String whose characters are a representation of the receiver as a user
	would want to see it.
	Implementation Note: For Integers this is the same as the #printString, and for
	many cases that has an optimized implementation of which we wish to take
	advantage."

	^self printString!

divideIntoFloat: aFloat
	"Private - Divide the receiver into the known Float, aFloat. Answer the result."

	^aFloat / self asFloat!

divideIntoFraction: aFraction
	"Private - Answer the result of dividing the receiver into the argument, with
	truncation towards negative infinity. In general Integer division is more
	likely to be inexact, so assume a Fraction will be needed. The Fraction class
	instance creation method will answer an Integer if it can."

	^Fraction
		rationalisedNumerator: aFraction numerator
		denominator: self * aFraction denominator!

divideIntoInteger: anInteger 
	"Private - Answer the result of dividing the receiver into the argument, with
	truncation towards negative infinity. In general Integer division is more
	likely to be inexact, so assume a Fraction will be needed. The Fraction class
	instance creation method will answer an Integer if it can."

	^Fraction rationalisedNumerator: anInteger denominator: self!

even
	"Answer whether the receiver is an even integer. Zero is considered even.
	Override superclass as we've a more efficient implementation."

	^(self bitAnd: 1) == 0!

factorial
	"Answer the <integer> factorial of the receiver. It is an error for the receiver to be
	negative."

	^self factorial2p!

factorial2p
	"Private - 2-partition fast factorial algorithm from 'Fast Computation of Factorials of Numbers',
	Thompson & Ugur."

	| x0 x1 x2 |
	self < 2 ifTrue: [^self < 0 ifTrue: [self error: 'negative factorial'] ifFalse: [1]].
	x0 := 2.
	x1 := 10.
	x2 := x0.
	self // 2 - 1 timesRepeat: 
			[x0 := x0 + x1.
			x1 := x1 + 8.
			x2 := x2 * x0].
	self odd ifTrue: [x2 := x2 * self].
	^x2!

factorialIterative
	"Private - Answer the factorial of the receiver. The receiver must be not less than 0."

	| factorial |
	self < 0
		ifTrue: [^self error: 'negative factorial' ].
 	factorial := 1.
	2 to: self asInteger do: [ :i | factorial := i * factorial ].
	^factorial!

floor
	"Answer the integer nearest the receiver (i.e. the receiver)."

	^self!

fractionPart
	"Answer a <number> of the same type as the receiver, representing the 
	fractional part of  the receiver."

	^0!

gcd: operand 
	"Answer the greatest common divisor of the receiver and the <integer>, operand, computed 
	using Euclid's algorithm. See Knuth vol. II"

	| u v |
	v := operand abs.
	u := self abs.
	[v == 0] whileFalse: 
			[| r |
			r := u \\ v.
			u := v.
			v := r].
	^u!

gcdbin: operand 
	"Answer the greatest common divisor of the receiver and the <integer>, operand, computed 
	using Stein's binary algorithm. See Knuth vol. II"

	| k u v t |
	u := self abs.
	v := operand abs.
	k := 0.
	[u even and: [v even]] whileTrue: 
			[k := k + 1.
			u := u bitShift: -1.
			v := v bitShift: -1].
	t := u even ifTrue: [u bitShift: -1] ifFalse: [v negated].
	
	[[t even] whileTrue: [t := t bitShift: -1].
	t > 0 ifTrue: [u := t] ifFalse: [v := t negated].
	t := u - v.
	t == 0] 
			whileFalse.
	^u bitShift: k!

greaterThanFloat: aFloat
	"Private - Answer whether the receiver is greater than the known Float, aFloat."

	^aFloat < self asFloat!

greaterThanFraction: aFraction
	"Private - Answer whether the receiver is greater than the known Fraction, aFraction"

	^aFraction numerator < (self * aFraction denominator)!

hash
	"Answer the <integer> hash value of the receiver."

	"Implementation Note: In order to satisfy the invariant that Floats that compare
	equal also have the same hash, we have to limit the precision of the hash by using 
	only the top hashBits bits of the absolute value of the receiver, xor'ing in the shift
	as a way of taking some account of the magnitude of the receiver.
	Thanks to John Brant for contributing this hash function."

	| bitCount shiftDistance |
	self negative ifTrue: [^self negated hash negated].
	bitCount := self highBit.
	^bitCount > self hashBits 
		ifTrue: 
			[| value |
			shiftDistance := self hashBits - bitCount + 1.
			value := (self bitShift: shiftDistance) + 1 bitShift: -1.
			value highBit > self hashBits 
				ifTrue: [(value bitShift: -1) bitXor: (shiftDistance - 1) abs]
				ifFalse: [value bitXor: shiftDistance abs]]
		ifFalse: [self]!

hex
	"Answer a <readableString> whose characters are a description of 
	the receiver in the hexadecimal."

	^self printStringRadix: 16 showRadix: true!

highBit
	"Answer the <integer> index of the most significant non-zero bit of the binary 
	representation of the receiver.
	N.B. This operation is not defined for negative integers."

	^self highByte highBit + (self digitLength - 1 bitShift: 3)!

highByte
	"Private - Answer the most significant radix-256 digit of the receiver."

	^self byteAt: self digitLength!

highPartSigned
	"Answers the high order signed word of the receiver (assumes the receiver is a machine word sized integer)."

	^(self bitShift: ##(VMConstants.HalfPtrBits negated)) lowPartSigned!

highWord
	"Answers the high order unsigned word of the receiver (assumes the receiver is a 32-bit Integer)."

	^(self bitShift: -16) bitAnd: 16rFFFF!

integerPart
	"Answer an <integer> representing the whole integer part of the receiver."

	^self!

isBitSet: index
	"Answer whether the index'th bit of the receiver is set (has the value 1), 
	where the least significant bit is considered to have index 1."

	^self anyMask: (1 bitShift: index-1)!

isInteger
	"Answer whether the receiver is an <integer>."

	^true!

isNull
	"Answer whether the receiver is 'null' (equal to zero)."

	^self == 0!

isSDWORD
	"Answer whether the receiver can be represented as a 32-bit two's complement signed integer
	(i.e. as an SDWORD)."

	^self >= ##(-2 raisedToInteger: 31) and: [self < ##(2 raisedToInteger: 31)]!

lcm: anInteger 
	"Answer the least common multiple of the receiver and the <integer> argument."

	| gcd |
	anInteger = 0 ifTrue: [^0].
	gcd := self gcd: anInteger.
	^gcd == 0 ifTrue: [1] ifFalse: [(self // gcd * anInteger) abs]!

lowBit
	"Answer the index of the lowest order bit of the receiver which is set."

	1 to: self basicSize
		do: 
			[:i | 
			| byte |
			byte := self byteAt: i.
			byte == 0 ifFalse: [^byte lowBit + ((i - 1) * 8)]].
	^0!

lowPart
	"Answers the low order unsigned word of the receiver (assumes the receiver is a machine word sized Integer, i.e. an INT_PTR)."

	^self bitAnd: VMConstants.HalfPtrMask!

lowPartSigned
	"Answers the low order signed word of the receiver (assumes the receiver is a machine word sized Integer)."

	| part |
	part := self lowPart.
	^part > VMConstants.HalfPtrMax 
		ifTrue: [(part bitXor: VMConstants.HalfPtrMask) bitInvert]
		ifFalse: [part]!

lowWord
	"Answers the low order word of the receiver."

	^self bitAnd: 16rFFFF.!

mask: integerMask set: aBoolean
	"Answer the result of setting/resetting the specified mask in the receiver."

	^aBoolean 
		ifTrue: [self maskSet: integerMask]
		ifFalse: [self maskClear: integerMask]
!

maskClear: anInteger
	"Answer a copy of the receiver with the bits of the argument, anInteger, masked out."

	^self bitAnd: anInteger bitInvert!

maskSet: anInteger
	"Answer a copy of the receiver with the bits of the argument, anInteger, masked in"

	^self bitOr: anInteger!

multiplyByFloat: aFloat
	"Private - Multiply the receiver by the known Float, aFloat. Answer the result."

	^aFloat * self asFloat!

multiplyByFraction: aFraction
	"Private - Answer the result of multiplying the receiver by the known Fraction, aFraction."

	^Fraction
		rationalisedNumerator: self * aFraction numerator
		denominator: aFraction denominator!

negated
	"Answer a <number> of the same type of the receiver
	which is its negation.

	Implementation Note: Overridden purely for improved performance."

	^0 - self!

negative
	"Answer whether the receiver is a negative number.
	Implementation Note: Override for performance only."

	^self < 0!

noMask: mask
	"Answer whether none of the bits that are set in the <integer> argument, mask,
	are also set in the receiver."

	^(self bitAnd: mask) == 0!

normalize
	"Private - Answer the receiver in its minimal representation (i.e. itself)."

	^self!

notNull
	"Answer whether the receiver is not 'null' (not equal to zero)"
	
	^(self == 0) == false!

printDigitsOn: aStream base: anInteger 
	"Private - Recursively print the digits of the receiver in base anInteger to aStream.
	N.B. The receiver MUST be positive for this to work correctly."

	self basicPrintDigitsOn: aStream base: anInteger!

printOn: aStream
	"Append the ASCII representation of the receiver to aStream.
	Although not strictly part of the ANSI protocol <number>, this method is the
	means by which Integer complies with that protocol in order to produce
	a literal representation of the receiver."

	self printOn: aStream base: 10 showRadix: false!

printOn: output base: base
	"Append a text representation of the receiver on the <puttableStream>, output,
	in the specified <integer> base with a radix prefix."

	self printOn: output base: base showRadix: true!

printOn: output base: base showRadix: flag
	"Append a text representation of the receiver on the <puttableStream>, output,
	in the specified <integer> base, showing a radix prefix if requested."

	self negative
		ifTrue: [ 
			output nextPut: $-.
			self negated printOn: output base: base showRadix: flag]
		ifFalse: [
			flag ifTrue: [base printOn: output. output nextPut: $r].
			self printDigitsOn: output base: base]!

printStringRadix: base
	"Answer a <readableString> whose characters are a description of 
	the receiver in the specified <integer> radix."

	^self printStringRadix: base showRadix: true!

printStringRadix: base showRadix: flag
	"Answer a String which represents the receiver in the radix, base (an Integer).
	The radix prefix is included if the boolean flag is true."

	| aStream |
	aStream := String writeStream: 16.
	self printOn: aStream base: base showRadix: flag.
	^aStream contents
!

quo: aNumber
	"Answer the integer quotient of the receiver divided by aNumber with 
	truncation toward zero (i.e. like C integer division)."

	^(self quoAndRem: aNumber) basicAt: 1
!

rounded
	"Answer the integer nearest the receiver."

	^self
!

setBit: index
	"Answer the Integer which results from setting the index'th bit of the receiver,
	where the least significant bit is considered to have index 1."

	^self maskSet: (1 bitShift: index-1)!

size
	"Integer's do not support indexed instance variables."

	^self shouldNotImplement!

subtractFromFloat: aFloat
	"Private - Subtract the receiver from the known Float, aFloat, and answer the result."

	^aFloat - self asFloat!

subtractFromFraction: aFraction
	"Private - Subtract the receiver from the known fraction, aFraction and answer the result.
	There is no need to normalise the result."

	^Fraction
		numerator: aFraction numerator - (self * aFraction denominator)
		denominator: aFraction denominator!

timesRepeat: aBlock 
	"Evaluate aBlock repeatedly, once for each integer from 1 to the floor of 
	the receiver."

	"Implementation Note: This message is normally inlined by the Compiler,
	but it is only able to make that optimization if the argument is a literal
	block. Although at first glance infinitely recursive, the most optimal 
	implementation is to exploit that inlining and implement this method
	in terms of itself."

	self timesRepeat: [aBlock value]!

truncated
	"Answer the integer nearest the receiver toward zero."

	^self
! !

ScaledDecimal comment:
'ScaledDecimal is a Number class to represent fixed point decimal numbers. It supports unbounded precision, with no practical limit to the number of digits before and after the decimal point.

ScaledDecimal conforms to the following ANSI protocols:
	Float
	magnitude
	number
	Object
	rational
	scaledDecimal

A ScaledDecimal represents a value as a Fraction and the number of digits after the decimal point. This representation allows us to take advantage of the implementation of unbounded rational numbers provided by Fraction with very small amount of simple code.

We are grateful to Richard A. Harmon for contributing his ANSI compliant ScaledDecimal implementation from which this class was derived.
'!
!ScaledDecimal class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

newFromNumber: aNumber scale: scaleInteger
	"Answer a new instance of me."

	^self basicNew
		setFraction: aNumber asFraction scale: scaleInteger;
		yourself!

one
	"Answer the receiver's representation of one."

	^self
		newFromNumber: 1
		scale: 0!

zero
	"Answer the receiver's representation of zero."

	^self
		newFromNumber: 0
		scale: 0
! !

!ScaledDecimal methodsFor!

- operand
	"Answer the difference between the receiver and the <number>
	argument, operand."

	^operand subtractFromScaledDecimal: self!

* operand
	"Answer the result of multiplying the receiver by the <number>
	argument, operand."

	^operand multiplyByScaledDecimal: self!

/ operand
	"Answer the result of dividing the receiver by <number> argument, 
	operand. Raise a <ZeroDivide> exception if the operand is zero."

	^operand divideIntoScaledDecimal: self!

// operand 
	"Answer the <integer> quotient defined by division with truncation toward negative infinity
	of the receiver by the <number> operand."

	^fraction // operand!

+ operand
	"Answer the sum of the receiver and the <number> argument, 
	operand."

	^operand addToScaledDecimal: self
!

< operand
	"Answer whether the receiver is less than the <number>, operand."

	^operand greaterThanScaledDecimal: self
!

addToScaledDecimal: operand
	"Private - Answer the <ScaledDecimal> result of adding the receiver
	to the known <ScaledDecimal>."

	^self species
		newFromNumber: operand asFraction + fraction
		scale: (self scale max: operand scale)!

asFloat
	"Answer the receiver represented as the nearest possible <Float>."

	^fraction asFloat
!

asFraction
	"Answer an <integer> or <fraction> approximating the receiver."

	^fraction!

asScaledDecimal: newScale
	"Answer a new <ScaledDecimal>, with a fractional precision of scale, 
	which most nearly approximates the receiver."

	^self species
		newFromNumber: fraction
		scale: newScale!

coerce: coercee
	"Private - Coerce the <ArithmeticValue>, coercee, which must be of a lower generality than the receiver, to be the 
	same type as the receiver."

	^coercee asScaledDecimal: scale
!

denominator
	"Answer the <integer> denominator of the receiver."

	^fraction denominator
!

displayOn: target 
	"Append, to the <puttableStream, aStream, a String whose characters are a 
	representation of the receiver as a user would want to see it."

	| scaler quoRem num denom scaled |
	scaler := 10 raisedToInteger: scale.
	num := fraction numerator.
	denom := fraction denominator.
	scaled := (num * scaler + (denom bitShift: -1)) // denom.
	num negative 
		ifTrue: 
			[target nextPut: $-.
			scaled := scaled negated].
	quoRem := scaled quoAndRem: scaler.
	(quoRem at: 1) printOn: target.
	scale > 0 
		ifTrue: 
			[target nextPut: $..
			scale timesRepeat: 
					[| rem |
					rem := (quoRem at: 2) * 10.
					quoRem := rem quoAndRem: scaler.
					target nextPut: (Character digitValue: (quoRem at: 1))]]!

divideIntoScaledDecimal: operand
	"Private - Answer the result of dividing the known <ScaledDecimal>, operand, by the receiver."

	^self species
		newFromNumber: operand asFraction / fraction
		scale: (scale max: operand scale)!

fractionPart
	"Answer a <number> of the same type as the receiver, representing the 
	fractional part of  the receiver."

	^self species
		newFromNumber: fraction fractionPart
		scale: scale!

generality
	"Private - Answer the Smalltalk generality of the receiver, used for performing type conversions.
	ScaledDecimals are considered more general than Fractions but less general than Floats."

	"There is some controversy as to whether this is the correct generality for ScaledDecimals.
	Theoretically ScaledDecimals are more general than Floats, however traditionally Floats
	have been considered more general than Fractions although they clearly aren't (perhaps
	this arrangement was chosen for reasons of efficiency). Therefore making ScaledDecimals
	sit in between fits with the historic arrangements. It may be that the whole scheme needs to
	be altered for ANSI compatibility (or that the ANSI standard needs to be altered for
	compatibility with existing applications)."

	^35!

greaterThanScaledDecimal: comperand
	"Private - Answer whether the receiver is greater than the known <ScaledDecimal>, comperand."

	^comperand asFraction < fraction!

hash
	"Answer the <integer> hash value for the receiver." 

	^fraction hash
!

integerPart
	"Answer a <ScaledDecimal> representing the integral part of the receiver."

	^self species
		newFromNumber: fraction integerPart
		scale: scale!

isZero
	"Answer whether the receiver is equal to its class' zero"

	^fraction isZero!

multiplyByScaledDecimal: operand
	"Private - Multiply the receiver by the known <ScaledDecimal>, operand,
	answering the result."

	^self species
		newFromNumber: operand asFraction * fraction
		scale: (scale max: operand scale)!

negated
	"Answer a <number> of the same type of the receiver
	which is its negation."

	^self species
		newFromNumber: fraction negated
		scale: scale!

numerator
	"Answer the <integer> numerator of the receiver."

	^fraction numerator
!

printOn: target
	"Append, to the <puttableStream>, target, a string whose characters are a 
	the same as those which would result from sending a #printString
	message to the receiver."

	self displayOn: target.
	target nextPut: $s!

raisedToInteger: operand
	"Answer the receiver raised to the <integer> power, operand."

	^self species
		newFromNumber: (fraction raisedToInteger: operand)
		scale: self scale
!

reciprocal
	"Answer a <ScaledDecimal> which is the reciprocal of the receiver (i.e. 1/receiver).
	Raise a ZeroDivide exception if the receiver is zero.
	Implementation Note: Override because we can implement this much more
	efficiently by simply flipping over our Fraction (done in its own efficient reciprocal)."

	^self species
		newFromNumber: fraction reciprocal
		scale: scale
!

scale
	"Answer an <integer> which represents the total number of digits used to 
	represent the fraction part of the receiver, including trailing zeroes."

	^scale
!

setFraction: f scale: s 
	"Private - Initialize the receiver's identity variables."

	fraction := f.
	scale := s.
	self isImmutable: true!

subtractFromScaledDecimal: operand
	"Private - Answer the result of subtracting the receiver from the 
	known <ScaledDecimal>, operand."

	^self species
		newFromNumber: operand asFraction - fraction
		scale: (scale max: operand scale)!

truncated
	"Answer the <integer> nearest the receiver toward zero."

	^fraction truncated
! !

LargeInteger comment:
'Class LargeInteger is the class of Integers which are outside the range of SmallIntegers (i.e. outside (SmallInteger minimum..SmallInteger maximum). Basically any Integer requiring more than 31-bits to be represented in 2''s complement will be a LargeInteger.

LargeIntegers in Dolphin do not follow the standard signed-magnitude radix-256 Smalltalk representation, with separate subclasses for positive and negative integers. Dolphin''s LargeIntegers follow standard machine representation, in that they are 2''s complement, 32-bit granular (i.e. they might have 32, 64, 96, ...n*32 bits). This representation has the dual advantages of higher performance, and simplified external interfacing. In particular the 32 and 64-bit Integers have the same representation externally as they do in Dolphin. Note that all integers are considered immutable - attempts to update the individual bytes will fail.

LargeInteger includes high performance primitive implementations for the common arithmetical operations and bit manipulations.'!
!LargeInteger class methodsFor!

fromBytes: bytes 
	"Answer an instance of the receiver instantiated from the the byte object, bytes,
	which is assumed to contain a positive Integer magnitude."

	| size answer |
	size := bytes size.
	answer := self basicNew: (size roundUpTo: 4) + 4.
	1 to: size do: [:i | answer basicAt: i put: (bytes basicAt: i)].
	answer isImmutable: true.
	^answer normalize!

fromSmallInteger: anInteger 
	"Private - Answer an instance of the receiver representing the SmallInteger value,
	anInteger. Note that the result is NOT normalized, as otherwise the answer
	would just be the SmallInteger!! Because the answer is not normalized, it is
	not strictly a valid LargeInteger in all circumstances, hence this routine is 
	private."

	^(self basicNew: VMConstants.IntPtrSize)
		intPtrAtOffset: 0 put: anInteger;
		isImmutable: true;
		yourself!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

new: anInteger
	"Private - Answer a new LargeInteger of the requested number of 32-bit digits."

	^self basicNew: (anInteger bitShift: 2)!

new64
	"Private - Answer a new 64-bit LargeInteger.
	N.B. The answer is not a valid LargeInteger since zero is a SmallInteger."

	^self basicNew: 8! !

!LargeInteger methodsFor!

- operand
	"Answer a <number> which is the difference between the receiver and the <number> argument, 
	operand."

	<primitive: 22>
	^operand subtractFromInteger: self!

* operand
	"Answer the <number> result of multiplying the receiver by 
	the <number> argument, operand."

	<primitive: 29>
	^operand multiplyByInteger: self!

/ operand
	"Answer the <number> which is the result of dividing the receiver by <number> argument, 
	operand. If their is any remainder, then the result will be a <Fraction>. Raise a <ZeroDivide> 
	exception if the operand is zero."

	<primitive: 30>
	^operand divideIntoInteger: self!

// operand
	"Answer a <number> which is the quotient resulting from dividing the receiver 
	by the <number> argument, operand,  with truncation towards negative infinity."

	<primitive: 32>
	^super // operand!

\\ operand
	"Answer the <integer> remainder defined by division with truncation toward negative 
	infinity; e.g. 7 \\ 2 = 1, -7 \\ 2 = 1, 7 \\ -2 = -1. 
	This is the modulo operation, but it is not the same as C modulo (%) which truncates 
	towards zero (use #mod:). Report an error if the aNumber is zero."

	<primitive: 31>
	^super \\ operand!

+ operand
	"Answer a <number> which is the sum of the receiver and 
	the <number> argument, operand."

	<primitive: 21>
	^operand addToInteger: self!

< operand
	"Answer whether the receiver is less than the <number>, operand."

	<primitive: 23>
	^super < operand!

<= operand
	"Answer whether the receiver is less than or equal to the <number>, operand."

	<primitive: 25>
	^super <= operand!

= comperand
	"Answer whether the receiver is equal to the <Object>, comperand."

	<primitive: 27>
	^super = comperand!

> operand
	"Answer whether the receiver is greater than the <number>, operand."

	<primitive: 24>
	^super > operand!

>= aNumber
	"Answer whether the receiver is greater than or equal to aNumber."

	<primitive: 26>
	^super >= aNumber!

addToInteger: anInteger
	"Private - Add the receiver to the known Integer, anInteger. 
	We should only normally get here if anInteger is a SmallInteger.
	Implementation Notes: As addition is commutative we can use the 
	large integer add primitive. We do not supersend if the primitive
	fails because it does not fail for Integer arguments, and a non-Integer
	argument breaks the preconditions of this method.

	Primitive Failure Reasons:
		0	- anInteger is not an Integer.
	"

	<primitive: 21>
	^self primitiveFailed!

asFloat
	"Answer the floating point representation of the receiver. Some precision may be lost. The
	result will be the nearest fp value calculated using IEEE round-to-nearest even rounding.

	Primitive Failure Reasons: 
		1 - The receiver has more than 64-bits "

	| result nTruncatedBits |
	<primitive: 167>
	result := self abs.
	nTruncatedBits := result highBit - Float precision.
	nTruncatedBits > 0 
		ifTrue: 
			[| exponent mask trailingBits carry |
			mask := (1 bitShift: nTruncatedBits) - 1.
			trailingBits := result bitAnd: mask.
			carry := trailingBits bitShift: 1 - nTruncatedBits.
			result := result bitShift: nTruncatedBits negated.
			exponent := nTruncatedBits.
			(carry isZero or: [(trailingBits bitAnd: (mask bitShift: -1)) isZero and: [result even]]) 
				ifFalse: [result := result + 1].
			^self positive 
				ifTrue: [result asFloat timesTwoPower: exponent]
				ifFalse: [result asFloat negated timesTwoPower: exponent]].

	"Should never reach this code as the primitive should handle the non-truncated case"
	result := 0.0.
	self basicSize to: 1
		by: -1
		do: [:i | result := result * 256.0 + (self byteAt: i) asFloat].
	^result!

bitAnd: mask
	"Answer an integer whose bits are the logical AND of the
	bits of the 2's complement representation of the receiver and 
	the bits of the 2's complement representation of the Integer 
	argument, mask. Note that this implies sign extension of the
	shorter of the two operands.

	Implementation Note: Because Dolphin Integers are always represented
	in 2's complement, this is a very fast operation.
	
	Primitive Failure Reasons:
		0	-	The argument is not an Integer (large or small).
	"

	<primitive: 34>
	^self primitiveFailed!

bitInvert
	"Answer an integer whose bits are the complement of the receiver."

	<primitive: 38>
	^self primitiveFailed!

bitOr: anInteger
	"Answer an integer whose bits are the logical OR of the
	receiver's bits and those of the argument, anInteger.

	Primitive Failure Reasons:
		0	-	The argument is not an Integer (large or small).
	"

	<primitive: 35>
	^self primitiveFailed!

bitShift: delta
	"Answer an integer which is the receiver bits shifted by the
	SmallInteger argument, delta, bit positions. The shift direction
	is left if delta is positive, or right if delta is negative).
	Note that the shift is arithmetic, rather than logical, so sign
	bits are shifted in from the left on right shifts.

	Primitive Failure Reasons:
		0	- Argument, delta, is not a SmallInteger

	The superclass implementation is relatively slow, but does support 
	LargeInteger deltas!! However, it is rather unlikely you will have
	enough memory to store the result (you'll need 256Mb or more)."

	<primitive: 37>
	^super bitShift: delta!

bitXor: anInteger
	"Answer an integer whose bits are the logical XOR of the
	receiver's bits and those of the argument, anInteger.

	Primitive Failure Reasons:
		0	-	The argument is not an Integer (large or small).
	"

	<primitive: 36>
	^self primitiveFailed!

byteAt: index 
	"Private - Answer the byte (radix 256 digit) at index in the receiver.
	Note that the receiver is in two's complement representation, so
	the answer may be negative."

	| size |
	size := self basicSize.
	^index < size 
		ifTrue: [self basicAt: index]
		ifFalse: 
			[index == size 
				ifTrue: 
					[| answer |
					answer := self basicAt: index.
					answer > 127 ifTrue: [answer - 256] ifFalse: [answer]]
				ifFalse: [self signBit * -1]].
	#todo	"Either remove or implement more efficiently (may be useful for Smalltalk LI algorithms"!

byteSize
	"Private - Answer the number of bytes in the receiver's 2's complement
	representation."

	^self basicSize!

digitAt: anInteger 
	"Answer the n'th byte of 2's complement representation of the receiver."

	"Implementation Note: As Dolphin's LargeIntegers are stored directly in 2's complement
	32-bit digits, we can make use of the standard byte accessing primitive, passing potential
	out of bounds accesses to the superclass implementation."

	<primitive: 60>
	^super digitAt: anInteger!

digitLength
	"Answer the number of significant radix-256 digits necessary to
	represent the absolute magnitude of the receiver."

	"Implementation Note: Superclass implementation will work, but this is better than twice as fast"

	| size abs |
	abs := self abs.
	size := abs basicSize.
	[(abs basicAt: size) == 0 and: [size > 0]] whileTrue: [size := size - 1].
	^size!

dwordAtOffset: anInteger
	"Private - Answer the unsigned 4 byte integer at offset (i.e. zero relative) 
	anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds (not in the range 1..receiver's size - 4)."

	<primitive: 120>
	^self primitiveFailed!

dwordAtOffset: anInteger put: anObject 
	"Private - Store an unsigned 4 byte value at byte offset anInteger within the receiver. Note
	that this will fail unless the LargeInteger has first been marked as mutable."

	<primitive: 121>
	^anObject isInteger 
		ifTrue: 
			[| code |
			code := Processor activeProcess primitiveFailureCode.
			code < 2 
				ifTrue: 
					["Erroneous offset parameter"
					code == 0 
						ifTrue: [Error nonIntegerIndex: anInteger]
						ifFalse: 
							[self isImmutable 
								ifTrue: [Processor constWriteSignal signalWith: self]
								ifFalse: [self errorSubscriptBounds: anInteger]]]]
		ifFalse: [self dwordAtOffset: anInteger put: anObject asInteger]!

generality
	"Private - Answer the generality of the receiver in the Smalltalk number system.
	Integers are the lowest generalities (20 Large, 10 Small)."

	^20!

greaterThanInteger: anInteger
	"Private - Answer whether the receiver is greater than the known integer, anInteger."

	<primitive: 24>
	^super greaterThanInteger: anInteger!

hash
	"Answer the <integer> hash value of the receiver."

	"Implementation Note: It is assumed here that #hashBits must be >= SmallIntegerMax highBit.
	This is 30 on a 32-bit host, or 62 on a 64-bit host, and the minimum LargeInteger value is
	(2**30) or (2**62) respectively.."

	| shiftDistance highBits |
	self negative ifTrue: [^self negated hash negated].
	shiftDistance := self hashBits - self highBit + 1.
	highBits := (self bitShift: shiftDistance) + 1 bitShift: -1.
	^highBits highBit > self hashBits 
		ifTrue: [(highBits bitShift: -1) bitXor: (shiftDistance - 1) abs]
		ifFalse: [highBits bitXor: shiftDistance abs]!

intPtrAtOffset: anInteger put: anObject 
	"Private - Store anObject as a signed machine-word sized integer at anInteger offset in the receiver. anInteger must 
	be representable in a machine word. Uses the intPtrAtOffset:put: primitive. This is intended only as a way to initialize
	a new LargeInteger with a SmallInteger value."

	| value |
	<primitive: 183>
	value := anObject asInteger.
	value byteSize > VMConstants.IntPtrSize ifFalse: [^self errorCantHold: anObject].
	1 to: VMConstants.IntPtrSize
		do: [:index | self basicAt: anInteger + index put: (value digitAt: index)].
	^anObject!

isZero
	"Answer whether the receiver is zero.
	LargeIntegers cannot be zero, because there is a more compact representation
	(i.e. SmallInteger 0)."

	^false!

limbSize
	"Private - Answer the number of 32-bit limbs in the receiver."

	^self basicSize bitShift: -2!

multiplyByInteger: anInteger
	"Private - Answer the result of multiplying the receiver by the argument, anInteger.
	N.B. If we get in here, then anInteger must be small, in which case we just perform
	the arithmetic in reverse (at present the SmallInteger prim's cannot handle LargeInteger arguments,
	but the the LI prims can handle SmallInteger args).
	The primitive should not fail for an Integer argument, so we treat that as an error."

	<primitive: 29>
	^self primitiveFailed!

negated
	"Answer the negative value of the receiver.
	The primitive does not fail."

	<primitive: 39>
	^self bitInvert + 1!

normalize
	"Private - Answer the receiver in its minimal 2's complement representation.
	The answer may be the receiver, a compressed version of the receiver (without
	leading sign digits), or a SmallInteger."

	<primitive: 28>
	^self primitiveFailed!

printDecimalDigitsOn: aStream 
	"Private - Append the ASCII representation (radix 10) of the receiver to aStream. At least
	twice as fast as #basicPrintDigitsOn:base: for base 10."

	| quotient digits index |
	digits := ByteArray new: self basicSize * 3.
	index := 1.
	quotient := self.
	[quotient isImmediate] whileFalse: 
			[| quoAndRem |
			quoAndRem := quotient quoAndRem: 100.
			digits at: index put: (quoAndRem at: 2).
			index := index + 1.
			quotient := quoAndRem at: 1].
	quotient printOn: aStream.
	[(index := index - 1) > 0] whileTrue: 
			["Note that the compiler will fold the strings into a single literal"
			aStream
				nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: (digits at: index) // 10 + 1);
				nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: (digits at: index) \\ 10 + 1)]!

printDigitsOn: aStream base: anInteger 
	"Private - Recursively print the digits of the receiver in base anInteger to aStream.
	N.B. The receiver MUST be positive for this to work correctly."

	anInteger == 10 
		ifTrue: [self printDecimalDigitsOn: aStream]
		ifFalse: [self basicPrintDigitsOn: aStream base: anInteger]!

quoAndRem: aNumber
	"Private- Answer a two element array containing the integer quotient of 
	the receiver divided by aNumber with truncation toward zero (i.e. like C 
	integer division), and the corresponding remainder.
	
	Primitive Failure Reasons:
		0	- aNumber is not an Integer.
	"

	<primitive: 33>
	^aNumber quoAndRemFromInteger: self!

quoAndRemFromInteger: anInteger 
	"Private - Answer a two element Array containing the quotient and remainder
	resulting from dividing the integer receiver into the argument, anInteger.
	Truncation is towards zero. 
	Implementation Note: We should normally only be here when attempting
	to divide a SmallInteger by a LargeInteger, the result of which, by the
	definition must be (0, <self>), since ANY normalized LargeInteger must be greater
	in absolute magnitude than any SmallInteger, EXCEPT the special case of the
	largest negative SmallInteger the absolute value of which is a LargeInteger."

	^(anInteger == VMConstants.SmallIntegerMin and: [self = ##(VMConstants.SmallIntegerMin negated)]) 
		ifTrue: [Array with: -1 with: 0]
		ifFalse: [Array with: 0 with: anInteger]!

rem: operand
	"Answer the <number> remainder resulting from division of the receiver by
	the <number>, operand, with truncation toward zero; 
		e.g. 7 rem: 2 = 1, -7 rem: 2 = -1 (whereas -7 \\ 2 = 1)
	The answer is always of the same sign as the receiver, regardless of
	the sign of the argument."

	^(self quoAndRem: operand) basicAt: 2!

replaceBytesOf: aByteObject from: start to: stop startingAt: fromStart 
	"Private - Standard method for transfering bytes from one variable
	byte object to another, normally double dispatched from #replaceFrom:to:with:startingAt:

	Primitive Failure Reasons:
		0 	- fromStart is not a SmallInteger.
		1	- stop is not a SmallInteger.
		2	- start is not a SmallInteger.
		3	- aByteObject is not a byte object
		4	- 'from' or 'to' interval is out-of-bounds
	"

	<primitive: 142>
	^self primitiveFailed!

sdwordAtOffset: anInteger 
	"Private - Answers the signed 4 byte integer at byte offset anInteger in the receiver.

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger
		1 -	anInteger is out of bounds."

	<primitive: 122>
	^self primitiveFailed!

signBit
	"Private - Answer the receiver's sign bit. This will be 0 for positive integers
	and 1 for negative integers."

	^(self basicAt: self basicSize) bitShift: -7!

subtractFromInteger: anInteger 
	"Private - Subtract the receiver from the known integer, anInteger
	and answer the result.
	N.B. The negated receiver may not be large if the receiver is VMConstants.SmallIntegerMax+1
	and therefore it is better to send #+ that #addToInteger:."

	^self negated + anInteger! !

SmallInteger comment:
'Class SmallInteger is an optimized representation of 31-bit 2''s complement integers.

Wherever an Integer may be represented as a SmallInteger, then its only truly valid representation is as a SmallInteger. (i.e their "normalized" representation is as a SmallInteger). The range is such that the majority of integers used for counting and indexing, and even arithmetical tasks, will be SmallIntegers.'!
!SmallInteger class methodsFor!

basicNew
	"SmallIntegers are immediate objects, and cannot be instantiated directly, they
	can only be created by literal references or by operations on other SmallIntegers."

	^self shouldNotImplement!

hasImmediateInstances
	"Answer whether the receiver's instances are immutable objects encoded entirely 
	in an Oop (e.g. SmallIntegers)."

	^true!

maxBytes
	"Answer the largest number of radix-256 digits which can be represented
	in a SmallInteger (31-bits, so not all 4 byte numbers will fit)."

	^VMConstants.IntPtrSize!

maximum
	"Answer the largest positive integer value which can be
	represented as a SmallInteger."

	^VMConstants.SmallIntegerMax!

minimum
	"Answer the largest negative integer value which can be 
	represented as a SmallInteger"

	^VMConstants.SmallIntegerMin! !

!SmallInteger methodsFor!

- operand
	"Answer the result of subtracting the <number>, operand, from the receiver.

	Primitive failure codes:
		0	- operand is not a SmallInteger."

	<primitive: 14>
	^operand subtractFromInteger: self!

& anInteger
	"Answer the result of a bitwise AND between the receiver and the argument, anInteger.
	N.B. Use of #bitAnd: is preferred (even though it is more typing) because it is
	a special selector (i.e. it is more compact and faster), and is portable.
	
	Primitive failure codes:
		0	- anInteger is not a SmallInteger."

	<primitive: 40>
	^anInteger bitAnd: self!

* aNumber
	"Answer the result of multiplying the receiver by aNumber. 

	Primitive failure codes:
		0	- aNumber is not a SmallInteger.
		1	- the result requires more than 31-bits to represent. 

	When the primitive fails we use a double dispatch to ask aNumber to multiply the receiver, 
	which we know to be a kind of Integer, by itself."

	<primitive: 9>
	^aNumber multiplyByInteger: self!

/ operand
	"Answer the result of dividing the receiver by the <number>, operand.
	Attempted division by zero will cause a <ZeroDivide> exception to be
	raised.

	Primitive failure codes:
		0 -	aNumber is not a SmallInteger.
		2 -	the result cannot be represented exactly as an Integer."

	<primitive: 10>
	^operand divideIntoInteger: self!

// aNumber
	"Answer the integer quotient defined by division with truncation toward negative
	infinity.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger.

	Attempted division by zero will cause a ZeroDivide exception to be
	raised by the VM."

	<primitive: 12>
	^super // aNumber!

\\ aNumber
	"Answer the integer remainder defined by division with trunction toward negative infinity. This is 
	the modulo operation. N.B. This is not the same as the C/C++ modulus operator (%), which always
	truncates towards zero.

	Primitive failure codes:
		0 -	aNumber is not a SmallInteger.

	Attempted division by zero will cause a ZeroDivide exception to be
	raised by the VM."

	<primitive: 11>
	^super \\ aNumber!

_deepCopy: anIdentityDictionary
	^self!

| anInteger
	"Answer the result of a bitwise OR between the receiver and the argument, anInteger.
	N.B. Use of #bitOr: is preferred (even though it is more typing) because it is
	a special selector (i.e. it is more compact and faster), and is portable.

	Primitive failure codes:
		0	- anInteger is not a SmallInteger."

	<primitive: 41>
	^anInteger bitOr: self!

+ aNumber
	"Add the argument, aNumber, to the receiver and answer the result.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 15>
	^aNumber addToInteger: self!

< aNumber
	"Answer whether the receiver is less than the argument, aNumber.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 18>
	^aNumber greaterThanInteger: self!

<< anInteger
	"Answer the result of shifting the receiver left anInteger bits."

	<primitive: 43>
	^self bitShift: anInteger!

<= aNumber
	"Answer whether the receiver is numerically less than or equal to the argument aNumber.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 20>
	^super <= aNumber!

= aNumber
	"Answer whether the receiver is equal to aNumber. Numbers are considered
	equal if their difference is zero.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 16>
	^super = aNumber!

> aNumber
	"Answer whether the receiver is greater than the argument, aNumber.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 19>
	^super > aNumber!

>= aNumber
	"Answer whether the receiver is greater than or equal to the argument, aNumber.

	Primitive failure codes:
		0	- aNumber is not a SmallInteger."

	<primitive: 17>
	^super >= aNumber!

allMask: mask
	"Answer whether all of the bits that are set in the <integer> mask are also set in 
	the receiver.

	Primitive failure reasons:
		0 -	mask is not a SmallInteger."

	<primitive: 146>
	^super allMask: mask!

anyMask: mask
	"Answer whether any of the bits that are set in the <integer> mask are also set 
	in the receiver.

	Primitive failure reasons:
		0 -	mask is not a SmallInteger."

	<primitive: 145>
	^super anyMask: mask!

asFloat
	"Answer the floating point representation of the receiver. The primitive should not fail."

	<primitive: 168>
	^self primitiveFailed!

basicAt: index
	"Private - Answer the receivers indexed instance variable at the
	argument, index. Not valid for immediate objects,  which have no indexable
	variables as such.
	Do not remove this method, as the primitive implementation in Object
	will behave unexpectedly for immediate objects."

	^self shouldNotImplement!

basicAt: index put: value
	"Private - Replace the receivers indexed instance variable at the
	argument, index, with the argument, value. Not valid for immediate,
	objects which are constants.
	Do not remove this method, as the primitive implementation in Object
	will behave unexpectedly for immediate objects."

	^self shouldNotImplement!

basicShallowCopy
	"SmallIntegers have an immediate representation - i.e. they have only
	one representation for a particular value - and are immutable."

	^self
!

basicSize
	"Private - We must override the primitive implementation in Object,
	which does not expect to be invoked  for SmallInteger receivers"

	^0!

basicYourAddress
	"Private - Answer the address of the bytes of the receiver. 
	Assumes the receiver is an address."

	^self!

bitAnd: anInteger
	"Answer an Integer whose bits are the logical AND of the receiver's bits
	and those of the argument anInteger. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger."

	<primitive: 40>
	^anInteger bitAnd: self!

bitOr: anInteger
	"Answer an Integer whose bits are the logical OR of the receiver's bits
	and those of the argument anInteger. 

	Primitive failure reasons:
		0 -	anInteger is not a SmallInteger."

	<primitive: 41>
	^anInteger bitOr: self!

bitShift: anInteger
	"Answer an Integer whose value (in two's-complement representation) is the receiver's value 
	(in 2's complement) shifted left by the number of bits indicated by the argument anInteger. 
	Negative arguments shift right in left shifts. The sign bit is extended in right shifts.
	A right shift of more than 30 bits will lose all significant bits, so the result will be 0
	for positive receivers, and -1 for negative receivers (sign extension).

	Primitive failure codes:
		0 -	anInteger is not a SmallInteger.
		1 -	the result overflowed the SmallInteger range."

	<primitive: 43>
	^(LargeInteger fromSmallInteger: self) bitShift: anInteger!

bitXor: mask
	"Answer an <integer> whose bits are the logical XOR of the receiver's
	bits and those of the argument, mask.

	Primitive failure codes:
		0 -	mask is not a SmallInteger."

	<primitive: 42>
	^mask bitXor: self!

byteAt: index
	"Private - Answer the byte at index, index, of the absolute value of the
	receiver (i.e. magnitude  only representation).

	Primitive failure reasons:
		0 -	the argument, index, is not a SmallInteger
		1 -	the argument index is not in the range 1..4."

	<primitive: 158>
	^index > self byteSize
		ifTrue: [0]
		ifFalse: [self errorSubscriptBounds: index].

	"Equivalent to:
		^(self abs bitShift: 1 - index * 8) bitAnd: 16rFF"!

byteSize
	"Private - Answer the number of bytes in the receiver's 2's complement
	representation."

	^VMConstants.IntPtrSize!

coerce: anArithmeticValue
	"Private - Answer anArithmeticValue coerced to be a SmallInteger."

	^anArithmeticValue truncated
!

deepCopy
	"SmallIntegers have an immediate representation - i.e. they have only
	one representation for a particular value - and are immutable."

	^self
!

generality
	"Private - Answer the generality in the Smalltalk number system of the receiver.
	SmallIntegers are the lowest generality (10)"

	^10
!

hash
	"Answer the SmallInteger hash value for the receiver (itself)."

	^self!

highBit
	"Answer the index (1 based) of the high order bit of the positive 2's complement 
	representation of the receiver. e.g.

		SmallInteger maximum highBit

	Implementation Note: Although this can be implemented relatively efficiently
	in Smalltalk by using a series of conditional tests and a table lookup,
	it can be implemented in a single instruction in x86 assembler, hence the
	(very fast) primitive.

	Primitive Failure Reasons:
		0	- Negative receiver (high bit would always be sign bit!!!!)
	"

	<primitive: 54>
	^self primitiveFailed!

identityHash
	"Answer the <integer> identity hash value for the receiver (itself)."

	"Implementation Note: We must override because the identity hash primitive does not work
	for immediate objects."

	^self!

instVarAt: index
	"Private - Answer the receivers instance variable at the argument, index. 
	Not valid for SmallIntegers,  which have no instance variables in the true sense.
	Do not remove this method, as the primitive implementation in Object
	will behave unexpectedly for SmallIntegers."

	^self shouldNotImplement!

instVarAt: index put: value
	"Private - Replace the receivers instance variable at the argument, index, 
	with the argument, value. Not valid for SmallIntegers, which are constants.
	Do not remove this method, as the primitive implementation in Object
	will behave unexpectedly for SmallIntegers."

	^self shouldNotImplement!

isImmediate
	"Answer whether the receiver has an immediate representation."

	^true
!

isZero
	"Answer whether the receiver is zero. SmallIntegers can be zero, and there is a
	very fast check."

	^self == 0!

lowBit
	"Answer the index of the lowest bit of the receiver which is set.
	Unlike #highBit, this is meaningful for negative numbers too.
	Implementation Note: The primitive makes use of the Intel
	BSF instruction."

	| i t |
	<primitive: 152>
	self == 0 ifTrue: [^self].
	t := self.
	i := 1.
	[(t bitAnd: 16rF) == 0] whileTrue: [
		i := i + 4.
		t := t bitShift: -4].
	[(t bitAnd: 1) == 0] whileTrue: [
		i := i + 1.
		t := t bitShift: -1].
	^i!

multiplyByInteger: anInteger 
	"Private - Answer the result of multiplying the receiver by the argument, anInteger.

	Implementation Note: Invoked when SmallInteger multiplied by another SmallInteger but the
	result overflows the SmallInteger range (a fairly common occurrence). The superclass
	implementation does not work because it goes through the generic coercion mechanism, which
	does not expect to be invoked for two numbers of the same generality."

	^(LargeInteger fromSmallInteger: self) * anInteger!

printString
	"Answer the <readableString> representation of the receiver in base 10."

	"Implementation Note: Although this method is strictly not necessary
	(SmallInteger>>printOn:base:showRadix: makes it redundant), printing SmallIntegers is such a
	common operation that it is worth providing an optimised version generating a String."

	| value aString i |
	<primitive: 44>
	(value := self) < 0 ifTrue: [^'-' , self negated printString].
	i := ##(VMConstants.SmallIntegerMax log truncated + 1).
	aString := String new: i.
	[value < 10] whileFalse: 
			[aString at: i put: (Character digitValue: value \\ 10).
			i := i - 1.
			value := value // 10].
	aString at: i put: (Character digitValue: value \\ 10).
	^aString copyFrom: i to: aString size!

quo: aNumber
	"Answer the integer quotient defined by division with truncation toward zero.

	Primitive failure codes:
		0 -	aNumber is not a SmallInteger.

	Attempted division by zero will cause a ZeroDivide exception to be
	raised by the VM."

	<primitive: 53>
	^(aNumber quoAndRemFromInteger: self) basicAt: 1
!

quoAndRem: aNumber
	"Answer a 2-element array containing the integer quotient and remainder
	resulting from division of the receiver by the argument with truncation 
	toward zero.

	Primitive failure codes:
		0 -	aNumber is not a SmallInteger.

	Attempted division by zero will cause a ZeroDivide exception to be
	raised by the VM."

	<primitive: 13>
	^aNumber quoAndRemFromInteger: self!

shallowCopy
	"SmallIntegers have an immediate representation - i.e. they have only
	one representation for a particular value - and are immutable."

	^self
!

species
	"Answer the 'species' of the receiver.
	Implementation Note: The primitive superclass implementation
	will fail for immediate classes, so we must override here."

	^SmallInteger!

yourAddress
	"Answer the address of the bytes of the receiver. 
	Assume that the integer is being used as an address, so answer self."

	^self! !

VariableBinding comment:
''!
!VariableBinding methodsFor!

displayOn: aStream 
	"Append a short textual description of the receiver to aStream."

	aStream display: key! !

MessageSendAbstract comment:
'A MessageSendAbstract is the abstract base class of fully closed <Message>s, that include a receiver object, a message selector, and an array of sufficient arguments. As a fully closed valuable, Message Sends can be evaluated by sending them the #value message, and they can frequently be employed where a <BlockClosure> might otherwise be used.

Athough Message Sends are complete in themselves, they also respond to the valuable messages which take arguments. The general principle is that the supplied arguments supplant those stored in the Message Send according to some algorithm determined by the particular subclass.'!
!MessageSendAbstract class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

receiver: anObject selector: aSymbol
	"Answer a new instance of the receiver with the receiver, anObject, and selector, 
	aSymbol"

	^self 
		receiver: anObject
		selector: aSymbol
		arguments: #()!

receiver: anObject selector: aSymbol argument: aParameter
	"Answer a new instance of the receiver with the receiver, anObject, selector, 
	aSymbol, and argument, anObject"

	^self 
		receiver: anObject
		selector: aSymbol
		arguments: (Array with: aParameter)!

receiver: anObject selector: aSymbol arguments: anArray 
	"Answer a new instance of the receiver with the receiver, anObject, selector, 
	aSymbol, and arguments, anArray"

	^(self new)
		receiver: anObject;
		setSelector: aSymbol arguments: anArray;
		yourself!

selector: aSymbol arguments: anArray 
	"Answer a new instance of the receiver with selector, aSymbol, and arguments, anArray"

	^self 
		receiver: nil
		selector: aSymbol
		arguments: anArray! !

!MessageSendAbstract methodsFor!

= aMessageSend
	"Answer true if the receiver and aMessage are equal.
	Since we override #= we also override hash."

	^super = aMessageSend and: [self receiver == aMessageSend receiver]!

deferredValue
	"Answer a <niladicValuable> that begins evaluating the receiver asynchronously,
	and which when evaluated will synchronously supply the result."

	^self deferredValueAt: Processor activePriority!

deferredValueAt: priority
	"Answer a <niladicValuable> that begins evaluating the receiver asynchronously
	at the specified <Process> priority, and which when evaluated will synchronously 
	supply the result."

	^DeferredValue evaluate: self at: priority!

forwardTo: anObject
	"Send the receiver Message to anObject for evaluation, 
	answering the result"

	^self forwardTo: anObject withArguments: #()!

hash
	"Since we implement #= we must also implement hash to match."

	^selector hash + args hash + self receiver hash!

printOn: target 
	"Append a short textual description of the receiver to the <puttableStream>
	argument, target."

	target
		basicPrint: self;
		nextPut: $(;
		print: self receiver;
		nextPutAll: '>>';
		print: self selector.
	args notEmpty 
		ifTrue: 
			[target
				nextPutAll: ', ';
				print: args].
	target nextPut: $)!

receiver
	"Answer the receiver instance variable of the receiver (i.e the object which is 
	the current destination of the receiver should it be evaluated)"

	^self subclassResponsibility!

receiver: anObject
	"Set the receiver"

	^self subclassResponsibility!

value
	"Evaluates the receiver send the message identified by the 
	receiver's selector to the receiver's receiver, with the 
	receiver's arguments, and answers the result."
	
	^self receiver perform: selector withArguments: args!

value: anObject
	"Answer the result of sending the receiver. 
	Implementation Note: By implementing this selector from the <monadicValuable>
	protocol, we enable the substitution of MessageSends for a
	large number of parameterization cases where blocks would otherwise
	be required."

	^self valueWithArguments: (Array with: anObject)!

value: arg1 value: arg2
	"Answer the result of sending the receiver.
	Implementation Note: By implementing this selector from the <dyadicValuable>
	 protocol, we enable the substitution of MessageSends for a
	large number of parameterization cases where blocks would otherwise
	be required. In any case we must override this because the superclass
	implementation is wrong for us."

	^self valueWithArguments: (Array with: arg1 with: arg2)!

valueWithArguments: triggerArguments
	"Executes the receiver with the specified <Array> of arguments. If insufficient arguments are
	supplied then these are substituted with arguments supplied at the time the event handler was
	registered, or nils if there are still insufficient. If the combined number of arguments is greater
	than that required, then the subclass determines which take precedence."

	^self forwardTo: self receiver withArguments: triggerArguments! !

EventMessageSend comment:
'An EventMessageSend is a fully closed <Message>, including receiver object, the message selector, and an array of sufficient arguments, however the receiver is referenced weakly.

When evaluate with extra arguments, an EventMessageSend merges its own argument with those supplied at evaluation time with the latter taking precedence from the left. For example if the message requires two arguments, and one is supplied at evaluation time, then the first argument sent will be that one, and the second the second of the arguments stored in the EventMessageSend itself.'!
!EventMessageSend class methodsFor!

new
	^(self new: 1) beWeak; yourself! !

!EventMessageSend methodsFor!

forwardTo: anObject withArguments: triggerArguments
	"Private - Send the receiver Message to the <Object>, anObject, with the <Array> of arguments, anArray.	
	If insufficient arguments are supplied then these are substituted with arguments supplied at the 	
	time the event handler was registered, or nils if there are still insufficient. If the combined number 
	of arguments is greater than that required, then the arguments supplied at trigger time take precedence."

	^anObject perform: selector
		withArguments: (expectedArgCount = triggerArguments basicSize 
				ifTrue: [triggerArguments]
				ifFalse: [self mergeArguments: triggerArguments])!

mergeArguments: triggerArguments
	| actualArgs |
	actualArgs := Array new: expectedArgCount.
	actualArgs
		replaceFrom: 1
			to: (expectedArgCount min: args basicSize)
			with: args
			startingAt: 1;
		replaceFrom: 1
			to: (expectedArgCount min: triggerArguments basicSize)
			with: triggerArguments
			startingAt: 1.
	^actualArgs!

postCopy
	self beWeak.
	^self!

receiver
	^self basicAt: 1!

receiver: anObject
	self basicAt: 1 put: anObject!

selector: aSelector
	"Sets the selector for the receiver to aSelector. Also
	computes the expected argument count that will be required
	when the selector is sent."

	super selector: aSelector.
	expectedArgCount := aSelector argumentCount.
	args := #()!

setSelector: aSymbol arguments: argArray
	"Private - Initialize the receiver's instance variables."

	selector := aSymbol.
	expectedArgCount := aSymbol argumentCount.
	self assert: [argArray size <= expectedArgCount].
	args := argArray!

value
	"Evaluates the receiver send the message identified by the 
	receiver's selector to the receiver's receiver, with the 
	receiver's arguments, and answers the result."

	^self forwardTo: self receiver withArguments: #()! !

MessageSend comment:
'A MessageSend is a fully closed <Message>, including receiver object, the message selector, and an array of sufficient arguments.

When evaluated with additional arguments the supplied arguments supplant those stored in the MessageSend itself by replacement from the right.

Instance Variables:
	receiver		<Object>, the destination of the message when evaluated'!
!MessageSend class methodsFor!

empty
	"Answers an instance of the receiver that does nothing.
	N.B. This is a shared object, and should not be modified."

	EmptySend isNil ifTrue: [
		EmptySend := self receiver: nil selector: #isNil].
	^EmptySend! !

!MessageSend methodsFor!

forwardTo: anObject withArguments: anArgumentArray
	"Answer the result of evaluating the receiver replacing the stored arguments 
	with those from the <Array>, anArgumentArray, from the right, i.e. if two arguments 
	are supplied for a three argument message then the penultimate and last arguments 
	will be those supplied and the first will come from the stored argument <Array>,
	and then forwarding a message composed of those arguments and the selector stored 
	in the receiver to the <Object>, anObject. If more arguments are supplied than are 
	required for the message, then the extraneous arguments are simply ignored."

	^args isEmpty 
		ifTrue: [anObject perform: selector]
		ifFalse: 
			[| actualArgs argCount |
			actualArgs := args shallowCopy.
			argCount := args basicSize.
			actualArgs 
				replaceFrom: (argCount - anArgumentArray basicSize + 1 max: 1)
				to: argCount
				with: anArgumentArray
				startingAt: 1.
			anObject perform: selector withArguments: actualArgs]!

receiver
	^receiver!

receiver: anObject
	receiver := anObject.
! !

MessageBox comment:
'MessageBox provides a convenient wrapping aound the standard Windows Message Box. It can be used to pose questions, and report information, warnings, or errors.

Note that MessageBox is deliberately implemented using low-level Windows APIs in order to be independent of the MVP subsystem.

Example usage:

	MessageBox new 
		confirm: ''Would you like a cup of tea?''.
	MessageBox warning: ''Contents are hot''.
	MessageBox errorMsg: ''You''''ve burned yourself''.

	"If you are on XP or 2k(3) you can try out the new style of Abort/Retry/Ignore box"
	MessageBox new
		icon: Object icon;
		buttonStyle: #cancelRetryContinue;
		text: ''Is this any more helpful?'';
		open

MessageBox''s can also be configured so that they are suppressible by the user. This includes a checkbox in the MessageBox which the user can tick if they don''t want to see the messsage again. Subsequent attempts to display the same message (as identified by the uniqueId) will result in the immediate return of the default button value. Note that it is the default button value that is returned, NOT the button the user pressed when the chose to suppress the message box. MSDN explains this as follows: 

	Do not confuse "Do not show this dialog box" with "Remember this answer". SHMessageBoxCheck does not provide "Remember this answer" functionality. If the user opts to suppress the message box again, the function does not preserve which button they clicked. Instead, subsequent invocations of SHMessageBoxCheck simply return the [default value].

In other words, if you want to remember the choice the user made when they suppressed the dialog box, and apply that in future, you must store it yourself and set the #defaultButton: index appropriately before "opening" the message box.

Suppressible message boxes support only a limited set of the full range of MessageBox styles. For example they can only show the OK, OK & Cancel, or Yes & No buttons (although in fact the Yes/No style is equivalent to the normal Yes/No/Cancel since it enables the close button on the title bar). Another respect in which SHMessageBoxCheck is more limited is that it ignores the MB_DEFBUTTONX flags. The default button is always the first button in the dialog (i.e. either OK, or Yes, depending on the button style). In the Dolphin implementation setting the #defaultButton: index can be used to control the default answer when the message box has been suppressed as mentioned above, but unfortunately it will not influence the default button selected when the message box is actually show. When a message box is suppressed by the user, Windows writes a value under HKCU/Software/Microsoft/Windows/CurrentVersion/Explorer/DontShowMeThisDialogAgain. The value is named after the #uniqueId set when the message box was opened, prepended with the GUID of the Dolphin application (i.e. the GUID of the SessionManager class). For further information see the MSDN entry for the SHMessageBoxCheck API:

	http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/shlwapi/others/SHMessageBoxCheck.asp

Instance Variables:
	button		<integer> id of the button that was pressed (e.g. IDOK)
	uniqueId	<Object>. The display string of this object is used to uniquely identify (within an application) a particular suppressible message box instance.
	flags		<integer>. Miscellaneous flags
	icon		<Icon> displayed in the message box.
	styleFlags	<integer>. Button and icon styles.

Class Variables:
	SuppressableMask	<integer> flags mask

Class Variables:
	ButtonMap			<Array> mapping <integer> button ids to <symbol>ic button names.
	ButtonsForStyle		<Array> of <Array> of <integer>. Button ids present on a box with a particular button style, in display order.
	ButtonStyles		<IdentityDictionary> mapping <symbol>ic button style names to the corresponding <integer> MB_ flag values.
	ModeStyles			<IdentityDictionary> mapping <symbol>ic modality style names (e.g. #task) to the corresponding <integer> MB_ flag value.
	SuppressibleMask	<integer>. Masks in/out the suppressible flag from the flags instance variable.

'!
!MessageBox class methodsFor!

confirm: promptText
	"Display a Windows Message Box prompting for confirmation of the 
	<readableString> prompt, promptText.
	Answer whether the user confirmed (by pressing the Yes button).
	The caption will be filled in from the defaults later."

	^self confirm: promptText  caption: nil!

confirm: prompt caption: title
	"Display a Windows Message Box prompting for confirmation of the 
	<readableString> question, prompt , with the <readableString> caption,
	title."

	^self new
		caption: title;
		confirm: prompt !

confirm: aString onYes: yesBlock onNo: noBlock onCancel: cancelBlock
	"Prompts the user with a Yes/No/Cancel message box and evaluates the 
	appropriate block based on the response"

	^self new
		confirm: aString
		onYes: yesBlock
		onNo: noBlock
		onCancel: cancelBlock!

initialize
	"Private - Initialize the class variables of the receiver:
		MessageBox initialize
	"

	ButtonMap := (Array new: 11)
				at: IDOK put: #ok;
				at: IDCANCEL put: #cancel;
				at: IDABORT put: #abort;
				at: IDRETRY put: #retry;
				at: IDIGNORE put: #ignore;
				at: IDYES put: #yes;
				at: IDNO put: #no;
				at: IDCLOSE put: #close;
				at: IDHELP put: #help;
				at: IDTRYAGAIN put: #retry;
				at: IDCONTINUE put: #ignore;
				yourself.
	"at: IDTIMEOUT put: #timeout;"
	SuppressibleMask := 16r10.
	ButtonStyles := (IdentityDictionary new)
				at: #ok put: MB_OK;
				at: #okCancel put: MB_OKCANCEL;
				at: #abortRetryIgnore put: MB_ABORTRETRYIGNORE;
				at: #yesNoCancel put: MB_YESNOCANCEL;
				at: #yesNo put: MB_YESNO;
				at: #retryCancel put: MB_RETRYCANCEL;
				at: #cancelRetryContinue put: MB_CANCELTRYCONTINUE;
				shrink;
				yourself.
	ButtonsForStyle := (Array new: 7)
				at: MB_OK + 1 put: (Array with: IDOK);
				at: MB_OKCANCEL + 1 put: (Array with: IDOK with: IDCANCEL);
				at: MB_ABORTRETRYIGNORE + 1
					put: (Array 
							with: IDABORT
							with: IDRETRY
							with: IDCANCEL);
				at: MB_YESNOCANCEL + 1
					put: (Array 
							with: IDYES
							with: IDNO
							with: IDCANCEL);
				at: MB_YESNO + 1 put: (Array with: IDYES with: IDNO);
				at: MB_RETRYCANCEL + 1 put: (Array with: IDRETRY with: IDCANCEL);
				at: MB_CANCELTRYCONTINUE + 1
					put: (Array 
							with: IDCANCEL
							with: IDTRYAGAIN
							with: IDCONTINUE);
				yourself.
	ModeStyles := (IdentityDictionary new)
				at: #application put: MB_APPLMODAL;
				at: #task put: MB_TASKMODAL;
				at: #system put: MB_SYSTEMMODAL;
				shrink;
				yourself! !

!MessageBox methodsFor!

abortRetryIgnore
	#deprecated.
	self buttonStyle: #abortRetryIgnore!

assertStylesValid
	"Private - SHMessageBoxCheck supports only a limited range of the full set of MessageBox
	styles. We try to adapt the style request to an equivalent style, but if this is not
	possible then let the programmer know that they will not get the desired effect."

	"Implementation Note: Although the documentation states that SHMessageBoxCheck does not
	support MB_YESNOCANCEL, in fact its MB_YESNO style is really the that. It doesn't display a
	Cancel button, but it does enable the close box on the caption (and will respond to the
	ESCape key), and the result in that case is #cancel."

	self assert: 
			[##(Array 
				with: MB_YESNOCANCEL
				with: MB_OKCANCEL
				with: MB_YESNO
				with: MB_OK) includes: self buttonStyleValue].
	self assert: 
			[| val |
			val := self iconStyleFlag.
			val ~= MB_USERICON and: [IconStyles values includes: val]]!

basicOpen
	"Private - Display the receiver, and answer the Win32 Id of the button pressed by the user."

	self assert: [self defaultButton <= self buttonIds size].
	self hasOwner ifTrue: [self owner ensureVisible].
	self isSuppressible ifTrue: [self showSuppressible] ifFalse: [self showIndirect].
	^button!

beFatalError
	"Set the receiver's style such that the receiver opens as a fatal error message (e.g. for
	out of resource situations)."

	self
		iconStyle: #error;
		beSystemModal!

beSystemModal
	"Set the receiver's style so that it is system modal (i.e. all top level windows are 
	disabled) when opened. Since this option disables all other applications, it should
	be used only when catastrophic errors occur which require immediate user attention.
	N.B. Should be combined with #error to prevent activation messages being sent to
	the parent window when opened."

	self modality: #system!

beTaskModal
	"Set the receiver's style so that it is task modal (i.e. all top level Dolphin
	windows are disabled) when opened. Other applications are unaffected.
	Task modality only works in Win32 if the owner window handle is NULL, and by
	default we pass the handle of the active window, so must explicity null it here."

	self modality: #task.
	self setForeground.
	self owner: 0!

buttonIds
	^ButtonsForStyle at: self buttonStyleValue + 1!

buttonStyle
	"Answer the symbolic name of the button style to be used in the message box (one of: #ok,
	#okCancel, #yesNo, #yesNoCancel #abortRetryIgnore, #retryCancel, #cancelRetryContinue)"

	^ButtonStyles keyAtValue: self buttonStyleValue!

buttonStyle: aSymbol 
	self setStyle: (ButtonStyles at: aSymbol) maskedBy: MB_TYPEMASK!

buttonStyleValue
	^styleFlags bitAnd: MB_TYPEMASK!

confirm: promptString 
	"Display a host system message box with the prompt, promptString, with caption, 
	captionString, and Yes and No push buttons. Answer whether the user confirmed 
	(by pressing the Yes button)."

	self text: promptString.
	self iconStyle: #prompt.
	self buttonStyle: #yesNo.
	^self open == #yes!

confirm: aString onYes: yesBlock onNo: noBlock onCancel: cancelBlock
	"Prompts the user with a Yes/No/Cancel message box and evaluates the appropriate block based on the response"

	| response |
	response := self confirmOrCancel: aString.

	^response == #cancel
		ifTrue: [cancelBlock value]
		ifFalse: [ 
			response == #yes
				ifTrue: [yesBlock value]
				ifFalse: [noBlock value]]!

confirmOrCancel: promptString 
	"Display a host system message box for the receiver with the prompt, aString,
	and Yes, No and Cancel push buttons. Answer one of the symbolic
	constants #yes, #no, #cancel, according to the button pressed by the receiver."

	self text: promptString.
	self iconStyle: #prompt.
	self buttonStyle: #yesNoCancel.
	^self open!

defaultButton
	"Answer the one-based integer index of the default button."

	^((styleFlags bitAnd: MB_DEFMASK) >> 8) + 1!

defaultButton: anInteger 
	"Set the one-based index of the default push button to be used when the receiver is opened.
	By default the first push button is the default button."

	(anInteger between: 1 and: 4) 
		ifFalse: [^self error: ('Invalid default button index: <1d>' expandMacrosWith: anInteger)].
	self setStyle: anInteger - 1 << 8 maskedBy: MB_DEFMASK!

error
	#deprecated.
	self iconStyle: #error!

fatalError
	#deprecated.
	self beFatalError!

globallyUniqueId
	^'<1d>:<2d>' expandMacrosWith: SessionManager current appIdString with: self uniqueId!

hasOwner
	^self owner notNil and: [self owner ~= 0]!

icon: anIcon 
	"Set the receiver's icon to be the argument, anIcon. The icon MUST have been loaded from
	resources since the message box does not use the icon directly, but rather it uses its ID
	and module handle to load it again.. Also the icon only seems to be displayed if the
	resource id is an integer."

	icon := anIcon.
	self iconStyle: (icon isNil ifTrue: [#notify] ifFalse: [#user])!

iconStyleFlag
	"Private - Answer the icon style bits from the receiver's style mask."

	^styleFlags bitAnd: MB_ICONMASK!

iconStyleFlag: anInteger 
	self setStyle: anInteger maskedBy: MB_ICONMASK!

idOfButtonAt: anInteger 
	^self buttonIds at: anInteger!

initialize
	"Private - Initialize the receiver's instance variables."

	flags := 0.
	styleFlags := 0!

isSuppressible
	"Answer whether this message box will be give the user the option of not seeing further
	occurrences with the same uniqueId in the future."

	^(flags allMask: SuppressibleMask) and: [self uniqueId notNil]!

isSuppressible: aBoolean 
	"Set whether this message box will give the user the option of not seeing further
	occurrences with the same uniqueId in the future. Note that this flag is ignored unless the
	uniqueId associated with this particular message box is also set."

	flags := flags mask: SuppressibleMask set: aBoolean!

isTaskModal
	"Answer whether the receiver is task modal (i.e. modal to all windows
	in the application not just the active one)."

	^styleFlags allMask: MB_TASKMODAL!

modality
	"Answer the symbolic name of the receiver's modal style (one of #application, #task, or
	#system). "

	^ModeStyles keyAtValue: (styleFlags bitAnd: MB_MODEMASK)!

modality: aSymbol 
	self setStyle: (ModeStyles at: aSymbol) maskedBy: MB_MODEMASK!

ok
	#deprecated.
	self buttonStyle: #ok!

okCancel
	#deprecated.
	self buttonStyle: #okCancel!

open
	"Display a host system message box for the receiver, and answer a portable symbolic constant 
	for the button pressed by the user.
	Note that the message box will beep when opened by the user (if configured)."

	^self basicOpen; result!

prompt
	#deprecated.
	self iconStyle: #prompt!

result
	"Answer a portable symbolic constant describing the button that was pressed by the user
	to close the receiver."

	^ButtonMap at: button!

retryCancel
	#deprecated.
	self buttonStyle: #retryCancel!

setForeground
	"Set the receiver's style such that the receiver opens in the foreground."

	styleFlags := styleFlags mask: MB_SETFOREGROUND set: true!

setStyle: anInteger maskedBy: maskInteger 
	styleFlags := (styleFlags maskClear: maskInteger) maskSet: (anInteger bitAnd: maskInteger)!

showIndirect
	| hInstance iconIdentifier |
	icon isNil 
		ifFalse: 
			[iconIdentifier := icon identifier.
			hInstance := icon instanceHandle asParameter].
	button := UserLibrary default 
				messageBox: self ownerHandle
				text: self text
				caption: self caption
				style: styleFlags
				icon: iconIdentifier
				instance: hInstance!

showSuppressible
	"Implementation Note: SHMessageBoxCheck does not seem to suffer from the same bug as the
	normal message box of re-enabling a disabled owner."

	self assertStylesValid.
	button := ShlwapiLibrary default 
				shMessageBoxCheck: self ownerHandle
				pszText: self text
				pszTitle: self caption
				uType: styleFlags
				iDefault: (self idOfButtonAt: self defaultButton)
				pszRegVal: self globallyUniqueId.
	button == -1 ifTrue: [ShlwapiLibrary default systemError]!

systemModal
	#deprecated.
	self beSystemModal!

taskModal
	#deprecated.
	self beTaskModal!

uniqueId
	"Answer the unique id that, should the user decide to suppress this message box, will be
	stored under the following registry key:
		HKCU/Software/Microsoft/Windows/CurrentVersion/Explorer/DontShowMeThisDialogAgain
	This is a global area used by all applications, so the id has to be unique. The class
	attempts to assist you in this by pre-pending this unique id with the GUID of the
	SessionManager class, which is the closest thing to a unique id for each Dolphin
	application. A good choice for the unique id is then the full name of the method displaying
	the message box. Note that if the id is nil the message box will not be suppressible."

	^uniqueId!

uniqueId: anObject 
	uniqueId := anObject displayString!

yesNo
	#deprecated.
	self buttonStyle: #yesNo!

yesNoCancel
	#deprecated.
	self buttonStyle: #yesNoCancel! !

EventMessageSequence comment:
''!
!EventMessageSequence methodsFor!

add: aMessageSend
	"Adds a <MessageSend> to this sequence. Normally this would be an
	EventMessageSend, a special kind of message send that maintains only
	a weak reference to its receiver, and which merges trigger and registration
	arguments in a particular way. However, the argument can be any
	valuable that implements the #value[:] message appropriate for the number
	of arguments triggered with the event, and it must also implement #receiver.
	So, for example, blocks and normal MessageSends can be used.
	Note that we take an additional weak reference to the receiver for the sole
	purpose of being notified when the receiver has been garbage collected
	so that the message sequence can be updated."

	| receiver index |
	tally := tally + 1.
	receiver := aMessageSend receiver.
	index := receivers addAnsweringIndex: receiver.
	index > messages basicSize ifTrue: [messages resize: receivers basicSize].
	messages basicAt: index put: aMessageSend.
	^aMessageSend!

elementsExpired: count of: aWeakArray
	"Private - Handle the loss of <integer> count values from the receiver's receiver <Array> (
	which is also the argument, aWeakArray). We nil the message corresponding to each corpse
	(although we don't bother nilling the dead receivers to speed up the search for an empty slot)."

	tally := tally - count.
	receivers corpsesDo: [:deathAt | messages at: deathAt put: nil]!

initialize
	"Private - Initialize the receiver.
	Implementation Note: The majority of instances only ever contain one message
	for the event against the receiver, so we use 1 as the initial capacity."

	receivers := (MourningWeakArray with: DeadObject current)
				pathologist: self;
				yourself.
	messages := Array new: 1.
	tally := 0!

messagesDo: operation 
	"Private - Evaluates the <monadicValuable>, operation, for all non-dead elements of the receiver.
	An event message registration is considered dead if the target (receiver) of the message has been
	garbage collected."

	| corpse |
	corpse := DeadObject current.
	1 to: receivers basicSize
		do: 
			[:index | 
			"Assign the receiver into a temp to prevent it being GC'd before the message can be sent."

			| receiver |
			receiver := receivers at: index.
			receiver == corpse 
				ifFalse: [(messages at: index) ifNotNil: [:msg | operation value: msg]]]!

removeMessagesFor: anObject
	"Removes all the messages in this sequence that are destined for anObject. Answers the receiver."

	| corpse |
	corpse := DeadObject current.
	1 to: receivers basicSize
		do: 
			[:index | 
			(receivers at: index) == anObject 
				ifTrue: 
					[tally := tally - 1.
					receivers at: index put: corpse.	"corpse marks empty slots"
					messages at: index put: nil]]!

size
	"Answers the number of messages in the receiver"

	^tally! !

MessageSequence comment:
''!
!MessageSequence class methodsFor!

withMessages: aSequencedReadableCollection
	"Answer a new instance of the receiver with the specified sequence of <MessageSend>s."

	| answer |
	answer := self new.
	answer list addAll: aSequencedReadableCollection.
	^answer! !

!MessageSequence methodsFor!

add: aMessage
	"Adds aMessage to the end of this sequence. Answers aMessage"

	^list addLast: aMessage.
!

add: newElement afterIndex: index
	"Add newElement to the receiver immediately after the element currently at the
	specified <integer> index. index must be between 0 and the receiver's current 
	size (if not raise an exception). Answer newElement."

	^list add: newElement afterIndex: index!

addAll: newElements afterIndex: index
	"Add all of the elements in the <collection>, newElements, after the existing element of
	the receiver at the one-based <integer> index, index. Answer the newly added elements."

	^list addAll: newElements afterIndex: index!

initialize
	"Private - Initialize the receiver"

	super initialize.
	list := OrderedCollection new.!

list
	"Private - Answers the message list"

	^list!

messagesDo: aBlock
	"Private - Enumerates through the receiver"

	^list do: aBlock!

removeMessagesFor: anObject
	"Removes all the messages in this sequence that are destined for anObject.
	Answer the receiver."

	list := list reject: [ :each | each receiver == anObject]!

size
	"Answers the number of messages in the sequence"

	^list size! !

PermanentRegistry comment:
'PermanentRegistry is a specialized class of <ObjectRegistry>s which maintain a strong reference to registered objects, preventing them from being garbage collected. They are useful where the objects may only be referenced ''externally'' (e.g. COM server objects).

The superclass instance variable ''registry'' is initialized to an <Array> in instances of this class. The slots of the array are populated either with registered objects, or linked onto a free list by index (the content of the slot being the next free entry). The last element of the <Array> is always zero to mark the end of the free list. When a new object is registered the first slot on the free list is used, unless there are no free slots in which case the array is resized to increase its capacity.

Note: The implementation of the free list in this class using integer indices means that PermanentRegistry instances are not suitable for registries of <Integer>s.

Instance Variables:
	freeHead		<integer> index of the first free slot in the registry.'!
!PermanentRegistry methodsFor!

addAnsweringIndex: anObject
	"Register the argument, anObject, answering a unique SmallInteger id which can be used
	subsequently to retrieve that object.
	Implementation Note: Permanent object registries cannot reliably locate registered
	integers by value, though they can hold them."

	| id |
	freeHead == 0 ifTrue: [self grow].
	id := freeHead.
	freeHead := registry basicAt: freeHead.
	registry basicAt: id put: anObject.
	^id!

grow
	"Private - Increase the capacity of the receiver. We do this by increasing
	the size of the registry, and building a free list."

	| capacity |
	capacity := registry size.
	registry := registry, (capacity+2 to: capacity*2), (Array with: freeHead).
	freeHead := capacity+1
!

initialize: anInteger
	"Private - Initialize the receiver with the specified initial capacity."

	registry := (2 to: anInteger), ##(Array with: 0).
	freeHead := 1!

removeAtIndex: anInteger
	"Remove, and answer, the registered object with <integer> id, anInteger, in the receiver. 
	Raise an error if there is no element indexed by anInteger."

	(registry basicAt: anInteger) isInteger ifFalse: [
		registry basicAt: anInteger put: freeHead.
		freeHead := anInteger]! !

WeakRegistry comment:
'WeakRegistry comment: ''WeakRegistry is the class of <ObjectRegistry>s which maintain only a weak reference to registered objects. Thus registration in a WeakRegistry will not prevent the registrant from being garbage collected, which makes it useful where a unique identifier is needed for an object only for as long as it is still referred to from elsewhere in the image. An example usage is the register of extant <ExternalCallback> objects.

The superclass instance variable ''''registry'''' is initialized to an <WeakArray> in instances of this class. The slots of the array are populated either with registered objects, or with the corpse object (i.e. the DeadObject singleton instance). When a new object is registered the first slot currently occuppied by a corpse is used, unless there are no ''''dead'''' entries, in which case the weak array is resized to increase its capacity. The integer key associated with a registered object is its index in the array.
'!
!WeakRegistry methodsFor!

addAnsweringIndex: anObject
	"Register the argument, anObject, answering a unique SmallInteger id which can be used
	subsequently to retrieve that object."

	^registry addAnsweringIndex: anObject!

initialize: anInteger
	"Private - Initialize the receiver with the specified initial capacity."

	registry := WeakArray new: anInteger.
	registry replaceFrom: 1 to: anInteger withObject: DeadObject current!

removeAtIndex: anInteger
	"Remove, and answer, the registered object with id anInteger in the receiver. 
	Raise an error if there is no element indexed by anInteger."

	| object |
	object := registry basicAt: anInteger.
	registry basicAt: anInteger put: DeadObject current.
	^object! !

PluggableSearchPolicy comment:
'PluggableSearchPolicy is for configuring pluggable collections and models to use pluggable search and comparison operations, i.e. one can define new search policies as instances of this class without writing a new <SearchPolicy> class, however performance will suffer slightly.'!
!PluggableSearchPolicy class methodsFor!

new
	"Instances of the receiver require that hashing and comparison valuables
	be supplied - use newCompareBlock:hashBlock:"

	^self shouldNotImplement!

newCompareBlock: discriminator hashBlock: hasher
	"Answer a new instance of the receiver configured with the <dyadicValuable comparison block,
	discriminator, and the <monadicValuable> hashing block, hasher."

	^super new
		compareBlock: discriminator hashBlock: hasher! !

!PluggableSearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^compareBlock value: operand1 value: operand2
!

compareBlock: discriminator hashBlock: hasher
	"Set the <dynadicValuable> used by receiver to compare object to the
	argument, discriminator. The discriminator should answer true if its two
	arguments are considered equivalent under this search policy, else false.
	Also set the <monadicValuable> used by the receiver to calculate hash values to the
	argument, hasher. Answer the receiver."

	compareBlock := discriminator.
	hashBlock := hasher.
	^self!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy."

	^hashBlock value: operand! !

SingletonSearchPolicy comment:
''!
!SingletonSearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self subclassResponsibility!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self current.
	anSTBInFiler register: singleton.
	^singleton! !

!SingletonSearchPolicy methodsFor!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self! !

AlwaysSearchPolicy comment:
''!
!AlwaysSearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self always! !

!AlwaysSearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^true!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy.
	Implementation Note: Since the objects compared are always considered equal, 
	we must use the same hash value for all objects."

	^1! !

CaseInsensitiveSearchPolicy comment:
'CaseInsensitiveSearchPolicy is for configuring pluggable collections and models of strings to use case-insensitive equality based search and comparisons, i.e. using #sameAs: and the #hash of the lowercased equivalent of the string.

N.B. Unlike other SearchPolicy classes, instances of this class are only appropriate for comparing and searching collections of strings, or objects which can be represented as strings (i.e. implementors of #asString).
'!
!CaseInsensitiveSearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self caseInsensitive! !

!CaseInsensitiveSearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^operand1 asString sameAs: operand2 asString!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy."

	^operand asString asLowercase hash!

keyAtValue: value in: collection ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value in the keyed
	collection, collection, using the receiver's search policy. If there is no such 
	value, answer the result of evaluating the <niladicValuable>, operation.
	The reverse mapping identity search operation is used: The collection argument
	must respond to #keysAndValuesDo: (there is no keyedCollection protocol
	defined at present)."

	| comperand |
	comperand := value asString.
	collection keysAndValuesDo: [:k :v | (self compare: v asString with: comperand) ifTrue: [^k]].
	^operation value
! !

EqualitySearchPolicy comment:
'EqualitySearchPolicy is for configuring pluggable collections and models to use equality based search and comparisons, i.e. using #= and #hash, etc. Using an instance of this search policy a <PluggableSet> will behave in the same way as a <Set>.'!
!EqualitySearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self equality! !

!EqualitySearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^operand1 = operand2!

hash: operand max: maximum
	"Answer a suitable hash value for the <Object>, operand, under this search policy, 
	between 1 and the <integer>, maximum.
	Implementation Note: Override to avoid a message send (seems trivial but performance
	of search policies can be important)."

	^operand hash \\ maximum + 1!

keyAtValue: value in: collection ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value in the keyed
	collection, collection, using the receiver's search policy. If there is no such 
	value, answer the result of evaluating the <niladicValuable>, operation.
	The reverse mapping equality search operation is used: The collection argument
	must respond to #keyAtEqualValue:ifAbsent: (there is no keyedCollection protocol
	defined at present)."

	^collection keyAtEqualValue: value ifAbsent: operation!

newLookupTable
	"Answer a new <LookupTable> with the receiver as its search policy."

	^LookupTable new!

nextIndexOf: anElement in: collection from: start to: stop
	"Answer the index of the next occurrence of anElement in the <sequencedReadableCollection>
	argument,  collection, between startIndex and stopIndex inclusive. If there are no such occurrences, 
	answer 0."

	^collection nextIndexOf: anElement from: start to: stop! !

IdentitySearchPolicy comment:
'IdentitySearchPolicy is for configuring pluggable collections and models to use identity based search and comparisons, i.e. using #== and #identityHash, etc. Using an instance of this search policy a <PluggableSet> will behave in the same way as an <IdentitySet>.'!
!IdentitySearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self identity! !

!IdentitySearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^operand1 == operand2!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy."

	^operand identityHash!

hash: operand max: maximum
	"Answer a suitable hash value for the <Object>, operand, under this search policy, 
	between 1 and the <integer>, maximum.
	Implementation Note: The identityHash range is limited to 16-bits, so we must scale for large 
	collections to avoid excessive collisions causing a dramatic fall off in performance."

	^maximum < 8192
		ifTrue: [operand identityHash \\ maximum + 1]
		ifFalse: [(operand identityHash * (maximum bitShift: -12)) \\ maximum + 1]!

keyAtValue: value in: collection ifAbsent: operation
	"Answer the <Object> key of the <Object> argument, value in the keyed
	collection, collection, using the receiver's search policy. If there is no such 
	value, answer the result of evaluating the <niladicValuable>, operation.
	The reverse mapping identity search operation is used: The collection argument
	must respond to #keyAtValue:ifAbsent: (there is no keyedCollection protocol
	defined at present)."

	^collection keyAtValue: value ifAbsent: operation!

newLookupTable
	"Answer a new <LookupTable> with the receiver as its search policy."

	^IdentityDictionary new!

nextIndexOf: anElement in: collection from: start to: stop
	"Answer the index of the next occurrence of anElement in the <sequencedReadableCollection>
	argument,  collection, between startIndex and stopIndex inclusive. If there are no such occurrences, 
	answer 0."

	^collection nextIdentityIndexOf: anElement from: start to: stop! !

NeverSearchPolicy comment:
''!
!NeverSearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	^self never! !

!NeverSearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^false! !

SymbolStringSearchPolicy comment:
'SymbolStringSearchPolicy is for configuring pluggable collections and models of <String>s or <Symbol>s such that the same sequence of characters compare as equal, regardless of whether the sequence is stored in a Symbol or a String. Normally Symbols are not considered equal to Strings even when they contain the same characters.

N.B. Unlike most other SearchPolicy classes, instances of this class are only appropriate for comparing and searching collections of Symbols and Strings (the objects to be compared must implement #hashCharacters and #trueCompare:).'!
!SymbolStringSearchPolicy class methodsFor!

current
	"Answer the singleton instance of the receiver."

	Current isNil ifTrue: [Current := self new].
	^Current!

onPreStripImage
	"Private - Tidy up the receiver's lazily initialized class vars in preparation for image stripping."

	self uninitialize!

uninitialize
	"Private - Tidy up the receiver in preparation for removal from the system."

	Current := nil! !

!SymbolStringSearchPolicy methodsFor!

compare: operand1 with: operand2
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^(operand1 trueCompare: operand2) == 0
!

hash: operand
	"Answer a suitable hash value for the <Object>, operand, under this search policy."

	^operand hashCharacters! !

AssociationSearchPolicy comment:
'AssocationSearchPolicy is a specialized <EqualitySearchPolicy> for searching homogeneous collections of Associations by equality.

Association has traditionally implemented #hash as the has of its key only, and this leads to poor lookup performance in a standard <Set> where there are a lot of Associations with equal keys. This search policy can be used with <PluggableSet> and <PluggableLookupTable> to ameliorate this problem.'!
!AssociationSearchPolicy class methodsFor!

current
	"Answer the singleton sub-instance of the receiver which supports a search policy
	based on equality."

	Current isNil ifTrue: [Current := super new].
	^Current!

onPreStripImage
	"Private - Tidy up the receiver's lazily initialized class vars in preparation for image stripping."

	self uninitialize!

uninitialize
	"Private - Tidy up the receiver in preparation for removal from the system."

	Current := nil! !

!AssociationSearchPolicy methodsFor!

hash: operand
	"Answer a hash value for the <Assocation>, operand, which takes account
	of the value as well as the key (historically Association>>hash has answered the
	hash of its key only, which makes it a poor Set element if a lot of the keys are the
	same)."

	^operand key hash bitXor: operand value hash!

hash: operand max: maximum
	"Answer a suitable hash value for the <Object>, operand, under this search policy, 
	between 1 and the <integer>, maximum. If maximum is a significant proportion
	of the range of hash values generated, then the result should be scaled to distribute
	evenly between 1 and maximum in order to avoid generating excessive collisions at
	the low end of the range."

	^(operand key hash bitXor: operand value hash) \\ maximum + 1! !

BootSessionManager comment:
'BootSessionManager is the class of <SessionManager>s installed when the Dolphin image is booting from sources.'!
!BootSessionManager class methodsFor!

imageExtension
	"Answer the suffix for an executable image file"

	^'img'! !

!BootSessionManager methodsFor!

basicTertiaryStartup
	"Perform tertiary system startup operations."

	"Nothing to do - this SessionManager should never be installed on startup anyway?"!

keepAlive
	"We stay alive until explicitly terminated."

	^self!

main
	self stdout 
		nextPutAll: 'Dolphin Smalltalk Boot'; cr; 
		nextPutAll: 'Copyright (c) Object Arts Ltd, 1997-2004.'; cr; cr;
		nextPutAll: 'Loading boot script...'; cr; flush.

	self class sourceManager fileIn: 'Boot.st'.
!

onPreSaveImage
	"Private - Perform pre-image save actions (but without the MemoryManager>>onPreSaveImage,
	since this causes a problem when saving an image. This method should be removed later to
	re-inherit the superclass version."

	self trigger: #imageSaveStarting.
	self saveSessionState.
	
	"MemoryManager current onPreSaveImage."
	self class environment at: #Delay ifPresent: [:d | d onPreSaveImage]
!

onUnhandledNotification: aNotification
	"The unhandled Notification, aNotification, occurred in the active Process.
	Display the notification description on the Transcript (or other trace device)."

	aNotification toTrace.
	^nil!

openConsoleStreams
	"Private - Open the standard console I/O streams. Note that the actual
	C-runtime library stdin/stdout/stderr streams will be correctly set up so
	that it is possible to use the CRT stdio functions such as puts(), printf(), etc.
	Implementation Note: A boot session is run by the GUI stub and therefore
	the CRT streams will not have been initialized."

	stdioStreams isNil 
		ifTrue: 
			[| crt |
			crt := CRTLibrary default.
			stdioStreams := Array 
						with: (StdioFileStream fromHandle: (crt 
										connectDescriptor: 0
										toWinStdHandle: STD_INPUT_HANDLE
										mode: 'rt'))
						with: (StdioFileStream fromHandle: (crt 
										connectDescriptor: 1
										toWinStdHandle: STD_OUTPUT_HANDLE
										mode: 'wt'))
						with: (StdioFileStream fromHandle: (crt 
										connectDescriptor: 2
										toWinStdHandle: STD_ERROR_HANDLE
										mode: 'wt'))]!

openSources
	"Private - Open the source files with names derived from the current image path."

	self class sourceManager openSources: self imagePath!

primaryStartup
	"Private - Perform very early startup actions.
	We must initialize the source manager fairly early on so that we can use the change log."

	self basicPrimaryStartup.
	self openSources!

productDetails
	"Private - Answers a five element<Array> describing this version of the development environment

	1. <readableString> Product name 
	2. <readableString> Short product name
	3. <Float> Version number
	4. <readableString> Version special
	5. <Integer> Image patch level
	6 <readableString> Very short product name
	7 <readableString> Serial number"

	productDetails isNil ifTrue: [productDetails := VMLibrary default defaultProductDetails].
	^productDetails!

productDetails: anArray
	"Private - Sets the receiver's product details to a five element<Array> 
	describing this version of the development environment"

	productDetails := anArray!

productVersion
	"Answers the <Float> version of this product"
	
	^VMLibrary default defaultProductDetails at: 3
!

saveImageDefault
	"Save an image of the current session to the default persistant store (whatever that is)."

	self class sourceManager flushChanges.
	self snapshot.!

saveImageTo: aString 
	"Private - Snapshot to filePath.img, marking the log with a timestamp and copying sources
	files. N.B. Use the public entry point #saveImage: to save an image to a new path.

	Take a special interest if we do not currently have the source files available. This will be
	the case when we load from a .exe. In this case we generate some suitable empty source
	files. We also have to mark methods so that they know they have lost any reference to
	information in a .sml file."

	| oldImagePath oldSentry |
	oldImagePath := self imagePath.
	oldSentry := sentry.

	"Now save image and swap over sources. Take care to end up with a good sources and imagePath"
	
	[self imagePath: aString.
	self createSentinel 
		ifTrue: 
			[| mb |
			mb := MessageBox new.
			mb beTaskModal.
			mb 
				errorMsg: ('The image <1p> is open in another Dolphin instance.<n><n>Close that instance and try again should you still wish to save this image to that name.<n><n>The image has not been saved!!' 
						expandMacrosWith: self imageFileName).
			^self].
	self class sourceManager copyAndReopenSources: self imagePath.
	self
		snapshot: self imageFileName;
		logComment: ('Image saved to <1p>' expandMacrosWith: aString).
	KernelLibrary default closeHandle: oldSentry] 
			ifCurtailed: 
				["Attempt to return to the old state so sources & stuff are intact
				 before showing the user the problem."
				
				[KernelLibrary default closeHandle: sentry.
				sentry := oldSentry.
				self
					imagePath: oldImagePath;
					openSources] 
						on: Error
						do: [:anError | anError resignalAsWarning]]!

shellClosed: aShell
	"Inform the receiver that aShell has been closed"
!

shellOpened: aShell
	"Inform the receiver that aShell has been opened"


!

shutdown
	"Perform shutdown operations before the VM puts out the lights."

	self trace: 'Shutting down boot session', String lineDelimiter.
	super shutdown!

snapshot
	"Private - Performs a snapshot of the current image."
	
	Notification signal: 'Saving booted image to ', self imageFileName.
	self snapshot: self imageFileName!

startUI
	"Start up the input loop/message loop (instruct InputState appropriate depending on whether
	this is a GUI or console session)."

	self inputState consoleStartup!

trace: aString
	"Append aString to the trace device.
	Use the stderr stream if available, otherwise the OS debug trace device (implemented in superclass)"

	stdioStreams isNil
		ifTrue: [super trace: aString]
		ifFalse: [self stderr nextPutAll: aString; flush]!

unhandledException: anException 
	"Private - Pop-up a walkback with details from the argument, anException."

	"Attempt to log the error, but don't allow it to become recursive (#logError: does not
	raise an exception if it fails)"
	| title topFrame |
	self logError: anException.
	title := [anException description] on: Error do: [:e | anException class name].
	topFrame := anException raisingFrame.

	"In a development session, we'll be wanting a walkback..."
	topFrame process 
		walkback: title
		topFrame: topFrame
		resumable: anException isResumable! !

ConsoleSessionManager comment:
'ConsoleSessionManager is the class of <SessionManager>s used to manage the life-cycle of a deployed console, or command-line, application.

The main entry point hook is the #main method. The program logic can be implemented entirely in #main in the case of simple applications, but it is recommended that a separate application class be constructed, with additional support classes as required. A console application normally exits when the #main method returns.

The standard C I/O streams, stdin/stdout/stderr, can be accessed by sending the #stdin, #stdout, and #stderr messages to the session. The resulting streams implement the full Smalltalk Stream protocols, and can be used interchangeably with normal streams. Furthermore these are connected to the actual C runtime library streams of the same name, and so calling C runtime library functions such as printf() (either from within Dolphin, or a DLL called from Dolphin) will result in output to the same console window. Note that these streams (and the console) are actually usable from <GUISessionManager>s too, which is useful for testing and debugging console applications from within the develoopment environment. The class side #run method provides a simple way to fire up a console application in the development environment, although the session manager is not actually installed.

A simple example of a console application is the command line version of the Hello World sample. Try it out be evaluating:

	CommandLineHelloWorld run    "Watch out for the appearance of the console, and press ENTER to continue"
'!
!ConsoleSessionManager class methodsFor!

isRuntime
	"Answer whether the sessions managed by instances of the receiver are for a run-time applications 
	(as opposed to development, or abstract)."

	^true!

new
	"Answer a new instance of the receiver. This is permited for ConsoleSessionManagers in order
	to facilitate testing."

	^self basicNew initialize;
		initializeFromSessionManager: self current;
		yourself!

run
	"Test this console program.
		self run
	"
	| consoleAlreadyOpen |

	"As this is used from the development environment, we must make sure that a console has been allocated.
	 If we opened it just for this test, then we want to close it before finishing"
	consoleAlreadyOpen := self current openConsole.
	self new main.
	consoleAlreadyOpen ifFalse: [self current closeConsole]! !

!ConsoleSessionManager methodsFor!

allocConsole
	"Private - Open a console for this session."

	"We already have one"!

basicTertiaryStartup
	"Perform fundamental tertiary system startup operations."

	self embeddedStartup!

freeConsole
	"Private - Close (actually detach from) the console for this session.
	In the case of a console app, we didn't allocate the console, so we don't
	free it (even though to do so would be harmless)."

	self assert: [consoleHandler isNil]!

isEmbedded
	"Answer whether the session is running, or should be started, in 'embedded' 
	mode (i.e. headless). This is an embedded session in so far as it has no GUI."

	^true!

logError: anException 
	"Append details about the unhandled exception, anException, to the session error log.
	Ignored for runtime systems, but it is suggested that subclasses perform some appropriate
	form of error logging. The VM crash dump is one such facility (it doesn't cause a crash and
	can be used for generating a VM walkback to the crash dump file at any time)"

	| stderrBad |
	stderrBad := false.
	
	[| target |
	target := self stderr.
	target
		next: 40 put: $-;
		nextPutAll: 'Unhandled exception - '.
	anException printTraceOn: target.
	target
		next: 40 put: $-;
		cr;
		cr] 
			on: Error
			do: [:e | stderrBad := true].

	"If we were unable to write to stderr for some reason, then produce a crash dump"
	(stderrBad or: [false]) ifTrue: [super logError: anException]!

onCloseConsole
	"The user is attempting to close the console window. Act accordingly (by shutting
	down the application)."

	self quit: -1!

openConsoleStreams
	"Private - Open the standard console I/O streams.
	In this case we attach to pre-existing C run-time library stdio streams, as they
	will be correctly set up."

	stdioStreams isNil ifTrue: [ | crt |
		crt := CRTLibrary default.
		stdioStreams := Array new: 3.
		0 to: 2 do: [:i | stdioStreams at: i+1 put: (StdioFileStream fromHandle: (crt getStdHandle: i))]].

	"Note that all the above streams should be in text/translating mode"!

startUI
	"Start up the input loop/message loop (instruct InputState appropriate depending on whether
	this is a GUI or console session)."

	self inputState consoleStartup!

unhandledException: anException
	"Private - The unhandled Exception, anException, occurred in the active Process.
	Depending on the user response and the resumability of the exception, either 
	resume or terminate the process.
	Note: The exception response protocol (#resume, #pass, #outer, #exit, etc)
	can only be sent to an Exception inside a handler block (i.e. the second
	argument to BlockClosure>>on:do:)."

	self logError: anException.
	"Note that unlike a GUI session (which is event driven), we kill the entire session in the event
	  of an unhandled Error. If you are writing a multi-threaded, headless, server then you may 
	  want to override this behaviour to just #terminate the faulting <Process>."
	anException isUserResumable ifFalse: [
		self quit: -1].
	^anException! !

NotificationSignal comment:
''!
!NotificationSignal class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Notification icon! !

!NotificationSignal methodsFor!

defaultAction: exception
	"Private - Perform the default action for the raised incarnation of the receiver,
	exception, as it has not been handled.
	Implementation Note: forward to the SessionManager for application specific handling."

	^SessionManager current onUnhandledNotification: exception!

defaultResumption
	"Private - Answer the default setting for the receiver's resumable flag."

	^true!

exceptionClass
	"Private - Answer the class of Exception to be raised when the receiver
	is signalled."

	^RaisedNotificationSignal! !

WarningSignal comment:
''!
!WarningSignal class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Warning icon! !

!WarningSignal methodsFor!

defaultAction: exception
	"Private - Perform the default action for the raised incarnation of the receiver,
	exception, as it has not been handled.
	Implementation Note: forward to the SessionManager for application specific handling."

	^SessionManager current onUnhandledWarning: exception! !

DefaultSortAlgorithm comment:
'DefaultSortAlgorithm implements the default sorting algorithm and sort-ordering as a sorting strategy for use in conjunction with <SortedCollection>s.

Currently DefaultSortAlgorithm is an implementation of the Introsort algorithm. This is a modified Quicksort that switches to Heapsort when it detects that quicksort is going quadratic. The sort-order relationship is fixed and always uses the #<= message to compare elements.

The default sort algorithm is not guaranteed to be a stable sort (in fact in the current implementation it definitely is not), i.e. if the collection has previously been sorted by some other criteria, then this previous ordering of sort equal elements is not maintained when resorting.'!
!DefaultSortAlgorithm class methodsFor!

current
	^Current!

initialize
	Current := self new!

pluggableEquivalentClass
	^IntrosortAlgorithm!

sortBlock: aDyadicValuable 
	^self pluggableEquivalentClass sortBlock: aDyadicValuable! !

!DefaultSortAlgorithm methodsFor!

compare: operand1 with: operand2 
	"Answer whether the <Object>, operand1, is considered equivalent to the <Object> argument,
	operand2, by this search policy."

	^operand1 <= operand2!

copyWithSortBlock: aDyadicValuable 
	^self class sortBlock: aDyadicValuable!

insertionSort: anObject from: startInteger to: stopInteger 
	startInteger + 1 to: stopInteger
		do: 
			[:j | 
			| a t i |
			a := anObject basicAt: j.
			i := j.
			[i <= startInteger or: [(t := anObject basicAt: i - 1) <= a]] whileFalse: 
					[anObject basicAt: i put: t.
					i := i - 1].
			anObject basicAt: i put: a]!

sift: anObject from: anInteger between: startInteger and: stopInteger 
	"Private-"

	"Implementation Note: Override purely to inline the sort order comparison."

	| val i |
	val := anObject basicAt: anInteger.
	i := anInteger.
	
	[| left right max j leftVal rightVal |
	max := val.
	j := i.
	left := j + j + 1 - startInteger.
	(left <= stopInteger and: [max <= (leftVal := anObject basicAt: left)]) 
		ifTrue: 
			[i := left.
			max := leftVal].
	right := left + 1.
	(right <= stopInteger and: [max <= (rightVal := anObject basicAt: right)]) 
		ifTrue: 
			[i := right.
			max := rightVal].
	i == j 
		ifTrue: 
			[j > anInteger ifTrue: [anObject basicAt: j put: val].
			^self].
	anObject basicAt: j put: max] 
			repeat!

sort: anObject from: startInteger to: stopInteger 
	"Sort elements in the range of indexable instance variables of the <Object> argument from
	startInteger through stopInteger to be non-descending according to the #<= message."

	| n |
	n := stopInteger - startInteger + 1.
	n <= 1 ifTrue: [^self].
	self 
		sort: anObject
		from: startInteger
		to: stopInteger
		limit: (self quicksortRecursionLimit: n)!

sort: anObject from: startInteger to: stopInteger limit: limitInteger 
	"Private - Sort elements in the range of indexable instance variables of the <Object> argument from
	startInteger through stopInteger to be non-descending according to the receiver's sort
	block."

	"Implementation Note: This is a copy of IntrosortAlgorithm>>introsort:from:to:limit: with
	the default sort order comparison inlined."

	| i j up lo limit |
	up := stopInteger.
	lo := startInteger.
	limit := limitInteger.
	[up - lo > 7] whileTrue: 
			[| temp pivot |
			(limit := limit - 1) == 0 
				ifTrue: 
					["Appears to be degenerating, so heapsort this partition"
					self 
						heapsort: anObject
						from: lo
						to: up.
					^self].
			"Choose median and arrange so [lo+1] <= [lo] <= [up]"
			j := lo + up bitShift: -1.
			i := lo + 1.
			temp := anObject basicAt: j.
			anObject basicAt: j put: (anObject basicAt: i).
			anObject basicAt: i put: temp.
			(anObject basicAt: up) <= temp 
				ifTrue: 
					[anObject basicAt: i put: (anObject basicAt: up).
					anObject basicAt: up put: temp].
			(anObject basicAt: up) <= (anObject basicAt: lo) 
				ifTrue: 
					[temp := anObject basicAt: up.
					anObject basicAt: up put: (anObject basicAt: lo).
					anObject basicAt: lo put: temp].
			(anObject basicAt: lo) <= (anObject basicAt: i) 
				ifTrue: 
					[temp := anObject basicAt: lo.
					anObject basicAt: lo put: (anObject basicAt: i).
					anObject basicAt: i put: temp].

			"Partition...(note we must test that i and j remain in bounds because the sort block may use <= or >=."
			j := up.	"i.e. start from up-1"
			pivot := anObject basicAt: lo.
			
			[[i < j and: [(anObject basicAt: (i := i + 1)) <= pivot]] whileTrue.
			[j >= i and: [pivot <= (anObject basicAt: (j := j - 1))]] whileTrue.
			j < i] 
					whileFalse: 
						[temp := anObject basicAt: i.
						anObject basicAt: i put: (anObject basicAt: j).
						anObject basicAt: j put: temp].

			"Insert partitioning element"
			anObject basicAt: lo put: (anObject basicAt: j).
			anObject basicAt: j put: pivot.

			"Skip sort-equal elements to speed up worst cases - suggested by John Brant"
			[(j := j - 1) > lo and: [pivot <= (anObject basicAt: j)]] whileTrue.

			"Recursively sort smaller sub-interval and process larger remainder on the next loop iteration"
			up - i < (j - lo) 
				ifTrue: 
					[self 
						sort: anObject
						from: i
						to: up
						limit: limit.
					up := j]
				ifFalse: 
					[self 
						sort: anObject
						from: lo
						to: j
						limit: limit.
					lo := i]].

	"When interval size drops below threshold perform an insertion sort (quicker for small
	numbers of elements)"
	self 
		insertionSort: anObject
		from: lo
		to: up!

sortBlock
	"Answer a <dyadicVariable> that implements the sort-order comparison in use by the receiver."

	^[:a :b | a <= b]! !

PluggableSortAlgorithm comment:
'PluggableSortAlgorithm is the class of <SortAlgorithm>s that allow the sort order relationship between elements to be configured by means of a pluggable sort block.

Instance Variables:
	sortBlock		<dyadicValuable> defines the sort-order relationship.

'!
!PluggableSortAlgorithm class methodsFor!

new
	"Answer a new instance of the receiver with the default sort block."

	^self sortBlock: [:a :b | a <= b]!

sortBlock: aDyadicValuable 
	^(self basicNew)
		setSortBlock: aDyadicValuable;
		yourself! !

!PluggableSortAlgorithm methodsFor!

copyWithSortBlock: aDyadicValuable 
	^self class sortBlock: aDyadicValuable!

setSortBlock: aDyadicValuable 
	sortBlock := aDyadicValuable!

sortBlock
	"Answer a <dyadicVariable> that implements the sort-order comparison in use by the receiver."

	^sortBlock! !

IntrosortAlgorithm comment:
'IntrosortAlgorithm implements David Musser''s introspective sort algorithm as a sorting strategy for use in conjunction with <SortedCollection>s.

Introsort is not a new sorting algorithm, but rather hybrid of two others. It exhibits high-performance of Quicksort on average, but without the latter''s worst cases. It achieves this by using Quicksort as its default algorithm, but switching to Heapsort when it appears that quicksort is going quadratic. It is still not as fast as Heapsort on Quicksorts worst cases, because Quicksort wastes some time before the advisability of switching to Heapsort is detected, but it is a reasonable compromise.

Introsort is not a stable sort, i.e. if the collection has previously been sorted by some other criteria, then the sort will not maintain this previous ordering for sort equal elements when resorting. Use <MergesortAlgorithm> if a stable sort is required.'!
!IntrosortAlgorithm methodsFor!

sort: anObject from: startInteger to: stopInteger 
	"Sort elements in the range of indexable instance variables of the <Object> argument from
	startInteger through stopInteger to be non-descending according to the receiver's sort
	block."

	| n |
	n := stopInteger - startInteger + 1.
	n <= 1 ifTrue: [^self].
	self 
		sort: anObject
		from: startInteger
		to: stopInteger
		limit: (self quicksortRecursionLimit: n)!

sort: anObject from: startInteger to: stopInteger limit: limitInteger 
	"Private - Sort elements in the range of indexable instance variables of the <Object> argument from
	startInteger through stopInteger to be non-descending according to the receiver's sort
	block."

	"Implementation Note: This is a modified copy of QuicksortAlgorithm>>sort:from:to: The only
	change is to add the recursion depth limit."

	| i j up lo cmp limit |
	up := stopInteger.
	lo := startInteger.
	cmp := self sortBlock.
	limit := limitInteger.
	[up - lo > 7] whileTrue: 
			[| a b |
			(limit := limit - 1) == 0 
				ifTrue: 
					["Appears to be degenerating, so heapsort this partition"
					self 
						heapsort: anObject
						from: lo
						to: up.
					^self].
			"Choose median and arrange so [lo+1] <= [lo] <= [up]"
			j := lo + up bitShift: -1.
			i := lo + 1.
			a := anObject basicAt: j.
			anObject basicAt: j put: (anObject basicAt: i).
			anObject basicAt: i put: a.
			(cmp value: (anObject basicAt: up) value: a) 
				ifTrue: 
					[anObject basicAt: i put: (anObject basicAt: up).
					anObject basicAt: up put: a].
			(cmp value: (anObject basicAt: up) value: (anObject basicAt: lo)) 
				ifTrue: 
					[a := anObject basicAt: up.
					anObject basicAt: up put: (anObject basicAt: lo).
					anObject basicAt: lo put: a].
			(cmp value: (anObject basicAt: lo) value: (anObject basicAt: i)) 
				ifTrue: 
					[a := anObject basicAt: lo.
					anObject basicAt: lo put: (anObject basicAt: i).
					anObject basicAt: i put: a].

			"Partition...(note we must test that i and j remain in bounds because the sort block may use <= or >=."
			j := up.	"i.e. start from up-1"
			b := anObject basicAt: lo.
			
			[[i < j and: [cmp value: (anObject basicAt: (i := i + 1)) value: b]] whileTrue.
			[j >= i and: [cmp value: b value: (anObject basicAt: (j := j - 1))]] whileTrue.
			j < i] 
					whileFalse: 
						[a := anObject basicAt: i.
						anObject basicAt: i put: (anObject basicAt: j).
						anObject basicAt: j put: a].

			"Insert partitioning element"
			anObject basicAt: lo put: (anObject basicAt: j).
			anObject basicAt: j put: b.

			"Skip sort-equal elements to speed up worst cases - suggested by John Brant"
			[(j := j - 1) > lo and: [cmp value: b value: (anObject basicAt: j)]] whileTrue.

			"Recursively sort smaller sub-interval and process larger remainder on the next loop iteration"
			up - i < (j - lo) 
				ifTrue: 
					[self 
						sort: anObject
						from: i
						to: up
						limit: limit.
					up := j]
				ifFalse: 
					[self 
						sort: anObject
						from: lo
						to: j
						limit: limit.
					lo := i]].

	"When interval size drops below threshold perform an insertion sort (quicker for small
	numbers of elements)"
	self 
		insertionSort: anObject
		from: lo
		to: up! !

ChunkSourceFiler comment:
''!
!ChunkSourceFiler class methodsFor!

on: aWriteStream sourceFileIndex: anInteger
	"Answer a new instance of the receiver for filing out source code onto the 
	<puttableStream> argument, and using the <integer>, anInteger, as the 
	source file index when asked to update the source descriptor of <sourceObject>s.
	If the argument is nil, then answer a null source filer that discards all filed source."

	^(self on: aWriteStream)
		sourceFileIndex: anInteger;
		yourself! !

!ChunkSourceFiler methodsFor!

emitCategories: aCollection for: aSymbol in: aClass 
	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesFor:;
		space.
	"#2144."
	self emitString: aSymbol printString.
	stream nextPut: $!!.
	aCollection asSortedCollection do: [:each | self nextChunkPut: each name].
	self endChunk!

emitCategoriesOfClass: aClass 
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	| categories |
	categories := aClass categories.
	categories notEmpty 
		ifTrue: 
			[stream
				nextPut: $!!;
				nextPutAll: aClass name;
				space;
				nextPutAll: #categoriesForClass;
				nextPutAll: '!!'.
			categories asSortedCollection do: [:aCategory | self nextChunkPut: aCategory name].
			self endChunk]!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append a chunk to the <puttableStream>, aWriteStream,
	to reclassify the <CompiledMethod>, aCompiledMethod, in all its current 
	method categories."

	self 
		emitCategories: aCompiledMethod realCategories
		for: aCompiledMethod selector
		in: aCompiledMethod methodClass!

emitChunk: aString 
	"Private - Output the specified text with a trailing end of chunk marker 
	to the argument, aWriteStream."

	self
		nextChunkPut: aString;
		cr!

emitComment: aString 
	"Private - Record aString to the change log as a comment. All comments
	logged are prefixed with a timestamp.
	N.B. Logging requests should be directed through the SessionManager."

	stream
		nextPut: $";
		nextPutAll: aString;
		nextPut: $";
		nextPut: $!!;
		cr;
		flush!

emitCommentOfClass: aClass 
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to the <puttableStream>
	aWriteStream."

	self emitChunk: aClass name , ' comment: ' , aClass comment printString!

emitFooterForMethodsOf: aClass 
	"Private - Ends the method definition chunks for aClass onto
	the source stream."

	self endChunk!

emitGUIDOfClass: aClass 
	"Private - Emit a GUID definition chunk for the <Class>, aClass, onto the <puttableStream>, aWriteStream."

	| guid |
	guid := aClass guid.
	stream
		nextPutAll: aClass name;
		nextPutAll: ' guid: (';
		nextPutAll: guid class name;
		nextPutAll: ' fromString: ';
		print: guid asString;
		nextPut: $);
		nextPut: $!!;
		cr!

emitHeaderForMethodsOf: aClass 
	"Private - Emits a category header for the class, aClass, to the source stream."

	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #methodsFor;
		nextPut: $!!!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, 
	to the source stream, updating the method's source descriptor if configured with a 
	source file index."

	self storeSource: aCompiledMethod getSource for: aCompiledMethod!

emitSetBehaviorFlag: flagName forClass: aClass 
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	stream
		print: aClass;
		space;
		nextPutAll: flagName;
		nextPutAll: ': true!!';
		cr!

emitString: aString 
	"Private - Print the <readableString>, aString, to the source stream, quoting any 
	embedded meta-characters so that it can be re-read as the exact same string when filed-in. 
	Answer aString.
	In this case we need only double embedded chunk markers, there being no other meta-characters."

	"Source will very rarely include the chunk terminator character so perform a fast search first...."

	(aString identityIncludes: $!!) 
		ifTrue: 
			[aString do: 
					[:character | 
					stream nextPut: character.
					"Double up embedded chunk markers"
					character == $!! ifTrue: [stream nextPut: $!!]]]
		ifFalse: [stream nextPutAll: aString].
	^aString!

endChunk
	"Private - Output an end of chunk marker to the argument, aStream."

	stream
		nextPutAll: ' !!';
		cr!

fileIn
	"File in the expressions/definitions from receiver's source stream, which is
	expected to be in the receiver's chunk format. Any methods that fail to compile are stubbed 
	with instances of <CompileFailedMethod> and errors are logged to the Transcript."

	
	[[stream atEnd] whileFalse: 
			[stream skipSeparators.
			(stream peekFor: $!!) 
				ifTrue: 
					["#methodsFor: expression (we hope) - don't log evaluation"

					| chunk reader |
					chunk := self nextChunk.
					reader := Compiler 
								evaluate: chunk
								for: self evaluationContext
								logged: false.
					reader isNil 
						ifTrue: 
							["The above evaluation failed to compile and the error will have
					been logged to the Transcript. Use the null ChunkReader to skip
					over the chunks in the source file."

							reader := ChunkReader null].
					reader fileInFrom: self]
				ifFalse: 
					["Normal expression evaluation - log it"

					| chunk |
					chunk := self nextChunk.
					Compiler 
						evaluate: chunk
						for: self evaluationContext
						logged: true]]] 
			on: MethodCompileFailed
			do: 
				[:n | 
				"If we get a method compilation error then we install a stub method so we'll be able 
			to see the source. For evaluations this does nothing, unfortunately"

				n
					beep;
					resumeWithStubMethod]!

fileOutBasicDefinitionOfClass: aClass 
	"Print a definition of the <Class>, aClass, onto the <puttableStream>, aWriteStream."

	aClass printDefinitionOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutBinaryGlobal: anAssociation 
	"File out the text representation of the non-<sourceObject> which is the value of the
	<Association>, anAssociation, onto the receiver's source stream. The key of the association
	is the global name. If the global is just an alias to a class, then we don't need to binary
	file it at all."

	| glob |
	glob := anAssociation value.
	(glob class isMeta and: [anAssociation key ~= glob name]) 
		ifTrue: 
			[stream
				nextPutAll: anAssociation key;
				nextPutAll: ' := ';
				print: anAssociation value;
				nextPut: $!!;
				cr.
			^self].
	stream
		nextPutAll: anAssociation key;
		nextPutAll: ' := ';
		print: Object;
		space;
		display: #fromBinaryStoreBytes:;
		space;
		cr.
	glob binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutExpression: aString
	"Append an immediate expression evaluation to the the source stream."

	self emitChunk: aString; cr!

fileOutPoolDictionary: aPoolDictionary 
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the <puttableStream>, aWriteStream. The definition should be sufficient to recreate a
	copy of the dictionary."

	| poolName value env |
	env := aPoolDictionary environment.
	poolName := aPoolDictionary name.
	stream
		nextPutAll: (env keyAtValue: env);
		nextPutAll: ' at: ';
		print: poolName;
		nextPutAll: ' put: (';
		nextPutAll: aPoolDictionary class name;
		nextPutAll: ' named: ';
		print: aPoolDictionary name.
	self emitChunk: ')'.
	aPoolDictionary associations asSortedCollection do: 
			[:a | 
			stream
				nextPutAll: poolName;
				nextPutAll: ' at: ';
				print: a key;
				nextPutAll: ' put: '.
			value := a value.
			value isLiteral 
				ifTrue: 
					[self emitChunk: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value printString])]
				ifFalse: 
					[stream
						nextPut: $(;
						print: Object;
						space;
						display: #fromBinaryStoreBytes:;
						space;
						cr.
					value binaryStoreBytes base64StoreOn: stream.
					self emitChunk: ')']].
	self emitChunk: poolName , ' shrink'!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to source stream,
	associating them with the <ClassDescription>, aClassDescription."

	aCollection isEmpty ifTrue: [^self].
	(aCollection asSortedCollection: [:a :b | (a name trueCompare: b name) <= 0]) do: 
			[:p | 
			stream
				nextPutAll: aClassDescription name;
				nextPutAll: ' methodProtocol: ';
				print: p asSymbol;
				nextPutAll: ' attributes: ';
				print: p attributes asArray;
				nextPutAll: ' selectors: #('.
			"We must print the selectors individually as their may be very many and the default print truncates after
			 a certain number of characters."
			p selectors asSortedCollection do: [:s | stream print: s] separatedBy: [stream space].
			self
				nextChunkPut: ')';
				cr].
	self cr!

getSourceFromDescriptor: sourceDescriptor
	"Answer the <readableString> source corresponding to the specified <integer> 
	descriptor, sourceDescriptor, from the receiver's source stream."

	stream position: (self sourcePositionFromDescriptor: sourceDescriptor).
	^self nextChunk!

logEvaluation: aString
	"Private - Log an immediate expression evaluation to the the source stream."

	stream nextPutAll: '"Evaluate"'; cr.
	self fileOutExpression: aString!

nextChunk
	"Private - Answer a <String> containing the text up to the next chunk marker in the receiver's source stream,
	undoubling embedded chunk markers. Leading white space is skipped. 
	Implementation Note: String concatenation is more efficient here in the loop body because most 
	chunks do not include embedded chunk markers."

	| result |
	stream skipSeparators.
	result := stream upTo: $!!.
	[stream atEnd or: [(stream peekFor: $!!) not]]
		whileFalse: [result := result, '!!', (stream upTo: $!!)].
	^result!

nextChunkPut: aString 
	"Private - Print the string, aString, to the <puttableStream> aWriteStream as a chunk. 
	This means doubling any chunk marker characters in the string and terminating 
	it with another chunk marker. Answer aString."

	self emitString: aString.
	stream nextPut: $!!.
	^aString!

sourceDescriptorForIndex: indexInteger position: positionInteger 
	"Private - Answer an <integer> source descriptor which encodes the <integer> source file
	index, indexInteger, and the <integer> source file position, positionInteger. The source
	file index must be in the range 0..15, and the position >= 0."

	^(indexInteger bitAnd: 16rF) bitOr: (positionInteger bitShift: 4)!

sourceFileIndex: anInteger
	"Private - Set the <integer> source file index associated with the receiver."

	sourceFileIndex := anInteger!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	stream nextPutAll: aClass name; nextPutAll: ' comment:'; cr.
	self storeSource: aString printString for: aClass.
	stream cr!

storeCommentString: aString forPackage: aPackage 
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	stream
		nextPut: $(;
		print: aPackage class;
		space;
		nextPutAll: #manager;
		space;
		nextPutAll: #packageNamed:;
		space;
		print: aPackage name;
		nextPutAll: ') ';
		nextPutAll: #comment:;
		cr.
	self storeSource: aString printString for: aPackage.
	stream cr!

storeSource: aString for: aSourceObject 
	"Private - Store the <readableString>, aString, as the source text for the <sourceObject>,
	aSourceObject. If the receiver has been associated with a source file (i.e. the
	sourceFileIndex is set) then update aSourceObject's source descriptor so that in future it
	retrieves the source text from the receiver's source stream."

	| position |
	position := stream position.
	self nextChunkPut: aString.
	sourceFileIndex notNil 
		ifTrue: 
			[aSourceObject sourceDescriptor: (self sourceDescriptorForIndex: sourceFileIndex position: position)]!

storeSourceString: aString forMethod: aCompiledMethod 
	"Private - Save the <readableString>, aString, as the source text for the 
	<CompiledMethod>, aCompiledMethod, to the receiver's source stream
	encoding the position and index into the methods source descriptor so that 
	the source may be retrieved later."

	| methodClass |
	methodClass := aCompiledMethod methodClass.
	self 
		emitHeaderForMethodsOf: methodClass; 
		cr;
		storeSource: aString for: aCompiledMethod;
		emitFooterForMethodsOf: methodClass;
		flush
! !

VeryBasicSourceManager comment:
'VeryBasicSourceManager provides the simplest possible external source code control aid for single developer systems. Files that are seen to be checked in are mde write protected; checked out files are write enabled.'!
!VeryBasicSourceManager class methodsFor!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	DefaultInstance class == self ifTrue: [self reset]! !

!VeryBasicSourceManager methodsFor!

checkIn: aStringFilename withComment: aStringComment
	"Check in aStringFilename using the receiver to set the file mode
	to read only. Signals an error if unsuccessful"

	(File isWriteable: aStringFilename set: false) ifFalse: [self error: 'check in failed' ].
!

checkOut: aStringFilename
	"Check out aStringFilename using the receiver to set the file mode
	to writeable. Signals an error if unsuccessful"

	(File isWriteable: aStringFilename set: true) ifFalse: [self error: 'check out failed' ].
!

get: aStringFilename
	"Get the latest version of aStringFilename from the receiver. 
	Since this is the file currently on disk do nothing"

! !

BlockFrame comment:
''!
!BlockFrame methodsFor!

argumentCount
	"Private - Answer the number of arguments to the receivers stack frame, this will 
	vary depending on whether the receiver is a frame for a block or method activation."
	
	^self block argumentCount!

block
	| context |
	context := self environment.
	^context class == BlockClosure ifTrue: [context] ifFalse: [context block]!

displayOn: aStream
	"Append a short textual description of the receiver to aStream appropriate
	for displaying in a stack trace."

	aStream nextPutAll: '[] in '.
	super displayOn: aStream!

isBlockFrame
	^true!

mapInitialIpFrom: aCompiledMethod to: debugCompiledMethod 
	| map debugMap i ip |
	map := aCompiledMethod debugInfo textMap.
	debugMap := debugCompiledMethod debugInfo textMap.
	self assert: [map size == debugMap size].
	ip := self block initialIP.
	i := self findIP: ip inTextMap: map.
	self assert: [(map at: i) key = ip].
	^(debugMap at: i) key!

method: aCompiledMethod 
	"Private - Set the method of the stack frame."

	"Implementation Note: Override to update the block's method reference as well.
	We have to be careful here because clean block's are shared objects, so we must
	make a copy of them before updating them."

	| block |
	super method: aCompiledMethod.
	block := self block.
	block isNil ifTrue: [^self].
	block isClean 
		ifTrue: 
			["Note that there may be other refs to the block in the stack, but we 
			  don't bother updating these because a clean block is a literal const 
			  and so it doesn't really matter how many copies there are"
			self assert: [self environment == block].
			block := block shallowCopy.
			self environment: block].
	block method: aCompiledMethod! !

STBInFiler comment:
''!
!STBInFiler class methodsFor!

initialize
	UpgradingMask := 1!

peekForSignatureIn: aReadStream
	"Answer whether the <readableStream> argument, aReadStream, appears to
	be an STB stream (or is positioned at the start of an STB stream). If the STB
	signature is found, then the stream is left positioned immediately after it, 
	otherwise the stream position is not changed."

	| position |
	position := aReadStream position.
	^(aReadStream next: self signature size) = self signature
		or: [aReadStream position: position. false]! !

!STBInFiler methodsFor!

basicNext
	"Private - Answer the next object from the receiver's stream.
	Implementation Note: This has been optimized to avoid having to create
	an STBPrefix object for every object loaded during de-serialization,
	this means that STBPrefix's private knowledge of the prefix format has
	been used here, which is not ideal, but the performance of serialization
	is critical for the time taken to instantiate views, etc."

	"First, read the prefix - ."

	| prefix class anObject newObjectIndex |
	prefix := self readInteger.
	prefix == 0 ifTrue: [^nil].	"optimize for nil"

	"SmallInteger?"
	(prefix allMask: SmallIntegerMask) ifTrue: [^prefix bitShift: -1].

	"Literal? (Hook for STL filer)"
	prefix == LiteralPrefixMask ifTrue: [^self readLiteralData].
	(prefix allMask: DataPrefixMask) 
		ifFalse: 
			[^(prefix allMask: CharacterMask) 
				ifTrue: [Character value: (prefix bitShift: IndexShift)]
				ifFalse: [self objectAt: (prefix bitShift: IndexShift)]].

	"Ascertain the class of the object."
	class := (prefix allMask: ClassPrefixMask) 
				ifTrue: [self readClassData: prefix]
				ifFalse: [self classAt: (prefix bitShift: IndexShift)].

	"Now read the object data."
	newObjectIndex := readMap size + 1.
	anObject := self readObjectOfClass: class.

	"If anObject was a proxy for the real one, evaluate it now."
	^anObject stbFixup: self at: newObjectIndex!

classAt: anInteger 
	"Private - Answer the map value for a class at anInteger. If anInteger is zero then answer nil.
	Signal an exception if there is no such entry."

	^self objectAt: anInteger.
	!

classLocator
	"Answer the receiver's classLocator inst var. This holds the context of any remote
	class references and provides the mechanism of resolving them."

	^classLocator!

classLocator: aClassLocator
	"Sets the receiver's classLocator instVar to aClassLocator.
	This is required to hold the context of any relative class reference and to provide
	the mechanism for resolving it."

	classLocator := aClassLocator!

contents
	"Answer an array of the objects stored in the stream."

	| writeStream |
	writeStream := Array writeStream: 16.
	[self atEnd]
		whileFalse: [writeStream nextPut: self next].
	^writeStream contents!

defaultClassLocatorClass
	"Answer the class of Class Locator to use by default for finding and validating
	classes in the receiver's input stream."

	^ClassLocator!

deferAction: aNiladicValuable
	"Add the <niladicValuable> argument to the receiver's deferredActions collection for later 
	evaluation just before the receiver answers from its #next method. This method is available for 
	use by the #fixup:at: method of STBProxy classes to defer a <niladicValuable> for fixing-up
	of new instances when all filed-in objects are in a known state."

	deferredActions isNil ifTrue: [deferredActions := OrderedCollection new].
	deferredActions addLast: aNiladicValuable!

evaluateDeferredActions
	"Private - Evaluate any deferred actions then clear the deferredActions collection."

	deferredActions notNil ifTrue: [
		deferredActions do: [:aNiladicValuable | aNiladicValuable value].
		deferredActions := nil]!

fixup: anInteger to: anObject
	"Replace the readMap entry at anInteger with anObject."

	readMap at: anInteger put: anObject
!

initialize
	"Private - Initialize the receiver."

	classLocator := self defaultClassLocatorClass new.
	flags := 0.
	^super initialize!

isUpgrading
	^flags allMask: UpgradingMask!

isUpgrading: aBoolean 
	flags := flags mask: UpgradingMask set: aBoolean!

next
	"Answer the next object from the receiver's stream."

	| nextObject |
	nextObject := self basicNext.
	self evaluateDeferredActions.
	^nextObject!

objectAt: anInteger
	"Private - Answer the map value at anInteger. If anInteger is zero then answer nil.
	Signal an exception if there is no such entry."

	^anInteger == 0 
		ifFalse: [readMap at: anInteger ifAbsent: [self class errorInconsistentSTB: anInteger]]!

readClassData: anInteger 
	"Private - Answer the class whose details are prefixed by the specified <integer> flags
	in <STBPrefix> format."

	| versionBeingRead class |
	versionBeingRead := (anInteger allMask: NonZeroVersionMask) ifTrue: [self readInteger] ifFalse: [0].
	class := self readClassLocator: anInteger.
	self register: class.
	versionBeingRead = class stbVersion 
		ifFalse: 
			[| format |
			format := STBClassConversion 
						forFiler: self
						class: class
						version: versionBeingRead
						prefix: anInteger.
			format converterBlock isNil 
				ifTrue: [^self class errorUnrecognisedClass: class version: versionBeingRead].
			converters at: class put: format].
	^class!

readClassLocator: anIntegerFlags 
	| locatorString |
	locatorString := (stream next: (anIntegerFlags bitShift: LocatorLenShift)) asString.
	^(classLocator key: locatorString) locateClass!

readInteger
	"Private - Answer the next 32-bit integer in the stream."

	^stream nextSDWORD!

readLiteralData
	self shouldNotImplement!

readMap
	"Private - Answer the value of the receiver's readMap. This is an OrderedCollection of all
	the object read so far from the filer. It is used  to map the object identifiers in
	the file stream (which are really the indices into the collection) to the actual
	objects"

	^readMap!

readObjectOfClass: aClass 
	| converter |
	converter := converters at: aClass ifAbsent: [].
	^aClass stbReadFrom: self format: converter!

readObjectOfClass: aClass format: anSTBClassConversion 
	"Private - Read the stream for the data to create an instance of aClass."

	| basicSize fullSize newObject |
	basicSize := (self version < 3 or: [aClass isVariable]) ifTrue: [self readInteger] ifFalse: [0].
	"Create a new object of sufficient size to hold the stored data."
	anSTBClassConversion isNil 
		ifTrue: 
			["The object is of the current format.
			Create an instance of the appropriate class."
			fullSize := aClass instSize + basicSize.
			newObject := aClass isVariable ifTrue: [aClass basicNew: basicSize] ifFalse: [aClass basicNew]]
		ifFalse: 
			["The object is of an old format.
			Create an Array or ByteArray to hold the stored data. This is
			passed to the converter block which answers an instance of the
			real class initialised from it."
			fullSize := anSTBClassConversion instSize + basicSize.
			newObject := (anSTBClassConversion isBytes ifTrue: [ByteArray] ifFalse: [Array]) basicNew: fullSize].
	"Register the new object before reading its instance variables, in case of circular references"
	self register: newObject.

	"Read the object's instance data."
	aClass isBytes 
		ifTrue: 
			["Many of these objects will be Strings, so some optimization may be possible"
			1 to: fullSize do: [:i | newObject basicAt: i put: stream next]]
		ifFalse: [1 to: fullSize do: [:i | newObject instVarAt: i put: self basicNext]].
	anSTBClassConversion notNil 
		ifTrue: 
			["Initialise a new instance from the old format object data and become it."
			newObject become: (anSTBClassConversion converterBlock value: newObject)].
	^newObject!

register: anObject 
	"Private - Add anObject to the readMap. Answer the registered objects unique reference."

	readMap addLast: anObject.
	^readMap size!

reset
	"Private - Reset the instance.
	Read the stream to establish whether it is in STB format
	and if so initialise the readMap."

	self resetAndValidateStream.
	readMap := OrderedCollection new: 512.
	converters := IdentityDictionary new.
	deferredActions := nil.
	super reset!

resetAndValidateStream
	| char |
	(self class peekForSignatureIn: stream) ifFalse: [self class errorNotSTB].
	version := 0.
	[(char := Character value: stream next) isDigit] 
		whileTrue: [version := version * 10 + char digitValue].
	char = Character space ifFalse: [self class errorNotSTB].
	version > self class version ifTrue: [self class errorVersion: version]!

setRefOffset: anInteger
	readMap setSize: anInteger!

timedNext
	"Answer the next object from the receiver's stream."

	| nextObject |
	Notification signal: (Time millisecondsToRun: [nextObject := self basicNext]) displayString.
	self evaluateDeferredActions.
	^nextObject! !

STBOutFiler comment:
'<STBOutFiler> is the basic binary filer for serializing a tree of <Object>s to a byte stream.

Instance Variables:
	writeMap		<IdentityDictionary>. Map of <Object>s to their <SmallInteger> id in the binary output stream.
	globals		<IdentityDictionary>. Map of global <Object>s to their associated global name <Symbol>s.
	globalNils		<OrderedCollection> of <Symbol>s being the names of nil value global variables written to the stream.
	proxyOverrides	<IdentityDictionary>. Map of <Object>s to the <STBProxy>s (or special values) output in their place.

'!
!STBOutFiler methodsFor!

basicNextPut: anObject 
	"Private - Write anObject to the stream in STB format."

	anObject isNil ifTrue: [^self writeInteger: 0].
	"If anObject has been registered as a global then we wrap it up as an STBGlobalObjectProxy
	and output that instead."
	(self objectIsGlobal: anObject) ifTrue: [^self putGlobal: anObject].

	"SmallIntegers can be encoded entirely within the prefix."
	anObject isImmediate 
		ifTrue: 
			[anObject class == SmallInteger 
				ifTrue: [^self writeInteger: (STBPrefix forSmallInteger: anObject) dword].

			"Characters can be encoded entirely within the prefix."
			anObject class == Character ifTrue: [^self writeInteger: (STBPrefix forCharacter: anObject) dword].
			self error: 'unrecognised immediate object type'].

	"References to objects already output can also be encoded entirely within the prefix."
	(self refForObject: anObject) 
		ifNotNil: [:refIndex | ^self writeInteger: (STBPrefix forObjectRef: refIndex) dword].

	"If anObject is the subject of an override:with: message then we output the 'with' proxy object instead."
	proxyOverrides at: anObject
		ifPresent: 
			[:objectToSave | 
			objectToSave notNil ifTrue: [proxyOverrides removeKey: anObject].
			^self saveObject: anObject as: objectToSave].
	(self objectIsLiteral: anObject) ifTrue: [^self putLiteral: anObject].

	"Let anObject output itself."
	anObject stbSaveOn: self!

nextPut: anObject
	"Write anObject to the stream in STB format."

	self basicNextPut: anObject.
	^anObject!

objectIsGlobal: anObject 
	"Private - Answer true if anObject has been registered as global."

	anObject isNil ifTrue: [^globalNils notEmpty].
	^globals includesKey: anObject!

objectIsLiteral: anObject 
	"Private - Override hook for the STL filter"

	^false!

override: anObject with: anObjectToSave
	"This is an opportunity circumvent the running of anObject's #stbSaveOn: method by
	pre-specifying the required behaviour. The possible actions depend on the value of anObjectToSave.
	If anObjectToSave is:
		0
			This will cause anObject to be output as normal (ie. with no proxy).
		nil
			This will cause nil to be output in place of anObject.
		an STBProxy
			This will be output in place of the receiver. It will be sent a #fixup:at:
			message at load time and should then answer the object it represents."

	anObject isNil ifFalse: [proxyOverrides at: anObject put: anObjectToSave]!

putGlobal: anObject 
	"Private - Wrap anObject up as an STBGlobalObjectProxy and output that instead."

	| symbol |
	anObject isNil 
		ifTrue: [symbol := globalNils removeFirst]
		ifFalse: 
			[| symbolCollection |
			symbolCollection := globals at: anObject.
			symbol := symbolCollection removeFirst.
			symbolCollection isEmpty ifTrue: [globals removeKey: anObject]].
	self basicNextPut: (STBGlobalObjectProxy for: anObject name: symbol)!

putLiteral: anObject
	self shouldNotImplement!

refForObject: anObject
	"Private - Answer the map index of anObject or nil if it is not present.
	The nil object has a conceptual index of zero." 

	anObject isNil
		ifTrue: [^0].

	^writeMap at: anObject ifAbsent: []!

register: anObject
	"Private - Add anObject to the map of output objects."

	writeMap at: anObject put: writeMap size + refOffset!

register: anObject asGlobal: aSymbol
	"Add anObject to the globals dictionary.
	When this object is output it will be wrapped in an STBGlobalObjectProxy.
	When the proxy is subsequently loaded it be added to Smalltalk with the
	name aSymbol. If the same object is registered as several global symbols
	then it must be #nextPut: a corresponding number of times." 

	(anObject isNil
		ifTrue: [globalNils]
		ifFalse: [globals at: anObject ifAbsentPut: [OrderedCollection new]]) add: aSymbol!

reset
	"Private - Reset the instance.
	Write the fixed-format header to stream. This enables the reader to identify
	the version of the written data."

	refOffset := 1.
	writeMap := IdentityDictionary new: 128.
	globals := IdentityDictionary new: 8.
	globalNils := OrderedCollection new: 8.
	proxyOverrides := IdentityDictionary new.
	self resetStream.
	super reset!

resetStream
	stream
		nextPutAll: self class signature;
		nextPutAll: self class version displayString asByteArray;
		nextPut: Character space codePoint!

saveObject: aNonImmediateObject
	"Write anObject to the stream in STB format as normal.
	Note that the argument must NOT be a SmallInteger or other immediate object,
	neither should it be another 'special' object such as nil.
	This is a low-level method, and is not intended for normal binary object streaming - 
	use #nextPut: instead."

	self writeObject: aNonImmediateObject as: aNonImmediateObject withPrefix: STBPrefix forData!

saveObject: anObject as: anObjectToSave
	"Write anObject to the stream in STB format as anObjectToSave."

	"If anObjectToSave is zero then output anObject as normal (ie. without any proxy)."
	anObjectToSave == 0
		ifTrue: [^self saveObject: anObject].

	"A proxy of nil means output nil instead of anObject."
	anObjectToSave isNil
		ifTrue: [^self basicNextPut: nil].

	"Output anObject to save instead of anObject marking it as a proxy so the STBInFiler
	knows to do a #fixup:to on input."
	self writeObject: anObject as: anObjectToSave withPrefix: STBPrefix forProxy!

setRefOffset: anInteger
	refOffset := anInteger - writeMap size + 1!

writeClass: anObject withLocator: locatorString 
	stream nextPutAll: locatorString asByteArray!

writeClass: class withPrefix: anSTBPrefix 
	"Private - An object of the <Class>, class, is about to be written to the binary stream,
	output an appropriate class prefix for it."

	(self refForObject: class) 
		ifNotNil: 
			[:refIndex | 
			"class has already been output 	so we can encode a short reference to the class within the prefix."
			self writeInteger: (anSTBPrefix classRef: refIndex) dword]
		ifNil: 
			["hitherto unencountered class so we need to save full class details in the object header."
			| classVersion locatorString |
			locatorString := class name asString.
			self writeInteger: (anSTBPrefix class: class locator: locatorString) dword.
			(classVersion := class stbVersion) ~~ 0 ifTrue: [self writeInteger: classVersion].
			self writeClass: class withLocator: locatorString.
			self register: class]!

writeInstanceVariables: objectToSave 
	"Private - Dump the instance variables of the <Object> argument to the binary stream."

	| class basicSize |
	class := objectToSave basicClass.
	basicSize := objectToSave basicSize.
	class isVariable ifTrue: [self writeInteger: basicSize].
	class isBytes 
		ifTrue: 
			["#1132: Temp patch for rare 4-byte STB corruption"
			1 to: basicSize do: [:i | stream nextPut: (objectToSave basicAt: i)]
			"stream next: basicSize putAll: objectToSave yourAddress asExternalAddress startingAt: 1"]
		ifFalse: [1 to: class instSize + basicSize do: [:i | self basicNextPut: (objectToSave instVarAt: i)]]!

writeInteger: anInteger
	"Private - Write anInteger to the stream."

	stream nextSDWORDPut: anInteger!

writeObject: anObject as: objectToSave withPrefix: anSTBPrefix
	"Private - Represent anObject on the stream as objectToSave giving it a prefix of anSTBPrefix."

	self 
		writeClass: objectToSave class withPrefix: anSTBPrefix;
		register: anObject;
		writeInstanceVariables: objectToSave!

writePreambleFor: anObject 
	"Write the normal STB pre-amble for anObject to the output stream. The object is also
	registered in the write map so that any subsequent refs are shared. This method is intended
	for use from custom implementations of the class side #stbSaveOn: message."

	self
		writeClass: anObject class withPrefix: STBPrefix forData;
		register: anObject! !

STBValidatingInFiler comment:
'STBValidatingInFiler is a specialisation of STBInFiler that is capable of validating the classes of objects appearing in a STB input stream before the objects are actually allowed to be loaded.  This is important since STB is generally considered to be an insecure storage mechanism as it can allow arbitrary classes and blocks of code to be imported. Hence the STBValidatingInFiler is useful in situations where it is important to guarantee that only "safe" objects can be loaded (e.g. DolphinSure certificates need to be secure and yet are often stored using STB streams).  

After instantiating an instance of STBValidatingInFiler, it can be configured with a validation block (using #validationBlock:) that takes a symbolic class name as a single parameter.  The block can be used to indicate whether instances of this class should be considered to be safe in the context of the input stream.  If the block evaluates to true the object load will be allowed whereas if it evaluates to false the load will be denied by signalling a STBError.'!
!STBValidatingInFiler class methodsFor!

errorInvalidClass: aClassName 
	"Private - Signal an exception to warn that an input stream contains an invalid class."

	STBError signal: ('Input stream contains an invalid class (<1s>)' expandMacrosWith: aClassName)! !

!STBValidatingInFiler methodsFor!

classAt: anInteger 
	"Private - Answer the map value for a class at anInteger. If anInteger is zero then answer nil.
	Signal an exception if there is no such entry."

	| class |
	class := super classAt: anInteger.
	(self validationBlock value: class name) 
		ifFalse: [STBValidatingInFiler errorInvalidClass: class name].
	^class!

defaultClassLocatorClass
	"Answer the class of Class Locator to use by default for finding and validating
	classes in the receiver's input stream."

	^ValidatingClassLocator!

validationBlock
	"Private - Answer the monadic valuable (usually a block) that when passed a class name symbol will answer true if objects
	of this class are valid for loading from the receiver."

	^self classLocator validationBlock
!

validationBlock: aMonadicValuable 
	"Set the monadic valuable (usually a block) that when passed a class name symbol will answer true if objects
	of this class are valid for loading from the receiver."

	self classLocator validationBlock: aMonadicValuable.! !

STBClassProxy comment:
''!
!STBClassProxy class methodsFor!

for: aClass 
	#deprecated.
	^self forClass: aClass!

forClass: aClass
	"Answer a new instance with its locator key representing aClass."

	^self basicNew
		locatorKey: aClass name asString;
		packageName: aClass owningPackage name;
		yourself!

stbConvertFrom: anSTBClassFormat 
	"Convert from earlier version models.
	1: Added 'packageName' instance variable."

	^
	[:data | 
	| newInst |
	newInst := self basicNew.
	data keysAndValuesDo: [:i :v | newInst instVarAt: i + 1 put: v].
	newInst]!

stbVersion
	"Answer the current binary filer version number for instances of the receiver."

	^1! !

!STBClassProxy methodsFor!

locatorKey: aString
	"Private - Set the receiver's locatorKey inst var to aString."

	locatorKey := aString!

packageName: aString
	"Private - Set the receiver's package name inst var to aString."

	packageName := aString!

resolveWithClassLocator: aClassLocator 
	"Private - If the class represented by the <ClassLocator> argument is a resident class or a
	loaded imported class then answer the class. Otherwise answer a <ClassStub> representing the
	class which will be resolved when it is first used."

	^aClassLocator findAvailableClass ifNil: [self withClassLocator: aClassLocator]!

stbFixup: inFiler at: anInteger
	"Resolve the receiver to either the behaviour it represents or an appropriate stub class."

	| behaviourOrStub classLocator |

	"Create a class locator that can be used to find this class"
	classLocator := inFiler classLocator copyWithCodeBase.
	classLocator key: locatorKey; packageName: packageName.

	behaviourOrStub := self resolveWithClassLocator: classLocator.
	inFiler fixup: anInteger to: behaviourOrStub.

	^behaviourOrStub.!

withClassLocator: aClassLocator 
	^(Smalltalk at: #ClassStub ifAbsent: []) 
		ifNotNil: [:classStub | classStub withClassLocator: aClassLocator]! !

STBCollectionProxy comment:
''!
!STBCollectionProxy class methodsFor!

class: aClass array: anArray
	"Answer a new instance containing the class and elements of
	the collection that it represents."

	^self basicNew
		class: aClass;
		array: anArray;
		yourself
	!

for: aCollection 
	#deprecated.
	^self forCollection: aCollection!

forCollection: aCollection 
	"Answer a new instance representing aCollection."

	^self class: aCollection class array: aCollection asArray! !

!STBCollectionProxy methodsFor!

array: anArray
	"Private - Set the array inst var to anArray, the elements of the collection represented by the receiver.
	The use of the empty array literal enables the STBOutFiler to issue a shorter object reference for
	any subsequent empty instances of the receiver."

	array := anArray isEmpty
		ifTrue: [#()]
		ifFalse: [anArray]
!

class: aClass
	"Private - Set the class of the object represented by the receiver."

	class := aClass
!

value
	"Answer a new collection of class class and elements array."

	^class withAll: array! !

STBExternalResourceLibraryProxy comment:
'STBExternalResourceLibraryProxy is the class of <STBProxy>s used to save the state necessary to re-open an <ExternalResourceLibrary> from an STB stream. We use a special proxy in order to share a common instance so that each resource library need only be opened once.'!
!STBExternalResourceLibraryProxy class methodsFor!

forLibrary: lib
	"Answer a new instance representing the <ExternalResourceLibrary>, lib."

	^self basicNew
		fileName: lib fileName;
		yourself! !

!STBExternalResourceLibraryProxy methodsFor!

fileName: path
	"Private - Set the file name of the library represented by the receiver
	to the <readableString>, path."

	fileName := path!

stbFixup: inFiler at: id
	"Answer the object that this one represents.
	Implementation Note: The library that we represent may already be open 
	and cached in the table of open resource libraries, so we must not use become: 
	to swap the receiver with it. Instead we need to tell inFiler to replace 
	its (only) readMap entry for the receiver with the object it represents."

	| anObject |
	anObject := self value.
	inFiler fixup: id to: anObject.
	^anObject!

value
	"Answer an <ExternalResourceLibrary> opened on the receiver's
	file path name."

	^ExternalResourceLibrary open: fileName! !

STBGlobalObjectProxy comment:
''!
!STBGlobalObjectProxy class methodsFor!

for: anObject name: aSymbol
	"Answer an instance of the receiver representing the global anObject
	which will be made global on load with the name asymbol."

	^self basicNew
		symbol: aSymbol;
		object: anObject;
		yourself! !

!STBGlobalObjectProxy methodsFor!

object: anObject
	"Private - Set the receiver's object inst var."

	object := anObject!

stbFixup: inFiler at: anInteger
	"Answer the object that this one represents.
	We must not use #become: to swap the receiver with the represented
	object because the object is either:
		a reference to an existing global, or
		a new global that may be nil but in this case there will never
		be other references to the proxy.

	We need to tell inFiler to replace its readMap entry for our answer."

	| anObject |
	anObject := self value.
	inFiler fixup: anInteger to: anObject.
	^anObject!

stbSaveOn: anSTBOutFiler
	"Save out a binary representation of the receiver to anSTBOutFiler.
	This is a rather unusual case. This outputs itself as its own proxy.
	Mmm... It's just a trick used by STBOutFiler, best not to copy this idea."

	anSTBOutFiler saveObject: self as: self!

symbol: aSymbol
	"Private - Set the symbol inst var to aSymbol."

	symbol := aSymbol!

value
	"Install object as a global in the Smalltalk System Dictionary and answer it."

	^Smalltalk at: symbol put: object! !

STBSingletonProxy comment:
''!
!STBSingletonProxy class methodsFor!

for: aClass 
	#deprecated.
	^self forClass: aClass!

for: aClass using: aSelectorSymbol 
	#deprecated.
	^self forClass: aClass using: aSelectorSymbol!

forClass: aClass 
	"Answers an instance of the receiver that represents the singleton class, aClass.
	It is assumed that aClass will exist in the destination image and #current will
	be sent to it to yield the appropriate singleton instance"

	^self forClass: aClass using: #current!

forClass: aClass using: aSelectorSymbol 
	"Answers an instance of the receiver that represents the singleton class, aClass.
	It is assumed that aClass will exist in the destination image and aSelectorSymbol will
	be sent to it to yield the appropriate singleton instance"

	^(self basicNew)
		class: aClass;
		selector: aSelectorSymbol;
		yourself! !

!STBSingletonProxy methodsFor!

class: aClass
	"Set the receiver's class inst var."

	class := aClass!

selector: aSymbol
	"Set the receiver's selector inst var."

	selector := aSymbol!

stbFixup: inFiler at: anInteger
	"Answer the object that this one represents.
	We must not use #become: to swap the receiver with the represented
	object. We need to tell inFiler to replace its readMap entry for our answer."

	| anObject |
	anObject := class perform: selector.
	inFiler fixup: anInteger to: anObject.
	^anObject! !

STBMetaclassProxy comment:
''!
!STBMetaclassProxy class methodsFor!

forClass: aMetaclass
	"Answer a new instance representing aMetaclass."

	^super forClass: aMetaclass instanceClass! !

!STBMetaclassProxy methodsFor!

resolveWithClassLocator: aClassLocator 
	"Private - If the class represented by the <ClassLocator> argument is a resident class or a
	loaded imported class then answer the class' metaclass. Otherwise answer a <MetaclassStub>
	representing the Metaclass which will be resolved when it is first used."

	^aClassLocator findAvailableClass 
		ifNotNil: [:availableClass | availableClass class]
		ifNil: [self withClassLocator: aClassLocator]!

withClassLocator: aClassLocator 
	^(Smalltalk at: #MetaclassStub ifAbsent: []) 
		ifNotNil: [:classStub | classStub withClassLocator: aClassLocator]! !

STBIdentityDictionaryProxy comment:
''!
!STBIdentityDictionaryProxy class methodsFor!

forCollection: anIdentityDictionary
	"Answer a new instance of the receiver which contains the key-value object pairs
	of anIdentityDictionary as an Array."

	| tempStream |
	tempStream := Array writeStream: anIdentityDictionary size * 2.
	anIdentityDictionary keysAndValuesDo: [
		:key :value |
		tempStream
			nextPut: key;
			nextPut: value].	
	^self
		class: anIdentityDictionary class
		array: tempStream contents
! !

!STBIdentityDictionaryProxy methodsFor!

value
	"Answer a new IdentityDictionary from the key-value pairs held by the receiver."

	| inst |
	inst := class new: (array size) / 2.
	1 to: array size by: 2 do: [:i |
		inst
			at:  (array at: i)
			put: (array at: i + 1)].
	^inst! !

STBSortedCollectionProxy comment:
''!
!STBSortedCollectionProxy class methodsFor!

forCollection: aSortedCollection 
	"Answer a new instance representing aSortedCollection."

	^(super forCollection: aSortedCollection)
		sortBlock: aSortedCollection sortBlock;
		yourself! !

!STBSortedCollectionProxy methodsFor!

sortBlock: aBlock
	"Private - Set the sortBlock inst var to aBlock."

	sortBlock := aBlock
!

value
	"Answer a new SortedCollection with elements, array, and sort block, sortBlock."

	"Implementation Note: The collection is assumed to be sorted in the correct order, so the sort block
	is not evaluated at all. This modification for 5.02 makes it safe to at least load an STB file containing a 
	SortedCollection. Previously if the sortBlock contained malicious code, then that code would be run	
	purely as a result of realizing the content of the STB. This does mean that potentially a SortedCollection
	may not be correctly sorted if the sort criteria differ for some reason between the source image and
	the destination image. Where this is possible the application must explicitly #reSort the collection."

	^(class new: array size)
		sortBlock: sortBlock;
		addAllWithoutSorting: array;
		yourself! !

Random comment:
'Random is a subclass of <Stream> that determines its elements based on an algorithm employing a number as a seed. Random itself is abstract, but has various concrete subclasses that implement different pseudo-random number generation algorithms. Attempts to instantiate an instance of Random will answer an instance of the default generator, which is usually the Park & Miller multiplicative congruential generator. This is a good generator, but uses FP arithmetic and is therefore rather slower than the typical quick''n''dirty generator one finds in most C runtime libraries. 

Random provides a concrete implementation of #atEnd, but because the size of the collection is infinite, it never ends.

Instance Variables:
	seed		<Integer>. Random seed'!
!Random class methodsFor!

defaultGeneratorClass
	^DefaultGeneratorClass!

defaultGeneratorClass: aClass 
	DefaultGeneratorClass := aClass!

initialize
	DefaultGeneratorClass := RandomParkMiller!

isAbstract
	^self == ##(self)!

new
	"Answer a new Random number generator seeded off the system clock."

	^self seed: (self systemClockSeed bitOr: 1)!

newConcrete
	^self isAbstract ifTrue: [self newDefault] ifFalse: [self basicNew]!

newDefault
	^DefaultGeneratorClass new!

seed: anInteger 
	"Anwer a new Random stream with the initial seed anInteger. Due
	to a limitation of the Park and Miller algorithm, the seed cannot
	be zero."

	^(self newConcrete)
		seed: anInteger;
		yourself!

systemClockSeed
	| seed |
	seed := Delay millisecondClockValue bitAnd: 16r3FFFFFFF.
	seed = 0 ifTrue: [seed := 1].
	^seed! !

!Random methodsFor!

atEnd
	"Answer whether the Stream is at its end - never true for a Stream of Random numbers"

	^false
!

chiSquareTest: N max: r 
	"Private - Perform a chi-square test on N numbers in the range 0..r-1.
	e.g. 
		RandomLinearCongruential newANSIC chiSquareTest: 5000000 max: 100		
		RandomLinearCongruential newParkMiller chiSquareTest: 5000000 max: 100
		RandomCRT new chiSquareTest: 5000000 max: 100		

	It should yield a value in the range 80..120, the nearer to 100 the better."

	| f t |
	f := (1 to: r) collect: [:i | 0].
	N timesRepeat: 
			[| i |
			i := self next.
			i := (i * r) truncated.
			f basicAt: i + 1 put: (f basicAt: i + 1) + 1].
	t := 0.
	1 to: r do: [:i | t := t + (f basicAt: i) squared].
	^r asFloat * t / N - N!

isReadable
	"Answer whether the receiver can be read from (i.e. it implements the 
	gettableStream protocol)."

	^true!

peek
	"Answer a pseudo-Random floating point number between 0 and 1 generated
	from the next seed, but do not advance down the stream (i.e. self peek = self peek)."

	^self subclassResponsibility!

seed
	"Answer the receiver's seed."

	^seed!

seed: anInteger
	"Set the seed of the Random stream to anInteger (or 1 if zero)."

	seed := anInteger max: 1!

skip: anInteger
	"Set the receiver's position reference to be the current position plus
	the argument, anInteger, possibly adjusting the result so as to remain
	within the bounds of the collection."

	anInteger < 0 ifTrue: [self error: 'Cannot move backwards in Random number stream'].
	anInteger timesRepeat: [self next]! !

SequencedStream comment:
'SequencedStream is an class of <Stream>s that stream over a finite number of past and future sequence values, maintaining a current position among those sequence values and allowing that position to be altered. Sub-instances of <SequencedStream> conform to the ANSI <sequencedStream> protocol.'!
!SequencedStream methodsFor!

contents
	"Answer a <sequencedReadableCollection> that contains the receiver's past and future
	sequence values, in order, i.e. the complete contents of the stream."

	^self subclassResponsibility
!

copyFrom: startInteger to: stopInteger 
	"Answer a new <sequencedReadableCollection> like that streamed over by the receiver
	containing those elements of the receiver between the specified one-based <integer> indices,
	inclusive, and in the same order. The stream position is left unchanged."

	| answer mark |
	mark := self position.
	self position: startInteger - 1.
	answer := self next: stopInteger - startInteger + 1.
	self position: mark.
	^answer!

flush
	"No-op to allow non-FileStreams to be used interchangeably with FileStream."

	^self!

isEmpty
	"Answer whether the sets of both past and future sequence values are empty."

	^self size == 0!

nextLine
	"Answer a Collection consisting of the receiver contents up to (but not including) the next
	line delimiter. If there are no further line delimiters in the receiver, then the rest of
	the receiver's contents are answered. If the receiver is at its end, then an empty
	collection is answered. "

	"N.B. This method works for Unix and Windows line delimiters (that is CR/LF and LF sequences
	respectively), but not if the line delimiter consists solely of a CR."

	| result eol |
	eol := String lineDelimiter.
	result := self upTo: eol last.
	^(result notEmpty and: [result last = eol first]) ifTrue: [result allButLast] ifFalse: [result]!

nextWord
	"Answer the next 'word' in the receiver's element stream, where a word is defined as a
	sequence of one or more elements delimited by an elements which answer true to #isSeparator,
	or nil if there are no more words in the receiver. Leading separators are skipped. The
	stream is left positioned after the first trailing separator."

	| wordStream element |
	self skipSeparators ifFalse: [^nil].
	wordStream := self contentsSpecies writeStream: 32.
	[self atEnd] whileFalse: 
			[element := self next.
			element isSeparator ifTrue: [^wordStream contents].
			wordStream nextPut: element].
	^wordStream contents!

notEmpty
	"Answer whether there are any sequence values in the receiver."

	^self isEmpty not!

peek
	"Answer the next element in the collection, but do not change the current position. Answer
	nil if the receiver is at its end."

	^self atEnd 
		ifFalse: 
			[| anObject |
			anObject := self next.
			"We don't use #skip:, since we know going back 1 is in bounds"
			self position: self position - 1.
			anObject]!

peekFor: anObject 
	"Determine the response to the message peek. If it is the same as the argument, anObject,
	then advance the current position and answer true. Otherwise answer false and do not change
	the current position."

	^self atEnd not and: 
			[self next = anObject 
				ifTrue: [true]
				ifFalse: 
					["We don't use #skip:, since we know going back 1 is in bounds"
					self position: self position - 1.
					false]]!

pop
	"Move back one position in the stream."

	self skip: -1!

position
	"Answer the current <integer> position in the stream of  values."

	^self subclassResponsibility!

position: anInteger 
	"Set the current position in the stream of values to the <integer> argument."

	^self subclassResponsibility!

reset
	"Reset the position of the receiver to be at the beginning of the stream of values, i.e. the
	stream will answer the first sequence value (if any) in response to the #next message."

	self position: 0!

setToEnd
	"Set the position of the receiver to be past the last value (i.e. the stream will have no
	future sequence values), and will answer true in response to the #atEnd message."

	^self subclassResponsibility!

skip: anInteger 
	"Set the receiver's position to be the current position plus the argument, anInteger,
	possibly adjusting the result so as to remain within the bounds of the collection."

	self position: self position + anInteger.
	#todo	"This may need to be modified to be compatible with ANSI definition"!

skipSeparators
	"Advance the receiver's position over any leading whitespace. Answer whether their are more
	elements remaining in the receiver after the separators."

	"Implementation Note: Implementable in terms of #skipWhile:, but this is called so
	frequently that we open code to avoid instantiating a block."

	[self atEnd] whileFalse: 
			[self next isSeparator 
				ifFalse: 
					[self position: self position - 1.
					^true]].
	^false!

skipToAll: aCollection 
	"Set the receivers current position to be past the next occurrence of the sequence of
	objects which are the elements of the <collection> argument. Answer whether such any such
	sequence was found."

	| sequence partialStart |
	sequence := aCollection readStream.
	[sequence atEnd] whileFalse: 
			[self atEnd ifTrue: [^false].
			self next = sequence next 
				ifTrue: [partialStart isNil ifTrue: [partialStart := self position]]
				ifFalse: 
					[sequence reset.
					partialStart isNil 
						ifFalse: 
							[self position: partialStart.
							partialStart := nil]]].
	^true!

skipWhile: aMonadicValuable 
	"Advance the receiver's current position to be past the sequence of future values for which
	the <monadicValuable> argument evaluates to true. Answer true if there are more elements on
	the stream of false otherwise."

	[self atEnd] whileFalse: 
			[(aMonadicValuable value: self next) 
				ifFalse: 
					[self pop.
					^true]].
	^false!

skipWhileMatchAll: aCollection 
	"Advance the receiver's current position to be past the sequence of future values which
	match those in the <Collection> argument. Answer true if the match succeeds completely and
	the stream is left positioned after the final match. If the match fails at any point then
	false is answered and the stream is re-positioned to its initial position. The collection's
	elements are matched against the receiver's future sequence values in the same order as they
	would be enumerated by the collection's implementation of the #do: message."

	^aCollection skipOver: self!

upToAll: aCollection 
	"Answer a collection of the receiver's future sequence values starting with the next value
	accessed by the receiver, and up to, not inclusive of, the sequence of values that match the
	elements of the <collection> argument, or the remaining contents of the stream up to its end
	if the sequence is not found. The stream is left positioned after the last matching element,
	or at the end if the sequence is not found."

	| start |
	start := self position.
	^(self skipToAll: aCollection) 
		ifTrue: 
			[| end answer |
			end := self position.
			self position: start.
			answer := self next: end - start - aCollection size.
			self position: end.
			answer]
		ifFalse: 
			[self position: start.
			self upToEnd]! !

RandomCRT comment:
''!
!RandomCRT methodsFor!

next
	"Answer a pseudo-Random floating point number between 0 and 1.
	Uses the C run-time library rand() function.
	N.B. It is not recommended you use this generator, it is very poor. The range
	of numbers generated is only 15 bits. The only plus  point is speed."

	^next isNil 
		ifTrue: 
			[seed := CRTLibrary default rand.
			seed / ##(RAND_MAX + 1 asFloat)]
		ifFalse: 
			[| answer |
			answer := next.
			next := nil.
			answer]!

peek
	"Answer a pseudo-Random floating point number between 0 and 1 generated
	from the next seed, but do not advance down the stream (i.e. self peek = self peek)."

	"Implementation Note: We use the next inst. var to as a buffer for the next value."

	^next ifNil: [next := CRTLibrary default rand / ##(RAND_MAX + 1 asFloat)]!

seed: anInteger 
	"Set the seed of the Random stream to anInteger (or 1 if zero)."

	CRTLibrary default srand: anInteger.
	super seed: anInteger! !

RandomLinearCongruential comment:
'<RandomLinearCongruential> is a specialized <Random> stream that provides generic implementation of the Linear Congruential class of pseudo-random number generators. 

LCG generators are of the form:
	X[k] = ((a * X[k-1]) + c) mod m
The values of a, c, and m are the multiplier, increment and modulus constants respectively. These values are configurable in instances of RandomLinearCongruential, but they must be chosen very carefully to give good results. The instance creation method #newParkMiller answers an instance configured as Park & Miller''s "minimum standard" generator, which is a reasonable choice as a default random number generator, but it is inadequate for crypographic applications. Other suitable values for a, c, and m can easily be found on the net, including those with much larger periods.'!
!RandomLinearCongruential class methodsFor!

newANSIC
	"Answer a new <RandomLinearCongruential> configured as the ANSI C rand() generator."

	^self 
		newModulus: 16r80000000
		multiplier: 1103515245
		increment: 12345!

newModulus: mInteger multiplier: aInteger increment: cInteger 
	"Answer a new <RandomLinearCongruential> generator, configured with the specified a, c, and m
	constants."

	^(self basicNew)
		setModulus: mInteger
			multiplier: aInteger
			increment: cInteger;
		yourself!

newParkMiller
	"Answer a new <RandomLinearCongruential> configured as Park and Miller's 'Minimum Standard' 
	congruential generator (see 'Numerical Recipes in C', 2nd Edition; Press, Flannery, Teukolsky and 
	Vetterling; Cambridge University Press, 1992). "

	^self 
		newModulus: 16r7FFFFFFF
		multiplier: ##(7 raisedToInteger: 5)
		increment: 0!

newParkMiller2
	"Answer a new <RandomLinearCongruential> configured as Park and Miller's 'Minimum Standard' 
	congruential generator, but with an alternate multiplier."

	^self 
		newModulus: 16r7FFFFFFF
		multiplier: 48271
		increment: 0! !

!RandomLinearCongruential methodsFor!

lcg
	^seed * multiplier + increment rem: modulus!

next
	"Answer the next <Float> between 0 and 1 in the pseudo-random number stream."

	seed := self lcg.
	^seed / modulus asFloat!

peek
	"Answer the next <Float> between 0 and 1 in the pseudo-random number stream,
	but do not advance over it."

	^self lcg / modulus asFloat!

setModulus: modInteger multiplier: mulInteger increment: incInteger 
	modulus := modInteger.
	multiplier := mulInteger.
	increment := incInteger.
	seed := 1! !

RandomParkMiller comment:
'<RandomParkMiller> is a specialized <RandomLinearCongruential> stream that provides an optimised implementation of Park and Miller''s ''Minimum Standard''  linear congruential pseudo-random number generator (see ''Numerical Recipes in C'', 2nd Edition; Press, Flannery, Teukolsky and Vetterling; Cambridge University Press, 1992).

RandomParkMiller differs from a generic RandomLinearCongruential generator initialised with the same constants in that it is implemented using floating point arithmetic. This makes it about twice as fast as the RandomLinearCongruential equivalent, because the latter uses large-integer arithmetic when initialised with the Park-Miller constants.'!
!RandomParkMiller class methodsFor!

new
	^super 
		newModulus: 16r7FFFFFFF
		multiplier: ##(7 raisedToInteger: 5)
		increment: 0!

newModulus: mInteger multiplier: aInteger increment: cInteger 
	"This generator only supports a fixed set of constants."

	^self shouldNotImplement! !

!RandomParkMiller methodsFor!

lcg
	| remainder quotient answer |
	quotient := (seed quo: quo) asFloat.
	remainder := seed - (quotient * quo).
	answer := multiplier * remainder - (rem * quotient).
	^answer > 0.0 ifTrue: [answer] ifFalse: [answer + modulus]!

seed: anInteger
	"Set the seed of the Random stream to anInteger (or 1 if zero)."

	seed := anInteger asFloat max: 1.0!

setModulus: modInteger multiplier: mulInteger increment: incInteger 
	self assert: [incInteger = 0].
	modulus := modInteger asFloat.
	multiplier := mulInteger asFloat.
	increment := 0.
	seed := 1.0.
	quo := (modulus quo: multiplier) asFloat.
	rem := (modulus \\ multiplier) asFloat! !

PositionableStream comment:
'PositionableStream is the abstract class of <SequencedStream>s for which stream over sequence values from a Smalltalk sequenceable collection. Sub-instances of PositionableStream conform to the ANSI <collectionStream> protocol.

Instance Variables
	position		<Integer> 0 based offset of the current position in the stream
	readLimit	<Integer> Either the maximum read position in the stream, or the position up to which the stream has previously been read (depends on subclass).'!
!PositionableStream class methodsFor!

on: aCollection
	"Answer an instance of a kind of the receiver that streams over the 
	argument aCollection. If the new stream is writeable, the initial position
	is at the beginning of the collection (i.e. overwrite). See also 
	WriteStream>>#with:"
	
	^self basicNew
		collection: aCollection;
		initialize
!

on: aCollection from: firstIndex to: lastIndex
	"Answer an instance of a kind of the receiver that streams over a
	copy of a subcollection of the argument, aCollectionm from firstIndex to
	lastIndex. If the new stream is writeable, the initial position
	is at the beginning of the collection (i.e. overwrite). See also 
	WriteStream>>#with:from:to:"

	^self on: (aCollection copyFrom: firstIndex to: lastIndex)
! !

!PositionableStream methodsFor!

atEnd
	"Answer whether the receiver cannot access any more objects."

	"The stream primitives work only for Arrays and Strings, and will fail and fall back on the
	Smalltalk code for other types of collection.

	Primitive failure reasons: 
		0 - The receivers position or readLimit are not SmallInteger values 
		1 - The receiver's collection is not an Array, String or ByteArray."

	<primitive: 67>
	^position >= readLimit!

collection
	"Private - Answer the collection over which the receiver is streaming."

	^collection
!

collection: aCollection
	"Set the <collection> over which the receiver will stream."

	collection := aCollection.

!

contents
	"Answer a <sequencedReadableCollection> that contains the complete contents of the stream."

	^collection copyFrom: 1 to: self size!

contentsSpecies
	"Private - Answer the class of Object to be used when answering collections of elements from
	the receiver."

	^collection species
!

initialize
	position := 0.
	readLimit := collection size
!

lastPosition
	"Private - Answer the last position in the receiver (for the purposes of determining
	attempts to read off the end, etc)."

	^readLimit!

nextAvailable
	"Answer the next object accessible by the receiver, or nil if at the end of the stream.
	Note that if the stream can contain nils, then you will not be able to distinguish a nil element from the 
	end of stream, so this method is only useful for text and byte streams, or where the collection
	being streamed over is known not to contain nils."

	^self atEnd ifFalse: [self next]!

nextAvailable: anInteger 
	"Answer up to anInteger elements of the receiver's collection. The answer will be a
	collection of the same species as the one accessed by the receiver, and will contain anInteger
	elements, or as many as are left in the receiver's collection."

	"Implementation Note: Override superclass for improved performance."

	self position + anInteger > self lastPosition ifTrue: [^self upToEnd].
	^self next: anInteger!

nextDOUBLE
	"Answer a <Float> constructed from the next 8 bytes on the receiver, which are assumed to
	represent an IEEE double precision floating point number."

	"N.B. This will fail if the receiver is not a byte stream."

	^(self next: 8) doubleAtOffset: 0!

nextDWORD
	"Answer a 32-bit unsigned integer constructed from the host system representation contained
	in the next 4 bytes on the receiver."

	"N.B. This will fail if the receiver is not a byte stream."

	^(self next: 4) dwordAtOffset: 0!

nextFLOAT
	"Answer a <Float> constructed from the next 4 bytes on the receiver, which are assumed to
	represent an IEEE single precision floating point number."

	"N.B. This will fail if the receiver is not a byte stream."

	^(self next: VMConstants.FloatSize) floatAtOffset: 0!

nextInto: aSequenceableCollection
	"Destructively replace all elements of the argument, aSequenceableCollection,
	with the next elements of the receiver. Answer aSequenceableCollection."

	^self next: aSequenceableCollection size into: aSequenceableCollection startingAt: 1!

nextSDWORD
	"Answer a 32-bit signed integer constructed from the host system representation contained in
	the next 4 bytes on the receiver."

	"N.B. This will fail if not streaming over a byte collection.

	Primitive failure reasons:
		0 -	The receivers position or readLimit are not SmallInteger values
		1 -	The receiver's collection is not a ByteArray.
		2 -	The receiver is at its end (position >= readLimit).
		3 -	The next 32-bit Integer would run off the end of the streamed over collection.
		4 - 	The receiver's new position would overflow the SmallInteger range."

	<primitive: 144>
	^(self next: 4) sdwordAtOffset: 0!

nextSWORD
	"Answer a 16-bit signed integer constructed from the host system representation contained in
	the next 2 bytes on the receiver."

	"N.B. This will fail if the receiver is not a byte stream."

	^(self next: 2) swordAtOffset: 0!

nextWORD
	"Answer a 16-bit unsigned integer constructed from the host system representation contained
	in the next 2 bytes on the receiver."

	"N.B. This will fail if the receiver is not a byte stream."

	^(self next: 2) wordAtOffset: 0!

position
	"Answer the current <integer> position in the stream of  values."

	^position!

position: anInteger 
	"Set the current position in the stream of values to the <integer> argument. If the argument
	is not within the bounds of the receiver's collection, report an error."

	(anInteger >= 0 and: [anInteger <= readLimit]) 
		ifTrue: [position := anInteger]
		ifFalse: [^self errorSubscriptBounds: anInteger]!

positionAfterNext: anInteger 
	"Private - Answer the new position which the receiver would be in if a further anInteger are
	read from the receiver."

	| stop |
	stop := position + anInteger.
	stop > self lastPosition ifTrue: [^self errorEndOfStream].
	^stop!

reverseContents
	"Answer a copy of the receiver's contents in reverse order."

	| newCollection size |
	size := self size.
	newCollection := self contentsSpecies new: size.
	1 to: size do: [:i | newCollection at: i put: (collection at: size - i + 1)].
	^newCollection!

setToEnd
	"Set the position of the receiver to be past the last value in the stream."

	position := readLimit!

size
	"Answer the number of values in the stream."

	"Implementation Note: Take the opportunity to update the read limit."

	readLimit < position ifTrue: [readLimit := position].
	^self lastPosition!

upToEnd
	"Answer a collection consisting of the future sequence values of the receiver (i.e. from 
	the current position to the end)."

	"Implementation Note: We implement this in terms of #next:, which is optimized for
	 particular streams."

	^self next: self lastPosition - self position! !

StdioFileStream comment:
'StdioFileStream is a <FileStream> implemented over C runtime library stdio streams. Its main purpose is to wrap the stdin, stdout, and stderr streams in console applications, and it is not intended for general use. FileStream itself should be used by preference in most cases.

Instance Variables:
	stream	<ExternalHandle>. FILE* stream handle.
	isText	<Boolean>. Whether or not this is a text stream.
	name	<String>. Path of file. Can be nil, e.g. if connected to standard I/O handle

'!
!StdioFileStream class methodsFor!

fromHandle: anExternalHandle
	"Answer a new instance of the receiver on the specified stdio FILE pointer,
	assumed to be in text mode."

	^self basicNew 
		setStream: anExternalHandle
		isText: true
		name: nil!

read: aString 
	"Answer a new text mode instance of the receiver whose future sequence values consist
	of the textual contents of the file identified by the <readableString> argument."

	^self read: aString text: true!

read: aString text: aBoolean
	"Answer an instance of the receiver whose future sequence values consist
	of the contents of the file named, aString, and whose access is character
	based or binary, depending on the <boolean> argument. Raise an exception
	if the file does not exist."

	^self basicNew 
		setStream: (CRTLibrary default fopen: aString
				mode: (aBoolean ifTrue: ['rt'] ifFalse: ['rb']))
		isText: aBoolean
		name: aString!

read: aString type: aSymbol 
	"Answer an instance of the receiver whose future sequence values consist
	of the contents of the file identified by the <readableString> argument, and 
	whose external stream type and sequence value type is determined by the
	<symbol> argument (i.e. either #binary or #text)."

	^self read: aString text: aSymbol == #text!

write: aString 
	"Answer a new text mode instance of the receiver opened on a new or truncated file 
	identified by the <readableString> argument."

	^self write: aString mode: #truncate!

write: aString mode: aSymbol 
	"Answer a new instance of the receiver open on the textual contents of
	the file identified by the <readableString> argument.
	See #write:mode:check:type: for a description of the mode <symbol> 
	argument."

	^self 
		write: aString
		mode: aSymbol
		check: false
		text: true!

write: aString mode: aSymbol check: checkBoolean text: textBoolean 
	"Answer a new instance of the receiver open on the contents of
	the file identified by the <readableString> argument.
	The <symbol> argument identifies the manner in which the file is opened.
	It may be one of:
		#create 	create a new file, position at its start.
		#append	open an existing file, position at its end.
		#truncate	create or open a file, position at its start.
	See also the File class for further information on the mode.
	The first <boolean> argument determines whether or not  errors are reported 
	if the file does or does not exist (depending on the mode). 
	The final <boolean> argument specifies the external type (#binary or #text) 
	for which the new instance is initially configured."

	| answer |
	checkBoolean 
		ifTrue: 
			[| exists |
			exists := File exists: aString.
			aSymbol == #create 
				ifTrue: [exists ifTrue: [self error: 'File already exists']]
				ifFalse: [exists ifFalse: [self error: 'File does not exist']]].
	"Note that Smalltalk #append mode is unlike the 'a' and 'a+' fopen() modes, because
	in Smalltalk the mode only controls the initial file position, and it is possible to overwrite
	the existing data by moving the stream pointer backwards. With the fopen() append
	modes it is not possible to overwrite the existing data."
	answer := (self basicNew)
				setStream: (CRTLibrary default fopen: aString
							mode: (aSymbol == #append ifTrue: ['r+'] ifFalse: ['w+']) 
									, (textBoolean ifTrue: ['t'] ifFalse: ['b']))
					isText: textBoolean
					name: aString;
				yourself.
	aSymbol == #append ifTrue: [answer setToEnd].
	^answer!

write: fileId mode: mode check: aBoolean type: typeSymbol 
	"Answer a new instance of the receiver open on the contents of
	the file identified by the <readableString> argument.
	The first <symbol> argument identifies the manner in which the file
	is opened. It may be one of:
		#create 	create a new file, position at its start.
		#append	open an existing file, position at its end.
		#truncate	create or open a file, position at its start.
	See also the File class for further information on the mode.
	The <boolean> argument determines whether or not errors are reported 
	if the file does or does not exist (depending on the mode). The final <symbol>
	argument specifies the external type (#binary or #text) for which the new instance 
	is initially configured."

	^self 
		write: fileId
		mode: mode
		check: aBoolean
		text: typeSymbol == #text!

write: aString text: aBoolean 
	"Create a new file/truncate an existing file for read/write access through the receiver.
	The stream will expect characters or bytes depending on the value of the <boolean>
	argument."

	^self 
		write: aString
		mode: #truncate
		check: false
		text: aBoolean! !

!StdioFileStream methodsFor!

asParameter
	"Answer the receiver in a form suitable for passing to an external function
	primitive method (see ExternalLibrary and subclasses). The default is self."

	^stream!

atEnd
	"Answer whether the receiver cannot access any more objects"

	^(CRTLibrary default feof: stream) ~~ 0 or: [self peek isNil]!

basicPrint: anObject 
	anObject basicPrintOn: self!

close
	"Relinquish any external resources associated with the receiver, and put the
	receiver into a 'closed' state. Answer the receiver."

	stream isNull ifTrue: [^self].
	self beUnfinalizable.
	CRTLibrary default fclose: stream.
	stream := nil!

contents
	"Answer a <String> or <ByteArray> containing the complete contents of the file
	accessed by the receiver."

	| len |
	self reset.
	len := CRTLibrary default _filelength: self fileno.
	^len == -1 ifTrue: [self upToEnd] ifFalse: [self next: len]!

contentsSpecies
	^isText ifTrue: [String] ifFalse: [ByteArray]!

cr
	"Store the line delimiter character sequence (as required by
	the environment) as the next element(s) of the receiver."

	"Implementation Note: Assumes the receiver is in text mode, and 
	will translate the single LF character to a CR/LF pair on output."

	self nextPut: Character lf!

crtab
	"Append a line-delimiter and a tab to the receiver."

	self cr; tab!

crtab: anInteger 
	"Append a line-delimiter and the specified number of tabs to the receiver."

	self
		cr;
		tab: anInteger!

display: anObject
	"Ask anObject to append its end-user textual description to the receiver."

	anObject displayOn: self!

elementFor: anInteger 
	^isText ifTrue: [Character value: anInteger] ifFalse: [anInteger]!

externalType
	"Answer a <symbol> which names the external stream type of the receiver."

	^self isText ifFalse: [#binary] ifTrue: [#text]!

fileno
	^CRTLibrary default _fileno: stream!

finalize
	self close!

flush
	"Flush any buffered modifications to the file."

	CRTLibrary default fflush: stream!

isBinary
	"Answer whether the receiver's data is binary (i.e. consisting of Integers in the range 0..255)."

	^self isText not!

isReadable
	"Answer whether the receiver can be read from (i.e. it implements the 
	<gettableStream> protocol)."

	^true!

isText
	"Answer whether if the receiver's data is characters.
	X3J20 (draft) includes rational as to why this message is not called #isCharacter."

	^isText!

isWriteable
	"Answer whether the receiver can be written to (i.e. it implements the 
	<puttableStream> protocol)."

	^true!

name
	^name ifNil: ['%<<1d>%>' expandMacrosWith: self fileno]!

next
	"Answer a <Character> or <integer> in the range 0..255, being the next of the 
	receiver's future sequence values."

	| ch |
	ch := CRTLibrary default fgetc: stream.
	^ch == -1 ifTrue: [self errorEndOfStream] ifFalse: [self elementFor: ch]!

next: countInteger into: aSequenceableCollection startingAt: startInteger 
	"Destructively replace the elements of the argument, aSequenceableCollection,
	(which must be some sort of byte object or <ExternalStructure> type object
	which holds bytes) in the interval (startAt..startAt+count-1) with the next, count, 
	elements of the receiver. Answer aSequenceableCollection."

	| read |
	read := CRTLibrary default 
				fread: aSequenceableCollection yourAddress + startInteger - 1
				size: aSequenceableCollection class elementSize
				count: countInteger
				stream: stream.
	read = countInteger ifFalse: [^self errorEndOfStream].
	^aSequenceableCollection!

next: anInteger put: anObject
	"Store the argument, anObject, as the next anInteger number of elements accessible by the receiver. 
	Answer anObject."

	anInteger timesRepeat: [self nextPut: anObject].
	^anObject!

next: countInteger putAll: aSequenceableCollection startingAt: startInteger 
	"Append countInteger elements of aSequenceableCollection from startInteger
	to the receiver. Answer aSequenceableCollection."

	CRTLibrary default 
		fwrite: aSequenceableCollection yourAddress + startInteger - 1
		size: aSequenceableCollection class elementSize
		count: countInteger
		stream: stream.
	^aSequenceableCollection!

nextAvailable: anInteger 
	"Answer up to anInteger elements of the receiver's collection. The answer will be a
	collection of the same species as the one accessed by the receiver, and will contain anInteger
	elements, or as many as are left in the receiver's collection."

	"Implementation Note: Override superclass for improved performance. The superclass method is
	particularly slow for StdioFileStream because the atEnd test has to peek the stream because
	feof() returns false until one has read off the end of the stream (or read the Ctrl+Z
	character)."

	| read buf |
	buf := self contentsSpecies new: anInteger.
	read := CRTLibrary default 
				fread: buf yourAddress
				size: 1
				count: anInteger
				stream: stream.
	^read < anInteger ifTrue: [buf copyFrom: 1 to: read] ifFalse: [buf].!

nextLine
	"Answer a Collection consisting of the receiver contents up to (but not including) the 
	next line delimiter. If there are no further line delimiters in the receiver, then the 
	rest of the receiver's contents are answered. If the receiver is at its end, then an empty 
	collection is answered."

	| buf answer len last |
	isText ifFalse: [self error: 'Invalid operation for binary streams'].
	buf := String new: 128.
	answer := ''.
	
	[| part |
	part := CRTLibrary default 
				fgets: buf
				n: buf byteSize
				stream: stream.
	part isNil 
		ifTrue: 
			["Hit eof"

			^answer , buf trimNulls].
	answer := answer , part.
	part size = 128] 
			whileTrue.
	len := answer size.
	"Strip off the line terminator, allowing for binary or text mode"
	last := answer at: len.
	^last == Character lf 
		ifTrue: 
			[(len > 1 and: [(answer at: len - 1) == Character cr]) 
				ifTrue: [answer copyFrom: 1 to: len - 2]
				ifFalse: [answer copyFrom: 1 to: len - 1]]
		ifFalse: [last == Character cr ifTrue: [answer copyFrom: 1 to: len - 1] ifFalse: [answer]]!

nextPut: anObject 
	"Store the <Character> or <integer> (in the range 0..255) as the next element of the receiver."

	CRTLibrary default fputc: anObject asInteger stream: stream.
	^anObject!

nextPutAll: aCollection 
	"Store the elements in the argument, aCollection, as the next elements accessible by the receiver. 
	Answer aCollection"

	^aCollection appendToStream: self!

peek
	"Answer the next element in the collection, but do not change the position reference. 
	Answer nil if the receiver is at its end."

	| ch |
	ch := CRTLibrary default fgetc: stream.
	^ch == -1 
		ifFalse: 
			[CRTLibrary default ungetc: ch stream: stream.
			self elementFor: ch]!

peekFor: anObject 
	"Determine the response to the message peek. If it is the same as the
	argument, anObject, then increment the position reference and answer true.
	Otherwise answer false and do not change the position reference"

	| ch |
	ch := CRTLibrary default fgetc: stream.
	^ch ~~ -1 and: 
			[CRTLibrary default ungetc: ch stream: stream.
			(self elementFor: ch) = anObject]!

position
	"Answer the absolute (zero-based) position of the file pointer."

	^CRTLibrary default ftell: stream!

position: anInteger 
	"Set the receiver's current position reference for accessing the collection
	to the the argument, anInteger. If the argument is not within the bounds of
	the receiver's collection, report an error."

	CRTLibrary default 
		fseek: stream
		offset: anInteger
		origin: SEEK_SET!

print: anObject
	"Ask anObject to append its textual description to the receiver"

	anObject printOn: self!

reset
	"Set the receiver's position reference to the beginning of the collection"

	CRTLibrary default rewind: stream!

setStream: anExternalAddress isText: aBoolean name: aString 
	stream := anExternalAddress asExternalHandle.
	isText := aBoolean.
	name := aString.
	self beFinalizable!

setToEnd
	"Set the file pointer to the end of the file."

	CRTLibrary default 
		fseek: stream
		offset: 0
		origin: SEEK_END!

size
	"Answer the size of the file in bytes. Enquiring the size of streams connected
	to, for example, stdin is an error."

	| len |
	self flush.
	^(len := CRTLibrary default _filelength: self fileno) == -1 
		ifTrue: [CRTError signal]
		ifFalse: [len]!

skip: anInteger 
	"Adjust the receiver's position by the <integer> argument."

	CRTLibrary default 
		fseek: stream
		offset: anInteger
		origin: SEEK_CUR!

space
	"Store a space character as the next element of the receiver."

	self nextPut: Character space!

tab
	"Store a tab character as the next element of the receiver."

	self nextPut: Character tab!

tab: anInteger 
	"Append the specified number of tabs to the receiver."

	anInteger timesRepeat: [self tab]! !

ReadStream comment:
'Class ReadStream is a concrete subclass of PositionableStream that represents
an accessor that can only read elements from a collection.'!
!ReadStream methodsFor!

isReadable
	"Answer whether the receiver can be read from (i.e. it implements the 
	gettableStream protocol)."

	^true!

next
	"Answer the next object accessible by the receiver. The primitive implementation works for Strings
	and Arrays only, and will otherwise fail if the receiver is at its end, or the index is outside
	the bounds of the collection.

	Primitive failure reasons:
		0 -	The receivers index or readLimit are not SmallInteger values
		1 -	The receiver's collection is not an Array, String or ByteArray.
		2 -	The receiver is at its end (index >= readLimit).
		3 -	The next index is beyond the end of the streamed over collection."

	<primitive: 65>
	^position >= readLimit
		ifTrue: [self errorEndOfStream]
		ifFalse: [collection at: (position := position + 1)]!

next: count into: aSequenceableCollection startingAt: startAt
	"Destructively replace the elements of the argument, aSequenceableCollection,
	in the interval (startAt..startAt+count-1) with the next, count, elements of
	the receiver. Answer aSequenceableCollection."

	| stop |
	stop := self positionAfterNext: count.
	aSequenceableCollection
		replaceFrom: startAt
		to: startAt+count-1
		with: collection
		startingAt: position+1.
	self position: stop.
	^aSequenceableCollection!

nextAvailable
	"Answer the next object accessible by the receiver, or nil if at the end of the stream.
	Note that if the stream can contain nils, then you will not be able to distinguish a nil element from the 
	end of stream, so this method is only useful for text and byte streams, or where the collection
	being streamed over is known not to contain nils."

	<primitive: 65>
	^super nextAvailable! !

WriteStream comment:
'Class WriteStream is a concrete subclass of PositionableStream representing accessors for writing elements into a collecition. None of the next, next:, nor do: messages can be successfully sent to a WriteStream.

Instance Variables:
	writeLimit		<Integer>. Current maximum position up to which the stream may be positioned for writing.'!
!WriteStream class methodsFor!

with: aCollection
	"Answer a new instance of the receiver accessing the <collection>, aCollection,
	but positioned to store the next element at the end of it, i.e. an APPEND stream."

	^(self on: aCollection)
		moveToEnd;
		yourself

!

with: aCollection from: firstIndex to: lastIndex
	"Answer an instance of WriteStream accessing the subcollection of argument, 
	aCollection, from location firstIndex to lastIndex, but positioned to store
	the next element at the end of the subcollection, i.e. an APPEND stream."

	^(self on: aCollection from: firstIndex to: lastIndex)
		moveToEnd;
		yourself! !

!WriteStream methodsFor!

basicPrint: printee
	"Private - Ask the <Object>, printee, to append its basic textual description
	to the receiver."

	printee basicPrintOn: self!

binaryStore: anObject
	"Ask anObject to append to the receiver binary byte which when
	read will result in an Object equivalent to anObject"

	anObject binaryStoreOn: self
!

contents
	"Answer the contents of the streamed over collection up to
	the current position. At the same time adjust the readLimit
	to include that position if it doesn't already. I.E. By accessing
	the contents we have 'read' all the elements in the receiver.
	The readLimit is mostly of use to readable subclasses."

	readLimit := readLimit max: position.
	^collection copyFrom: 1 to: position!

cr
	"Store the line delimiter character sequence (as required by
	the environment) as the next element(s) of the receiver."

	self nextPutAll: String lineDelimiter!

crtab
	"Append a line-delimiter and a tab to the receiver."

	self cr; tab!

crtab: tabCount
	"Append a line-delimiter and the specified number of tabs to the receiver."

	self cr; tab: tabCount!

display: anObject
	"Ask anObject to append its end-user textual description to the receiver."

	anObject displayOn: self!

growCollection
	"Private - Increase the size of the streamed over collection
	to accomodate more elements."

	collection grow.
	writeLimit := collection size!

initialize
	"Private - Intitialise the receiver."

	position := readLimit := 0.
	writeLimit := collection size!

isWriteable
	"Answer whether the receiver can be written to (i.e. it implements the 
	puttableStream protocol)."

	^true!

moveToEnd
	"Private - Position the receiver to the end of its underlying
	collection."

	readLimit := collection size.
	self setToEnd!

next
	"Answer the next object accessible by the receiver. WriteStreams do not support reading.
	This effectively stubs out all the read methods inherited from superclasses."

	^self shouldNotImplement!

next: anInteger put: anObject
	"Store the argument, anObject, as the next anInteger number of elements accessible by the receiver. 
	Answer anObject."

	anInteger timesRepeat: [self nextPut: anObject].
	^anObject!

next: sizeInteger putAll: aSequenceableCollection startingAt: startInteger 
	"Append countInteger elements of aSequenceableCollection from startInteger
	to the receiver. Answer aSequenceableCollection."

	| stop |
	stop := position + sizeInteger.
	stop <= writeLimit 
		ifTrue: 
			["The block fits into the current collection and can be
			written directly"

			collection 
				replaceFrom: position + 1
				to: stop
				with: aSequenceableCollection
				startingAt: startInteger.
			position := stop]
		ifFalse: 
			["The block will not fit within the current collection, so
			fall back on the slow way"

			startInteger to: startInteger + sizeInteger - 1
				do: [:i | self nextPut: (aSequenceableCollection at: i)]].
	^aSequenceableCollection!

nextDWORDPut: anInteger 
	"Append a 32-bit unsigned integer representation as the next 4 bytes on the receiver."

	self nextPutAll: ((ByteArray new: 4)
				dwordAtOffset: 0 put: anInteger;
				yourself).
	^anInteger!

nextPut: anObject
	"Store anObject as the next element of the receiver.  If the receiver is not stream 
	over an Array or a String, or if the Array or String becomes full, then the primitive 
	will fail, and the backup Smalltalk code will be activated."

	<primitive: 66>
	position < writeLimit ifFalse: [self growCollection].
	^collection at: (position := position + 1) put: anObject!

nextPutAll: aCollection
	"Store the elements in the argument, aCollection, as the next elements accessible by the receiver. 
	Answer aCollection"

	<primitive: 173>
	^aCollection appendToStream: self!

nextSDWORDPut: anInteger
	"Append a 32-bit signed integer in 2's complement representation 
	as the next 4 bytes on the receiver."

	self nextPutAll: 
		((ByteArray new: 4)
			sdwordAtOffset: 0 put: anInteger;
			yourself).
	^anInteger!

padTo: anInteger put: anObject
	"Align the receiver's position to the next multiple of anInteger, padding with the 
	argument, anObject.  Answer the number of elements written."

	| delta |
	delta := anInteger - (self position \\ anInteger).
	^delta = anInteger ifTrue: [0] ifFalse: [self next: delta put: anObject]!

position: anInteger
	"Set the receiver's current position reference for accessing the collection
	to the the argument, anInteger. If the argument is not within the bounds of
	the receiver's collection, report an error.
	Override to update the readLimit."

	readLimit := readLimit max: position.
	super position: anInteger!

print: anObject
	"Ask anObject to append its textual description to the receiver"

	anObject printOn: self!

setToEnd
	"Set the receivers position reference to the end of the collection,
	updating the readLimit if necessary."

	position := self size!

space
	"Store a space character as the next element of the receiver"

	self nextPut: Character space!

tab
	"Store a tab character as the next element of the receiver"

	self nextPut: Character tab!

tab: tabCount
	"Append the specified number of tabs to the receiver."

	tabCount timesRepeat: [self tab]! !

ReadWriteStream comment:
'Class ReadWriteStream is a subclass of WriteStream that represents an accessor that can both read and write elements into its collection. It supports all the protocol of both ReadStream and WriteStream.
'!
!ReadWriteStream methodsFor!

contents
	"Answer a collection of the same type that the stream is accessing, 
	up to the current readLimit (adjusted to include the current position
	if it does not already). i.e.. This will answer the contents of
	the stream up to the high water mark. This also updates the read limit
	(high water mark) to include any elements written but not read."

	^collection copyFrom: 1 to: self size!

isReadable
	"Answer whether the receiver can be read from (i.e. it implements the 
	gettableStream protocol)."

	^true!

next
	"Answer the next object accessible by the receiver. The primitive implementation works for Strings
	and Arrays only, and will otherwise fail if the receiver is at its end, or the index is outside
	the bounds of the collection. Duplicate the ReadStream method as we're not a subclass.

	Primitive failure reasons:
		0 -	The receivers index or readLimit are not SmallInteger values
		1 -	The receiver's collection is not an Array, String or ByteArray.
		2 -	The receiver is at its end (index >= readLimit).
		3 -	The next index is beyond the end of the streamed over collection."

	<primitive: 65>
	^position >= readLimit
		ifTrue: [self errorEndOfStream]
		ifFalse: [collection at: (position := position + 1)]!

next: count into: aSequenceableCollection startingAt: startAt
	"Destructively replace the elements of the argument, aSequenceableCollection,
	in the interval (startAt..startAt+count-1) with the next, count, elements of
	the receiver. Answer aSequenceableCollection."

	| stop |
	stop := self positionAfterNext: count.
	aSequenceableCollection
		replaceFrom: startAt
		to: startAt+count-1
		with: collection
		startingAt: position+1.
	self position: stop.
	^aSequenceableCollection! !

FileStream comment:
'FileStream is a specialized <ReadWriteStream> for streaming over binary and text files.

The collection instance variable inherited from <Stream> is used to hold a fixed size buffer representing a cached ''page'' of the actual file. This is flushed back to the file either when a new page is loaded, or when explictly requested by #flush or #fullFlush. The readLimit and writeLimit instance variables inherited from <PositionableStream> and <WriteStream> respectively have a different usage in this class than in their defining classes; they are the limits for the current "page" rather than the whole stream. The readLimit will always be equal to the page size, except on the last page of the file. The writeLimit is always equal to the page size. This use of the superclass instance variables allows us to use the stream primitives for every efficient access within the current page, which means that even single character I/O is reasonably fast..

Instance Variables:
	file		The <File> being streamed over.
	flags		<integer> flags such as whether the page buffer is dirty.
	pageBase		<integer> offset of the page currently in the buffer. Always a multiple of the page size, plus 1.
	logicalFileSize	<integer> size of the file. This is cached because it is expensive to determine dynamically.
'!
!FileStream class methodsFor!

bufferSize
	"Answer the size of the buffer to be used."

	^8192!

initialize
	"Private - Initialize class variables of the receiver."

	DirtyBufferMask := 16r0002.
!

on: aFile
	"Answer an intance of the receiver attached to the open file aFile."

	^self on: aFile text: true!

on: aFile text: aBoolean
	"Answer an intance of the receiver attached to the open file aFile, in
	binary or text mode depending on the argument, aBoolean."

	aFile isReadable
		ifFalse: [self error: 'must be attached to a readable file'].
	^self basicNew
		collection: ((aBoolean ifTrue: [String] ifFalse: [ByteArray]) new: self bufferSize);
		initialize;
		file: aFile;
		initialRead;
		yourself!

open: aString mode: aSymbol
	"Private - Answer an instance of the receiver opened on aString 
	for aSymbol text access. Signal a FileException if the file can't be opened."

	^self open: aString mode: aSymbol text: true!

open: aString mode: aSymbol check: checkBoolean text: textBoolean
	"Private - Answer an instance of the receiver opened on
	aString for accessMode access as binary or text depending on aBoolean,
	reporting errors if the file can't be opened (though file exist/file
	does not exist error notifications depend on the value of checkBoolean).
	By default we share for read only."

	| answer |
	answer := self on: (File 
						open: aString
						mode: aSymbol
						check: checkBoolean
						share: #readWrite)
				text: textBoolean.
	aSymbol == #append ifTrue: [answer setToEnd].
	^answer.
	#todo	"Default sharing should be #read, but causes problems with boot"!

open: aString mode: aSymbol text: aBoolean
	"Private - Answer an instance of the receiver opened on
	aString for accessMode access as binary or text depending on aBoolean.
	Signal a FileException if the file can't be opened."
 
	^self open: aString mode: aSymbol check: false text: aBoolean!

read: fileId
	"Answer an instance of the receiver whose future sequence values consist
	of the textual contents of the file identified by the <readableString> path, fileId."

	^self read: fileId text: true!

read: aString text: aBoolean
	"Answer an instance of the receiver whose future sequence values consist
	of the contents of the file named, aString, and whose access is character
	based or binary, depending on the argument aBoolean. Raise an exception
	if the file does not exist."

	^self open: aString 
		mode: #read
		check: true
		text: aBoolean!

read: fileId type: fileType
	"Answer an instance of the receiver whose future sequence values consist
	of the contents of the file identified by the <readableString>, fileId, and 
	whose external stream type and sequence value type is determined by the
	<symbol> argument, fileType (i.e. either binary or text)."

	^self read: fileId text: (fileType == #text)!

readWrite: aString
	"Answer an instance of the receiver opened on aFileName."

	^self open: aString mode: #create!

write: fileId
	"Answer an instance of the receiver opened on a new or truncated file 
	identified by the <readableString> path, fileId."

	^self write: fileId mode: #truncate!

write: fileId mode: mode
	"Answer a new instance of the receiver open on the textual contents of
	the file identified by the <readableString> path, fileId.
	See #write:mode:check:type: for a description of the mode argument."

	^self 
		write: fileId
		mode: mode
		check: false
		text: true!

write: aString mode: aSymbol check: checkBoolean text: textBoolean
	"Open a file for write access (in fact our filestreams required read/write
	access for buffering, so the result is actually a read/write file stream).
	The mode symbol, modeSymbol, determines what file opening mode to use when 
	opening the file (see File for further details).
	The check flag, checkBoolean, determines whether or not errors are reported 
	if the file does or does not exist (depending on the mode). The text flag,
	textBoolean, determines whether or not the new instance is initially configured
	to read the file as if it contains Characters or bytes."

	^self open: aString 
		mode: aSymbol
		check: checkBoolean
		text: textBoolean!

write: fileId mode: mode check: check type: fileType
	"Answer a new instance of the receiver open on the contents of
	the file identified by the <readableString> path, fileId.
	The <symbol> argument, mode, identifies the manner in which the file
	is opened. It may be one of:
		#create 	create a new file, position at its start.
		#append	open an existing file, position at its end.
		#truncate	create or open a file, position at its starte.
	See also the File class for further information on the mode.
	The <boolean> argument, check, determines whether or not errors are reported 
	if the file does or does not exist (depending on the mode). The <symbol>, type,
	specifies the external type (binary or text) for which the new instance is initially
	configured.
	Implementation Note: Dolphin's FileStreams require read access for
	buffering, so result is actually a read/write file stream."


	^self open: fileId 
		mode: mode
		check: check
		text: (fileType == #text)!

write: aString text: aBoolean
	"Create a new file/truncate an existing file for write access (in fact our 
	filestreams require read/write access for buffering, so the result is actually 
	a read/write file stream) through the receiver. The stream will expect characters
	or bytes depending on the value of aBoolean."

	^self write: aString 
		mode: #truncate
		check: false
		text: aBoolean! !

!FileStream methodsFor!

atEnd
	"Answer true if the receiver is positioned at its logical end."

	^position >= readLimit and: [pageBase + position > self lastPosition]

!

beBinary
	"Set a flag indicating that the elements of the receiver should be
	treated as bytes (Integers)."

	collection := collection asByteArray!

beClean
	"Private - Set the buffer status to 'clean', ie. 'not written to'."

	flags := flags maskClear: DirtyBufferMask
!

beDirty
	"Private - Set the buffer status to 'dirty', ie. 'has been written to'."

	flags := flags bitOr: DirtyBufferMask!

beText
	"Set a flag indicating that the elements of the receiver should be
	treated as Characters. This is the default."

	collection := collection asString!

close
	"Write any outstanding changes to the file and close it."

	file notNil ifFalse: [^self].
	self
		flush;
		beUnfinalizable.
	file close.
	file := nil!

contents
	"Answer the contents of the file. For a read-only file answer
	the entire contents. For a writeable file answer the contents
	up to the current position. This will be a <ByteArray> if #isBinary
	is true or a <String> if #isText is true."

	| size contents |
	size := file isWriteable
		ifTrue: [self position]
		ifFalse: [self lastPosition].
	contents := self makeBufferOfSize: size.

	self flush.
	file
		reset;
		read: contents count: size.
	^contents!

externalType
	"Answer a <symbol> which represents the external stream type of the receiver."

	^self isBinary ifTrue: [#binary] ifFalse: [#text]!

file
	"Answer the <File> instance over which the receiver is streaming."

	^file!

file: aStreamableFile
	"Private - Set the file instance var to aFile."

	file := aStreamableFile!

finalize
	"Private - The receiver is about to be GC'd, flush any updates to the underlying medium."

	self flush.
	"Note that we can't actually close the File, because we don't know that we opened it."
	file := nil

!

flush
	"Flush any buffered modifications to the file."

	self isBufferDirty ifTrue: [self writePage]!

fullFlush
	"Flush any buffered modifications to the file and
	force the file to disk."

	self flush.
	file flush.!

growCollection
	"Private - The buffer of a FileStream is fixed at the page size."

	^self shouldNotImplement!

initialize
	"Private - Initialise the new instance."

	self beFinalizable.
	flags := 0.
	super initialize!

initialRead
	"Private - Initialise the new instance's buffer and establish the file size."

	self readPageFor: 0.
	logicalFileSize := file size.!

isBinary
	"Answer whether the receiver's data is binary (i.e. consisting of Integers in the range 0..255)."

	^self collection isMemberOf: ByteArray!

isBufferDirty
	"Private - Answer true if the receiver's buffer has been written to."

	^flags anyMask: DirtyBufferMask
!

isText
	"Answer whether if the receiver's data is characters.
	X3J20 (draft) includes rational as to why this message is not called #isCharacter."

	^self isBinary not!

lastPosition
	"Private - Answer last position in the file stream.
	Ensure that any post-open file growth is reflected."

	| absolute |
	logicalFileSize < (absolute := self position) ifTrue: [logicalFileSize := absolute].
	^logicalFileSize!

makeBufferOfSize: anInteger
	"Private - Answer a ByteArray or String of size anInteger depending on whether the receiver
	treats its contents as Characters or Bytes."

	^self contentsSpecies new: anInteger!

name
	"Private - Answer the name of the file to which the receiver is attached."
	
	^file name!

next
	"Answer the receiver's next element, a <Character> if #isText is
	true otherwise an <integer>. Signal an exception if we are atEnd."
	
	<primitive: 65>
	^self atEnd
		ifTrue: [self errorEndOfStream]
		ifFalse: [
			self position: self position.
			collection at: (position := position + 1)]!

next: count into: aSequenceableCollection startingAt: startAt
	"Destructively replace the elements of the argument, aSequenceableCollection,
	in the interval (startAt..startAt+count-1) with the next, count, elements of
	the receiver. Answer aSequenceableCollection.
	Implementation Note: For efficiency we implement this as a loop which
	transfers as many elements as possible on each iteration, optimally a page
	at a time."

	| startOffset elemsRead |
	startOffset := startAt - 1.
	elemsRead := 0.
	[elemsRead < count] whileTrue: [ | blockSize tmp |
		self atEnd ifTrue: [self errorEndOfStream].
		blockSize := (readLimit - position) min: (count - elemsRead).
		tmp := elemsRead + blockSize.
		aSequenceableCollection
			replaceFrom: startAt + elemsRead
			to: startOffset + tmp
			with: collection
			startingAt: position + 1.
		"Reposition to the start of the next page (or the end of the file)"
		self position: self position + blockSize.
		elemsRead := tmp].
	^aSequenceableCollection!

next: sizeInteger putAll: aSequenceableCollection startingAt: startInteger 
	"Append countInteger elements of aSequenceableCollection from startInteger
	to the receiver. Answer aSequenceableCollection."

	| stop |
	stop := position + sizeInteger.
	stop <= writeLimit 
		ifTrue: 
			["The block fits into the current page and can be 	written directly to the buffer"

			sizeInteger > 0 
				ifTrue: 
					[collection 
						replaceFrom: position + 1
						to: stop
						with: aSequenceableCollection
						startingAt: startInteger.
					position := stop.
					self beDirty]]
		ifFalse: 
			[| lastPos lastPageStart startNextPage wholePagesSize writeOffset |
			lastPos := pageBase + position + sizeInteger - 1.
			writeOffset := writeLimit - position.
			"Update and write current page"
			position < writeLimit 
				ifTrue: 
					[collection 
						replaceFrom: position + 1
						to: writeLimit
						with: aSequenceableCollection
						startingAt: startInteger.
					position := writeLimit.
					self beDirty].
			self flush.
			"Next write any whole pages"
			startNextPage := pageBase + writeLimit.
			lastPageStart := (lastPos truncateTo: writeLimit) + 1.
			wholePagesSize := lastPageStart - startNextPage.
			wholePagesSize > 0 
				ifTrue: 
					[file position: startNextPage - 1.
					0 to: wholePagesSize // writeLimit - 1
						do: 
							[:i | 
							collection 
								replaceFrom: 1
								to: writeLimit
								with: aSequenceableCollection
								startingAt: startInteger + writeOffset + (i * writeLimit).
							file write: collection count: writeLimit].
					self assert: [file position = (lastPageStart - 1)]].

			"And finally buffer any trailing data having repositioned to the correct page"
			self readPageFor: lastPageStart.
			position := lastPos - lastPageStart + 1.
			position > 0 
				ifTrue: 
					[collection 
						replaceFrom: 1
						to: position
						with: aSequenceableCollection
						startingAt: startInteger + writeOffset + wholePagesSize.
					self beDirty]].
	^aSequenceableCollection!

nextPut: anIntegerOrCharacter 
	"Write anIntegerOrCharacter to the receiver and answer the argument."

	"Implementation Note: Inline the #beDirty operation as a performance optimization."

	flags := flags bitOr: DirtyBufferMask.
	^self primitiveNextPut: anIntegerOrCharacter!

nextPutAll: aCollection
	"Store the elements in the argument, aCollection, as the next elements accessible by the receiver. 
	Answer aCollection"

	^aCollection appendToStream: self!

position
	"Answer the absolute (zero-based) position of the file pointer."

	^pageBase + position - 1!

position: anInteger 
	"Move the receiver's logical position to absolute (zero-based) position anInteger."

	| pos |
	self size.	"cause limits to be updated"
	pos := anInteger + 1.
	(pos < pageBase or: [pos >= (pageBase + writeLimit)]) 
		ifTrue: 
			["anInteger is not within the current page.
			Write out any changes to the current page buffer and read the one required."
			self
				flush;
				readPageFor: anInteger].
	position := pos - pageBase!

primitiveNextPut: anIntegerOrCharacter
	"Private - Write anIntegerOrCharacter to the receiver."
	
	<primitive: 66>
	self position: self position.
	self beDirty.
	^collection at: (position := position + 1) put: anIntegerOrCharacter!

readPageFor: anInteger 
	"Private - Read the page containing position anInteger and record the pageBase
	and readLimit. The readLimit will be equal to the page size unless there are insufficient
	elements. The writeLimit is always equal to the page/buffer size."

	#todo.	"If page size must be power of 2, can avoid division here."
	pageBase := anInteger // writeLimit * writeLimit + 1.
	readLimit := file
				position: pageBase - 1;
				read: collection count: writeLimit!

reverseContents
	"Answer the reversed contents of the receiver."

	^(self contents readStream) reverseContents
!

setToEnd
	"Set the file pointer to the end of the file. The current page is flushed and the last page in the file
	will be read, unless already on the last page."

	self position: self lastPosition
!

skip: anInteger
	"Adjust the receiver's position by anInteger ensuring that it remains
	within the bounds of the collection."

	self position: (((self position + anInteger) max: 0) min: self size - 1)
!

upTo: anObject 
	"Answer a <sequencedReadableCollection> of elements starting with the 
	next element accessed by the receiver, and up to, but not inclusive of, 
	the next element that is equal to the <Object>, anObject.
	Positions the stream after anObject if found. If anObject is not in the 
	collection, answer the entire rest of the collection.
	If the receiver is at its end, then answer an empty collection."

	| found answer |
	found := false.
	answer := self makeBufferOfSize: 0.
	[found or: [self atEnd]] whileFalse: 
			[| startIndex endIndex |
			self position: self position.
			startIndex := position + 1.
			position := collection 
						nextIdentityIndexOf: anObject
						from: startIndex
						to: readLimit.
			(found := position ~~ 0) 
				ifTrue: [endIndex := position - 1]
				ifFalse: [endIndex := position := readLimit].
			answer := answer , (collection copyFrom: startIndex to: endIndex)].
	^answer!

writePage
	self size.	"cause limits to be updated"
	file
		position: pageBase - 1;
		write: collection count: readLimit.
	self beClean! !

(Package manager packageNamed: 'Dolphin') comment:
'Dolphin Smalltalk Base System.
Copyright (c) Object Arts Ltd. 1997-2016'!
