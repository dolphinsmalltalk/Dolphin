| package |
package := Package name: 'Dialect Abstraction Layer'.
package paxVersion: 1;
	basicComment: ''.

package basicPackageVersion: '6.1.8'.


package classNames
	add: #COMMTIMEOUTS;
	add: #COMPortWriter;
	add: #DCB;
	add: #Filename;
	add: #ItcBase64EncoderDecoder;
	add: #ItcConverter;
	add: #ItcDeferredValue;
	add: #ItcInterval;
	add: #ItcLookupTable;
	add: #ItcOrderedUniqueCollection;
	add: #ItcProtoObject;
	add: #ItcSemaphoreWithTimeout;
	add: #ItcSortBlock;
	add: #ItcSSLSocket;
	add: #ItcSystemManager;
	add: #LIBEAY32Library;
	add: #LIBSSL32Library;
	add: #Money;
	add: #Timestamp;
	yourself.

package methodNames
	add: #ArrayedCollection -> #replaceAll:with:;
	add: #Behavior -> #basicAllInstances;
	add: #BlockClosure -> #cachedValue;
	add: #BlockClosure -> #generateOn:;
	add: #BlockClosure -> #isBlockClosure;
	add: #BlockClosure -> #itcDeferredValue;
	add: #ByteArray -> #itcAsHexString;
	add: #ByteArray -> #itcAsInteger;
	add: #Character -> #itcAsInteger;
	add: #Collection -> #conform:;
	add: #Collection -> #isNilOrEmpty;
	add: #Collection -> #itcGetAbsSum;
	add: #Collection -> #itcGetMax;
	add: #Collection -> #itcGetMin;
	add: #Collection -> #itcGetSum;
	add: #Collection -> #itcGetSumOrNil;
	add: #Date -> #asDDMMYYYYstring;
	add: #Date -> #asFilenameString;
	add: #Date -> #asOdbcString;
	add: #Date -> #asOdbcStringOn:;
	add: #Date -> #asYYMMDDstring;
	add: #Date -> #date;
	add: #Date -> #dayOfWeek;
	add: #Date -> #daysFromBaseDay;
	add: #Date -> #daysInMonth;
	add: #Date -> #daysLeftInMonth;
	add: #Date -> #firstDayOfMonthDate;
	add: #Date -> #firstDayOfYearDate;
	add: #Date -> #fullMonthsUntil:;
	add: #Date -> #itcIsSunday;
	add: #Date -> #lastDayOfMonthDate;
	add: #Date -> #lastDayOfWeekDate;
	add: #Date -> #lastDayOfYearDate;
	add: #Date -> #monthsArrayUntil:;
	add: #Date -> #monthsUntil:;
	add: #Date -> #subtractMonths:;
	add: #Dictionary -> #at:add:;
	add: #Dictionary -> #isDictionaryOrLookupTable;
	add: #Dictionary -> #replaceAll:with:;
	add: #Exception -> #exitWith:;
	add: #Exception -> #itcDescription;
	add: #Exception -> #signalWithMessage:;
	add: #FileStream -> #isFileStream;
	add: #Integer -> #asDecimalOrFloat;
	add: #Integer -> #asHexString;
	add: #Integer -> #asLeadingZerosStringOfSize:;
	add: #Integer -> #itcAsBitString;
	add: #Integer -> #itcAsByteArray;
	add: #KernelLibrary -> #getCommState:lpDCB:;
	add: #KernelLibrary -> #getCurrentProcessId;
	add: #KernelLibrary -> #setCommState:lpDCB:;
	add: #Number -> #-~;
	add: #Number -> #+~;
	add: #Number -> #asDecimalOrFloat;
	add: #Number -> #itcAsInteger;
	add: #Number -> #itcAsNumberOrZero;
	add: #Number -> #itcNegated;
	add: #Number -> #itcRoundTo:;
	add: #Object -> #addToBeFinalized;
	add: #Object -> #asDateFromDDMMYYYYString;
	add: #Object -> #cachedValue;
	add: #Object -> #isBlockClosure;
	add: #Object -> #isDictionaryOrLookupTable;
	add: #Object -> #isFileStream;
	add: #Object -> #isNilOrEmpty;
	add: #Object -> #isNilOrZero;
	add: #Object -> #itcAsInteger;
	add: #Object -> #itcAsNumberOrZero;
	add: #Object -> #itcNegated;
	add: #Object -> #itcObsoleteCode;
	add: #Object -> #itcRoundTo:;
	add: #Object -> #itcTemp;
	add: #Object -> #itcTodo;
	add: #Object -> #sestej:;
	add: #OrderedCollection -> #replaceAll:with:;
	add: #PositionableStream -> #peekLine;
	add: #Process -> #attributes;
	add: #Process -> #attributesReset;
	add: #Process -> #itcIsTerminated;
	add: #Process -> #itcProcessId;
	add: #Process -> #itcProcessName;
	add: #Process -> #itcProcessSize;
	add: #Process -> #itcProcessState;
	add: #Process -> #itcSafeTerminate;
	add: #Process -> #itcSuspendedFrameString;
	add: #ProcessorScheduler -> #allProcesses;
	add: #ReadStream -> #peek:;
	add: #SequenceableCollection -> #at:add:;
	add: #SequenceableCollection -> #doWithIndex:;
	add: #SequenceableCollection -> #findLastElement:;
	add: #SequenceableCollection -> #indexOf:startingAt:;
	add: #SequencedStream -> #itcSkipToAll:;
	add: #SequencedStream -> #itcUpToAll:;
	add: #Socket -> #peerAddressString;
	add: #SocketAbstract -> #isClosed;
	add: #SocketAbstract -> #socketShutdown;
	add: #SocketAbstract -> #socketShutdownAndClose;
	add: #SocketReadStream -> #isBytes:;
	add: #SocketReadStream -> #itcUpToEnd;
	add: #SocketWriteStream -> #isBytes:;
	add: #SocketWriteStream -> #itcFlush;
	add: #SocketWriteStream -> #sendLine:;
	add: #Stream -> #itcCrLf;
	add: #String -> #add:withDelimiter:;
	add: #String -> #asDateFromDDMMYYYYString;
	add: #String -> #asDecimalOrFloat;
	add: #String -> #asFilenameString;
	add: #String -> #asPlainAsciiString;
	add: #String -> #asUTF8;
	add: #String -> #asUTF8String;
	add: #String -> #beginsWithUppercase:;
	add: #String -> #breakIntoLinesOfLength:;
	add: #String -> #breakIntoStringsOfLength:;
	add: #String -> #breakIntoStringsOfLength:skipLeadingWhitespace:;
	add: #String -> #endsWithUppercase:;
	add: #String -> #isAllDigits;
	add: #String -> #isAlphabeticalyBefore:;
	add: #String -> #itcAsInteger;
	add: #String -> #itcAsMoneyDecimal;
	add: #String -> #itcAsMoneyDecimalWithPrecision:;
	add: #String -> #itcReplaceAllSubstrings:with:;
	add: #String -> #itcSubStrings:;
	add: #String -> #splitString:;
	add: #String -> #trimByReducingVowelsToSize:;
	add: #String -> #trimOrPadLeftToSize:;
	add: #String -> #trimOrPadToSize:;
	add: #String -> #trimOrPadToSize:using:;
	add: #String -> #trimOrZeroPadToSize:;
	add: #String -> #trimSeparators;
	add: #String -> #trimToSize:;
	add: #String -> #trimToSizeWithDots:;
	add: #Symbol -> #itcAsClass;
	add: #Symbol -> #itcAsClassOrNil;
	add: #Time -> #asOdbcString;
	add: #Time -> #asOdbcStringOn:;
	add: #TimeStamp -> #asFilenameString;
	add: #TimeStamp -> #asOdbcStringOn:;
	add: #TimeStamp -> #asOdbcStringWithMicrosOn:;
	add: #TimeStamp -> #totalSeconds;
	add: #UndefinedObject -> #-~;
	add: #UndefinedObject -> #+~;
	add: #UndefinedObject -> #add:withDelimiter:;
	add: #UndefinedObject -> #asString;
	add: #UndefinedObject -> #isNilOrEmpty;
	add: 'Exception class' -> #signalWithMessage:;
	add: 'FileStream class' -> #delete:;
	add: 'ScaledDecimal class' -> #numerator:denominator:scale:;
	add: 'String class' -> #utf8DecodeFrom:on:;
	add: 'String class' -> #utf8DecodeNextUnicodeFromUtf8Stream:;
	add: 'String class' -> #utf8EncodeFrom:on:addMarker:;
	add: 'String class' -> #utf8EncodeUnicode:;
	add: 'Time class' -> #hours:minutes:seconds:milliseconds:;
	yourself.

package globalNames
	add: #ItcDelay;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	add: #ItcDelay;
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\..\Object Arts\Dolphin\Base\Dolphin';
	add: '..\..\Object Arts\Dolphin\Sockets\Dolphin Sockets';
	add: '..\..\Object Arts\Dolphin\MVP\Gdiplus\Gdiplus';
	add: 'OmniBase';
	add: '..\..\Object Arts\Dolphin\Sockets\Sockets Connection';
	add: '..\..\Object Arts\Dolphin\ActiveX\Shell\Windows Shell';
	yourself).

package!

"Class Definitions"!

Object subclass: #COMPortWriter
	instanceVariableNames: 'handle'
	classVariableNames: ''
	poolDictionaries: 'Win32Constants Win32Errors'
	classInstanceVariableNames: ''!
Object subclass: #Filename
	instanceVariableNames: 'filename file'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ItcBase64EncoderDecoder
	instanceVariableNames: 'decodingTable'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ItcConverter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ItcSemaphoreWithTimeout
	instanceVariableNames: 'realSemaphore maxWaitTimeout lastCriticalSectionEntryTS lastCriticalSectionWaitTS onMutexResetBlock semaphoreName'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ItcSortBlock
	instanceVariableNames: 'sortSelectors'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ItcSystemManager
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'previousTimeReading rollOverValue isHeadless liveUpdatePatchDict'!
Interval subclass: #ItcInterval
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
OrderedCollection variableSubclass: #ItcOrderedUniqueCollection
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
LookupTable variableSubclass: #ItcLookupTable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
DeferredValue subclass: #ItcDeferredValue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ExternalLibrary subclass: #LIBEAY32Library
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ExternalLibrary subclass: #LIBSSL32Library
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'isInitialized'!
Win32Structure subclass: #COMMTIMEOUTS
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Win32Structure subclass: #DCB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Magnitude subclass: #Money
	instanceVariableNames: 'currency amount'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
TimeStamp subclass: #Timestamp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Socket subclass: #ItcSSLSocket
	instanceVariableNames: 'method ctx handle'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ProtoObject subclass: #ItcProtoObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: '_InstanceBehaviorMasks'
	classInstanceVariableNames: ''!

"Global Aliases"!

ItcDelay := Delay!


"Loose Methods"!

!ArrayedCollection methodsFor!

replaceAll: element1 with: element2 
	"Answer the receiver after replacing all occurrences of element1
	 with element2."

	1 to: self size do: [:i | (self at: i) = element1 ifTrue: [self at: i put: element2]]! !
!ArrayedCollection categoriesFor: #replaceAll:with:!public!replacing! !

!Behavior methodsFor!

basicAllInstances
	"For compatibility with VAST and for skipping the global garbage collection."

	^self primAllInstances! !
!Behavior categoriesFor: #basicAllInstances!instances!public! !

!BlockClosure methodsFor!

cachedValue
	"See implementors of #cachedValue.
	This is used for lazy intialization and caching of expressions results
	For example, if you use:

			[10000 factorial] cachedValue

	in the method this will be evaluated only once.
	"

	self argumentCount = 0 ifFalse: [self error: 'Invalid number of block arguments'].
	^self become: self value!

generateOn: htmlStream 
	self argumentCount = 0 ifTrue: [self value] ifFalse: [self value: htmlStream]!

isBlockClosure
	^true!

itcDeferredValue
	"Answer deferred value and evaluate aBlock in parallel.
	The difference to standard Dolphin deferred value is
	that this method will copy current process's attributes (session, process expiration, ...).
	
	Answer a <niladicValuable> that begins evaluating the receiver asynchronously
	at the current process's priority, and which when evaluated will synchronously 
	supply the result."

	^ItcDeferredValue evaluate: self at: Processor activePriority! !
!BlockClosure categoriesFor: #cachedValue!not restartable!public!unwinding! !
!BlockClosure categoriesFor: #generateOn:!not restartable!public!unwinding! !
!BlockClosure categoriesFor: #isBlockClosure!not restartable!public!unwinding! !
!BlockClosure categoriesFor: #itcDeferredValue!not restartable!public!unwinding! !

!ByteArray methodsFor!

itcAsHexString
	| stream |
	stream := WriteStream on: String new.
	self printHexOn: stream.
	^stream contents!

itcAsInteger
	^self inject: 0 into: [:sum :each | sum * 256 + each]! !
!ByteArray categoriesFor: #itcAsHexString!accessing!public! !
!ByteArray categoriesFor: #itcAsInteger!accessing!public! !

!Character methodsFor!

itcAsInteger
	"Answer the number that it is"

	| i |
	i := self codePoint.
	^(i > 47 and: [i < 58]) ifTrue: [i - 48]! !
!Character categoriesFor: #itcAsInteger!converting!public! !

!Collection methodsFor!

conform: discriminator
	"Answer whether the <monadicValuable>, discriminator, evaluates to true for
	every element of the receiver.
	Implementation Note: The argument is evaluated for every element
	of the receiver iff it is satisfied for every element."

	self do: [:e | (discriminator value: e) ifFalse: [^false]].
	^true!

isNilOrEmpty
	^self isEmpty!

itcGetAbsSum
	| sum |
	sum := 0.
	self do: [:each | each isNil ifFalse: [sum := sum + each abs]].
	^sum!

itcGetMax
	| max |
	max := nil.
	self 
		do: [:each | each isNil ifFalse: [max isNil ifTrue: [max := each] ifFalse: [max := max max: each]]].
	^max!

itcGetMin
	| min |
	min := nil.
	self 
		do: [:each | each isNil ifFalse: [min isNil ifTrue: [min := each] ifFalse: [min := min min: each]]].
	^min!

itcGetSum
	| sum |
	sum := 0.
	self do: [:each | each isNil ifFalse: [sum := sum + each]].
	^sum!

itcGetSumOrNil
	| sum |
	sum := nil.
	self 
		do: [:each | each isNil ifFalse: [sum isNil ifTrue: [sum := each] ifFalse: [sum := sum + each]]].
	^sum! !
!Collection categoriesFor: #conform:!enumerating!public! !
!Collection categoriesFor: #isNilOrEmpty!public! !
!Collection categoriesFor: #itcGetAbsSum!enumerating!public! !
!Collection categoriesFor: #itcGetMax!enumerating!public! !
!Collection categoriesFor: #itcGetMin!enumerating!public! !
!Collection categoriesFor: #itcGetSum!enumerating!public! !
!Collection categoriesFor: #itcGetSumOrNil!enumerating!public! !

!Date methodsFor!

asDDMMYYYYstring
	^ItcConverter getStringFromDate: self dateFormat: 'DDMMYYYY'!

asFilenameString
	^self asOdbcString!

asOdbcString
	| stream |
	stream := WriteStream on: (String new: 16).
	self asOdbcStringOn: stream.
	^stream contents!

asOdbcStringOn: stream 
	| n |
	(n := self year) > 999 
		ifTrue: [n printOn: stream]
		ifFalse: 
			[n < 10 ifTrue: [stream nextPut: $0].
			n < 100 ifTrue: [stream nextPut: $0].
			stream nextPut: $0.
			n printOn: stream].
	stream nextPut: $-.
	(n := self monthIndex) < 10 ifTrue: [stream nextPut: $0].
	n printOn: stream.
	stream nextPut: $-.
	(n := self dayOfMonth) < 10 ifTrue: [stream nextPut: $0].
	n printOn: stream!

asYYMMDDstring
	^ItcConverter getStringFromDate: self dateFormat: 'YYMMDD'!

date
	"To make timestamps and dates interoperabile."

	^self!

dayOfWeek
		"ANSI API - answer day of week index: Sunday, Monday, ... = 1, 2, 3, ...
		This is different than Dolphin's weekDayIndex."

	| index |
	index := self weekdayIndex.
	^index = 7
		ifTrue: [1]
		ifFalse: [index + 1]!

daysFromBaseDay
	^self asDays!

daysInMonth
	^self class daysInMonthIndex: self monthIndex forYear: self year!

daysLeftInMonth
	^self daysInMonth - self dayOfMonth!

firstDayOfMonthDate

	"Answer a <date> representing the first day of the
	 month which includes the receiver."

	^self subtractDays: self dayOfMonth - 1!

firstDayOfYearDate
	"Answer a <date> representing the first day of the
	 month which includes the receiver."

	^self class 
		newDay: 1
		monthIndex: 1
		year: self year!

fullMonthsUntil: aDate 
	"Return number of full pasted months. Etc. from 8.1. tp 8.2., or from 30.1. to 28.2. (last day in month)."

	| months |
	aDate < self ifTrue: [^0].
	months := aDate monthIndex + (aDate year * 12) - (self monthIndex + (self year * 12)).
	(aDate dayOfMonth >= self dayOfMonth or: [aDate daysLeftInMonth = 0]) 
		ifFalse: [months := months - 1 max: 0].
	^months!

itcIsSunday
	^self dayOfWeek = 1!

lastDayOfMonthDate
	"Answer a <date> representing the last day of the
	 month which includes the receiver."

	^self addDays: self daysLeftInMonth!

lastDayOfWeekDate
	"Answer a <date> representing the last day of the
	 week (Sunday) which includes the receiver."

	| d |
	d := self.
	[d itcIsSunday] whileFalse: [d := d addDays: 1].
	^d!

lastDayOfYearDate
	^self class 
		newDay: 31
		monthIndex: 12
		year: self year!

monthsArrayUntil: dateUntil 
	| date result endDate |
	result := OrderedCollection new.
	date := self.
	[date < dateUntil] whileTrue: 
			[endDate := (Date 
						newDay: (Date daysInMonthIndex: date monthIndex forYear: date year)
						monthIndex: date monthIndex
						year: date year) min: dateUntil.
			result add: (Array with: date with: endDate).
			date := date addMonths: 1.
			date := Date 
						newDay: 1
						monthIndex: date monthIndex
						year: date year].
	^result!

monthsUntil: aDate 
	| months minDate maxDate calculationDate |
	self > aDate 
		ifTrue: 
			[maxDate := self.
			minDate := aDate]
		ifFalse: 
			[maxDate := aDate.
			minDate := self].
	calculationDate := maxDate addDays: 1.
	months := (calculationDate year - minDate year) * 12 
				+ (calculationDate monthIndex - minDate monthIndex).
	minDate dayOfMonth > calculationDate dayOfMonth ifTrue: [months := months - 1].
	^months!

subtractMonths: numberOfMonths 
	| monthIndex leto months monthDifference |
	months := numberOfMonths asInteger.
	monthDifference := self monthIndex - months.
	leto := self year.
	monthIndex := monthDifference abs \\ 12.
	monthDifference < 0 
		ifTrue: 
			[monthIndex := 12 - monthIndex.
			leto := leto - (monthDifference abs // 12) - 1].
	monthIndex = 0 
		ifTrue: 
			[monthIndex := 12.
			leto := leto - 1].
	^Date 
		newDay: (self dayOfMonth min: (Date daysInMonthIndex: monthIndex forYear: leto))
		monthIndex: monthIndex
		year: leto! !
!Date categoriesFor: #asDDMMYYYYstring!public! !
!Date categoriesFor: #asFilenameString!public! !
!Date categoriesFor: #asOdbcString!public! !
!Date categoriesFor: #asOdbcStringOn:!public! !
!Date categoriesFor: #asYYMMDDstring!public! !
!Date categoriesFor: #date!operations!public! !
!Date categoriesFor: #dayOfWeek!accessing!public! !
!Date categoriesFor: #daysFromBaseDay!accessing!public! !
!Date categoriesFor: #daysInMonth!accessing!public! !
!Date categoriesFor: #daysLeftInMonth!accessing!public! !
!Date categoriesFor: #firstDayOfMonthDate!operations!public! !
!Date categoriesFor: #firstDayOfYearDate!operations!public! !
!Date categoriesFor: #fullMonthsUntil:!public! !
!Date categoriesFor: #itcIsSunday!public! !
!Date categoriesFor: #lastDayOfMonthDate!operations!public! !
!Date categoriesFor: #lastDayOfWeekDate!operations!public! !
!Date categoriesFor: #lastDayOfYearDate!operations!public! !
!Date categoriesFor: #monthsArrayUntil:!public! !
!Date categoriesFor: #monthsUntil:!public! !
!Date categoriesFor: #subtractMonths:!public! !

!Dictionary methodsFor!

at: key add: value 
	"Vrednosti at: key pristeje value.
	- ce je value 0 se ne zgodi nic
	- ce je sedanja vrednost nil jo postavi na 0"

	| currentValue |
	currentValue := self at: key ifAbsent: [0].
	currentValue isNil ifTrue: [currentValue := 0].
	value isNil ifFalse: [currentValue := currentValue + value].
	self at: key put: currentValue.
	^value!

isDictionaryOrLookupTable
	^true!

replaceAll: aValue with: newValue 
	self 
		keysAndValuesDo: [:eachKey :eachValue | eachValue = aValue ifTrue: [self at: eachKey put: newValue]]! !
!Dictionary categoriesFor: #at:add:!accessing!public! !
!Dictionary categoriesFor: #isDictionaryOrLookupTable!accessing!public! !
!Dictionary categoriesFor: #replaceAll:with:!accessing!public! !

!Exception methodsFor!

exitWith: anObject 
	^self return: anObject!

itcDescription
	^self description!

signalWithMessage: aString 
	^self signal: aString! !
!Exception categoriesFor: #exitWith:!handler responses!public! !
!Exception categoriesFor: #itcDescription!displaying!public! !
!Exception categoriesFor: #signalWithMessage:!displaying!public! !

!Exception class methodsFor!

signalWithMessage: aString 
	^self signal: aString! !
!Exception class categoriesFor: #signalWithMessage:!instance creation!public! !

!FileStream methodsFor!

isFileStream
	^true! !
!FileStream categoriesFor: #isFileStream!buffer!public! !

!FileStream class methodsFor!

delete: filename 
	^File delete: filename! !
!FileStream class categoriesFor: #delete:!instance creation!public! !

!Integer methodsFor!

asDecimalOrFloat
	^self asScaledDecimal: 2!

asHexString
	^self printStringRadix: 16 showRadix: false!

asLeadingZerosStringOfSize: size 
	| str |
	str := self printString.
	[str size < size] whileTrue: [str := '0' , str].
	^str!

itcAsBitString
	^self printStringRadix: 2 showRadix: false!

itcAsByteArray
	| stream |
	stream := WriteStream on: ByteArray new.
	self digitLength to: 1
		by: -1
		do: [:digitIndex | stream nextPut: (self digitAt: digitIndex)].
	^stream contents! !
!Integer categoriesFor: #asDecimalOrFloat!public! !
!Integer categoriesFor: #asHexString!public! !
!Integer categoriesFor: #asLeadingZerosStringOfSize:!public! !
!Integer categoriesFor: #itcAsBitString!public! !
!Integer categoriesFor: #itcAsByteArray!converting!public! !

!KernelLibrary methodsFor!

getCommState: fileHandle lpDCB: aDCB 
	"Retrieves the current control settings for a specified communications device.

Parameters:

hFile
    [in] A handle to the communications device. The CreateFile function returns this handle.
lpDCB
   [out] A pointer to a DCB structure that receives the control settings information.

Return Value:

If the function succeeds, the return value is nonzero.
If the function fails, the return value is zero. To get extended error information, call GetLastError.


BOOL WINAPI GetCommState(
  HANDLE hFile,
  LPDCB lpDCB
);
"

	<stdcall: bool GetCommState handle DCB*>
	^self invalidCall!

getCurrentProcessId
	"Answer handle of the Dolphin process.

		DWORD GetCurrentProcessId()"

	<stdcall: dword GetCurrentProcessId>
	^self invalidCall
 !

setCommState: fileHandle lpDCB: aDCB 
	"Configures a communications device according to the specifications in a device-control block (a DCB structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues.

Parameters:

hFile
    [in] A handle to the communications device. The CreateFile function returns this handle.
lpDCB
    [in] A pointer to a DCB structure that contains the configuration information for the specified communications device.

Return Value:

If the function succeeds, the return value is nonzero.
If the function fails, the return value is zero. To get extended error information, call GetLastError.


BOOL WINAPI SetCommState(
  HANDLE hFile,
  LPDCB lpDCB
);
"

	<stdcall: bool SetCommState handle DCB*>
	^self invalidCall! !
!KernelLibrary categoriesFor: #getCommState:lpDCB:!public! !
!KernelLibrary categoriesFor: #getCurrentProcessId!public!win32 functions-process and thread! !
!KernelLibrary categoriesFor: #setCommState:lpDCB:!public! !

!Number methodsFor!

-~ aNumber 
	^aNumber isNil ifFalse: [self - aNumber roundTo: 0.01s] ifTrue: [self]!

+~ aNumber 
	^aNumber isNil ifTrue: [self] ifFalse: [self + aNumber roundTo: 0.01s]!

asDecimalOrFloat
	^self!

itcAsInteger
	^self asInteger!

itcAsNumberOrZero
	^self!

itcNegated
	^0.0s -~ self!

itcRoundTo: vrstaZaokrozevanja 
	(vrstaZaokrozevanja isNil or: [vrstaZaokrozevanja < 2]) ifTrue: [^self roundTo: 0.01s].
	vrstaZaokrozevanja = 4 ifTrue: [^self roundTo: 1.00s].
	vrstaZaokrozevanja = 3 ifTrue: [^self roundTo: 0.50s].
	vrstaZaokrozevanja = 2 ifTrue: [^self roundTo: 0.10s].
	vrstaZaokrozevanja = 5 ifTrue: [^self roundTo: 0.001s].
	vrstaZaokrozevanja = 6 ifTrue: [^self roundTo: 0.0001s].
	vrstaZaokrozevanja = 7 ifTrue: [^self roundTo: 0.00001s].
	vrstaZaokrozevanja = 8 ifTrue: [^self roundTo: 0.000001s].
	self error: 'Unknown rounding type'! !
!Number categoriesFor: #-~!converting!public! !
!Number categoriesFor: #+~!converting!public! !
!Number categoriesFor: #asDecimalOrFloat!converting!public! !
!Number categoriesFor: #itcAsInteger!converting!public! !
!Number categoriesFor: #itcAsNumberOrZero!converting!public! !
!Number categoriesFor: #itcNegated!converting!public! !
!Number categoriesFor: #itcRoundTo:!converting!public! !

!Object methodsFor!

addToBeFinalized
	self beFinalizable!

asDateFromDDMMYYYYString
	^nil!

cachedValue
	"See implementors of #cachedValue.
	This is used for lazy intialization and caching of expressions results
	For example, if you use:

			[10000 factorial] cachedValue

	in the method this will be evaluated only once.
	"

	^self!

isBlockClosure
	^false!

isDictionaryOrLookupTable
	^false!

isFileStream
	^false!

isNilOrEmpty
	^false!

isNilOrZero
	^self isNil or: [self = 0]!

itcAsInteger
	^0!

itcAsNumberOrZero
	"If the receiver is number it will answer receiver, else zero."

	^0!

itcNegated
	^nil!

itcObsoleteCode
	"Send this message to mark method as obsolete.
	Use references to #itcObsoleteCode to find all obsolete methods."

	!

itcRoundTo: vrstaZaokrozevanja 
	^nil!

itcTemp
	"Use this method anywhere in your code to indicate that there is a temporary code which needs to be removed/fixed before deployment."

	!

itcTodo
	"Use this method anywhere in your code to indicate that there is still something to do."

	!

sestej: selectors 
	| sum value |
	selectors do: 
			[:each | 
			value := self perform: each.
			value isNil 
				ifFalse: 
					[sum isNil ifTrue: [sum := 0.0s].
					sum := sum + value]].
	^sum! !
!Object categoriesFor: #addToBeFinalized!comparing!public! !
!Object categoriesFor: #asDateFromDDMMYYYYString!comparing!public! !
!Object categoriesFor: #cachedValue!comparing!public! !
!Object categoriesFor: #isBlockClosure!constants!public! !
!Object categoriesFor: #isDictionaryOrLookupTable!public!testing! !
!Object categoriesFor: #isFileStream!public!testing! !
!Object categoriesFor: #isNilOrEmpty!public! !
!Object categoriesFor: #isNilOrZero!public! !
!Object categoriesFor: #itcAsInteger!comparing!public! !
!Object categoriesFor: #itcAsNumberOrZero!comparing!public! !
!Object categoriesFor: #itcNegated!comparing!public! !
!Object categoriesFor: #itcObsoleteCode!public! !
!Object categoriesFor: #itcRoundTo:!converting!public! !
!Object categoriesFor: #itcTemp!public! !
!Object categoriesFor: #itcTodo!public! !
!Object categoriesFor: #sestej:!comparing!public! !

!OrderedCollection methodsFor!

replaceAll: element1 with: element2 
	"Answer the receiver after replacing all occurrences of element1
	 with element2."

	1 to: self size do: [:i | (self at: i) = element1 ifTrue: [self at: i put: element2]]! !
!OrderedCollection categoriesFor: #replaceAll:with:!public!replacing! !

!PositionableStream methodsFor!

peekLine
	| pos |
	pos := self position.
	[^self nextLine] ensure: [self position: pos]! !
!PositionableStream categoriesFor: #peekLine!accessing!public! !

!Process methodsFor!

attributes
	_reserved1 ifNil: [_reserved1 := LookupTable new].
	^_reserved1!

attributesReset
	"Reset attributes for the next request."

	| oldDict newDict previousValue |
	^(oldDict := self attributes) notEmpty 
		ifTrue: 
			[newDict := LookupTable new.
			(previousValue := oldDict at: #name ifAbsent: []) isNil 
				ifFalse: [newDict at: #name put: previousValue].
			(previousValue := oldDict at: #webLanguage ifAbsent: []) isNil 
				ifFalse: [newDict at: #webLanguage put: previousValue].
			(previousValue := oldDict at: #webHttpSocketToClose ifAbsent: []) isNil 
				ifFalse: [newDict at: #webHttpSocketToClose put: previousValue].
			(previousValue := oldDict at: #webLanguageDict ifAbsent: []) isNil 
				ifFalse: [newDict at: #webLanguageDict put: previousValue].
			_reserved1 := newDict.
			newDict]!

itcIsTerminated
	"Dialect portable way of asking if a process was terminated."

	self isAlive ifTrue: [^false].
	^self isDead or: [self isTerminated]!

itcProcessId
	^self id!

itcProcessName
	^self name!

itcProcessSize
	^self size!

itcProcessState
	^self state!

itcSafeTerminate
	"Safely terminates the running process."

	| socketToClose |
	(self attributes at: #orTransactionCommitInProgress ifAbsent: []) isNil 
		ifFalse: 
			[30 timesRepeat: 
					[ItcSystemManager 
						logLineWithTsAndSession: 'Terminating process "' , self itcProcessName asWebString 
								, '", waiting 1 sec due to OR transaction commit in progress'.
					(ItcDelay forSeconds: 1) wait.
					(self attributes at: #orTransactionCommitInProgress ifAbsent: []) isNil 
						ifTrue: [^self itcSafeTerminate]].
			self attributes at: #orTransactionCommitInProgress put: nil.
			Processor activeProcess == self ifTrue: [^self itcSafeTerminate].
			ItcSystemManager 
				forkNewProcessOn: [self itcSafeTerminate]
				named: 'Terminating process "' , self itcProcessName asWebString 
						, '", forked due to OR transaction commit in progress'
				priority: ItcSystemManager serverWatchdogPriority.
			^self].
	((self respondsTo: #webHttpSocketToClose) 
		and: [(socketToClose := self webHttpSocketToClose) notNil]) 
			ifTrue: 
				[
				[ItcSystemManager 
					logLineWithTsAndPID: 'About to close server socket for process #' , self itcProcessId printString.
				self webHttpSocketToClose: nil.
				socketToClose close] 
						on: Error
						do: [:ex | ].
				Processor activeProcess == self 
					ifTrue: 
						[(ItcDelay forMilliseconds: 300) wait.
						^self itcSafeTerminate].
				ItcSystemManager 
					forkNewProcessOn: 
						[(ItcDelay forMilliseconds: 300) wait.
						self itcSafeTerminate]
					named: 'Terminating process "' , self itcProcessName asWebString , '" due to open server socket'
					priority: ItcSystemManager serverWatchdogPriority.
				^self].
	((self respondsTo: #webHttpClientSocketToClose) 
		and: [(socketToClose := self webHttpClientSocketToClose) notNil]) 
			ifTrue: 
				[
				[ItcSystemManager 
					logLineWithTsAndPID: 'About to close client socket for process #' , self itcProcessId printString.
				self webHttpClientSocketToClose: nil.
				socketToClose close] 
						on: Error
						do: [:ex | ].
				Processor activeProcess == self 
					ifTrue: 
						[(ItcDelay forMilliseconds: 300) wait.
						^self itcSafeTerminate].
				ItcSystemManager 
					forkNewProcessOn: 
						[(ItcDelay forMilliseconds: 300) wait.
						self itcSafeTerminate]
					named: 'Terminating process "' , self itcProcessName asWebString , '" due to open client socket'
					priority: ItcSystemManager serverWatchdogPriority.
				^self].
	"reusing temp var socketToClose..."
	(socketToClose := self attributes at: #webDeferredValueToSignalOnTerminate ifAbsent: []) isNil 
		ifFalse: 
			[socketToClose hasValue 
				ifFalse: 
					[socketToClose exception: ((Error new)
								messageText: 'Deferred value process was forcefully terminated';
								yourself)]].
	ItcSystemManager logLineWithTsAndPID: 'Process #' , self itcProcessId printString , ' terminated'.
	^self terminate!

itcSuspendedFrameString
	^self suspendedFrame displayString! !
!Process categoriesFor: #attributes!accessing!public! !
!Process categoriesFor: #attributesReset!accessing!public! !
!Process categoriesFor: #itcIsTerminated!public!states-testing! !
!Process categoriesFor: #itcProcessId!accessing!public! !
!Process categoriesFor: #itcProcessName!accessing!public! !
!Process categoriesFor: #itcProcessSize!accessing!public! !
!Process categoriesFor: #itcProcessState!accessing!public! !
!Process categoriesFor: #itcSafeTerminate!public!states-testing! !
!Process categoriesFor: #itcSuspendedFrameString!accessing!public! !

!ProcessorScheduler methodsFor!

allProcesses
	"
	| coll |
	coll := OrderedCollection new.
	1 to: Processor highestPriority do: [:i | coll addAll: (processLists at: i)].
	^coll"

	^Process allInstances! !
!ProcessorScheduler categoriesFor: #allProcesses!processes-accessing!public! !

!ReadStream methodsFor!

peek: anInteger 
	| lastPos result i |
	lastPos := self position.
	result := ''.
	i := 0.
	
	[[self atEnd or: [i = anInteger]] whileFalse: 
			[result := result , self next asString.
			i := i + 1]] 
			ensure: [self position: lastPos].
	^result! !
!ReadStream categoriesFor: #peek:!accessing!public! !

!ScaledDecimal class methodsFor!

numerator: n denominator: d scale: scale 
	^(self basicNew)
		setFraction: (Fraction numerator: n denominator: d) scale: scale;
		yourself! !
!ScaledDecimal class categoriesFor: #numerator:denominator:scale:!instance creation!public! !

!SequenceableCollection methodsFor!

at: index add: value 
	"Vrednosti at: index pristeje value.
	- ce je value 0 se ne zgodi nic
	- ce je sedanja vrednost nil jo postavi na 0"

	| currentValue |
	currentValue := self at: index.
	currentValue isNil ifTrue: [currentValue := 0].
	value isNil ifFalse: [currentValue := currentValue + value].
	self at: index put: currentValue.
	^value!

doWithIndex: aBlock 
	1 to: self size do: [:i | aBlock value: (self at: i) value: i]!

findLastElement: discriminator 
	"Answer the last element in the receiver for which the discriminator block evaluates to <true>.
	Answer <nil> if none."

	self reverseDo: [:each | (discriminator value: each) ifTrue: [^each]].
	^nil!

indexOf: target startingAt: start
	"Answer the <integer> index of the first element of the receiver which is 
	equal to the <Object> argument, target, within the receiver. If the receiver 
	does not contain any elements equal to target, answer 0."

	^self nextIndexOf: target from: start to: self size! !
!SequenceableCollection categoriesFor: #at:add:!accessing!public!testing! !
!SequenceableCollection categoriesFor: #doWithIndex:!enumerating!public! !
!SequenceableCollection categoriesFor: #findLastElement:!converting!public! !
!SequenceableCollection categoriesFor: #indexOf:startingAt:!public!searching! !

!SequencedStream methodsFor!

itcSkipToAll: aCollection 
	"Set the receivers current position to be past the next occurrence of the sequence of
	objects which are the elements of the <collection> argument. Answer whether such any such
	sequence was found."

	^self skipToAll: aCollection!

itcUpToAll: aCollection 
	"Answer a collection of the receiver's future sequence values starting with the next value
	accessed by the receiver, and up to, not inclusive of, the sequence of values that match the
	elements of the <collection> argument, or the remaining contents of the stream up to its end
	if the sequence is not found. The stream is left positioned after the last matching element,
	or at the end if the sequence is not found."

	^self upToAll: aCollection! !
!SequencedStream categoriesFor: #itcSkipToAll:!positioning!public! !
!SequencedStream categoriesFor: #itcUpToAll:!positioning!public! !

!Socket methodsFor!

peerAddressString
	^self peerAddress displayString! !
!Socket categoriesFor: #peerAddressString!accessing!public! !

!SocketAbstract methodsFor!

isClosed
	"Answer true if the receiver is closed"

	^self descriptor isNil!

socketShutdown
	"Use this instead of #close if you want to terminate an outstanding send/receive in another thread which is blocked.
	Using #close can result in image crash on Linux.
	"

	^self close!

socketShutdownAndClose
	"Use this instead of #close if you want to terminate an outstanding send/receive in another thread which is blocked.
	Using #close can result in image crash on Linux.
	"

	^self close! !
!SocketAbstract categoriesFor: #isClosed!public!testing! !
!SocketAbstract categoriesFor: #socketShutdown!public!testing! !
!SocketAbstract categoriesFor: #socketShutdownAndClose!public!testing! !

!SocketReadStream methodsFor!

isBytes: aBoolean 
	aBoolean 
		ifTrue: [collection class == ByteArray ifFalse: [collection := collection asByteArray]]
		ifFalse: [collection class == String ifFalse: [collection := collection asString]]!

itcUpToEnd
	| remainder |
	remainder := self contentsSpecies writeStream: 10240.
	[[self atEnd] whileFalse: [remainder nextPut: self next]] on: SocketClosed do: [:ex | ].
	^remainder contents! !
!SocketReadStream categoriesFor: #isBytes:!public! !
!SocketReadStream categoriesFor: #itcUpToEnd!operations!public! !

!SocketWriteStream methodsFor!

isBytes: aBoolean

	"do nothing"!

itcFlush
	^self flush!

sendLine: aCollection 
	^self
		nextPutAll: aCollection;
		nextPut: 13;
		nextPut: 10! !
!SocketWriteStream categoriesFor: #isBytes:!constants!public! !
!SocketWriteStream categoriesFor: #itcFlush!constants!public! !
!SocketWriteStream categoriesFor: #sendLine:!constants!public! !

!Stream methodsFor!

itcCrLf
	self nextPutAll: '
'! !
!Stream categoriesFor: #itcCrLf!accessing!public! !

!String methodsFor!

add: aString withDelimiter: delimiter 
	"Metoda spoji dva stringa z delimiterjem.
	Ce je katerikoli od stringov nil ali prazen se delimiter ne uporabi.
	Metoda vrne string, razen v primeru, ko je receiver prazen, aString pa nil."

	self isEmpty ifTrue: [^aString].
	aString isNilOrEmpty ifTrue: [^self].
	^self , delimiter , aString!

asDateFromDDMMYYYYString
	^ItcConverter getDateFromString: self dateFormat: 'DD.MM.YYYY'!

asDecimalOrFloat
	"Always answer a decimal or an integer."

	| n denominator start size scale ch |
	n := 0.
	denominator := 1.
	start := 1.
	(size := self size) > 0 ifFalse: [^0].
	
	[ch := self at: start.
	ch isDigit or: [ch = $. or: [ch = $-]]] whileFalse: [start := start + 1].
	
	[ch := self at: size.
	ch isDigit or: [ch = $. or: [size = start]]] whileFalse: [size := size - 1].
	"negative number?"
	(self at: start) = $- 
		ifTrue: 
			[start + 1 to: size
				do: 
					[:i | 
					ch := self at: i.
					"decimal point?"
					ch = $. 
						ifTrue: [scale := size - i]
						ifFalse: 
							[n := n * 10 + ch asInteger - 48.
							scale isNil ifFalse: [denominator := denominator * 10]]].
			n := 0 - n]
		ifFalse: 
			[start to: size
				do: 
					[:i | 
					ch := self at: i.
					"decimal point?"
					ch = $. 
						ifTrue: [scale := size - i]
						ifFalse: 
							[n := n * 10 + ch asInteger - 48.
							scale isNil ifFalse: [denominator := denominator * 10]]]].
	^scale isNil 
		ifTrue: 
			[ScaledDecimal 
				numerator: n
				denominator: 1
				scale: 0]
		ifFalse: 
			[ScaledDecimal 
				numerator: n
				denominator: denominator
				scale: scale]!

asFilenameString
	"Vrne string, ki ga sfiltrira tako, da je primeren za uporabo, kot filename.
	Vrne string za file name t.j. brez extenzije, ki se doda naknadno.
	Torej $. (pika) ne bo nikoli v stringu in se mora dodati naknadno z ekstenzijo."

	| str |
	str := ''.
	self asPlainAsciiString do: 
			[:ch | 
			('abcdefghijklmnopqrstuvwxyz1234567890-_.' includes: ch asLowercase) 
				ifTrue: [str := str , ch asString]
				ifFalse: [ch = $/ ifTrue: [str := str , '-'] ifFalse: [ch = $  ifTrue: [str := str , '_']]]].
	^str isNilOrEmpty ifTrue: ['empty'] ifFalse: [str]!

asPlainAsciiString
	"Metoda konvertira vse sumnike in umlaute v njihove najblizje ASCII ekvivalente."

	| temp ch |
	#itcTodo.
	"fix this so that it will work also when not running in CP 1250. Define conversion maps on WebTranslationService."
	temp := self copy.
	1 to: temp size
		do: 
			[:i | 
			ch := temp at: i.
			"CP 1251 - there are problems starting with á character that is used in windows encoding also"
			"ch = $à ifTrue: [temp at: i put: $a].
			ch = $á ifTrue: [temp at: i put: $b].
			ch = $â ifTrue: [temp at: i put: $v].
			ch = $ã ifTrue: [temp at: i put: $g]."

			"Windows encoding"
			ch = $š ifTrue: [temp at: i put: $s].
			ch = $Š ifTrue: [temp at: i put: $S].
			ch = $è ifTrue: [temp at: i put: $c].
			ch = $È ifTrue: [temp at: i put: $C].
			ch = $ž ifTrue: [temp at: i put: $z].
			ch = $Ž ifTrue: [temp at: i put: $Z].
			ch = $æ ifTrue: [temp at: i put: $c].
			ch = $Æ ifTrue: [temp at: i put: $C].
			ch = $Ð ifTrue: [temp at: i put: $D].
			ch = $ð ifTrue: [temp at: i put: $d].
			ch = $é ifTrue: [temp at: i put: $e].
			ch = $Ô ifTrue: [temp at: i put: $O].
			ch = $Á ifTrue: [temp at: i put: $A].
			ch = $ô ifTrue: [temp at: i put: $o].
			ch = $á ifTrue: [temp at: i put: $a].
			ch = $É ifTrue: [temp at: i put: $E].

			"ISO encoding"
			ch = $¹ ifTrue: [temp at: i put: $s].
			ch = $© ifTrue: [temp at: i put: $S].
			ch = $¾ ifTrue: [temp at: i put: $z].
			ch = $® ifTrue: [temp at: i put: $Z].

			"German keyboard"
			ch = $ä ifTrue: [temp at: i put: $a].
			ch = $ö ifTrue: [temp at: i put: $o].
			ch = $ü ifTrue: [temp at: i put: $u].
			ch = $ë ifTrue: [temp at: i put: $e].
			ch = $Ä ifTrue: [temp at: i put: $A].
			ch = $Ë ifTrue: [temp at: i put: $E].
			ch = $Ö ifTrue: [temp at: i put: $O].
			ch = $Ü ifTrue: [temp at: i put: $U].

			"Replace forbiden characters with blank space"
			(#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 127 129 132 133 134 135 139 144 160 164) 
				includes: ch asInteger) ifTrue: [temp at: i put: $ ]].
	^temp!

asUTF8
	"Answer receiver encoded into UTF-8 byte string. The encoding will be done based on the current process code page.
	Warning, the result will include 4 byte UTF8 marker !!!!!!
	"

	| ws |
	ws := WriteStream on: (String new: self size + 100).
	self class 
		utf8EncodeFrom: (ReadStream on: self)
		on: ws
		addMarker: true.
	^ws contents!

asUTF8String
	"Answer receiver encoded into UTF-8 byte string. The encoding will be done based on the current process code page."

	| ws |
	ws := WriteStream on: (String new: self size + 20).
	self class 
		utf8EncodeFrom: (ReadStream on: self)
		on: ws
		addMarker: false.
	^ws contents!

beginsWithUppercase: aString

	| stringSize |
	(stringSize := aString size)  > self size ifTrue: [^false].
	1 to: stringSize do: [:i |
		(self at: i) asUppercase = (aString at: i) ifFalse: [^false]
	].
	^true!

breakIntoLinesOfLength: maxLineSize 
	| result coll |
	self size <= maxLineSize ifTrue: [^self].
	coll := self breakIntoStringsOfLength: maxLineSize skipLeadingWhitespace: true.
	result := WriteStream on: String new.
	coll do: 
			[:eachLine | 
			result
				nextPutAll: eachLine;
				nextPutAll: '
'].
	^result contents!

breakIntoStringsOfLength: maxLineSize 
	^self breakIntoStringsOfLength: maxLineSize skipLeadingWhitespace: true!

breakIntoStringsOfLength: maxLineSize skipLeadingWhitespace: skipLeadingWhitespace 
	| result beginPos pos wholeSize |
	(wholeSize := self size) <= maxLineSize ifTrue: [^Array with: self].
	result := OrderedCollection new.
	beginPos := 1.
	[beginPos <= wholeSize] whileTrue: 
			[skipLeadingWhitespace == true 
				ifTrue: 
					[[beginPos <= wholeSize and: [(self at: beginPos) isSeparator]] 
						whileTrue: [beginPos := beginPos + 1]].
			beginPos > wholeSize 
				ifFalse: 
					[(pos := beginPos + maxLineSize - 1 min: wholeSize) = wholeSize 
						ifFalse: 
							[[(self at: pos) isSeparator not and: [pos > beginPos]] whileTrue: [pos := pos - 1].
							pos <= beginPos ifTrue: [pos := beginPos + maxLineSize - 1 min: wholeSize]].
					result add: (self copyFrom: beginPos to: pos) trimBlanks.
					beginPos := pos + 1]].
	^result!

endsWithUppercase: aString 
	| stringSize j |
	(stringSize := aString size) > self size ifTrue: [^false].
	j := self size - stringSize.
	1 to: stringSize
		do: [:i | (self at: (j := j + 1)) asUppercase = (aString at: i) ifFalse: [^false]].
	^true!

isAllDigits
	^self trimBlanks conform: [:each | each isDigit]!

isAlphabeticalyBefore: aString 
	"Answer <true> if receiver should be alphabeticaly positioned before aString."

	| charOrder minSize p1 p2 translationService app |
	charOrder := ((translationService := #WebTranslationService itcAsClassOrNil) isNil 
				or: [(app := Processor activeProcess webApplication) isNil]) 
					ifTrue: ['AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz']
					ifFalse: [translationService getAlphabeticalCharacterSortOrderForLanguage: app defaultLanguage].
	minSize := self size min: aString size.
	1 to: minSize
		do: 
			[:i | 
			p1 := charOrder indexOf: (self at: i).
			p1 = 0 ifTrue: [p1 := (self at: i) asInteger] ifFalse: [p1 := p1 + 256].
			p2 := charOrder indexOf: (aString at: i).
			p2 = 0 ifTrue: [p2 := (aString at: i) asInteger] ifFalse: [p2 := p2 + 256].
			p1 > p2 ifTrue: [^false].
			p1 < p2 ifTrue: [^true]].
	^self size < aString size!

itcAsInteger
	| negative str value i ch |
	(str := self trimBlanks) isEmpty ifTrue: [^0].
	i := 1.
	(negative := str first = $-) ifTrue: [i := 2] ifFalse: [str first = $+ ifTrue: [i := 2]].
	value := 0.
	[i <= str size and: [(ch := str at: i) isDigit]] whileTrue: 
			[value := value * 10 + (ch asInteger - 48).
			i := i + 1].
	^negative ifTrue: [0 - value] ifFalse: [value]!

itcAsMoneyDecimal
	^self itcAsMoneyDecimalWithPrecision: 2!

itcAsMoneyDecimalWithPrecision: precision 
	| decimalPoint commaIndex pointIndex str |
	str := self trimBlanks select: [:eachCh | '0123456789,.-+ ' includes: eachCh].
	str size = 0 ifTrue: [^nil].
	decimalPoint := $..
	commaIndex := self indexOf: $,.
	pointIndex := self indexOf: $..
	decimalPoint := commaIndex > pointIndex ifTrue: [$,] ifFalse: [$.].
	^ItcConverter 
		getNumberFromString: str
		scale: 20
		precision: precision
		thousandsSeparator: nil
		decimalPoint: decimalPoint!

itcReplaceAllSubstrings: aString1 with: aString2 
	| i pos result |
	pos := 1.
	result := self.
	[(i := result indexOfSubCollection: aString1 startingAt: pos) > 0] whileTrue: 
			[result := (result copyFrom: 1 to: i - 1) , aString2 , (result copyFrom: i + aString1 size).
			pos := i + aString2 size].
	^result!

itcSubStrings: separator 
	separator class == Character 
		ifFalse: 
			[self 
				error: 'This method accepts only single character separators. Use #splitString: for string delimiters.'].
	^self subStrings: separator!

splitString: delimiterString
	| coll str index |
	coll := OrderedCollection new.
	str := self.
	[(index := str indexOfSubCollection: delimiterString) > 0] whileTrue: 
			[index > 1 ifTrue: [coll add: (str copyFrom: 1 to: index - 1)] ifFalse: [coll add: ''].
			str := index + delimiterString size > str size 
						ifTrue: ['']
						ifFalse: [str copyFrom: index + delimiterString size to: str size]].
	coll add: str.
	^coll!

trimByReducingVowelsToSize: maxSize 
	"Answers string trimmed to size maxSize by reducing words like:

		Business -> Busins
		Software -> Sftwr
		Application -> App
	"

	| str pos |
	str := self.
	str size > maxSize 
		ifTrue: 
			["fist try taking all small case vowels away"
			pos := str size.
			[pos > 2 and: [str size > maxSize]] whileTrue: 
					[((str at: pos) isVowel and: [(str at: pos) isLowercase]) 
						ifTrue: 
							[str := (str copyFrom: 1 to: pos - 1) 
										, (pos = str size ifTrue: [''] ifFalse: [str copyFrom: pos + 1 to: str size])].
					pos := pos - 1].

			"then all the vowels except the first letter"
			pos := str size.
			[pos > 2 and: [str size > maxSize]] whileTrue: 
					[(str at: pos) isVowel 
						ifTrue: 
							[str := (str copyFrom: 1 to: pos - 1) 
										, (pos = str size ifTrue: [''] ifFalse: [str copyFrom: pos + 1 to: str size])].
					pos := pos - 1].
			"then if nothing else helps just trim it"
			str := str trimToSize: maxSize].
	^str!

trimOrPadLeftToSize: desiredSize 
	| str |
	self size = desiredSize ifTrue: [^self].
	str := self copyFrom: 1 to: (self size min: desiredSize).
	[str size < desiredSize] whileTrue: [str := ' ' , str].
	^str!

trimOrPadToSize: desiredSize 
	| str |
	self size = desiredSize ifTrue: [^self].
	str := self copyFrom: 1 to: (self size min: desiredSize).
	[str size < desiredSize] whileTrue: [str := str , ' '].
	^str!

trimOrPadToSize: desiredSize using: aCharacter 
	| str |
	self size = desiredSize ifTrue: [^self].
	str := self copyFrom: 1 to: (self size min: desiredSize).
	[str size < desiredSize] whileTrue: [str := str , (String with: aCharacter)].
	^str!

trimOrZeroPadToSize: desiredSize 
	| str |
	self size = desiredSize ifTrue: [^self].
	str := self copyFrom: 1 to: (self size min: desiredSize).
	[str size < desiredSize] whileTrue: [str := '0' , str].
	^str!

trimSeparators
	"Answer a String containing the receiver string with leading and
	 trailing separators removed."

	| start end done |
	(end := self size) == 0 ifTrue: [^self].
	start := 1.
	done := false.
	[(self at: start) isSeparator not or: [done := start == end]] whileFalse: [start := start + 1].
	done ifTrue: [^''].
	[(self at: end) isSeparator not or: [done := start == end]] whileFalse: [end := end - 1].
	^done ifTrue: [''] ifFalse: [self copyFrom: start to: end]!

trimToSize: maxSize 
	^self copyFrom: 1 to: (self size min: maxSize)!

trimToSizeWithDots: maxSize 
	^self size > maxSize ifFalse: [self] ifTrue: [(self copyFrom: 1 to: maxSize - 3) , '...']! !
!String categoriesFor: #add:withDelimiter:!converting!public! !
!String categoriesFor: #asDateFromDDMMYYYYString!public! !
!String categoriesFor: #asDecimalOrFloat!converting!public! !
!String categoriesFor: #asFilenameString!public! !
!String categoriesFor: #asPlainAsciiString!public! !
!String categoriesFor: #asUTF8!converting!public! !
!String categoriesFor: #asUTF8String!converting!public! !
!String categoriesFor: #beginsWithUppercase:!converting!public! !
!String categoriesFor: #breakIntoLinesOfLength:!comparing!public! !
!String categoriesFor: #breakIntoStringsOfLength:!comparing!public! !
!String categoriesFor: #breakIntoStringsOfLength:skipLeadingWhitespace:!comparing!public! !
!String categoriesFor: #endsWithUppercase:!converting!public! !
!String categoriesFor: #isAllDigits!converting!public! !
!String categoriesFor: #isAlphabeticalyBefore:!converting!public! !
!String categoriesFor: #itcAsInteger!converting!public! !
!String categoriesFor: #itcAsMoneyDecimal!converting!public! !
!String categoriesFor: #itcAsMoneyDecimalWithPrecision:!converting!public! !
!String categoriesFor: #itcReplaceAllSubstrings:with:!converting!public! !
!String categoriesFor: #itcSubStrings:!copying!public! !
!String categoriesFor: #splitString:!converting!public! !
!String categoriesFor: #trimByReducingVowelsToSize:!converting!public! !
!String categoriesFor: #trimOrPadLeftToSize:!converting!public! !
!String categoriesFor: #trimOrPadToSize:!converting!public! !
!String categoriesFor: #trimOrPadToSize:using:!converting!public! !
!String categoriesFor: #trimOrZeroPadToSize:!converting!public! !
!String categoriesFor: #trimSeparators!converting!public! !
!String categoriesFor: #trimToSize:!converting!public! !
!String categoriesFor: #trimToSizeWithDots:!converting!public! !

!String class methodsFor!

utf8DecodeFrom: readStream on: writeStream 
	"Izvede UTF-8 dekodiranje iz readStream-a na writeStream. UTF-8 se dekodira v trenutni 8-bitni code page, ki se pobere iz aktivnega procesa."

	| unicode charMap translationService isRuntime |
	isRuntime := ItcSystemManager isRuntime.
	charMap := (translationService := #WebTranslationService itcAsClassOrNil) isNil 
				ifFalse: 
					[translationService 
						getUnicodeIntegerTo8bitCodePageMapForCodePage: Processor activeProcess webRequestCodePage].
	(readStream peek: 3) = #[16rEF 16rBB 16rBF] asString 
		ifTrue: 
			["ignore Unicode String header"
			readStream next: 3].
	[(unicode := self utf8DecodeNextUnicodeFromUtf8Stream: readStream) isNil] whileFalse: 
			[unicode < 128 
				ifTrue: [writeStream nextPut: unicode asCharacter]
				ifFalse: 
					[| ch |
					(charMap isNil or: [(ch := charMap at: unicode ifAbsent: []) isNil]) 
						ifTrue: 
							[(unicode >= 256 and: [isRuntime not]) ifTrue: [self halt].
							writeStream nextPut: (unicode < 256 ifTrue: [unicode asCharacter] ifFalse: [$?])]
						ifFalse: [ch isString ifTrue: [writeStream nextPutAll: ch] ifFalse: [writeStream nextPut: ch]]]]!

utf8DecodeNextUnicodeFromUtf8Stream: aStream 
	"Answer next Unicode characted code from UTF-8 encoded character stream."

	| octet1 octet2 octet3 octet4 |
	aStream atEnd ifTrue: [^nil].
	octet1 := aStream next asInteger.
	octet1 > 127 
		ifFalse: 
			["0zzzzzzz"
			^octet1].
	aStream atEnd ifTrue: [^nil].
	octet2 := aStream next asInteger.
	(octet1 bitAnd: 224) == 192 
		ifTrue: 
			["110yyyyy 10zzzzzz"
			^((octet1 bitAnd: 63) bitShift: 6) bitOr: (octet2 bitAnd: 63)].
	aStream atEnd ifTrue: [^nil].
	octet3 := aStream next asInteger.
	(octet1 bitAnd: 240) == 224 
		ifTrue: 
			["1110xxxx 10yyyyyy 10zzzzzz"
			^(((octet1 bitAnd: 15) bitShift: 12) bitOr: ((octet2 bitAnd: 63) bitShift: 6)) 
				bitOr: (octet3 bitAnd: 63)].
	octet4 := aStream next asInteger.
	"11110www 10xxxxxx 10yyyyyy 10zzzzzz"
	^((octet1 bitAnd: 7) bitShift: 18) bitOr: (((octet2 bitAnd: 63) bitShift: 12) 
				bitOr: (((octet3 bitAnd: 63) bitShift: 6) bitOr: (octet4 bitAnd: 63)))!

utf8EncodeFrom: readStream on: writeStream addMarker: aBoolean 
	"Izvede UTF-8 kodiranje iz readStream-a na writeStream. Trenutni 8-bitni code page pobere iz aktivnega procesa."

	| ch utf charMap translationService |
	charMap := (translationService := #WebTranslationService itcAsClassOrNil) isNil 
				ifFalse: 
					[translationService get8bitToUTF8CodePageMapsForCodePage: Processor activeProcess webRequestCodePage].
	aBoolean ifTrue: [writeStream nextPutAll: #[16rEF 16rBB 16rBF] asString].
	[readStream atEnd] whileFalse: 
			[ch := readStream next.
			ch asInteger > 127 
				ifFalse: [writeStream nextPut: ch]
				ifTrue: 
					[(charMap isNil or: [(utf := charMap at: ch) isNil]) 
						ifTrue: [writeStream nextPut: $ ]
						ifFalse: [writeStream nextPutAll: (self utf8EncodeUnicode: utf)]]]!

utf8EncodeUnicode: unicodeNumber 
	^unicodeNumber > 127 
		ifFalse: [String with: unicodeNumber asCharacter]
		ifTrue: 
			[unicodeNumber > 2047 
				ifFalse: 
					[String with: (192 bitOr: (unicodeNumber bitShift: -6)) asCharacter
						with: (128 bitOr: (unicodeNumber bitAnd: 63)) asCharacter]
				ifTrue: 
					[unicodeNumber > 65535 
						ifFalse: 
							[String 
								with: (224 bitOr: (unicodeNumber bitShift: -12)) asCharacter
								with: (128 bitOr: ((unicodeNumber bitShift: -6) bitAnd: 63)) asCharacter
								with: (128 bitOr: (unicodeNumber bitAnd: 63)) asCharacter]]]! !
!String class categoriesFor: #utf8DecodeFrom:on:!OmniBase!public! !
!String class categoriesFor: #utf8DecodeNextUnicodeFromUtf8Stream:!OmniBase!public! !
!String class categoriesFor: #utf8EncodeFrom:on:addMarker:!OmniBase!public! !
!String class categoriesFor: #utf8EncodeUnicode:!OmniBase!public! !

!Symbol methodsFor!

itcAsClass
	^Smalltalk at: self ifAbsent: [self error: 'Class ' , self asString , ' not loaded']!

itcAsClassOrNil
	^Smalltalk at: self ifAbsent: []! !
!Symbol categoriesFor: #itcAsClass!public!RefactoringBrowser! !
!Symbol categoriesFor: #itcAsClassOrNil!public!RefactoringBrowser! !

!Time methodsFor!

asOdbcString
	| stream |
	stream := WriteStream on: (String new: 16).
	self asOdbcStringOn: stream.
	^stream contents!

asOdbcStringOn: aStream 
	| n |
	(n := self hours) < 10 ifTrue: [aStream nextPut: $0].
	n printOn: aStream.
	aStream nextPut: $:.
	(n := self minutes) < 10 ifTrue: [aStream nextPut: $0].
	n printOn: aStream.
	aStream nextPut: $:.
	(n := self seconds) < 10 ifTrue: [aStream nextPut: $0].
	n printOn: aStream! !
!Time categoriesFor: #asOdbcString!public! !
!Time categoriesFor: #asOdbcStringOn:!public! !

!Time class methodsFor!

hours: hours minutes: minutes seconds: seconds milliseconds: msecs

	^self basicNew setMilliseconds: (hours * 3600000) + (minutes * 60000) + (seconds * 1000) + msecs! !
!Time class categoriesFor: #hours:minutes:seconds:milliseconds:!instance creation!public! !

!TimeStamp methodsFor!

asFilenameString

	| stream |
	stream := WriteStream on: (String new: 20).
	stream
		nextPutAll: (self date year asLeadingZerosStringOfSize: 4);
		nextPutAll: (self date monthIndex asLeadingZerosStringOfSize: 2);
		nextPutAll: (self date dayOfMonth asLeadingZerosStringOfSize: 2);
		nextPut: $-;
		nextPutAll: (self time hours asLeadingZerosStringOfSize: 2);
		nextPutAll: (self time minutes asLeadingZerosStringOfSize: 2);
		nextPutAll: (self time seconds asLeadingZerosStringOfSize: 2);
		nextPut: $-;
		nextPutAll: ((self time asMilliseconds \\ 1000) asLeadingZerosStringOfSize: 3).
	^stream contents!

asOdbcStringOn: aStream 
	date asOdbcStringOn: aStream.
	aStream nextPut: $ .
	time asOdbcStringOn: aStream!

asOdbcStringWithMicrosOn: aStream 
	| micros |
	date asOdbcStringOn: aStream.
	aStream nextPut: $ .
	time asOdbcStringOn: aStream.
	micros := (time asMilliseconds \\ 1000 * 1000) printString.
	aStream
		nextPut: $.;
		nextPutAll: ('000000' copy 
					replaceFrom: 7 - micros size
					to: 6
					with: micros
					startingAt: 1)!

totalSeconds
	^self asSeconds! !
!TimeStamp categoriesFor: #asFilenameString!printing!public! !
!TimeStamp categoriesFor: #asOdbcStringOn:!printing!public! !
!TimeStamp categoriesFor: #asOdbcStringWithMicrosOn:!printing!public! !
!TimeStamp categoriesFor: #totalSeconds!public! !

!UndefinedObject methodsFor!

-~ aNumber 
	^aNumber isNil ifFalse: [0 - aNumber]!

+~ aNumber 
	^aNumber!

add: aString withDelimiter: delimiter 
	"Metoda spoji dva stringa z delimiterjem.
	Ce je katerikoli od stringov nil ali prazen se delimiter ne uporabi.
	Metoda vrne string, razen v primeru, ko je receiver prazen, aString pa nil."

	^aString isNilOrEmpty ifFalse: [aString] ifTrue: ['']!

asString
	^''!

isNilOrEmpty
	^true! !
!UndefinedObject categoriesFor: #-~!public! !
!UndefinedObject categoriesFor: #+~!public! !
!UndefinedObject categoriesFor: #add:withDelimiter:!control flow!public! !
!UndefinedObject categoriesFor: #asString!public! !
!UndefinedObject categoriesFor: #isNilOrEmpty!public! !

"End of package definition"!

