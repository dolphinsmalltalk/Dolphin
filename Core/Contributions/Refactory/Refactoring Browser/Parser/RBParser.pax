| package |
package := Package name: 'RBParser'.
package paxVersion: 2.1;
	environmentName: #{Refactory.Browser};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin RBParser Package
Copyright John Brant and Don Roberts.

This package aliases most of the RBParser classes to the Dolphin equivalents which are then used instead. RB specific classes, such as the search/replace rules are hosted directly in this package.

Should be used in place of the full RBParser package, which contains the ''...parser for the Refactoring Browser. It contains both the ability to parse Smalltalk and also to rewrite Smalltalk code. The refactorings use this rewriting behavior to perform the source code transformations.'''.


package setClassNames: #(
	#{Refactory.Browser.ParseTreeRewriter}
	#{Refactory.Browser.ParseTreeSearcher}
	#{Refactory.Browser.PatternBlockToken}
	#{Refactory.Browser.RBBindingReference}
	#{Refactory.Browser.RBBlockReplaceRule}
	#{Refactory.Browser.RBParser}
	#{Refactory.Browser.RBParseTreeRule}
	#{Refactory.Browser.RBPatternAnnotationNode}
	#{Refactory.Browser.RBPatternBlockNode}
	#{Refactory.Browser.RBPatternMessageNode}
	#{Refactory.Browser.RBPatternMethodNode}
	#{Refactory.Browser.RBPatternParser}
	#{Refactory.Browser.RBPatternScanner}
	#{Refactory.Browser.RBPatternVariableNode}
	#{Refactory.Browser.RBPatternWrapperBlockNode}
	#{Refactory.Browser.RBQualifiedReferenceNode}
	#{Refactory.Browser.RBReplaceRule}
	#{Refactory.Browser.RBSearchRule}
	#{Refactory.Browser.RBSmallDictionary}
	#{Refactory.Browser.RBStringReplacement}
	#{Refactory.Browser.RBStringReplaceRule}
).

package setMethodNames: #(
	#(#{Kernel.AbstractLiteralArrayNode} #match:inContext:)
	#(#{Kernel.AbstractLiteralArrayNode} #replaceNode:withNode:)
	#(#{Kernel.CompileFailedMethod} #refersToVariable:)
	#(#{Kernel.ParseNodeVisitor} #visitPatternBlockNode:)
	#(#{Kernel.ParseNodeVisitor} #visitPatternWrapperBlockNode:)
	#(#{Kernel.Scanner} #scanPatternVariable)
	#(#{Kernel.StAnnotationNode} #copyInContext:)
	#(#{Kernel.StAnnotationNode} #equalTo:withMapping:)
	#(#{Kernel.StAnnotationNode} #match:inContext:)
	#(#{Kernel.StAnnotationNode} #matchArgumentsAgainst:inContext:)
	#(#{Kernel.StAnnotationNode} #replaceNode:withNode:)
	#(#{Kernel.StAssignmentNode} #copyInContext:)
	#(#{Kernel.StAssignmentNode} #equalTo:withMapping:)
	#(#{Kernel.StAssignmentNode} #match:inContext:)
	#(#{Kernel.StAssignmentNode} #replaceNode:withNode:)
	#(#{Kernel.StAssignmentNode} #replaceSourceWith:)
	#(#{Kernel.StBlockNode} #copyInContext:)
	#(#{Kernel.StBlockNode} #equalTo:withMapping:)
	#(#{Kernel.StBlockNode} #match:inContext:)
	#(#{Kernel.StBlockNode} #references:)
	#(#{Kernel.StBlockNode} #replaceNode:withNode:)
	#(#{Kernel.StBraceArrayNode} #addNode:)
	#(#{Kernel.StBraceArrayNode} #addNode:before:)
	#(#{Kernel.StBraceArrayNode} #addNodeFirst:)
	#(#{Kernel.StBraceArrayNode} #addNodes:)
	#(#{Kernel.StBraceArrayNode} #addNodes:before:)
	#(#{Kernel.StBraceArrayNode} #addNodesFirst:)
	#(#{Kernel.StBraceArrayNode} #copyInContext:)
	#(#{Kernel.StBraceArrayNode} #equalTo:withMapping:)
	#(#{Kernel.StBraceArrayNode} #indexOfNode:)
	#(#{Kernel.StBraceArrayNode} #match:inContext:)
	#(#{Kernel.StBraceArrayNode} #references:)
	#(#{Kernel.StBraceArrayNode} #replaceNode:withNode:)
	#(#{Kernel.StCascadeNode} #copyInContext:)
	#(#{Kernel.StCascadeNode} #equalTo:withMapping:)
	#(#{Kernel.StCascadeNode} #match:inContext:)
	#(#{Kernel.StCascadeNode} #replaceNode:withNode:)
	#(#{Kernel.StExternalCallNode} #copyInContext:)
	#(#{Kernel.StExternalCallNode} #replaceNode:withNode:)
	#(#{Kernel.StIdentifierToken} #isPatternVariable)
	#(#{Kernel.StKeywordToken} #isPatternVariable)
	#(#{Kernel.StLiteralNode} #replaceSourceFrom:)
	#(#{Kernel.StLiteralNode} #replaceSourceWith:)
	#(#{Kernel.StLiteralValueNode} #copyInContext:)
	#(#{Kernel.StMessageNode} #copyInContext:)
	#(#{Kernel.StMessageNode} #equalTo:withMapping:)
	#(#{Kernel.StMessageNode} #isContainmentReplacement:)
	#(#{Kernel.StMessageNode} #match:inContext:)
	#(#{Kernel.StMessageNode} #replaceContainmentSourceWith:)
	#(#{Kernel.StMessageNode} #replaceNode:withNode:)
	#(#{Kernel.StMessageNode} #replaceSourceWith:)
	#(#{Kernel.StMessageNode} #replaceSourceWithMessageNode:)
	#(#{Kernel.StMethodNode} #addNode:)
	#(#{Kernel.StMethodNode} #addReplacement:)
	#(#{Kernel.StMethodNode} #addReturn)
	#(#{Kernel.StMethodNode} #addSelfReturn)
	#(#{Kernel.StMethodNode} #changeSourceSelectors:arguments:)
	#(#{Kernel.StMethodNode} #clearReplacements)
	#(#{Kernel.StMethodNode} #copyInContext:)
	#(#{Kernel.StMethodNode} #equalTo:withMapping:)
	#(#{Kernel.StMethodNode} #initialize)
	#(#{Kernel.StMethodNode} #map:to:)
	#(#{Kernel.StMethodNode} #mappingFor:)
	#(#{Kernel.StMethodNode} #match:inContext:)
	#(#{Kernel.StMethodNode} #matchTagsAgainst:inContext:)
	#(#{Kernel.StMethodNode} #newSource)
	#(#{Kernel.StMethodNode} #references:)
	#(#{Kernel.StMethodNode} #reformatSource)
	#(#{Kernel.StMethodNode} #renameSelector:andArguments:)
	#(#{Kernel.StMethodNode} #replaceNode:withNode:)
	#(#{Kernel.StOptimizedNode} #copyInContext:)
	#(#{Kernel.StOptimizedNode} #equalTo:withMapping:)
	#(#{Kernel.StOptimizedNode} #match:inContext:)
	#(#{Kernel.StOptimizedNode} #replaceNode:withNode:)
	#(#{Kernel.StPrimitiveNode} #copyInContext:)
	#(#{Kernel.StPrimitiveNode} #equalTo:withMapping:)
	#(#{Kernel.StPrimitiveNode} #replaceNode:withNode:)
	#(#{Kernel.StProgramNode} #addReplacement:)
	#(#{Kernel.StProgramNode} #asReturn)
	#(#{Kernel.StProgramNode} #clearReplacements)
	#(#{Kernel.StProgramNode} #copyInContext:)
	#(#{Kernel.StProgramNode} #copyList:inContext:)
	#(#{Kernel.StProgramNode} #equalTo:withMapping:)
	#(#{Kernel.StProgramNode} #isPatternNode)
	#(#{Kernel.StProgramNode} #mappingFor:)
	#(#{Kernel.StProgramNode} #match:inContext:)
	#(#{Kernel.StProgramNode} #matchList:against:inContext:)
	#(#{Kernel.StProgramNode} #matchList:index:against:index:inContext:)
	#(#{Kernel.StProgramNode} #references:)
	#(#{Kernel.StProgramNode} #removeDeadCode)
	#(#{Kernel.StProgramNode} #replaceMethodSource:)
	#(#{Kernel.StProgramNode} #replaceNode:withNode:)
	#(#{Kernel.StProgramNode} #replaceSourceFrom:)
	#(#{Kernel.StProgramNode} #replaceSourceWith:)
	#(#{Kernel.StProgramNode} #replaceWith:)
	#(#{Kernel.StProgramNode} #selfMessages)
	#(#{Kernel.StProgramNode} #superMessages)
	#(#{Kernel.StQualifiedReferenceNode} #clearPositions)
	#(#{Kernel.StReturnNode} #copyInContext:)
	#(#{Kernel.StReturnNode} #equalTo:withMapping:)
	#(#{Kernel.StReturnNode} #match:inContext:)
	#(#{Kernel.StReturnNode} #replaceNode:withNode:)
	#(#{Kernel.StSequenceNode} #addNode:)
	#(#{Kernel.StSequenceNode} #addNode:before:)
	#(#{Kernel.StSequenceNode} #addNodeFirst:)
	#(#{Kernel.StSequenceNode} #addNodes:)
	#(#{Kernel.StSequenceNode} #addNodes:before:)
	#(#{Kernel.StSequenceNode} #addNodesFirst:)
	#(#{Kernel.StSequenceNode} #addReturn)
	#(#{Kernel.StSequenceNode} #addSelfReturn)
	#(#{Kernel.StSequenceNode} #addTemporariesNamed:)
	#(#{Kernel.StSequenceNode} #addTemporaryNamed:)
	#(#{Kernel.StSequenceNode} #copyInContext:)
	#(#{Kernel.StSequenceNode} #equalTo:withMapping:)
	#(#{Kernel.StSequenceNode} #indexOfNode:)
	#(#{Kernel.StSequenceNode} #match:inContext:)
	#(#{Kernel.StSequenceNode} #references:)
	#(#{Kernel.StSequenceNode} #removeDeadCode)
	#(#{Kernel.StSequenceNode} #removeNode:)
	#(#{Kernel.StSequenceNode} #removeTemporaryNamed:)
	#(#{Kernel.StSequenceNode} #replaceNode:withNode:)
	#(#{Kernel.StSequenceNode} #replaceNode:withNodes:)
	#(#{Kernel.StSpecialVariableNode} #copyInContext:)
	#(#{Kernel.StToken} #isPatternVariable)
	#(#{Kernel.StValueNode} #clearPositions)
	#(#{Kernel.StVariableNode} #clearPositions)
	#(#{Kernel.StVariableNode} #copyInContext:)
	#(#{Kernel.StVariableNode} #equalTo:withMapping:)
	#(#{Kernel.StVariableNode} #references:)
	#(#{Kernel.StVariableNode} #replaceSourceFrom:)
	#(#{Kernel.StVariableNode} #replaceSourceWith:)
	#(#{Refactory.Browser.RBConfigurableFormatter} #visitPatternWrapperBlockNode:)
	#(#{Refactory.Browser.RBFormatter} #visitPatternWrapperBlockNode:)
).

package setPrerequisites: #(
	'..\..\..\..\Object Arts\Dolphin\Base\Dolphin'
	'..\Formatters\RBFormatters'
	'..\..\RBNamespaces'
	'..\..\..\..\Object Arts\Dolphin\System\Compiler\Smalltalk Parser'
).

package setManualPrerequisites: #(
	'Smalltalk Parser'
).

package!

"Class Definitions"!

Core.Object
	subclass: #'Refactory.Browser.RBParseTreeRule'
	instanceVariableNames: 'searchTree owner'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object
	subclass: #'Refactory.Browser.RBStringReplacement'
	instanceVariableNames: 'startPosition stopPosition string'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.BindingReferenceWrapper
	subclass: #'Refactory.Browser.RBBindingReference'
	instanceVariableNames: 'model'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Collection
	subclass: #'Refactory.Browser.RBSmallDictionary'
	instanceVariableNames: 'keys values size'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.ParseNodeVisitor
	subclass: #'Refactory.Browser.ParseTreeSearcher'
	instanceVariableNames: 'searches answer argumentSearches context messages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ParseTreeSearcher
	subclass: #'Refactory.Browser.ParseTreeRewriter'
	instanceVariableNames: 'tree'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.Parser
	subclass: #'Refactory.Browser.RBParser'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.Parser
	subclass: #'Refactory.Browser.RBPatternParser'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBParseTreeRule
	subclass: #'Refactory.Browser.RBReplaceRule'
	instanceVariableNames: 'verificationBlock'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBParseTreeRule
	subclass: #'Refactory.Browser.RBSearchRule'
	instanceVariableNames: 'answerBlock'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBReplaceRule
	subclass: #'Refactory.Browser.RBBlockReplaceRule'
	instanceVariableNames: 'replaceBlock'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBReplaceRule
	subclass: #'Refactory.Browser.RBStringReplaceRule'
	instanceVariableNames: 'replaceTree'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.Scanner
	subclass: #'Refactory.Browser.RBPatternScanner'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: { 'CascadeCharacter' -> $;. 'ListCharacter' -> $@. 'VariableCharacter' -> $` }!
Kernel.StMethodNode
	subclass: #'Refactory.Browser.RBPatternMethodNode'
	instanceVariableNames: 'isList'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StAnnotationNode
	subclass: #'Refactory.Browser.RBPatternAnnotationNode'
	instanceVariableNames: 'isList'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StBlockNode
	subclass: #'Refactory.Browser.RBPatternBlockNode'
	instanceVariableNames: 'valueBlock'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBPatternBlockNode
	subclass: #'Refactory.Browser.RBPatternWrapperBlockNode'
	instanceVariableNames: 'wrappedNode'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StQualifiedReferenceNode
	subclass: #'Refactory.Browser.RBQualifiedReferenceNode'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StMessageNode
	subclass: #'Refactory.Browser.RBPatternMessageNode'
	instanceVariableNames: 'isList isCascadeList'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StRealVariableNode
	subclass: #'Refactory.Browser.RBPatternVariableNode'
	instanceVariableNames: 'recurseInto isList isLiteral isStatement isAnything'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StValueToken
	subclass: #'Refactory.Browser.PatternBlockToken'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Kernel.AbstractLiteralArrayNode methodsFor!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^self 
		matchList: contents
		against: aNode contents
		inContext: aDictionary!

replaceNode: aNode withNode: anotherNode 
	self contents: (contents 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.AbstractLiteralArrayNode categoriesForMethods!
match:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.CompileFailedMethod methodsFor!

refersToVariable: aString
	| tree searcher |
	tree := self parseTreeNoError.
	(tree isNil or: [(tree defines: aString) or: [tree body defines: aString]]) ifTrue: [^false].
	searcher := ParseTreeSearcher new.
	searcher
		matches: aString do: [:node :answer | true];
		matches: '[:`@vars | | `@temps | `@.Stmts]'
			do: 
				[:node :answer |
				answer or: 
						[((node defines: aString) or: [node body defines: aString]) not
							and: [searcher executeTree: node body initialAnswer: false]]].
	^searcher executeTree: self parseTree initialAnswer: false! !
!Kernel.CompileFailedMethod categoriesForMethods!
refersToVariable:!development!private!testing! !
!

!Kernel.ParseNodeVisitor methodsFor!

visitPatternBlockNode: aRBPatternBlockNode
	self visitArgumentNodes: aRBPatternBlockNode arguments.
	self visitNode: aRBPatternBlockNode body.
	^aRBPatternBlockNode!

visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self visitArgumentNodes: aRBPatternWrapperBlockNode arguments.
	self visitNode: aRBPatternWrapperBlockNode body.
	^aRBPatternWrapperBlockNode! !
!Kernel.ParseNodeVisitor categoriesForMethods!
visitPatternBlockNode:!public!visiting! !
visitPatternWrapperBlockNode:!public!visiting! !
!

!Kernel.Scanner methodsFor!

scanPatternVariable
	buffer nextPut: currentCharacter.
	self step.
	currentCharacter == ${
		ifTrue: 
			[self step.
			^PatternBlockToken
				start: tokenStart
				comments: nil
				value: '`{'].
	[characterType == #alphabetic] whileFalse: 
			[characterType == #eof ifTrue: [^self metaVariableExpected].
			buffer nextPut: currentCharacter.
			self step].
	^self scanIdentifierOrKeyword! !
!Kernel.Scanner categoriesForMethods!
scanPatternVariable!private!scanning! !
!

!Kernel.StAnnotationNode methodsFor!

copyInContext: aDictionary
	^self class selector: selector
		arguments: (arguments collect: [:each | each copyInContext: aDictionary])!

equalTo: anObject withMapping: aDictionary
	| otherArgs count |
	self class == anObject class ifFalse: [^false].
	selector == anObject selector ifFalse: [^false].
	count := arguments size.
	count == anObject arguments size ifFalse: [^false].
	otherArgs := anObject arguments.
	1 to: count
		do: [:i | ((arguments at: i) equalTo: (otherArgs at: i) withMapping: aDictionary) ifFalse: [^false]].
	^true!

match: aNode inContext: aDictionary
	aNode class == self class ifFalse: [^false].
	selector == aNode selector ifFalse: [^false].
	^self matchArgumentsAgainst: aNode inContext: aDictionary!

matchArgumentsAgainst: aNode inContext: aDictionary
	| otherArgs count |
	(count := arguments size) == (otherArgs := aNode arguments) size ifFalse: [^false].
	1 to: count
		do: [:i | ((arguments at: i) match: (otherArgs at: i) inContext: aDictionary) ifFalse: [^false]].
	^true!

replaceNode: aNode withNode: anotherNode
	self arguments: (arguments collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StAnnotationNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!public! !
match:inContext:!matching!public! !
matchArgumentsAgainst:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StAssignmentNode methodsFor!

copyInContext: aDictionary 
	^(self class new)
		variable: (variable copyInContext: aDictionary);
		value: (value copyInContext: aDictionary);
		yourself!

equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(self variable equalTo: anObject variable withMapping: aDictionary) 
				and: [self value equalTo: anObject value withMapping: aDictionary]]!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^(variable match: aNode variable inContext: aDictionary)
		and: [value match: aNode value inContext: aDictionary]!

replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode].
	variable == aNode ifTrue: [self variable: anotherNode]!

replaceSourceWith: aNode
	"Check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."

	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].
	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].
	(self mappingFor: self value) = aNode arguments first ifFalse: [^super replaceSourceWith: aNode].
	(self value hasParentheses not and: [aNode arguments first precedence >= aNode precedence])
		ifTrue: 
			[self
				addReplacement: (RBStringReplacement
							replaceFrom: self value start
							to: self value start - 1
							with: '(');
				addReplacement: (RBStringReplacement
							replaceFrom: self value stop + 1
							to: self value stop
							with: ')')].
	self addReplacement: (RBStringReplacement
				replaceFrom: self variable start
				to: self assignmentPosition + 1
				with: aNode receiver name , ' ' , aNode selector)! !
!Kernel.StAssignmentNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
match:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
replaceSourceWith:!public!replacing! !
!

!Kernel.StBlockNode methodsFor!

copyInContext: aDictionary 
	^(self class new)
		arguments: (self copyList: arguments inContext: aDictionary);
		body: (body copyInContext: aDictionary);
		yourself!

equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	(self body equalTo: anObject body withMapping: aDictionary)
		ifFalse: [^false].
	self arguments do: [:each | aDictionary removeKey: each name].
	^true!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^(self 
		matchList: arguments
		against: aNode arguments
		inContext: aDictionary) 
			and: [body match: aNode body inContext: aDictionary]!

references: aVariableName 
	^body references: aVariableName!

replaceNode: aNode withNode: anotherNode 
	body == aNode ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StBlockNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
match:inContext:!matching!public! !
references:!public!testing! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StBraceArrayNode methodsFor!

addNode: aNode
	statements := statements asOrderedCollection
				add: aNode;
				yourself.
	aNode parent: self.
	^aNode!

addNode: aNode before: anotherNode
	| index |
	aNode isReturn ifTrue: [self error: 'Cannot add return node'].
	index := self indexOfNode: anotherNode.
	index == 0 ifTrue: [^self addNode: aNode].
	statements := statements asOrderedCollection
				add: aNode beforeIndex: index;
				yourself.
	aNode parent: self.
	^aNode!

addNodeFirst: aNode
	statements := statements asOrderedCollection
				addFirst: aNode;
				yourself.
	aNode parent: self.
	^aNode!

addNodes: aCollection
	statements := statements asOrderedCollection
				addAll: aCollection;
				yourself.
	aCollection do: [:each | each parent: self].
	^aCollection!

addNodes: aCollection before: anotherNode
	aCollection do: [:each | self addNode: each before: anotherNode].
	^aCollection!

addNodesFirst: aCollection
	statements := statements asOrderedCollection
				addAllFirst: aCollection;
				yourself.
	aCollection do: [:each | each parent: self].
	^aCollection!

copyInContext: aDictionary
	^self class statements: (self copyList: statements inContext: aDictionary)!

equalTo: anObject withMapping: aDictionary
	self class = anObject class ifFalse: [^false].
	self statements size = anObject statements size ifFalse: [^false].
	self statements with: anObject statements
		do: [:first :second | (first equalTo: second withMapping: aDictionary) ifFalse: [^false]].
	aDictionary values asSet size = aDictionary size ifFalse: [^false].
	^true!

indexOfNode: aNode
	"Try to find the node by first looking for ==, and then for ="

	| index |
	(index := statements identityIndexOf: aNode) == 0 ifTrue: [index := statements indexOf: aNode].
	^index!

match: aNode inContext: aDictionary
	aNode class = self class ifFalse: [^false].
	^self
		matchList: statements
		against: aNode statements
		inContext: aDictionary!

references: aVariableName 
	^statements anySatisfy: [:each | each references: aVariableName]!

replaceNode: aNode withNode: anotherNode
	self statements: (statements collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StBraceArrayNode categoriesForMethods!
addNode:!adding nodes!public! !
addNode:before:!adding nodes!public! !
addNodeFirst:!adding nodes!public! !
addNodes:!adding nodes!public! !
addNodes:before:!adding nodes!public! !
addNodesFirst:!adding nodes!public! !
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
indexOfNode:!helpers!private! !
match:inContext:!matching!public! !
references:!public!testing! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StCascadeNode methodsFor!

copyInContext: aDictionary 
	^(self class new)
		messages: (self copyList: messages inContext: aDictionary);
		yourself!

equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self messages size == anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: 
			[:i | 
			((self messages at: i) equalTo: (anObject messages at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^self 
		matchList: messages
		against: aNode messages
		inContext: aDictionary!

replaceNode: aNode withNode: anotherNode 
	self messages: (messages 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StCascadeNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
match:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StExternalCallNode methodsFor!

copyInContext: aDictionary
	^self class new
		nameOrOrdinal: nameOrOrdinal;
		returnType: (returnType copyInContext: aDictionary);
		argumentTypes: (argumentTypes collect: [:each | each copyInContext: aDictionary]);
		flags: flags;
		callingConvention: callingConvention;
		yourself!

replaceNode: aNode withNode: anotherNode
	returnType == aNode
		ifTrue: 
			[self returnType: anotherNode.
			^self].
	self
		argumentTypes: (argumentTypes collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StExternalCallNode categoriesForMethods!
copyInContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StIdentifierToken methodsFor!

isPatternVariable
	^(value at: 1) == RBPatternScanner.VariableCharacter! !
!Kernel.StIdentifierToken categoriesForMethods!
isPatternVariable!public!testing! !
!

!Kernel.StKeywordToken methodsFor!

isPatternVariable
	^(value at: 1) == RBPatternScanner.VariableCharacter! !
!Kernel.StKeywordToken categoriesForMethods!
isPatternVariable!public!testing! !
!

!Kernel.StLiteralNode methodsFor!

replaceSourceFrom: aNode
	self addReplacement: (RBStringReplacement
				replaceFrom: aNode start
				to: aNode stop
				with: self formattedCode)!

replaceSourceWith: aNode
	self addReplacement: (RBStringReplacement
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)! !
!Kernel.StLiteralNode categoriesForMethods!
replaceSourceFrom:!private!replacing! !
replaceSourceWith:!private!replacing! !
!

!Kernel.StLiteralValueNode methodsFor!

copyInContext: aDictionary
	^self class literalToken: token removePositions! !
!Kernel.StLiteralValueNode categoriesForMethods!
copyInContext:!matching!public! !
!

!Kernel.StMessageNode methodsFor!

copyInContext: aDictionary 
	^(self class new)
		receiver: (receiver copyInContext: aDictionary);
		selectorParts: (selectorParts collect: [:each | each removePositions]);
		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);
		yourself!

equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	((self receiver equalTo: anObject receiver withMapping: aDictionary)
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true!

isContainmentReplacement: aNode 
	^(self mappingFor: self receiver) = aNode 
		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]!

match: aNode inContext: aDictionary
	| count otherArgs |
	aNode class == self class ifFalse: [^false].
	self selector == aNode selector ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	otherArgs := aNode arguments.
	count := arguments size.
	count == otherArgs size ifFalse: [^false].
	1 to: count
		do: [:i | ((arguments at: i) match: (otherArgs at: i) inContext: aDictionary) ifFalse: [^false]].
	^true!

replaceContainmentSourceWith: aNode
	| originalNode needsParenthesis |
	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].
	originalNode := (self mappingFor: self receiver) = aNode
				ifTrue: [self receiver]
				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].
	self
		addReplacement: (RBStringReplacement
					replaceFrom: self start
					to: originalNode start - 1
					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));
		addReplacement: (RBStringReplacement
					replaceFrom: originalNode stop + 1
					to: self stop
					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))!

replaceNode: aNode withNode: anotherNode 
	"If we're inside a cascade node and are changing the receiver, change all the receivers"

	receiver == aNode 
		ifTrue: 
			[self receiver: anotherNode.
			(parent notNil and: [parent isCascade]) 
				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])!

replaceSourceWith: aNode 
	(self isContainmentReplacement: aNode) 
		ifTrue: [^self replaceContainmentSourceWith: aNode].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	^self replaceSourceWithMessageNode: aNode!

replaceSourceWithMessageNode: aNode
	| isBinaryToKeyword |
	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].
	(self mappingFor: self receiver) = aNode receiver ifFalse: [^super replaceSourceWith: aNode].
	self arguments with: aNode arguments
		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].
	(isBinaryToKeyword := self isBinary and: [aNode isKeyword])
		ifTrue: 
			[(self hasParentheses not and: [self parent precedence <= aNode precedence])
				ifTrue: 
					[self
						addReplacement: (RBStringReplacement
									replaceFrom: self start
									to: self start - 1
									with: '(');
						addReplacement: (RBStringReplacement
									replaceFrom: self stop + 1
									to: self stop
									with: ')')]].
	self selectorParts with: aNode selectorParts
		do: 
			[:old :new |
			old value ~= new value
				ifTrue: 
					[self addReplacement: (RBStringReplacement
								replaceFrom: old start
								to: old stop
								with: ((isBinaryToKeyword and: [(self source at: old start - 1) isSeparator not])
										ifTrue: [' ' , new value]
										ifFalse: [new value]))]]! !
!Kernel.StMessageNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
isContainmentReplacement:!private!replacing! !
match:inContext:!matching!public! !
replaceContainmentSourceWith:!private!replacing! !
replaceNode:withNode:!public!replacing! !
replaceSourceWith:!private!replacing! !
replaceSourceWithMessageNode:!private!replacing! !
!

!Kernel.StMethodNode methodsFor!

addNode: aNode 
	^body addNode: aNode!

addReplacement: aStringReplacement 
	replacements isNil ifTrue: [^self].
	replacements add: aStringReplacement!

addReturn
	body addReturn!

addSelfReturn
	^body addSelfReturn!

changeSourceSelectors: oldSelectorParts arguments: oldArguments
	
	[oldSelectorParts size = selectorParts size ifFalse: [^self].
	oldArguments size = arguments size ifFalse: [^self].
	oldSelectorParts with: selectorParts
		do: 
			[:old :new |
			self addReplacement: (RBStringReplacement
						replaceFrom: old start
						to: old stop
						with: new value)].
	oldArguments with: arguments
		do: 
			[:old :new |
			self addReplacement: (RBStringReplacement
						replaceFrom: old start
						to: old stop
						with: new value)]]
			on: Error
			do: [:ex | ex return]!

clearReplacements
	replacements := nil!

copyInContext: aDictionary
	^self class new
		selectorParts: (selectorParts collect: [:each | each removePositions]);
		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);
		tags: (self tags isEmpty
					ifTrue: [(aDictionary at: '-tags-' ifAbsent: #()) collect: [:each | each copy]]
					ifFalse: [self copyList: tags inContext: aDictionary]);
		body: (body copyInContext: aDictionary);
		source: (aDictionary at: '-source-' ifAbsentPut: [self source]);
		methodClass: methodClass environment: environment;
		yourself!

equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	(self selector = anObject selector 
		and: [self body equalTo: anObject body withMapping: aDictionary]) 
			ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false].
			aDictionary removeKey: (self arguments at: i) name].
	^self tags = anObject tags!

initialize
	replacements := SortedCollection sortBlock: 
					[:a :b |
					a startPosition < b startPosition
						or: [a startPosition = b startPosition and: [a stopPosition < b stopPosition]]]!

map: oldNode to: newNode
	(nodeReplacements
		ifNil: 
			[nodeReplacements := IdentityDictionary new.
			nodeReplacements]) at: oldNode
			put: newNode!

mappingFor: oldNode
	^nodeReplacements ifNil: [oldNode] ifNotNil: [nodeReplacements at: oldNode ifAbsent: [oldNode]]!

match: aNode inContext: aDictionary
	self class == aNode class ifFalse: [^false].
	aDictionary at: '-source-' put: aNode source.
	self selector == aNode selector ifFalse: [^false].
	^(self
		matchList: arguments
		against: aNode arguments
		inContext: aDictionary) and: 
				[(self matchTagsAgainst: aNode inContext: aDictionary)
					and: [body match: aNode body inContext: aDictionary]]!

matchTagsAgainst: aStMethodNode inContext: aDictionary
	| otherTags |
	otherTags := aStMethodNode tags.
	self tags isEmpty
		ifTrue: 
			[aDictionary at: '-tags-' put: otherTags.
			^true].
	^tags
		allSatisfy: [:matchNode | otherTags anySatisfy: [:tagNode | matchNode match: tagNode inContext: aDictionary]]!

newSource
	replacements isNil ifTrue: [^self formattedCode].
	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]!

references: aVariableName 
	^body references: aVariableName!

reformatSource
	| newSource stream |
	stream := WriteStream on: (Utf8String new: source size + 100).
	stream
		nextPutAll: (source copyFrom: (replacements inject: 1
						into: 
							[:sum :each |
							stream
								nextPutAll: (source copyFrom: sum to: each startPosition - 1);
								nextPutAll: each string.
							each stopPosition + 1])
				to: source size).
	newSource := stream contents.
	self = (Parser parseMethod: newSource onError: [:s :p | ^self formattedCode])
		ifFalse: [^self formattedCode].	"Sanity check -- make sure the formatted code is = self"
	^newSource!

renameSelector: newSelector andArguments: varNodeCollection 
	| oldSelectorParts oldArguments |
	oldSelectorParts := selectorParts.
	oldArguments := arguments.
	self
		arguments: varNodeCollection;
		selector: newSelector.
	self changeSourceSelectors: oldSelectorParts arguments: oldArguments!

replaceNode: aNode withNode: anotherNode
	aNode == body
		ifTrue: 
			[self body: anotherNode.
			^self].
	self arguments: (arguments collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !
!Kernel.StMethodNode categoriesForMethods!
addNode:!accessing!public! !
addReplacement:!public!replacing! !
addReturn!accessing!public! !
addSelfReturn!accessing!public! !
changeSourceSelectors:arguments:!private!replacing! !
clearReplacements!public!replacing! !
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
initialize!initializing!public! !
map:to:!public!replacing! !
mappingFor:!public!replacing! !
match:inContext:!matching!public! !
matchTagsAgainst:inContext:!matching!private! !
newSource!accessing!public! !
references:!public!testing! !
reformatSource!operations!private! !
renameSelector:andArguments:!accessing!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StOptimizedNode methodsFor!

copyInContext: aDictionary 
	^self class body: (body copyInContext: aDictionary)!

equalTo: anObject withMapping: aDictionary 
	^self class = anObject class 
		and: [self body equalTo: anObject body withMapping: aDictionary]!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^body match: aNode body inContext: aDictionary!

replaceNode: aNode withNode: anotherNode 
	body == aNode ifTrue: [self body: anotherNode]! !
!Kernel.StOptimizedNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
match:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StPrimitiveNode methodsFor!

copyInContext: aDictionary
	| copy |
	copy := self class primitiveIndex: primitiveIndex.
	errorTemp ifNotNil: [copy errorTemp: (errorTemp copyInContext: aDictionary)].
	^copy!

equalTo: anObject withMapping: aDictionary
	self class == anObject class ifFalse: [^false].
	primitiveIndex == anObject primitiveIndex ifFalse: [^false].
	^(errorTemp isNil
		ifTrue: [anObject errorTemp isNil]
		ifFalse: [errorTemp equalTo: anObject errorTemp withMapping: aDictionary]) ifFalse: [^false]!

replaceNode: aNode withNode: anotherNode
	errorTemp == aNode ifTrue: [self errorTemp: anotherNode]! !
!Kernel.StPrimitiveNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StProgramNode methodsFor!

addReplacement: aStringReplacement
	parent isNil ifTrue: [^self].
	parent addReplacement: aStringReplacement!

asReturn
	"Change the current node to a return node."

	parent isNil 
		ifTrue: [self error: 'Cannot change to a return without a parent node.'].
	parent isSequence 
		ifFalse: [self error: 'Parent node must be a sequence node.'].
	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].
	^parent addReturn!

clearReplacements
	parent isNil ifTrue: [^self].
	parent clearReplacements!

copyInContext: aDictionary
	^self copy!

copyList: matchNodes inContext: aDictionary
	| newNodes |
	newNodes := OrderedCollection new.
	matchNodes do: 
			[:each |
			| object |
			object := each copyInContext: aDictionary.
			newNodes addAll: object].
	^newNodes!

equalTo: aNode withMapping: aDictionary 
	^self = aNode!

isPatternNode
	^false!

mappingFor: aNode
	| method |
	method := self methodNode.
	method isNil ifTrue: [^aNode].
	^method mappingFor: aNode!

match: aNode inContext: aDictionary 
	^self = aNode!

matchList: matchNodes against: programNodes inContext: aDictionary 
	^self
		matchList: matchNodes
		index: 1
		against: programNodes
		index: 1
		inContext: aDictionary!

matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 
	| node |
	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].
	node := matchNodes at: matchIndex.
	node isList 
		ifTrue: 
			[| currentIndex |
			currentIndex := programIndex - 1.
			
			[| currentDictionary |
			currentDictionary := aDictionary copy.
			programNodes size < currentIndex or: 
					[| nodes |
					nodes := programNodes copyFrom: programIndex to: currentIndex.
					(currentDictionary at: node ifAbsentPut: nodes) = nodes and: 
							[(self 
								matchList: matchNodes
								index: matchIndex + 1
								against: programNodes
								index: currentIndex + 1
								inContext: currentDictionary) 
									ifTrue: 
										[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].
										^true].
							false]]] 
					whileFalse: [currentIndex := currentIndex + 1].
			^false].
	programNodes size < programIndex ifTrue: [^false].
	(node match: (programNodes at: programIndex) inContext: aDictionary) ifFalse: [^false].
	^self 
		matchList: matchNodes
		index: matchIndex + 1
		against: programNodes
		index: programIndex + 1
		inContext: aDictionary!

references: aVariableName 
	self childrenDo: [:each | (each references: aVariableName) ifTrue: [^true]].
	^false!

removeDeadCode
	self childrenDo: [:each | each removeDeadCode]!

replaceMethodSource: aNode
	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."

	| method |
	method := self methodNode.
	method notNil ifTrue: [method map: self to: aNode].
	aNode parent: self parent.
	[self replaceSourceWith: aNode] on: Error
		do: 
			[:ex |
			self clearReplacements.
			ex return]!

replaceNode: aNode withNode: anotherNode 
	self error: 'I don''t store other nodes'!

replaceSourceFrom: aNode 
	self clearReplacements!

replaceSourceWith: aNode 
	aNode replaceSourceFrom: self!

replaceWith: aNode 
	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].
	self replaceMethodSource: aNode.
	parent replaceNode: self withNode: aNode!

selfMessages
	| searcher |
	searcher := ParseTreeSearcher new.
	searcher matches: 'self `@msg: ``@args'
		do: 
			[:aNode :answer |
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new!

superMessages
	| searcher |
	SuperSearch isNil
		ifTrue: 
			[SuperSearch := RBPatternParser parseExpression: 'super `@msg: ``@args' onError: nil.
			SuperSearch
				selector;
				beImmutableObject].
	searcher := ParseTreeSearcher new.
	searcher addRule: (RBSearchRule searchForTree: SuperSearch
				thenDo: 
					[:aNode :answer |
					answer
						add: aNode selector;
						yourself]).
	^searcher executeTree: self initialAnswer: Set new! !
!Kernel.StProgramNode categoriesForMethods!
addReplacement:!public!replacing! !
asReturn!accessing!public! !
clearReplacements!public!replacing! !
copyInContext:!matching!public! !
copyList:inContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
isPatternNode!public!testing/matching! !
mappingFor:!accessing!public! !
match:inContext:!matching!public! !
matchList:against:inContext:!matching!public! !
matchList:index:against:index:inContext:!matching!public! !
references:!public!testing! !
removeDeadCode!public!replacing! !
replaceMethodSource:!public!replacing! !
replaceNode:withNode:!public!replacing! !
replaceSourceFrom:!private!replacing! !
replaceSourceWith:!private!replacing! !
replaceWith:!public!replacing! !
selfMessages!public!querying! !
superMessages!public!querying! !
!

!Kernel.StQualifiedReferenceNode methodsFor!

clearPositions
	start := 0.
	stop := -1.
	parentheses := nil! !
!Kernel.StQualifiedReferenceNode categoriesForMethods!
clearPositions!public!replacing! !
!

!Kernel.StReturnNode methodsFor!

copyInContext: aDictionary 
	^(self class new)
		value: (value copyInContext: aDictionary);
		yourself!

equalTo: anObject withMapping: aDictionary 
	^self class = anObject class 
		and: [self value equalTo: anObject value withMapping: aDictionary]!

match: aNode inContext: aDictionary 
	aNode class == self class ifFalse: [^false].
	^value match: aNode value inContext: aDictionary!

replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode]! !
!Kernel.StReturnNode categoriesForMethods!
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
match:inContext:!matching!public! !
replaceNode:withNode:!public!replacing! !
!

!Kernel.StSequenceNode methodsFor!

addNode: aNode
	(statements notEmpty and: [statements last isReturn])
		ifTrue: [self error: 'Cannot add statement after return node'].
	statements := statements asOrderedCollection
				add: aNode;
				yourself.
	aNode parent: self.
	^aNode!

addNode: aNode before: anotherNode
	| index |
	index := self indexOfNode: anotherNode.
	index == 0 ifTrue: [^self addNode: aNode].
	statements := statements asOrderedCollection
				add: aNode beforeIndex: index;
				yourself.
	aNode parent: self.
	^aNode!

addNodeFirst: aNode
	statements := statements asOrderedCollection
				addFirst: aNode;
				yourself.
	aNode parent: self.
	^aNode!

addNodes: aCollection
	(statements notEmpty and: [statements last isReturn])
		ifTrue: [self error: 'Cannot add statement after return node'].
	statements := statements asOrderedCollection
				addAll: aCollection;
				yourself.
	aCollection do: [:each | each parent: self].
	^aCollection!

addNodes: aCollection before: anotherNode
	aCollection do: [:each | self addNode: each before: anotherNode].
	^aCollection!

addNodesFirst: aCollection
	statements := statements asOrderedCollection
				addAllFirst: aCollection;
				yourself.
	aCollection do: [:each | each parent: self].
	^aCollection!

addReturn
	| node |
	statements isEmpty ifTrue: [^nil].
	statements last isReturn ifTrue: [^statements last].
	node := StReturnNode value: statements last.
	statements at: statements size put: node.
	node parent: self.
	^node!

addSelfReturn
	| node |
	self lastIsReturn ifTrue: [^self].
	node := StReturnNode value: (StSelfVariableNode start: 0).
	self addNode: node!

addTemporariesNamed: aCollection 
	aCollection do: [:each | self addTemporaryNamed: each]!

addTemporaryNamed: aString 
	| variableNode |
	variableNode := StTempDeclNode named: aString.
	variableNode parent: self.
	temporaries := temporaries copyWith: variableNode!

copyInContext: aDictionary 
	^(self class new)
		temporaries: (self copyList: temporaries inContext: aDictionary);
		statements: (self copyList: statements inContext: aDictionary);
		yourself!

equalTo: anObject withMapping: aDictionary
	self class = anObject class ifFalse: [^false].
	self statements size == anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: 
			[:i |
			((self statements at: i) equalTo: (anObject statements at: i) withMapping: aDictionary)
				ifFalse: [^false]].
	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"
	self temporaries do: [:each | aDictionary removeKey: each name ifAbsent: nil].
	^true!

indexOfNode: aNode
	"Try to find the node by first looking for ==, and then for ="

	| index |
	(index := statements identityIndexOf: aNode) == 0 ifTrue: [index := statements indexOf: aNode].
	^index!

match: aNode inContext: aDictionary 
	self class == aNode class ifFalse: [^false].
	^(self 
		matchList: temporaries
		against: aNode temporaries
		inContext: aDictionary) and: 
				[self 
					matchList: statements
					against: aNode statements
					inContext: aDictionary]!

references: aVariableName 
	^statements anySatisfy: [:each | each references: aVariableName]!

removeDeadCode
	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) to: 1
		by: -1
		do: 
			[:i | 
			(statements at: i) isImmediateNode 
				ifTrue: 
					[self clearReplacements.
					statements removeAtIndex: i]].
	super removeDeadCode!

removeNode: aNode
	self replaceNode: aNode withNodes: #()!

removeTemporaryNamed: aName 
	temporaries := temporaries reject: [:each | each name = aName]!

replaceNode: aNode withNode: anotherNode 
	self statements: (statements 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).
	self temporaries: (temporaries 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])!

replaceNode: aNode withNodes: aCollection 
	| index newStatements |
	self clearReplacements.
	index := self indexOfNode: aNode.
	newStatements := OrderedCollection new: statements size + aCollection size.
	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].
	newStatements addAll: aCollection.
	index + 1 to: statements size
		do: [:i | newStatements add: (statements at: i)].
	aCollection do: [:each | each parent: self].
	statements := newStatements! !
!Kernel.StSequenceNode categoriesForMethods!
addNode:!adding nodes!public! !
addNode:before:!adding nodes!public! !
addNodeFirst:!adding nodes!public! !
addNodes:!adding nodes!public! !
addNodes:before:!adding nodes!public! !
addNodesFirst:!adding nodes!public! !
addReturn!accessing!public! !
addSelfReturn!adding nodes!public! !
addTemporariesNamed:!adding nodes!public! !
addTemporaryNamed:!adding nodes!public! !
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
indexOfNode:!helpers!private! !
match:inContext:!matching!public! !
references:!public!testing! !
removeDeadCode!public!replacing! !
removeNode:!public!replacing! !
removeTemporaryNamed:!accessing!public! !
replaceNode:withNode:!public!replacing! !
replaceNode:withNodes:!public!replacing! !
!

!Kernel.StSpecialVariableNode methodsFor!

copyInContext: aDictionary
	^self class start: start! !
!Kernel.StSpecialVariableNode categoriesForMethods!
copyInContext:!matching!public! !
!

!Kernel.StToken methodsFor!

isPatternVariable
	^false! !
!Kernel.StToken categoriesForMethods!
isPatternVariable!public!testing! !
!

!Kernel.StValueNode methodsFor!

clearPositions
	parentheses := nil! !
!Kernel.StValueNode categoriesForMethods!
clearPositions!public!replacing! !
!

!Kernel.StVariableNode methodsFor!

clearPositions
	start := 0.
	parentheses := nil!

copyInContext: aDictionary
	^self class named: self name!

equalTo: anObject withMapping: aDictionary
	^anObject isVariable and: [(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name].!

references: aVariableName 
	^self name = aVariableName!

replaceSourceFrom: aNode
	self addReplacement: (RBStringReplacement
				replaceFrom: aNode start
				to: aNode stop
				with: self name)!

replaceSourceWith: aNode
	self addReplacement: (RBStringReplacement
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)! !
!Kernel.StVariableNode categoriesForMethods!
clearPositions!public!replacing! !
copyInContext:!matching!public! !
equalTo:withMapping:!comparing!public! !
references:!public!testing! !
replaceSourceFrom:!public!replacing! !
replaceSourceWith:!public!replacing! !
!

!Refactory.Browser.RBConfigurableFormatter methodsFor!

visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self visitPatternBlockNode: aRBPatternWrapperBlockNode! !
!Refactory.Browser.RBConfigurableFormatter categoriesForMethods!
visitPatternWrapperBlockNode:!public!visitor/double dispatching! !
!

!Refactory.Browser.RBFormatter methodsFor!

visitPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self acceptBlockNode: aRBPatternWrapperBlockNode startBlockString: '`{'.
	codeStream nextPut: $}! !
!Refactory.Browser.RBFormatter categoriesForMethods!
visitPatternWrapperBlockNode:!public!visitor/double dispatching! !
!

"End of package definition"!

