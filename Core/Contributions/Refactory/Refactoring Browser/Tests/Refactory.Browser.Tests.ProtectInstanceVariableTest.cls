"Filed out from Dolphin Smalltalk"!

Refactory.Browser.Tests.RefactoringTest subclass: #'Refactory.Browser.Tests.ProtectInstanceVariableTest'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.Tests.ProtectInstanceVariableTest guid: (Core.GUID fromString: '{4fadb9c6-abde-452c-90b8-bc1b80b72555}')!
Refactory.Browser.Tests.ProtectInstanceVariableTest comment: ''!
!Refactory.Browser.Tests.ProtectInstanceVariableTest categoriesForClass!Refactory-Testing! !
!Refactory.Browser.Tests.ProtectInstanceVariableTest methodsFor!

testProtectInstanceVariable
	| refactoring class |
	refactoring := ProtectInstanceVariableRefactoring variable: 'rewrite' , 'Rule1'
				class: SubclassOfClassToRename.
	self executeRefactoring: refactoring.
	class := refactoring model classNamed: #'Refactory.Browser.Tests.SubclassOfClassToRename'.
	self assert: (class parseTreeFor: #calls1)
		equals: (self parseMethod: 'calls1
								^rewriteRule1 := (rewriteRule1 := self calls)').
	self assert: (class parseTreeFor: #calls)
		equals: (self parseMethod: 'calls
								^rewriteRule1 := rewriteRule1 , rewriteRule1').
	"The name method should be preserved, even though it returns the value of the instance variable, because it is sent from elsewhere and so cannot be removed if behaviour is to be preserved."
	self assert: (class directlyDefinesMethod: 'name' asSymbol).
	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).
	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)!

testVariableNotDefined
	| refactoring |
	refactoring := ProtectInstanceVariableRefactoring variable: 'rewrite' class: SubclassOfClassToRename.
	self shouldFail: refactoring! !
!Refactory.Browser.Tests.ProtectInstanceVariableTest categoriesForMethods!
testProtectInstanceVariable!public!tests! !
testVariableNotDefined!failure tests!public! !
!

