"Filed out from Dolphin Smalltalk"!

Refactory.Browser.MethodRefactoring subclass: #'Refactory.Browser.PushUpMethodRefactoring'
	instanceVariableNames: 'removeDuplicates selectors'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.PushUpMethodRefactoring guid: (Core.GUID fromString: '{9124b878-03e9-4e01-abb4-34cf953777f4}')!
Refactory.Browser.PushUpMethodRefactoring comment: ''!
!Refactory.Browser.PushUpMethodRefactoring categoriesForClass!Refactory-Refactorings! !
!Refactory.Browser.PushUpMethodRefactoring methodsFor!

checkBackReferencesTo: aSelector
	| definingClass pushUpParseTree |
	definingClass := class superclass whoDefinesMethod: aSelector.
	definingClass isNil ifTrue: [^self].
	pushUpParseTree := class parseTreeFor: aSelector.
	class superclass allSubclasses do: 
			[:each |
			each selectors do: 
					[:sel |
					| parseTree |
					parseTree := each parseTreeFor: sel.
					(parseTree notNil and: 
							[(parseTree superMessages includes: aSelector)
								and: [definingClass == (each whoDefinesMethod: aSelector)]])
						ifTrue: 
							[removeDuplicates := true.
							(aSelector == sel and: [parseTree equalTo: pushUpParseTree exceptForVariables: #()])
								ifFalse: 
									[self refactoringError: ('Cannot push up <1p> since it would override the method defined in <2p>'
												expandMacrosWith: aSelector
												with: definingClass)]]]]!

checkClassVars
	selectors do: [:each | self checkClassVarsFor: each]!

checkClassVarsFor: aSelector
	class nonMetaclass classVariableNames do: 
			[:each |
			((class whichSelectorsReferToClassVariable: each) includes: aSelector)
				ifTrue: 
					[self refactoringError: ('<1p> refers to <2s> which is defined in <3p>'
								expandMacrosWith: aSelector
								with: each
								with: class)]]!

checkInstVars
	selectors do: [:each | self checkInstVarsFor: each]!

checkInstVarsFor: aSelector
	class instanceVariableNames do: 
			[:each |
			((class whichSelectorsReferToInstanceVariable: each) includes: aSelector)
				ifTrue: 
					[self refactoringError: ('<1p> refers to <2s> which is defined in <3p>'
								expandMacrosWith: aSelector
								with: each
								with: class)]]!

checkSiblingSuperSendsFrom: aRBClass
	selectors do: 
			[:aSelector |
			(aRBClass whichMethodsReferToSymbol: aSelector) do: 
					[:each |
					| tree |
					tree := each parseTree.
					tree notNil
						ifTrue: 
							[(tree superMessages includes: aSelector)
								ifTrue: 
									[| definer |
									definer := aRBClass superclass whoDefinesMethod: aSelector.
									(definer notNil and: [class includesClass: definer])
										ifTrue: 
											[self refactoringError: ('Cannot push up <1p> since <2d>>><3s> sends a super message to it.'
														expandMacrosWith: aSelector
														with: aRBClass unqualifiedName
														with: each selector)]]]]].
	aRBClass allSubclasses do: [:each | self checkSiblingSuperSendsFrom: each]!

checkSuperclass
	| overrideSelectors |
	overrideSelectors := selectors select: [:each | class superclass definesMethod: each].
	overrideSelectors := overrideSelectors reject: 
					[:each |
					| myTree superTree |
					myTree := class parseTreeFor: each.
					superTree := class superclass parseTreeFor: each.
					superTree equalTo: myTree exceptForVariables: #()].
	overrideSelectors isEmpty ifTrue: [^self].
	class superclass isAbstract
		ifFalse: 
			[self refactoringError: ('Non-abstract class <2p> or one of its superclasses already define <1p>'
						expandMacrosWith: overrideSelectors asArray first
						with: class superclass)].
	overrideSelectors do: [:each | self checkBackReferencesTo: each]!

checkSuperMessages
	self checkSuperSendsFromPushedUpMethods.
	self checkSuperSendsFromSiblings!

checkSuperSendsFromPushedUpMethods
	selectors do: 
			[:each |
			| parseTree |
			parseTree := class parseTreeFor: each.
			(parseTree superMessages anySatisfy: [:sup | class superclass directlyDefinesMethod: sup])
				ifTrue: 
					[self
						refactoringError: ('Cannot push up <1p> since it sends a super message that is defined in the superclass.'
								expandMacrosWith: each)]]!

checkSuperSendsFromSiblings
	| siblings |
	siblings := class superclass subclasses reject: [:each | each = class].
	siblings do: [:aRBClass | self checkSiblingSuperSendsFrom: aRBClass]!

copyDownMethod: aSelector
	| oldProtocols oldSource superclassDefiner subclasses refactoring |
	superclassDefiner := class superclass whoDefinesMethod: aSelector.
	superclassDefiner isNil ifTrue: [^self].
	oldSource := superclassDefiner sourceCodeFor: aSelector.
	oldSource isNil
		ifTrue: [self refactoringError: 'Source code for <1s> superclass method not available' << aSelector].
	oldProtocols := superclassDefiner protocolsFor: aSelector.
	subclasses := class superclass subclasses reject: [:each | each directlyDefinesMethod: aSelector].
	subclasses isEmpty ifTrue: [^self].
	((superclassDefiner parseTreeFor: aSelector) superMessages
		anySatisfy: [:each | superclassDefiner directlyDefinesMethod: each])
			ifTrue: 
				[self
					refactoringError: 'The <2p> method in superclass <3d> must be copied down to its other subclasses, but sends a super message that will be overridden.'
							<< {class. aSelector. superclassDefiner unqualifiedName}].
	(self shouldCopyDownSuperclassMethod: aSelector) ifFalse: [self refactoringAborted].
	refactoring := ExpandReferencedPoolsRefactoring
				model: self model
				forMethod: (superclassDefiner parseTreeFor: aSelector)
				fromClass: superclassDefiner
				toClasses: subclasses.
	self performComponentRefactoring: refactoring.
	subclasses do: [:each | each compile: oldSource categories: oldProtocols]!

copyDownMethods
	selectors do: [:each | self copyDownMethod: each]!

preconditions
	^(selectors inject: (RBCondition hasSuperclass: class)
		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 
			& (RBCondition withBlock: 
						[self checkInstVars.
						self checkClassVars.
						self checkSuperclass.
						self checkSuperMessages.
						true])!

pushUp: aSelector
	| source refactoring packageAndEnv |
	source := class sourceCodeFor: aSelector.
	source isNil ifTrue: [self refactoringError: 'Source for method not available'].
	refactoring := ExpandReferencedPoolsRefactoring
				model: self model
				forMethod: (class parseTreeFor: aSelector)
				fromClass: class
				toClasses: {class superclass}.
	self performComponentRefactoring: refactoring.
	"Maintain package and any custom namespace"
	packageAndEnv := class existingMethodPackageAndEnvironment: aSelector.
	class superclass
		compile: source
		environment: packageAndEnv second
		categories: (class protocolsFor: aSelector)
		package: packageAndEnv first!

pushUp: selectorCollection from: aClass 
	#rbFix. "Ensure displayString works when model is lazily created for Undo/Redo name (needs inst. vars set up)."
	class := aClass.
	selectors := selectorCollection.
	removeDuplicates := false.
	class := self classObjectFor: aClass!

pushUpMethods
	selectors do: [:each | self pushUp: each]!

removeDuplicateMethods
	selectors do: [:each | self removeDuplicatesOf: each]!

removeDuplicatesOf: aSelector
	| tree duplicatedIn |
	tree := class superclass parseTreeFor: aSelector.
	duplicatedIn := class superclass allSubclasses select: 
					[:each |
					(each directlyDefinesMethod: aSelector) and: 
							[(tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #())
								and: [(each superclass whoDefinesMethod: aSelector) == class superclass]]].
	(removeDuplicates or: [duplicatedIn isEmpty])
		ifFalse: [removeDuplicates := self shouldRemoveDuplicatesOf: aSelector in: duplicatedIn].
	removeDuplicates ifTrue: [duplicatedIn do: [:each | each removeMethod: aSelector]]!

removePushedUpMethods
	selectors do: [:each | class removeMethod: each]!

shouldCopyDownSuperclassMethod: aSelector
	^(self lookupOption: #copyDownSuperclassMethod) cull: self cull: aSelector!

shouldRemoveDuplicatesOf: aSymbol in: aCollectionOfClasses
	^(self lookupOption: #pushUpRemoveDuplicates)
		cull: self
		cull: aSymbol
		cull: aCollectionOfClasses!

storeOn: aStream 
	aStream nextPut: $(.
	self class storeOn: aStream.
	aStream nextPutAll: ' pushUp: '.
	selectors asArray storeOn: aStream.
	aStream nextPutAll: ' from: '.
	class storeOn: aStream.
	aStream nextPut: $)!

transform
	self
		copyDownMethods;
		pushUpMethods;
		removePushedUpMethods;
		removeDuplicateMethods! !
!Refactory.Browser.PushUpMethodRefactoring categoriesForMethods!
checkBackReferencesTo:!preconditions!public! !
checkClassVars!preconditions!public! !
checkClassVarsFor:!preconditions!public! !
checkInstVars!preconditions!public! !
checkInstVarsFor:!preconditions!public! !
checkSiblingSuperSendsFrom:!preconditions!public! !
checkSuperclass!preconditions!public! !
checkSuperMessages!preconditions!public! !
checkSuperSendsFromPushedUpMethods!preconditions!public! !
checkSuperSendsFromSiblings!preconditions!public! !
copyDownMethod:!private!transforming! !
copyDownMethods!public!transforming! !
preconditions!preconditions!public! !
pushUp:!public!transforming! !
pushUp:from:!initialize/release!public! !
pushUpMethods!public!transforming! !
removeDuplicateMethods!public!transforming! !
removeDuplicatesOf:!public!transforming! !
removePushedUpMethods!public!transforming! !
shouldCopyDownSuperclassMethod:!private!requests! !
shouldRemoveDuplicatesOf:in:!private!requests! !
storeOn:!printing!public! !
transform!public!transforming! !
!

!Refactory.Browser.PushUpMethodRefactoring class methodsFor!

model: aRBNamespace pushUp: selectorCollection from: aClass 
	^(self new)
		model: aRBNamespace;
		pushUp: selectorCollection from: aClass;
		yourself!

pushUp: selectorCollection from: aClass 
	^self new pushUp: selectorCollection from: aClass! !
!Refactory.Browser.PushUpMethodRefactoring class categoriesForMethods!
model:pushUp:from:!instance creation!public! !
pushUp:from:!instance creation!public! !
!

