;
; IDEAS:
;	1: Increment often succeeds a push of temporary, e.g. in the optimized version of #to:do: generated by the compiler,
;		so add a Push Temp N and Increment - Shame can't do "push, inc and store" (because of failure case?).
;
; Dolphin Smalltalk
; Byte code Interpreter routines and helpers in Assembler for IX86
; (Blair knows how these work, honest)
;
; DEBUG Build syntax:
;		ml /coff /c /Zi /Fr /Fl /Sc /Fo /D_DEBUG /Fo WinDebug\byteasm.obj byteasm.asm
; RELEASE Build syntax:
;		ml /coff /c /Zi /Fr /Fl /Sc /Fo WinRel\byteasm.obj byteasm.asm
;
; this will generate debug info (Zi) and full browse info (Fr), and this is
; appropriate for debug and release versions, and a listing with timings

; Notes about __fastcall calling convention:
; - The first two args of DWORD or less size are passed in ecx and
;	edx.
; - Other arguments are placed on the stack in the normal CDecl/Stdcall order
; - Return value is in EAX
; - In addition to preserving the normal set of registers, ESI
;	EDI, EBP, you must also preserve EBX (surprisingly),
;	and ES, FS AND GS (not surprisingly) for 32-bit Mixed language
;	programming
;
; Other register conventions:
;	- 	_SP is used to hold the Smalltalk stack pointer
;	-	_IP	is used to hold the Smalltalk instruction pointer
;		and is only ever written back to the global when calling
;		into C++.
;	-	Assembler subroutines obey the fastcall calling convention where appropriate
;
; N.B.
; I have tended to replicate small common code sequences to reduce jumps, as these
; are relatively expensive (3 cycles if taken) and performance is even more
; important here than it is for the primitives.
;
; References:
;	1	"How to optimize for the Pentium Processor", Agner Fog, 1996

INCLUDE IstAsm.Inc

.LISTALL
.LALL

.CODE BYTECODES_SEG

ASSUME	_IP:PTR BYTE			; Interpreters instruction pointer
ASSUME	_BP:PTR Oop				; Interpreters BP (base pointer - points at first arg/temp of method)
ASSUME	_SP:PTR Oop				; Interpreters SP (stack pointer)

; If debugging, always turn on profiling
IFDEF _DEBUG
	;;PROFILING	EQU		1
ENDIF

public ?primitiveActivateMethod@Interpreter@@CIPAIQAII@Z

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exports

; Byte code dispatch loop
public _byteCodeLoop									; Main entry point from C++
EXECUTENEWMETHOD EQU ?executeNewMethod@Interpreter@@CIXPAV?$TOTE@VCompiledMethod@ST@@@@I@Z
public EXECUTENEWMETHOD
ACTIVATENEWMETHOD EQU ?activateNewMethod@Interpreter@@SIXPAVCompiledMethod@ST@@@Z
public ACTIVATENEWMETHOD

public byteCodeTable

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Imports

IFDEF _DEBUG
	extern _primitiveCounters:DWORD
ENDIF

IFDEF PROFILING
	extern ?contextReturns@@3IA:DWORD
	extern ?contextsSuspended@@3IA:DWORD
	extern ?methodsActivated@@3IA:DWORD
	extern ?contextsCopied@@3IA:DWORD
	extern ?byteCodeCount@@3IA:DWORD
ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; C++ method imports
SENDVMINTERRUPT EQU ?sendVMInterrupt@Interpreter@@CIXII@Z
extern SENDVMINTERRUPT:near32

FINDNEWMETHODNOCACHE EQU ?findNewMethodInClassNoCache@Interpreter@@SGPAUMethodCacheEntry@1@PAV?$TOTE@VBehavior@ST@@@@I@Z ; STDCALL, OTE return and arg
extern FINDNEWMETHODNOCACHE:near32

BLOCKCOPY EQU ?blockCopy@Interpreter@@CIPAV?$TOTE@VBlockClosure@ST@@@@K@Z
extern BLOCKCOPY:near32											; See bytecde.cpp

INPUTPOLLCOUNTER		EQU		?m_nInputPollCounter@Interpreter@@0JC
extern INPUTPOLLCOUNTER:DWORD
INPUTPOLLINTERVAL		EQU		?m_nInputPollInterval@Interpreter@@0JA
extern INPUTPOLLINTERVAL:DWORD
MSGPOLL EQU ?MsgSendPoll@Interpreter@@CGHXZ
extern MSGPOLL:near32											; See bytecde.cpp
BYTEPOLL EQU ?BytecodePoll@Interpreter@@CGHXZ
extern BYTEPOLL:near32											; See bytecde.cpp
CHECKPROCESSSWITCH EQU ?CheckProcessSwitch@Interpreter@@CIHXZ
extern CHECKPROCESSSWITCH:near32								; See process.cpp
STEPPING				EQU		?m_bStepping@Interpreter@@0HA
extern STEPPING:DWORD

ResetInputPollCounter MACRO
	mov		[INPUTPOLLCOUNTER], 2
ENDM

CallCPPAndLoop MACRO mangledName
	CallCPP mangledName
	DispatchByteCode
ENDM

NONLOCALRETURN EQU ?nonLocalReturnValueTo@Interpreter@@CIXII@Z		; See bytecde.cpp
extern NONLOCALRETURN:near32

NEWCONTEXT EQU ?New@Context@ST@@SIPAV?$TOTE@VContext@ST@@@@II@Z
extern NEWCONTEXT:near32		; See bytecde.cpp
NEWBLOCK EQU ?New@BlockClosure@ST@@SIPAV?$TOTE@VBlockClosure@ST@@@@I@Z
extern NEWBLOCK:near32		; See bytecde.cpp

;; Special selector primitive response routines
extern arithmeticBitShift:near32							; See primasm.asm

IFDEF _DEBUG
	extern ?executionTrace@Interpreter@@2HA:DWORD
	CACHEHITS EQU ?cacheHits@@3KA
	extern CACHEHITS:DWORD
	DEBUGEXECTRACE EQU ?debugExecTrace@Interpreter@@SIXPAEPAI@Z
	extern DEBUGEXECTRACE:near32
	DEBUGMETHODACTIVATED EQU ?debugMethodActivated@Interpreter@@SIXPAI@Z
	extern DEBUGMETHODACTIVATED:near32
	DEBUGRETURNTOMETHOD EQU ?debugReturnToMethod@Interpreter@@SIXPAI@Z
	extern DEBUGRETURNTOMETHOD:near32
ENDIF

RESIZEACTIVEPROCESS EQU ?resizeActiveProcess@Interpreter@@SIXXZ
extern RESIZEACTIVEPROCESS:near32

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants (see also IstAsm.Inc)

EXECUTIONTRACE			EQU		?executionTrace@Interpreter@@2HA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data

.DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macros to generate instruction labels for jump table

CreateInstructionLabel MACRO stem, index
	DWORD		stem&&index
ENDM

CreateInstructionLabels MACRO stem, count
	index = 0
	REPEAT count
		CreateInstructionLabel stem
		index = index + 1
	ENDM
ENDM

CreateUniqueInstructionLabels MACRO stem, count
	index = 0
	REPEAT count
		CreateInstructionLabel stem, %index
		index = index + 1
	ENDM
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table of byte code routines for dispatch byte codes
;; Those marked with *2 are double byte, *3 triple byte

.CODE BYTECODES_SEG

;; N.B. These must be carefully maintained to ensure that Double Byte instructions start at 204 and Triple Byte
;; instructions at 240
NUMRESERVEDSINGLEBYTE	EQU 2			; Number of extra single byte instructions reserved before start of double byte
NUMRESERVEDDOUBLEBYTE	EQU 0			; Number of extra double byte instructions reserved before start of triple byte
NUMRESERVEDTRIPLEBYTE	EQU	0			; Number of extra triple byte instructions reserved before start of quad byte

FIRSTSHORTPUSHIV		EQU 1
NUMSHORTPUSHIVS			EQU 16			; Number of short push instance variable instructions

FIRSTSHORTPUSHTEMP		EQU (FIRSTSHORTPUSHIV + NUMSHORTPUSHIVS)
NUMSHORTPUSHTEMPS		EQU 8			; Number of short push temporary variable instructions

FIRSTPUSHCTXTTEMP		EQU	(FIRSTSHORTPUSHTEMP + NUMSHORTPUSHTEMPS)
NUMPUSHCTXTTEMPS		EQU 2

FIRSTPUSHOUTERTEMP		EQU (FIRSTPUSHCTXTTEMP + NUMPUSHCTXTTEMPS)
NUMPUSHOUTERTEMPS		EQU	2

FIRSTSHORTPUSHCONST		EQU (FIRSTPUSHOUTERTEMP	+ NUMPUSHOUTERTEMPS)
NUMSHORTPUSHCONSTANTS	EQU	16			; Number of short push constant (literal) instructions

FIRSTSHORTPUSHSTATIC	EQU (FIRSTSHORTPUSHCONST + NUMSHORTPUSHCONSTANTS)
NUMSHORTPUSHSTATICS		EQU	12			; Number of short push static (literal variable) instructions

FIRSTSHORTPUSHPSEUDO	EQU (FIRSTSHORTPUSHSTATIC + NUMSHORTPUSHSTATICS)
NUMSHORTPUSHPSEUDOS		EQU	4

FIRSTSHORTPUSHIMMEDIATE EQU (FIRSTSHORTPUSHPSEUDO + NUMSHORTPUSHPSEUDOS)
NUMSHORTPUSHIMMEDIATES	EQU 4

FIRSTSHORTPUSHSELFANDTEMP	EQU	(FIRSTSHORTPUSHIMMEDIATE + NUMSHORTPUSHIMMEDIATES)
NUMSHORTPUSHSELFANDTEMPS	EQU 4

FIRSTSHORTSTORETEMP		EQU	(FIRSTSHORTPUSHSELFANDTEMP + NUMSHORTPUSHSELFANDTEMPS)
NUMSHORTSTORETEMPS		EQU 4

SHORTPOPPUSHTEMP		EQU (FIRSTSHORTSTORETEMP + NUMSHORTSTORETEMPS)
NUMSHORTPOPPUSHTEMPS	EQU	2

POPPUSHSELF				EQU (SHORTPOPPUSHTEMP + NUMSHORTPOPPUSHTEMPS)
POPDUP					EQU (POPPUSHSELF+1)

FIRSTPOPSTORECTXTTEMP	EQU (POPDUP+1)
NUMPOPSTORECTXTTEMPS	EQU 2

FIRSTPOPSTOREOUTERTEMP	EQU (FIRSTPOPSTORECTXTTEMP + NUMPOPSTORECTXTTEMPS)
NUMPOPSTOREOUTERTEMPS	EQU 2

FIRSTPOPNSTOREINSTVAR	EQU (FIRSTPOPSTOREOUTERTEMP	+ NUMPOPSTOREOUTERTEMPS)
NUMPOPNSTOREINSTVARS	EQU	8			; Numbed of short pop and store instance variable instructions

FIRSTPOPNSTORETEMP		EQU (FIRSTPOPNSTOREINSTVAR + NUMPOPNSTOREINSTVARS)
NUMPOPNSTORETEMPS		EQU 8			; Number of short pop and store temporary variable instructions

POPSTACK				EQU (FIRSTPOPNSTORETEMP + NUMPOPNSTORETEMPS)

INCREMENTSTACKTOP		EQU (POPSTACK+1)
DECREMENTSTACKTOP		EQU (INCREMENTSTACKTOP+1)

DUPLICATESTACKTOP		EQU (DECREMENTSTACKTOP+1)								; 

RETURNSELF				EQU (DUPLICATESTACKTOP+1)
RETURNTRUE				EQU (RETURNSELF+1)
RETURNFALSE				EQU (RETURNTRUE+1)
RETURNNIL				EQU (RETURNFALSE+1)
RETURNMESSAGESTACKTOP	EQU (RETURNNIL+1)
RETURNBLOCKSTACKTOP		EQU (RETURNMESSAGESTACKTOP+1)
FARRETURNFROMBLOCK		EQU (RETURNBLOCKSTACKTOP+1)
POPRETURNSELF			EQU (FARRETURNFROMBLOCK+1)
NOOP					EQU (POPRETURNSELF+1)

FIRSTSHORTJUMP			EQU (NOOP+1)
NUMSHORTJUMPS			EQU 8			; Number of short jump instructions

FIRSTSHORTJUMPIFFALSE	EQU 118; (FIRSTSHORTJUMP+NUMSHORTJUMPS)
NUMSHORTJUMPSIFFALSE	EQU 8			; Number of short conditional jumps on false

FIRSTSPECIALSEND		EQU (FIRSTSHORTJUMPIFFALSE+NUMSHORTJUMPSIFFALSE)
NUMEXTRASPECIALSELECTORS EQU 4			; Number of special selectors which can be modified
NUMSPECIALSENDS			EQU (16+2+NUMEXTRASPECIALSELECTORS+10)

FIRSTSHORTSENDNOARGS	EQU (FIRSTSPECIALSEND+NUMSPECIALSENDS)
NUMSHORTSENDNOARGS		EQU 13			; Number of short send literal selector N with 0 args instructions

FIRSTSHORTSENDSELFNOARGS EQU (FIRSTSHORTSENDNOARGS + NUMSHORTSENDNOARGS)
NUMSHORTSENDSELFNOARGS	EQU 5

FIRSTSHORTSENDONEARG	EQU (FIRSTSHORTSENDSELFNOARGS+NUMSHORTSENDSELFNOARGS)
NUMSHORTSENDONEARG		EQU 14			; Number of short send literal selector N with 1 arg instructions

FIRSTSHORTSENDTWOARGS	EQU (FIRSTSHORTSENDONEARG+NUMSHORTSENDONEARG)
NUMSHORTSENDTWOARGS		EQU 8			; Number of short send literal selector N with 2 args instructions

FIRSTDOUBLEBYTE			EQU 204

PUSHINSTVAR				EQU	FIRSTDOUBLEBYTE
PUSHTEMPORARY			EQU (PUSHINSTVAR+1)
PUSHCONSTANT			EQU (PUSHTEMPORARY+1)
PUSHSTATIC				EQU (PUSHCONSTANT+1)
STOREINSTVAR			EQU (PUSHSTATIC+1)
STORETEMPORARY			EQU (STOREINSTVAR+1)
STORESTATIC				EQU (STORETEMPORARY+1)
POPSTOREINSTVAR			EQU (STORESTATIC+1)

; On Pentiums, "The Jump addresses should be placed in the data segment, not in the code seqment" (Ref 1)
.DATA
ALIGN 16
	; N.B. As currently coded, shortPushInstVar MUST come first (i.e. 0..NUMSHORTPUSHIVS-1)
byteCodeTable DD		break										; All push[0] instructions are now odd

	CreateInstructionLabels <shortPushInstVar>,					<NUMSHORTPUSHIVS>
	DWORD		shortPushTemp0
	CreateInstructionLabels <shortPushTemp>,					<(NUMSHORTPUSHTEMPS-1)>
	CreateInstructionLabels <shortPushContextTemp>,				<NUMPUSHCTXTTEMPS>
	CreateInstructionLabels <shortPushOuterTemp>,				<NUMPUSHOUTERTEMPS>
	CreateInstructionLabels <shortPushConstant>,				<NUMSHORTPUSHCONSTANTS>
	CreateInstructionLabels <shortPushStatic>,					<NUMSHORTPUSHSTATICS>

	; Block of 8 pushes of constants
	DWORD		shortPushSelf											; N.B. MUST BE ODD! (57)
	DWORD		shortPushTrue												;
	DWORD		shortPushFalse												;
	DWORD		shortPushNil													;
	CreateInstructionLabels <shortPushImmediate>,				<NUMSHORTPUSHIMMEDIATES>

	CreateInstructionLabels <shortPushSelfAndTemp>,				<NUMSHORTPUSHSELFANDTEMPS>
	CreateInstructionLabels <shortStoreTemp>,					<NUMSHORTSTORETEMPS>
	CreateInstructionLabels <shortPopPushTemp>,					<NUMSHORTPOPPUSHTEMPS>

	DWORD		popPushSelf
	DWORD		popDup

	CreateInstructionLabels <popStoreContextTemp>,					<NUMPOPSTORECTXTTEMPS>
	CreateInstructionLabels <shortPopStoreOuterTemp>,				<NUMPOPSTOREOUTERTEMPS>
	CreateInstructionLabels <shortPopStoreInstVar>,			<NUMPOPNSTOREINSTVARS>
	CreateInstructionLabels <shortPopStoreTemp>,			<NUMPOPNSTORETEMPS>

	DWORD		popStack												; 

	;; Additional instructions for the common increment and decrement instructions
	DWORD		incrementStackTop										; case 87 (not Smalltalk-80)
	DWORD		decrementStackTop										; case 88 (not Smalltalk-80)

	DWORD		duplicateStackTop										; 

	DWORD		returnSelf												; Must be in same order as pseudo pushes 
	DWORD		returnTrue												; 
	DWORD		returnFalse												; 
	DWORD		returnNil												; (Normally 123)
	DWORD		returnMessageStackTop									; 
	DWORD		returnBlockStackTop										; 
	DWORD		farReturnFromBlock										; Reserved for far return from Block (i.e. ^-return)

	DWORD		popReturnSelf
	
	DWORD		noOp													; No Operation. Must be odd number

	CreateUniqueInstructionLabels <shortJump>, <NUMSHORTJUMPS>
	CreateInstructionLabels <shortJumpIfFalse>, <NUMSHORTJUMPSIFFALSE>

	;; Block of 32 special sends, mostly the same as the Smalltalk-80 set
	DWORD		sendArithmeticAdd										; 
	DWORD		sendArithmeticSubtract									; 
	DWORD		sendArithmeticLessThan									; 
	DWORD		sendArithmeticGreaterThan								; 
	DWORD		sendArithmeticLessOrEqual								; 
	DWORD		sendArithmeticGreaterOrEqual							; 
	DWORD		sendArithmeticEqual										; 
	DWORD		sendArithmeticNotEqual									; 
	DWORD		sendArithmeticMultiply									; 
	DWORD		sendArithmeticDivide									; 
	DWORD		sendArithmeticMod										; 
	DWORD		sendArithmeticBitShift									; 
	DWORD		sendArithmeticDiv										; 
	DWORD		sendArithmeticBitAnd									; 
	DWORD		sendArithmeticBitOr										; 
	DWORD		shortSpecialSendIdentical								; 
	
	DWORD		shortSpecialSendValue									; 
	DWORD		shortSpecialSendValueColon								; 

	; The last group special selectors can be changed at will, or removed altogether
	CreateUniqueInstructionLabels <shortSpecialSend>, <NUMEXTRASPECIALSELECTORS>

	DWORD		shortSpecialSendAt									; 
	DWORD		shortSpecialSendAtPut								; 
	DWORD		shortSpecialSendValueValue								; 
	DWORD		shortSpecialSendBasicNew								; 
	DWORD		shortSpecialSendBasicClass								; 
	DWORD		shortSpecialSendBasicSize								; 
	DWORD		shortSpecialSendBasicAt									; 
	DWORD		shortSpecialSendBasicAtPut								; 
	DWORD		shortSpecialSendIsNil									; 
	DWORD		shortSpecialSendNotNil									; 

	CreateInstructionLabels <shortSendNoArgs>,			<NUMSHORTSENDNOARGS>
	CreateInstructionLabels <shortSendSelfNoArgs>,		<NUMSHORTSENDSELFNOARGS>
	CreateInstructionLabels <shortSendOneArg>,			<NUMSHORTSENDONEARG>	;
	CreateInstructionLabels <shortSendTwoArgs>,			<NUMSHORTSENDTWOARGS>			;

	DWORD		isZero
	DWORD		pushActiveFrame

	DWORD		shortSpecialSendNotIdentical
	DWORD		shortSpecialSendNot

	CreateInstructionLabels <invalidByteCode>, <NUMRESERVEDSINGLEBYTE>

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;; Beyond this point, all multi-byte codes (Almost all these codes not Smalltalk-80)

	;; Double byte codes (starting from 205)

	DWORD		pushInstVar										; 
	DWORD		pushTemporary									; 
	DWORD		pushConstant									; 
	DWORD		pushStatic										; 
	DWORD		storeInstVar									; 
	DWORD		storeTemporary									; 
	DWORD		storeStatic										; 
	DWORD		popStoreInstVar								; 
	DWORD		popStoreTemporary							; 
	DWORD		popStoreStatic								; 

	DWORD		pushImmediate
	DWORD		pushChar

	DWORD		Send													; 
	DWORD		Supersend												;
	DWORD		invalidByteCode											; Reserved for extended special send
	
	DWORD		nearJump												; 
	DWORD		nearJumpIfTrue											; 
	DWORD		nearJumpIfFalse											; 
	DWORD		nearJumpIfNil											;
	DWORD		nearJumpIfNotNil										;
	DWORD		invalidByteCode
	DWORD		invalidByteCode
	DWORD		sendTempNoArgs
	DWORD		pushSelfAndTemp
	DWORD		pushOuterTemp
	DWORD		storeOuterTemp
	DWORD		popStoreOuterTemp
	DWORD		sendSelfNoArgs
	DWORD		invalidByteCode
	DWORD		pushTempPair

	CreateInstructionLabels	<invalidByteCode>, <NUMRESERVEDDOUBLEBYTE>

	;; Triple Byte codes (starting from 234)

	DWORD		longPushConstant
	DWORD		longPushStatic
	DWORD		longStoreStatic
	DWORD		invalidByteCode
	DWORD		longPushImmediate
	DWORD		longSend											; 
	DWORD		longSupersend										; 
	DWORD		longJump												; 
	DWORD		longJumpIfTrue											; 
	DWORD		longJumpIfFalse											; 
	DWORD		longJumpIfNil
	DWORD		longJumpIfNotNil
	DWORD		longPushOuterTemp
	DWORD		longStoreOuterTemp
	DWORD		incrementTemp
	DWORD		incrementTempAndPush
	DWORD		decrementTemp
	DWORD		decrementTempAndPush
	CreateInstructionLabels <invalidByteCode>, <NUMRESERVEDTRIPLEBYTE>
	
	DWORD		blockCopy
	DWORD		exLongSend
	DWORD		exLongSupersend
	DWORD		exLongPushImmediate
	CreateInstructionLabels <invalidByteCode>, <0>

IFDEF _DEBUG
_byteCodeCounters DD	256 DUP (0)
public _byteCodeCounters
_lastByteCode DD 1 DUP (0)
_byteCodePairs DD	65536 DUP (0)
public _byteCodePairs
ENDIF

; N.B. This must be kept up to date with the structure in Interprt.h
MethodCacheEntry STRUCT
	selector				POTE		?
	classPointer			POTE		?
	method					POTE		?
	primAddress				DWORD		?
MethodCacheEntry ENDS

;ALIGN 16
;METHODCACHE MethodCacheEntry 1024 DUP (<>,<>,<>,<>)
;public METHODCACHE

METHODCACHE EQU ?methodCache@Interpreter@@0PAUMethodCacheEntry@1@A
extern METHODCACHE:MethodCacheEntry

.CODE BYTECODES_SEG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros

;; Declare an instruction

ENTERPROC MACRO
ENDM

EXITPROC MACRO
ENDM

ALIGNPROC MACRO
	ALIGN 16
ENDM

BEGINPROCNOALIGN MACRO name
	name PROC PUBLIC
	ENTERPROC
ENDM

BEGINPROC MACRO name
	ALIGNPROC
	BEGINPROCNOALIGN name
ENDM

BEGINRAREPROC MACRO name
	.CODE RAREBC_SEG
	name PROC PUBLIC
	ENTERPROC
ENDM

ENDPROC MACRO name
	name ENDP
ENDM

ENTERBYTECODE MACRO
ENDM

EXITBYTECODE MACRO
ENDM

BEGINBYTECODENOALIGN MACRO name
	.CODE BYTECODES_SEG
	name PROC PUBLIC
	ENTERBYTECODE
ENDM

BEGINBYTECODE MACRO name
	.CODE BYTECODES_SEG
	ALIGNPROC
	name PROC PUBLIC
	ENTERBYTECODE
ENDM

ENDBYTECODE MACRO name
	EXITBYTECODE
	ENDPROC name
ENDM

BEGINRARECODE MACRO name
	.CODE RAREBC_SEG
	name PROC PUBLIC
	ENTERBYTECODE
ENDM

FetchByteNoClear MACRO regLetter:=<c>
	mov		regLetter&l, BYTE PTR[_IP]
	inc		_IP
ENDM	

FetchByte MACRO regLetter:=<c>
	movzx	e&regLetter&x, BYTE PTR[_IP]
	inc		_IP
ENDM

FetchNext MACRO
	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			mov		ecx, _IP
			; We must preserve edx and eax so that this is transparent, 
			; but ecx will be overwritten anyway, so we can ignore that.
			push	edx
			mov		edx, _SP
			push	eax
			call	DEBUGEXECTRACE
			pop		eax
			pop		edx
		.ENDIF
	ENDIF

	FetchByte

	IFDEF PROFILING
		inc		[?byteCodeCount@@3IA]
	ENDIF
ENDM

MPrefetch MACRO
	IFDEF _DEBUG
	ELSE
		FetchNext
	ENDIF
ENDM

DispatchNext MACRO
	IFDEF _DEBUG
		FetchNext
		inc	[_byteCodeCounters+ecx*4]
		mov	edx, [_lastByteCode]
		shl edx, 10
		inc [_byteCodePairs+edx+(ecx*4)]
		mov [_lastByteCode], ecx
	ENDIF
	jmp		DWORD PTR[byteCodeTable+ecx*4]		;; Transfer control via jump table (will return to dispatchByte)
ENDM		

;; Instructions to dispatch the next byte code
;;
DispatchByteCode MACRO
	MPrefetch
	DispatchNext
ENDM

PopDispatchByteCode MACRO
	MPrefetch
	sub		_SP, OOPSIZE
	DispatchNext
ENDM	

CountDownOopAndDispatch MACRO
	LOCAL	deleteObject
	ASSUME	ecx:PTR OTE						;; ECX contains the object to count down

	test 	cl, 1							;; Was it an immediate object?
	jnz 	@F								;; Yes, no further processing

	mov		dl, [ecx].m_count
	cmp		dl, 0ffh						;; Has count overflowed?
	je		@F								;; Yes, do nothing
	dec		dl								;; Two instructions = 2 cycles, dec [mem] = 3 cycles
	mov		[ecx].m_count, dl
	jz		addToZct						;; Count reduced to zero?
@@:
	DispatchByteCode
	
addToZct:
	AddToZct <c>
	DispatchByteCode

	ASSUME ecx:NOTHING
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Send macros for sending a selector to the stack top object with zero or more args

SendSelectorOneArgToInteger MACRO selector
	mov 	edx, [selector]								;; access entry in SpecialSelectors table
	pushd	1											;; 1 argument
	mov		[STACKPOINTER], _SP		 					;; Save down stack pointer (needed for DNU and C++ primitives)
	mov		ecx, [Pointers.ClassSmallInteger]
	mov		[MESSAGE], edx								;; Set interpreters messageSelector register (no effect on flags)
	jmp		execMethodOfClass							;; Jump directly to exec. routine
ENDM

SendSelectorOneArgToObjectEAX MACRO selector
	ASSUME	eax:PTR OTE									;; N.B. Expects receiver in EAX

	mov 	edx, [selector]								;; access entry in SpecialSelectors table
	mov		[STACKPOINTER], _SP		 					;; Save down SP for DNU and prims

	pushd	1											;; 0 argument
	mov		ecx, [eax].m_oteClass						;; Get the class of the Object

	mov		[MESSAGE], edx								;; Set the MESSAGE global
	jmp		execMethodOfClass							; Jump to routine to exec class>>message in ECX>>EDX
ENDM

SendSelectorArgs MACRO selector, args
	LOCAL sendToSmallInteger

	mov 	edx, [selector]								;; access entry in SpecialSelectors table
	pushd	args										;; N arguments

	mov		eax, [_SP-(OOPSIZE*args)]					;; Load receiver into EAX (under args)
	mov		[STACKPOINTER], _SP		 					;; Save down SP for DNU and C++ prims

	mov		[MESSAGE], edx								;; Set the MESSAGE global
	test	al, 1
	
	jnz		sendToSmallInteger

	ASSUME	eax:PTR OTE
	mov		ecx, [eax].m_oteClass						;; Get the class of the Object

	jmp		execMethodOfClass							; Jump to routine to exec class>>message in ECX>>EDX

sendToSmallInteger:
	ASSUME	eax:SDWORD									;; EAX is a SmallInteger

	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass							; Jump to routine to exec class>>message in ECX>>EDX
ENDM

SendSelectorNoArgs MACRO selector
	SendSelectorArgs selector, 0
ENDM

SendSelectorOneArg MACRO selector
	SendSelectorArgs selector, 1
ENDM

SendSelectorTwoArgs MACRO selector
	SendSelectorArgs selector, 2
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reference count helper(s)

;; push an Oop onto the stack, overwriting whatever is there
;; Inputs:
;;		EDX = Oop to push
;;		_SP = Stack pointer
;; Outputs:
;;		EDX = destroyed
;;		EAX = destroyed
;;		
PushOop MACRO regLetter
	; To avoid AGI stall, use offset and add afterwards
	mov		[_SP+OOPSIZE], e&regLetter&x				;; push object onto stack
	add     _SP, OOPSIZE
ENDM

PushAndDispatch MACRO regLetter
	ASSERTNEQU c, &regLetter

	MPrefetch
	PushOop regLetter
	DispatchNext
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Byte code Dispatching

GetInitialIPOfMethod MACRO methodPtr
	mov	_IP, [methodPtr].m_byteCodes
	.IF (_IP & 1)
		lea		_IP, [methodPtr].m_byteCodes
	.ELSE
		IFDEF _DEBUG
			.IF (_IP == [oteNil])
				int	3
			.ENDIF
		ENDIF
		mov		_IP, (OTE PTR[_IP]).m_location
		;; There is no longer any header on the object body to skip here
	.ENDIF
ENDM

ASSUME _IP:PTR BYTE

; The main byte code loop entry point from C++.
; Never returns except to an enclosing exception handler
BEGINPROC _byteCodeLoop
	mov		_BP, [BASEPOINTER]
	mov		_IP, [INSTRUCTIONPOINTER]
	MPrefetch
	mov		_SP, [STACKPOINTER]
	DispatchNext
ENDPROC _byteCodeLoop


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Byte Code Interpretation routines.
;; Attempt to get most frequest instructions on same page as byte code loop
;; for locality of reference

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Instance Variable Instructions (single byte)

PushInstVar MACRO index
	mov		eax, [_BP-OOPSIZE]							;; Load Oop of receiver (_BP-1)	(u)
	mov		eax, (OTE PTR[eax]).m_location				;; Load pointer to receiver (u)
	mov     eax, (Object PTR[eax]).fields[index*OOPSIZE]	;; Load inst var into edx
	PushAndDispatch <a>
ENDM

; On the Pentium there is relatively little benefit to inlining the instructions, since the cost
; of the extra instruction to access the index from the instruction is hidden in
; pairing and the fact that the arithmetic can be done in the load address calc.
; so we might as well save the space (increasing caching possibilities too)

BEGINBYTECODE shortPushInstVar
	mov		eax, [_BP-OOPSIZE]							;; Load Oop of receiver (_BP-1)
	mov		edx, ecx
	mov		eax, (OTE PTR[eax]).m_location				;; Load pointer to receiver
	ASSUME	eax:Ptr Object
	MPrefetch
	mov     eax, [eax].fields[edx*OOPSIZE-(FIRSTSHORTPUSHIV*OOPSIZE)]
	ASSUME	eax:Oop
	PushOop <a>
	DispatchNext
ENDBYTECODE shortPushInstVar

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Temporary Variable Instructions (single byte)
;;	Note that these push stack temporaries, not environment temps
;; 
PushTemporary MACRO index
	mov     eax, [_BP+index*OOPSIZE]			;; Load temp var Oop from _BP
	PushAndDispatch <a>							;; Push Oop in edx, and dispatch next (no clear ECX)
ENDM

PushTemporaryN MACRO index
	BEGINBYTECODE shortPushTemp&index
		PushTemporary index
	ENDBYTECODE shortPushTemp&index
ENDM

ALIGN 16 
; Worth inlining this one, as reduced instruction size
PushTemporaryN 0

ALIGN 16
BEGINBYTECODE shortPushTemp
	mov     eax, [_BP+(ecx*OOPSIZE)-(FIRSTSHORTPUSHTEMP*OOPSIZE)]		;; Load temp var Oop from _BP
	PushAndDispatch <a>													;; Push Oop in edx, and dispatch next (no clear ECX)
ENDBYTECODE shortPushTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Special push instructions (single byte)

;; This used to be the most commonly executed instruction, but now push temp 0 and return stack top are 
;; more common because of the macro forms
ALIGN 16
BEGINBYTECODE shortPushSelf
	mov		eax, [_BP-OOPSIZE]					; Access receiver at _BP-1
	PushAndDispatch <a>
ENDBYTECODE shortPushSelf

;; Macro instruction combining
;;	push self
;;	push temp[n]
;;
ALIGN 16
BEGINBYTECODE shortPushSelfAndTemp
	mov		edx, [_BP-OOPSIZE]					; Access receiver at _BP-1
	mov     eax, [_BP+(ecx*OOPSIZE)-(FIRSTSHORTPUSHSELFANDTEMP*OOPSIZE)]		;; Load temp var Oop from _BP
	MPrefetch
	mov		[_SP+OOPSIZE], edx				;; push object onto stack
	mov		[_SP+OOPSIZE*2], eax
	add		_SP, OOPSIZE*2
	DispatchNext
ENDBYTECODE shortPushSelfAndTemp

BEGINBYTECODE pushTempPair
	movzx	ecx, BYTE PTR[_IP]
	mov		eax, ecx
	inc		_IP
	shr		ecx, 4
	and		eax, 0Fh
	mov     ecx, [_BP+ecx*OOPSIZE]			;; Load temp var Oop from _BP
	mov     eax, [_BP+eax*OOPSIZE]			;; Load temp var Oop from _BP
	mov		[_SP+OOPSIZE], ecx
	MPrefetch
	mov		[_SP+OOPSIZE*2], eax
	add		_SP, OOPSIZE*2
	DispatchNext
ENDBYTECODE pushTempPair

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Context Temp (i.e. Push Outer [0] Temp [N]) (single byte)

BEGINBYTECODE shortPushContextTemp
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields

	mov		edx, [edx].m_environment
	mov		edx, (OTE PTR[edx]).m_location
	ASSUME	edx:PTR Context

	mov		eax, [edx].m_tempFrame[ecx*OOPSIZE-(FIRSTPUSHCTXTTEMP*OOPSIZE)]
	PushAndDispatch <a>
ENDBYTECODE shortPushContextTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Outer Temp (i.e. Push Outer [1] Temp [N]) (single byte)
;; Hmm, indirections make for a lot of AGI faults here (unfortunately)

BEGINBYTECODE shortPushOuterTemp
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields

	mov		edx, [edx].m_environment
	ASSUME	edx:PTR OTE
	mov		edx, [edx].m_location
	ASSUME	edx:PTR Context

	mov		edx, [edx].m_outer
	ASSUME	edx:PTR OTE
	mov		edx, [edx].m_location
	ASSUME	edx:PTR Context

	mov		eax, [edx].m_tempFrame[ecx*OOPSIZE-(FIRSTPUSHOUTERTEMP*OOPSIZE)]
	PushAndDispatch <a>
ENDBYTECODE shortPushOuterTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Literal Constant Instructions (single byte)

LoadLiteralAt MACRO offset
	ASSERTNEQU eax, &offset
	mov		eax, [pMethod]												;; Load pointer to current method
	mov     eax, (CompiledCodeObj PTR[eax]).m_aLiterals[offset]			;; Load Oop from literal frame
ENDM

LoadLiteral MACRO index
	LoadLiteralAt index*OOPSIZE
ENDM

PushConstantAt MACRO offset
	LoadLiteralAt offset
	PushAndDispatch <a>
ENDM

PushConstant MACRO index
	PushConstantAt index*OOPSIZE
ENDM

PushConstantN MACRO index
	BEGINBYTECODE shortPushConstant&index
		PushConstant index
	ENDBYTECODE shortPushConstant&index
ENDM

BEGINBYTECODE shortPushConstant
	mov		eax, [pMethod]												;; Load pointer to current method
	mov     eax, (CompiledCodeObj PTR[eax]).m_aLiterals[(ecx*OOPSIZE) - (FIRSTSHORTPUSHCONST*OOPSIZE)]			;; Load Oop from literal frame
	PushAndDispatch <a>
ENDBYTECODE shortPushConstant

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short Push Static (Literal) Variable Instructions (single byte)

LoadStatic MACRO index
	LoadLiteral index
	mov		eax, (OTE PTR[eax]).m_location			;; Load pointer to binding
	mov		eax, (Object PTR[eax]).fields[OOPSIZE]	;; Load value Oop from binding
ENDM

PushStatic MACRO index
	IFDEF _DEBUG
		LoadStatic index
		PushAndDispatch <a>									;; Push eax onto the stack
	ELSE
		mov		eax, [pMethod]							;; Load pointer to current method
		ASSUME	eax:PTR CompiledCodeObj
		xor		ecx, ecx

		add     _SP, OOPSIZE							;; We're going to push, so prepare _SP 
		mov     eax, [eax].m_aLiterals[index*OOPSIZE]	;; Load Oop from literal frame
		ASSUME	eax:PTR OTE

		mov		cl, [_IP]								;; Load next instruction
		mov		eax, [eax].m_location					;; Load pointer to binding
		ASSUME	eax:PTR Object

		inc		_IP
		mov		eax, [eax].fields[OOPSIZE]				;; Load value Oop from binding
		
		;; Now Push eax onto the stack
		mov		[_SP], eax								;; push inst var onto stack
		ASSUME	eax:NOTHING
		
		jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	ENDIF
ENDM

PushStaticN MACRO index
	BEGINBYTECODE shortPushStatic&index
		PushStatic %index
	ENDBYTECODE shortPushStatic&index
ENDM

BEGINBYTECODE shortPushStatic
	IFDEF _DEBUG
		mov		eax, [pMethod]							;; Load pointer to current method
		ASSUME	eax:PTR CompiledCodeObj
		mov     eax, [eax].m_aLiterals[(ecx*OOPSIZE)-(FIRSTSHORTPUSHSTATIC*OOPSIZE)]	;; Load Oop from literal frame
		ASSUME	eax:NOTHING
		mov		eax, (OTE PTR[eax]).m_location			;; Load pointer to binding
		mov		eax, (Object PTR[eax]).fields[OOPSIZE]	;; Load value Oop from binding

		PushAndDispatch <a>
	ELSE
		mov		eax, [pMethod]							;; Load pointer to current method
		ASSUME	eax:PTR CompiledCodeObj

		add     _SP, OOPSIZE							;; We're going to push, so prepare _SP 
		mov     eax, [eax].m_aLiterals[(ecx*OOPSIZE)-(FIRSTSHORTPUSHSTATIC*OOPSIZE)]	;; Load Oop from literal frame
		ASSUME	eax:NOTHING

		xor		ecx, ecx
		mov		eax, (OTE PTR[eax]).m_location			;; Load pointer to binding
		mov		cl, BYTE PTR[_IP]
		mov		eax, (Object PTR[eax]).fields[OOPSIZE]	;; Load value Oop from binding
		inc		_IP

		;; Now Push eax onto the stack
		mov		[_SP], eax								;; push inst var onto stack

		jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	ENDIF
ENDBYTECODE shortPushStatic

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Store into a stack temp. Note no ref. counting needed, as all on the stack

BEGINBYTECODE shortPopStoreTemp
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	mov     [_BP+(ecx*OOPSIZE)-(FIRSTPOPNSTORETEMP*OOPSIZE)], eax
	DispatchByteCode
ENDBYTECODE shortPopStoreTemp

BEGINBYTECODE shortStoreTemp
	mov		eax, [_SP]
	mov     [_BP+(ecx*OOPSIZE)-(FIRSTSHORTSTORETEMP*OOPSIZE)], eax
	DispatchByteCode
ENDBYTECODE shortStoreTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Instructions (double Byte). 
;;

BEGINBYTECODE pushSelfAndTemp
	mov		eax, [_BP-OOPSIZE]					; Access receiver at _BP-1
	FetchByte <d>
	PushOop <a>									; push receiver
	mov     eax, [_BP+edx*OOPSIZE]				; Load temp var Oop from _BP
	PushAndDispatch <a>							; Push Oop in edx, and dispatch next (no clear ECX)
ENDBYTECODE pushSelfAndTemp

;; Extension is the index (0 based)

; pushInstVar - see shortPushInstVar above
BEGINBYTECODE pushInstVar
	mov		eax, [_BP-OOPSIZE]							;; Load Oop of receiver (_BP-1)
	FetchByte <d>
	mov		eax, (OTE PTR[eax]).m_location				;; Load pointer to receiver
	ASSUME	eax:Ptr Object
	MPrefetch
	mov     eax, [eax].fields[edx*OOPSIZE]
	ASSUME	eax:Oop
	PushOop <a>
	DispatchNext
ENDBYTECODE pushInstVar

BEGINBYTECODE pushTemporary
	FetchByte
	PushTemporary ecx
ENDBYTECODE pushTemporary

OuterTempPreamble MACRO
	movzx	ecx, BYTE PTR[_IP]
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields

	mov		eax, ecx							
	and		eax, 31									; Bottom 5 bits are temp index
	shr		ecx, 5									; Top 3 bits are outer path distance

	mov		edx, [edx].m_environment
	mov		edx, (OTE PTR[edx]).m_location
	ASSUME	edx:PTR Context
	.WHILE	ecx > 0
		mov	edx, [edx].m_outer
		mov	edx, (OTE PTR[edx]).m_location
		dec	ecx
	.ENDW
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Outer Temporary Instruction (double byte)

BEGINBYTECODE pushOuterTemp
	OuterTempPreamble

	mov		cl, BYTE PTR[_IP+1]
	mov		eax, [edx].m_tempFrame[eax*OOPSIZE]

IFDEF _DEBUG
	inc		_IP
	PushOop <a>
	DispatchByteCode
ELSE
	add		_IP, 2
	PushOop <a>
	DispatchNext
ENDIF
ENDBYTECODE pushOuterTemp


BEGINBYTECODE pushConstant
	IFDEF _DEBUG
		FetchByte
		PushConstant ecx
	ELSE

		mov		eax, [pMethod]							;; Load pointer to current method
		ASSUME	eax:PTR CompiledCodeObj

		movzx	ecx, [_IP]								;; Load literal index
		add     _SP, OOPSIZE							;; We're going to push, so prepare _SP 

		inc		_IP
		mov     eax, [eax].m_aLiterals[ecx*OOPSIZE]		;; Load Oop from literal frame

		ASSUME	eax:NOTHING
		MPrefetch
		
		mov		[_SP], eax								;; push literal const onto stack

		DispatchNext
	ENDIF
ENDBYTECODE pushConstant

BEGINBYTECODE pushStatic
	IFDEF _DEBUG
		FetchByte
		PushStatic <ecx>
	ELSE
		mov		eax, [pMethod]							;; Load pointer to current method
		ASSUME	eax:PTR CompiledCodeObj

		movzx	ecx, [_IP]								;; Load literal index
		add     _SP, OOPSIZE							;; We're going to push, so prepare _SP 
		
		inc		_IP
		mov     eax, [eax].m_aLiterals[ecx*OOPSIZE]		;; Load Oop from literal frame

		MPrefetch
		
		mov		eax, (OTE PTR[eax]).m_location			;; Load pointer to binding
		ASSUME eax:PTR Object
		mov		eax, [eax].fields[OOPSIZE]				;; Load value Oop from binding
		mov		[_SP], eax								;; push value onto stack
		ASSUME eax:NOTHING
		
		DispatchNext
	ENDIF

ENDBYTECODE pushStatic

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BEGINBYTECODE shortPopStoreInstVar
	mov		edx, [_BP-OOPSIZE]					;; Load Oop of receiver from _BP-1
	ASSUME	edx:PTR OTE
	sub		ecx, FIRSTPOPNSTOREINSTVAR
	
	mov		eax, [edx].m_location				;; Load pointer to receiver
	ASSUME	eax:PTR Object
	shl		ecx, OOPSHIFT
	
	cmp		ecx, [edx].m_size
	jge		storeError							;; Out of bounds, or immutable

	lea		edx, [eax].fields[ecx]
	ASSUME	edx:PTR Oop

	mov		ecx, [_SP]							;; ECX is the popped Oop
	sub		_SP, OOPSIZE
	CountUpOopIn <c>							;; N.B. Storing into a heap object slot
			
	;; Load pointer to inst var into edx
	mov		eax, [edx]							;; Load existing value of inst var into EAX for countDown
	test	al, 1

	mov     [edx], ecx							;; Store Oop from stack top into inst var slot
	ASSUME	edx:NOTHING
	jnz		@F									;; SmallInteger, so skip the count down

	CountDownObjectIn <a>
@@:
	DispatchByteCode

storeError:
	;; An attempt was made to store out of bounds, or into an immutable object
	;; We must send #instVarAt:put:, leaving the IP of the current frame
	;; at the store instruction
	ASSUME	edx:PTR OTE							;; edx is still the Oop of the receiver
	ASSUME	ecx:DWORD							;; ecx is store offset
	ASSUME	eax:NOTHING
	
	mov	eax, [_SP]								;; EAX is the Oop being stored
	shr ecx, OOPSHIFT-1
	mov	[_SP], edx								;; Push receiver
	add ecx, 03h								;; Convert zero-based to one-based index and set SmallInteger flag
	dec	_IP										;; Leave IP at pop;store IV instruction
	mov [_SP+OOPSIZE], ecx						;; Push index
	mov [_SP+(OOPSIZE*2)], eax					;; Push arg
	add _SP, OOPSIZE*2							;; Two args
	SendSelectorTwoArgs <Pointers.instVarAtPutSymbol>
	
ENDBYTECODE shortPopStoreInstVar

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pop Stack Top Instruction (single byte)
;;
BEGINBYTECODE popStack
 	MPrefetch
	sub		_SP, OOPSIZE					;; Perform the actual pop
	DispatchNext
ENDBYTECODE popStack

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Duplicate Stack Top Instruction (single byte)
;; Replicate the object on top of the stack.

BEGINBYTECODE duplicateStackTop
	mov		eax, [_SP]
	PushAndDispatch <a>
ENDBYTECODE duplicateStackTop

BEGINBYTECODE popPushSelf
	mov		eax, [_BP-OOPSIZE]				; Access receiver at _BP-1
	MPrefetch
	mov		[_SP], eax						; Replace stack top with receiver
	DispatchNext
ENDBYTECODE popPushSelf

BEGINBYTECODE shortPopPushTemp
	mov     eax, [_BP+(ecx*OOPSIZE)-(SHORTPOPPUSHTEMP*OOPSIZE)]		; Load temp var Oop from _BP
	MPrefetch
	mov		[_SP], eax						; Replace stack top with temp
	DispatchNext
ENDBYTECODE shortPopPushTemp

BEGINBYTECODE popDup
	mov		eax, [_SP-OOPSIZE]				; Load object under stack top
	MPrefetch
	mov		[_SP], eax						; Dup
	DispatchNext
ENDBYTECODE popDup

;; Macro instruction combining
;;	push self
;;	send [n] with 0 args
;;
BEGINBYTECODE sendSelfNoArgs
	mov		eax, [_BP-OOPSIZE]						; Access receiver at _BP-1
	FetchByte

	; ecx-offset is the literal index
	mov		edx, [pMethod]							; Load current method
	ASSUME	edx:PTR CompiledCodeObj

	PushOop <a>										; push receiver
	
	test	al, 1									; Test for immediate receiver (used later)
	mov		[STACKPOINTER], _SP		 				; Save down stack pointer (needed for DNU and C++ primitives)

	mov     edx, [edx].m_aLiterals[ecx*OOPSIZE]		; Load selector Oop into ecx

	pushd	0										; 0 arguments
	mov		[MESSAGE], edx							; Save down message

	jnz		@F										; If a SmallInteger need to load class differently
	mov		ecx, (OTE PTR[eax]).m_oteClass			; Get class into ECX
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
@@:
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX

	ASSUME	ecx:NOTHING
ENDBYTECODE sendSelfNoArgs

BEGINBYTECODE shortPushTrue
	mov		eax, [oteTrue]
	PushAndDispatch <a>
ENDBYTECODE shortPushTrue

BEGINBYTECODE shortPushFalse
	mov		eax, [oteFalse]
	PushAndDispatch <a>
ENDBYTECODE shortPushFalse

;; This is a very commonly executed instruction
BEGINBYTECODE shortPushNil
	mov		eax, [oteNil]
	PushAndDispatch <a>
ENDBYTECODE shortPushNil

IF 1
BEGINBYTECODE shortPushImmediate
	lea		eax, [(ecx*2)-((FIRSTSHORTPUSHIMMEDIATE + 1)*2)+1]
	MPrefetch
	mov		[_SP+OOPSIZE], eax
	add     _SP, OOPSIZE
	DispatchNext
ENDBYTECODE shortPushImmediate

ELSE
;; These routines would have better pairability if the small integer value was first loaded into
;; eax, BUT, that doesn't save any cycles (they take only 5), and increase the number of instructions
;; and the size of the procedures by 4 bytes a piece
BEGINBYTECODE shortPushMinusOne
	MPrefetch
	mov		[_SP+OOPSIZE], -1
	add     _SP, OOPSIZE
	DispatchNext
ENDBYTECODE shortPushMinusOne

BEGINBYTECODE shortPushZero
	MPrefetch
	mov		[_SP+OOPSIZE], SMALLINTZERO
	add     _SP, OOPSIZE
	DispatchNext
ENDBYTECODE shortPushZero

BEGINBYTECODE shortPushOne
	MPrefetch
	mov		[_SP+OOPSIZE], SMALLINTONE
	add     _SP, OOPSIZE
	DispatchNext
ENDBYTECODE shortPushOne

BEGINBYTECODE shortPushTwo
	MPrefetch
	mov		[_SP+OOPSIZE], SMALLINTTWO
	add     _SP, OOPSIZE
	DispatchNext
ENDBYTECODE shortPushTwo
ENDIF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Signed Byte Instruction (double byte)
;;
;; Extension (-128..127) is value to be pushed as SmallInteger

BEGINBYTECODE pushImmediate
	; Optimized form...
	movsx	eax, BYTE PTR[_IP]					; Sign extend next byte into EAX
	add		_SP, OOPSIZE
	movzx	ecx, [_IP+1]

	lea		eax, [eax+eax+1]					; Convert to SmallInteger
	add		_IP,2

	mov		[_SP], eax							; push SmallInteger onto stack

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			push	ecx
			mov		ecx, _IP
			mov		edx, _SP
			dec		ecx
			call	DEBUGEXECTRACE
			pop		ecx
		.ENDIF
		inc		[_byteCodeCounters+ecx*4]
	ENDIF
	IFDEF PROFILING
		inc		[?byteCodeCount@@3IA]
	ENDIF

	jmp		byteCodeTable[ecx*4]			; Transfer control via jump table (will return to dispatchByte)
ENDBYTECODE pushImmediate

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Return instructions

ReturnOopToSender MACRO oop
	mov		edx, [ACTIVEFRAME]							; Load pointer to top stack frame into EDX

	ASSUME	ecx:Oop
	ASSUME	edx:PStackFrame

	; Note that the frame could still have an associated context if we are returning from a method
	; that has full blocks.
	
	mov		edx, [edx].m_caller							; Load sender frame of active frame (Does not affect flags)
	ASSUME	edx:PTR Oop

	call	shortReturn
	DispatchByteCode
ENDM

BEGINBYTECODE popReturnSelf
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	; Drop through...
ENDBYTECODE popReturnSelf

BEGINBYTECODENOALIGN returnSelf
;;
;; Return receiver to sending context is a very common operation (default method
;; return), but dynamically it occurs much less frequently than return message
;; stack top. We need to inc. ref. count of receiver as return routine pushes it on
;; without ref. count.
;;
	mov		ecx, [_BP-OOPSIZE]				; Receiver is one below _BP
	ReturnOopToSender
ENDBYTECODE returnSelf

BEGINBYTECODE returnTrue
	mov		ecx, [oteTrue]			; Load True Oop
	ReturnOopToSender
ENDBYTECODE returnTrue

BEGINBYTECODE returnFalse
	mov		ecx, [oteFalse]			; Load False Oop
	ReturnOopToSender
ENDBYTECODE returnFalse

BEGINBYTECODE returnNil
	mov		ecx, [oteNil]				; Load Nil Oop
	ReturnOopToSender
ENDBYTECODE returnNil

;; When returning from a block using this instruction, we always return from our
;; caller. As we are a block context, then ACTIVECONTEXT must be a genuine
;; Object, and not a SmallInteger pointer into the stack (Blocks are never stored on the stack).
BEGINBYTECODE returnBlockStackTop
	; TODO: Can implement this slightly more efficiently as don't need to check for no-context case
	; ... Drop through and implement as normal short return ....
ENDBYTECODE returnBlockStackTop

;; Return message stack top is one of the most commonly occurring bytecodes (both
;; statically and dynamically)
BEGINBYTECODENOALIGN returnMessageStackTop
	mov		ecx, [_SP]									; Load stack top into register
	sub		_SP, OOPSIZE								; Adjust SP for pop
	ReturnOopToSender
ENDBYTECODE returnMessageStackTop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Context (short) return routine
; Inputs:
;		ECX		- Return Value Oop
;		EDX		- Return frame (SmallInteger pointer into active process stack)
;
; Outputs:
;		_SP		- Updated to point at return contexts saved _SP + 1, with return value stored at stack top
;		EBX		- Points to base temps and args
;		EDI		- Points at next instruction to execute in method
;		EAX		- Destroyed
;		ECX		- Destroyed
;		EDX		- Destroyed
;
; N.B. We can freely use EDI, and EBX since these will be reloaded anyway for the return context

; No alignment (drop through from above)
BEGINPROC shortReturn

	; If returning FROM a full method context, need to nil old frame pointer to mark as returned
	mov		eax, [ACTIVEFRAME]						; u - Load old frame pointer
	ASSUME	eax:PStackFrame

	lea		_BP, [edx-1]
	ASSUME _BP:PStackFrame
	ASSUME edx:NOTHING								; EDX now free for other uses

	mov		eax, [eax].m_environment				; Load context Oop of frame being returned from
	mov		[ACTIVEFRAME], _BP						; Save down new active frame pointer

	.IF	!(al & 1)									; Has a full context?
		ASSUME	eax:PTR OTE							; Yes, BP points at context object
		mov		edx, [eax].m_location				; Load pointer to the Context
		ASSUME	edx:PTR Context
		.IF ([edx].m_outer & 1)						; Is it a Method context?
			mov		[edx].m_outer, SMALLINTZERO		; Yes, zero out the frame
		.ENDIF
	.ENDIF
	ASSUME	eax:NOTHING
	ASSUME	edx:NOTHING
	
	; First adjust stack to SP of return context
	mov		_SP, [_BP].m_sp							; Get _SP of return context - use the _IP register
	add		_SP, OOPSIZE-1							; Adjust to point at return value slot
	
	; _BP still points at return StackFrame
	mov		eax, [_BP].m_method						; Get Oop of method
	ASSUME	eax:PTR OTE
	mov		_IP, [_BP].m_ip							; Load _IP before we overwrite pNewContext

	mov		[_SP], ecx								; Push on the result

	mov		eax, [eax].m_location					; Get pointer to new Method into EAX
	ASSUME	eax:PTR CompiledCodeObj

	;; Now we set up _IP (_IP) and _BP (_BP) - _SP adjusted above
	sar		_IP, 1									; Convert SmallInteger _IP index
	ASSUME	_IP:PTR BYTE

	mov		[pMethod], eax							; Save down pointer to method into global

	mov		_BP, [_BP].m_bp							; Load context Oop of return frame
	ASSUME	_BP:PTR Oop								
	MUSTBEINTEGEROBJECT<_BP>

	;; Get instruction base address into EAX
	.IF !((BYTE PTR([eax].m_byteCodes) & 1))
		mov		eax, [eax].m_byteCodes				; Bytes in a ByteArray, offset includes header size
		ASSUME	eax:PTR OTE
		mov		eax, [eax].m_location				; Load the address of the start of the byte code array
	.ELSE
		add		eax, CompiledCodeObj.m_byteCodes	; Bytes packed in SmallInteger
	.ENDIF

	dec		_BP										; Remove SmallInteger flag from BP
	add		_IP, eax								; Add base to current offset to give _IP of return context

	mov		[BASEPOINTER], _BP						; save it down for C++

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			mov		ecx, _SP
			call	DEBUGRETURNTOMETHOD
			mov		ecx, _IP
			mov		edx, _SP
		.ENDIF
	ENDIF

	ret
shortReturn ENDP

BEGINBYTECODE farReturnFromBlock
	mov		edx, [ACTIVEFRAME]							; Load pointer to top stack frame into EDX
	mov		ecx, [_SP]									; Load stack top into register
	sub		_SP, OOPSIZE								; Adjust SP for pop

	ASSUME	ecx:Oop
	ASSUME	edx:PStackFrame

	mov		eax, [edx].m_environment					; Load context of frame into EAX
	CANTBEINTEGEROBJECT <eax>
	mov		edx, [edx].m_caller							; Load sender frame of active frame (Does not affect flags)
	ASSUME	edx:PTR Oop

	; Full context, so need to check if Block - outer will be SmallInteger if a method context
	mov		eax, [eax].m_location						; Load pointer to context object
	mov		eax, (Context PTR[eax]).m_outer				; Load home context or frame offset
	
	CANTBEINTEGEROBJECT <eax>

	; We want to return to the sender of the blocks home context (something tied down at closure time
	; not activation time) so chain up through contexts until locate home
	; EAX still contains Oop of outer context
	.REPEAT
		mov	edx, [eax].m_location						; Load pointer to home method context
		ASSUME edx:PTR Context
		mov	eax, [edx].m_outer							; Load frame index of home context into EDX
	.UNTIL (eax & 1)

	cmp		eax, SMALLINTZERO							; Already returned?
	je		invalidReturn								; Yes, cannot return from home
	xor		eax, 1										; Remove SmallInteger flag, hey presto pointer to frame
	ASSUME	eax:PStackFrame
	cmp		eax, [ACTIVEFRAME]
	jge		invalidReturn
	cmp		eax, [ACTIVEPROCESS]
	jle		invalidReturn

	mov		edx, [eax].m_caller
	ASSUME	edx:Oop

	mov		eax, [ACTIVEFRAME]
	ASSUME	eax:PStackFrame
	cmp		[eax].m_caller, edx							; Actually returning to the caller?
	jne		@F

	; Yes, its a short return after all
	call shortReturn
	DispatchByteCode
	
@@:
	; Not returning to caller, need to perform unwind
	CallCPP <NONLOCALRETURN>
	DispatchByteCode
ENDBYTECODE farReturnFromBlock

;; A little entry thunk for the C++ routine which raises and error for attempts to return
;; from contexts which have already returned and/or attempts to perform cross process returns
BEGINRAREPROC invalidReturn
	mov		eax, [Pointers.Scheduler]		; Processor receives #cannotReturn:
	mov		[_SP+OOPSIZE], eax				; Push processor
	mov		[_SP+OOPSIZE*2], ecx			; Push result
	add		_SP, OOPSIZE*2

	SendSelectorOneArgToObjectEAX <Pointers.CannotReturnSelector>
ENDPROC invalidReturn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Return the first argument to the stack frame at the address specified by the second arg.
; Primitive here for locality of reference
BEGINPRIMITIVE primitiveReturn
	mov		eax, [ACTIVEPROCESS]
	ASSUME	eax:PTR Process
	mov		edx, [_SP]							; Get the frame index (a SmallInteger)
	mov		ecx, [_SP-OOPSIZE]					; Get return value
	sub		_SP, OOPSIZE*2						; Args ref. count will be assumed for return value, so ensure not popped
	sub		edx, 3								; Convert SmallInteger index to zero based offset * 2 (i.e. word offset)
	add		eax, OFFSET Process.m_stack + 1		; Adjust for fixed inst. vars (note that 1 added to get frame Oop result at end)
	shl		edx, 1								; Convert to byte offset
	add		edx, eax							; Calculate the frame Oop, which is expected in EDX

	mov		eax, [ACTIVEFRAME]
	ASSUME	eax:PStackFrame
	
	cmp		[eax].m_caller, edx					; Returning to active contexts caller?
	jne		@F

	call	shortReturn

	mov		eax, _SP							; primitiveSuccess(0)
	ret

@@:
	; Store interpreter registers before calling C++ func
	mov		[INSTRUCTIONPOINTER], _IP
	mov		[STACKPOINTER], _SP
	call	NONLOCALRETURN
	; Reload interpreter registers afer non-local return (note SP is reloaded from eax after calling all primitives)
	mov		_IP, [INSTRUCTIONPOINTER]
	mov		eax, [STACKPOINTER]
	mov		_BP, [BASEPOINTER]
	ret
ENDPRIMITIVE primitiveReturn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASSUME ecx:NOTHING
ASSUME	_BP:PTR Oop

BEGINBYTECODE popStoreContextTemp
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields
	mov		eax, [_SP]								; Loop Oop from stack top
	ASSUME	eax:Oop

	mov		edx, [edx].m_environment
	sub		_SP, OOPSIZE

	mov		edx, (OTE PTR[edx]).m_location
	ASSUME	edx:PTR Context

	; We must count up the new value as we are going to store it into a heap object
	CountUpOopIn<a>
	
	; Swap existing value with new value
	; TODO: Get rid of xchg, as this is slow (interlocked)
	xchg	eax, [edx].m_tempFrame[ecx*OOPSIZE-(FIRSTPOPSTORECTXTTEMP*OOPSIZE)]

	; Since count down destroys register contents, we can't pre-fetch
	CountDownOopIn<a>
	
	DispatchByteCode
ENDBYTECODE popStoreContextTemp

BEGINBYTECODE shortPopStoreOuterTemp
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields
	mov		eax, [_SP]								; Loop Oop from stack top
	ASSUME	eax:Oop

	mov		edx, [edx].m_environment
	sub		_SP, OOPSIZE
	ASSUME	edx:PTR OTE
	mov		edx, [edx].m_location
	ASSUME	edx:PTR Context

	mov		edx, [edx].m_outer
	ASSUME	edx:PTR OTE
	mov		edx, [edx].m_location
	ASSUME	edx:PTR Context

	; We must count up the new value as we are going to store it into a heap object
	CountUpOopIn<a>

	; Swap existing value with new value
	; TODO: Get rid of slow xchg instruction
	xchg	eax, [edx].m_tempFrame[ecx*OOPSIZE-(FIRSTPOPSTOREOUTERTEMP*OOPSIZE)]

	; Since count down destroys registers we can't prefetch
	CountDownOopIn<a>
	
	DispatchByteCode
ENDBYTECODE shortPopStoreOuterTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (Pop And) Store Instance Variable (double byte)
;;
;; Extension is inst var index (0 based)

; Similar to short store, but we need to use lea here as not enough registers free to perform
; address calculation more than once.
StoreInstVarAndDispatch MACRO
	ASSUME	eax:Oop								;; EAX is the Oop to be stored
	ASSUME	ecx:DWORD							;; ECX is zero-based inst var index
	
	mov		edx, [_BP-OOPSIZE]					;; Load Oop of receiver from _BP-1
	ASSUME	edx:PTR OTE
	shl		ecx, OOPSHIFT						;; Convert to byte offset
	
	cmp		ecx, [edx].m_size					;; Check not out of bounds, or immutable
	jge		storeError
	
	mov		edx, [edx].m_location				;; Load pointer to receiver
	ASSUME	edx:PTR Object

	lea		edx, [edx].fields[ecx]
	ASSUME	edx:PTR Oop
	
	CountUpOopIn <a>

	mov		ecx, [edx]				;; Load existing value of inst var into ECX for countDown
	mov     [edx], eax				;; Store Oop from stack top into inst var
	ASSUME	edx:NOTHING
	CountDownOopAndDispatch

storeError:	
	;; An attempt was made to store out of bounds, or into an immutable object
	;; We must send #instVarAt:put:, leaving the IP of the current frame
	;; at the store instruction
	ASSUME	edx:PTR OTE							;; edx is still the Oop of the receiver
	ASSUME	ecx:DWORD							;; ecx is store offset
	ASSUME	eax:Oop								;; eax is the Oop to store
	
	shr ecx, OOPSHIFT-1
	mov	[_SP+OOPSIZE], edx						;; Push receiver
	add ecx, 03h								;; Convert zero-based to one-based index and set SmallInteger flag
	sub	_IP,2									;; Leave IP at (pop)store IV instruction
	mov [_SP+(OOPSIZE*2)], ecx					;; Push index
	mov [_SP+(OOPSIZE*3)], eax					;; Push arg
	add _SP, OOPSIZE*3							;; Receiver + Two args
	SendSelectorTwoArgs <Pointers.instVarAtPutSymbol>

ENDM

BEGINBYTECODE popStoreInstVar
	FetchByte
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	StoreInstVarAndDispatch						;; Store down the inst var whose index is in ECX from EAX
ENDBYTECODE popStoreInstVar

BEGINBYTECODE storeInstVar
	mov		eax, [_SP]
	FetchByte
	StoreInstVarAndDispatch
ENDBYTECODE storeInstVar

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (Pop And) Store Temporary Variable (double byte). 
;;

BEGINBYTECODE popStoreTemporary
	FetchByte <d>
	mov		eax, [_SP]							;; Load stack top into register
	sub		_SP, OOPSIZE						;; Adjust SP for pop
	MPrefetch
	mov     [_BP+edx*OOPSIZE], eax				;; Store Oop from stack top into stack slot
	DispatchNext
ENDBYTECODE popStoreTemporary

BEGINBYTECODE storeTemporary
	FetchByte <d>
	mov		eax, [_SP]
	MPrefetch
	mov     [_BP+edx*OOPSIZE], eax					;; Store Oop from stack top into inst var
	DispatchNext
ENDBYTECODE storeTemporary

BEGINBYTECODE incrementTemp
	movzx	edx, BYTE PTR[_IP+1]
	mov		eax, [_BP+edx*OOPSIZE]
	test	al, 1									; Is it a SmallInteger?
	jz		@F										; No, skip primitive response

	add		eax, SMALLINTONE - 1					; Add one (without SmallInteger bit)
	jo		overflow								; It overflowed 31-bits?

	IFDEF _DEBUG
		mov		[_BP+edx*OOPSIZE], eax
		add _IP,2									; Skip over the PopStoreTempN instruction
		DispatchByteCode							; Dispatch the next byte code
	ELSE
		movzx	ecx, BYTE PTR[_IP+2]
		mov		[_BP+edx*OOPSIZE], eax
		add		_IP, 3
		jmp byteCodeTable[ecx*4]
	ENDIF
	; Doesn't get to here

overflow:
	mov		eax, [_BP+edx*OOPSIZE]
	
@@:
	; Not a SmallInteger or overflow, send '+ 1'. Execution will continue on the 
	; PopStoreTempN instruction that occurs in the middle of this one
	mov		[_SP+OOPSIZE], eax
	mov		[_SP+OOPSIZE*2], SMALLINTONE
	add     _SP, OOPSIZE*2
	SendSelectorOneArg <Pointers.plusSelector>

ENDBYTECODE incrementTemp

BEGINBYTECODE incrementTempAndPush
	movzx	edx, BYTE PTR[_IP+1]
	mov		eax, [_BP+edx*OOPSIZE]
	test	al, 1									; Is it a SmallInteger?
	jz		@F										; No, skip primitive response

	add		eax, SMALLINTONE - 1					; Add one (without SmallInteger bit)
	jo		overflow								; It overflowed 31-bits?

	mov		[_BP+edx*OOPSIZE], eax

	IFDEF _DEBUG
		PushOop <a>
		add _IP,2									; Skip over the PopStoreTempN instruction
		DispatchByteCode							; Dispatch the next byte code
	ELSE
		movzx	ecx, BYTE PTR[_IP+2]
		mov		[_SP+OOPSIZE], eax				;; push object onto stack
		add		_IP, 3
		add     _SP, OOPSIZE
		jmp byteCodeTable[ecx*4]
	ENDIF
	; Doesn't get to here

overflow:
	mov		eax, [_BP+edx*OOPSIZE]
	
@@:
	; Not a SmallInteger or overflow, send '+ 1'. Execution will continue on the 
	; StoreTempN instruction that occurs in the middle of this one
	mov		[_SP+OOPSIZE], eax
	mov		[_SP+OOPSIZE*2], SMALLINTONE
	add     _SP, OOPSIZE*2
	SendSelectorOneArg <Pointers.plusSelector>

ENDBYTECODE incrementTempAndPush

BEGINBYTECODE decrementTemp
	movzx	edx, BYTE PTR[_IP+1]
	mov		eax, [_BP+edx*OOPSIZE]
	test	al, 1									; Is it a SmallInteger?
	jz		@F										; No, skip primitive response

	sub		eax, SMALLINTONE - 1					; Add one (without SmallInteger bit)
	jo		overflow								; It overflowed 31-bits?

	IFDEF _DEBUG
		mov		[_BP+edx*OOPSIZE], eax
		add _IP,2									; Skip over the PopStoreTempN instruction
		DispatchByteCode							; Dispatch the next byte code
	ELSE
		movzx	ecx, BYTE PTR[_IP+2]
		mov		[_BP+edx*OOPSIZE], eax
		add		_IP, 3
		jmp byteCodeTable[ecx*4]
	ENDIF
	; Doesn't get to here

overflow:
	mov		eax, [_BP+edx*OOPSIZE]
	
@@:
	; Not a SmallInteger or overflow, send '+ 1'. Execution will continue on the 
	; PopStoreTempN instruction that occurs in the middle of this one
	mov		[_SP+OOPSIZE], eax
	mov		[_SP+OOPSIZE*2], SMALLINTONE
	add     _SP, OOPSIZE*2
	SendSelectorOneArg <Pointers.minusSelector>

ENDBYTECODE decrementTemp

BEGINBYTECODE decrementTempAndPush
	movzx	edx, BYTE PTR[_IP+1]
	mov		eax, [_BP+edx*OOPSIZE]
	test	al, 1									; Is it a SmallInteger?
	jz		@F										; No, skip primitive response

	sub		eax, SMALLINTONE - 1					; Add one (without SmallInteger bit)
	jo		overflow								; It overflowed 31-bits?

	mov		[_BP+edx*OOPSIZE], eax

	IFDEF _DEBUG
		PushOop <a>
		add _IP,2									; Skip over the PopStoreTempN instruction
		DispatchByteCode							; Dispatch the next byte code
	ELSE
		movzx	ecx, BYTE PTR[_IP+2]
		mov		[_SP+OOPSIZE], eax				;; push object onto stack
		add		_IP, 3
		add     _SP, OOPSIZE
		jmp byteCodeTable[ecx*4]
	ENDIF
	; Doesn't get to here

overflow:
	mov		eax, [_BP+edx*OOPSIZE]
	
@@:
	; Not a SmallInteger or overflow, send '+ 1'. Execution will continue on the 
	; StoreTempN instruction that occurs in the middle of this one
	mov		[_SP+OOPSIZE], eax
	mov		[_SP+OOPSIZE*2], SMALLINTONE
	add     _SP, OOPSIZE*2
	SendSelectorOneArg <Pointers.minusSelector>

ENDBYTECODE decrementTempAndPush
BEGINBYTECODE popStoreOuterTemp
	OuterTempPreamble
	ASSUME	edx:PTR Context		; EDX points to the Context containing the temp
	ASSUME	eax:DWORD			; EAX is pointer to 
	ASSUME	ecx:NOTHING			; ECX is 0

	mov		ecx, [_SP]								;; Load Oop to store from ToS
	lea		edx, [edx].m_tempFrame[eax*OOPSIZE]
	ASSUME	edx:Ptr Oop
	sub		_SP, OOPSIZE
	CountUpOopIn <c>
	
	mov		eax, [edx]								;; Load existing value of temporary
	inc		_IP
	mov		[edx], ecx								;; And overwrite with new value
	
	; Since count down may destroy register contents, we can't prefetch here
	CountDownOopIn <a>
	
	DispatchByteCode
ENDBYTECODE popStoreOuterTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEGINBYTECODE storeOuterTemp
	OuterTempPreamble
	ASSUME	edx:PTR Context		; EDX points to the Context containing the temp
	ASSUME	eax:DWORD			; EAX is pointer to 
	ASSUME	ecx:NOTHING			; ECX is 0

	mov		ecx, [_SP]								;; Load Oop to store from ToS
	lea		edx, [edx].m_tempFrame[eax*OOPSIZE]
	ASSUME	edx:Ptr Oop
	
	; Must count up because its going to be stored into a heap object
	CountUpOopIn <c>

	mov		eax, [edx]								;; Load existing value of temporary
	mov		[edx], ecx								;; And overwrite with new value

	inc		_IP
	
	; Must count down overwritten context temp - may destroy registers, so can't prefetch
	CountDownOopIn <a>
	
	DispatchByteCode
ENDBYTECODE storeOuterTemp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (Pop And) Store Static (Literal) Variable (double byte)
;;
;; Extension is inst var index (0 based).
;; There are no short variants of these instructions

StoreStaticAndDispatch MACRO
	mov		edx, [pMethod]						; Load Oop of current method
	ASSUME	edx:PTR CompiledCodeObj
	CountUpOopIn <a>								; Storing into a heap object, so must count up
	;; Load literal Oop of binding
	mov     edx, [edx].m_aLiterals[ecx*OOPSIZE]	
	ASSUME	edx:PTR OTE
	
	mov		edx, [edx].m_location		; Load pointer to binding
	ASSUME	edx:PTR VariableBindingObj
	mov		ecx, [edx].m_value			; Load existing value
	mov		[edx].m_value, eax			; Store new value
	
	;; Count down original value of static variable - may destroy registers so can't prefetch
	CountDownOopIn <c>
	
	DispatchByteCode							;; Dispatch the next byte code
ENDM

BEGINBYTECODE popStoreStatic
	mov		eax, [_SP]							;; Load stack top into register
	FetchByte
	sub		_SP, OOPSIZE
	StoreStaticAndDispatch
ENDBYTECODE popStoreStatic

BEGINBYTECODE storeStatic
	mov		eax, [_SP]
	FetchByte
	StoreStaticAndDispatch
ENDBYTECODE storeStatic

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Signed Word Instruction (triple byte).
;;
;; Extension (-32768..32767) is value to be pushed as SmallInteger

BEGINBYTECODE longPushImmediate
	movsx	eax, WORD PTR[_IP]					; Sign extend next two bytes into EDX
	xor		ecx, ecx							; Clear ECX (avoid partial register stall on PPro and later PIIs it would appear)
	
	add		_SP, OOPSIZE
	mov		cl, [_IP+2]
	
	lea		eax, [eax+eax+1]					; Convert to SmallInteger
	add		_IP, 3								; Advance instruction pointer (over next instruction)
	
	mov		[_SP], eax							; push SmallInteger onto stack

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			push	ecx
			mov		ecx, _IP
			mov		edx, _SP
			dec		ecx
			call	DEBUGEXECTRACE
			pop		ecx
		.ENDIF
		inc		[_byteCodeCounters+ecx*4]
	ENDIF
	IFDEF PROFILING
		inc		[?byteCodeCount@@3IA]
	ENDIF

	jmp		byteCodeTable[ecx*4]				; Transfer control via jump table
ENDBYTECODE longPushImmediate

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push a 31-bit integer (five bytes).
;;
BEGINBYTECODE exLongPushImmediate
	mov		eax, DWORD PTR[_IP]					; Load the SmallInteger encoded in the next 4 bytes of the instruction stream
	xor		ecx, ecx							; Clear ECX (avoid partial register stall on PPro and later PIIs it would appear)

	add		_SP, OOPSIZE
	mov		cl, [_IP+4]

	lea		eax, [eax+eax+1]					; Convert to SmallInteger
	add		_IP, 5								; Advance instruction pointer (over next instruction)
	
	mov		[_SP], eax							; push SmallInteger onto stack

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			push	ecx
			mov		ecx, _IP
			mov		edx, _SP
			dec		ecx
			call	DEBUGEXECTRACE
			pop		ecx
		.ENDIF
		inc		[_byteCodeCounters+ecx*4]
	ENDIF
	IFDEF PROFILING
		inc		[?byteCodeCount@@3IA]
	ENDIF

	jmp		byteCodeTable[ecx*4]				; Transfer control via jump table
ENDBYTECODE exLongPushImmediate

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Character Instruction (double byte).
;; Extension is character code (0..255)

BEGINBYTECODE pushChar
	mov		edx, [OBJECTTABLE]
	movzx	eax, BYTE PTR[_IP]					; Load code point byte into EAX
	movzx	ecx, [_IP+1]
	add		_SP, OOPSIZE

	;; TODO: Need faster way to do this for 16 byte entry
;	lea		eax, [edx+FIRSTCHAROFFSET+eax*OTENTRYSIZE]
	shl		eax, 4
	add		edx, FIRSTCHAROFFSET
	add		eax, edx

	add		_IP, 2
	mov		[_SP], eax							; push Character onto stack

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			push	ecx
			mov		ecx, _IP
			mov		edx, _SP
			dec		ecx
			call	DEBUGEXECTRACE
			pop		ecx
		.ENDIF
		inc		[_byteCodeCounters+ecx*4]
	ENDIF
	IFDEF PROFILING
		inc		[?byteCodeCount@@3IA]
	ENDIF

	jmp		byteCodeTable[ecx*4]				; Transfer control via jump table
ENDBYTECODE pushChar

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short forward jumps to fixed relative offsets

;; N.B. The minimum jump is +2. A +1 jump (offset 0) would be a NOP, which would waste a valuable
;; short instruction. Note that this adjustment is not applied to longer jumps, where
;; offset 0 if always considered to be a NOP jump.

ShortJumpN MACRO index
	BEGINBYTECODENOALIGN shortJump&index
		;ALIGN 4
	;BEGINBYTECODE shortJump&index
		IFDEF _DEBUG
			add	_IP, index+1					;; N.B. Extra 1 added to extend range of short jumps
												;; i.e. minimum jump is +2 (from start of jump instruction)
			DispatchByteCode
		ELSE
			movzx	ecx, [_IP+index+1]
			add		_IP, index+1+1
			jmp		byteCodeTable[ecx*4]
		ENDIF
	ENDBYTECODE shortJump&index
ENDM

ALIGN 16
; So short that we might as well inline it
index = 0
REPEAT NUMSHORTJUMPS
	ShortJumpN %index
	index = index + 1
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Short jump on false, generate inline instructions from macro again

BEGINBYTECODE shortJumpIfFalse
IFDEF _DEBUG
	;; N.B. Extra 1 added to extend range of short jumps
	sub		ecx, FIRSTSHORTJUMPIFFALSE-1
	mov		eax, [_SP]
	sub		_SP, OOPSIZE

	sub		eax, [oteFalse]
	jnz		@F

	add		_IP, ecx
	DispatchByteCode

@@:
	; Branch not taken, dispatch next if ToS was boolean true
	cmp		eax, -OTENTRYSIZE			;; true is immediately before false in OT
	jne		@F
	DispatchByteCode

@@:
	;; Error - receiver not a boolean, we don't care about performance of this arm
	dec		_IP							;; We'll retry the conditional test if #mustBeBoolean returns
	add		_SP, OOPSIZE			; Unpop
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>

ELSE
	lea		edx, [ecx-FIRSTSHORTJUMPIFFALSE+2]
	ASSUME	edx:DWORD
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	sub		eax, [oteFalse]				;; Is it false?
	jnz		@F

	; Branch taken (it was false)
	movzx	ecx, [_IP+edx-1]			
	ASSUME	ecx:DWORD
	add		_IP, edx
	jmp		byteCodeTable[ecx*4]

@@: 
	; Branch not taken (it was not false)
	;; Might need xor ecx, ecx here, apparently zeroing forgotten after branch misprediction
	movzx	ecx, [_IP]					;; Load next instruction in prep.
	cmp		eax, -OTENTRYSIZE			;; true is immediately before false in OT
	jne		@F							;; But not true either, so error case

	inc		_IP							;; OK, let's process next instruction
	jmp		byteCodeTable[ecx*4]		;; Off to the next instruction

@@:
	;; Error - receiver not a boolean, we don't care about performance of this arm
	dec		_IP							;; We'll retry the conditional test if #mustBeBoolean returns
	add		_SP, OOPSIZE			; Unpop								;; Undo stack damage
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>	;; And inform the image of the error
ENDIF
ENDBYTECODE shortJumpIfFalse

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ASSUME eax:NOTHING

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unconditional Jumps

;; Note that by performing the decrement of the input poll counter as a series of
;; instructions to load/dec/save rather than dec [mem] we can hide it in the execution
;; of the real work and reduce the number of cycles for a nearJump to 11.
BEGINBYTECODE nearJump
	ASSUME	_IP:PTR BYTE
	
	movsx	eax, [_IP]							; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

	IFDEF _DEBUG
		lea		_IP, [_IP+eax+1]					; Offset 0 is the next instruction (after single byte instruction extension)
		.IF (!edx)
			CallCPP<BYTEPOLL>
		.ENDIF
		DispatchByteCode
	ELSE
		; Optimized pentium form

		movzx	ecx, [_IP+eax+1]
		test	edx, edx
		lea		_IP, [_IP+eax+2]					; Offset 0 is the next instruction (after single byte instruction extension)
		jnz		@F									; If async events pending, go and poll input
		jmp	byteCodeTable[ecx*4]

	@@:		
		dec		_IP
		CallCPPAndLoop	<BYTEPOLL>
	ENDIF
ENDBYTECODE nearJump

; Long jump is fairly rarely used. A noteable exception is in the long inlined sort algorithm implementations
BEGINBYTECODE longJump
	ASSUME	_IP:PTR BYTE
	
	movsx	eax, WORD PTR[_IP]							; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

	IFDEF _DEBUG
		lea		_IP, [_IP+eax+2]					; Offset 0 is the next instruction (after single byte instruction extension)
		.IF (!edx)
			CallCPP<BYTEPOLL>
		.ENDIF
		DispatchByteCode
	ELSE
		; Optimized pentium form

		movzx	ecx, [_IP+eax+2]
		test	edx, edx
		lea		_IP, [_IP+eax+3]					; Offset 0 is the next instruction (after double byte instruction extension)
		jnz		@F									; If async events pending, go and poll input
		jmp	byteCodeTable[ecx*4]

	@@:		
		dec		_IP
		CallCPPAndLoop	<BYTEPOLL>
	ENDIF
ENDBYTECODE longJump

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Conditional Jumps

; A typical use of this byte code is to skip back a loop body when the condition evaluates to false.
; Therefore it makes most sense to optimize the false branch
BEGINBYTECODE nearJumpIfTrue
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	sub		edx, [oteTrue]
	jnz		elseBranch								; Skip to false/error handling (N.B. forward jump)

	; The TOS was true, so the jump is to be followed.

	movsx	eax, BYTE PTR[_IP]						; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

IFDEF _DEBUG
	lea		_IP, [_IP+eax+1]						; Offset 0 is the next instruction (after single byte instruction extension)
	DispatchByteCode
ELSE
	movzx	ecx, BYTE PTR[_IP+eax+1]
	test	edx, edx
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after single byte instruction extension)
	jnz		@F
	jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	
@@:		
	dec		_IP
	CallCPPAndLoop	<BYTEPOLL>
ENDIF

elseBranch:
	; The TOS was not false, so the jump is not to be followed. We must check if TOS is a boolean.

	cmp		edx, OTENTRYSIZE						; false follows true in OT
	jne		@F

	IFDEF _DEBUG
		inc		_IP									; Byte for the jump length
		DispatchByteCode
	ELSE
		; Optimized pentium form
		movzx	ecx, [_IP+1]								; Load instruction after extension byte
		add		_IP, 2									; _IP points to instruction after that
		jmp		byteCodeTable[ecx*4]
	ENDIF

@@:	;; This is the error case - speed not that important
	dec _IP												; Retry the conditional test if #must be boolean returns
	add		_SP, OOPSIZE			; Unpop
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>
ENDBYTECODE nearJumpIfTrue

BEGINBYTECODE nearJumpIfNil
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	cmp		eax, [oteNil]
	jnz		elseBranch

	movsx	eax, BYTE PTR[_IP]						; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

IFDEF _DEBUG
	lea		_IP, [_IP+eax+1]						; Offset 0 is the next instruction (after single byte instruction extension)
	DispatchByteCode
ELSE
	movzx	ecx, BYTE PTR[_IP+eax+1]
	test	edx, edx
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after single byte instruction extension)
	jnz		@F
	jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	
@@:		
	dec		_IP
	CallCPPAndLoop	<BYTEPOLL>
ENDIF

elseBranch:
	IFDEF _DEBUG
		inc		_IP									; Byte for the jump length
		DispatchByteCode
	ELSE
		; Optimized pentium form
		movzx	ecx, [_IP+1]								; Load instruction after extension byte
		add		_IP, 2									; _IP points to instruction after that
		jmp		byteCodeTable[ecx*4]
	ENDIF
ENDBYTECODE nearJumpIfNil

BEGINBYTECODE nearJumpIfNotNil
	mov		eax, [_SP]
	sub		_SP, OOPSIZE
	cmp		eax, [oteNil]
	jz		elseBranch								; If nil then dispatch next instruction

	movsx	eax, BYTE PTR[_IP]						; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

IFDEF _DEBUG
	lea		_IP, [_IP+eax+1]						; Offset 0 is the next instruction (after single byte instruction extension)
	DispatchByteCode
ELSE
	movzx	ecx, BYTE PTR[_IP+eax+1]
	test	edx, edx
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after single byte instruction extension)
	jnz		@F
	jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	
@@:		
	dec		_IP
	CallCPPAndLoop	<BYTEPOLL>
ENDIF

elseBranch:
	; Its nil, dispatch next
	IFDEF _DEBUG
		inc		_IP									; Byte for the jump length
		DispatchByteCode
	ELSE
		movzx	ecx, [_IP+1]								; Load instruction after extension byte
		add		_IP, 2									; _IP points to instruction after that
		jmp		byteCodeTable[ecx*4]
	ENDIF
ENDBYTECODE nearJumpIfNotNil

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Decrement Stack Top Instruction (single byte)
;;
;; This is an optimisation which is equivalent to the sequence Push 1, Send #-

ALIGN 16
BEGINBYTECODE decrementStackTop
	mov		eax, [_SP]									; Load receiver at stack top
	movzx	ecx, [_IP]
	test	al, 1										; Is it a SmallInteger?

	jz		@F											; No, skip primitive response

	sub		eax, SMALLINTONE - 1						; Subtract 1 (without SmallInteger bit)
	jo		overflow									; It overflowed 31-bits?

	mov		[_SP], eax									; Save back as it didn't overflow
	IFDEF _DEBUG
		DispatchByteCode								; Dispatch the next byte code
	ELSE
		inc	_IP
		jmp byteCodeTable[ecx*4]
	ENDIF
														; Doesn't get to here
@@:
	; Not a SmallInteger, send '- 1'.
	mov		[_SP+OOPSIZE], SMALLINTONE
	add     _SP, OOPSIZE
	SendSelectorOneArgToObjectEAX <Pointers.minusSelector>

overflow:
	cmc													; Get carry flag in correct direction for subroutine
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED									; Return to caller with Oop of new Signed Integer in eax
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode

ENDBYTECODE decrementStackTop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Send Byte Codes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Send Special Selector Byte Codes
; These byte codes attempt a primitive response for certain critical
; operations (e.g. adding two numbers). Should the primitive response
; fail, then they fall back on the usual method lookup
; I have replicated the code for many of these byte codes in order
; to avoid a two level dispatch through a second jump table.

; Send a special selector, invoked direct from byte code interpreter
; There are three possible execution paths:
;	1)	The special selector can be directly invoked (all
;		arithmetic primitives and a few of the common selector
;		primitives), and the primitive succeeds. In this case
;		we continue execution with the next bytecode. This makes
;		for very efficient execution of certain operations such
;		as SmallInteger arithmetic.
;	2)	The special selector can be directly invoked, but the
;		primitive routine (or its entry thunk) fails, the fallback
;		being to send the selector to the receiver. This most
;		commonly occurs because the receiver is not the class
;		expected by the optimised case - e.g. #value is sent to
;		an object which is not a BlockClosure.
;	3)	The special selector requires message lookup (i.e. it is
;		not optimised). This applies to all the common selector
;		primitives excluding #==, #value and #value:. 
;		In this case we just send the selector to the receiver through 
;		the normal message lookup.
;
;	Note that a special selector primitive must fail twice before 
;   the actual method is invoked - unless I can do something
;	about that.
;

; Arithmetic operations are very, very, common instruction, and
; consequently the primitive code is inlined. Even so note the
; amount of testing which is necessary because these instructions
; are generated for all arithmetic selectors, regardless of type 
; (even though in some cases the compiler does know whether the receiver or
; argument is a SmallInteger). Anyway the minimum cycle time
; for a SmallInteger addition is 13 machine cycles plus byte
; code dispatching time (8 cycles). Other SmallInteger arithmetic
; and relational operations have cycle times of similar magnitudes
;

BEGINBYTECODE sendArithmeticAdd
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		edx, [_SP]									; Load argument at top of stack (v)
	test	al, 1										; Receiver is a SmallInteger? (u)
	jz		sendMessageToObject							; No, skip primitive response (v)
	test	dl, 1										; Argument is a SmallInteger? (u)
	jz		sendMessageToInteger						; No, skip primitive response (v)
	sub		_SP, OOPSIZE								; Pop argument
	xor		eax, 1										; Clear bottom bit of receiver (arithmetic can then be done without shifting)
	add		eax, edx									; Perform the actual addition
	jo		overflow									; Overflowed 31-bits?

	MPrefetch	
	mov		[_SP], eax									; Save back as it didn't overflow
	DispatchNext

overflow:
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED									; Return to caller with Oop of new Signed Integer in eax
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode

sendMessageToObject:
	; Try sending the '+' selector through normal message lookup
	SendSelectorOneArgToObjectEAX<Pointers.plusSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.plusSelector>

ENDBYTECODE sendArithmeticAdd


BEGINBYTECODE sendArithmeticSubtract
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		edx, [_SP]									; Load argument at top of stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	dl, 1										; Argument is SmallInteger
	jz		sendMessageToInteger						; No, skip primitive response
	sub		_SP, OOPSIZE											; Pop argument	(which is not ref. counted)
	xor		edx, 1										; Remove arg's SmallInteger bit
	sub		eax, edx									; Perform actual subtraction
	jo		pushLargeFromSmallNegAndCarryEAX			; Overflowed 31-bits?
	
	MPrefetch
	mov		[_SP], eax
	DispatchNext

pushLargeFromSmallNegAndCarryEAX:
	cmc													; Get carry flag in correct direction for subroutine
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED	
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode

sendMessageToObject:
	; Try sending the '-' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.minusSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.minusSelector>

ENDBYTECODE sendArithmeticSubtract

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Increment Stack Top Instruction (single byte)
;;
;; This is an optimisation which is equivalent to the sequence Push 1, Send #+
BEGINBYTECODE incrementStackTop
	;; N.B. This is highly optimized for the Pentium processor, hence use of EAX as quicker to test accumulator
	;; against immediate, and strange instruction ordering
	mov		eax, [_SP]								; Load receiver at stack top
	movzx	ecx, [_IP]								; Load next instruction for most common smallinteger inc. case
	test	al, 1									; Is it a SmallInteger?

	jz		@F										; No, skip primitive response

	add		eax, SMALLINTONE - 1					; Add one (without SmallInteger bit)
	jo		overflow								; It overflowed 31-bits?

	mov		[_SP], eax								; Save back as it didn't overflow
	IFDEF _DEBUG
		DispatchByteCode							; Dispatch the next byte code
	ELSE
		inc	_IP
		jmp byteCodeTable[ecx*4]
	ENDIF
													; Doesn't get to here
@@:
	; Not a SmallInteger, send '+ 1'.
	mov		[_SP+OOPSIZE], SMALLINTONE
	add     _SP, OOPSIZE
	SendSelectorOneArgToObjectEAX <Pointers.plusSelector>

overflow:
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED									; Return to caller with Oop of new Signed Integer in eax
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode
ENDBYTECODE incrementStackTop

BEGINBYTECODE sendArithmeticLessThan
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default - not less than arg
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver < arg?
	cmovl	edx, [oteTrue]
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '<' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.lessThanSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.lessThanSelector>

ENDBYTECODE sendArithmeticLessThan

; A typical use of this byte code is to skip back a loop body when the condition evaluates to false.
; Therefore it makes most sense to optimize the false branch
BEGINBYTECODE nearJumpIfFalse
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	sub		edx, [oteFalse]
	jnz		elseBranch								; Skip to true case/error handling (N.B. forward jump)

	; The TOS was false, so the jump is to be followed.

	movsx	eax, BYTE PTR[_IP]						; Sign extend instruction argument byte (offset) into EAX
	mov		edx, [ASYNCPENDING]

IFDEF _DEBUG
	lea		_IP, [_IP+eax+1]						; Offset 0 is the next instruction (after single byte instruction extension)
	DispatchByteCode
ELSE
	movzx	ecx, BYTE PTR[_IP+eax+1]
	test	edx, edx
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after single byte instruction extension)
	jnz		@F
	jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
	
@@:		
	dec		_IP
	CallCPPAndLoop	<BYTEPOLL>
ENDIF

elseBranch:
	; The TOS was not false, so the jump is not to be followed. We must check if TOS is a boolean.

	cmp		edx, -OTENTRYSIZE						; false follows true in OT
	jne		@F

	IFDEF _DEBUG
		inc		_IP									; Byte for the jump length
		DispatchByteCode
	ELSE
		; Optimized pentium form
		movzx	ecx, [_IP+1]								; Load instruction after extension byte
		add		_IP, 2									; _IP points to instruction after that
		jmp		byteCodeTable[ecx*4]
	ENDIF

@@:	;; This is the error case - speed not that important
	dec _IP												; Retry the conditional test if #must be boolean returns
	add		_SP, OOPSIZE			; Unpop
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>
ENDBYTECODE nearJumpIfFalse

; Inlines primitive coding for SmallInteger
BEGINBYTECODE sendArithmeticLessOrEqual
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default, true
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver <= arg?
	cmovle	edx, [oteTrue]								;
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '<=' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.lessOrEqualSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.lessOrEqualSelector>

ENDBYTECODE sendArithmeticLessOrEqual

BEGINBYTECODE sendArithmeticGreaterThan
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default, true
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver > arg?
	cmovg	edx, [oteTrue]								;
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '>' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.greaterThanSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.greaterThanSelector>

ENDBYTECODE sendArithmeticGreaterThan

; Inlines primitive coding for SmallInteger
BEGINBYTECODE sendArithmeticGreaterOrEqual
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default, true
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver >= arg?
	cmovge	edx, [oteTrue]								;
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '>=' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.greaterOrEqualSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.greaterOrEqualSelector>

ENDBYTECODE sendArithmeticGreaterOrEqual


BEGINBYTECODE sendArithmeticEqual
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default, true
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver = arg?
	cmove	edx, [oteTrue]								;
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '=' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.equalSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.equalSelector>

ENDBYTECODE sendArithmeticEqual


BEGINBYTECODE sendArithmeticNotEqual
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		ecx, [_SP]									; Load argument from stack
	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	cl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response
	mov		edx, [oteFalse]								; Default, true
	sub		_SP, OOPSIZE								; Pop argument
	cmp		eax, ecx									; receiver != arg?
	cmovne	edx, [oteTrue]								;
	MPrefetch
	mov		[_SP], edx
	DispatchNext

sendMessageToObject:
	; Try sending the '~=' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.notEqualSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.notEqualSelector>

ENDBYTECODE sendArithmeticNotEqual


BEGINBYTECODE sendArithmeticMultiply
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		edx, [_SP]									; Load argument from stack

	test	al, 1										; Is it a SmallInteger?
	jz		sendMessageToObject							; Receiver not SmallInteger, skip primitive response

	sar		edx, 1										; Extract integer value of arg
	jnc		sendMessageToInteger						; Arg not a SmallInteger

	xor		eax, 1										; Remove SmallInteger flag
	imul	edx
	jo		sendMessageToInteger						; If overflowed SmallInteger bits then skip primitive response
	
	xor		ecx, ecx
	or		eax, 1										; Replace SmallInteger flag bit
	
	mov		cl, [_IP]
	mov		[_SP-OOPSIZE], eax							; Replace receiver with answer
	
	sub		_SP, OOPSIZE
	IFDEF _DEBUG
		DispatchByteCode
	ELSE
		inc		_IP
		jmp		byteCodeTable[ecx*4]
	ENDIF

sendMessageToObject:
	; Try sending the '*' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.multiplySelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.multiplySelector>

ENDBYTECODE sendArithmeticMultiply


;; N.B. Some difference here - we shift receiver, not just test bottom bit
BEGINBYTECODE sendArithmeticDivide
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument	(v - pairs)
	mov		ecx, [_SP]									; Load argument from stack	(u)
	sar		eax, 1										; Is it a SmallInteger?	(u)
	jnc		sendMessageToObject							; No, skip primitive response (v - pairs)
	sar		ecx, 1										; Extract integer value of arg (u)
	jnc		sendMessageToInteger						; Arg not a SmallInteger (v - pairs)
	mov		edx, eax									; Sign extend ...		(u)
	
	; It is more time consuming to set up corectly for the exception handler (we must
	; set the divide selector so that the primitive gets invoked), so rather than
	; rely on that, we explicitly test and fall back on the primitive, which does use
	; the handler
	jz		sendMessageToInteger						; Catch division by zero	(v - pairs)
	sar		edx, 31										; ... into edx (instead of CDQ)

	idiv	ecx
	test	edx, edx									; Test remainder in edx	 (u)
	jnz		sendMessageToInteger						; Inexact, fail primitive	(v - pairs)

	sub		_SP, OOPSIZE											; Pop argument	(which is not ref. counted) (u)

	; Note that an overflow could occur if min. SmallInteger divided by -1
	add		eax, eax									; Shift for SmallInteger
	jo		overflow
	or		eax, 1										; Add SmallInteger bit

	MPrefetch
	mov		[_SP], eax									; Replace stack top integer
	DispatchNext

sendMessageToObject:
	; Try sending the '/' selector through normal message lookup
	add		eax, eax									; Reverse the right shift
	SendSelectorOneArgToObjectEAX <Pointers.divideSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.divideSelector>

overflow:
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED	
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode

ENDBYTECODE sendArithmeticDivide


;; N.B. Some difference here - we shift receiver, not just test bottom bit
BEGINBYTECODE sendArithmeticMod
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument	(v - pairs)
	mov		ecx, [_SP]									; Load argument from stack			(u)
	sar		eax, 1										; Is it a SmallInteger?				(u)
	jnc		sendMessageToObject							; No, skip primitive response		(v - pairs)
	sar		ecx, 1										; Extract integer value of arg		(u)
	jnc		sendMessageToInteger						; Arg not a SmallInteger			(v - pairs)
	mov		edx, eax									; Sign extend...					(u)
	
	; It is more time consuming to set up corectly for the exception handler (we must
	; set the divide selector so that the primitive gets invoked), so rather than
	; rely on that, we explicitly test and fall back on the primitive, which does use
	; the handler
	jz		sendMessageToInteger						; Catch division by zero			(v - pairs)
	
	sar		edx, 31										; ... into edx (faster than CDQ)	(u)
	sub		_SP, OOPSIZE											; Pop argument	(which is not ref. counted)	(v - pairs)

	idiv      ecx

	test      eax,eax									; test Quotient						(u)
	jg        @F										; If positive, skip adjust			(v - pairs)
	test      edx,edx									; test remainder					(u)
	jz        @F										; if exact skip adjust				(v - pairs)
	xor       ecx,edx									; test sign of numerator and denominator	(u)
	jns       @F										; non-negative, skip adjust					(v - pairs)
	xor       ecx,edx									; reverse previous XOR				(no pair, write, read)
	add       edx,ecx									; adjust remainder by numerator
@@:
	lea		eax, [edx+edx+1]
	;; N.B. Pop happens above
	MPrefetch
	mov		[_SP], eax									; Replace stack top integer with remainder
	DispatchNext

sendMessageToObject:
	; Try sending the '\\' selector through normal message lookup
	add		eax, eax									; Reverse the right shift
	SendSelectorOneArgToObjectEAX <Pointers.modSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.modSelector>

ENDBYTECODE sendArithmeticMod


;; N.B. Some difference here - we shift receiver, not just test bottom bit
BEGINBYTECODE sendArithmeticDiv
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument	(u)
	mov		ecx, [_SP]									; Load argument from stack		(v)
	sar		eax, 1										; Is it a SmallInteger?			(u)
	jnc		sendMessageToObject							; No, skip primitive response	(v)
	sar		ecx, 1										; Extract integer value of arg	(u - not pairable in v-pipe)
	jnc		sendMessageToInteger						; Arg not a SmallInteger		(v - pairs)
	mov		edx, eax									; Sign extend ...				(u)
	
	; It is more time consuming to set up corectly for the exception handler (we must
	; set the divide selector so that the primitive gets invoked), so rather than
	; rely on that, we explicitly test and fall back on the primitive, which does use
	; the handler
	jz		sendMessageToInteger						; Catch division by zero		(v - pairs)
	
	sar		edx, 31										; ... into edx					(u)
	idiv	ecx											; Sadly IDIV does not change the flag in a predictable way (u)
	sub		_SP, OOPSIZE											; Pop argument	(which is not ref. counted) (u)

	test	eax, eax									; Quotient?
	jg		@F											; greater than zero
	test	edx, edx									; Remainder?
	jz		@F											; zero
	xor		ecx,edx										; numerator/remainder signed
	jns		@F											; no, skip
	dec		eax											; adjust negative

@@:
	add		eax, eax
	jo		overflow									; Overflow possible if divide by -1
	or		eax, 1										; Add SmallInteger bit
	mov		[_SP], eax									; (u) Replace stack top integer
	DispatchByteCode

sendMessageToObject:
	; Try sending the '//' selector through normal message lookup
	add		eax, eax									; Reverse the right shift
	SendSelectorOneArgToObjectEAX <Pointers.divSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.divSelector>

overflow:
	mov		ecx, eax
	rcr		ecx, 1										; Revert to non-shifted value
	call	LINEWSIGNED									; Return to caller with Oop of new Signed Integer in eax
	mov		[_SP], eax									; Replace ToS with new object
	AddToZct <a>
	DispatchByteCode

ENDBYTECODE sendArithmeticDiv


;; BitShift is a bit too complicated to expand in-line at present, due to the rather crap overflow
;; detection - this seems to make it no faster than multiplication, which is crap of course.
BEGINBYTECODE sendArithmeticBitShift
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	test	al, 1										; Receiver is a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	call	arithmeticBitShift							; Try primitive response
	test	eax, eax									; Primitive response failed (eax==zero)?
	jz		sendMessage									; Failed, so send the message

	MPrefetch
	mov		_SP, eax
	DispatchNext

sendMessage:
	SendSelectorOneArgToInteger <Pointers.bitShiftSelector>

sendMessageToObject:
	; Try sending the 'bitShift:' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.bitShiftSelector>

ENDBYTECODE sendArithmeticBitShift


; bitAnd: is a very fast instruction!
BEGINBYTECODE sendArithmeticBitAnd
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		edx, [_SP]
	and		eax, edx									; Perform the bitwise op with arg
	test	al, 1										; Result a SmallInteger
	jz		sendMessage									; No, receiver or Arg not a SmallInt

	mov		[_SP-OOPSIZE], eax							; Replace stack top integer with result
	PopDispatchByteCode

sendMessage:
	; Try sending the 'bitAnd:' selector through normal message lookup
	SendSelectorOneArg <Pointers.bitAndSelector>

ENDBYTECODE sendArithmeticBitAnd


BEGINBYTECODE sendArithmeticBitOr
	mov		eax, [_SP-OOPSIZE]							; Access receiver beneath argument
	mov		edx, [_SP]									; Load argument from stack
	test	al, 1										; Receiver is a SmallInteger?
	jz		sendMessageToObject							; No, skip primitive response
	test	dl, 1										; Arg is a SmallInteger?
	jz		sendMessageToInteger						; No, skip primitive response

	; There is no need to shift or clear the SmallInteger flag
	or		eax, edx									; Perform the actual bitwise op

	mov		[_SP-OOPSIZE], eax							; Replace stack top integer with boolean result
	PopDispatchByteCode

sendMessageToObject:
	; Try sending the 'bitOr:' selector through normal message lookup
	SendSelectorOneArgToObjectEAX <Pointers.bitOrSelector>

sendMessageToInteger:
	SendSelectorOneArgToInteger <Pointers.bitOrSelector>

ENDBYTECODE sendArithmeticBitOr

;
; object == object?
; N.B. Identity comparisons do not fail, so cannot be overridden. The actual primitive (not used
; here) may be invoked for other selectors so we still need it. #== is never 
; really sent to objects, but is implemented here directly (it CANNOT be overridden)
; as the VM never sends this selector directly (only if #perform'd).
;
BEGINBYTECODE shortSpecialSendIdentical
	mov		eax, [_SP-OOPSIZE]							; Load receiver into eax
	mov		ecx, [_SP]									; Get argument at stack top into ecx
	sub		_SP, OOPSIZE								; POP
	mov		edx, [oteFalse]								; Load false (default answer)
	cmp		eax, ecx									; receiver == arg?
	cmove	edx, [oteTrue]
	MPrefetch
	mov		[_SP], edx									; Overwrite stack top with true/false
	DispatchNext										; Dispatch the next byte code
ENDBYTECODE shortSpecialSendIdentical

;
; object ~~ object?
;
BEGINBYTECODE shortSpecialSendNotIdentical
	mov		eax, [_SP-OOPSIZE]							; Load receiver into eax
	mov		ecx, [_SP]									; Get argument at stack top into ecx
	sub		_SP, OOPSIZE								; POP
	mov		edx, [oteFalse]								; Load false (default answer)
	cmp		eax, ecx									; receiver ~~ arg?
	cmovne	edx, [oteTrue]
	MPrefetch
	mov		[_SP], edx									; Overwrite stack top with true/false
	DispatchNext										; Dispatch the next byte code
ENDBYTECODE shortSpecialSendNotIdentical

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The following special selectors can have their selectors changed, or they
;; can be removed. They are open coded for performance reasons (otherwise not much
;; point having them at all).

; This implementation means we CAN override #class (not Smalltalk-80, but supported by modern Smalltalks)
BEGINBYTECODE shortSpecialSend0
	SendSelectorNoArgs <Pointers.specialSelectors[0*OOPSIZE]>		; class
ENDBYTECODE shortSpecialSend0

BEGINBYTECODE shortSpecialSend1
	SendSelectorNoArgs <Pointers.specialSelectors[1*OOPSIZE]>		; size
ENDBYTECODE shortSpecialSend1

BEGINBYTECODE shortSpecialSend2
	SendSelectorNoArgs <Pointers.specialSelectors[2*OOPSIZE]>		; new
ENDBYTECODE shortSpecialSend2

BEGINBYTECODE shortSpecialSend3
	SendSelectorOneArg <Pointers.specialSelectors[3*OOPSIZE]>		; new:
ENDBYTECODE shortSpecialSend3

BEGINBYTECODE shortSpecialSendBasicNew
	SendSelectorOneArg <Pointers.basicNewSelector>					; basicNew:
ENDBYTECODE shortSpecialSendBasicNew

BEGINBYTECODE shortSpecialSendBasicSize
	mov		eax, [_SP]								; Load receiver into eax

	test	al, 1									; Is it a SmallInteger?
	jz		notSmallInteger

	MPrefetch
	mov		[_SP], SMALLINTZERO						; Size of SmallInteger is zero
	DispatchNext

notSmallInteger:
	ASSUME	eax:PTR OTE								; eax points at receiver OTE

	mov		ecx, eax
	ASSUME	ecx:PTR OTE

	;; Get the byte length of the object (into eax)
	mov		edx, [eax].m_location					; Load object address into edx
	ASSUME	edx:PTR Object							; edx points at receiver object
	mov		eax, [eax].m_size
	ASSUME	eax:NOTHING

	mov		edx, [ecx].m_oteClass					; Get class Oop	from Object into edx
	ASSUME	edx:PTR OTE								; edx now points at class OTE

	and		eax, 7fffffffh							; Mask out sign bit of size (used to mark const objects)

	test	[ecx].m_flags, MASK m_pointer			; ote->isPointers?

	mov		edx, [edx].m_location					; Load address of class object into edx
	ASSUME	edx:PTR Behavior						; edx now points at class object

	jz		isBytes									; Byte objects cannot have inst vars, so can skip next bit

	;; Calculate the length of the indexed part of a pointer object

	mov		edx, [edx].m_instanceSpec				; Load InstanceSpecification into edx
	ASSUME	edx:NOTHING
	and		edx, MASK m_fixedFields					; Mask out everything but inst. var. count
	
	add		edx, edx								; Convert to byte size (already *2 since SmallInteger)
	sub		eax, edx								; Calculate length of variable part in bytes
	shr		eax, 1									; Divide byte size by 2 to get MWORD size as SmallInteger
	or		eax, 1									; Add SmallInteger flag
	MPrefetch
	mov		[_SP], eax								; Replace stack top with indexed pointer size
	DispatchNext

isBytes:
	ASSUME	ecx:PTR OTE								; ecx is the receiver OTE
	ASSUME  edx:PTR Behavior						; edx points to the receiver's class object
	ASSUME	eax:DWORD								; eax is the size in bytes

	test	[ecx].m_flags, MASK m_weakOrZ			; Is a string?
	jz		@F

	; Its a string, temporarily use the encoding to determine the element size (in future revised InstanceSpec should be used)

	movzx   edx, [edx].m_instanceSpec.m_extraSpec
	dec     edx  
	sub     edx,1  
	je      words

	sub     edx,1  
	jne     @F

	shr     eax, 2  

@@:
	add		eax, eax
words:
	or		eax, 1
	MPrefetch
	mov		[_SP], eax								; Replace stack top with byte size
	DispatchNext

ENDBYTECODE shortSpecialSendBasicSize

BEGINBYTECODE shortSpecialSendBasicAt
	mov		eax, [_SP-OOPSIZE]					; Access receiver under argument
	mov		edx, [_SP]							; Load argument from stack

	test	al, 1
	jnz		sendMessageToSmallInteger			; Its a SmallInteger, probably an error, try sending it #basicAt:

   	ASSUME	eax:PTR OTE							; eax is receiver OTE
	mov		ecx, [eax].m_oteClass				; Get class Oop from OTE into eax for later use
	ASSUME	ecx:PTR OTE

	sar		edx, 1								; Argument is a SmallInteger?
	jnc		sendMessageToClass					; Arg not a SmallInteger, send the message
	jle		sendMessageToClass					; Index out of bounds (<= 0)
	     	
	test	[eax].m_flags, MASK m_pointer		; Test pointer bit of object table entry
	jz		byteObjectAt						; Contains bytes? Yes, skip to byte access code

pointerAt:
	ASSUME eax:PTR OTE							; EAX is receiver Oop
	ASSUME ecx:PTR OTE							; ECX is class Oop
	ASSUME edx:DWORD							; EDX is offset

	push	ebx
	; Array of pointers?
	mov		ebx, [eax].m_size					; Load size into eax
	ASSUME	ebx:DWORD

	mov		ecx, [ecx].m_location				; Load address of class object into eax from OTE at ecx
	ASSUME	ecx:PTR Behavior
	
	and		ebx, 7fffffffh						; Ignore the sign bit of the size (used to mark const objects)
	shr		ebx, 2								; ecx = total Oop size (bytesize div 4)

	mov		ecx, [ecx].m_instanceSpec			; Load Instancespecification into edx
	ASSUME	ecx:DWORD

	and		ecx, MASK m_fixedFields				; Mask off flags
	shr		ecx, 1								; Convert from SmallInteger
	add		edx, ecx							; Add fixed offset for inst vars
	
	cmp		edx, ebx							; Index <= size (still in ebx)?
	pop		ebx

	ja		indexTooLarge						; No, out of bounds

	mov		eax, [eax].m_location				; Load address of receiver into eax
	ASSUME	eax:PTR Oop

	sub		_SP, OOPSIZE
	MPrefetch

	mov		eax, [eax+edx*OOPSIZE-OOPSIZE]		; Load Oop of element at required index
	mov		[_SP], eax							; And overwrite receiver in stack with it

	DispatchNext

;byteObjectAt:
;	ASSUME	eax:PTR OTE							; EAX is Oop of receiver
;	ASSUME	edx:DWORD							; EDX is the index
;	ASSUME	ecx:PTR OTE							; ECX is the Oop of the receiver's class
;
;	mov		ecx, [eax].m_size
;	ASSUME	ecx:DWORD
;	and		ecx, 7fffffffh						; Ignore sign bit (used to mark const objects)
;	
;	cmp		edx, ecx							; Bounds check
;	mov		ecx, [eax].m_location				; Load object address into ecx on expection it will be in bounds
;	ASSUME	ecx:PTR ByteArray					; EAX points at receiver
;	ja		indexTooLarge						; Index out of bounds (>= size)
;	
;	movzx	eax, BYTE PTR[ecx+edx-1]			; Load required byte, zero extending
;	ASSUME	eax:NOTHING
;
;	MPrefetch
;
;	lea		eax, [eax+eax+1]					; Convert to SmallInteger
;	mov		[_SP-OOPSIZE], eax					; Overwrite receiver with result. No need to count as SmallInteger
;
;	sub		_SP, OOPSIZE						; Pop arg off stack
;
;	DispatchNext

sendMessageToSmallInteger:						; Sent #basicAt: to a SmallInteger, probably an error
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		sendMessageToClass

indexTooLarge:
	ASSUME	eax:PTR OTE
	mov		ecx, [eax].m_oteClass

byteObjectAt:
sendMessageToClass:
	ASSUME	eax:Oop										; EAX is receiver, although we don't need it here
	ASSUME	ecx:PTR OTE									; ECX contains class

	mov 	edx, Pointers.specialSelectors[10*OOPSIZE]	; basicAt:
	mov		[STACKPOINTER], _SP		 					; Save down interpreter stack pointer, e.g. for C routine
	pushd	1											; 1 argument
	mov		[MESSAGE], edx								;; Set the MESSAGE global
	jmp		execMethodOfClass							; Jump to routine to exec class>>message in ECX>>EDX
ENDBYTECODE shortSpecialSendBasicAt

; #basicAt:put:
BEGINBYTECODE shortSpecialSendBasicAtPut
	mov		ecx, [_SP-OOPSIZE*2]				; Access receiver under arguments
	mov		edx, [_SP-OOPSIZE]					; Load index argument from stack
	ASSUME	ecx:PTR OTE

	test	cl, 1
	jnz		sendMessage							; Its a SmallInteger, send it #basicAt:

	sar		edx, 1								; Argument is a SmallInteger?
	jnc		sendMessage	 						; No, send the message
	jle		sendMessage							; Index out of bounds (<= 0)

	test	[ecx].m_flags, MASK m_pointer
	jz		byteObjectAtPut						; Skip to code for storing bytes

	mov		eax, [ecx].m_oteClass				; Get class Oop	from OTE into eax
	ASSUME	eax:PTR OTE
	
	push	ebx
	mov		eax, [eax].m_location				; Load address of class object into eax
	ASSUME	eax:PTR Behavior

	mov		ebx, [ecx].m_size					; Load size of receiver into ebx
	ASSUME	ebx:SDWORD							; N.B. DON'T mask out the immutable bit here, so size negative if const object

	mov		eax, [eax].m_instanceSpec			; Load Instancespecification into edx
	ASSUME	eax:DWORD

	sar		ebx, 2								; ebx = total Oop size
	
	and		eax, MASK m_fixedFields				; Mask off flags
	shr		eax, 1								; Convert from SmallInteger
	add		edx, eax							; Add fixed offset for inst vars

	cmp		edx, ebx							; Index < size (still in ebx)?

	mov		eax, [ecx].m_location
	ASSUME	eax:PTR Object

	pop		ebx

	jg		sendMessage							; No, out of bounds
	
	lea		eax, [eax+edx*OOPSIZE-OOPSIZE]		; Get address of slot to update into EAX

	mov		edx, [_SP]							; Load value to write
	ASSUME	edx:PTR OTE
	
	; We must inc ref. count, as we are storing into a heap allocated object here
	CountUpOopIn <d>
	
	; Exchange Oop of overwritten value with new value
	mov		ecx, [eax]
	mov		[eax], edx

	; Must count down overwritten value, as it was in a heap object slot
	CountDownOopIn <c>							

	; count down destroys eax, ecx, and edx, so have to wait til now for prefetch
	
	mov		eax, [_SP]							; Reload new value into eax
	MPrefetch
	mov		[_SP-OOPSIZE*2], eax				; And overwrite receiver in stack with new value
	sub		_SP, OOPSIZE*2						; Pop args
	
	DispatchNext

byteObjectAtPut:
;	ASSUME	ecx:PTR OTE						; ECX is receiver Oop (known byte object)
;	ASSUME	edx:DWORD						; EDX is index
;
;	mov		eax, [ecx].m_location			; Load object address into eax
;	ASSUME	eax:PTR ByteArray				; EAX is pointer to byte object
;	
;	cmp		edx, [ecx].m_size				; Compare offset+HEADERSIZE with object size
;	jg		sendMessage						; Index out of bounds (> size)
;
;	mov		ecx, [_SP]						; Load value to store from stack top
;	
;	add		eax, edx						; Calculate address of byte to write
;	ASSUME	eax:PTR BYTE
;	ASSUME	edx:NOTHING						; EDX is now free
;
;	mov		edx, ecx						; Save value to return later
;	ASSUME	edx:DWORD
;	sar		ecx, 1							; Convert to real integer value
;	jnc		sendMessage						; Not a SmallInteger
;
;	cmp		ecx, 0FFh
;	ja		sendMessage						; Used unsigned comparison for 0<=ecx<=255
;
;	mov		[eax-1], cl						; Store byte into receiver
;	ASSUME	ecx:NOTHING
;
;	MPrefetch
;
;	mov		[_SP-OOPSIZE*2], edx			; Overwrite receiver with value for return
;	sub		_SP, OOPSIZE*2					; Pop Args
;
;	DispatchNext
;
sendMessage:
	; This is an unlikely error case (non-indexable receiver, out of bounds), so we don't care about perf here
	SendSelectorTwoArgs <Pointers.specialSelectors[11*OOPSIZE]>			; #basicAt:put:
ENDBYTECODE shortSpecialSendBasicAtPut

BEGINBYTECODE shortSpecialSendBasicClass
	mov		ecx, [_SP]								; Load receiver into ecx
	test	cl, 1
	jne		smallInteger

	ASSUME	ecx:PTR OTE
	mov		eax, [ecx].m_oteClass					; Get class Oop	from Object into eax
	MPrefetch
	mov		[_SP], eax								; Replace stack top with class Oop
	DispatchNext

smallInteger:	
	mov		eax, [Pointers.ClassSmallInteger]
	MPrefetch
	mov		[_SP], eax								; Replace stack top with class Oop
	DispatchNext

ENDBYTECODE shortSpecialSendBasicClass

BEGINBYTECODE shortSpecialSendIsNil
	mov		eax, [oteNil]
	mov		edx, [oteFalse]
	cmp		eax, [_SP]
	cmove	edx, [oteTrue]
	MPrefetch
	mov		[_SP], edx								; Overwrite stack top with false
	DispatchNext
ENDBYTECODE shortSpecialSendIsNil

BEGINBYTECODE shortSpecialSendNotNil
	mov		eax, [oteNil]
	mov		edx, [oteFalse]
	cmp		eax, [_SP]
	cmovne	edx, [oteTrue]
	MPrefetch
	mov		[_SP], edx								; Overwrite stack top with false
	DispatchNext
ENDBYTECODE shortSpecialSendNotNil

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
BEGINBYTECODE isZero
	mov		eax, [oteFalse]								; Load false (default answer)
	cmp		[_SP], SMALLINTZERO							; "receiver" is 0?
	cmove	eax, [oteTrue]
	MPrefetch
	mov		[_SP], eax									; Overwrite stack top with true/false
	DispatchNext
ENDBYTECODE isZero

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
BEGINBYTECODE shortSpecialSendNot
	mov		eax, [_SP]		
	cmp		eax, [oteFalse]
	je		isFalse

	cmp		eax, [oteTrue]
	jne		notABoolean

	; true, answer false
	add		eax, OTENTRYSIZE		; false immediately after true in OT
	MPrefetch
	mov		[_SP], eax
	DispatchNext

isFalse:
	; false, answer true
	sub		eax, OTENTRYSIZE		; true is immediately before false in OT
	MPrefetch
	mov		[_SP], eax									
	DispatchNext

notABoolean:
	SendSelectorNoArgs <Pointers.notSymbol>
ENDBYTECODE shortSpecialSendNot

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Block Copy Instruction (quad byte)

; Calls C++ block copy routine (TODO - Implement entirely in assembler)
; Note that blockCopy uses _IP, but not _SP or _BP

BEGINBYTECODE blockCopy
	xor		ecx, ecx
	mov		ecx, DWORD PTR[_IP]						; Load extension into
	movsx	edx, WORD PTR[_IP+4]					; Load jump offset into EDX
	add		_IP, 6
	mov		[INSTRUCTIONPOINTER], _IP				; Save down IP (points at start of block byte codes)...
	mov		[STACKPOINTER], _SP		 				; ...and SP (needed in case any values to copy off stack)
	add		_IP, edx								; Prepare to jump to first byte code after block
	call	BLOCKCOPY								; Create new block (returned in EAX)
	mov		_SP, OOPSIZE							
	add		_SP, [STACKPOINTER]						; blockCopy may have adjusted stack to remove copied values
	mov		[_SP], eax								; New block pushed onto stack
	AddToZct <a>
	DispatchByteCode
ENDBYTECODE blockCopy

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ShortSendXArgsN MACRO x, index
	LOCAL sendToSmallInteger

	mov		edx, [pMethod]							; Load current method
	ASSUME	edx:PTR CompiledCodeObj
	LoadStackValueInto <x>,<eax>					;; Load receiver into EAX (under arg)

	push DWORD	x									; N arguments
	mov		[STACKPOINTER], _SP		 				; Save down stack pointer (needed for DNU and C++ primitives)

	mov     edx, [edx].m_aLiterals[&index*OOPSIZE]	; Load selector Oop into edx
	test	al, 1									; Test for immediate receiver (used later)

	mov		[MESSAGE], edx							; Save down message
	jnz		sendToSmallInteger						; If a SmallInteger need to load class differently

	ASSUME	eax:PTR OTE
	
	mov		ecx, [eax].m_oteClass					; Get class into ECX
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX

sendToSmallInteger:
	ASSUME	eax:DWORD

	mov		ecx, [Pointers.ClassSmallInteger]

	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
	ASSUME	ecx:NOTHING
ENDM

ShortSendXArgs MACRO x, offset
	LOCAL sendToSmallInteger

	; ecx-offset is the literal index
	mov		edx, [pMethod]							;; Load current method
	ASSUME	edx:PTR CompiledCodeObj
	mov		eax, [_SP-(OOPSIZE*x)]					;; Load receiver into EAX (under arg(s))
	
	test	al, 1									;; Test for immediate receiver (used later)
	mov		[STACKPOINTER], _SP		 				;; Save down stack pointer (needed for DNU and C++ primitives)

	mov     edx, [edx].m_aLiterals[(ecx*OOPSIZE)-(offset*OOPSIZE)]	;; Load selector Oop into ecx
	jnz		sendToSmallInteger						;; If a SmallInteger need to load class differently

	ASSUME	eax:PTR OTE

	pushd	x										;; X arguments
	mov		[MESSAGE], edx							;; Save down message
	
	mov		ecx, [eax].m_oteClass					;; Get class into ECX
	jmp		execMethodOfClass						;; Jump to routine to exec class>>message in ECX>>EDX

sendToSmallInteger:
	ASSUME	eax:DWORD

	pushd	x
	mov		[MESSAGE], edx

	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass						;; Jump to routine to exec class>>message in ECX>>EDX

	ASSUME	ecx:NOTHING
ENDM

BEGINBYTECODE shortSendNoArgs
	ShortSendXArgs <0>, <FIRSTSHORTSENDNOARGS>
ENDBYTECODE shortSendNoArgs

BEGINBYTECODE shortSendSelfNoArgs
	mov		eax, [_BP-OOPSIZE]						; Access receiver at _BP-1

	; ecx-offset is the literal index
	mov		edx, [pMethod]							; Load current method
	ASSUME	edx:PTR CompiledCodeObj

	PushOop <a>										; push receiver
	
	test	al, 1									; Test for immediate receiver (used later)
	mov		[STACKPOINTER], _SP		 				; Save down stack pointer (needed for DNU and C++ primitives)

	mov     edx, [edx].m_aLiterals[(ecx*OOPSIZE)-(FIRSTSHORTSENDSELFNOARGS*OOPSIZE)]		; Load selector Oop into ecx

	pushd	0										; 0 arguments
	mov		[MESSAGE], edx							; Save down message

	jnz		@F										; If a SmallInteger need to load class differently
	mov		ecx, (OTE PTR[eax]).m_oteClass			; Get class into ECX
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
@@:
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX

	ASSUME	ecx:NOTHING
ENDBYTECODE shortSendSelfNoArgs

BEGINBYTECODE shortSendOneArg
	ShortSendXArgs <1>, <FIRSTSHORTSENDONEARG>
ENDBYTECODE shortSendOneArg

BEGINBYTECODE shortSendTwoArgs
	ShortSendXArgs <00000002h>, <FIRSTSHORTSENDTWOARGS>
ENDBYTECODE shortSendTwoArgs

ASSUME edx:NOTHING

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Send Instruction  (double byte)
;;
;; Extension specifies argument count and selector literal index (encoded into a byte as follows 111 11111)

SendLiteralECXinEAXwithEDXArgs MACRO
	LOCAL sendToSmallInteger

	ASSUME	eax:PTR CompiledCodeObj
	ASSUME	ecx:DWORD
	ASSUME	edx:DWORD

	pushd	edx								; N arguments
	neg		edx								; Negate in order to access receiver under args

	; Load selector Oop into ecx from literal frame of method pointed at by EAX
	mov     ecx, [eax].m_aLiterals[ecx*OOPSIZE]
	ASSUME	eax:NOTHING						; Ptr to method no longer required
	mov		[STACKPOINTER], _SP		 		; Save down SP for DNU and prims
	mov		eax, [_SP+(edx*OOPSIZE)]		; Load receiver into EAX (under args) (EDX now free)

	mov		[MESSAGE], ecx					; Set the MESSAGE global
	test	al, 1							; Is the receiver a SmallInteger
	
	mov		edx, ecx						; Move message selector into edx (ECX now free)
	jnz		sendToSmallInteger				; Branch if receiver is a SmallInteger

	ASSUME	eax:PTR OTE						; Receiver is an object
	mov		ecx, [eax].m_oteClass			; Get the class of the Object
	jmp		execMethodOfClass				; Jump to routine to exec class>>message in ECX>>EDX

sendToSmallInteger:
	ASSUME	eax:SDWORD						; Receiver is a SmallInteger

	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass				; Jump to routine to exec class>>message in ECX>>EDX
ENDM

; Optimized for Pentium (perfectly paired - 8 instructions in 4 cycles)
BEGINBYTECODE Send
	movzx	ecx, [_IP]						; Get next byte code (top 3 bytes of ecx still 0)
	mov		eax, [pMethod]					; Load Oop of current method
	mov		edx, ecx						; EDX = descriptor
	and		ecx, 01Fh						; bottom 5 bits are literal index
	shr		edx, 5							; edx now contains argCount
	inc		_IP

	SendLiteralECXinEAXwithEDXArgs
ENDBYTECODE Send

BEGINBYTECODE sendTempNoArgs
	movzx	edx, [_IP]								; Get next byte code
	mov		eax, [pMethod]							; Load Oop of current method
	ASSUME	eax:PTR CompiledCodeObj
	mov		ecx, edx								; 
	and		edx, 01Fh								; bottom 5 bits are literal index
	shr		ecx, 5									; ecx now contains temp index (3 bits)
	mov     edx, [eax].m_aLiterals[edx*OOPSIZE]
	ASSUME	eax:NOTHING								; Ptr to method no longer required
	inc		_IP
	mov     eax, [_BP+ecx*OOPSIZE]					; Load temp var Oop from _BP into EAX
	add		_SP, OOPSIZE

	test	al, 1									; Test for immediate receiver (used later)
	mov		[STACKPOINTER], _SP						; Save down stack pointer (needed for DNU and C++ primitives)

	pushd	0										; 0 arguments
	mov		[MESSAGE], edx							; Save down message
	mov		[_SP], eax								; Temp pushed on Smalltalk stack

	jnz		@F										; If a SmallInteger need to load class differently
	mov		ecx, (OTE PTR[eax]).m_oteClass			; Get class into ECX
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
@@:
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX

	ASSUME	ecx:NOTHING
ENDBYTECODE sendTempNoArgs

BEGINBYTECODE shortSpecialSendAt
	mov		eax, [_SP-OOPSIZE]						; Load receiver into EAX
	mov		edx, [_SP]

	test	al, 1
	jnz		sendToSmallInteger

	ASSUME	eax:PTR OTE

	mov		ecx, [eax].m_oteClass					; Get the class of the Object
	ASSUME	ecx:PTR OTE

	; Test for integer index first as this will detect typical dictionary lookup by non-integer key without need to compare against Array class
	sar		edx, 1
	jnc		sendToClass								; Index not an integer
	jle		sendToClass

	test	[eax].m_flags, MASK m_pointer		; Test pointer bit of object table entry
	jz		byteObjectAt		

	cmp		ecx, [Pointers.ClassArray]
	jne		sendToClass

	; It's an Array, so use hard-coded implementation for this very common operation

	mov		ecx, 7fffffffh						; Ignore the sign bit of the size (used to mark const objects)
	shl		edx, 2								; edx = edx*OOPSIZE
	and		ecx, [eax].m_size					; Load size into ecx (masking out sign bit)
	ASSUME	ecx:DWORD

	mov		eax, [eax].m_location				; Load address of receiver into eax
	ASSUME	eax:PTR Oop

	cmp		edx, ecx							; Index < size
	ja		boundsError							; No, out of bounds

	sub		_SP, OOPSIZE
	MPrefetch

	mov		eax, [eax+edx-OOPSIZE]				; Load Oop of element at required index
	mov		[_SP], eax							; And overwrite receiver in stack with it

	DispatchNext

byteObjectAt:
	ASSUME	eax:PTR OTE							; ECX is Oop of receiver, but not needed
	ASSUME	edx:DWORD							; EDX is the index
	ASSUME	ecx:PTR OTE							; EAX is the Oop of the receiver's class

	cmp		ecx, [Pointers.ClassByteArray]
	jne		sendToClass

	mov		ecx, [eax].m_location				; Load object address into eax
	ASSUME	ecx:PTR ByteArray					; EAX points at receiver

	mov		eax, [eax].m_size					
	ASSUME	eax:DWORD
	and		eax, 7fffffffh						; Mask out the immutability bit
	
	cmp		edx, eax							; Index out of bounds (>= size) ?
	ja		boundsError				; 
	
	movzx	eax, BYTE PTR[ecx+edx-1]			; Load required byte, zero extending

	sub		_SP, OOPSIZE
	MPrefetch

	lea		eax, [eax+eax+1]					; Convert to SmallInteger
	mov		[_SP], eax							; Overwrite receiver with result. 

	DispatchNext

sendToSmallInteger:
	ASSUME	eax:SDWORD									;; EAX is a SmallInteger
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		sendToClass

boundsError:
	mov		eax, [_SP-OOPSIZE]
	ASSUME	eax:PTR OTE
	mov		ecx, [eax].m_oteClass

sendToClass:
	mov 	edx, [Pointers.atSelector]				; access entry in SpecialSelectors table
	mov		[STACKPOINTER], _SP		 				; Save down SP for DNU and prims
	pushd	1										; 1 argument
	mov		[MESSAGE], edx							; Set the MESSAGE global
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
ENDBYTECODE shortSpecialSendAt


BEGINBYTECODE shortSpecialSendAtPut
	mov		eax, [_SP-OOPSIZE*2]					; Access receiver under arguments
	mov		edx, [_SP-OOPSIZE]						; Load index argument from stack

	test	al, 1
	jnz		sendToSmallInteger						; Its a SmallInteger, send it #at:put: even though this is probably an error
	ASSUME	eax:PTR OTE

	mov		ecx, [eax].m_oteClass
	
	sar		edx, 1									; Convert SmallIteger arg to int
	jnc		sendToClass			 					; Non-SmallInteger?
	jle		sendToClass								; Index is <= 0?

	test	[eax].m_flags, MASK m_pointer		; Test pointer bit of object table entry
	jz		byteObjectAtPut

	cmp		ecx, [Pointers.ClassArray]
	jne		sendToClass

	; It's an Array, so use hard-coded implementation for this very common operation

	mov		ecx, [eax].m_location
	ASSUME	ecx:PTR Object
	mov		eax, [eax].m_size						; Compare with byte size of receiver Array
	sar		eax, 2									; N.B. DON'T mask out the immutable bit here, so size negative if const object
	lea		ecx, [ecx+edx*OOPSIZE-OOPSIZE]
	ASSUME	ecx:PTR Oop
	cmp		edx, eax

	mov		edx, [_SP]								; Load value to write into EDX
	ASSUME	edx:PTR OTE
	
	jg		sendToToS								; No, out of bounds (not unsigned comparison is correct here in case of large EDX that would go negative when shifted)

	; We must inc ref. count, as we are storing into a heap allocated object here
	CountUpOopIn <d>
	
	; Exchange Oop of overwritten value with new value
	mov		eax, [ecx]
	mov		[ecx], edx

	; Must count down overwritten value, as it was in a heap object slot
	CountDownOopIn <a>							

	; count down destroys eax, ecx, and edx, so have to wait til now for prefetch
	
	mov		eax, [_SP]								; Reload new value into eax
	MPrefetch
	mov		[_SP-OOPSIZE*2], eax					; And overwrite receiver in stack with new value
	sub		_SP, OOPSIZE*2							; Pop args
	
	DispatchNext

byteObjectAtPut:
	ASSUME	eax:PTR OTE						; EAX is byte object Oop
	ASSUME	ecx:PTR OTE						; ECX is byte object's class Oop
	ASSUME	edx:DWORD						; EDX is index

	cmp		ecx, [Pointers.ClassByteArray]
	jne		sendToClass

	cmp		edx, [eax].m_size				; Compare index+HEADERSIZE with object size (latter -ve if immutable)
	jg		sendToClass						; Index out of bounds (>= size)

	mov		ecx, [eax].m_location			; Load object address into eax
	ASSUME	ecx:PTR ByteArray				; EAX is pointer to byte object
	mov		eax, [_SP]						; Load value to store/return
	ASSUME	eax:Oop

	add		ecx, edx
	ASSUME	ecx:PTR BYTE

	mov		edx, eax						; Preserve value to return later in edx
	ASSUME	edx:Oop

	sar		eax, 1							; Convert to real integer value
	jnc		sendToToS						; Not a SmallInteger

	cmp		eax, 0FFh						; Too large?
	ja		sendToToS						; Used unsigned comparison for 0<=ecx<=255

	mov		[ecx-1], al						; Store byte into receiver
	ASSUME	ecx:NOTHING
	
	MPrefetch
	mov		[_SP-OOPSIZE*2], edx			; Overwrite receiver with value for return (still in EDX)
	sub		_SP, OOPSIZE*2

	DispatchNext

sendToSmallInteger:
	ASSUME	eax:SDWORD								; EAX is a SmallInteger
	mov		ecx, [Pointers.ClassSmallInteger]
	jmp		sendToClass

sendToToS:
	mov		eax, [_SP-OOPSIZE*2]
	ASSUME	eax:PTR OTE
	mov		ecx, [eax].m_oteClass

sendToClass:
	mov 	edx, [Pointers.atPutSelector]			; access entry in SpecialSelectors table
	mov		[STACKPOINTER], _SP		 				; Save down SP for DNU and prims
	pushd	2										; 1 argument
	mov		[MESSAGE], edx							; Set the MESSAGE global
	jmp		execMethodOfClass						; Jump to routine to exec class>>message in ECX>>EDX
ENDBYTECODE shortSpecialSendAtPut


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Extended Send Instruction (triple byte). 
;;
;; Extension specifies argument count (first byte) and selector literal index (second byte)
;;
;; This occurs commonly when calling external functions because they often take more arguments
;; than 7 arguments

BEGINBYTECODE longSend
	xor		ecx, ecx
	mov		eax, [pMethod]					; Load pointer to current method
	ASSUME	eax:PTR CompiledCodeObj

	mov		cl, BYTE PTR[_IP+1]

	movzx	edx, BYTE PTR[_IP]

	add		_IP, 2

	SendLiteralECXinEAXwithEDXArgs

ENDBYTECODE longSend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;

; Executing a method may involve a primitive response (quick return of nil/true/
; false/zero/self/instance var, or a primitive call) or 
; normal method invocation (non-primitive or following primitive 
; failure). In the case of normal method invocation the machine
; is placed into a state where it is ready to begin executing the
; new method, but the actual execution is performed after this
; function returns by the byte code dispatch loop. Special methods
; with primitive responses are executed immediately, complete
; before this function returns, and do not involve a new context.
;
; The main body of the routine is very short, being a switch
; through a jump table (see immediately below).

; New code which does only a single jump via primitives table
;
MExecNewMethod MACRO
	
	ASSUME	ecx:PTR CompiledCodeObj
	ASSUME	edx:DWORD
	ASSUME	eax:DWORD

	IFDEF _DEBUG
		push	eax
		ASSUME	eax:NOTHING
		movzx	eax, [ecx].m_header.primitiveIndex
		inc DWORD PTR[_primitiveCounters+eax*4]
		pop		eax
		ASSUME	eax:DWORD
	ENDIF

	mov		ecx, _SP
	mov		[INSTRUCTIONPOINTER], _IP		;; Save IP in case of fault or call to C++ primitive

	call	eax

	;; Likelihood is that the primitive will succeed, so jump conditionally on failure
	;; (static prediction is that all forwards jumps will not be taken)

	test	eax, eax
	jz		@F								;; Primitive failed?
	MPrefetch
	mov		_SP, eax						;; Reload stack pointer as primitive may have modified
	DispatchNext							;; succeeded, continue executing byte codes without activating new context

@@:
	;; Activate method as primitive failed - note we don't bother to pass the correct argument count
	call	?primitiveActivateMethod@Interpreter@@CIPAIQAII@Z
	MPrefetch
	mov		_SP, eax
	DispatchNext
ENDM

BEGINPROC execMethodOfClass
	ASSUME	edx:PTR OTE		; Selector (N.B. must have been saved down in MESSAGE global
	ASSUME	ecx:PTR OTE		; Class
							; [ESP] is the argument count (i.e. one arg on stack)

	; Calculate the method cache hash
	mov		eax, ecx								; Get class Oop into ecx
	xor		eax, edx								; Xor with selector oop
	and		eax, METHODCACHEMASK					; Mod method cache size

	; Cache is 16 bytes per entry (a Pentium sweet spot, and since OTE is 16 bytes long, we don't
	; need to scale the hash we calculated
	
	; At this point
	;	EAX = byte index into cache
	;	ECX = class OTE
	;	EDX = selectOR OTE

	cmp		(MethodCacheEntry PTR METHODCACHE[eax]).selector, edx
	jne		findMethodCacheMiss						; Forward jump (predict not taken) if cache miss
	
	cmp		(MethodCacheEntry PTR METHODCACHE[eax]).classPointer, ecx
	jne		findMethodCacheMiss						; Forward jump (predict not taken) if cache miss

	mov		ecx, (MethodCacheEntry PTR METHODCACHE[eax]).method
	assume	ecx:PTR OTE

	mov		eax, (MethodCacheEntry PTR METHODCACHE[eax]).primAddress

	IFDEF _DEBUG
		inc	[CACHEHITS]
	ENDIF

	mov		[NEWMETHOD], ecx
	pop		edx										; Restore arg count

	mov		ecx, [ecx].m_location
	
	; At this point edx=argCount, ecx & [NEWMETHOD] = Oop of new method, _SP=[STACKPOINTER]
	; eax = pointer to func to run
	
	; Execute new method, and dispatch the next byte code
	MExecNewMethod

findMethodCacheMiss:
	push	ecx
	call	FINDNEWMETHODNOCACHE
	ASSUME eax:PTR MethodCacheEntry

	mov		ecx, [eax].method;
	ASSUME ecx:PTR OTE

	mov		eax, [eax].primAddress
	ASSUME	eax:DWORD

	mov		[NEWMETHOD], ecx						; Store down new method register

	mov		ecx, [ecx].m_location					; Load address of new method object into ecx
	ASSUME	ecx:PTR CompiledCodeObj

	mov		_SP, [STACKPOINTER]						; Restore stack pointer (in case of DNU)
	movzx	edx, [ecx].m_header.argumentCount
	
	; ECX = CompiledMethod*, EDX = arg count, EAX = primitive routine to call
	MExecNewMethod
	
ENDPROC execMethodOfClass

;; Activate a method (i.e. update the calling stack frame's IP & sp, setup a new stack frame, and initialize appropriate interpreter 
;; registers to execute the new methods bytecodes, and set up a stack frame)
MActivateMethod MACRO 
	ASSUME ecx:PTR CompiledCodeObj					; Expects ptr to new method in ECX

	IFDEF PROFILING
		inc 	[?contextsSuspended@@3IA]
		inc 	[?methodsActivated@@3IA]
	ENDIF

	;; Work out _IP index before overwriting old method pointer
	mov		eax, [pMethod]							; Load pointer to current method into eax
	ASSUME	eax:PTR CompiledCodeObj

	mov		edx, ecx								; Get pointer to new method into edx
	ASSUME	edx:PTR CompiledCodeObj
	mov		[pMethod], ecx							; Save down pointer to new method

	.IF ((BYTE PTR([eax].m_byteCodes) & 1))
		add		eax, CompiledCodeObj.m_byteCodes
	.ELSE
		mov		eax, [eax].m_byteCodes
		ASSUME	eax:PTR OTE
		mov		eax, [eax].m_location
	.ENDIF
	ASSUME	eax:NOTHING
	sub		_IP, eax
	IFDEF _DEBUG
		.IF (_IP > 16384)
			int	3									;; Probably a bug - unusual to have a method with more than 16k bytecodes
		.ENDIF
	ENDIF
	; At this point _IP is the offset into the byte codes

	movzx	eax, [edx].m_header.argumentCount

	; Work out the new base pointer (points at first argument - not receiver)
	neg		eax										; We'll be subtracting arg count
	lea		_IP, [_IP+_IP+1]						; Convert old IP offset to SmallInteger for later

	; We're don't need pointer to new method any more
	ASSUME ecx:NOTHING

	; Now work out the number of temporaries required for new method
	; Load flag word which contains temp count
	movzx	ecx, [edx].m_header.stackTempCount		; Get stack temp count into ecx

	lea		_BP, [_SP+eax*OOPSIZE+OOPSIZE]			; Calculate _BP of new context (points at first argument NOT receiver)
	add		_SP, OOPSIZE

	mov		eax, [oteNil]							; Temps must have initial value of Nil
	cmp		ecx, 0
	.WHILE (!ZERO?)
		mov		[_SP], eax
		add		_SP, OOPSIZE
		dec		ecx
	.ENDW

	ASSUME	_SP:PStackFrame						; _SP now points at location for new StackFrame

	mov		ecx, [NEWMETHOD]					; Restore method Oop
	; Note that we used to have to count up the method's ref. count here, but no more since the frame is on the stack
	mov		[_SP].m_method, ecx					; Store new method oop into new StackFrame fields

	; Now see whether a real (object) context is required

	.IF !([edx].m_header.flags & MASK envTempCount)					; Test if method requires a context
		mov		[_SP].m_environment, SMALLINTZERO	; Zero out the env slot as this frame has no environment
	.ELSE
		; At this point, _BP points at the first argument of the new context (in the stack), i.e. it is
		; correctly set up for the new frame. ECX contains method header flags
		ASSUME	_SP:PStackFrame					; _SP now points at location for new StackFrame

		movzx	ecx, [edx].m_header.flags
		
		push	edx										; Save edx for later
		ASSUME	edx:NOTHING

		shr		ecx, 2									; Access the actual env temp count
		lea		edx, [_SP+1]							; 2: Calc SmallInteger frame pointer into EAX...
		sub		ecx, 1									; Count is one greater than number of slots required (to flag need for Context for far ^-return)

		call	NEWCONTEXT								
		ASSUME	eax:PTR OTE								; EAX is the Oop of the new Context

		lea		edx, [_SP].m_environment
		; Set the context of the stack frame to be the new method context
		mov		[_SP].m_environment, eax
		AddToZct <a>,<edx>
		ASSUME	eax:NOTHING								; Context Oop no longer needed

		pop		edx
		ASSUME	edx:PTR CompiledCodeObj
	.ENDIF

	ASSUME eax:NOTHING
	ASSUME ecx:NOTHING
	ASSUME _SP:PStackFrame
	ASSUME _BP:PTR Oop
	ASSUME edx:PTR CompiledCodeObj

	lea		eax, [_BP+1]						; Make SmallInteger pointer to base in EAX
	mov		[BASEPOINTER], _BP					; Save down BP into interpreter register

	mov		ecx, [ACTIVEFRAME]					; Load frame being suspended into ECX
	ASSUME	ecx:PStackFrame

	mov		[_SP].m_ip, SMALLINTZERO			; Zero out the new frames IP
	mov		[_SP].m_bp, eax						; Store SmallInteger base pointer into new frame fields

	;; Suspended contexts _SP is _BP - 2		(_BP points at first arg, not receiver)
	sub		eax, OOPSIZE*2			  			; EAX contains SmallInteger _BP (from above)

	;; Save down suspended context's _IP and _SP (using ECX)
	mov		[ecx].m_ip, _IP						; IP index was worked out above
	mov		[ecx].m_sp, eax

	lea		eax, [ecx+1]	  					; Create SmallInteger pointer to frame being suspended ...
	ASSUME	ecx:NOTHING							; We have no further use for the suspended context

	mov		[_SP].m_sp, SMALLINTZERO			; Zero out new frames SP
	mov		[_SP].m_caller, eax					; Store SmallInt pointer to calling frame into new context fields
	
	; Save down frame pointer for C++
	mov		[ACTIVEFRAME], _SP

	ASSUME	_SP:PTR Oop
	add		_SP, SIZEOF StackFrame-OOPSIZE		; Adjust _SP to point at last field of frame
	
	; Set up interpreters _IP
	GetInitialIPOfMethod <edx>

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			mov		ecx, _SP
			call	DEBUGMETHODACTIVATED
		.ENDIF
	ENDIF

ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create a new frame for the new method and start executing its bytcodes
;
BEGINPRIMITIVE primitiveActivateMethod
	;MActivateMethod

	IFDEF PROFILING
		inc 	[?contextsSuspended@@3IA]
		inc 	[?methodsActivated@@3IA]
	ENDIF

	mov		ecx, [NEWMETHOD]
	ASSUME	ecx:PTR OTE

	;; Work out _IP index before overwriting old method pointer
	mov		eax, [pMethod]							; Load pointer to current method into eax
	ASSUME	eax:PTR CompiledCodeObj

	mov		edx, [ecx].m_location					; Get pointer to new method into edx
	ASSUME	edx:PTR CompiledCodeObj
	mov		[pMethod], edx							; Save down pointer to new method

	.IF ((BYTE PTR([eax].m_byteCodes) & 1))
		add		eax, CompiledCodeObj.m_byteCodes
	.ELSE
		mov		eax, [eax].m_byteCodes
		ASSUME	eax:PTR OTE
		mov		eax, [eax].m_location
	.ENDIF
	ASSUME	eax:NOTHING
	sub		_IP, eax
	IFDEF _DEBUG
		.IF (_IP > 16384)
			int	3									;; Probably a bug - unusual to have a method with more than 16k bytecodes
		.ENDIF
	ENDIF
	; At this point _IP is the offset into the byte codes

	movzx	eax, [edx].m_header.argumentCount

	; Work out the new base pointer (points at first argument - not receiver)
	neg		eax										; We'll be subtracting arg count
	lea		_IP, [_IP+_IP+1]						; Convert old IP offset to SmallInteger for later

	; Now work out the number of temporaries required for new method
	; Load flag word which contains temp count
	movzx	ecx, [edx].m_header.stackTempCount		; Get stack temp count into ecx

	lea		_BP, [_SP+eax*OOPSIZE+OOPSIZE]			; Calculate _BP of new context (points at first argument NOT receiver)
	add		_SP, OOPSIZE

	mov		eax, [oteNil]							; Temps must have initial value of Nil
	cmp		ecx, 0
	.WHILE (!ZERO?)
		mov		[_SP], eax
		add		_SP, OOPSIZE
		dec		ecx
	.ENDW

	ASSUME	_SP:PStackFrame						; _SP now points at location for new StackFrame

	mov		ecx, [NEWMETHOD]					; Restore method Oop
	; Note that we used to have to count up the method's ref. count here, but no more since the frame is on the stack
	mov		[_SP].m_method, ecx					; Store new method oop into new StackFrame fields

	; Now see whether a real (object) context is required

	.IF !([edx].m_header.flags & MASK envTempCount)					; Test if method requires a context
		mov		[_SP].m_environment, SMALLINTZERO	; Zero out the env slot as this frame has no environment
	.ELSE
		; At this point, _BP points at the first argument of the new context (in the stack), i.e. it is
		; correctly set up for the new frame. ECX contains method header flags
		ASSUME	_SP:PStackFrame					; _SP now points at location for new StackFrame

		movzx	ecx, [edx].m_header.flags
		
		push	edx										; Save edx for later
		ASSUME	edx:NOTHING

		shr		ecx, 2									; Access the actual env temp count
		lea		edx, [_SP+1]							; 2: Calc SmallInteger frame pointer into EAX...
		sub		ecx, 1									; Count is one greater than number of slots required (to flag need for Context for far ^-return)

		call	NEWCONTEXT								
		ASSUME	eax:PTR OTE								; EAX is the Oop of the new Context

		lea		edx, [_SP].m_environment
		; Set the context of the stack frame to be the new method context
		mov		[_SP].m_environment, eax
		AddToZct <a>,<edx>
		ASSUME	eax:NOTHING								; Context Oop no longer needed

		pop		edx
		ASSUME	edx:PTR CompiledCodeObj
	.ENDIF

	ASSUME eax:NOTHING
	ASSUME ecx:NOTHING
	ASSUME _SP:PStackFrame
	ASSUME _BP:PTR Oop
	ASSUME edx:PTR CompiledCodeObj

	lea		eax, [_BP+1]						; Make SmallInteger pointer to base in EAX
	mov		[BASEPOINTER], _BP					; Save down BP into interpreter register

	mov		ecx, [ACTIVEFRAME]					; Load frame being suspended into ECX
	ASSUME	ecx:PStackFrame

	mov		[_SP].m_ip, SMALLINTZERO			; Zero out the new frames IP
	mov		[_SP].m_bp, eax						; Store SmallInteger base pointer into new frame fields

	;; Suspended contexts _SP is _BP - 2		(_BP points at first arg, not receiver)
	sub		eax, OOPSIZE*2			  			; EAX contains SmallInteger _BP (from above)

	;; Save down suspended context's _IP and _SP (using ECX)
	mov		[ecx].m_ip, _IP						; IP index was worked out above
	mov		[ecx].m_sp, eax

	lea		eax, [ecx+1]	  					; Create SmallInteger pointer to frame being suspended ...
	ASSUME	ecx:NOTHING							; We have no further use for the suspended context

	mov		[_SP].m_sp, SMALLINTZERO			; Zero out new frames SP
	mov		[_SP].m_caller, eax					; Store SmallInt pointer to calling frame into new context fields
	
	; Save down frame pointer for C++
	mov		[ACTIVEFRAME], _SP

	ASSUME	_SP:PTR Oop
	add		_SP, SIZEOF StackFrame-OOPSIZE		; Adjust _SP to point at last field of frame
	
	; Set up interpreters _IP
	GetInitialIPOfMethod <edx>

	IFDEF _DEBUG
		.IF ([EXECUTIONTRACE])
			mov		ecx, _SP
			call	DEBUGMETHODACTIVATED
		.ENDIF
	ENDIF

	mov		eax, [ASYNCPENDING]
	test	eax, eax
	jnz		asyncPending								;; If any ansync. signals, go and test process switch
	
	mov		eax, _SP									; primitiveSuccess(0)
	ret

asyncPending:
	; Store interpreter registers before calling C++ func
	mov		[INSTRUCTIONPOINTER], _IP
	mov		[STACKPOINTER], _SP
	call	MSGPOLL
	mov		_IP, [INSTRUCTIONPOINTER]
	mov		eax, [STACKPOINTER]
	mov		_BP, [BASEPOINTER]
	ret
ENDPRIMITIVE primitiveActivateMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BEGINPRIMITIVE primitiveReturnInstVar
	; Its a primitive return of an instance variable
	; Compiler should not generate such a method for a SmallInteger
	; Which inst var do we want? Well its that whose index is
	; in the extra index field of the method (normally used
	; for primitives)
	;	1 Nop
	;	2 PushInstVarN
	;	3(inst var index)
	;	4 ReturnStackTop

	mov		ecx, [NEWMETHOD]

	ASSUME	edx:NOTHING				; Don't need the argument count

	; We need a mini interpreter now to extract the inst var index from the byte codes

	mov		ecx, (OTE PTR[ecx]).m_location
	ASSUME	ecx:PTR CompiledCodeObj				; ECX points at the new method

	mov		edx, [STEPPING]
	mov		eax, [ecx].m_byteCodes				; Get bytecodes into eax - note that it MUST be a SmallInteger
	mov		ecx, [_SP]							; ecx = receiver Oop at stack top
	ASSUME	ecx:PTR OTE

	test	edx, edx
	jnz		stepping
	
	shr		eax, 16
	mov		edx, [ecx].m_location 				; edx points at receiver object
	ASSUME	edx:PTR Object
	and		eax, 0FFh
	
	; No arguments to pop as compiler only generates this quick method form if zero args

	; Load inst var Oop from object into edx
	mov		edx, [edx].fields[eax*OOPSIZE]
	ASSUME	edx:Oop

	mov		[_SP], edx							; Overwrite receiver with inst. var Oop

	mov		eax, _SP							; primitiveSuccess(0)
	ret

stepping:
	; Fail so can step into method
	xor		eax, eax
	ret

ENDPRIMITIVE primitiveReturnInstVar

BEGINPRIMITIVE primitiveSetInstVar
	; Its a primitive set of an instance variable
	; Compiler should not generate such a method for a SmallInteger
	; This is somewhat simpler that primitiveReturnInstVar because the compiler
	; always generates the same form for these methods
	;	1 PushTemp0
	;	2 StoreInstVarN
	;	3 (inst var index)
	;	4 Return Self
	; There won't be any initial Nop, because the first instruction is always PushTemp0
	; There must only be one argument, and that is the value to store down. There is no
	; net effect on its ref. count (similar code to pop & store)

	mov		ecx, [NEWMETHOD]

	; We need a mini interpreter now to extract the inst var index from the byte codes
	
	cmp		[STEPPING], 0
	mov		ecx, (OTE PTR[ecx]).m_location
	ASSUME	ecx:PTR CompiledCodeObj				; ECX points at the new method
	mov		edx, [_SP-OOPSIZE]					; edx = receiver Oop under argument
	ASSUME	edx:PTR OTE
	
	mov		eax, [ecx].m_byteCodes				; Get bytecodes into eax - MUST be a SmallInteger

	jne		steppingOrFailure

	mov		ecx, [edx].m_location 				; ecx now points at receiver object
	ASSUME	ecx:PTR Object

	; Note assumption here that OOPSIZE == 4 (32-bit)
	
	.IF (ah == POPSTOREINSTVAR)
		shr		eax, (16-OOPSHIFT)
	.ELSE
		shr		eax, (8-OOPSHIFT)
		sub		eax, (FIRSTPOPNSTOREINSTVAR*OOPSIZE)
	.ENDIF
	and		eax, (0FFh*OOPSIZE)
	
	ASSUME eax:DWORD		; eax is now the offset into the fields of the inst var to set
	cmp		eax, [edx].m_size
	jge		steppingOrFailure					; Attempt to write off end, or immutable
	
	lea		eax, [ecx].fields[eax]
	ASSUME	eax:PTR Oop

	mov		edx, [_SP]
	ASSUME	edx:Oop

	mov		ecx, [eax]							; Load existing inst. var value into ECX for count down
	ASSUME	ecx:Oop

	; Storing new inst var value, we must bump its ref. count
	CountUpOopIn <d>
	mov		[eax], edx

	; We must count down ECX (the old inst var value) here, because we've overwritten a heap object slot
	CountDownOopIn <c>

	lea		eax, [_SP-OOPSIZE]				; primitiveSuccess(1)
	ret

steppingOrFailure:
	xor		eax, eax
	ret

ENDPRIMITIVE primitiveSetInstVar


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Supersend Instruction (double byte)
;;
;; Extension specifies argument count and selector literal index (encoded into a byte as follows 111 11111)

BEGINBYTECODE Supersend
	movzx	ecx, [_IP]						; Get next byte code (top 3 bytes of ecx still 0)
	inc		_IP
	mov		edx, ecx						; EDX = descriptor
	and		ecx, 01Fh						; bottom 5 bits are literal index
	shr		edx, 5							; edx now contains argCount
	; Drop through ...
ENDBYTECODE Supersend

; No align as dropped into from above
BEGINPROCNOALIGN sendLiteralSelectorToSuper			; EDX = argCount, ECX = literal index
	mov		eax, [pMethod]							; Load Oop of current method
	ASSUME	eax:PTR CompiledCodeObj
	mov     ecx, [eax].m_aLiterals[ecx*OOPSIZE]		; Load selector Oop into ecx
	mov		[MESSAGE], ecx							; Save down message selector
	mov		ecx, [eax].m_methodClass				; Load class Oop from the method
	ASSUME	eax:NOTHING
	mov		ecx, (OTE PTR[ecx]).m_location			; Load pointer to class object
	mov		ecx, (Behavior PTR[ecx]).m_superclass	; Load Oop of superclass into ECX

	mov		[STACKPOINTER], _SP		 				; Save down stack pointer (needed for DNU and C++ primitives)
	push	edx										; Save arg count for later use

	mov		edx, [MESSAGE]
	jmp		execMethodOfClass

ENDPROC sendLiteralSelectorToSuper

BEGINPROC EXECUTENEWMETHOD
;
; void __factcall Interpreter::executeNewMethod(OTE* newMethod, unsigned argCount)
;
; Inputs:
;	ECX	- Oop of method to execute (needed by activateNewMethod for setting up context)
;	EDX - Argument count
; Outputs:
;	EAX - Destroyed
;	ECX - Destroyed
;	EDX - Destroyed
;
; C++ entry point for preparing to execute new method. This routine is
; an almost exact copy of the byte code dispatch loops execNewMethod,
; BUT with the significant difference that it returns to the caller,
; not the byte dispatch loop. There are three reasons for having
; two different versions - performance, performance and performance.

	ASSUME	ecx:PTR OTE
	ASSUME	edx:DWORD

	mov		[NEWMETHOD], ecx						; Save Oop of new method
	mov		ecx, [ecx].m_location					; Load address of CompiledMethod into ECX
	ASSUME	ecx:PTR CompiledCodeObj

	; Entered from C++, must save then set up _SP/_IP for assembler primitives
	; Load primitive index (0..255), top 3 bytes of EAX still 0
	push	_SP									; Mustn't destroy for C++ caller
	push	_IP									; Ditto _IP
	push	_BP
	movzx	eax, [ecx].m_header.primitiveIndex
	mov		_SP, [STACKPOINTER]
	mov		_IP, [INSTRUCTIONPOINTER]
	mov		_BP, [BASEPOINTER]
	mov		ecx, _SP

	IFDEF _DEBUG
		inc	DWORD PTR[_primitiveCounters+eax*4]
	ENDIF
	call	DWORD PTR[_primitivesTable+eax*4]	; Call via jump table

	test	eax, eax							; Primitives return 0 for failure, ~0 for success
	jz		@F									; Failed?
	
	mov		[STACKPOINTER], eax	
	mov		[INSTRUCTIONPOINTER], _IP			; Do we need this?

	pop		_BP
	pop		_IP
	pop		_SP
	ret

@@:
	; Failed, so must activate the new method
	call	?primitiveActivateMethod@Interpreter@@CIPAIQAII@Z

	mov		[STACKPOINTER], eax	
	mov		[INSTRUCTIONPOINTER], _IP

	pop		_BP
	pop		_IP
	pop		_SP
	ret

ENDPROC EXECUTENEWMETHOD

BEGINPROC ACTIVATENEWMETHOD
	; See execPrimitive above.
	; Entered from C++, must save then set up _SP/_IP/_BP for assembler code
	push	_SP									; Mustn't destroy for C++ caller
	push	_IP									; Ditto _IP
	push	_BP

	; Load interpreter registers
	mov		_IP, [INSTRUCTIONPOINTER]
	mov		_SP, [STACKPOINTER]
	mov		_BP, [BASEPOINTER]
	MActivateMethod
	; Store interpreter registers
	mov		[INSTRUCTIONPOINTER], _IP
	mov		[STACKPOINTER], _SP

	pop		_BP
	pop		_IP
	pop		_SP
	ret
ENDPROC ACTIVATENEWMETHOD

; Send the 0 argument selector #value.
; Optimise for zero arg blocks to bypass message lookup.
BEGINBYTECODE shortSpecialSendValue
	mov		eax, [_SP]							; Access the receiver
	test	al, 1
	jnz		sendMessage							; Its a SmallInteger, send it #value
	ASSUME	eax:PTR OTE							; EAX is the Oop of the receiving block (we hope)

	mov		ecx, eax
	ASSUME	ecx:PTR OTE							; ECX is the Oop of the receiving block (we hope)

	mov		edx, [eax].m_location				; Load pointer to block into EDX
	ASSUME edx:PTR BlockClosure

	mov		eax, [Pointers.ClassBlockClosure]
	cmp		eax, [ecx].m_oteClass				; Is it a block?
	jne		sendMessage							; No, send it #value

	cmp		[edx].m_info.argumentCount, 0
	jne		sendMessage

	; _SP is pointing at the block (no args), which we must overwrite with the receiver from the closure.
	
	lea		_BP, [_SP+OOPSIZE]					; Set up new frame base pointer for activateBlock (points at [recever+1])

	; To invoke activateBlock: ECX is Oop of Block, EDX is pointer to block

	call	activateBlock
	DispatchByteCode

sendMessage:
	SendSelectorNoArgs <Pointers.valueSelector>
ENDBYTECODE shortSpecialSendValue


; Send the 1 argument selector #value.
; Optimise for one arg blocks to bypass message lookup.
BEGINBYTECODE shortSpecialSendValueColon
	mov		eax, [_SP-OOPSIZE]					; Load receiver block into EAX
	test	al, 1								; SmallInteger?
	jnz		sendMessage							; Yes, skip to send
	ASSUME	eax:PTR OTE

	mov		ecx, eax
	ASSUME	ecx:PTR OTE							; ECX and EAX are now receiver block

	mov		edx, [eax].m_location				; Load pointer to block into EDX
	ASSUME edx:PTR BlockClosure

	mov		eax, [Pointers.ClassBlockClosure]	; Is it a block
	cmp		eax, [ecx].m_oteClass
	ASSUME	eax:NOTHING

	jne		sendMessage							; No, send it #value
	cmp		[edx].m_info.argumentCount, 1
	jne		sendMessage							; Arg. count not one, must fail

	; activateBlock expects _BP to be set up
	mov		_BP, _SP							; _BP points at first (and only) arg

	; At this point _BP points at [receiver+1]
	; _SP points at TOS
	; ecx is the block being activated
	; edx points at the block body

	call	activateBlock
	DispatchByteCode

sendMessage:
	SendSelectorOneArg <Pointers.valueColonSelector>
ENDBYTECODE shortSpecialSendValueColon

; Send the 2 argument selector #value:value:.
; Optimise for two arg blocks to bypass message lookup.
BEGINBYTECODE shortSpecialSendValueValue
	mov		eax, [_SP-OOPSIZE*2]				; Load receiver block into EAX
	test	al, 1								; SmallInteger?
	jnz		sendMessage							; Yes, skip to send
	ASSUME	eax:PTR OTE

	mov		ecx, eax
	ASSUME	ecx:PTR OTE							; Copy receiver into ECX

	mov		edx, [eax].m_location				; Load pointer to block into EDX
	ASSUME edx:PTR BlockClosure

	mov		eax, [Pointers.ClassBlockClosure]	; Is receiver a block
	cmp		eax, [ecx].m_oteClass
	jne		sendMessage							; No, send it #value:value:

	cmp		[edx].m_info.argumentCount, 2
	jne		sendMessage							; Arg. count not two, must fail

	; activateBlock expects pointer to position to store stack frame in BP
	lea		_BP, [_SP-OOPSIZE]					; _BP should point at first arg, which is at TOS-1

	; At this point _BP points at [receiver+1]
	; _SP points at TOS
	; ecx is the block being activated
	; edx points at the block body

	call	activateBlock
	DispatchByteCode

sendMessage:
	SendSelectorArgs <Pointers.valueValueSelector>, <2>				; value:value:
ENDBYTECODE shortSpecialSendValueValue

; Activate the block in ECX creating a new frame at _SP in the stack. _BP is set up for new frame
BEGINPROC activateBlock
	ASSUME	ecx:PTR OTE						; Oop of block to be activiated
	ASSUME	edx:PTR BlockClosure			; Ptr to the block to be activated

	; First overwrite the block itself in the stack with the receiver captured at time of closure
	; (Could be nil)
	mov		eax, [edx].m_receiver
	ASSUME eax:Oop

	; No ref counting needed, as we're overwriting a stack slot, however we must count up the block
	; if it needs a context, as it is stored into the context
	mov		[_BP-OOPSIZE], eax

	add		_SP, OOPSIZE
	mov		eax, [ecx].m_size						; Load size into eax
	and		eax, 7fffffffh							; Mask out the immutability bit

	push	ecx										; Save block pointer for later use
	ASSUME	ecx:NOTHING

	; Now push any copied values onto the stack, again no ref. counting needed...

	sub		eax, SIZEOF BlockClosure
	.IF	(!ZERO?)
		; Push copied values

		push	eax
		shr		eax, 2

	@@:
		mov		ecx, [edx].m_copiedValues[eax*OOPSIZE-OOPSIZE]
		mov		[_SP+eax*OOPSIZE-OOPSIZE], ecx
		sub		eax, 1
		jnz		@B

		pop		eax
		add		_SP, eax
	.ENDIF

	movzx	eax, [edx].m_info.stackTempsCount
	.IF	(eax != 0)
		; Allocate and initialize the stack temps to nil
		mov		ecx, [oteNil]
		
	@@:
		mov	[_SP], ecx
		add _SP, OOPSIZE
		sub eax, 1
		jnz @B
	.ENDIF
	
	; _SP now points at the location for the new stack frame
	ASSUME	_SP:PStackFrame
	
	; eax and ecx free again
	ASSUME ecx:NOTHING
	ASSUME eax:NOTHING
	
	; edx still pointer to the block
	ASSUME edx:PTR BlockClosure

	movzx	ecx, [edx].m_info.envTempsCount
	.IF		(ecx == 0)
		; No env temps (the common case)
		pop		eax
		ASSUME	eax:PTR OTE
		
		; The environment ref in this case is the block itself (it has no shared temps),
		; We are only really using this slot as a way to keep a ref. to the block to prevent 
		; it being GC'd and for the debugger. I wonder do we still need to do this?
		mov		[_SP].m_environment, eax
		
	.ELSE
		mov		eax, [edx].m_method			; Load method Oop into ECX from block
		mov		edx, [edx].m_outer			; Load outer for Context::New (block is 
		mov		[_SP].m_method, eax			; Store method down into frame so that it is value should we need to reconcile Zct
		call	NEWCONTEXT
		ASSUME	eax:PTR OTE
		lea		edx, [_SP].m_environment
		; The environment ref. in the frame is in this case a real context
		mov		[_SP].m_environment, eax
		AddToZct <a>,<edx>

		mov		eax, [_SP].m_environment	; Reload env OTE
		ASSUME	eax:PTR OTE

		mov		ecx, [eax].m_location
		ASSUME	ecx:PTR Context
		
		pop		edx							; Pop the BlockClosure OTE
		ASSUME	edx:PTR OTE
		CountUpObjectIn <d>
		mov		[ecx].m_block, edx			; Save pointer to block into context (just ref. counted)
		mov		edx, [edx].m_location
		ASSUME	edx:PTR BlockClosure		; Ptr to the block to be activated
	.ENDIF

	mov		eax, [ACTIVEFRAME]						; Load pointer to current active frame into ECX
	ASSUME	eax:PStackFrame

	mov		ecx, SMALLINTZERO
	ASSUME	ecx:Oop

	; Overwrite any existing values in the IP and SP slots of the frame
	mov		[_SP].m_ip, ecx
	mov		[_SP].m_sp, ecx

	; Calc SP of suspended context, its can be calc'd off BP of new frame
	; (_BP - 1 slot for receiver, - 1 to offset to last slot of caller frame)
	lea		ecx, [_BP-(OOPSIZE*2-1)]				; Leave it odd to mark as SmallInteger
	
	mov		[ACTIVEFRAME], _SP						; Store down new active frame
	
	mov		[eax].m_sp, ecx							; Store SP into suspended frame

	; Calculate current _IP to store down in deactivated context
	GetIPOffsetUsing <ecx>
	lea		ecx, [eax+1]							; Create a SmallInteger pointer to current active frame

	mov		[_SP].m_caller, ecx						; Save down caller frame SmallInteger pointer into stack frame
	lea		ecx, [_BP+1]
	
	lea		_IP, [_IP+_IP+1]						; Convert _IP to SmallInteger
	
	mov		[eax].m_ip, _IP							; Saved down _IP at time of suspension
	ASSUME	eax:NOTHING								; We've now finished with the old frame

	mov		[_SP].m_bp, ecx

	;; Retrieve the new _IP
	mov		_IP, [edx].m_initialIP					; Get the initial IP from block being activated

	mov		ecx, [edx].m_method						; Load method Oop into ECX from block
	ASSUME	ecx:PTR OTE								; Finished with the block
	ASSUME	edx:NOTHING								; Finished with pointer to block body

	;; EDX is now a pointer to home context, _SP points at new frame
	mov		[_SP].m_method, ecx						; Save down method into frame (as well), no ref count as ref from stack
	ASSUME	_SP:PTR Oop								; New frame now fully set up
	add		_SP, SIZEOF StackFrame-OOPSIZE			; _SP should point at last used slot in stack (i.e. last slot of frame)

	sar		_IP, 1									; u - Convert initial IP to real integer value
	mov		ecx, [ecx].m_location					; v - Get pointer to method
	ASSUME	ecx:PTR CompiledCodeObj

	mov		[pMethod], ecx

	; Set up instruction pointer (currently contains index into bytecodes of block initial IP)
	mov		edx, [ecx].m_byteCodes
	.IF (edx & 1)
		ASSUME edx:DWORD
		lea		edx, [ecx].m_byteCodes
		add		_IP, edx
	.ELSE
		ASSUME edx:PTR OTE
		;; There is no longer any header on the object body to skip here
		add		_IP, [edx].m_location
	.ENDIF
	ASSUME	ecx:NOTHING								; Finished with bytecodes Oop
	ASSUME	edx:NOTHING

	dec		_IP										; Adjust IP from index to offset

	mov		[BASEPOINTER], _BP						; ... Save down BP into interpreter global for C++

	; Necessary to permit debug break on entry to block

	mov		eax, [ASYNCPENDING]
	test	eax, eax
	jnz		@F											;; If any ansync. signals, go and test process switch
	ret
@@:
	CallCPP <MSGPOLL>
	ret

ENDPROC activateBlock

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some long and rarely used instructions that are present for completeness

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Long Jumps (triple byte)
;; These are very rarely used

BEGINRARECODE longJumpIfTrue
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	sub		edx, [oteTrue]
	jnz		@F

	movsx	eax, WORD PTR[_IP]						; Sign extend instruction argument word (offset) into EAX
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after double byte of instruction extension)
	DispatchByteCode

@@:
	add		_IP, SIZEOF WORD						; Adjust IP to point at next instruction
	cmp		edx, OTENTRYSIZE						; false is next Oop after true
	jne		@F
	; it was false, so dispatch next
	DispatchByteCode

@@:	; Errorneous attempt to branch on non-boolean object
	sub		_IP, 1+SIZEOF WORD						;; We'll retry the conditional test if #mustBeBoolean returns
	add		_SP, OOPSIZE			; Unpop
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>
ENDBYTECODE longJumpIfTrue

BEGINRARECODE longJumpIfFalse
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	sub		edx, [oteFalse]
	jnz		@F

	movsx	eax, WORD PTR[_IP]						; Sign extend instruction argument word (offset) into EAX
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after double byte of instruction extension)
	DispatchByteCode

@@:
	add		_IP, SIZEOF WORD						; Adjust IP to point at next instruction
	cmp		edx, -OTENTRYSIZE						; true is Oop before false
	jne		@F										; Not a boolean?
	
	; it was true, so dispatch next
	DispatchByteCode

@@:	; Errorneous attempt to branch on non-boolean object
	sub		_IP, 1+SIZEOF WORD
	add		_SP, OOPSIZE			; Unpop
	SendSelectorNoArgs <Pointers.MustBeBooleanSelector>
ENDBYTECODE longJumpIfFalse

BEGINRARECODE longJumpIfNil
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	cmp		edx, [oteNil]
	jne		@F

	movsx	eax, WORD PTR[_IP]						; Sign extend instruction argument word (offset) into EAX
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after double byte of instruction extension)
	DispatchByteCode

@@:
	add		_IP, SIZEOF WORD						; Adjust IP to point at next instruction
	; it was not nil, so dispatch next
	DispatchByteCode
ENDBYTECODE longJumpIfNil

BEGINRARECODE longJumpIfNotNil
	mov		edx, [_SP]
	sub		_SP, OOPSIZE
	cmp		edx, [oteNil]
	je		@F

	movsx	eax, WORD PTR[_IP]						; Sign extend instruction argument word (offset) into EAX
	lea		_IP, [_IP+eax+2]						; Offset 0 is the next instruction (after double byte of instruction extension)
	DispatchByteCode

@@:
	add		_IP, SIZEOF WORD						; Adjust IP to point at next instruction
	; it was nil, so dispatch next
	DispatchByteCode
ENDBYTECODE longJumpIfNotNil

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Extended Supersend Instruction (triple byte).
;;
;; Extension specifies argument count (first byte) and selector literal index (second byte)
;; This byte code is very, very, rarely used

BEGINRARECODE longSupersend
	IFDEF _DEBUG
		FetchByte <d>	 						; argCount = next byte code
		FetchByte							; literal index = next byte code
		jmp		sendLiteralSelectorToSuper		; Use code shared with singleExtendedSuperBytecode
	ELSE
		xor		ecx, ecx
		movzx	edx, BYTE PTR[_IP]				; argCount = first byte code
		mov		cl, BYTE PTR[_IP+1]				; literal index = last byte code
		add		_IP, 2
		jmp	sendLiteralSelectorToSuper		; Use code shared with singleExtendedSuperBytecode
	ENDIF
ENDBYTECODE longSupersend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Double Extended Supersend Instruction (quad byte).
;;
;; Extension specifies argument count (first byte) and selector literal index (last two bytes)
;; This byte code is very, very, very, rarely used

BEGINRARECODE exLongSupersend
	movzx	edx, BYTE PTR[_IP]				; argCount = first byte code
	movzx	ecx, WORD PTR[_IP+1]			; literal index = last byte codes
	add		_IP, 3
	jmp		sendLiteralSelectorToSuper		; Use code shared with singleExtendedSuperBytecode
ENDBYTECODE exLongSupersend

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Double Extended Send Instruction (quad byte). 
;;
;; Extension specifies argument count(first byte) and selector literal index (last two bytes)

BEGINRARECODE exLongSend
	mov		eax, [pMethod]					; Load pointer to current method
	ASSUME	eax: PTR CompiledCodeObj

	movzx	ecx, WORD PTR[_IP+1]

	movzx	edx, BYTE PTR[_IP]

	add		_IP, 3

	SendLiteralECXinEAXwithEDXArgs

	ASSUME	eax:NOTHING
ENDBYTECODE exLongSend

BEGINRARECODE longStoreStatic
	mov		eax, [_SP]
	movzx	ecx, WORD PTR[_IP]
	add		_IP, 2
	StoreStaticAndDispatch
ENDBYTECODE longStoreStatic

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Long Push Instructions (triple byte). 
;;
;; Extension is the index (0 based)

BEGINRARECODE longPushConstant
	movzx	ecx, WORD PTR[_IP]
	add		_IP, 2
	LoadLiteral ecx
	PushAndDispatch <a>
ENDBYTECODE longPushConstant

BEGINRARECODE longPushStatic
	movzx	ecx, WORD PTR[_IP]
	add		_IP, 2
	LoadStatic ecx
	PushAndDispatch <a>
ENDBYTECODE longPushStatic

LOuterTempPreamble MACRO
	mov		cl, BYTE PTR[_IP]
	movzx	eax, BYTE PTR[_IP+1]

	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EAX is now a pointer to the active context's fields

	mov		edx, [edx].m_environment
	mov		edx, (OTE PTR[edx]).m_location
	ASSUME	edx:PTR Context
	.WHILE	ecx > 0
		mov	edx, [edx].m_outer
		mov	edx, (OTE PTR[edx]).m_location
		dec	ecx
	.ENDW
ENDM

BEGINRARECODE longPushOuterTemp
	LOuterTempPreamble

	; Preload next bytecode in anticipation of dispatch
	mov		cl, BYTE PTR[_IP+2]
	mov		eax, [edx].m_tempFrame[eax*OOPSIZE]

IFDEF _DEBUG
	add		_IP, 2
	PushOop <a>
	DispatchByteCode
ELSE
	add		_IP, 3
	mov		[_SP+OOPSIZE], eax						;; push outer temp var onto stack
	ASSUME	eax:NOTHING
	add		_SP, OOPSIZE
	jmp		byteCodeTable[ecx*4]					;; Transfer control via jump table (will return to dispatchByte)
ENDIF
ENDBYTECODE longPushOuterTemp

BEGINRARECODE longStoreOuterTemp
	LOuterTempPreamble
	ASSUME	edx:PTR Context		; EDX points to the Context containing the temp
	ASSUME	eax:DWORD			; EAX is pointer to 
	ASSUME	ecx:NOTHING			; ECX is 0

	mov		ecx, [_SP]								;; Load Oop to store from ToS
	lea		edx, [edx].m_tempFrame[eax*OOPSIZE]
	ASSUME	edx:Ptr Oop
	CountUpOopIn <c>								;; Must count up as stored into a Context object

	mov		eax, [edx]								;; Load existing value of temporary
	mov		[edx], ecx								;; And overwrite with new value

	add		_IP, 2
	CountDownOopIn <a>								;; Must count down Context temps
	DispatchByteCode
ENDBYTECODE longStoreOuterTemp

BEGINRARECODE noOp
	DispatchByteCode
ENDBYTECODE noOp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Push Active Frame Instruction (single byte)

BEGINRARECODE pushActiveFrame
	; Save down the current active process' size based on the current SP
	mov		eax, _SP
	ASSUME	eax:DWORD
	mov		edx, [ACTIVEPROCESS]
	ASSUME	edx:PTR Process					; EAX is now a pointer to the active context's fields
	
	; "Resize" the active process (i.e. update its size to reflect the current top of stack)
	mov		ecx, [OTEACTIVEPROCESS]
	ASSUME	ecx:PTR OTE
	sub		eax, edx
	add		eax, OOPSIZE					; size = end - start + 1
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame					; EAX is now a pointer to the active context's fields
	mov		[ecx].m_size, eax

	; Save down _SP of the current active context (may be useful, but only approximate)
	lea		eax, [_SP+1]
	mov		[edx].m_sp, eax
	ASSUME	edx:NOTHING

	or		edx, 1							; Make active frame address a SmallInteger pointer
	PushAndDispatch <d>						; And push it on to the stack before continuing
ENDBYTECODE pushActiveFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is the debug break byte code (0)
BEGINRARECODE break
	mov		edx, [ACTIVEFRAME]
	ASSUME	edx:PStackFrame						; EDX is now a pointer to the active context's fields

	; Save down _SP of the current active context (may be useful, but only approximate)
	mov		[STEPPING], FALSE						; Prevent any single step interrupt!
	mov		ecx, HALTINTERRUPT						; Load interrupt number to send

	ResetInputPollCounter
	or		edx, 1									; Make it a SmallInteger pointer to the frame
	CallCPPAndLoop	<SENDVMINTERRUPT>

	ASSUME	edx:NOTHING
ENDBYTECODE break

; This routine invoked when an unrecognised byte code number is
; encountered, and if you want to know what it is, its index is
; in AL.
BEGINRARECODE invalidByteCode
	int		3									; Exit to debugger
	DispatchByteCode
ENDBYTECODE invalidByteCode


END		;; Thats all folks
