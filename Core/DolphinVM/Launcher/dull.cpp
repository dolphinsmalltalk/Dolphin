// Dull.cpp - Main routine for development system launcher
//
// Dolphin.exe is executed with either a .img file as an argument or
// else the default .img file is used

#include "ist.h"
#include "startVM.h"
#include "DolphinSmalltalk_i.h"
#include "resource.h"
#include "..\rc_stub.h"
#include "ImageFileMapping.h"

#if _MSC_FULL_VER >= 140040130
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df'\"")
#endif

/////////////////////////////////////////////////////////////////////

// Currently this behaves in the same was as the default _matherr function.
int __cdecl _matherr(struct _exception *except)
{
	UNREFERENCED_PARAMETER(except);
	return 0;
}

HRESULT __stdcall ErrorUnableToCreateVM(HRESULT hr)
{
	return ReportWin32Error(IDP_CREATEVMFAILED, hr);
}

static const wchar_t* FindImageNameArg()
{
	LPCWSTR szImage = L"DPRO.img7";
	static wchar_t achImageName[_MAX_PATH];

	for (auto i=1;i<__argc;i++)
	{
		const wchar_t* arg = __wargv[i];
		wchar_t ch = *arg;
		if (ch != L'/' && ch != L'-')
		{
			szImage = __wargv[i];
			break;
		}
	}

	wchar_t* filePart;
	::GetFullPathNameW(szImage, _MAX_PATH, achImageName, &filePart);
	return achImageName;
}

static HRESULT StartOldImage(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPCWSTR lpCmdLine, int nCmdShow, 
						 const wchar_t* szImageName, uint16_t versionMajor)
{
	const CLSID* pVMCLSID = NULL;
	LPCWSTR pszVM = NULL;

	switch(versionMajor)
	{
	case 3:		// Dolphin 3.06
		pVMCLSID = &__uuidof(DolphinSmalltalk3);
		pszVM = L"DolphinVM003.DLL";
		break;

	case 4:		// Dolphin 4.01
		pVMCLSID = &__uuidof(DolphinSmalltalk4);
		pszVM = L"DolphinVM004.DLL";
		break;

	case 5:		// Dolphin 5.1
		pVMCLSID = &__uuidof(DolphinSmalltalk51);
		pszVM = L"DolphinVM005.DLL";
		break;

	case 6:		// Dolphin 6
		pszVM = L"DolphinVM006.DLL";
		pVMCLSID = &__uuidof(DolphinSmalltalk62);
		break;

	case 7:		// Dolphin 7 (or unknown)
		pszVM = L"DolphinVM7.DLL";
		pVMCLSID = &__uuidof(DolphinSmalltalk);
		break;

	default:
		return ReportError(IDP_UNRECOGNISEDIMAGEVERSION, szImageName, (int)versionMajor);
	}

	IDolphinStart3* piDolphin;
	HRESULT hr = CreateVM(CLSCTX_INPROC_SERVER, pVMCLSID, pszVM, __uuidof(IDolphinStart3), reinterpret_cast<void**>(&piDolphin));

	if (SUCCEEDED(hr))
	{
		int cbCmdLine = wcslen(lpCmdLine) + 1;
		char* cmdLine = (char*)malloc(cbCmdLine);
		::WideCharToMultiByte(CP_ACP, 0, lpCmdLine, -1, cmdLine, cbCmdLine, nullptr, nullptr);
		int cbImageName = wcslen(szImageName) + 1;
		char* imageName = (char*)malloc(cbImageName);
		::WideCharToMultiByte(CP_ACP, 0, lpCmdLine, -1, imageName, cbImageName, nullptr, nullptr);

		// Note that this does now return
		hr = piDolphin->Start(hInstance, hPrevInstance, cmdLine, nCmdShow, 0, imageName, NULL);
		piDolphin->Release();
		free(cmdLine);
		free(imageName);
	}

	return hr;
}

static HRESULT __stdcall StartDevSys(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPCWSTR lpCmdLine, int nCmdShow)
{
	const wchar_t* szImageName = FindImageNameArg();

	ImageFileMapping imageFile;
	int ret = imageFile.Open(szImageName);
	if (ret < 0)
		return ReportError(IDP_OPENIMAGEFAILURE, szImageName);

	if (imageFile.GetType() != ImageFileMapping::ISTIMAGE)
		return ReportError(IDP_INVALIDIMAGETYPE, szImageName, reinterpret_cast<char*>(imageFile.GetData()));

	ImageHeader* pHeader = imageFile.GetHeader();
	uint16_t versionMajor = LOWORD(pHeader->versionMS);
	if (versionMajor < 6)
	{
		imageFile.Close();
		return StartOldImage(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				szImageName, versionMajor);
	}

	IDolphinStart* piDolphin = NULL;
	HRESULT hr = CreateVM(CLSCTX_INPROC_SERVER, NULL, NULL, __uuidof(IDolphinStart), reinterpret_cast<void**>(&piDolphin));
	if FAILED(hr)
		return hr;

	// Perform a more detailed version check against the actual VM loaded
	VS_FIXEDFILEINFO vi;
	hr = piDolphin->GetVersionInfo(&vi);
	if (pHeader->versionMS != vi.dwProductVersionMS)
	{
		// version mismatch; this image file is probably invalid
		int resp = DolphinMessageBox(IDP_VERSIONMISMATCH, MB_YESNO|MB_ICONWARNING,
			HIWORD(pHeader->versionMS), LOWORD(pHeader->versionMS), HIWORD(pHeader->versionLS), LOWORD(pHeader->versionLS),
			HIWORD(vi.dwProductVersionMS), LOWORD(vi.dwProductVersionMS), HIWORD(vi.dwProductVersionLS), LOWORD(vi.dwProductVersionLS),
			szImageName);
		if (resp != IDYES)
			return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, IDP_VERSIONMISMATCH);
	}

	hr = piDolphin->Initialise(hInstance, szImageName, imageFile.GetRawData(), imageFile.GetRawSize(), /*IsDevSys*/1);
	if (FAILED(hr))
		return hr;

	// Once loaded, the image file is no longer needed and can be unmapped and closed.
	imageFile.Close();

	hr = piDolphin->Run(NULL);
	piDolphin->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////
int APIENTRY 
wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
	HRESULT hr = ::CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

 	int nRet = StartDevSys(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
	::CoUninitialize();
	return nRet;
}

HMODULE __stdcall GetResLibHandle()
{
	return GetModuleHandle(NULL);
}

///////////////////////////////////////////////////////////////////////
