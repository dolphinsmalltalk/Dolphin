| package |
package := Package name: 'Windows Service Manager'.
package paxVersion: 1;
	basicComment: 'Dolphin Smalltalk Win32 Service Manager
Copyright (c) Object Arts Ltd, 2024'.

package classNames
	add: #ENUM_SERVICE_STATUS_PROCESS;
	add: #SERVICE_STATUS;
	add: #SERVICE_STATUS_PROCESS;
	yourself.

package methodNames
	add: #AdvApiLibrary -> #allServiceNames;
	add: #AdvApiLibrary -> #closeServiceHandle:;
	add: #AdvApiLibrary -> #enumServices:type:state:;
	add: #AdvApiLibrary -> #enumServicesStatusEx:infoLevel:dwServiceType:dwServiceState:lpServices:cbBufSize:pcbBytesNeeded:lpServicesReturned:lpResumeHandle:pszGroupName:;
	add: #AdvApiLibrary -> #getServiceState:;
	add: #AdvApiLibrary -> #isServiceRunning:;
	add: #AdvApiLibrary -> #openSCManager:lpDatabaseName:dwDesiredAccess:;
	add: #AdvApiLibrary -> #openService:lpServiceName:dwDesiredAccess:;
	add: #AdvApiLibrary -> #queryServiceStatusEx:infoLevel:lpBuffer:cbBufSize:pcbBytesNeeded:;
	add: #AdvApiLibrary -> #serviceStatii:;
	add: #AdvApiLibrary -> #win32ServiceNames;
	add: #AdvApiLibrary -> #win32ServiceStatii;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\..\Base\Dolphin').

package!

"Class Definitions"!

Win32Structure subclass: #ENUM_SERVICE_STATUS_PROCESS
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_lpDisplayName _OffsetOf_lpServiceName _OffsetOf_ServiceStatusProcess SERVICE_ACTIVE SERVICE_ADAPTER SERVICE_DRIVER SERVICE_FILE_SYSTEM_DRIVER SERVICE_INACTIVE SERVICE_INTERACTIVE_PROCESS SERVICE_KERNEL_DRIVER SERVICE_PKG_SERVICE SERVICE_RECOGNIZER_DRIVER SERVICE_STATE_ALL SERVICE_TYPE_ALL SERVICE_USER_OWN_PROCESS SERVICE_USER_SERVICE SERVICE_USER_SHARE_PROCESS SERVICE_USERSERVICE_INSTANCE SERVICE_WIN32 SERVICE_WIN32_OWN_PROCESS SERVICE_WIN32_SHARE_PROCESS'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Win32Structure subclass: #SERVICE_STATUS
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_dwCheckPoint _OffsetOf_dwControlsAccepted _OffsetOf_dwCurrentState _OffsetOf_dwServiceSpecificExitCode _OffsetOf_dwServiceType _OffsetOf_dwWaitHint _OffsetOf_dwWin32ExitCode SC_STATUS_PROCESS_INFO SERVICE_CONTINUE_PENDING SERVICE_PAUSE_PENDING SERVICE_PAUSED SERVICE_RUNNING SERVICE_START_PENDING SERVICE_STOP_PENDING SERVICE_STOPPED'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

SERVICE_STATUS subclass: #SERVICE_STATUS_PROCESS
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_dwProcessId _OffsetOf_dwServiceFlags'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Loose Methods"!

!AdvApiLibrary methodsFor!

allServiceNames
	"
	AdvApi32 allServiceNames size
	"
	| services |
	services := OrderedCollection new.
	self
		enumServices: [:each | services addLast: each lpServiceName]
		type: ENUM_SERVICE_STATUS_PROCESS.SERVICE_TYPE_ALL
		state: ENUM_SERVICE_STATUS_PROCESS.SERVICE_STATE_ALL.
	^services!

closeServiceHandle: hSCObject
	"Invoke the CloseServiceHandle() function of the module wrapped by the receiver.
	Helpstring: Closes a handle to a service control manager or service object.

		BOOL __stdcall CloseServiceHandle(
			HANDLE hSCObject);"

	<stdcall: bool CloseServiceHandle handle>
	^self invalidCall: _failureCode!

enumServices: aMonadicValuable type: typeInteger state: stateInteger
	"Answer the current state of a named service."

	| hSCManager |
	hSCManager := self
				openSCManager: nil
				lpDatabaseName: nil
				dwDesiredAccess: 4.	"SC_MANAGER_ENUMERATE_SERVICE"
	hSCManager ifNil: [^self systemError].
	
	[| buf bytesNeeded servicesReturned resumeHandle ret |
	bytesNeeded := DWORDBytes new.
	servicesReturned := DWORDBytes new.
	resumeHandle := ExternalHandle new.
	"First call to establish initial buffer size"
	self
		enumServicesStatusEx: hSCManager
		infoLevel: 0
		dwServiceType: typeInteger
		dwServiceState: stateInteger
		lpServices: nil
		cbBufSize: 0
		pcbBytesNeeded: bytesNeeded
		lpServicesReturned: servicesReturned
		lpResumeHandle: resumeHandle
		pszGroupName: nil.
	ret := KernelLibrary default getLastError.
	ret ~~ ERROR_MORE_DATA ifTrue: [self systemError: ret].
	
	[buf := ByteArray newFixed: bytesNeeded value.
	(self
		enumServicesStatusEx: hSCManager
		infoLevel: 0
		dwServiceType: typeInteger
		dwServiceState: stateInteger
		lpServices: buf
		cbBufSize: buf size
		pcbBytesNeeded: bytesNeeded
		lpServicesReturned: servicesReturned
		lpResumeHandle: resumeHandle
		pszGroupName: nil)
			ifTrue: [ret := ERROR_SUCCESS]
			ifFalse: 
				[ret := KernelLibrary default getLastError.
				ret ~~ ERROR_MORE_DATA ifTrue: [self systemError: ret]].
	(StructureArray basicNew
		bytes: buf;
		length: servicesReturned value elementClass: ENUM_SERVICE_STATUS_PROCESS) do: aMonadicValuable.
	ret == ERROR_MORE_DATA]
			whileTrue]
			ensure: [self closeServiceHandle: hSCManager]!

enumServicesStatusEx: hSCManager infoLevel: infoLevel dwServiceType: dwServiceType dwServiceState: dwServiceState lpServices: lpServices cbBufSize: cbBufSize pcbBytesNeeded: pcbBytesNeeded lpServicesReturned: lpServicesReturned lpResumeHandle: lpResumeHandle pszGroupName: pszGroupName
	"Invoke the EnumServicesStatusEx() function of the module wrapped by the receiver.
	Helpstring: Enumerates services in the specified service control manager database.

		BOOL __stdcall EnumServicesStatusEx(
			HANDLE hSCManager,
			SC_ENUM_TYPE InfoLevel,
			DWORD dwServiceType,
			DWORD dwServiceState,
			ENUM_SERVICE_STATUS_PROCESS* lpServices,
			DWORD cbBufSize,
			unsigned long* pcbBytesNeeded,
			unsigned long* lpServicesReturned,
			unsigned long* lpResumeHandle,
			LPCWSTR pszGroupName);"

	<stdcall: bool EnumServicesStatusExW handle sdword dword dword ENUM_SERVICE_STATUS_PROCESS* dword dword* dword* dword* lpwstr>
	^self invalidCall: _failureCode!

getServiceState: aString
	"Answer the current state of a named service."

	| hSCManager |
	hSCManager := self
				openSCManager: nil
				lpDatabaseName: nil
				dwDesiredAccess: GENERIC_READ.
	hSCManager ifNil: [^self systemError].
	^
	[(self
		openService: hSCManager
		lpServiceName: aString
		dwDesiredAccess: GENERIC_READ)
			ifNil: 
				["Service does not exist"
				#unknown]
			ifNotNil: 
				[:hService |
				
				[| status bytesNeeded |
				status := SERVICE_STATUS_PROCESS newBuffer.
				bytesNeeded := DWORDBytes new.
				(self
					queryServiceStatusEx: hService
					infoLevel: SERVICE_STATUS.SC_STATUS_PROCESS_INFO
					lpBuffer: status
					cbBufSize: status byteSize
					pcbBytesNeeded: bytesNeeded) ifTrue: [status currentState] ifFalse: [self systemError]]
						ensure: [self closeServiceHandle: hService]]]
			ensure: [self closeServiceHandle: hSCManager]!

isServiceRunning: aString
	"Answer whether the named service is running."

	^(self getServiceState: aString) == #running!

openSCManager: lpMachineName lpDatabaseName: lpDatabaseName dwDesiredAccess: dwDesiredAccess
	"Invoke the OpenSCManager() function of the module wrapped by the receiver.
	Helpstring: Establishes a connection to the service control manager on the specified computer and opens the specified service control manager database.

		HANDLE __stdcall OpenSCManager(
			LPCWSTR lpMachineName,
			LPCWSTR lpDatabaseName,
			DWORD dwDesiredAccess);"

	<stdcall: handle OpenSCManagerW lpwstr lpwstr dword>
	^self invalidCall: _failureCode!

openService: hSCManager lpServiceName: lpServiceName dwDesiredAccess: dwDesiredAccess
	"Invoke the OpenService() function of the module wrapped by the receiver.
	Helpstring: Opens an existing service.

		HANDLE __stdcall OpenService(
			HANDLE hSCManager,
			LPCWSTR lpServiceName,
			DWORD dwDesiredAccess);"

	<stdcall: handle OpenServiceW handle lpwstr dword>
	^self invalidCall: _failureCode!

queryServiceStatusEx: hService infoLevel: infoLevel lpBuffer: lpBuffer cbBufSize: cbBufSize pcbBytesNeeded: pcbBytesNeeded
	"Invoke the QueryServiceStatusEx() function of the module wrapped by the receiver.
	Helpstring: Retrieves the current status of the specified service based on the specified information level.

		BOOL __stdcall QueryServiceStatusEx(
			HANDLE hService,
			SC_STATUS_TYPE InfoLevel,
			BYTE* lpBuffer,
			DWORD cbBufSize,
			unsigned long* pcbBytesNeeded);"

	<stdcall: bool QueryServiceStatusEx handle sdword byte* dword dword*>
	^self invalidCall: _failureCode!

serviceStatii: anInteger
	| services |
	services := LookupTable new.
	self
		enumServices: [:each | services at: each lpServiceName put: each ServiceStatusProcess copy]
		type: anInteger
		state: ENUM_SERVICE_STATUS_PROCESS.SERVICE_STATE_ALL.
	^services!

win32ServiceNames
	"
	AdvApi32 win32ServiceNames
	"
	| services |
	services := OrderedCollection new.
	self
		enumServices: [:each | services addLast: each lpServiceName]
		type: ENUM_SERVICE_STATUS_PROCESS.SERVICE_WIN32
		state: ENUM_SERVICE_STATUS_PROCESS.SERVICE_STATE_ALL.
	^services!

win32ServiceStatii
	"
	AdvApi32 win32ServiceStatii
	"
	^self serviceStatii: ENUM_SERVICE_STATUS_PROCESS.SERVICE_WIN32! !

!AdvApiLibrary categoriesForMethods!
allServiceNames!enquiries!public! !
closeServiceHandle:!**auto generated**!public! !
enumServices:type:state:!enquiries!public! !
enumServicesStatusEx:infoLevel:dwServiceType:dwServiceState:lpServices:cbBufSize:pcbBytesNeeded:lpServicesReturned:lpResumeHandle:pszGroupName:!**auto generated**!public!win32 functions-service manager! !
getServiceState:!enquiries!public! !
isServiceRunning:!enquiries!public! !
openSCManager:lpDatabaseName:dwDesiredAccess:!**auto generated**!public!win32 functions-service manager! !
openService:lpServiceName:dwDesiredAccess:!**auto generated**!public!win32 functions-service manager! !
queryServiceStatusEx:infoLevel:lpBuffer:cbBufSize:pcbBytesNeeded:!**auto generated**!public!win32 functions-service manager! !
serviceStatii:!enquiries!public! !
win32ServiceNames!enquiries!public! !
win32ServiceStatii!enquiries!public! !
!

"End of package definition"!

