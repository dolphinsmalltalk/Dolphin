| package |
package := Package name: 'ActiveX Automation'.
package paxVersion: 1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk ActiveX Automation Support.
Copyright (c) Object Arts Ltd, 2000-2003.

This package is the basis of Dolphin''s extensive Active-X Automation support (formally called OLE Automation). It includes classes to enable the use of Dolphin as both an Automation client (or controller) and server. In here you will find classes to support the familar Automation types such as VARIANTs, BSTRs and SAFEARRAYs. This package also includes extensive support for extracting information from type libraries, with this being further augmented by the ''ActiveX Automation Development'' package, which uses the type-library analyzer to generate wrapper classes for COM objects, etc.

'.

package basicPackageVersion: '6.1'.

package basicScriptAt: #postinstall put: 'VMLibrary default
	registryAt: #BSTR put: BSTR;
	registryAt: #VARIANT put: VARIANT;
	registryAt: #IDispatch put: IDispatch.

"Register all the existing ExternalStructures so that they can support IRecordInfo"
ExternalStructure registerSubclasses.'.
package basicScriptAt: #postuninstall put: 'ExternalStructure classPool at: ''RecordClasses'' put: nil.'.

package classNames
	add: #AbstractELEMDESC;
	add: #ARRAYDESC;
	add: #AXAPIInfoAnalyzer;
	add: #AXDispatchImpAbstract;
	add: #AXDualImp;
	add: #AXForwardingDualImp;
	add: #AXInterfaceTypeAnalyzer;
	add: #AXMemberDesc;
	add: #AXRecord;
	add: #AXStructureTypeAnalyzer;
	add: #AXTypeInfoAnalyzer;
	add: #AXTypeInfoObject;
	add: #AXTypeInfoStructure;
	add: #AXTypeLibDocumentation;
	add: #AXTypeLibraryAnalyzer;
	add: #COMVariantEnumerator;
	add: #CURRENCY;
	add: #CUSTDATA;
	add: #CUSTDATAITEM;
	add: #DATE;
	add: #DECIMAL;
	add: #DispFunction;
	add: #DISPPARAMS;
	add: #ELEMDESC;
	add: #FONTDESC;
	add: #FUNCDESC;
	add: #ICreateErrorInfo;
	add: #IDispatch;
	add: #IDLDESC;
	add: #IEnumVARIANT;
	add: #IPerPropertyBrowsing;
	add: #IProvideClassInfo;
	add: #IProvideClassInfo2;
	add: #IRecordInfo;
	add: #ITypeComp;
	add: #ITypeInfo;
	add: #ITypeInfo2;
	add: #ITypeLib;
	add: #ITypeLib2;
	add: #LPBSTR;
	add: #PARAMDESC;
	add: #PARAMDESCEX;
	add: #SAFEARRAY;
	add: #SAFEARRAYBOUND;
	add: #TKindAliasAnalyzer;
	add: #TKindCoclassAnalyzer;
	add: #TKindDispatchAnalyzer;
	add: #TKindEnumAnalyzer;
	add: #TKindInterfaceAnalyzer;
	add: #TKindModuleAnalyzer;
	add: #TKindRecordAnalyzer;
	add: #TKindUnionAnalyzer;
	add: #TLIBATTR;
	add: #TYPEATTR;
	add: #TYPEDESC;
	add: #VARDESC;
	add: #VARIANT;
	add: #VARIANT_BOOL;
	yourself.

package methodNames
	add: #Boolean -> #asVariant;
	add: #BSTR -> #asSAFEARRAY;
	add: #BSTR -> #asVariant;
	add: #ByteArray -> #asSAFEARRAY;
	add: #Character -> #asVariant;
	add: #Collection -> #asSAFEARRAY;
	add: #Collection -> #asVariant;
	add: #COMInterface -> #coclassTypeInfo;
	add: #COMInterface -> #coclassTypeInfoIfNone:;
	add: #COMInterface -> #typeInfo;
	add: #COMInterface -> #typeInfoIfNone:;
	add: #Date -> #asFloat;
	add: #Date -> #asVariant;
	add: #DateAndTime -> #asFloat;
	add: #DateAndTime -> #asVariant;
	add: #ExternalArray -> #asSAFEARRAY;
	add: #ExternalArray -> #asVariant;
	add: #ExternalScalar -> #asVariant;
	add: #ExternalStructure -> #asVariant;
	add: #ExternalStructure -> #recordInfo;
	add: #ExternalStructure -> #vt;
	add: #Float -> #asVariant;
	add: #Fraction -> #asVariant;
	add: #Integer -> #asVariant;
	add: #IUnknown -> #asVariant;
	add: #LargeInteger -> #asVariant;
	add: #OLEAutLibrary -> #clearCustData:;
	add: #OLEAutLibrary -> #createErrorInfo:;
	add: #OLEAutLibrary -> #getRecordInfoFromTypeInfo:ppRecInfo:;
	add: #OLEAutLibrary -> #lHashValOfNameSys:lcid:szName:;
	add: #OLEAutLibrary -> #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:;
	add: #OLEAutLibrary -> #loadTypeLib:pptlib:;
	add: #OLEAutLibrary -> #loadTypeLibEx:regkind:pptlib:;
	add: #OLEAutLibrary -> #oleCreateFontIndirect:riid:ppvObj:;
	add: #OLEAutLibrary -> #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:;
	add: #OLEAutLibrary -> #registerTypeLib:wszFullPath:wszHelpDir:;
	add: #OLEAutLibrary -> #registerTypeLibForUser:szFullPath:szHelpDir:;
	add: #OLEAutLibrary -> #safeArrayAccessData:ppvData:;
	add: #OLEAutLibrary -> #safeArrayCopy:ppsaout:;
	add: #OLEAutLibrary -> #safeArrayCreateEx:cDims:rgsabound:pvExtra:;
	add: #OLEAutLibrary -> #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:;
	add: #OLEAutLibrary -> #safeArrayDestroy:;
	add: #OLEAutLibrary -> #safeArrayGetDim:;
	add: #OLEAutLibrary -> #safeArrayGetElement:rgIndices:pv:;
	add: #OLEAutLibrary -> #safeArrayGetIID:pguid:;
	add: #OLEAutLibrary -> #safeArrayGetLBound:nDim:plLbound:;
	add: #OLEAutLibrary -> #safeArrayGetRecordInfo:prinfo:;
	add: #OLEAutLibrary -> #safeArrayGetUBound:nDim:plUbound:;
	add: #OLEAutLibrary -> #safeArrayGetVartype:pvt:;
	add: #OLEAutLibrary -> #safeArrayPtrOfIndex:rgIndices:ppvData:;
	add: #OLEAutLibrary -> #safeArrayPutElement:rgIndices:pv:;
	add: #OLEAutLibrary -> #safeArrayRedim:psaboundNew:;
	add: #OLEAutLibrary -> #safeArraySetIID:pguid:;
	add: #OLEAutLibrary -> #safeArrayUnaccessData:;
	add: #OLEAutLibrary -> #safeArrayUnlock:;
	add: #OLEAutLibrary -> #setErrorInfo:perrinfo:;
	add: #OLEAutLibrary -> #systemTimeToVariantTime:pvtime:;
	add: #OLEAutLibrary -> #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:;
	add: #OLEAutLibrary -> #varCmp:pvarRight:lcid:dwFlags:;
	add: #OLEAutLibrary -> #varDateFromStr:lcid:dwFlags:pdateOut:;
	add: #OLEAutLibrary -> #variantChangeType:pvarSrc:wFlags:vt:;
	add: #OLEAutLibrary -> #variantClear:;
	add: #OLEAutLibrary -> #variantCopy:pvargSrc:;
	add: #OLEAutLibrary -> #variantCopyInd:pvargSrc:;
	add: #OLEAutLibrary -> #variantInit:;
	add: #OLEAutLibrary -> #variantTimeToSystemTime:lpSystemTime:;
	add: #ScaledDecimal -> #asVariant;
	add: #SmallInteger -> #asVariant;
	add: #String -> #asVariant;
	add: #SYSTEMTIME -> #asFloat;
	add: #SYSTEMTIME -> #asVariant;
	add: #UndefinedObject -> #asVariant;
	add: 'BOOL class' -> #typeName;
	add: 'BOOLEAN class' -> #typeName;
	add: 'BSTR class' -> #fromObject:;
	add: 'BSTR class' -> #newSAFEARRAY:;
	add: 'BSTR class' -> #typeName;
	add: 'BSTR class' -> #vt;
	add: 'BYTE class' -> #typeName;
	add: 'BYTE class' -> #vt;
	add: 'ByteArray class' -> #typeName;
	add: 'CLSID class' -> #newSAFEARRAY:;
	add: 'CLSID class' -> #vt;
	add: 'COMInterface class' -> #coclassTypeInfo;
	add: 'COMInterface class' -> #coclassTypeInfoIfNone:;
	add: 'COMInterface class' -> #errorNoTypeInfo;
	add: 'COMInterface class' -> #fromObject:;
	add: 'COMInterface class' -> #newSAFEARRAY:;
	add: 'COMInterface class' -> #registerDispinterface:;
	add: 'COMInterface class' -> #typeInfoIfNone:;
	add: 'COMInterface class' -> #typeLib;
	add: 'DOUBLE class' -> #typeName;
	add: 'DOUBLE class' -> #vt;
	add: 'DWORD class' -> #typeName;
	add: 'DWORD class' -> #vt;
	add: 'ExternalAddress class' -> #typeName;
	add: 'ExternalAddress class' -> #vt;
	add: 'ExternalArray class' -> #vt;
	add: 'ExternalHandle class' -> #typeName;
	add: 'ExternalInteger class' -> #typeName;
	add: 'ExternalInteger class' -> #vt;
	add: 'ExternalStructure class' -> #classForGUID:ifNone:;
	add: 'ExternalStructure class' -> #clearGuid;
	add: 'ExternalStructure class' -> #finalRelease;
	add: 'ExternalStructure class' -> #fromAddress:recordInfo:owner:;
	add: 'ExternalStructure class' -> #fromObject:;
	add: 'ExternalStructure class' -> #GetField:szFieldName:pvarField:;
	add: 'ExternalStructure class' -> #GetFieldNames:rgBstrNames:;
	add: 'ExternalStructure class' -> #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:;
	add: 'ExternalStructure class' -> #GetGuid:;
	add: 'ExternalStructure class' -> #GetName:;
	add: 'ExternalStructure class' -> #GetSize:;
	add: 'ExternalStructure class' -> #GetTypeInfo:;
	add: 'ExternalStructure class' -> #initializeRegister;
	add: 'ExternalStructure class' -> #IsMatchingType:;
	add: 'ExternalStructure class' -> #newSAFEARRAY:;
	add: 'ExternalStructure class' -> #pointerFieldType;
	add: 'ExternalStructure class' -> #PutField:pvData:szFieldName:pvarField:;
	add: 'ExternalStructure class' -> #PutFieldNoCopy:pvData:szFieldName:pvarField:;
	add: 'ExternalStructure class' -> #queryInterface:;
	add: 'ExternalStructure class' -> #queryInterface:ifNone:;
	add: 'ExternalStructure class' -> #RecordClear:;
	add: 'ExternalStructure class' -> #RecordCopy:pvNew:;
	add: 'ExternalStructure class' -> #RecordCreate;
	add: 'ExternalStructure class' -> #RecordCreateCopy:ppvDest:;
	add: 'ExternalStructure class' -> #RecordDestroy:;
	add: 'ExternalStructure class' -> #recordInfo;
	add: 'ExternalStructure class' -> #RecordInit:;
	add: 'ExternalStructure class' -> #registerSubclasses;
	add: 'ExternalStructure class' -> #supportedInterfaces;
	add: 'ExternalStructure class' -> #typeInfo;
	add: 'ExternalStructure class' -> #typeInfoIfNone:;
	add: 'ExternalStructure class' -> #typeLib;
	add: 'ExternalStructure class' -> #typeName;
	add: 'ExternalStructure class' -> #vt;
	add: 'FILETIME class' -> #vt;
	add: 'FLOAT class' -> #typeName;
	add: 'FLOAT class' -> #vt;
	add: 'GUID class' -> #typeName;
	add: 'HRESULT class' -> #typeName;
	add: 'HRESULT class' -> #vt;
	add: 'IErrorInfo class' -> #fromEXCEPINFO:guid:;
	add: 'IErrorInfo class' -> #source:description:helpContext:helpFile:guid:;
	add: 'INT_PTR class' -> #typeName;
	add: 'INT_PTR class' -> #vt;
	add: 'IUnknown class' -> #vt;
	add: 'LARGE_INTEGER class' -> #typeName;
	add: 'LARGE_INTEGER class' -> #vt;
	add: 'LPVOID class' -> #typeName;
	add: 'LPVOID class' -> #vt;
	add: 'QWORD class' -> #vt;
	add: 'SBYTE class' -> #typeName;
	add: 'SBYTE class' -> #vt;
	add: 'SDWORD class' -> #typeName;
	add: 'SDWORD class' -> #vt;
	add: 'String class' -> #pointerType;
	add: 'String class' -> #typeName;
	add: 'String class' -> #vt;
	add: 'SWORD class' -> #typeName;
	add: 'SWORD class' -> #vt;
	add: 'SYSTEMTIME class' -> #fromDATE:;
	add: 'UINT_PTR class' -> #typeName;
	add: 'UINT_PTR class' -> #vt;
	add: 'ULARGE_INTEGER class' -> #typeName;
	add: 'UndefinedObject class' -> #typeName;
	add: 'UndefinedObject class' -> #vt;
	add: 'Utf16String class' -> #pointerType;
	add: 'Utf16String class' -> #typeName;
	add: 'Utf16String class' -> #vt;
	add: 'VOID class' -> #typeName;
	add: 'VOID class' -> #vt;
	add: 'WORD class' -> #typeName;
	add: 'WORD class' -> #vt;
	yourself.

package globalNames
	add: #AXAutomationConstants;
	add: #AXAutomationErrors;
	add: #AXTypeGenerationFlags;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\..\Base\Dolphin'
	'..\..\Base\Dolphin Conformant Array Fields'
	'..\..\Base\Dolphin Legacy Date & Time'
	'..\COM\OLE COM').

package!

"Class Definitions"!

Object subclass: #AXTypeInfoObject
	instanceVariableNames: 'tlbInterface generationFlags'
	classVariableNames: 'ClassCommentStyleMap GuidClash HighLevelWrapperStyleMap SuperclassClash TracingStyleMap'
	poolDictionaries: 'AXAutomationConstants AXTypeGenerationFlags'
	classInstanceVariableNames: ''!

Object subclass: #AXTypeLibDocumentation
	instanceVariableNames: 'name helpstring helpcontext helpfile'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoObject subclass: #AXTypeInfoAnalyzer
	instanceVariableNames: 'typeLib globalBinding guid index documentation'
	classVariableNames: 'VTtoIDLTypeMap'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoObject subclass: #AXTypeLibraryAnalyzer
	instanceVariableNames: 'attributes prefix packageName globalName constantsPoolName aliasMap typeAnalyzers'
	classVariableNames: 'TypeLibs'
	poolDictionaries: 'AXAutomationErrors Win32Constants'
	classInstanceVariableNames: ''!

AXTypeInfoAnalyzer subclass: #AXAPIInfoAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoAnalyzer subclass: #AXStructureTypeAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'BuiltIns'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoAnalyzer subclass: #TKindAliasAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'BaseTypes'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoAnalyzer subclass: #TKindCoclassAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXTypeInfoAnalyzer subclass: #TKindEnumAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXAPIInfoAnalyzer subclass: #AXInterfaceTypeAnalyzer
	instanceVariableNames: 'protocol isSource'
	classVariableNames: 'ReservedDispSelectors ReservedUnkSelectors'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXAPIInfoAnalyzer subclass: #TKindModuleAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXInterfaceTypeAnalyzer subclass: #TKindDispatchAnalyzer
	instanceVariableNames: ''
	classVariableNames: 'SpecialPropGets'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXInterfaceTypeAnalyzer subclass: #TKindInterfaceAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXStructureTypeAnalyzer subclass: #TKindRecordAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXStructureTypeAnalyzer subclass: #TKindUnionAnalyzer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

COMFunction subclass: #DispFunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'Win32Errors'
	classInstanceVariableNames: ''!

COMInterfaceImp subclass: #AXDispatchImpAbstract
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors Win32Constants'
	classInstanceVariableNames: ''!

AXDispatchImpAbstract subclass: #AXDualImp
	instanceVariableNames: 'interface piTypeInfo locale'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXDualImp subclass: #AXForwardingDualImp
	instanceVariableNames: 'interfaceClass server'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

COMEnumerator subclass: #COMVariantEnumerator
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IUnknown subclass: #ICreateErrorInfo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IUnknown subclass: #IDispatch
	instanceVariableNames: 'typeInfo dispatchImplementor'
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

IUnknown subclass: #IPerPropertyBrowsing
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IUnknown subclass: #IProvideClassInfo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IUnknown subclass: #IRecordInfo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

IUnknown subclass: #ITypeComp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IUnknown subclass: #ITypeInfo
	instanceVariableNames: 'attributes'
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

IUnknown subclass: #ITypeLib
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

IEnumXXXX subclass: #IEnumVARIANT
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

IProvideClassInfo subclass: #IProvideClassInfo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

ITypeInfo subclass: #ITypeInfo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

ITypeLib subclass: #ITypeLib2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

GenericExternalArray subclass: #SAFEARRAY
	instanceVariableNames: 'data start recordInfo'
	classVariableNames: '_OffsetOf_cbElements _OffsetOf_cDims _OffsetOf_cLocks _OffsetOf_fFeatures _OffsetOf_pvData _OffsetOf_rgsabound'
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

DOUBLE subclass: #DATE
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

SWORD subclass: #VARIANT_BOOL
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

LPVOID subclass: #LPBSTR
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEStructure subclass: #AbstractELEMDESC
	instanceVariableNames: 'owner tdesc'
	classVariableNames: '_OffsetOf_tdescElem'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #CURRENCY
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_cy'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #CUSTDATAITEM
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_guid _OffsetOf_varValue'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEStructure subclass: #DECIMAL
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_hi32 _OffsetOf_lo64 _OffsetOf_scale _OffsetOf_sign _OffsetOf_wReserved'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #DISPPARAMS
	instanceVariableNames: 'args vargs dispids'
	classVariableNames: '_OffsetOf_cArgs _OffsetOf_cNamedArgs _OffsetOf_rgdispidNamedArgs _OffsetOf_rgvarg ZeroArgs'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #FONTDESC
	instanceVariableNames: 'name'
	classVariableNames: '_OffsetOf_cySize _OffsetOf_dwSize _OffsetOf_fItalic _OffsetOf_fStrikethrough _OffsetOf_fUnderline _OffsetOf_lpstrName _OffsetOf_sCharset _OffsetOf_sWeight'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEStructure subclass: #IDLDESC
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_dwReserved _OffsetOf_wIDLFlags'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #PARAMDESC
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_pparamdescex _OffsetOf_wParamFlags'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #PARAMDESCEX
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_cBytes _OffsetOf_varDefaultValue'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEStructure subclass: #SAFEARRAYBOUND
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_cElements _OffsetOf_lLbound'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEStructure subclass: #TLIBATTR
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_guid _OffsetOf_lcid _OffsetOf_syskind _OffsetOf_wLibFlags _OffsetOf_wMajorVerNum _OffsetOf_wMinorVerNum'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEStructure subclass: #TYPEDESC
	instanceVariableNames: 'owner classDesc typeInfo'
	classVariableNames: '_OffsetOf_hreftype _OffsetOf_lpadesc _OffsetOf_lptdesc _OffsetOf_vt VTIndirections'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

AbstractELEMDESC subclass: #ARRAYDESC
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_cDims _OffsetOf_rgbounds'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AbstractELEMDESC subclass: #ELEMDESC
	instanceVariableNames: 'param'
	classVariableNames: '_OffsetOf_paramdesc'
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEFinalizableStructure subclass: #AXRecord
	instanceVariableNames: 'recordInfo owner'
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors'
	classInstanceVariableNames: ''!

OLEFinalizableStructure subclass: #AXTypeInfoStructure
	instanceVariableNames: 'analyzer'
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

OLEFinalizableStructure subclass: #CUSTDATA
	instanceVariableNames: 'contents'
	classVariableNames: '_OffsetOf_cCustData _OffsetOf_prgCustData WellKnownCustomAttributes'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

OLEFinalizableStructure subclass: #VARIANT
	instanceVariableNames: 'data'
	classVariableNames: '_OffsetOf_dblVal _OffsetOf_vt _OffsetOf_wReserved1 _OffsetOf_wReserved2 _OffsetOf_wReserved3 Unspecified VTClasses VTNames'
	poolDictionaries: 'AXAutomationConstants AXAutomationErrors Win32Constants'
	classInstanceVariableNames: ''!

AXTypeInfoStructure subclass: #AXMemberDesc
	instanceVariableNames: 'index customAttributes documentation'
	classVariableNames: ''
	poolDictionaries: 'AXAutomationConstants'
	classInstanceVariableNames: ''!

AXTypeInfoStructure subclass: #TYPEATTR
	instanceVariableNames: 'piTypeInfo'
	classVariableNames: '_OffsetOf_cbAlignment _OffsetOf_cbSizeInstance _OffsetOf_cbSizeVft _OffsetOf_cFuncs _OffsetOf_cImplTypes _OffsetOf_cVars _OffsetOf_dwReserved _OffsetOf_guid _OffsetOf_idldescType _OffsetOf_lcid _OffsetOf_lpstrSchema _OffsetOf_memidConstructor _OffsetOf_memidDestructor _OffsetOf_tdescAlias _OffsetOf_typekind _OffsetOf_wMajorVerNum _OffsetOf_wMinorVerNum _OffsetOf_wTypeFlags'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXMemberDesc subclass: #FUNCDESC
	instanceVariableNames: 'names arguments outputIndices retvalIndex methodName'
	classVariableNames: '_OffsetOf_callconv _OffsetOf_cParams _OffsetOf_cParamsOpt _OffsetOf_cScodes _OffsetOf_elemdescFunc _OffsetOf_funckind _OffsetOf_invkind _OffsetOf_lprgelemdescParam _OffsetOf_lprgscode _OffsetOf_memid _OffsetOf_oVft _OffsetOf_wFuncFlags'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

AXMemberDesc subclass: #VARDESC
	instanceVariableNames: ''
	classVariableNames: '_OffsetOf_elemdesc _OffsetOf_lpstrSchema _OffsetOf_lpvarValue _OffsetOf_memid _OffsetOf_oInst _OffsetOf_varkind _OffsetOf_wVarFlags'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Loose Methods"!

!BOOL class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !

!BOOL class categoriesForMethods!
typeName!constants!private! !
!

!Boolean methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^VARIANT fromBoolean: self! !

!Boolean categoriesForMethods!
asVariant!converting!public! !
!

!BOOLEAN class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !

!BOOLEAN class categoriesForMethods!
typeName!constants!private! !
!

!BSTR methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: SWORD!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !

!BSTR categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!BSTR class methodsFor!

fromObject: anObject
	^self fromString: anObject!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY length: length vt: self vt elementClass: self!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_BSTR! !

!BSTR class categoriesForMethods!
fromObject:!instance creation!public! !
newSAFEARRAY:!double dispatch!public! !
typeName!constants!private! !
vt!constants!public! !
!

!BYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#byte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI1! !

!BYTE class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!ByteArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: BYTE! !

!ByteArray categoriesForMethods!
asSAFEARRAY!converting!public! !
!

!ByteArray class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !

!ByteArray class categoriesForMethods!
typeName!constants!private! !
!

!Character methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I2). This will fail for code points not in the BMP."

	^VARIANT new
		sword: self codePoint;
		yourself! !

!Character categoriesForMethods!
asVariant!converting!public! !
!

!CLSID class methodsFor!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY length: length 	vt: self vt elementClass: self!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_CLSID
! !

!CLSID class categoriesForMethods!
newSAFEARRAY:!double dispatch!public! !
vt!constants!public! !
!

!Collection methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self!

asVariant
	"Answer the VARIANT representation of the receiver (a SAFEARRAY of VARIANT)."

	^VARIANT fromCollection: self! !

!Collection categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!COMInterface methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self class errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the object on which the receiver is an interface."

	^(self queryInterface: IProvideClassInfo) 
		ifNil: [self class coclassTypeInfoIfNone: [^exceptionHandler value]]
		ifNotNil: 
			[:ipc | 
			[AXTypeInfoAnalyzer onTypeInfo: ipc getClassInfo] on: HRESULTError
				do: [:ex | ^exceptionHandler value]]!

typeInfo
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^self typeInfoIfNone: [self class errorNoTypeInfo]!

typeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^(self coclassTypeInfoIfNone: [^exceptionHandler value]) defaultInterface! !

!COMInterface categoriesForMethods!
coclassTypeInfo!accessing!public! !
coclassTypeInfoIfNone:!accessing!public! !
typeInfo!accessing!public! !
typeInfoIfNone:!accessing!public! !
!

!COMInterface class methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler 
	"Answer any type information that exists for the object on which the receiver is the default interface.
	This link can only be made if the #clsid method is defined and a type library with the relevant
	information is available."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [tlb typeInfoForGuid: self clsid ifNone: [^exceptionHandler value]]!

errorNoTypeInfo
	"Private - Raise an exception to the effect that the receiver has no associated
	type information available."

	^self error: 'No type information available.'!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^anObject queryInterface: self!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver."

	^SAFEARRAY length: length interfaceClass: self!

registerDispinterface: anIID
	"Register the specified <IID> as another dispinterface (i.e. an IID implemented by IDispatch)."

	InterfaceClasses at: anIID put: IDispatch!

typeInfoIfNone: exceptionHandler
	"Answer an <AXInterfaceTypeAnalyzer> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [(tlb typeInfoForGuid: self guid ifNone: [^exceptionHandler value]) asImplType]!

typeLib
	"Answer an <AXTypeLibraryAnalyzer> on the receiver's type library,
	or nil if the receiver does not have a type library."

	^typeLib! !

!COMInterface class categoriesForMethods!
coclassTypeInfo!accessing!public! !
coclassTypeInfoIfNone:!accessing!public! !
errorNoTypeInfo!exceptions!private! !
fromObject:!instance creation!public! !
newSAFEARRAY:!double dispatch!public! !
registerDispinterface:!adding!public! !
typeInfoIfNone:!accessing!public! !
typeLib!accessing!public! !
!

!Date methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !

!Date categoriesForMethods!
asFloat!converting!public! !
asVariant!converting!public! !
!

!DateAndTime methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the <VARIANT> representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !

!DateAndTime categoriesForMethods!
asFloat!converting!public! !
asVariant!converting!public! !
!

!DOUBLE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#double!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_R8! !

!DOUBLE class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!DWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#dword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI4! !

!DWORD class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!ExternalAddress class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpvoid!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_PTR! !

!ExternalAddress class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!ExternalArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver."

	^SAFEARRAY withAll: self elementClass: self elementClass!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_ARRAY|VT_XX)."

	^VARIANT fromCollection: self! !

!ExternalArray categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!ExternalArray class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_CARRAY! !

!ExternalArray class categoriesForMethods!
vt!constants!public! !
!

!ExternalHandle class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#handle! !

!ExternalHandle class categoriesForMethods!
typeName!constants!private! !
!

!ExternalInteger class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^self subclassResponsibility!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self subclassResponsibility! !

!ExternalInteger class categoriesForMethods!
typeName!constants!private! !
vt!constants!private! !
!

!ExternalScalar methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^(VARIANT new)
		vt: (self vt bitOr: AXAutomationConstants.VT_BYREF);
		reference: self! !

!ExternalScalar categoriesForMethods!
asVariant!converting!public! !
!

!ExternalStructure methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Note that shis will be a reference to the receiver not a copy."

	^VARIANT new
		struct: self;
		yourself!

recordInfo
	"Answer an <IRecordInfo> on the receiver's type information."

	^self class recordInfo!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self class vt! !

!ExternalStructure categoriesForMethods!
asVariant!converting!public! !
recordInfo!accessing!public! !
vt!constants!private! !
!

!ExternalStructure class methodsFor!

classForGUID: aGUID ifNone: exceptionHandler
	"Private - Answer the <ExternalStructure> class (a subclass of the receiver) which
	represents the Record with <GUID>, aGUID, or if none is registered for that GUID
	then the result of evaluating the <niladicValuable>, exceptionHandler."

	^RecordClasses at: aGUID ifAbsent: exceptionHandler

	
!

clearGuid
	"Private - Set the receiver's GUID to be the null <GUID>.
	Override because we must retain our GUID for the table
	of record classes (only needed for ActiveX Automation)."

!

finalRelease
	"The last reference to the receiver (as a COM object) has been released.
	This is an opportunity to actively clean up, rather than passively waiting 
	for finalization which might is asynchronous and may never happen if the 
	object doesn't become garbage."

	"Override as necessary"!

fromAddress: address recordInfo: recInfo owner: owner
	"Answer a new subinstance of the receiver which references the structure
	described by the <IRecordInfo>, recInfo, at the specified address,
	which is owned by the Object, owner."


	^(self 
		classForGUID: recInfo guid 
		ifNone: [^AXRecord 
				fromAddress: address
				recordInfo: recInfo
				owner: owner])
		fromAddress: address!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^(self newBuffer)
		value: anObject;
		yourself!

GetField: pvData szFieldName: szFieldName pvarField: pvarField 
	"Implement the IRecordInfo::GetField() method for the UDT described by the receiver.

		HRESULT __stdcall GetField(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField);

	"

	| refInst hr |
	refInst := self fromAddress: pvData.
	"Help specifies that VariantClear is call on pvarField before copying, normally but just VariantInit, but ..."
	pvarField class clear: pvarField yourAddress.
	
	[pvarField value: (refInst getField: szFieldName).
	hr := 0	"S_OK"] on: MessageNotUnderstood
			do: [:x | hr := Win32Errors.E_INVALIDARG].
	^hr!

GetFieldNames: pcNames rgBstrNames: rgBstrNames
	"Implement the IRecordInfo::GetFieldNames() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNames(
			[in, out] unsigned long* pcNames,
			[out] BSTR* rgBstrNames);
	"

	| names |
	names := self getFieldNames.
	rgBstrNames isNull
		ifTrue: [pcNames value: names size]
		ifFalse: 
			[| namesArray maxNames end |
			maxNames := pcNames value.
			"rgBstrNames will be an LPVOID holding the address of the buffer, which is a sufficiently sized array of BSTR pointers"
			namesArray := DWORDArray fromAddress: rgBstrNames yourAddress length: maxNames.
			end := names size min: maxNames.
			1 to: end do: [:i | namesArray at: i put: (names at: i) asBSTR detach].
			end + 1 to: maxNames do: [:i | namesArray at: i put: 0].
			pcNames value: end].
	^0	"S_OK"!

GetFieldNoCopy: pvData szFieldName: szFieldName pvarField: pvarField ppvDataCArray: ppvDataCArray
	"Implement the IRecordInfo::GetFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNoCopy(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField,
			[out] void** ppvDataCArray);
	"

	^Win32Errors.E_NOTIMPL
!

GetGuid: pguid
	"Implement the IRecordInfo::GetGuid() method for the UDT described by the receiver.

		HRESULT __stdcall GetGuid(
			[out] GUID* pguid);
	"

	pguid value: self guid.
	^0 "S_OK"
!

GetName: pbstrName
	"Implement the IRecordInfo::GetName() method for the UDT described by the receiver,
	i.e. answer the name of the record via the <BSTR>* output parameter.

		HRESULT __stdcall GetName(
			[out] BSTR* pbstrName);
	"

	pbstrName value: self name asBSTR detach.
	^0 "S_OK"
!

GetSize: pcbSize
	"Implement the IRecordInfo::GetSize() method for the UDT described by the receiver.

		HRESULT __stdcall GetSize(
			[out] unsigned long* pcbSize);
	"
	
	pcbSize value: self byteSize.
	^0 "S_OK"!

GetTypeInfo: ppTypeInfo
	"Implement the IRecordInfo::GetTypeInfo() method for the UDT described by the receiver.

		HRESULT __stdcall GetTypeInfo(
			[out] ITypeInfo** ppTypeInfo);
	"

	| ti |
	ppTypeInfo value: 0.
	ti := self typeInfoIfNone: [^1 "S_FALSE"].
	ti addRef.
	ppTypeInfo value: ti yourAddress.
	^0 "S_OK"
!

initializeRegister
	"Private - Initialize the register of GUIDs to record classes."

	RecordClasses := LookupTable new

!

IsMatchingType: pRecordInfo
	"Implement the IRecordInfo::IsMatchingType() method for the UDT described by the receiver.

		long __stdcall IsMatchingType(
			[in] IRecordInfo* pRecordInfo);
	"

	^(self guid = pRecordInfo guid) asParameter!

newSAFEARRAY: length 
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	| vt |
	^(vt := self vt) == AXAutomationConstants.VT_RECORD 
		ifTrue: [SAFEARRAY length: length recordClass: self]
		ifFalse: 
			[SAFEARRAY 
				length: length
				vt: vt
				elementClass: self]!

pointerFieldType
	"Answer the <ExternalField> class to represent pointers to this external type with the
	one indirection."

	^PointerField!

PutField: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutField() method for the UDT described by the receiver.

		HRESULT __stdcall PutField(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	| refInst value |
	refInst := self fromAddress: pvData.
	wFlags = AXAutomationConstants.INVOKE_PROPERTYPUT
		ifTrue: 
			[| fieldValue |
			fieldValue := [refInst getField: szFieldName] on: MessageNotUnderstood
						do: [:x | ^Win32Errors.E_INVALIDARG].
			value := pvarField isDispatch ifTrue: [pvarField dispatch value] ifFalse: [pvarField value].
			(fieldValue isKindOf: IDispatch)
				ifTrue: 
					[fieldValue isNull ifTrue: [^Win32Errors.E_POINTER].
					fieldValue value: value]
				ifFalse: [refInst setField: szFieldName value: value]]
		ifFalse: 
			[wFlags = AXAutomationConstants.INVOKE_PROPERTYPUTREF
				ifTrue: [value := pvarField value]
				ifFalse: [^Win32Errors.E_INVALIDARG]].
	^
	[refInst setField: szFieldName value: value.
	0	"S_OK"] on: MessageNotUnderstood
			do: [:x | Win32Errors.E_INVALIDARG]!

PutFieldNoCopy: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall PutFieldNoCopy(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	^Win32Errors.E_NOTIMPL
!

queryInterface: anInterfaceClass
	"Answer a new interface which supports the specified interface protocol
	(usually a class), or nil if the receiver does not support the interface."

	^self queryInterface: anInterfaceClass ifNone: []
!

queryInterface: anInterfaceClass ifNone: exceptionHandler
	"Answer a new interface pointer which supports the specified interface protocol
	(usually a class). If the receiver does not support the interface, answer the
	result of evaluating the niladic valuable, exceptionHandler."

	| class |
	class := self supportedInterfaces 
		detect: [:ic | ic supportsInterface: anInterfaceClass] 
		ifNone: [^exceptionHandler value].
	^class on: self implementor: self
!

RecordClear: pvExisting
	"Implement the IRecordInfo::RecordClear() method for the UDT described by the receiver.
	Clearing down a record involves freeing any of the fields that need to be finalized, it does
	not include releasing the memory owned by the record.

		HRESULT __stdcall RecordClear(
			[in] void* pvExisting);
	"

	self clear: pvExisting.
	^0 "S_OK"
!

RecordCopy: pvExisting pvNew: pvNew
	"Implement IRecordInfo::RecordCopy() method for the UDT described by the receiver.
	Copy an existing area of memory occuppied by a record of the receiver's type to a new
	location. Relies on a correct implementation of #copy which copies any pointed at
	structures which should not be shared.

		HRESULT __stdcall RecordCopy(
			[in] void* pvExisting,
			[out] void* pvNew);
	"

	| ref |
	ref := self fromAddress: pvExisting.
	pvNew 
		replaceFrom: 1
		to: ref byteSize
		with: ref copy detach
		startingAt: 1.
	^0 "S_OK"!

RecordCreate 
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver
	Create a new record of the receiver's type in COM task memory.

		void* __stdcall RecordCreate();
	"

	^(COMTaskMemory new: self byteSize) detach
!

RecordCreateCopy: pvSource ppvDest: ppvDest
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver

		HRESULT __stdcall RecordCreateCopy(
			[in] void* pvSource,
			[out] void** ppvDest);
	"

	| pv |
	pv := self RecordCreate.
	ppvDest value: pv.
	pv isNull ifTrue: [^Win32Errors.E_OUTOFMEMORY].
	^self RecordCopy: pvSource pvNew: pv!

RecordDestroy: pvRecord
	"Implement the RecordDestroy() method for the UDT described by the receiver.
	Free up a record of the receiver's type previously created with RecordCreate().

		HRESULT __stdcall RecordDestroy(
			[in] void* pvRecord);
	"

	self RecordClear: pvRecord.
	COMTaskMemory free: pvRecord.
	^0 "S_OK"!

recordInfo
	"Answer an <IRecordInfo> describing the receiver's structure class.
	Note that we attempt to use the system provided implementation, but as this is frequently 
	unavailable (even for the DX-7 libraries which require extensive use of IRecordInfo)
	we must also be able to implement it ourselves."

	| ti ri |
	ti := self typeInfoIfNone: [].
	ri := ti notNil ifTrue: [ti recordInfoIfNone: []].
	^ri ifNil: [IRecordInfo on: self]!

RecordInit: pvNew
	"Implement the IRecordInfo::RecordInit() method for the UDT described by the receiver.
	Initialize a new empty buffer for a record of the receiver's type. This implementation is the
	simplest possible - it just zeros the whole area.

		HRESULT __stdcall RecordInit(
			[out] void* pvNew);
	"

	self init: pvNew.
	^0 "S_OK"
!

registerSubclasses
	"(Re)Register the receiver's subclasses as record classes with
	their appropriate GUIDs. This is intended as a helper function when
	developing, and has no run-time significance.

		self registerSubclasses
	"

	self initializeRegister.
	self allSubclassesDo: [:c | c register]!

supportedInterfaces
	"Private - Answer the set of interface classes supported by the receiver.
	Implementation Note: We aren't expecting that the implementation of IRecordInfo we provide will actually
	be used for getting and setting the values of fields in UDTs, but mainly provide it to make up for the 
	fact that the one type library we've so far experienced which makes heavy use of UDTs (i.e. the DX-7 VB
	library) does not contain sufficient information (mainly GUIDs) to allow the system implementation of
	IRecordInfo to be constructed on the ITypeInfo's of the various structures defined therein. This suggests
	that VB doesn't use the system implementation itself, as otherwise the type library would be useless. Also
	it seems that DX-7 actually ignores the IRecordInfo (perhaps not surprisingly for a C library), so it is only 
	really needed in order to create VT_RECORD SAFEARRAYs and VARIANTs."

	^#(##(IRecordInfo))!

typeInfo
	"Answer an <ITypeInfo> on the receiver's type information."

	^self typeInfoIfNone: [self error: 'No type information available']!

typeInfoIfNone: exceptionHandler
	"Answer an <ITypeInfo> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| assoc |
	^(assoc := self libraryAndIndex) isNil
		ifTrue: [exceptionHandler value]
		ifFalse: [assoc key typeInfoAt: assoc value]!

typeLib
	"Answer an <ITypeLib> on the receiver's type library,
	or <nil> if the receiver does not have a type library."

	| libAndIndex |
	libAndIndex := self libraryAndIndex.
	^libAndIndex isNil ifFalse: [libAndIndex key]!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	Generally speaking this is the class name."

	^self name!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_RECORD! !

!ExternalStructure class categoriesForMethods!
classForGUID:ifNone:!enquiries!private! !
clearGuid!accessing!private! !
finalRelease!public!realizing/unrealizing! !
fromAddress:recordInfo:owner:!instance creation!public! !
fromObject:!instance creation!public! !
GetField:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
GetFieldNames:rgBstrNames:!COM Interfaces-IRecordInfo!public! !
GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:!COM Interfaces-IRecordInfo!public! !
GetGuid:!COM Interfaces-IRecordInfo!public! !
GetName:!COM Interfaces-IRecordInfo!public! !
GetSize:!COM Interfaces-IRecordInfo!public! !
GetTypeInfo:!COM Interfaces-IRecordInfo!public! !
initializeRegister!initializing!private! !
IsMatchingType:!COM Interfaces-IRecordInfo!public! !
newSAFEARRAY:!double dispatch!public! !
pointerFieldType!constants!private! !
PutField:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
PutFieldNoCopy:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
queryInterface:!accessing-interfaces!public! !
queryInterface:ifNone:!accessing!accessing-interfaces!public! !
RecordClear:!COM Interfaces-IRecordInfo!public! !
RecordCopy:pvNew:!COM Interfaces-IRecordInfo!public! !
RecordCreate!COM Interfaces-IRecordInfo!public! !
RecordCreateCopy:ppvDest:!COM Interfaces-IRecordInfo!public! !
RecordDestroy:!COM Interfaces-IRecordInfo!public! !
recordInfo!accessing!public! !
RecordInit:!COM Interfaces-IRecordInfo!public! !
registerSubclasses!initializing!public! !
supportedInterfaces!constants!private! !
typeInfo!accessing!public! !
typeInfoIfNone:!accessing!public! !
typeLib!accessing!public! !
typeName!constants!private! !
vt!constants!public! !
!

!FILETIME class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_FILETIME! !

!FILETIME class categoriesForMethods!
vt!constants!public! !
!

!Float methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8)."

	^VARIANT fromFloat: self! !

!Float categoriesForMethods!
asVariant!converting!public! !
!

!FLOAT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#float!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_R4! !

!FLOAT class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!Fraction methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8).
	Note that precision may be lost."

	^self asFloat asVariant! !

!Fraction categoriesForMethods!
asVariant!converting!public! !
!

!GUID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !

!GUID class categoriesForMethods!
typeName!constants!private! !
!

!HRESULT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#hresult!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^AXAutomationConstants.VT_ERROR! !

!HRESULT class categoriesForMethods!
typeName!constants!private! !
vt!constants!private! !
!

!IErrorInfo class methodsFor!

fromEXCEPINFO: excepInfo guid: id
	"Answer a new instance of the receiver on a system extended error object
	with details from the <EXCEPINFO> structure, excepInfo."

	^(ICreateErrorInfo fromEXCEPINFO: excepInfo guid: id) errorInfo!

source: sourceString description: descriptionString helpContext: anInteger helpFile: helpFilePath guid: aGUID
	"Answer a new instance of the receiver encapsulating all of the specified details.
		ice := self source: 'Dolphin' description: 'It is all going horribly wrong' helpContext: 1 helpFile: nil guid: GUID newUnique.
	"

	| ice |
	ice := ICreateErrorInfo new.
	ice SetSource: sourceString.
	ice SetDescription: descriptionString.
	ice SetHelpContext: anInteger.
	ice SetHelpFile: helpFilePath.
	ice SetGuid: aGUID.
	^ice errorInfo

! !

!IErrorInfo class categoriesForMethods!
fromEXCEPINFO:guid:!instance creation!public! !
source:description:helpContext:helpFile:guid:!instance creation!public! !
!

!INT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#intptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [AXAutomationConstants.VT_I8] ifFalse: [AXAutomationConstants.VT_I4]! !

!INT_PTR class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!Integer methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4, VT_I8, or VT_UI8)."

	^self subclassResponsibility! !

!Integer categoriesForMethods!
asVariant!converting!public! !
!

!IUnknown methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver."

	^VARIANT fromUnknown: self! !

!IUnknown categoriesForMethods!
asVariant!converting!public! !
!

!IUnknown class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UNKNOWN! !

!IUnknown class categoriesForMethods!
vt!constants!public! !
!

!LARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sqword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I8! !

!LARGE_INTEGER class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!LargeInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I8).
	It is an error if the receiver is too large to be represented in 64-bits."

	^VARIANT fromLargeInteger: self! !

!LargeInteger categoriesForMethods!
asVariant!converting!public! !
!

!LPVOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	#todo "Is this right?".
	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	#todo "Is this right?".
	^AXAutomationConstants.VT_VOID! !

!LPVOID class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!OLEAutLibrary methodsFor!

clearCustData: pCustData
	"WINOLEAUTAPI_(void) ClearCustData(LPCUSTDATA pCustData);"

	<stdcall: void ClearCustData CUSTDATA*>
	^self invalidCall: _failureCode!

createErrorInfo: pperrinfo
	"Loads _and registers_ a type library from the specified path.

		HRESULT CreateErrorInfo(
			ICrateErrorInfo**		pperrinfo
		)"

	<stdcall: hresult CreateErrorInfo lppvoid>
	^self invalidCall: _failureCode!

getRecordInfoFromTypeInfo: pTypeInfo ppRecInfo: ppRecInfo
	"Create a RecordInfo object on the specified ITypeInfo, and answer an <IRecordInfo> on it.
		HRESULT GetRecordInfoFromTypeInfo( 
			ITypeInfo  pTypeInfo,  
			IRecordInfo** ppRecInfo);"

	"Implementation Note: Answer an integer HRESULT code rather than raising an exception
	as it is most unusual for this call to succeed it would seem!!"

	<stdcall: sdword GetRecordInfoFromTypeInfo ITypeInfo* IRecordInfo**>
	^self invalidCall: _failureCode!

lHashValOfNameSys: syskind lcid: lcid szName: szNem
	"Calculate the hash value of a string.

		ULONG LHashValOfNameSys(
		SYSKIND syskind <>, 
		LCID lcid <>, 
		const OLECHAR FAR* szName <> ); 
		)"

	<stdcall: dword LHashValOfNameSys sdword sdword lpwstr>
	^self invalidCall: _failureCode!

loadRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid pptlib: pptlib
	"Load a type library from the registry entries corresponding to the specified LIBID,
	version information, and LCID.

		HRESULT LoadRegTypeLib(      REFGUID rguid, 
			unsigned short wVerMajor, 
			unsigned short wVerMinor, 
			LCID lcid, 
			ITypeLib FAR* FAR* pptlib 
		); "

	<stdcall: hresult LoadRegTypeLib guid* word word dword lppvoid>
	^self invalidCall: _failureCode!

loadTypeLib: szFileName pptlib: lplptlib
	<stdcall: hresult LoadTypeLib lpwstr lppvoid>
	^self invalidCall: _failureCode!

loadTypeLibEx: szFileName regkind: regkind pptlib: lplptlib
	"Loads, and optionally registers, a type library from the specified path.

		HRESULT LoadTypeLibEx(
			OLECHAR FAR*		szFileName,
			REGKIND				regkind,
			ITypeLib FAR* FAR*	pptlib
		)"

	<stdcall: hresult LoadTypeLibEx lpwstr sdword lppvoid>
	^self invalidCall: _failureCode!

oleCreateFontIndirect: pFontDesc riid: riid ppvObj: ppvObj
	"Create an OLE font object matching the supplied <FONTDESC>. 

		STDAPI OleCreateFontIndirect(
			FONTDESC* pFontDesc,
			REFIID riid,
			VOID** ppvObj);
 	"

	<stdcall: hresult OleCreateFontIndirect FONTDESC* guid* void**>
	^self invalidCall: _failureCode!

queryPathOfRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid lpbstrPathName: lpbstrPathName
	"Determine the path of a registered type library.
	Implementation Note: It is quite a common occurrence that the library not be registered
	on a particular machine, and using this function is the best way to find that out, therefore
	we define the return code as an integer rather than an HRESULT to avoid getting an
	exception.

	HRESULT QueryPathOfRegTypeLib(
		REFGUID guid,
		unsigned short wVerMajor,
		unsigned short wVerMinor,
		LCID lcid,
		LPBSTR lpbstrPathName);"

	<stdcall: sdword QueryPathOfRegTypeLib guid* word word dword bstr*>
	^self invalidCall: _failureCode!

registerTypeLib: ptlib wszFullPath: wszFullPath wszHelpDir: wszHelpDir
	"Invoke the RegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Adds information about a type library to the system registry

		HRESULT __stdcall RegisterTypeLib(
			ITypeLib* ptlib,
			LPWSTR wszFullPath,
			LPWSTR wszHelpDir);"

	<stdcall: sdword RegisterTypeLib ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

registerTypeLibForUser: ptlib szFullPath: szFullPath szHelpDir: szHelpDir
	"Invoke the RegisterTypeLibForUser() function of the module wrapped by the receiver.
	Helpstring: Registers a type library for use by the calling user.

		HRESULT __stdcall RegisterTypeLibForUser(
			ITypeLib* ptlib,
			LPWSTR szFullPath,
			LPWSTR szHelpDir);"

	<stdcall: hresult RegisterTypeLibForUser ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

safeArrayAccessData: psa ppvData: ppvData
	"Increment the lock count of an array, and return a pointer to the array data
	through the <ExternalAddress>, ppvData.

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayAccessData SAFEARRAY* lppvoid>
	^self invalidCall: _failureCode!

safeArrayCopy: psa ppsaout: ppsaout
	"Create a copy of a SAFEARRAY.

		HRESULT SafeArrayCopy( 
			SAFEARRAY *  psa,          
			SAFEARRAY **  ppsaOut  
		);"

	<stdcall: hresult SafeArrayCopy SAFEARRAY* SAFEARRAY**>
	^self invalidCall: _failureCode!

safeArrayCreateEx: vt cDims: cDims rgsabound: rgsabound pvExtra: anExternalAddressOfNil
	<stdcall: SAFEARRAY* SafeArrayCreateEx word sdword SAFEARRAYBOUND* lpvoid>
	^self invalidCall: _failureCode!

safeArrayCreateVectorEx: vt lLbound: lLbound cElements: cElements pvExtra: pvExtra
	"Create a one-dimensional SAFEARRAY.

		SAFEARRAY SafeArrayCreateVectorEx( 
			VARTYPE  vt,             
			long  lLbound,           
			unsigned int  cElements ,
			LPVOID pvExtra
		);"

	<stdcall: SAFEARRAY* SafeArrayCreateVectorEx sword sdword dword lpvoid>
	^self invalidCall: _failureCode!

safeArrayDestroy: psa
	"Tidy away a SAFEARRAY. May involve releasing objects, etc.

		HRESULT SafeArrayDestroy(SAFEARRAY FAR*  psa);
	"

	<stdcall: sdword SafeArrayDestroy SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetDim: psa
	"Answer the number of dimensions in a SAFEARRAY.

		UINT SafeArrayGetDim(SAFEARRAY FAR*  psa);
	"

	<stdcall: dword SafeArrayGetDim SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetElement: psa rgIndices: rgIndices pv: pv
	"Answer an individual element of the receiver as identified by the array
	of indices, rgIndices, through the buffer, pv.

		HRESULT SafeArrayGetElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayGetElement SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayGetIID: psa pguid: pguid
	"Get the IID of the FADF_HAVEIID safe array, psa, storing it 
	into the output parameter, pvt.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			GUID* pguid
		);"

	<stdcall: hresult SafeArrayGetIID SAFEARRAY* guid*>
	^self invalidCall: _failureCode!

safeArrayGetLBound: psa nDim: nDim plLbound: plLbound
	"Answer the lower bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plLbound..

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayGetLBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetRecordInfo: aSAFEARRAY prinfo: anIRecordInfo
	<stdcall: hresult SafeArrayGetRecordInfo SAFEARRAY* IRecordInfo**>
	^self invalidCall: _failureCode!

safeArrayGetUBound: psa nDim: nDim plUbound: plUbound
	"Answer the upper bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plUbound..

		HRESULT SafeArrayGetUBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plUbound
		);"

	<stdcall: hresult SafeArrayGetUBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetVartype: psa pvt: pvt
	"Get the VARTYPE of the safe array, psa, storing it into the output parameter, pvt.

		HRESULT SafeArrayGetVartype(
			SAFEARRAY FAR* psa,
			VARTYPE* vt
		);"

	<stdcall: hresult SafeArrayGetVartype SAFEARRAY* word*>
	^self invalidCall: _failureCode!

safeArrayPtrOfIndex: aSAFEARRAY rgIndices: aSDWORDArray ppvData: anExternalAddress
	<stdcall: hresult SafeArrayPtrOfIndex SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayPutElement: psa rgIndices: rgIndices pv: pv
	"Replease the individual element of the receiver as identified by the array
	of indices, rgIndices, with the contents of the buffer pointed at by the
	<externalAddress>, pv.

		HRESULT SafeArrayPutElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayPutElement SAFEARRAY* sdword* lpvoid>
	^self invalidCall: _failureCode!

safeArrayRedim: psa psaboundNew: psaboundNew
	"Resize the least significant bound of the SAFEARRAY, psa,
	to the lower bound and element count specified in the 
	SAFEARRAYBOUND, psaboundNew.

		HRESULT SafeArrayRedim(
			SAFEARRAY FAR* psa,
			SAFEARRAYBOUND psaboundNew
		);"

	<stdcall: hresult SafeArrayRedim SAFEARRAY* SAFEARRAYBOUND*>
	^self invalidCall: _failureCode!

safeArraySetIID: psa pguid: pguid
	"Set the IID of the FADF_HAVEIID safe array, psa.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			REFGUID pguid
		);"

	<stdcall: hresult SafeArraySetIID SAFEARRAY* REFGUID>
	^self invalidCall: _failureCode!

safeArrayUnaccessData: psa
	"Reverse a previous SafeArrayAccessData.

		HRESULT SafeArrayUnaccessData(SAFEARRAY FAR*  psa);
	"

	<stdcall: hresult SafeArrayUnaccessData SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayUnlock: psa
	<stdcall: hresult SafeArrayUnlock SAFEARRAY*>
	^self invalidCall: _failureCode!

setErrorInfo: dwReserved perrinfo: perrinfo
	"Set the current <IErrorInfo> pointer for the calling thread.

		HRESULT SetErrorInfo(
			DWORD			dwReserved,
			IErrorInfo*		perrinfo
		)"

	<stdcall: hresult GetErrorInfo dword IErrorInfo*>
	^self invalidCall: _failureCode!

systemTimeToVariantTime: lpSystemTime pvtime: pvtime
	"Convert the <SYSTEMTIME>, lpSystemTime, to an OLE format <DATE>,
	answering whether the conversion succeeded.

		INT SystemTimeToVariantTime(
			SYSTEMTIME  lpSystemTime  
			double  *pvtime           
		);"

	<stdcall: bool SystemTimeToVariantTime SYSTEMTIME* double*>
	^self invalidCall: _failureCode!

unRegisterTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid syskind: syskind
	"Invoke the UnRegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Removes type library information from the system registry.

		HRESULT __stdcall UnRegisterTypeLib(
			GUID* rguid,
			unsigned short wVerMajor,
			unsigned short wVerMinor,
			unsigned long lcid,
			SYSKIND syskind);"

	<stdcall: hresult UnRegisterTypeLib guid* word word dword sdword>
	^self invalidCall: _failureCode!

varCmp: pvarLeft pvarRight: pvarRight lcid: lcid dwFlags: dwFlags
	"Answer a comparison result between the two VARIANT arguments.

		HRESULT VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);
	"

	<stdcall: hresult VarCmp variant* variant* dword dword>
	^self invalidCall: _failureCode!

varDateFromStr: strIn lcid: lcid dwFlags: dwFlags pdateOut: aFloat
	"Convert from a string date representation to the OLE Automation date type,
	according to the users regional settings.

		HRESULT VarDateFromStr(OLECHAR* strIn, LCID lcid, DWORD dwFlags, DATE* pdateOut);"

	<stdcall: hresult VarDateFromStr lpwstr dword dword lpvoid>
	^self invalidCall: _failureCode!

variantChangeType: pvargDest pvarSrc: pvarSrc wFlags: wFlags vt: vt
	"Convert a variant from one type to another. 

		HRESULT VariantChangeType(
			VARIANTARG FAR* pvargDest, 
			VARIANTARG FAR* pvarSrc, 
			unsigned short wFlags, 
			VARTYPE vt 
		);"

	<stdcall: hresult VariantChangeType variant* variant* word sword>
	^self invalidCall: _failureCode!

variantClear: pvarg
	"Free a VARIANT, performing any special clean up  required (such as 
	Release()ing an IUnknown/IDispatch).
	Implementation Note: As this is used to finalize VARIANTs and there
	is little we can do about a failure, we return an integer error code
	rather than automatically raising an exception.

		HRESULT VariantClear(VARIANTARG FAR* pvarg)"

	<stdcall: sdword VariantClear variant*>
	^self invalidCall: _failureCode!

variantCopy: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest.

		HRESULT VariantCopy(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopy variant* variant*>
	^self invalidCall: _failureCode!

variantCopyInd: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest,
	where the copy is guaranteed not to be a VT_BYREF.

		HRESULT VariantCopyInd(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopyInd variant* variant*>
	^self invalidCall: _failureCode!

variantInit: pvarg
	"Initialize a VARIANT - sets the type tag to VT_EMPTY, but does not zero the
	data part of the union.

		void VariantInit(VARIANTARG FAR* pvarg)"

	<stdcall: void VariantInit variant*>
	^self invalidCall: _failureCode!

variantTimeToSystemTime: vtime lpSystemTime: lpSystemTime
	"Convert the OLE format date-time, vtime, to a SYSTEMTIME,
	answering whether the conversion succeeded.

		INT VariantTimeToSystemTime( 
			double  vtime,              
			LPSYSTEMTIME  lpSystemTime  
		);"

	<stdcall: bool VariantTimeToSystemTime double SYSTEMTIME*>
	^self invalidCall: _failureCode! !

!OLEAutLibrary categoriesForMethods!
clearCustData:!Automation Functions-Error Handling API!public! !
createErrorInfo:!Automation Functions-Error Handling API!public! !
getRecordInfoFromTypeInfo:ppRecInfo:!OLE Functions-OLE!public! !
lHashValOfNameSys:lcid:szName:!Automation Functions-Type Compilation And Library!primitives!public! !
loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:!Automation Functions-Type Compilation And Library!public! !
loadTypeLib:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
loadTypeLibEx:regkind:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
oleCreateFontIndirect:riid:ppvObj:!OLE Functions-OLE!public! !
queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:!Automation Functions-Type Compilation And Library!public! !
registerTypeLib:wszFullPath:wszHelpDir:!Automation Functions-Type Compilation And Library!public! !
registerTypeLibForUser:szFullPath:szHelpDir:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
safeArrayAccessData:ppvData:!Automation Functions-Array Manipulation!public! !
safeArrayCopy:ppsaout:!Automation Functions-Array Manipulation!public! !
safeArrayCreateEx:cDims:rgsabound:pvExtra:!Automation Functions-Array Manipulation!public! !
safeArrayCreateVectorEx:lLbound:cElements:pvExtra:!Automation Functions-Array Manipulation!public! !
safeArrayDestroy:!Automation Functions-Array Manipulation!public! !
safeArrayGetDim:!Automation Functions-Array Manipulation!public! !
safeArrayGetElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
safeArrayGetIID:pguid:!Automation Functions-Array Manipulation!public! !
safeArrayGetLBound:nDim:plLbound:!Automation Functions-Array Manipulation!public! !
safeArrayGetRecordInfo:prinfo:!Automation Functions-Array Manipulation!public! !
safeArrayGetUBound:nDim:plUbound:!Automation Functions-Array Manipulation!public! !
safeArrayGetVartype:pvt:!Automation Functions-Array Manipulation!public! !
safeArrayPtrOfIndex:rgIndices:ppvData:!Automation Functions-Array Manipulation!public! !
safeArrayPutElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
safeArrayRedim:psaboundNew:!Automation Functions-Array Manipulation!public! !
safeArraySetIID:pguid:!Automation Functions-Array Manipulation!public! !
safeArrayUnaccessData:!Automation Functions-Array Manipulation!public! !
safeArrayUnlock:!Automation Functions-Array Manipulation!public! !
setErrorInfo:perrinfo:!Automation Functions-Error Handling API!public! !
systemTimeToVariantTime:pvtime:!Automation Functions-Variant Manipulation!public! !
unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
varCmp:pvarRight:lcid:dwFlags:!Automation Functions-Variant Manipulation!public! !
varDateFromStr:lcid:dwFlags:pdateOut:!Automation Functions-Variant Manipulation!public! !
variantChangeType:pvarSrc:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
variantClear:!Automation Functions-Variant Manipulation!public! !
variantCopy:pvargSrc:!Automation Functions-Variant Manipulation!public! !
variantCopyInd:pvargSrc:!Automation Functions-Variant Manipulation!public! !
variantInit:!Automation Functions-Variant Manipulation!public! !
variantTimeToSystemTime:lpSystemTime:!Automation Functions-Variant Manipulation!public! !
!

!QWORD class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI8! !

!QWORD class categoriesForMethods!
vt!constants!public! !
!

!SBYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sbyte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I1! !

!SBYTE class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!ScaledDecimal methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Both VT_CY (currency) and VT_DECIMAL types convert to ScaledDecimals
	but the latter has a wider (64-bit unsigned) range and a variable scale, so it
	is more likely to suit."

	^VARIANT new 
		decimal: self;
		yourself! !

!ScaledDecimal categoriesForMethods!
asVariant!converting!public! !
!

!SDWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sdword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I4! !

!SDWORD class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!SmallInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4 or VT_I8, depending on the
	bitness of the host machine)."

	^VARIANT fromSmallInteger: self! !

!SmallInteger categoriesForMethods!
asVariant!converting!public! !
!

!String methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !

!String categoriesForMethods!
asVariant!converting!public! !
!

!String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^LPSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_LPSTR! !

!String class categoriesForMethods!
pointerType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!SWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_I2! !

!SWORD class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!SYSTEMTIME methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	| vtime |
	vtime := DATE new.
	OLEAutLibrary default systemTimeToVariantTime: self pvtime: vtime.
	^vtime!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)"

	^VARIANT fromDATE: self asFloat! !

!SYSTEMTIME categoriesForMethods!
asFloat!converting!public! !
asVariant!converting!public! !
!

!SYSTEMTIME class methodsFor!

fromDATE: aFloat 
	| systime |
	systime := self new.
	OLEAutLibrary default variantTimeToSystemTime: aFloat lpSystemTime: systime.
	^systime! !

!SYSTEMTIME class categoriesForMethods!
fromDATE:!public! !
!

!UINT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uintptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [AXAutomationConstants.VT_UI8] ifFalse: [AXAutomationConstants.VT_UI4]! !

!UINT_PTR class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!ULARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#qword! !

!ULARGE_INTEGER class categoriesForMethods!
typeName!constants!private! !
!

!UndefinedObject methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_EMPTY).
	Implementation Note: VT_EMPTY is chosen for compatibility with VB which
	uses VT_EMPTY for null object references, even though VT_NULL might
	appear more appropriate at first glance."

	^VARIANT new! !

!UndefinedObject categoriesForMethods!
asVariant!converting!public! !
!

!UndefinedObject class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver."

	^#nil!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_EMPTY! !

!UndefinedObject class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!Utf16String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^LPWSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpwstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_LPWSTR! !

!Utf16String class categoriesForMethods!
pointerType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!VOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_VOID! !

!VOID class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!WORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#word!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AXAutomationConstants.VT_UI2! !

!WORD class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

"End of package definition"!

