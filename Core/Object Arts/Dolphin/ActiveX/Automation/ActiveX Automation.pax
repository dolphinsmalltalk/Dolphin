| package |
package := Package name: 'ActiveX Automation'.
package paxVersion: 2.1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk ActiveX Automation Support.
Copyright (c) Object Arts Ltd, 2000-2003.

This package is the basis of Dolphin''s extensive Active-X Automation support (formally called OLE Automation). It includes classes to enable the use of Dolphin as both an Automation client (or controller) and server. In here you will find classes to support the familar Automation types such as VARIANTs, BSTRs and SAFEARRAYs. This package also includes extensive support for extracting information from type libraries, with this being further augmented by the ''ActiveX Automation Development'' package, which uses the type-library analyzer to generate wrapper classes for COM objects, etc.

'.

package basicPackageVersion: '6.1'.

package basicScriptAt: #postinstall put: 'VM
	registryAt: #VARIANT put: COM.VARIANT;
	registryAt: #IDispatch put: COM.IDispatch.

"Register all the existing ExternalStructures so that they can support IRecordInfo"
External.Structure registerSubclasses.'.
package basicScriptAt: #postuninstall put: 'External.Structure classPool at: ''RecordClasses'' put: nil.'.

package setClassNames: #(
	#{OS.COM.AbstractDispatchImplementation}
	#{OS.COM.AbstractELEMDESC}
	#{OS.COM.APIInfoAnalyzer}
	#{OS.COM.ARRAYDESC}
	#{OS.COM.AutomationConstants}
	#{OS.COM.AutomationErrors}
	#{OS.COM.BSTRArray}
	#{OS.COM.CURRENCY}
	#{OS.COM.CUSTDATA}
	#{OS.COM.CUSTDATAITEM}
	#{OS.COM.DATE}
	#{OS.COM.DECIMAL}
	#{OS.COM.DispatchFunction}
	#{OS.COM.DISPPARAMS}
	#{OS.COM.DualInterfaceImplementation}
	#{OS.COM.ELEMDESC}
	#{OS.COM.FONTDESC}
	#{OS.COM.ForwardingDualInterfaceImplementation}
	#{OS.COM.FUNCDESC}
	#{OS.COM.ICreateErrorInfo}
	#{OS.COM.IDispatch}
	#{OS.COM.IDLDESC}
	#{OS.COM.IEnumVARIANT}
	#{OS.COM.InterfaceTypeAnalyzer}
	#{OS.COM.IPerPropertyBrowsing}
	#{OS.COM.IProvideClassInfo}
	#{OS.COM.IProvideClassInfo2}
	#{OS.COM.IRecordInfo}
	#{OS.COM.ITypeComp}
	#{OS.COM.ITypeInfo}
	#{OS.COM.ITypeInfo2}
	#{OS.COM.ITypeLib}
	#{OS.COM.ITypeLib2}
	#{OS.COM.LPBSTR}
	#{OS.COM.MemberDesc}
	#{OS.COM.PARAMDESC}
	#{OS.COM.PARAMDESCEX}
	#{OS.COM.Record}
	#{OS.COM.SAFEARRAY}
	#{OS.COM.SAFEARRAYBOUND}
	#{OS.COM.StructureTypeAnalyzer}
	#{OS.COM.TKindAliasAnalyzer}
	#{OS.COM.TKindCoclassAnalyzer}
	#{OS.COM.TKindDispatchAnalyzer}
	#{OS.COM.TKindEnumAnalyzer}
	#{OS.COM.TKindInterfaceAnalyzer}
	#{OS.COM.TKindModuleAnalyzer}
	#{OS.COM.TKindRecordAnalyzer}
	#{OS.COM.TKindUnionAnalyzer}
	#{OS.COM.TLIBATTR}
	#{OS.COM.TYPEATTR}
	#{OS.COM.TYPEDESC}
	#{OS.COM.TypeGenerationFlags}
	#{OS.COM.TypeInfoAnalyzer}
	#{OS.COM.TypeInfoObject}
	#{OS.COM.TypeInfoStructure}
	#{OS.COM.TypeLibDocumentation}
	#{OS.COM.TypeLibraryAnalyzer}
	#{OS.COM.VARDESC}
	#{OS.COM.VARIANT}
	#{OS.COM.VARIANT_BOOL}
	#{OS.COM.VariantEnumerator}
).

package setMethodNames: #(
	#(#{Core.Boolean} #asVariant)
	#(#{Core.ByteArray} #asSAFEARRAY)
	#(#{Core.ByteArray class} #typeName)
	#(#{Core.Character} #asVariant)
	#(#{Core.Collection} #asSAFEARRAY)
	#(#{Core.Collection} #asVariant)
	#(#{Core.DateAndTime} #asFloat)
	#(#{Core.DateAndTime} #asVariant)
	#(#{Core.Float} #asVariant)
	#(#{Core.Fraction} #asVariant)
	#(#{Core.GUID class} #arrayType:)
	#(#{Core.GUID class} #typeName)
	#(#{Core.LargeInteger} #asVariant)
	#(#{Core.Locale} #displayCURRENCY:on:)
	#(#{Core.Locale} #displayDECIMAL:on:)
	#(#{Core.Locale} #variantBool:)
	#(#{Core.Number} #asVariant)
	#(#{Core.ScaledDecimal} #asVariant)
	#(#{Core.SmallInteger} #asVariant)
	#(#{Core.String} #asVariant)
	#(#{Core.String class} #arrayType)
	#(#{Core.String class} #arrayType:)
	#(#{Core.String class} #pointerType)
	#(#{Core.String class} #typeName)
	#(#{Core.String class} #vt)
	#(#{Core.UndefinedObject} #asVariant)
	#(#{Core.UndefinedObject class} #typeName)
	#(#{Core.UndefinedObject class} #vt)
	#(#{Core.Utf16String class} #pointerType)
	#(#{Core.Utf16String class} #typeName)
	#(#{Core.Utf16String class} #vt)
	#(#{External.Address class} #typeName)
	#(#{External.Address class} #vt)
	#(#{External.BOOL class} #typeName)
	#(#{External.BOOLEAN class} #typeName)
	#(#{External.DOUBLE class} #arrayType)
	#(#{External.DOUBLE class} #typeName)
	#(#{External.DOUBLE class} #vt)
	#(#{External.ExternalArray} #asSAFEARRAY)
	#(#{External.ExternalArray} #asVariant)
	#(#{External.ExternalArray class} #arrayType)
	#(#{External.ExternalArray class} #vt)
	#(#{External.FLOAT class} #arrayType)
	#(#{External.FLOAT class} #typeName)
	#(#{External.FLOAT class} #vt)
	#(#{External.Handle class} #arrayType:)
	#(#{External.Handle class} #typeName)
	#(#{External.Int16 class} #arrayType)
	#(#{External.Int16 class} #typeName)
	#(#{External.Int16 class} #vt)
	#(#{External.Int32 class} #arrayType)
	#(#{External.Int32 class} #typeName)
	#(#{External.Int32 class} #vt)
	#(#{External.Int64 class} #typeName)
	#(#{External.Int64 class} #vt)
	#(#{External.Int8 class} #arrayType)
	#(#{External.Int8 class} #typeName)
	#(#{External.Int8 class} #vt)
	#(#{External.INTEGER class} #typeName)
	#(#{External.INTEGER class} #vt)
	#(#{External.IntPtr class} #arrayType)
	#(#{External.IntPtr class} #typeName)
	#(#{External.IntPtr class} #vt)
	#(#{External.LPVOID class} #typeName)
	#(#{External.LPVOID class} #vt)
	#(#{External.SCALAR} #asVariant)
	#(#{External.Structure} #asVariant)
	#(#{External.Structure} #recordInfo)
	#(#{External.Structure} #vt)
	#(#{External.Structure class} #arrayType)
	#(#{External.Structure class} #arrayType:)
	#(#{External.Structure class} #classForGUID:ifNone:)
	#(#{External.Structure class} #clearGuid)
	#(#{External.Structure class} #finalRelease)
	#(#{External.Structure class} #fromAddress:recordInfo:owner:)
	#(#{External.Structure class} #fromObject:)
	#(#{External.Structure class} #GetField:szFieldName:pvarField:)
	#(#{External.Structure class} #GetFieldNames:rgBstrNames:)
	#(#{External.Structure class} #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:)
	#(#{External.Structure class} #GetGuid:)
	#(#{External.Structure class} #GetName:)
	#(#{External.Structure class} #GetSize:)
	#(#{External.Structure class} #GetTypeInfo:)
	#(#{External.Structure class} #initializeRegister)
	#(#{External.Structure class} #IsMatchingType:)
	#(#{External.Structure class} #newSAFEARRAY:)
	#(#{External.Structure class} #pointerFieldType)
	#(#{External.Structure class} #PutField:pvData:szFieldName:pvarField:)
	#(#{External.Structure class} #PutFieldNoCopy:pvData:szFieldName:pvarField:)
	#(#{External.Structure class} #queryInterface:)
	#(#{External.Structure class} #queryInterface:ifNone:)
	#(#{External.Structure class} #RecordClear:)
	#(#{External.Structure class} #RecordCopy:pvNew:)
	#(#{External.Structure class} #RecordCreate)
	#(#{External.Structure class} #RecordCreateCopy:ppvDest:)
	#(#{External.Structure class} #RecordDestroy:)
	#(#{External.Structure class} #recordInfo)
	#(#{External.Structure class} #RecordInit:)
	#(#{External.Structure class} #registerSubclasses)
	#(#{External.Structure class} #supportedInterfaces)
	#(#{External.Structure class} #typeInfo)
	#(#{External.Structure class} #typeInfoIfNone:)
	#(#{External.Structure class} #typeLib)
	#(#{External.Structure class} #typeName)
	#(#{External.Structure class} #vt)
	#(#{External.UInt16 class} #arrayType)
	#(#{External.UInt16 class} #typeName)
	#(#{External.UInt16 class} #vt)
	#(#{External.UInt32 class} #arrayType)
	#(#{External.UInt32 class} #typeName)
	#(#{External.UInt32 class} #vt)
	#(#{External.UInt64 class} #typeName)
	#(#{External.UInt64 class} #vt)
	#(#{External.UInt8 class} #arrayType)
	#(#{External.UInt8 class} #typeName)
	#(#{External.UInt8 class} #vt)
	#(#{External.UIntPtr class} #arrayType)
	#(#{External.UIntPtr class} #typeName)
	#(#{External.UIntPtr class} #vt)
	#(#{External.VOID class} #arrayType)
	#(#{External.VOID class} #typeName)
	#(#{External.VOID class} #vt)
	#(#{Kernel.SmalltalkLocale} #displayCURRENCY:on:)
	#(#{Kernel.SmalltalkLocale} #displayDECIMAL:on:)
	#(#{Kernel.SmalltalkLocale} #variantBool:)
	#(#{OS.AbstractWindowsLocale} #boolFormat)
	#(#{OS.AbstractWindowsLocale} #displayCURRENCY:on:)
	#(#{OS.AbstractWindowsLocale} #displayDECIMAL:on:)
	#(#{OS.AbstractWindowsLocale} #getVariantBoolString:)
	#(#{OS.AbstractWindowsLocale} #variantBool:)
	#(#{OS.COM.BSTR} #asSAFEARRAY)
	#(#{OS.COM.BSTR} #asVariant)
	#(#{OS.COM.BSTR class} #fromObject:)
	#(#{OS.COM.BSTR class} #newSAFEARRAY:)
	#(#{OS.COM.BSTR class} #typeName)
	#(#{OS.COM.BSTR class} #vt)
	#(#{OS.COM.CLSID class} #newSAFEARRAY:)
	#(#{OS.COM.CLSID class} #vt)
	#(#{OS.COM.IErrorInfo class} #fromEXCEPINFO:guid:)
	#(#{OS.COM.IErrorInfo class} #source:description:helpContext:helpFile:guid:)
	#(#{OS.COM.Interface} #coclassTypeInfo)
	#(#{OS.COM.Interface} #coclassTypeInfoIfNone:)
	#(#{OS.COM.Interface} #typeInfo)
	#(#{OS.COM.Interface} #typeInfoIfNone:)
	#(#{OS.COM.Interface class} #coclassTypeInfo)
	#(#{OS.COM.Interface class} #coclassTypeInfoIfNone:)
	#(#{OS.COM.Interface class} #errorNoTypeInfo)
	#(#{OS.COM.Interface class} #fromObject:)
	#(#{OS.COM.Interface class} #newSAFEARRAY:)
	#(#{OS.COM.Interface class} #registerDispinterface:)
	#(#{OS.COM.Interface class} #typeInfoIfNone:)
	#(#{OS.COM.Interface class} #typeLib)
	#(#{OS.COM.IUnknown} #asVariant)
	#(#{OS.COM.IUnknown class} #vt)
	#(#{OS.COM.OLEAutLibrary} #clearCustData:)
	#(#{OS.COM.OLEAutLibrary} #createErrorInfo:)
	#(#{OS.COM.OLEAutLibrary} #getRecordInfoFromTypeInfo:ppRecInfo:)
	#(#{OS.COM.OLEAutLibrary} #lHashValOfNameSys:lcid:szName:)
	#(#{OS.COM.OLEAutLibrary} #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #loadTypeLib:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #loadTypeLibEx:regkind:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #oleCreateFontIndirect:riid:ppvObj:)
	#(#{OS.COM.OLEAutLibrary} #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:)
	#(#{OS.COM.OLEAutLibrary} #registerTypeLib:wszFullPath:wszHelpDir:)
	#(#{OS.COM.OLEAutLibrary} #registerTypeLibForUser:szFullPath:szHelpDir:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayAccessData:ppvData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCopy:ppsaout:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCreateEx:cDims:rgsabound:pvExtra:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayDestroy:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetDim:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetElement:rgIndices:pv:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetIID:pguid:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetLBound:nDim:plLbound:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetRecordInfo:prinfo:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetUBound:nDim:plUbound:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetVartype:pvt:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayPtrOfIndex:rgIndices:ppvData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayPutElement:rgIndices:pv:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayRedim:psaboundNew:)
	#(#{OS.COM.OLEAutLibrary} #safeArraySetIID:pguid:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayUnaccessData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayUnlock:)
	#(#{OS.COM.OLEAutLibrary} #setErrorInfo:perrinfo:)
	#(#{OS.COM.OLEAutLibrary} #systemTimeToVariantTime:pvtime:)
	#(#{OS.COM.OLEAutLibrary} #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:)
	#(#{OS.COM.OLEAutLibrary} #varBstrFromBool:lcid:dwFlags:pbstrOut:)
	#(#{OS.COM.OLEAutLibrary} #varBstrFromCy:lcid:dwFlags:pbstrOut:)
	#(#{OS.COM.OLEAutLibrary} #varBstrFromDec:lcid:dwFlags:pbstrOut:)
	#(#{OS.COM.OLEAutLibrary} #varCmp:pvarRight:lcid:dwFlags:)
	#(#{OS.COM.OLEAutLibrary} #varDateFromStr:lcid:dwFlags:pdateOut:)
	#(#{OS.COM.OLEAutLibrary} #variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:)
	#(#{OS.COM.OLEAutLibrary} #variantClear:)
	#(#{OS.COM.OLEAutLibrary} #variantCopy:pvargSrc:)
	#(#{OS.COM.OLEAutLibrary} #variantCopyInd:pvargSrc:)
	#(#{OS.COM.OLEAutLibrary} #variantInit:)
	#(#{OS.COM.OLEAutLibrary} #variantTimeToSystemTime:lpSystemTime:)
	#(#{OS.FILETIME class} #vt)
	#(#{OS.HRESULT class} #typeName)
	#(#{OS.HRESULT class} #vt)
	#(#{OS.SYSTEMTIME} #asFloat)
	#(#{OS.SYSTEMTIME} #asVariant)
	#(#{OS.SYSTEMTIME class} #fromDATE:)
).

package setPrerequisites: #(
	'..\..\Base\Dolphin'
	'..\..\Base\Dolphin Conformant Array Fields'
	'..\COM\OLE COM'
).

package!

"Class Definitions"!

Kernel.SharedPool
	subclass: #'OS.COM.AutomationConstants'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'ACTIVEOBJECT_STRONG' -> 16r0.
			'ACTIVEOBJECT_WEAK' -> 16r1.
			'CC_CDECL' -> 16r1.
			'CC_MACPASCAL' -> 16r3.
			'CC_MAX' -> 16r9.
			'CC_MPWCDECL' -> 16r7.
			'CC_MPWPASCAL' -> 16r8.
			'CC_MSCPASCAL' -> 16r2.
			'CC_PASCAL' -> 16r2.
			'CC_RESERVED' -> 16r5.
			'CC_STDCALL' -> 16r4.
			'CC_SYSCALL' -> 16r6.
			'DESCKIND_FUNCDESC' -> 16r1.
			'DESCKIND_IMPLICITAPPOBJ' -> 16r4.
			'DESCKIND_MAX' -> 16r5.
			'DESCKIND_NONE' -> 16r0.
			'DESCKIND_TYPECOMP' -> 16r3.
			'DESCKIND_VARDESC' -> 16r2.
			'DISPATCH_METHOD' -> 16r1.
			'DISPATCH_PROPERTYGET' -> 16r2.
			'DISPATCH_PROPERTYPUT' -> 16r4.
			'DISPATCH_PROPERTYPUTREF' -> 16r8.
			'DISPID_ACCELERATOR' -> -16r21F.
			'DISPID_APPEARANCE' -> -16r208.
			'DISPID_AUTOSIZE' -> -16r1F4.
			'DISPID_BACKCOLOR' -> -16r1F5.
			'DISPID_BACKSTYLE' -> -16r1F6.
			'DISPID_BORDERCOLOR' -> -16r1F7.
			'DISPID_BORDERSTYLE' -> -16r1F8.
			'DISPID_BORDERVISIBLE' -> -16r207.
			'DISPID_BORDERWIDTH' -> -16r1F9.
			'DISPID_CAPTION' -> -16r206.
			'DISPID_COLLECT' -> -16r8.
			'DISPID_COLUMN' -> -16r211.
			'DISPID_CONSTRUCTOR' -> -16r6.
			'DISPID_DESTRUCTOR' -> -16r7.
			'DISPID_DISPLAYSTYLE' -> -16r21C.
			'DISPID_DRAWMODE' -> -16r1FB.
			'DISPID_DRAWSTYLE' -> -16r1FC.
			'DISPID_DRAWWIDTH' -> -16r1FD.
			'DISPID_ENABLED' -> -16r202.
			'DISPID_ENTERKEYBEHAVIOR' -> -16r220.
			'DISPID_EVALUATE' -> -16r5.
			'DISPID_FILLCOLOR' -> -16r1FE.
			'DISPID_FILLSTYLE' -> -16r1FF.
			'DISPID_FONT' -> -16r200.
			'DISPID_FORECOLOR' -> -16r201.
			'DISPID_GROUPNAME' -> -16r21D.
			'DISPID_HWND' -> -16r203.
			'DISPID_IMEMODE' -> -16r21E.
			'DISPID_LIST' -> -16r210.
			'DISPID_LISTCOUNT' -> -16r213.
			'DISPID_LISTINDEX' -> -16r20E.
			'DISPID_MAXLENGTH' -> -16r215.
			'DISPID_MOUSEICON' -> -16r20A.
			'DISPID_MOUSEPOINTER' -> -16r209.
			'DISPID_MULTILINE' -> -16r219.
			'DISPID_MULTISELECT' -> -16r214.
			'DISPID_NEWENUM' -> -16r4.
			'DISPID_NUMBEROFCOLUMNS' -> -16r21B.
			'DISPID_NUMBEROFROWS' -> -16r21A.
			'DISPID_PASSWORDCHAR' -> -16r216.
			'DISPID_PICTURE' -> -16r20B.
			'DISPID_PROPERTYPUT' -> -16r3.
			'DISPID_READYSTATE' -> -16r20D.
			'DISPID_SCROLLBARS' -> -16r217.
			'DISPID_SELECTED' -> -16r20F.
			'DISPID_SELLENGTH' -> -16r224.
			'DISPID_SELSTART' -> -16r223.
			'DISPID_SELTEXT' -> -16r222.
			'DISPID_TABKEYBEHAVIOR' -> -16r221.
			'DISPID_TABSTOP' -> -16r204.
			'DISPID_TEXT' -> -16r205.
			'DISPID_UNKNOWN' -> -16r1.
			'DISPID_VALID' -> -16r20C.
			'DISPID_VALUE' -> 16r0.
			'DISPID_WORDWRAP' -> -16r218.
			'FADF_AUTO' -> 16r1.
			'FADF_BSTR' -> 16r100.
			'FADF_DISPATCH' -> 16r400.
			'FADF_EMBEDDED' -> 16r4.
			'FADF_FIXEDSIZE' -> 16r10.
			'FADF_HAVEIID' -> 16r40.
			'FADF_HAVEVARTYPE' -> 16r80.
			'FADF_RECORD' -> 16r20.
			'FADF_RESERVED' -> 16rF0E8.
			'FADF_STATIC' -> 16r2.
			'FADF_UNKNOWN' -> 16r200.
			'FADF_VARIANT' -> 16r800.
			'FUNC_DISPATCH' -> 16r4.
			'FUNC_NONVIRTUAL' -> 16r2.
			'FUNC_PUREVIRTUAL' -> 16r1.
			'FUNC_STATIC' -> 16r3.
			'FUNC_VIRTUAL' -> 16r0.
			'FUNCFLAG_FBINDABLE' -> 16r4.
			'FUNCFLAG_FDEFAULTBIND' -> 16r20.
			'FUNCFLAG_FDEFAULTCOLLELEM' -> 16r100.
			'FUNCFLAG_FDISPLAYBIND' -> 16r10.
			'FUNCFLAG_FHIDDEN' -> 16r40.
			'FUNCFLAG_FIMMEDIATEBIND' -> 16r1000.
			'FUNCFLAG_FNONBROWSABLE' -> 16r400.
			'FUNCFLAG_FREPLACEABLE' -> 16r800.
			'FUNCFLAG_FREQUESTEDIT' -> 16r8.
			'FUNCFLAG_FRESTRICTED' -> 16r1.
			'FUNCFLAG_FSOURCE' -> 16r2.
			'FUNCFLAG_FUIDEFAULT' -> 16r200.
			'FUNCFLAG_FUSESGETLASTERROR' -> 16r80.
			'ID_DEFAULTINST' -> -16r2.
			'IDLFLAG_FIN' -> 16r1.
			'IDLFLAG_FLCID' -> 16r4.
			'IDLFLAG_FOUT' -> 16r2.
			'IDLFLAG_FRETVAL' -> 16r8.
			'IDLFLAG_NONE' -> 16r0.
			'IMPLTYPEFLAG_FDEFAULT' -> 16r1.
			'IMPLTYPEFLAG_FRESTRICTED' -> 16r4.
			'IMPLTYPEFLAG_FSOURCE' -> 16r2.
			'INVOKE_FUNC' -> 16r1.
			'INVOKE_PROPERTYGET' -> 16r2.
			'INVOKE_PROPERTYPUT' -> 16r4.
			'INVOKE_PROPERTYPUTREF' -> 16r8.
			'LIBFLAG_FCONTROL' -> 16r2.
			'LIBFLAG_FHASDISKIMAGE' -> 16r8.
			'LIBFLAG_FHIDDEN' -> 16r4.
			'LIBFLAG_FRESTRICTED' -> 16r4.
			'MEMBERID_NIL' -> -16r1.
			'PARAMFLAG_FHASDEFAULT' -> 16r20.
			'PARAMFLAG_FIN' -> 16r1.
			'PARAMFLAG_FOPT' -> 16r10.
			'PARAMFLAG_FOUT' -> 16r2.
			'PARAMFLAG_FRETVAL' -> 16r8.
			'PARAMFLAG_NONE' -> 16r0.
			'REGKIND_DEFAULT' -> 16r0.
			'REGKIND_NONE' -> 16r2.
			'REGKIND_REGISTER' -> 16r1.
			'STDOLE_LCID' -> 16r0.
			'STDOLE_MAJORVERNUM' -> 16r1.
			'STDOLE_MINORVERNUM' -> 16r0.
			'SYS_MAC' -> 16r2.
			'SYS_WIN16' -> 16r0.
			'SYS_WIN32' -> 16r1.
			'TKIND_ALIAS' -> 16r6.
			'TKIND_COCLASS' -> 16r5.
			'TKIND_DISPATCH' -> 16r4.
			'TKIND_ENUM' -> 16r0.
			'TKIND_INTERFACE' -> 16r3.
			'TKIND_MAX' -> 16r8.
			'TKIND_MODULE' -> 16r2.
			'TKIND_RECORD' -> 16r1.
			'TKIND_UNION' -> 16r7.
			'TYPEFLAG_FAGGREGATABLE' -> 16r400.
			'TYPEFLAG_FAPPOBJECT' -> 16r1.
			'TYPEFLAG_FCANCREATE' -> 16r2.
			'TYPEFLAG_FCONTROL' -> 16r20.
			'TYPEFLAG_FDISPATCHABLE' -> 16r1000.
			'TYPEFLAG_FDUAL' -> 16r40.
			'TYPEFLAG_FHIDDEN' -> 16r10.
			'TYPEFLAG_FLICENSED' -> 16r4.
			'TYPEFLAG_FNONEXTENSIBLE' -> 16r80.
			'TYPEFLAG_FOLEAUTOMATION' -> 16r100.
			'TYPEFLAG_FPREDECLID' -> 16r8.
			'TYPEFLAG_FRESTRICTED' -> 16r200.
			'VAR_CONST' -> 16r2.
			'VAR_DATEVALUEONLY' -> 16r2.
			'VAR_DISPATCH' -> 16r3.
			'VAR_PERINSTANCE' -> 16r0.
			'VAR_STATIC' -> 16r1.
			'VAR_TIMEVALUEONLY' -> 16r1.
			'VARCMP_NULL' -> 16r3.
			'VARFLAG_FBINDABLE' -> 16r4.
			'VARFLAG_FDEFAULTBIND' -> 16r20.
			'VARFLAG_FDISPLAYBIND' -> 16r10.
			'VARFLAG_FHIDDEN' -> 16r40.
			'VARFLAG_FNONBROWSABLE' -> 16r400.
			'VARFLAG_FREADONLY' -> 16r1.
			'VARFLAG_FREQUESTEDIT' -> 16r8.
			'VARFLAG_FRESTRICTED' -> 16r80.
			'VARFLAG_FSOURCE' -> 16r2.
			'VARFLAG_FUIDEFAULT' -> 16r200.
			'VARIANT_ALPHABOOL' -> 16r2.
			'VARIANT_CALENDAR_GREGORIAN' -> 16r40.
			'VARIANT_CALENDAR_HIJRI' -> 16r8.
			'VARIANT_CALENDAR_THAI' -> 16r20.
			'VARIANT_FALSE' -> 16r0.
			'VARIANT_LOCALBOOL' -> 16r10.
			'VARIANT_NOUSEROVERRIDE' -> 16r4.
			'VARIANT_NOVALUEPROP' -> 16r1.
			'VARIANT_TRUE' -> -16r1.
			'VARIANT_USE_NLS' -> 16r80.
			'VT_ARRAY' -> 16r2000.
			'VT_BLOB' -> 16r41.
			'VT_BLOB_OBJECT' -> 16r46.
			'VT_BOOL' -> 16rB.
			'VT_BSTR' -> 16r8.
			'VT_BYREF' -> 16r4000.
			'VT_CARRAY' -> 16r1C.
			'VT_CF' -> 16r47.
			'VT_CLSID' -> 16r48.
			'VT_CY' -> 16r6.
			'VT_DATE' -> 16r7.
			'VT_DECIMAL' -> 16rE.
			'VT_DISPATCH' -> 16r9.
			'VT_EMPTY' -> 16r0.
			'VT_ERROR' -> 16rA.
			'VT_FILETIME' -> 16r40.
			'VT_HRESULT' -> 16r19.
			'VT_I1' -> 16r10.
			'VT_I2' -> 16r2.
			'VT_I4' -> 16r3.
			'VT_I8' -> 16r14.
			'VT_INT' -> 16r16.
			'VT_INT_PTR' -> 16r25.
			'VT_LPSTR' -> 16r1E.
			'VT_LPWSTR' -> 16r1F.
			'VT_NULL' -> 16r1.
			'VT_PTR' -> 16r1A.
			'VT_R4' -> 16r4.
			'VT_R8' -> 16r5.
			'VT_RECORD' -> 16r24.
			'VT_SAFEARRAY' -> 16r1B.
			'VT_STORAGE' -> 16r43.
			'VT_STORED_OBJECT' -> 16r45.
			'VT_STREAM' -> 16r42.
			'VT_STREAMED_OBJECT' -> 16r44.
			'VT_TYPEMASK' -> 16rFFF.
			'VT_UI1' -> 16r11.
			'VT_UI2' -> 16r12.
			'VT_UI4' -> 16r13.
			'VT_UI8' -> 16r15.
			'VT_UINT' -> 16r17.
			'VT_UINT_PTR' -> 16r26.
			'VT_UNKNOWN' -> 16rD.
			'VT_USERDEFINED' -> 16r1D.
			'VT_VARIANT' -> 16rC.
			'VT_VECTOR' -> 16r1000.
			'VT_VOID' -> 16r18
		}!

Kernel.SharedPool
	subclass: #'OS.COM.AutomationErrors'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'DISP_E_ARRAYISLOCKED' -> -16r7FFDFFF3.
			'DISP_E_BADINDEX' -> -16r7FFDFFF5.
			'DISP_E_BADVARTYPE' -> -16r7FFDFFF8.
			'DISP_E_DIVBYZERO' -> -16r7FFDFFEE.
			'DISP_E_EXCEPTION' -> -16r7FFDFFF7.
			'DISP_E_MEMBERNOTFOUND' -> -16r7FFDFFFD.
			'DISP_E_OVERFLOW' -> -16r7FFDFFF6.
			'DISP_E_PARAMNOTFOUND' -> -16r7FFDFFFC.
			'DISP_E_TYPEMISMATCH' -> -16r7FFDFFFB.
			'DISP_E_UNKNOWNNAME' -> -16r7FFDFFFA.
			'TYPE_E_CANTLOADLIBRARY' -> -16r7FFD63B6.
			'TYPE_E_ELEMENTNOTFOUND' -> -16r7FFD7FD5.
			'TYPE_E_FIELDNOTFOUND' -> -16r7FFD7FE9.
			'TYPE_E_LIBNOTREGISTERED' -> -16r7FFD7FE3.
			'WCODE_HRESULT_FIRST' -> -16r7FFBFE00.
			'WCODE_HRESULT_LAST' -> -16r7FFB0001
		}!

Kernel.SharedPool
	subclass: #'OS.COM.TypeGenerationFlags'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'CommentStyleMask' -> 16r101.
			'DefineProtocol' -> 16r20.
			'LowercaseIdentifiers' -> 16r400.
			'MinimizeWrappers' -> 16r80.
			'NoClassComment' -> 16r1.
			'NoCompile' -> 16r40.
			'NoFunctionTable' -> 16r4.
			'NoSourceInterfaces' -> 16r200.
			'NoTypeLib' -> 16r2.
			'OverwriteClassComments' -> 16r100.
			'RawMethodsOnly' -> 16r10.
			'Trace' -> 16r8.
			'TraceOnly' -> 16r48.
			'Verbose' -> 16r800.
			'WrapperStyleMask' -> 16r90
		}!

Core.Object
	subclass: #'OS.COM.TypeInfoObject'
	instanceVariableNames: 'tlbInterface generationFlags binding'
	classVariableNames: 'ClassCommentStyleMap GuidClash HighLevelWrapperStyleMap NamespaceClash SuperclassClash TracingStyleMap'
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.TypeGenerationFlags})
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'OS.COM.TypeLibDocumentation'
	instanceVariableNames: 'name helpstring helpcontext helpfile'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.InterfaceFunction
	subclass: #'OS.COM.DispatchFunction'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.Win32Errors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.InterfaceImplementation
	subclass: #'OS.COM.AbstractDispatchImplementation'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.AbstractDispatchImplementation
	subclass: #'OS.COM.DualInterfaceImplementation'
	instanceVariableNames: 'interface piTypeInfo locale'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.DualInterfaceImplementation
	subclass: #'OS.COM.ForwardingDualInterfaceImplementation'
	instanceVariableNames: 'interfaceClass server'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.Enumerator
	subclass: #'OS.COM.VariantEnumerator'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

External.Structure
	subclass: #'OS.COM.AbstractELEMDESC'
	instanceVariableNames: 'owner tdesc'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: { '_OffsetOf_tdescElem' -> 16r0 }!

External.Structure
	subclass: #'OS.COM.CURRENCY'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_CURRENCY_Size' -> 16r8.
			'_OffsetOf_cy' -> 16r0.
			'MaxValue' -> 922337203685477.5807s.
			'MinValue' -> -922337203685477.5808s
		}!

External.Structure
	subclass: #'OS.COM.CUSTDATAITEM'
	instanceVariableNames: 'key value'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_CUSTDATAITEM_Size' -> 16r20.
			'_OffsetOf_guid' -> 16r0.
			'_OffsetOf_varValue' -> 16r10
		}!

External.Structure
	subclass: #'OS.COM.DECIMAL'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_DECIMAL_Size' -> 16r10.
			'_OffsetOf_hi32' -> 16r4.
			'_OffsetOf_lo64' -> 16r8.
			'_OffsetOf_scale' -> 16r2.
			'_OffsetOf_sign' -> 16r3.
			'_OffsetOf_wReserved' -> 16r0.
			'MaxScale' -> 16r1C.
			'MaxValue' -> 16rFFFFFFFFFFFFFFFFFFFFFFFF.
			'SmallestValue' -> 0.0000000000000000000000000001s
		}!

External.Structure
	subclass: #'OS.COM.DISPPARAMS'
	instanceVariableNames: 'args vargs dispids'
	classVariableNames: 'ZeroArgs'
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_DISPPARAMS_Size' -> 16r10.
			'_OffsetOf_cArgs' -> 16r8.
			'_OffsetOf_cNamedArgs' -> 16rC.
			'_OffsetOf_rgdispidNamedArgs' -> 16r4.
			'_OffsetOf_rgvarg' -> 16r0
		}!

External.Structure
	subclass: #'OS.COM.IDLDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_IDLDESC_Size' -> 16r8.
			'_OffsetOf_dwReserved' -> 16r0.
			'_OffsetOf_wIDLFlags' -> 16r4
		}!

External.Structure
	subclass: #'OS.COM.PARAMDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_pparamdescex' -> 16r0.
			'_OffsetOf_wParamFlags' -> 16r4.
			'_PARAMDESC_Size' -> 16r8
		}!

External.Structure
	subclass: #'OS.COM.PARAMDESCEX'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_cBytes' -> 16r0.
			'_OffsetOf_varDefaultValue' -> 16r8.
			'_PARAMDESCEX_Size' -> 16r18
		}!

External.Structure
	subclass: #'OS.COM.SAFEARRAYBOUND'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_cElements' -> 16r0.
			'_OffsetOf_lLbound' -> 16r4.
			'_SAFEARRAYBOUND_Size' -> 16r8
		}!

External.Structure
	subclass: #'OS.COM.TLIBATTR'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_guid' -> 16r0.
			'_OffsetOf_lcid' -> 16r10.
			'_OffsetOf_syskind' -> 16r14.
			'_OffsetOf_wLibFlags' -> 16r1C.
			'_OffsetOf_wMajorVerNum' -> 16r18.
			'_OffsetOf_wMinorVerNum' -> 16r1A.
			'_TLIBATTR_Size' -> 16r20
		}!

External.Structure
	subclass: #'OS.COM.TYPEDESC'
	instanceVariableNames: 'owner classDesc typeInfo'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_hreftype' -> 16r0.
			'_OffsetOf_lpadesc' -> 16r0.
			'_OffsetOf_lptdesc' -> 16r0.
			'_OffsetOf_vt' -> 16r4.
			'_TYPEDESC_Size' -> 16r8.
			'VTIndirections'
				-> #[0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
		}!

OS.COM.AbstractELEMDESC
	subclass: #'OS.COM.ARRAYDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_ARRAYDESC_Size' -> 16r14.
			'_OffsetOf_cDims' -> 16r8.
			'_OffsetOf_rgbounds' -> 16rC
		}!

OS.COM.AbstractELEMDESC
	subclass: #'OS.COM.ELEMDESC'
	instanceVariableNames: 'param index custData'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: { '_ELEMDESC_Size' -> 16r10. '_OffsetOf_paramdesc' -> 16r8 }!

External.ExternalArray
	subclass: #'OS.COM.BSTRArray'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

External.GenericExternalArray
	subclass: #'OS.COM.SAFEARRAY'
	instanceVariableNames: 'data start recordInfo'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_cbElements' -> 16r4.
			'_OffsetOf_cDims' -> 16r0.
			'_OffsetOf_cLocks' -> 16r8.
			'_OffsetOf_fFeatures' -> 16r2.
			'_OffsetOf_pvData' -> 16rC.
			'_OffsetOf_rgsabound' -> 16r10.
			'_SAFEARRAY_Size' -> 16r18
		}!

External.FinalizableStructure
	subclass: #'OS.COM.CUSTDATA'
	instanceVariableNames: 'associations table'
	classVariableNames: 'WellKnownCustomAttributes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_CUSTDATA_Size' -> 16r8.
			'_OffsetOf_cCustData' -> 16r0.
			'_OffsetOf_prgCustData' -> 16r4
		}!

External.FinalizableStructure
	subclass: #'OS.COM.Record'
	instanceVariableNames: 'recordInfo owner'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

External.FinalizableStructure
	subclass: #'OS.COM.TypeInfoStructure'
	instanceVariableNames: 'analyzer'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!

External.FinalizableStructure
	subclass: #'OS.COM.VARIANT'
	instanceVariableNames: 'data'
	classVariableNames: 'Unspecified'
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_boolVal' -> 16r8.
			'_OffsetOf_bstrVal' -> 16r8.
			'_OffsetOf_bVal' -> 16r8.
			'_OffsetOf_byref' -> 16r8.
			'_OffsetOf_cVal' -> 16r8.
			'_OffsetOf_cyVal' -> 16r8.
			'_OffsetOf_date' -> 16r8.
			'_OffsetOf_dblVal' -> 16r8.
			'_OffsetOf_decVal' -> 16r0.
			'_OffsetOf_fltVal' -> 16r8.
			'_OffsetOf_intVal' -> 16r8.
			'_OffsetOf_iVal' -> 16r8.
			'_OffsetOf_llVal' -> 16r8.
			'_OffsetOf_lVal' -> 16r8.
			'_OffsetOf_parray' -> 16r8.
			'_OffsetOf_pboolVal' -> 16r8.
			'_OffsetOf_pbstrVal' -> 16r8.
			'_OffsetOf_pbVal' -> 16r8.
			'_OffsetOf_pcVal' -> 16r8.
			'_OffsetOf_pcyVal' -> 16r8.
			'_OffsetOf_pdate' -> 16r8.
			'_OffsetOf_pdblVal' -> 16r8.
			'_OffsetOf_pdecVal' -> 16r8.
			'_OffsetOf_pdispVal' -> 16r8.
			'_OffsetOf_pfltVal' -> 16r8.
			'_OffsetOf_pintVal' -> 16r8.
			'_OffsetOf_piVal' -> 16r8.
			'_OffsetOf_pllVal' -> 16r8.
			'_OffsetOf_plVal' -> 16r8.
			'_OffsetOf_pparray' -> 16r8.
			'_OffsetOf_ppdispVal' -> 16r8.
			'_OffsetOf_ppunkVal' -> 16r8.
			'_OffsetOf_pRecInfo' -> 16rC.
			'_OffsetOf_pscode' -> 16r8.
			'_OffsetOf_puintVal' -> 16r8.
			'_OffsetOf_puiVal' -> 16r8.
			'_OffsetOf_pullVal' -> 16r8.
			'_OffsetOf_pulVal' -> 16r8.
			'_OffsetOf_punkVal' -> 16r8.
			'_OffsetOf_pvarVal' -> 16r8.
			'_OffsetOf_pvRecord' -> 16r8.
			'_OffsetOf_scode' -> 16r8.
			'_OffsetOf_uintVal' -> 16r8.
			'_OffsetOf_uiVal' -> 16r8.
			'_OffsetOf_ullVal' -> 16r8.
			'_OffsetOf_ulVal' -> 16r8.
			'_OffsetOf_vt' -> 16r0.
			'_OffsetOf_wReserved1' -> 16r2.
			'_OffsetOf_wReserved2' -> 16r4.
			'_OffsetOf_wReserved3' -> 16r6.
			'_VARIANT_Size' -> 16r10.
			'VTClasses'
				-> #(#{Core.UndefinedObject} #{Core.UndefinedObject} #{External.Int16} #{External.Int32} #{External.FLOAT} #{External.DOUBLE} #{OS.COM.CURRENCY} #{OS.COM.DATE} #{OS.COM.BSTR} #{OS.COM.IDispatch} #{OS.HRESULT} #{OS.COM.VARIANT_BOOL} #{OS.COM.VARIANT} #{OS.COM.IUnknown} #{OS.COM.DECIMAL} nil #{External.Int8} #{External.UInt8} #{External.UInt16} #{External.UInt32} #{External.Int64} #{External.UInt64} #{External.Int32} #{External.UInt32} #{External.VOID} #{OS.HRESULT} #{External.Address} #{OS.COM.SAFEARRAY} #{External.Array} #{OS.COM.Record} #{Core.AnsiString} #{Core.Utf16String} nil nil nil nil #{External.Structure} #{External.IntPtr} #{External.UIntPtr} nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #{OS.FILETIME} #{Core.ByteArray} #{OS.COM.IStream} #{OS.COM.IStorage} #{OS.COM.IStream} #{OS.COM.IStorage} #{Core.ByteArray} #{External.UInt32} #{OS.COM.CLSID}).
			'VTNames'
				-> #(#nil #null #int16 #int32 #float #double #cy #date #bstr #dispatch #hresult #varbool #variant #unknown #decimal #badVarType #int8 #uint8 #uint16 #uint32 #int64 #uint64 #int32 #uint32 #void #hresult #lpvoid #safearray #carray #typedef #lpstr #lpwstr #badVarType #badVarType #badVarType #badVarType #struct #intptr #uintptr #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #filetime #blob #stream #storage #streamed_object #stored_object #blob_object #cf #clsid)
		}!

OS.COM.TypeInfoStructure
	subclass: #'OS.COM.MemberDesc'
	instanceVariableNames: 'index custData documentation'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: { '_OffsetOf_memid' -> 16r0 }!

OS.COM.TypeInfoStructure
	subclass: #'OS.COM.TYPEATTR'
	instanceVariableNames: 'piTypeInfo'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_cbAlignment' -> 16r34.
			'_OffsetOf_cbSizeInstance' -> 16r24.
			'_OffsetOf_cbSizeVft' -> 16r32.
			'_OffsetOf_cFuncs' -> 16r2C.
			'_OffsetOf_cImplTypes' -> 16r30.
			'_OffsetOf_cVars' -> 16r2E.
			'_OffsetOf_dwReserved' -> 16r14.
			'_OffsetOf_guid' -> 16r0.
			'_OffsetOf_idldescType' -> 16r44.
			'_OffsetOf_lcid' -> 16r10.
			'_OffsetOf_lpstrSchema' -> 16r20.
			'_OffsetOf_memidConstructor' -> 16r18.
			'_OffsetOf_memidDestructor' -> 16r1C.
			'_OffsetOf_tdescAlias' -> 16r3C.
			'_OffsetOf_typekind' -> 16r28.
			'_OffsetOf_wMajorVerNum' -> 16r38.
			'_OffsetOf_wMinorVerNum' -> 16r3A.
			'_OffsetOf_wTypeFlags' -> 16r36.
			'_TYPEATTR_Size' -> 16r4C
		}!

OS.COM.MemberDesc
	subclass: #'OS.COM.FUNCDESC'
	instanceVariableNames: 'names arguments outputIndices retvalIndex methodName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_FUNCDESC_Size' -> 16r34.
			'_OffsetOf_callconv' -> 16r14.
			'_OffsetOf_cParams' -> 16r18.
			'_OffsetOf_cParamsOpt' -> 16r1A.
			'_OffsetOf_cScodes' -> 16r1E.
			'_OffsetOf_elemdescFunc' -> 16r20.
			'_OffsetOf_funckind' -> 16rC.
			'_OffsetOf_invkind' -> 16r10.
			'_OffsetOf_lprgelemdescParam' -> 16r8.
			'_OffsetOf_lprgscode' -> 16r4.
			'_OffsetOf_oVft' -> 16r1C.
			'_OffsetOf_wFuncFlags' -> 16r30
		}!

OS.COM.MemberDesc
	subclass: #'OS.COM.VARDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_OffsetOf_elemdesc' -> 16rC.
			'_OffsetOf_lpstrSchema' -> 16r4.
			'_OffsetOf_lpvarValue' -> 16r8.
			'_OffsetOf_oInst' -> 16r8.
			'_OffsetOf_varkind' -> 16r20.
			'_OffsetOf_wVarFlags' -> 16r1C.
			'_VARDESC_Size' -> 16r24
		}!

OS.COM.IUnknown
	subclass: #'OS.COM.ICreateErrorInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.IDispatch'
	instanceVariableNames: 'typeInfo dispatchImplementor'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.IPerPropertyBrowsing'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.IProvideClassInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.IRecordInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.ITypeComp'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.ITypeInfo'
	instanceVariableNames: 'attributes allCustData'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IUnknown
	subclass: #'OS.COM.ITypeLib'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IEnumXXXX
	subclass: #'OS.COM.IEnumVARIANT'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.IProvideClassInfo
	subclass: #'OS.COM.IProvideClassInfo2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.ITypeInfo
	subclass: #'OS.COM.ITypeInfo2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.ITypeLib
	subclass: #'OS.COM.ITypeLib2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

External.DOUBLE
	subclass: #'OS.COM.DATE'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!

External.Int16
	subclass: #'OS.COM.VARIANT_BOOL'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

External.LPVOID
	subclass: #'OS.COM.LPBSTR'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.SizedStructure
	subclass: #'OS.COM.FONTDESC'
	instanceVariableNames: 'name'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'_FONTDESC_Size' -> 16r20.
			'_OffsetOf_cySize' -> 16r8.
			'_OffsetOf_fItalic' -> 16r14.
			'_OffsetOf_fStrikethrough' -> 16r1C.
			'_OffsetOf_fUnderline' -> 16r18.
			'_OffsetOf_lpstrName' -> 16r4.
			'_OffsetOf_sCharset' -> 16r12.
			'_OffsetOf_sWeight' -> 16r10
		}!

OS.COM.TypeInfoObject
	subclass: #'OS.COM.TypeInfoAnalyzer'
	instanceVariableNames: 'typeLib guid index documentation'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'VTtoIDLTypeMap'
				-> #(nil 'short' 'long' 'float' 'double' 'CURRENCY' 'DATE' 'BSTR' 'IDispatch*' 'SCODE' 'VARIANT_BOOL' 'VARIANT' 'IUnknown*' 'DECIMAL' nil 'char' 'BYTE' 'unsigned short' 'unsigned long' '__int64' 'unsigned __int64' 'int' 'unsigned int' 'void' 'HRESULT' '*' 'SAFEARRAY*' '[]' 'typedef' 'LPSTR' 'LPWSTR')
		}!

OS.COM.TypeInfoObject
	subclass: #'OS.COM.TypeLibraryAnalyzer'
	instanceVariableNames: 'attributes namespaceName packageName _unused7 constantsPoolName aliasMap typeAnalyzers'
	classVariableNames: 'StandardAliases TypeLibs'
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.TypeInfoAnalyzer
	subclass: #'OS.COM.APIInfoAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.TypeInfoAnalyzer
	subclass: #'OS.COM.StructureTypeAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'BuiltIns'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.TypeInfoAnalyzer
	subclass: #'OS.COM.TKindAliasAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'BaseTypes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.TypeInfoAnalyzer
	subclass: #'OS.COM.TKindCoclassAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.TypeInfoAnalyzer
	subclass: #'OS.COM.TKindEnumAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.APIInfoAnalyzer
	subclass: #'OS.COM.InterfaceTypeAnalyzer'
	instanceVariableNames: 'protocol isSource'
	classVariableNames: 'ReservedDispSelectors ReservedUnkSelectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.APIInfoAnalyzer
	subclass: #'OS.COM.TKindModuleAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.InterfaceTypeAnalyzer
	subclass: #'OS.COM.TKindDispatchAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'SpecialPropGets'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.InterfaceTypeAnalyzer
	subclass: #'OS.COM.TKindInterfaceAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.StructureTypeAnalyzer
	subclass: #'OS.COM.TKindRecordAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

OS.COM.StructureTypeAnalyzer
	subclass: #'OS.COM.TKindUnionAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Boolean methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^OS.COM.VARIANT fromBoolean: self! !

!Core.Boolean categoriesForMethods!
asVariant!converting!public! !
!

!Core.ByteArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^OS.COM.SAFEARRAY withAll: self elementClass: External.UInt8! !

!Core.ByteArray categoriesForMethods!
asSAFEARRAY!converting!public! !
!

!Core.ByteArray class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self fullName! !

!Core.ByteArray class categoriesForMethods!
typeName!constants!private! !
!

!Core.Character methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I2). This will fail for code points not in the BMP."

	^OS.COM.VARIANT new
		int16: self codePoint;
		yourself! !

!Core.Character categoriesForMethods!
asVariant!converting!public! !
!

!Core.Collection methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^OS.COM.SAFEARRAY withAll: self!

asVariant
	"Answer the VARIANT representation of the receiver (a SAFEARRAY of VARIANT)."

	^OS.COM.VARIANT fromCollection: self! !

!Core.Collection categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!Core.DateAndTime methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the <VARIANT> representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !

!Core.DateAndTime categoriesForMethods!
asFloat!converting!public! !
asVariant!converting!public! !
!

!Core.Float methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8)."

	^OS.COM.VARIANT fromFloat: self! !

!Core.Float categoriesForMethods!
asVariant!converting!public! !
!

!Core.Fraction methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8).
	Note that precision may be lost."

	^self asFloat asVariant! !

!Core.Fraction categoriesForMethods!
asVariant!converting!public! !
!

!Core.GUID class methodsFor!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [External.StructureArray] ifFalse: [External.PointerArray]!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self fullName! !

!Core.GUID class categoriesForMethods!
arrayType:!constants!private! !
typeName!constants!private! !
!

!Core.LargeInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I8).
	It is an error if the receiver is too large to be represented in 64-bits."

	^OS.COM.VARIANT fromLargeInteger: self! !

!Core.LargeInteger categoriesForMethods!
asVariant!converting!public! !
!

!Core.Locale methodsFor!

displayCURRENCY: aCURRENCY on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <CURRENCY> argument that a user in this <Locale> might expect to see."

	self subclassResponsibility!

displayDECIMAL: aDECIMAL on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <DECIMAL>, aDecimal, that a user in this <Locale> might expect to see."

	self subclassResponsibility!

variantBool: aBoolean
	^self subclassResponsibility! !

!Core.Locale categoriesForMethods!
displayCURRENCY:on:!displaying!public! !
displayDECIMAL:on:!displaying!public! !
variantBool:!constants!public! !
!

!Core.Number methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^self subclassResponsibility! !

!Core.Number categoriesForMethods!
asVariant!converting!public! !
!

!Core.ScaledDecimal methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Both VT_CY (currency) and VT_DECIMAL types convert to ScaledDecimals
	but the latter has a wider (64-bit unsigned) range and a variable scale, so it
	is more likely to suit."

	^OS.COM.VARIANT new
		decimal: self;
		yourself! !

!Core.ScaledDecimal categoriesForMethods!
asVariant!converting!public! !
!

!Core.SmallInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4 or VT_I8, depending on the
	bitness of the host machine)."

	^OS.COM.VARIANT fromSmallInteger: self! !

!Core.SmallInteger categoriesForMethods!
asVariant!converting!public! !
!

!Core.String methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^OS.COM.VARIANT fromString: self! !

!Core.String categoriesForMethods!
asVariant!converting!public! !
!

!Core.String class methodsFor!

arrayType
	^self!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections.
	Note that in the case of a String, one level of indirection is implied, and therefore we
	always use the PointerArray type."

	^External.PointerArray!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^External.LPSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_LPSTR! !

!Core.String class categoriesForMethods!
arrayType!constants!private! !
arrayType:!constants!private! !
pointerType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!Core.UndefinedObject methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_EMPTY).
	Implementation Note: VT_EMPTY is chosen for compatibility with VB which
	uses VT_EMPTY for null object references, even though VT_NULL might
	appear more appropriate at first glance."

	^OS.COM.VARIANT new! !

!Core.UndefinedObject categoriesForMethods!
asVariant!converting!public! !
!

!Core.UndefinedObject class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver."

	^#nil!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_EMPTY! !

!Core.UndefinedObject class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!Core.Utf16String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^External.LPWSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpwstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_LPWSTR! !

!Core.Utf16String class categoriesForMethods!
pointerType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.Address class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpvoid!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_PTR! !

!External.Address class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!External.BOOL class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !

!External.BOOL class categoriesForMethods!
typeName!constants!private! !
!

!External.BOOLEAN class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !

!External.BOOLEAN class categoriesForMethods!
typeName!constants!private! !
!

!External.DOUBLE class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^DOUBLEArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#double!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_R8! !

!External.DOUBLE class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.ExternalArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver."

	^COM.SAFEARRAY withAll: self elementClass: self elementClass!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_ARRAY|VT_XX)."

	^COM.VARIANT fromCollection: self! !

!External.ExternalArray categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!External.ExternalArray class methodsFor!

arrayType
	^self!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_CARRAY! !

!External.ExternalArray class categoriesForMethods!
arrayType!constants!private! !
vt!constants!public! !
!

!External.FLOAT class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^FLOATArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#float!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_R4! !

!External.FLOAT class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.Handle class methodsFor!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [HandleArray] ifFalse: [PointerArray]!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#handle! !

!External.Handle class categoriesForMethods!
arrayType:!constants!private! !
typeName!constants!private! !
!

!External.Int16 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^Int16Array!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#int16!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I2! !

!External.Int16 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.Int32 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^Int32Array!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#int32!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I4! !

!External.Int32 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.Int64 class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#int64!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I8! !

!External.Int64 class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!External.Int8 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^Int8Array!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#int8!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I1! !

!External.Int8 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^self subclassResponsibility!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self subclassResponsibility! !

!External.INTEGER class categoriesForMethods!
typeName!constants!private! !
vt!constants!private! !
!

!External.IntPtr class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^IntPtrArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#intptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [COM.AutomationConstants.VT_I8] ifFalse: [COM.AutomationConstants.VT_I4]! !

!External.IntPtr class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.LPVOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	#todo "Is this right?".
	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	#todo "Is this right?".
	^COM.AutomationConstants.VT_VOID! !

!External.LPVOID class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!External.SCALAR methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^(COM.VARIANT new)
		vt: (self vt bitOr: COM.AutomationConstants.VT_BYREF);
		reference: self! !

!External.SCALAR categoriesForMethods!
asVariant!converting!public! !
!

!External.Structure methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Note that shis will be a reference to the receiver not a copy."

	^COM.VARIANT new
		struct: self;
		yourself!

recordInfo
	"Answer an <IRecordInfo> on the receiver's type information."

	^self class recordInfo!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self class vt! !

!External.Structure categoriesForMethods!
asVariant!converting!public! !
recordInfo!accessing!public! !
vt!constants!private! !
!

!External.Structure class methodsFor!

arrayType
	"Private - Answer the <ExternalArray> class to be used to represent C arrays of the receiver's type.
	The generic <StructureArray> can actually handle most types, but this may be overridden
	for increased efficiency."

	^StructureArray!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [self arrayType] ifFalse: [PointerArray]!

classForGUID: aGUID ifNone: exceptionHandler
	"Private - Answer the <External.Structure> class (a subclass of the receiver) which
	represents the Record with <GUID>, aGUID, or if none is registered for that GUID
	then the result of evaluating the <niladicValuable>, exceptionHandler."

	^RecordClasses at: aGUID ifAbsent: exceptionHandler

	
!

clearGuid
	"Private - Set the receiver's GUID to be the null <GUID>.
	Override because we must retain our GUID for the table
	of record classes (only needed for ActiveX Automation)."

!

finalRelease
	"The last reference to the receiver (as a COM object) has been released.
	This is an opportunity to actively clean up, rather than passively waiting 
	for finalization which might is asynchronous and may never happen if the 
	object doesn't become garbage."

	"Override as necessary"!

fromAddress: address recordInfo: recInfo owner: owner
	"Answer a new subinstance of the receiver which references the structure
	described by the <IRecordInfo>, recInfo, at the specified address,
	which is owned by the Object, owner."

	^(self classForGUID: recInfo guid
		ifNone: 
			[^COM.Record
				fromAddress: address
				recordInfo: recInfo
				owner: owner])
			fromAddress: address!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^(self newBuffer)
		value: anObject;
		yourself!

GetField: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::GetField() method for the UDT described by the receiver.

		HRESULT __stdcall GetField(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField);

	"

	| refInst hr |
	refInst := self fromAddress: pvData.
	"Help specifies that VariantClear is call on pvarField before copying, normally but just VariantInit, but ..."
	pvarField class clear: pvarField yourAddress.
	
	[pvarField value: (refInst getField: szFieldName).
	hr := 0	"S_OK"] on: MessageNotUnderstood
			do: [:x | hr := Win32Errors.E_INVALIDARG].
	^hr!

GetFieldNames: pcNames rgBstrNames: rgBstrNames
	"Implement the IRecordInfo::GetFieldNames() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNames(
			[in, out] unsigned long* pcNames,
			[out] BSTR* rgBstrNames);
	"

	| names |
	names := self getFieldNames.
	rgBstrNames isNull
		ifTrue: [pcNames value: names size]
		ifFalse: 
			[| namesArray maxNames end |
			maxNames := pcNames value.
			"rgBstrNames will be an LPVOID holding the address of the buffer, which is a sufficiently sized array of BSTR pointers"
			namesArray := OS.COM.BSTRArray fromAddress: rgBstrNames yourAddress length: maxNames.
			end := names size min: maxNames.
			1 to: end do: [:i | namesArray at: i put: (names at: i)].
			end + 1 to: maxNames do: [:i | namesArray at: i put: 0].
			pcNames value: end].
	^0	"S_OK"!

GetFieldNoCopy: pvData szFieldName: szFieldName pvarField: pvarField ppvDataCArray: ppvDataCArray
	"Implement the IRecordInfo::GetFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNoCopy(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField,
			[out] void** ppvDataCArray);
	"

	^Win32Errors.E_NOTIMPL
!

GetGuid: pguid
	"Implement the IRecordInfo::GetGuid() method for the UDT described by the receiver.

		HRESULT __stdcall GetGuid(
			[out] GUID* pguid);
	"

	pguid value: self guid.
	^0 "S_OK"
!

GetName: pbstrName
	"Implement the IRecordInfo::GetName() method for the UDT described by the receiver,
	i.e. answer the name of the record via the <BSTR>* output parameter.

		HRESULT __stdcall GetName(
			[out] BSTR* pbstrName);
	"

	pbstrName value: self name asBSTR detach.
	^0 "S_OK"
!

GetSize: pcbSize
	"Implement the IRecordInfo::GetSize() method for the UDT described by the receiver.

		HRESULT __stdcall GetSize(
			[out] unsigned long* pcbSize);
	"
	
	pcbSize value: self byteSize.
	^0 "S_OK"!

GetTypeInfo: ppTypeInfo
	"Implement the IRecordInfo::GetTypeInfo() method for the UDT described by the receiver.

		HRESULT __stdcall GetTypeInfo(
			[out] ITypeInfo** ppTypeInfo);
	"

	| ti |
	ppTypeInfo value: 0.
	ti := self typeInfoIfNone: [^1 "S_FALSE"].
	ti addRef.
	ppTypeInfo value: ti yourAddress.
	^0 "S_OK"
!

initializeRegister
	"Private - Initialize the register of GUIDs to record classes."

	RecordClasses := WeakLookupTable new
!

IsMatchingType: pRecordInfo
	"Implement the IRecordInfo::IsMatchingType() method for the UDT described by the receiver.

		long __stdcall IsMatchingType(
			[in] IRecordInfo* pRecordInfo);
	"

	^(self guid = pRecordInfo guid) asParameter!

newSAFEARRAY: length 
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	| vt |
	^(vt := self vt) == COM.AutomationConstants.VT_RECORD 
		ifTrue: [COM.SAFEARRAY length: length recordClass: self]
		ifFalse: 
			[COM.SAFEARRAY 
				length: length
				vt: vt
				elementClass: self]!

pointerFieldType
	"Answer the <ExternalField> class to represent pointers to this external type with the
	one indirection."

	^PointerField!

PutField: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutField() method for the UDT described by the receiver.

		HRESULT __stdcall PutField(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	| refInst value |
	refInst := self fromAddress: pvData.
	wFlags = COM.AutomationConstants.INVOKE_PROPERTYPUT
		ifTrue: 
			[| fieldValue |
			fieldValue := [refInst getField: szFieldName] on: MessageNotUnderstood
						do: [:x | ^Win32Errors.E_INVALIDARG].
			value := pvarField isDispatch ifTrue: [pvarField dispatch value] ifFalse: [pvarField value].
			(fieldValue isKindOf: COM.IDispatch)
				ifTrue: 
					[fieldValue isNull ifTrue: [^Win32Errors.E_POINTER].
					fieldValue value: value]
				ifFalse: [refInst setField: szFieldName value: value]]
		ifFalse: 
			[wFlags = COM.AutomationConstants.INVOKE_PROPERTYPUTREF
				ifTrue: [value := pvarField value]
				ifFalse: [^Win32Errors.E_INVALIDARG]].
	^
	[refInst setField: szFieldName value: value.
	0	"S_OK"] on: MessageNotUnderstood
			do: [:x | Win32Errors.E_INVALIDARG]!

PutFieldNoCopy: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall PutFieldNoCopy(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	^Win32Errors.E_NOTIMPL
!

queryInterface: anInterfaceClass
	"Answer a new interface which supports the specified interface protocol
	(usually a class), or nil if the receiver does not support the interface."

	^self queryInterface: anInterfaceClass ifNone: []
!

queryInterface: anInterfaceClass ifNone: exceptionHandler
	"Answer a new interface pointer which supports the specified interface protocol
	(usually a class). If the receiver does not support the interface, answer the
	result of evaluating the niladic valuable, exceptionHandler."

	| class |
	class := self supportedInterfaces 
		detect: [:ic | ic supportsInterface: anInterfaceClass] 
		ifNone: [^exceptionHandler value].
	^class on: self implementor: self
!

RecordClear: pvExisting
	"Implement the IRecordInfo::RecordClear() method for the UDT described by the receiver.
	Clearing down a record involves freeing any of the fields that need to be finalized, it does
	not include releasing the memory owned by the record.

		HRESULT __stdcall RecordClear(
			[in] void* pvExisting);
	"

	self clear: pvExisting.
	^0 "S_OK"
!

RecordCopy: pvExisting pvNew: pvNew
	"Implement IRecordInfo::RecordCopy() method for the UDT described by the receiver.
	Copy an existing area of memory occupied by a record of the receiver's type to a new
	location. Relies on a correct implementation of #copy which copies any pointed at
	structures which should not be shared.

		HRESULT __stdcall RecordCopy(
			[in] void* pvExisting,
			[out] void* pvNew);
	"

	| ref |
	ref := self fromAddress: pvExisting.
	pvNew 
		replaceFrom: 1
		to: ref byteSize
		with: ref copy detach
		startingAt: 1.
	^0 "S_OK"!

RecordCreate
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver
	Create a new record of the receiver's type in COM task memory.

		void* __stdcall RecordCreate();
	"
	
	^COM.Ole32 coTaskMemAlloc: self byteSize!

RecordCreateCopy: pvSource ppvDest: ppvDest
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver

		HRESULT __stdcall RecordCreateCopy(
			[in] void* pvSource,
			[out] void** ppvDest);
	"

	| pv |
	pv := self RecordCreate.
	ppvDest value: pv.
	pv isNull ifTrue: [^Win32Errors.E_OUTOFMEMORY].
	^self RecordCopy: pvSource pvNew: pv!

RecordDestroy: pvRecord
	"Implement the RecordDestroy() method for the UDT described by the receiver.
	Free up a record of the receiver's type previously created with RecordCreate().

		HRESULT __stdcall RecordDestroy(
			[in] void* pvRecord);
	"

	self RecordClear: pvRecord.
	COM.Ole32 coTaskMemFree: pvRecord.
	^0	"S_OK"!

recordInfo
	"Answer an <IRecordInfo> describing the receiver's structure class.
	Note that we attempt to use the system provided implementation, but as this is frequently 
	unavailable (even for the DX-7 libraries which require extensive use of IRecordInfo)
	we must also be able to implement it ourselves."

	| ti ri |
	ti := self typeInfoIfNone: [].
	ri := ti notNil ifTrue: [ti recordInfoIfNone: []].
	^ri ifNil: [COM.IRecordInfo on: self]!

RecordInit: pvNew
	"Implement the IRecordInfo::RecordInit() method for the UDT described by the receiver.
	Initialize a new empty buffer for a record of the receiver's type. This implementation is the
	simplest possible - it just zeros the whole area.

		HRESULT __stdcall RecordInit(
			[out] void* pvNew);
	"

	self init: pvNew.
	^0 "S_OK"
!

registerSubclasses
	"(Re)Register the receiver's subclasses as record classes with
	their appropriate GUIDs. This is intended as a helper function when
	developing, and has no run-time significance.

		self registerSubclasses
	"

	self initializeRegister.
	self allSubclassesDo: [:c | c register]!

supportedInterfaces
	"Private - Answer the set of interface classes supported by the receiver.
	Implementation Note: We aren't expecting that the implementation of IRecordInfo we provide will actually
	be used for getting and setting the values of fields in UDTs, but mainly provide it to make up for the 
	fact that the one type library we've so far experienced which makes heavy use of UDTs (i.e. the DX-7 VB
	library) does not contain sufficient information (mainly GUIDs) to allow the system implementation of
	IRecordInfo to be constructed on the ITypeInfo's of the various structures defined therein. This suggests
	that VB doesn't use the system implementation itself, as otherwise the type library would be useless. Also
	it seems that DX-7 actually ignores the IRecordInfo (perhaps not surprisingly for a C library), so it is only 
	really needed in order to create VT_RECORD SAFEARRAYs and VARIANTs."

	^{COM.IRecordInfo}!

typeInfo
	"Answer an <ITypeInfo> on the receiver's type information."

	^self typeInfoIfNone: [self error: 'No type information available']!

typeInfoIfNone: exceptionHandler
	"Answer an <ITypeInfo> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| assoc |
	^(assoc := self libraryAndIndex) isNil
		ifTrue: [exceptionHandler value]
		ifFalse: [assoc key typeInfoAt: assoc value]!

typeLib
	"Answer an <ITypeLib> on the receiver's type library,
	or <nil> if the receiver does not have a type library."

	| libAndIndex |
	libAndIndex := self libraryAndIndex.
	^libAndIndex isNil ifFalse: [libAndIndex key]!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	Generally speaking this is the class name."

	^self fullName!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_RECORD! !

!External.Structure class categoriesForMethods!
arrayType!constants!private! !
arrayType:!constants!private! !
classForGUID:ifNone:!enquiries!private! !
clearGuid!accessing!private! !
finalRelease!public!realizing/unrealizing! !
fromAddress:recordInfo:owner:!instance creation!public! !
fromObject:!instance creation!public! !
GetField:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
GetFieldNames:rgBstrNames:!COM Interfaces-IRecordInfo!public! !
GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:!COM Interfaces-IRecordInfo!public! !
GetGuid:!COM Interfaces-IRecordInfo!public! !
GetName:!COM Interfaces-IRecordInfo!public! !
GetSize:!COM Interfaces-IRecordInfo!public! !
GetTypeInfo:!COM Interfaces-IRecordInfo!public! !
initializeRegister!initializing!private! !
IsMatchingType:!COM Interfaces-IRecordInfo!public! !
newSAFEARRAY:!double dispatch!public! !
pointerFieldType!constants!private! !
PutField:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
PutFieldNoCopy:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
queryInterface:!accessing-interfaces!public! !
queryInterface:ifNone:!accessing!accessing-interfaces!public! !
RecordClear:!COM Interfaces-IRecordInfo!public! !
RecordCopy:pvNew:!COM Interfaces-IRecordInfo!public! !
RecordCreate!COM Interfaces-IRecordInfo!public! !
RecordCreateCopy:ppvDest:!COM Interfaces-IRecordInfo!public! !
RecordDestroy:!COM Interfaces-IRecordInfo!public! !
recordInfo!accessing!public! !
RecordInit:!COM Interfaces-IRecordInfo!public! !
registerSubclasses!initializing!public! !
supportedInterfaces!constants!private! !
typeInfo!accessing!public! !
typeInfoIfNone:!accessing!public! !
typeLib!accessing!public! !
typeName!constants!private! !
vt!constants!public! !
!

!External.UInt16 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^UInt16Array!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uint16!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI2! !

!External.UInt16 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.UInt32 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^UInt32Array!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uint32!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI4! !

!External.UInt32 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.UInt64 class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uint64!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI8! !

!External.UInt64 class categoriesForMethods!
typeName!constants!private! !
vt!constants!public! !
!

!External.UInt8 class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^ExternalArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uint8!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI1! !

!External.UInt8 class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.UIntPtr class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^UIntPtrArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uintptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [COM.AutomationConstants.VT_UI8] ifFalse: [COM.AutomationConstants.VT_UI4]! !

!External.UIntPtr class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!External.VOID class methodsFor!

arrayType
	"Private - Answer the <ExternalArray> class to be used to represent C arrays of the receiver's type."

	"Implementation Note: Embedded arrays of <VOID> are not valid, since no size is known,
	however where a field is a void* pointer to a conformant array, we assume it is pointing at
	bytes."

	^ExternalArray!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_VOID! !

!External.VOID class categoriesForMethods!
arrayType!constants!private! !
typeName!constants!private! !
vt!constants!public! !
!

!Kernel.SmalltalkLocale methodsFor!

displayCURRENCY: aCURRENCY on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <CURRENCY> argument that a user in this <Locale> might expect to see."

	aCURRENCY value displayOn: aWriteStream!

displayDECIMAL: aDECIMAL on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <DECIMAL>, aDecimal, that a user in this <Locale> might expect to see."

	aDECIMAL value displayOn: aWriteStream!

variantBool: aBoolean
	^aBoolean class name! !

!Kernel.SmalltalkLocale categoriesForMethods!
displayCURRENCY:on:!displaying!public! !
displayDECIMAL:on:!displaying!public! !
variantBool:!constants!public! !
!

!OS.AbstractWindowsLocale methodsFor!

boolFormat
	"Answer an <Array> of two <String>s, being the representations for false and true in this Locale."

	^{self variantBool: false. self variantBool: true}!

displayCURRENCY: aCURRENCY on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <CURRENCY> argument that a user in this <Locale> might expect to see."

	| bstr |
	bstr := COM.BSTR new.
	COM.OleAut32
		varBstrFromCy: aCURRENCY
		lcid: self lcid
		dwFlags: 0
		pbstrOut: bstr.
	bstr
		displayOn: aWriteStream;
		free!

displayDECIMAL: aDECIMAL on: aWriteStream
	"Append to the <puttableStream> argument, aWriteStream, a <String> whose characters are a representation of the <DECIMAL>, aDecimal, that a user in this <Locale> might expect to see."

	| bstr |
	bstr := COM.BSTR new.
	COM.OleAut32
		varBstrFromDec: aDECIMAL
		lcid: self lcid
		dwFlags: 0
		pbstrOut: bstr.
	bstr
		displayOn: aWriteStream;
		free!

getVariantBoolString: anInteger
	| bstr str |
	bstr := COM.BSTR new.
	COM.OleAut32
		varBstrFromBool: anInteger
		lcid: self lcid
		dwFlags: COM.AutomationConstants.VARIANT_LOCALBOOL
		pbstrOut: bstr.
	str := bstr asUtf8String.
	bstr free.
	^str!

variantBool: aBoolean
	^info at: aBoolean class name
		ifAbsentPutClean: 
			[self getVariantBoolString: (aBoolean
						ifTrue: [COM.AutomationConstants.VARIANT_TRUE]
						ifFalse: [COM.AutomationConstants.VARIANT_FALSE])]! !

!OS.AbstractWindowsLocale categoriesForMethods!
boolFormat!constants!public! !
displayCURRENCY:on:!displaying!public! !
displayDECIMAL:on:!displaying!public! !
getVariantBoolString:!constants!public! !
variantBool:!constants!public! !
!

!OS.COM.BSTR methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: Int16!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !

!OS.COM.BSTR categoriesForMethods!
asSAFEARRAY!converting!public! !
asVariant!converting!public! !
!

!OS.COM.BSTR class methodsFor!

fromObject: anObject
	^self fromString: anObject!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY
		length: length
		vt: self vt
		elementClass: self!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_BSTR! !

!OS.COM.BSTR class categoriesForMethods!
fromObject:!instance creation!public! !
newSAFEARRAY:!double dispatch!public! !
typeName!constants!private! !
vt!constants!public! !
!

!OS.COM.CLSID class methodsFor!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY
		length: length
		vt: self vt
		elementClass: self!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AutomationConstants.VT_CLSID
! !

!OS.COM.CLSID class categoriesForMethods!
newSAFEARRAY:!double dispatch!public! !
vt!constants!public! !
!

!OS.COM.IErrorInfo class methodsFor!

fromEXCEPINFO: excepInfo guid: id
	"Answer a new instance of the receiver on a system extended error object
	with details from the <EXCEPINFO> structure, excepInfo."

	^(ICreateErrorInfo fromEXCEPINFO: excepInfo guid: id) errorInfo!

source: sourceString description: descriptionString helpContext: anInteger helpFile: helpFilePath guid: aGUID
	"Answer a new instance of the receiver encapsulating all of the specified details.
		ice := self source: 'Dolphin' description: 'It is all going horribly wrong' helpContext: 1 helpFile: nil guid: GUID newUnique.
	"

	| ice |
	ice := ICreateErrorInfo new.
	ice SetSource: sourceString.
	ice SetDescription: descriptionString.
	ice SetHelpContext: anInteger.
	ice SetHelpFile: helpFilePath.
	ice SetGuid: aGUID.
	^ice errorInfo! !

!OS.COM.IErrorInfo class categoriesForMethods!
fromEXCEPINFO:guid:!instance creation!public! !
source:description:helpContext:helpFile:guid:!instance creation!public! !
!

!OS.COM.Interface methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self class errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the object on which the receiver is an interface."

	^(self queryInterface: IProvideClassInfo)
		ifNil: [self class coclassTypeInfoIfNone: [^exceptionHandler value]]
		ifNotNil: 
			[:ipc |
			[TypeInfoAnalyzer onTypeInfo: ipc getClassInfo] on: HRESULTError
				do: [:ex | ^exceptionHandler value]]!

typeInfo
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^self typeInfoIfNone: [self class errorNoTypeInfo]!

typeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^(self coclassTypeInfoIfNone: [^exceptionHandler value]) defaultInterface! !

!OS.COM.Interface categoriesForMethods!
coclassTypeInfo!accessing!public! !
coclassTypeInfoIfNone:!accessing!public! !
typeInfo!accessing!public! !
typeInfoIfNone:!accessing!public! !
!

!OS.COM.Interface class methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler 
	"Answer any type information that exists for the object on which the receiver is the default interface.
	This link can only be made if the #clsid method is defined and a type library with the relevant
	information is available."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [tlb typeInfoForGuid: self clsid ifNone: [^exceptionHandler value]]!

errorNoTypeInfo
	"Private - Raise an exception to the effect that the receiver has no associated
	type information available."

	^self error: 'No type information available.'!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^anObject queryInterface: self!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver."

	^SAFEARRAY length: length interfaceClass: self!

registerDispinterface: anIID
	"Register the specified <IID> as another dispinterface (i.e. an IID implemented by IDispatch)."

	InterfaceClasses at: anIID put: IDispatch!

typeInfoIfNone: exceptionHandler
	"Answer an <AXInterfaceTypeAnalyzer> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [(tlb typeInfoForGuid: self guid ifNone: [^exceptionHandler value]) asImplType]!

typeLib
	"Answer an <AXTypeLibraryAnalyzer> on the receiver's type library,
	or nil if the receiver does not have a type library."

	^typeLib! !

!OS.COM.Interface class categoriesForMethods!
coclassTypeInfo!accessing!public! !
coclassTypeInfoIfNone:!accessing!public! !
errorNoTypeInfo!exceptions!private! !
fromObject:!instance creation!public! !
newSAFEARRAY:!double dispatch!public! !
registerDispinterface:!adding!public! !
typeInfoIfNone:!accessing!public! !
typeLib!accessing!public! !
!

!OS.COM.IUnknown methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver."

	^VARIANT fromUnknown: self! !

!OS.COM.IUnknown categoriesForMethods!
asVariant!converting!public! !
!

!OS.COM.IUnknown class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AutomationConstants.VT_UNKNOWN! !

!OS.COM.IUnknown class categoriesForMethods!
vt!constants!public! !
!

!OS.COM.OLEAutLibrary methodsFor!

clearCustData: pCustData
	"WINOLEAUTAPI_(void) ClearCustData(LPCUSTDATA pCustData);"

	<stdcall: void ClearCustData CUSTDATA*>
	^self invalidCall: _failureCode!

createErrorInfo: pperrinfo
	"Loads _and registers_ a type library from the specified path.

		HRESULT CreateErrorInfo(
			ICrateErrorInfo**		pperrinfo
		)"

	<stdcall: hresult CreateErrorInfo lppvoid>
	^self invalidCall: _failureCode!

getRecordInfoFromTypeInfo: pTypeInfo ppRecInfo: ppRecInfo
	"Create a RecordInfo object on the specified ITypeInfo, and answer an <IRecordInfo> on it.
		HRESULT GetRecordInfoFromTypeInfo( 
			ITypeInfo  pTypeInfo,  
			IRecordInfo** ppRecInfo);"

	"Implementation Note: Answer an integer HRESULT code rather than raising an exception
	as it is most unusual for this call to succeed it would seem!!"

	<stdcall: int32 GetRecordInfoFromTypeInfo ITypeInfo* IRecordInfo**>
	^self invalidCall: _failureCode!

lHashValOfNameSys: syskind lcid: lcid szName: szNem
	"Calculate the hash value of a string.

		ULONG LHashValOfNameSys(
		SYSKIND syskind <>, 
		LCID lcid <>, 
		const OLECHAR FAR* szName <> ); 
		)"

	<stdcall: uint32 LHashValOfNameSys int32 int32 lpwstr>
	^self invalidCall: _failureCode!

loadRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid pptlib: pptlib
	"Load a type library from the registry entries corresponding to the specified LIBID,
	version information, and LCID.

		HRESULT LoadRegTypeLib(      REFGUID rguid, 
			unsigned short wVerMajor, 
			unsigned short wVerMinor, 
			LCID lcid, 
			ITypeLib FAR* FAR* pptlib 
		); "

	<stdcall: hresult LoadRegTypeLib guid* uint16 uint16 uint32 lppvoid>
	^self invalidCall: _failureCode!

loadTypeLib: szFileName pptlib: lplptlib
	<stdcall: hresult LoadTypeLib lpwstr lppvoid>
	^self invalidCall: _failureCode!

loadTypeLibEx: szFileName regkind: regkind pptlib: lplptlib
	"Loads, and optionally registers, a type library from the specified path.

		HRESULT LoadTypeLibEx(
			OLECHAR FAR*		szFileName,
			REGKIND				regkind,
			ITypeLib FAR* FAR*	pptlib
		)"

	<stdcall: hresult LoadTypeLibEx lpwstr int32 lppvoid>
	^self invalidCall: _failureCode!

oleCreateFontIndirect: pFontDesc riid: riid ppvObj: ppvObj
	"Create an OLE font object matching the supplied <FONTDESC>. 

		STDAPI OleCreateFontIndirect(
			FONTDESC* pFontDesc,
			REFIID riid,
			VOID** ppvObj);
 	"

	<stdcall: hresult OleCreateFontIndirect FONTDESC* guid* void**>
	^self invalidCall: _failureCode!

queryPathOfRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid lpbstrPathName: lpbstrPathName
	"Determine the path of a registered type library.
	Implementation Note: It is quite a common occurrence that the library not be registered
	on a particular machine, and using this function is the best way to find that out, therefore
	we define the return code as an integer rather than an HRESULT to avoid getting an
	exception.

	HRESULT QueryPathOfRegTypeLib(
		REFGUID guid,
		unsigned short wVerMajor,
		unsigned short wVerMinor,
		LCID lcid,
		LPBSTR lpbstrPathName);"

	<stdcall: int32 QueryPathOfRegTypeLib guid* uint16 uint16 uint32 bstr*>
	^self invalidCall: _failureCode!

registerTypeLib: ptlib wszFullPath: wszFullPath wszHelpDir: wszHelpDir
	"Invoke the RegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Adds information about a type library to the system registry

		HRESULT __stdcall RegisterTypeLib(
			ITypeLib* ptlib,
			LPWSTR wszFullPath,
			LPWSTR wszHelpDir);"

	<stdcall: int32 RegisterTypeLib ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

registerTypeLibForUser: ptlib szFullPath: szFullPath szHelpDir: szHelpDir
	"Invoke the RegisterTypeLibForUser() function of the module wrapped by the receiver.
	Helpstring: Registers a type library for use by the calling user.

		HRESULT __stdcall RegisterTypeLibForUser(
			ITypeLib* ptlib,
			LPWSTR szFullPath,
			LPWSTR szHelpDir);"

	<stdcall: hresult RegisterTypeLibForUser ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

safeArrayAccessData: psa ppvData: ppvData
	"Increment the lock count of an array, and return a pointer to the array data
	through the <ExternalAddress>, ppvData.

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayAccessData SAFEARRAY* lppvoid>
	^self invalidCall: _failureCode!

safeArrayCopy: psa ppsaout: ppsaout
	"Create a copy of a SAFEARRAY.

		HRESULT SafeArrayCopy( 
			SAFEARRAY *  psa,          
			SAFEARRAY **  ppsaOut  
		);"

	<stdcall: hresult SafeArrayCopy SAFEARRAY* SAFEARRAY**>
	^self invalidCall: _failureCode!

safeArrayCreateEx: vt cDims: cDims rgsabound: rgsabound pvExtra: anExternalAddressOfNil
	<stdcall: SAFEARRAY* SafeArrayCreateEx uint16 int32 SAFEARRAYBOUND* lpvoid>
	^self invalidCall: _failureCode!

safeArrayCreateVectorEx: vt lLbound: lLbound cElements: cElements pvExtra: pvExtra
	"Create a one-dimensional SAFEARRAY.

		SAFEARRAY SafeArrayCreateVectorEx( 
			VARTYPE  vt,             
			long  lLbound,           
			unsigned int  cElements ,
			LPVOID pvExtra
		);"

	<stdcall: SAFEARRAY* SafeArrayCreateVectorEx int16 int32 uint32 lpvoid>
	^self invalidCall: _failureCode!

safeArrayDestroy: psa
	"Tidy away a SAFEARRAY. May involve releasing objects, etc.

		HRESULT SafeArrayDestroy(SAFEARRAY FAR*  psa);
	"

	<stdcall: int32 SafeArrayDestroy SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetDim: psa
	"Answer the number of dimensions in a SAFEARRAY.

		UINT SafeArrayGetDim(SAFEARRAY FAR*  psa);
	"

	<stdcall: uint32 SafeArrayGetDim SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetElement: psa rgIndices: rgIndices pv: pv
	"Answer an individual element of the receiver as identified by the array
	of indices, rgIndices, through the buffer, pv.

		HRESULT SafeArrayGetElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayGetElement SAFEARRAY* int32* lppvoid>
	^self invalidCall: _failureCode!

safeArrayGetIID: psa pguid: pguid
	"Get the IID of the FADF_HAVEIID safe array, psa, storing it 
	into the output parameter, pvt.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			GUID* pguid
		);"

	<stdcall: hresult SafeArrayGetIID SAFEARRAY* guid*>
	^self invalidCall: _failureCode!

safeArrayGetLBound: psa nDim: nDim plLbound: plLbound
	"Answer the lower bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <Int32> parameter, plLbound..

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayGetLBound SAFEARRAY* uint32 int32*>
	^self invalidCall: _failureCode!

safeArrayGetRecordInfo: aSAFEARRAY prinfo: anIRecordInfo
	<stdcall: hresult SafeArrayGetRecordInfo SAFEARRAY* IRecordInfo**>
	^self invalidCall: _failureCode!

safeArrayGetUBound: psa nDim: nDim plUbound: plUbound
	"Answer the upper bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <Int32> parameter, plUbound..

		HRESULT SafeArrayGetUBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plUbound
		);"

	<stdcall: hresult SafeArrayGetUBound SAFEARRAY* uint32 int32*>
	^self invalidCall: _failureCode!

safeArrayGetVartype: psa pvt: pvt
	"Get the VARTYPE of the safe array, psa, storing it into the output parameter, pvt.

		HRESULT SafeArrayGetVartype(
			SAFEARRAY FAR* psa,
			VARTYPE* vt
		);"

	<stdcall: hresult SafeArrayGetVartype SAFEARRAY* uint16*>
	^self invalidCall: _failureCode!

safeArrayPtrOfIndex: aSAFEARRAY rgIndices: anInt32Array ppvData: anExternalAddress
	<stdcall: hresult SafeArrayPtrOfIndex SAFEARRAY* int32* lppvoid>
	^self invalidCall: _failureCode!

safeArrayPutElement: psa rgIndices: rgIndices pv: pv
	"Replease the individual element of the receiver as identified by the array
	of indices, rgIndices, with the contents of the buffer pointed at by the
	<externalAddress>, pv.

		HRESULT SafeArrayPutElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayPutElement SAFEARRAY* int32* lpvoid>
	^self invalidCall: _failureCode!

safeArrayRedim: psa psaboundNew: psaboundNew
	"Resize the least significant bound of the SAFEARRAY, psa,
	to the lower bound and element count specified in the 
	SAFEARRAYBOUND, psaboundNew.

		HRESULT SafeArrayRedim(
			SAFEARRAY FAR* psa,
			SAFEARRAYBOUND psaboundNew
		);"

	<stdcall: hresult SafeArrayRedim SAFEARRAY* SAFEARRAYBOUND*>
	^self invalidCall: _failureCode!

safeArraySetIID: psa pguid: pguid
	"Set the IID of the FADF_HAVEIID safe array, psa.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			REFGUID pguid
		);"

	<stdcall: hresult SafeArraySetIID SAFEARRAY* REFGUID>
	^self invalidCall: _failureCode!

safeArrayUnaccessData: psa
	"Reverse a previous SafeArrayAccessData.

		HRESULT SafeArrayUnaccessData(SAFEARRAY FAR*  psa);
	"

	<stdcall: hresult SafeArrayUnaccessData SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayUnlock: psa
	<stdcall: hresult SafeArrayUnlock SAFEARRAY*>
	^self invalidCall: _failureCode!

setErrorInfo: dwReserved perrinfo: perrinfo
	"Set the current <IErrorInfo> pointer for the calling thread.

		HRESULT SetErrorInfo(
			DWORD			dwReserved,
			IErrorInfo*		perrinfo
		)"

	<stdcall: hresult GetErrorInfo uint32 IErrorInfo*>
	^self invalidCall: _failureCode!

systemTimeToVariantTime: lpSystemTime pvtime: pvtime
	"Convert the <SYSTEMTIME>, lpSystemTime, to an OLE format <DATE>,
	answering whether the conversion succeeded.

		INT SystemTimeToVariantTime(
			SYSTEMTIME  lpSystemTime  
			double  *pvtime           
		);"

	<stdcall: bool SystemTimeToVariantTime SYSTEMTIME* double*>
	^self invalidCall: _failureCode!

unRegisterTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid syskind: syskind
	"Invoke the UnRegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Removes type library information from the system registry.

		HRESULT __stdcall UnRegisterTypeLib(
			GUID* rguid,
			unsigned short wVerMajor,
			unsigned short wVerMinor,
			unsigned long lcid,
			SYSKIND syskind);"

	<stdcall: hresult UnRegisterTypeLib guid* uint16 uint16 uint32 int32>
	^self invalidCall: _failureCode!

varBstrFromBool: boolIn lcid: lcid dwFlags: dwFlags pbstrOut: pbstrOut
	"HRESULT VarBstrFromBool(
		  VARIANT_BOOL boolIn,
		  LCID         lcid,
		  ULONG        dwFlags,
		  BSTR         *pbstrOut
		);
	"

	<stdcall: hresult VarBstrFromBool int16 uint32 uint32 bstr*>
	^self invalidCall: _failureCode!

varBstrFromCy: pcyIn lcid: lcid dwFlags: dwFlags pbstrOut: pbstrOut
	<stdcall: hresult VarBstrFromCy CURRENCY uint32 uint32 bstr*>
	^self invalidCall: _failureCode!

varBstrFromDec: pdecIn lcid: lcid dwFlags: dwFlags pbstrOut: pbstrOut
	<stdcall: hresult VarBstrFromDec DECIMAL* uint32 uint32 bstr*>
	^self invalidCall: _failureCode!

varCmp: pvarLeft pvarRight: pvarRight lcid: lcid dwFlags: dwFlags
	"Answer a comparison result between the two VARIANT arguments.

		HRESULT VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);
	"

	<stdcall: hresult VarCmp variant* variant* uint32 uint32>
	^self invalidCall: _failureCode!

varDateFromStr: strIn lcid: lcid dwFlags: dwFlags pdateOut: aFloat
	"Convert from a string date representation to the OLE Automation date type,
	according to the users regional settings.

		HRESULT VarDateFromStr(OLECHAR* strIn, LCID lcid, DWORD dwFlags, DATE* pdateOut);"

	<stdcall: hresult VarDateFromStr lpwstr uint32 uint32 lpvoid>
	^self invalidCall: _failureCode!

variantChangeTypeEx: pvargDest pvarSrc: pvarSrc lcid: lcid wFlags: wFlags vt: vt
	"Converts a variant from one type to another, using an LCID.

		HRESULT VariantChangeTypeEx(
			VARIANTARG       	*pvargDest,
			const VARIANTARG *pvarSrc,
			LCID             		lcid,
			USHORT           	wFlags,
			VARTYPE          	vt
		);"

	<stdcall: hresult VariantChangeTypeEx variant* variant* uint32 uint16 int16>
	^self invalidCall: _failureCode!

variantClear: pvarg
	"Free a VARIANT, performing any special clean up  required (such as 
	Release()ing an IUnknown/IDispatch).
	Implementation Note: As this is used to finalize VARIANTs and there
	is little we can do about a failure, we return an integer error code
	rather than automatically raising an exception.

		HRESULT VariantClear(VARIANTARG FAR* pvarg)"

	<stdcall: int32 VariantClear variant*>
	^self invalidCall: _failureCode!

variantCopy: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest.

		HRESULT VariantCopy(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopy variant* variant*>
	^self invalidCall: _failureCode!

variantCopyInd: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest,
	where the copy is guaranteed not to be a VT_BYREF.

		HRESULT VariantCopyInd(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopyInd variant* variant*>
	^self invalidCall: _failureCode!

variantInit: pvarg
	"Initialize a VARIANT - sets the type tag to VT_EMPTY, but does not zero the
	data part of the union.

		void VariantInit(VARIANTARG FAR* pvarg)"

	<stdcall: void VariantInit variant*>
	^self invalidCall: _failureCode!

variantTimeToSystemTime: vtime lpSystemTime: lpSystemTime
	"Convert the OLE format date-time, vtime, to a SYSTEMTIME,
	answering whether the conversion succeeded.

		INT VariantTimeToSystemTime( 
			double  vtime,              
			LPSYSTEMTIME  lpSystemTime  
		);"

	<stdcall: bool VariantTimeToSystemTime double SYSTEMTIME*>
	^self invalidCall: _failureCode! !

!OS.COM.OLEAutLibrary categoriesForMethods!
clearCustData:!Automation Functions-Error Handling API!public! !
createErrorInfo:!Automation Functions-Error Handling API!public! !
getRecordInfoFromTypeInfo:ppRecInfo:!OLE Functions-OLE!public! !
lHashValOfNameSys:lcid:szName:!Automation Functions-Type Compilation And Library!primitives!public! !
loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:!Automation Functions-Type Compilation And Library!public! !
loadTypeLib:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
loadTypeLibEx:regkind:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
oleCreateFontIndirect:riid:ppvObj:!OLE Functions-OLE!public! !
queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:!Automation Functions-Type Compilation And Library!public! !
registerTypeLib:wszFullPath:wszHelpDir:!Automation Functions-Type Compilation And Library!public! !
registerTypeLibForUser:szFullPath:szHelpDir:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
safeArrayAccessData:ppvData:!Automation Functions-Array Manipulation!public! !
safeArrayCopy:ppsaout:!Automation Functions-Array Manipulation!public! !
safeArrayCreateEx:cDims:rgsabound:pvExtra:!Automation Functions-Array Manipulation!public! !
safeArrayCreateVectorEx:lLbound:cElements:pvExtra:!Automation Functions-Array Manipulation!public! !
safeArrayDestroy:!Automation Functions-Array Manipulation!public! !
safeArrayGetDim:!Automation Functions-Array Manipulation!public! !
safeArrayGetElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
safeArrayGetIID:pguid:!Automation Functions-Array Manipulation!public! !
safeArrayGetLBound:nDim:plLbound:!Automation Functions-Array Manipulation!public! !
safeArrayGetRecordInfo:prinfo:!Automation Functions-Array Manipulation!public! !
safeArrayGetUBound:nDim:plUbound:!Automation Functions-Array Manipulation!public! !
safeArrayGetVartype:pvt:!Automation Functions-Array Manipulation!public! !
safeArrayPtrOfIndex:rgIndices:ppvData:!Automation Functions-Array Manipulation!public! !
safeArrayPutElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
safeArrayRedim:psaboundNew:!Automation Functions-Array Manipulation!public! !
safeArraySetIID:pguid:!Automation Functions-Array Manipulation!public! !
safeArrayUnaccessData:!Automation Functions-Array Manipulation!public! !
safeArrayUnlock:!Automation Functions-Array Manipulation!public! !
setErrorInfo:perrinfo:!Automation Functions-Error Handling API!public! !
systemTimeToVariantTime:pvtime:!Automation Functions-Variant Manipulation!public! !
unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
varBstrFromBool:lcid:dwFlags:pbstrOut:!Automation Functions-Variant Manipulation!public! !
varBstrFromCy:lcid:dwFlags:pbstrOut:!Automation Functions-Variant Manipulation!public! !
varBstrFromDec:lcid:dwFlags:pbstrOut:!Automation Functions-Variant Manipulation!public! !
varCmp:pvarRight:lcid:dwFlags:!Automation Functions-Variant Manipulation!public! !
varDateFromStr:lcid:dwFlags:pdateOut:!Automation Functions-Variant Manipulation!public! !
variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
variantClear:!Automation Functions-Variant Manipulation!public! !
variantCopy:pvargSrc:!Automation Functions-Variant Manipulation!public! !
variantCopyInd:pvargSrc:!Automation Functions-Variant Manipulation!public! !
variantInit:!Automation Functions-Variant Manipulation!public! !
variantTimeToSystemTime:lpSystemTime:!Automation Functions-Variant Manipulation!public! !
!

!OS.FILETIME class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_FILETIME! !

!OS.FILETIME class categoriesForMethods!
vt!constants!public! !
!

!OS.HRESULT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#hresult!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^COM.AutomationConstants.VT_ERROR! !

!OS.HRESULT class categoriesForMethods!
typeName!constants!private! !
vt!constants!private! !
!

!OS.SYSTEMTIME methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	| vtime |
	vtime := COM.DATE new.
	COM.OleAut32 systemTimeToVariantTime: self pvtime: vtime.
	^vtime!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)"

	^COM.VARIANT fromDATE: self asFloat! !

!OS.SYSTEMTIME categoriesForMethods!
asFloat!converting!public! !
asVariant!converting!public! !
!

!OS.SYSTEMTIME class methodsFor!

fromDATE: aFloat
	| systime |
	systime := self new.
	COM.OleAut32 variantTimeToSystemTime: aFloat lpSystemTime: systime.
	^systime! !

!OS.SYSTEMTIME class categoriesForMethods!
fromDATE:!public! !
!

"End of package definition"!

