| package |
package := Package name: 'ActiveX Automation'.
package paxVersion: 2.1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk ActiveX Automation Support.
Copyright (c) Object Arts Ltd, 2000-2003.

This package is the basis of Dolphin''s extensive Active-X Automation support (formally called OLE Automation). It includes classes to enable the use of Dolphin as both an Automation client (or controller) and server. In here you will find classes to support the familar Automation types such as VARIANTs, BSTRs and SAFEARRAYs. This package also includes extensive support for extracting information from type libraries, with this being further augmented by the ''ActiveX Automation Development'' package, which uses the type-library analyzer to generate wrapper classes for COM objects, etc.

'.

package basicPackageVersion: '6.1'.

package basicScriptAt: #postinstall put: 'VMLibrary default
	registryAt: #VARIANT put: COM.VARIANT;
	registryAt: #IDispatch put: COM.IDispatch.

"Register all the existing ExternalStructures so that they can support IRecordInfo"
External.Structure registerSubclasses.'.
package basicScriptAt: #postuninstall put: 'External.Structure classPool at: ''RecordClasses'' put: nil.'.

package setClassNames: #(
	#{OS.COM.AbstractDispatchImplementation}
	#{OS.COM.AbstractELEMDESC}
	#{OS.COM.APIInfoAnalyzer}
	#{OS.COM.ARRAYDESC}
	#{OS.COM.AutomationConstants}
	#{OS.COM.AutomationErrors}
	#{OS.COM.CURRENCY}
	#{OS.COM.CUSTDATA}
	#{OS.COM.CUSTDATAITEM}
	#{OS.COM.DATE}
	#{OS.COM.DECIMAL}
	#{OS.COM.DispatchFunction}
	#{OS.COM.DISPPARAMS}
	#{OS.COM.DualInterfaceImplementation}
	#{OS.COM.ELEMDESC}
	#{OS.COM.FONTDESC}
	#{OS.COM.ForwardingDualInterfaceImplementation}
	#{OS.COM.FUNCDESC}
	#{OS.COM.ICreateErrorInfo}
	#{OS.COM.IDispatch}
	#{OS.COM.IDLDESC}
	#{OS.COM.IEnumVARIANT}
	#{OS.COM.InterfaceTypeAnalyzer}
	#{OS.COM.IPerPropertyBrowsing}
	#{OS.COM.IProvideClassInfo}
	#{OS.COM.IProvideClassInfo2}
	#{OS.COM.IRecordInfo}
	#{OS.COM.ITypeComp}
	#{OS.COM.ITypeInfo}
	#{OS.COM.ITypeInfo2}
	#{OS.COM.ITypeLib}
	#{OS.COM.ITypeLib2}
	#{OS.COM.LPBSTR}
	#{OS.COM.MemberDesc}
	#{OS.COM.PARAMDESC}
	#{OS.COM.PARAMDESCEX}
	#{OS.COM.Record}
	#{OS.COM.SAFEARRAY}
	#{OS.COM.SAFEARRAYBOUND}
	#{OS.COM.StructureTypeAnalyzer}
	#{OS.COM.TKindAliasAnalyzer}
	#{OS.COM.TKindCoclassAnalyzer}
	#{OS.COM.TKindDispatchAnalyzer}
	#{OS.COM.TKindEnumAnalyzer}
	#{OS.COM.TKindInterfaceAnalyzer}
	#{OS.COM.TKindModuleAnalyzer}
	#{OS.COM.TKindRecordAnalyzer}
	#{OS.COM.TKindUnionAnalyzer}
	#{OS.COM.TLIBATTR}
	#{OS.COM.TYPEATTR}
	#{OS.COM.TYPEDESC}
	#{OS.COM.TypeGenerationFlags}
	#{OS.COM.TypeInfoAnalyzer}
	#{OS.COM.TypeInfoObject}
	#{OS.COM.TypeInfoStructure}
	#{OS.COM.TypeLibDocumentation}
	#{OS.COM.TypeLibraryAnalyzer}
	#{OS.COM.VARDESC}
	#{OS.COM.VARIANT}
	#{OS.COM.VARIANT_BOOL}
	#{OS.COM.VariantEnumerator}
).

package setMethodNames: #(
	#(#{Core.Boolean} #asVariant)
	#(#{Core.ByteArray} #asSAFEARRAY)
	#(#{Core.ByteArray class} #typeName)
	#(#{Core.Character} #asVariant)
	#(#{Core.Collection} #asSAFEARRAY)
	#(#{Core.Collection} #asVariant)
	#(#{Core.DateAndTime} #asFloat)
	#(#{Core.DateAndTime} #asVariant)
	#(#{Core.Float} #asVariant)
	#(#{Core.Fraction} #asVariant)
	#(#{Core.GUID class} #typeName)
	#(#{Core.Integer} #asVariant)
	#(#{Core.LargeInteger} #asVariant)
	#(#{Core.Locale} #variantBool:)
	#(#{Core.ScaledDecimal} #asVariant)
	#(#{Core.SmallInteger} #asVariant)
	#(#{Core.String} #asVariant)
	#(#{Core.String class} #pointerType)
	#(#{Core.String class} #typeName)
	#(#{Core.String class} #vt)
	#(#{Core.UndefinedObject} #asVariant)
	#(#{Core.UndefinedObject class} #typeName)
	#(#{Core.UndefinedObject class} #vt)
	#(#{Core.Utf16String class} #pointerType)
	#(#{Core.Utf16String class} #typeName)
	#(#{Core.Utf16String class} #vt)
	#(#{External.Address class} #typeName)
	#(#{External.Address class} #vt)
	#(#{External.BOOL class} #typeName)
	#(#{External.BOOLEAN class} #typeName)
	#(#{External.BYTE class} #typeName)
	#(#{External.BYTE class} #vt)
	#(#{External.DOUBLE class} #typeName)
	#(#{External.DOUBLE class} #vt)
	#(#{External.DWORD class} #typeName)
	#(#{External.DWORD class} #vt)
	#(#{External.ExternalArray} #asSAFEARRAY)
	#(#{External.ExternalArray} #asVariant)
	#(#{External.ExternalArray class} #vt)
	#(#{External.FLOAT class} #typeName)
	#(#{External.FLOAT class} #vt)
	#(#{External.Handle class} #typeName)
	#(#{External.INT_PTR class} #typeName)
	#(#{External.INT_PTR class} #vt)
	#(#{External.INTEGER class} #typeName)
	#(#{External.INTEGER class} #vt)
	#(#{External.LPVOID class} #typeName)
	#(#{External.LPVOID class} #vt)
	#(#{External.QWORD class} #vt)
	#(#{External.SBYTE class} #typeName)
	#(#{External.SBYTE class} #vt)
	#(#{External.SCALAR} #asVariant)
	#(#{External.SDWORD class} #typeName)
	#(#{External.SDWORD class} #vt)
	#(#{External.Structure} #asVariant)
	#(#{External.Structure} #recordInfo)
	#(#{External.Structure} #vt)
	#(#{External.Structure class} #classForGUID:ifNone:)
	#(#{External.Structure class} #clearGuid)
	#(#{External.Structure class} #finalRelease)
	#(#{External.Structure class} #fromAddress:recordInfo:owner:)
	#(#{External.Structure class} #fromObject:)
	#(#{External.Structure class} #GetField:szFieldName:pvarField:)
	#(#{External.Structure class} #GetFieldNames:rgBstrNames:)
	#(#{External.Structure class} #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:)
	#(#{External.Structure class} #GetGuid:)
	#(#{External.Structure class} #GetName:)
	#(#{External.Structure class} #GetSize:)
	#(#{External.Structure class} #GetTypeInfo:)
	#(#{External.Structure class} #initializeRegister)
	#(#{External.Structure class} #IsMatchingType:)
	#(#{External.Structure class} #newSAFEARRAY:)
	#(#{External.Structure class} #pointerFieldType)
	#(#{External.Structure class} #PutField:pvData:szFieldName:pvarField:)
	#(#{External.Structure class} #PutFieldNoCopy:pvData:szFieldName:pvarField:)
	#(#{External.Structure class} #queryInterface:)
	#(#{External.Structure class} #queryInterface:ifNone:)
	#(#{External.Structure class} #RecordClear:)
	#(#{External.Structure class} #RecordCopy:pvNew:)
	#(#{External.Structure class} #RecordCreate)
	#(#{External.Structure class} #RecordCreateCopy:ppvDest:)
	#(#{External.Structure class} #RecordDestroy:)
	#(#{External.Structure class} #recordInfo)
	#(#{External.Structure class} #RecordInit:)
	#(#{External.Structure class} #registerSubclasses)
	#(#{External.Structure class} #supportedInterfaces)
	#(#{External.Structure class} #typeInfo)
	#(#{External.Structure class} #typeInfoIfNone:)
	#(#{External.Structure class} #typeLib)
	#(#{External.Structure class} #typeName)
	#(#{External.Structure class} #vt)
	#(#{External.SWORD class} #typeName)
	#(#{External.SWORD class} #vt)
	#(#{External.UINT_PTR class} #typeName)
	#(#{External.UINT_PTR class} #vt)
	#(#{External.VOID class} #typeName)
	#(#{External.VOID class} #vt)
	#(#{External.WORD class} #typeName)
	#(#{External.WORD class} #vt)
	#(#{Kernel.SmalltalkLocale} #variantBool:)
	#(#{OS.COM.BSTR} #asSAFEARRAY)
	#(#{OS.COM.BSTR} #asVariant)
	#(#{OS.COM.BSTR class} #fromObject:)
	#(#{OS.COM.BSTR class} #newSAFEARRAY:)
	#(#{OS.COM.BSTR class} #typeName)
	#(#{OS.COM.BSTR class} #vt)
	#(#{OS.COM.CLSID class} #newSAFEARRAY:)
	#(#{OS.COM.CLSID class} #vt)
	#(#{OS.COM.IErrorInfo class} #fromEXCEPINFO:guid:)
	#(#{OS.COM.IErrorInfo class} #source:description:helpContext:helpFile:guid:)
	#(#{OS.COM.Interface} #coclassTypeInfo)
	#(#{OS.COM.Interface} #coclassTypeInfoIfNone:)
	#(#{OS.COM.Interface} #typeInfo)
	#(#{OS.COM.Interface} #typeInfoIfNone:)
	#(#{OS.COM.Interface class} #coclassTypeInfo)
	#(#{OS.COM.Interface class} #coclassTypeInfoIfNone:)
	#(#{OS.COM.Interface class} #errorNoTypeInfo)
	#(#{OS.COM.Interface class} #fromObject:)
	#(#{OS.COM.Interface class} #newSAFEARRAY:)
	#(#{OS.COM.Interface class} #registerDispinterface:)
	#(#{OS.COM.Interface class} #typeInfoIfNone:)
	#(#{OS.COM.Interface class} #typeLib)
	#(#{OS.COM.IUnknown} #asVariant)
	#(#{OS.COM.IUnknown class} #vt)
	#(#{OS.COM.OLEAutLibrary} #clearCustData:)
	#(#{OS.COM.OLEAutLibrary} #createErrorInfo:)
	#(#{OS.COM.OLEAutLibrary} #getRecordInfoFromTypeInfo:ppRecInfo:)
	#(#{OS.COM.OLEAutLibrary} #lHashValOfNameSys:lcid:szName:)
	#(#{OS.COM.OLEAutLibrary} #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #loadTypeLib:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #loadTypeLibEx:regkind:pptlib:)
	#(#{OS.COM.OLEAutLibrary} #oleCreateFontIndirect:riid:ppvObj:)
	#(#{OS.COM.OLEAutLibrary} #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:)
	#(#{OS.COM.OLEAutLibrary} #registerTypeLib:wszFullPath:wszHelpDir:)
	#(#{OS.COM.OLEAutLibrary} #registerTypeLibForUser:szFullPath:szHelpDir:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayAccessData:ppvData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCopy:ppsaout:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCreateEx:cDims:rgsabound:pvExtra:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayDestroy:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetDim:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetElement:rgIndices:pv:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetIID:pguid:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetLBound:nDim:plLbound:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetRecordInfo:prinfo:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetUBound:nDim:plUbound:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayGetVartype:pvt:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayPtrOfIndex:rgIndices:ppvData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayPutElement:rgIndices:pv:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayRedim:psaboundNew:)
	#(#{OS.COM.OLEAutLibrary} #safeArraySetIID:pguid:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayUnaccessData:)
	#(#{OS.COM.OLEAutLibrary} #safeArrayUnlock:)
	#(#{OS.COM.OLEAutLibrary} #setErrorInfo:perrinfo:)
	#(#{OS.COM.OLEAutLibrary} #systemTimeToVariantTime:pvtime:)
	#(#{OS.COM.OLEAutLibrary} #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:)
	#(#{OS.COM.OLEAutLibrary} #varBstrFromBool:lcid:dwFlags:pbstrOut:)
	#(#{OS.COM.OLEAutLibrary} #varCmp:pvarRight:lcid:dwFlags:)
	#(#{OS.COM.OLEAutLibrary} #varDateFromStr:lcid:dwFlags:pdateOut:)
	#(#{OS.COM.OLEAutLibrary} #variantChangeType:pvarSrc:wFlags:vt:)
	#(#{OS.COM.OLEAutLibrary} #variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:)
	#(#{OS.COM.OLEAutLibrary} #variantClear:)
	#(#{OS.COM.OLEAutLibrary} #variantCopy:pvargSrc:)
	#(#{OS.COM.OLEAutLibrary} #variantCopyInd:pvargSrc:)
	#(#{OS.COM.OLEAutLibrary} #variantInit:)
	#(#{OS.COM.OLEAutLibrary} #variantTimeToSystemTime:lpSystemTime:)
	#(#{OS.FILETIME class} #vt)
	#(#{OS.HRESULT class} #typeName)
	#(#{OS.HRESULT class} #vt)
	#(#{OS.LARGE_INTEGER class} #typeName)
	#(#{OS.LARGE_INTEGER class} #vt)
	#(#{OS.SYSTEMTIME} #asFloat)
	#(#{OS.SYSTEMTIME} #asVariant)
	#(#{OS.SYSTEMTIME class} #fromDATE:)
	#(#{OS.ULARGE_INTEGER class} #typeName)
	#(#{OS.WindowsLocale} #boolFormat)
	#(#{OS.WindowsLocale} #getVariantBoolString:)
	#(#{OS.WindowsLocale} #variantBool:)
).

package setPrerequisites: #(
	'..\..\Base\Dolphin'
	'..\..\Base\Dolphin Conformant Array Fields'
	'..\COM\OLE COM'
).

package!

"Class Definitions"!

Kernel.SharedPool subclass: #'OS.COM.AutomationConstants'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'ACTIVEOBJECT_STRONG' -> 16r0.
		'ACTIVEOBJECT_WEAK' -> 16r1.
		'CC_CDECL' -> 16r1.
		'CC_MACPASCAL' -> 16r3.
		'CC_MAX' -> 16r9.
		'CC_MPWCDECL' -> 16r7.
		'CC_MPWPASCAL' -> 16r8.
		'CC_MSCPASCAL' -> 16r2.
		'CC_PASCAL' -> 16r2.
		'CC_RESERVED' -> 16r5.
		'CC_STDCALL' -> 16r4.
		'CC_SYSCALL' -> 16r6.
		'DESCKIND_FUNCDESC' -> 16r1.
		'DESCKIND_IMPLICITAPPOBJ' -> 16r4.
		'DESCKIND_MAX' -> 16r5.
		'DESCKIND_NONE' -> 16r0.
		'DESCKIND_TYPECOMP' -> 16r3.
		'DESCKIND_VARDESC' -> 16r2.
		'DISPATCH_METHOD' -> 16r1.
		'DISPATCH_PROPERTYGET' -> 16r2.
		'DISPATCH_PROPERTYPUT' -> 16r4.
		'DISPATCH_PROPERTYPUTREF' -> 16r8.
		'DISPID_COLLECT' -> -16r8.
		'DISPID_CONSTRUCTOR' -> -16r6.
		'DISPID_DESTRUCTOR' -> -16r7.
		'DISPID_EVALUATE' -> -16r5.
		'DISPID_NEWENUM' -> -16r4.
		'DISPID_PROPERTYPUT' -> -16r3.
		'DISPID_UNKNOWN' -> -16r1.
		'DISPID_VALUE' -> 16r0.
		'FADF_AUTO' -> 16r1.
		'FADF_BSTR' -> 16r100.
		'FADF_DISPATCH' -> 16r400.
		'FADF_EMBEDDED' -> 16r4.
		'FADF_FIXEDSIZE' -> 16r10.
		'FADF_HAVEIID' -> 16r40.
		'FADF_HAVEVARTYPE' -> 16r80.
		'FADF_RECORD' -> 16r20.
		'FADF_RESERVED' -> 16rF0E8.
		'FADF_STATIC' -> 16r2.
		'FADF_UNKNOWN' -> 16r200.
		'FADF_VARIANT' -> 16r800.
		'FUNC_DISPATCH' -> 16r4.
		'FUNC_NONVIRTUAL' -> 16r2.
		'FUNC_PUREVIRTUAL' -> 16r1.
		'FUNC_STATIC' -> 16r3.
		'FUNC_VIRTUAL' -> 16r0.
		'FUNCFLAG_FBINDABLE' -> 16r4.
		'FUNCFLAG_FDEFAULTBIND' -> 16r20.
		'FUNCFLAG_FDEFAULTCOLLELEM' -> 16r100.
		'FUNCFLAG_FDISPLAYBIND' -> 16r10.
		'FUNCFLAG_FHIDDEN' -> 16r40.
		'FUNCFLAG_FIMMEDIATEBIND' -> 16r1000.
		'FUNCFLAG_FNONBROWSABLE' -> 16r400.
		'FUNCFLAG_FREPLACEABLE' -> 16r800.
		'FUNCFLAG_FREQUESTEDIT' -> 16r8.
		'FUNCFLAG_FRESTRICTED' -> 16r1.
		'FUNCFLAG_FSOURCE' -> 16r2.
		'FUNCFLAG_FUIDEFAULT' -> 16r200.
		'FUNCFLAG_FUSESGETLASTERROR' -> 16r80.
		'ID_DEFAULTINST' -> -16r2.
		'IDLFLAG_FIN' -> 16r1.
		'IDLFLAG_FLCID' -> 16r4.
		'IDLFLAG_FOUT' -> 16r2.
		'IDLFLAG_FRETVAL' -> 16r8.
		'IDLFLAG_NONE' -> 16r0.
		'IMPLTYPEFLAG_FDEFAULT' -> 16r1.
		'IMPLTYPEFLAG_FRESTRICTED' -> 16r4.
		'IMPLTYPEFLAG_FSOURCE' -> 16r2.
		'INVOKE_FUNC' -> 16r1.
		'INVOKE_PROPERTYGET' -> 16r2.
		'INVOKE_PROPERTYPUT' -> 16r4.
		'INVOKE_PROPERTYPUTREF' -> 16r8.
		'LIBFLAG_FCONTROL' -> 16r2.
		'LIBFLAG_FHASDISKIMAGE' -> 16r8.
		'LIBFLAG_FHIDDEN' -> 16r4.
		'LIBFLAG_FRESTRICTED' -> 16r4.
		'MEMBERID_NIL' -> -16r1.
		'PARAMFLAG_FHASDEFAULT' -> 16r20.
		'PARAMFLAG_FIN' -> 16r1.
		'PARAMFLAG_FOPT' -> 16r10.
		'PARAMFLAG_FOUT' -> 16r2.
		'PARAMFLAG_FRETVAL' -> 16r8.
		'PARAMFLAG_NONE' -> 16r0.
		'REGKIND_DEFAULT' -> 16r0.
		'REGKIND_NONE' -> 16r2.
		'REGKIND_REGISTER' -> 16r1.
		'STDOLE_LCID' -> 16r0.
		'STDOLE_MAJORVERNUM' -> 16r1.
		'STDOLE_MINORVERNUM' -> 16r0.
		'SYS_MAC' -> 16r2.
		'SYS_WIN16' -> 16r0.
		'SYS_WIN32' -> 16r1.
		'TKIND_ALIAS' -> 16r6.
		'TKIND_COCLASS' -> 16r5.
		'TKIND_DISPATCH' -> 16r4.
		'TKIND_ENUM' -> 16r0.
		'TKIND_INTERFACE' -> 16r3.
		'TKIND_MAX' -> 16r8.
		'TKIND_MODULE' -> 16r2.
		'TKIND_RECORD' -> 16r1.
		'TKIND_UNION' -> 16r7.
		'TYPEFLAG_FAGGREGATABLE' -> 16r400.
		'TYPEFLAG_FAPPOBJECT' -> 16r1.
		'TYPEFLAG_FCANCREATE' -> 16r2.
		'TYPEFLAG_FCONTROL' -> 16r20.
		'TYPEFLAG_FDISPATCHABLE' -> 16r1000.
		'TYPEFLAG_FDUAL' -> 16r40.
		'TYPEFLAG_FHIDDEN' -> 16r10.
		'TYPEFLAG_FLICENSED' -> 16r4.
		'TYPEFLAG_FNONEXTENSIBLE' -> 16r80.
		'TYPEFLAG_FOLEAUTOMATION' -> 16r100.
		'TYPEFLAG_FPREDECLID' -> 16r8.
		'TYPEFLAG_FRESTRICTED' -> 16r200.
		'VAR_CONST' -> 16r2.
		'VAR_DATEVALUEONLY' -> 16r2.
		'VAR_DISPATCH' -> 16r3.
		'VAR_PERINSTANCE' -> 16r0.
		'VAR_STATIC' -> 16r1.
		'VAR_TIMEVALUEONLY' -> 16r1.
		'VARFLAG_FBINDABLE' -> 16r4.
		'VARFLAG_FDEFAULTBIND' -> 16r20.
		'VARFLAG_FDISPLAYBIND' -> 16r10.
		'VARFLAG_FHIDDEN' -> 16r40.
		'VARFLAG_FNONBROWSABLE' -> 16r400.
		'VARFLAG_FREADONLY' -> 16r1.
		'VARFLAG_FREQUESTEDIT' -> 16r8.
		'VARFLAG_FRESTRICTED' -> 16r80.
		'VARFLAG_FSOURCE' -> 16r2.
		'VARFLAG_FUIDEFAULT' -> 16r200.
		'VARIANT_ALPHABOOL' -> 16r2.
		'VARIANT_CALENDAR_GREGORIAN' -> 16r40.
		'VARIANT_CALENDAR_HIJRI' -> 16r8.
		'VARIANT_CALENDAR_THAI' -> 16r20.
		'VARIANT_FALSE' -> 16r0.
		'VARIANT_LOCALBOOL' -> 16r10.
		'VARIANT_NOUSEROVERRIDE' -> 16r4.
		'VARIANT_NOVALUEPROP' -> 16r1.
		'VARIANT_TRUE' -> -16r1.
		'VARIANT_USE_NLS' -> 16r80.
		'VT_ARRAY' -> 16r2000.
		'VT_BLOB' -> 16r41.
		'VT_BLOB_OBJECT' -> 16r46.
		'VT_BOOL' -> 16rB.
		'VT_BSTR' -> 16r8.
		'VT_BYREF' -> 16r4000.
		'VT_CARRAY' -> 16r1C.
		'VT_CF' -> 16r47.
		'VT_CLSID' -> 16r48.
		'VT_CY' -> 16r6.
		'VT_DATE' -> 16r7.
		'VT_DECIMAL' -> 16rE.
		'VT_DISPATCH' -> 16r9.
		'VT_EMPTY' -> 16r0.
		'VT_ERROR' -> 16rA.
		'VT_FILETIME' -> 16r40.
		'VT_HRESULT' -> 16r19.
		'VT_I1' -> 16r10.
		'VT_I2' -> 16r2.
		'VT_I4' -> 16r3.
		'VT_I8' -> 16r14.
		'VT_INT' -> 16r16.
		'VT_LPSTR' -> 16r1E.
		'VT_LPWSTR' -> 16r1F.
		'VT_NULL' -> 16r1.
		'VT_PTR' -> 16r1A.
		'VT_R4' -> 16r4.
		'VT_R8' -> 16r5.
		'VT_RECORD' -> 16r24.
		'VT_SAFEARRAY' -> 16r1B.
		'VT_STORAGE' -> 16r43.
		'VT_STORED_OBJECT' -> 16r45.
		'VT_STREAM' -> 16r42.
		'VT_STREAMED_OBJECT' -> 16r44.
		'VT_TYPEMASK' -> 16rFFF.
		'VT_UI1' -> 16r11.
		'VT_UI2' -> 16r12.
		'VT_UI4' -> 16r13.
		'VT_UI8' -> 16r15.
		'VT_UINT' -> 16r17.
		'VT_UNKNOWN' -> 16rD.
		'VT_USERDEFINED' -> 16r1D.
		'VT_VARIANT' -> 16rC.
		'VT_VECTOR' -> 16r1000.
		'VT_VOID' -> 16r18
	}!
Kernel.SharedPool subclass: #'OS.COM.AutomationErrors'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'DISP_E_ARRAYISLOCKED' -> -16r7FFDFFF3.
		'DISP_E_BADINDEX' -> -16r7FFDFFF5.
		'DISP_E_BADVARTYPE' -> -16r7FFDFFF8.
		'DISP_E_DIVBYZERO' -> -16r7FFDFFEE.
		'DISP_E_EXCEPTION' -> -16r7FFDFFF7.
		'DISP_E_MEMBERNOTFOUND' -> -16r7FFDFFFD.
		'DISP_E_OVERFLOW' -> -16r7FFDFFF6.
		'DISP_E_PARAMNOTFOUND' -> -16r7FFDFFFC.
		'DISP_E_TYPEMISMATCH' -> -16r7FFDFFFB.
		'DISP_E_UNKNOWNNAME' -> -16r7FFDFFFA.
		'TYPE_E_CANTLOADLIBRARY' -> -16r7FFD63B6.
		'TYPE_E_ELEMENTNOTFOUND' -> -16r7FFD7FD5.
		'TYPE_E_FIELDNOTFOUND' -> -16r7FFD7FE9.
		'TYPE_E_LIBNOTREGISTERED' -> -16r7FFD7FE3.
		'WCODE_HRESULT_FIRST' -> -16r7FFBFE00.
		'WCODE_HRESULT_LAST' -> -16r7FFB0001
	}!
Kernel.SharedPool subclass: #'OS.COM.TypeGenerationFlags'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'CommentStyleMask' -> 16r101.
		'DefineProtocol' -> 16r20.
		'LowercaseIdentifiers' -> 16r400.
		'MinimizeWrappers' -> 16r80.
		'NoClassComment' -> 16r1.
		'NoCompile' -> 16r40.
		'NoFunctionTable' -> 16r4.
		'NoSourceInterfaces' -> 16r200.
		'NoTypeLib' -> 16r2.
		'OverwriteClassComments' -> 16r100.
		'RawMethodsOnly' -> 16r10.
		'Trace' -> 16r8.
		'TraceOnly' -> 16r48.
		'Verbose' -> 16r800.
		'WrapperStyleMask' -> 16r90
	}!
Core.Object subclass: #'OS.COM.TypeInfoObject'
	instanceVariableNames: 'tlbInterface generationFlags'
	classVariableNames: 'ClassCommentStyleMap GuidClash HighLevelWrapperStyleMap SuperclassClash TracingStyleMap'
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.TypeGenerationFlags})
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'OS.COM.TypeLibDocumentation'
	instanceVariableNames: 'name helpstring helpcontext helpfile'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.InterfaceFunction subclass: #'OS.COM.DispatchFunction'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.Win32Errors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.InterfaceImplementation subclass: #'OS.COM.AbstractDispatchImplementation'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.AbstractDispatchImplementation subclass: #'OS.COM.DualInterfaceImplementation'
	instanceVariableNames: 'interface piTypeInfo locale'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.DualInterfaceImplementation subclass: #'OS.COM.ForwardingDualInterfaceImplementation'
	instanceVariableNames: 'interfaceClass server'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.Enumerator subclass: #'OS.COM.VariantEnumerator'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
External.GenericExternalArray subclass: #'OS.COM.SAFEARRAY'
	instanceVariableNames: 'data start recordInfo'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cbElements' -> 16r4.
		'_OffsetOf_cDims' -> 16r0.
		'_OffsetOf_cLocks' -> 16r8.
		'_OffsetOf_fFeatures' -> 16r2.
		'_OffsetOf_pvData' -> 16rC.
		'_OffsetOf_rgsabound' -> 16r10
	}!
OS.COM.IUnknown subclass: #'OS.COM.ICreateErrorInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.IDispatch'
	instanceVariableNames: 'typeInfo dispatchImplementor'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.IPerPropertyBrowsing'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.IProvideClassInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.IRecordInfo'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.ITypeComp'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.ITypeInfo'
	instanceVariableNames: 'attributes'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IUnknown subclass: #'OS.COM.ITypeLib'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IEnumXXXX subclass: #'OS.COM.IEnumVARIANT'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IProvideClassInfo subclass: #'OS.COM.IProvideClassInfo2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.ITypeInfo subclass: #'OS.COM.ITypeInfo2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.ITypeLib subclass: #'OS.COM.ITypeLib2'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.OLEStructure subclass: #'OS.COM.AbstractELEMDESC'
	instanceVariableNames: 'owner tdesc'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_tdescElem' -> 16r0
	}!
OS.COM.OLEStructure subclass: #'OS.COM.CURRENCY'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cy' -> 16r0
	}!
OS.COM.OLEStructure subclass: #'OS.COM.CUSTDATAITEM'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_varValue' -> 16r10
	}!
OS.COM.OLEStructure subclass: #'OS.COM.DECIMAL'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_hi32' -> 16r4.
		'_OffsetOf_lo64' -> 16r8.
		'_OffsetOf_scale' -> 16r2.
		'_OffsetOf_sign' -> 16r3.
		'_OffsetOf_wReserved' -> 16r0
	}!
OS.COM.OLEStructure subclass: #'OS.COM.DISPPARAMS'
	instanceVariableNames: 'args vargs dispids'
	classVariableNames: 'ZeroArgs'
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cArgs' -> 16r8.
		'_OffsetOf_cNamedArgs' -> 16rC.
		'_OffsetOf_rgdispidNamedArgs' -> 16r4.
		'_OffsetOf_rgvarg' -> 16r0
	}!
OS.COM.OLEStructure subclass: #'OS.COM.FONTDESC'
	instanceVariableNames: 'name'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cySize' -> 16r8.
		'_OffsetOf_dwSize' -> 16r0.
		'_OffsetOf_fItalic' -> 16r14.
		'_OffsetOf_fStrikethrough' -> 16r1C.
		'_OffsetOf_fUnderline' -> 16r18.
		'_OffsetOf_lpstrName' -> 16r4.
		'_OffsetOf_sCharset' -> 16r12.
		'_OffsetOf_sWeight' -> 16r10
	}!
OS.COM.OLEStructure subclass: #'OS.COM.IDLDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_dwReserved' -> 16r0.
		'_OffsetOf_wIDLFlags' -> 16r4
	}!
OS.COM.OLEStructure subclass: #'OS.COM.PARAMDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_pparamdescex' -> 16r0.
		'_OffsetOf_wParamFlags' -> 16r4
	}!
OS.COM.OLEStructure subclass: #'OS.COM.PARAMDESCEX'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cBytes' -> 16r0.
		'_OffsetOf_varDefaultValue' -> 16r8
	}!
OS.COM.OLEStructure subclass: #'OS.COM.SAFEARRAYBOUND'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cElements' -> 16r0.
		'_OffsetOf_lLbound' -> 16r4
	}!
OS.COM.OLEStructure subclass: #'OS.COM.TLIBATTR'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_lcid' -> 16r10.
		'_OffsetOf_syskind' -> 16r14.
		'_OffsetOf_wLibFlags' -> 16r1C.
		'_OffsetOf_wMajorVerNum' -> 16r18.
		'_OffsetOf_wMinorVerNum' -> 16r1A
	}!
OS.COM.OLEStructure subclass: #'OS.COM.TYPEDESC'
	instanceVariableNames: 'owner classDesc typeInfo'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_hreftype' -> 16r0.
		'_OffsetOf_lpadesc' -> 16r0.
		'_OffsetOf_lptdesc' -> 16r0.
		'_OffsetOf_vt' -> 16r4.
		'VTIndirections' -> #[0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
	}!
OS.COM.AbstractELEMDESC subclass: #'OS.COM.ARRAYDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cDims' -> 16r8.
		'_OffsetOf_rgbounds' -> 16rC
	}!
OS.COM.AbstractELEMDESC subclass: #'OS.COM.ELEMDESC'
	instanceVariableNames: 'param'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_paramdesc' -> 16r8
	}!
OS.COM.FinalizableStructure subclass: #'OS.COM.CUSTDATA'
	instanceVariableNames: 'contents'
	classVariableNames: 'WellKnownCustomAttributes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cCustData' -> 16r0.
		'_OffsetOf_prgCustData' -> 16r4
	}!
OS.COM.FinalizableStructure subclass: #'OS.COM.Record'
	instanceVariableNames: 'recordInfo owner'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.FinalizableStructure subclass: #'OS.COM.TypeInfoStructure'
	instanceVariableNames: 'analyzer'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.FinalizableStructure subclass: #'OS.COM.VARIANT'
	instanceVariableNames: 'data'
	classVariableNames: 'Unspecified'
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_dblVal' -> 16r8.
		'_OffsetOf_vt' -> 16r0.
		'_OffsetOf_wReserved1' -> 16r2.
		'_OffsetOf_wReserved2' -> 16r4.
		'_OffsetOf_wReserved3' -> 16r6.
		'VTClasses' -> #(#{UndefinedObject} nil #{SWORD} #{SDWORD} #{FLOAT} #{DOUBLE} #{CURRENCY} #{DATE} #{BSTR} #{IDispatch} #{HRESULT} #{VARIANT_BOOL} #{VARIANT} #{IUnknown} #{DECIMAL} nil #{SBYTE} #{BYTE} #{WORD} #{DWORD} #{LARGE_INTEGER} #{ULARGE_INTEGER} #{SDWORD} #{DWORD} #{VOID} #{HRESULT} #{Address} #{SAFEARRAY} #{External.Array} #{Record} #{String} #{Utf16String} nil nil nil nil #{Structure} nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #{FILETIME} nil nil nil nil nil nil #{DWORD} #{CLSID}).
		'VTNames' -> #(#nil #null #sword #sdword #float #double #cy #date #bstr #dispatch #hresult #varbool #variant #unknown #decimal #badVarType #sbyte #byte #word #dword #sqword #qword #sdword #dword #void #hresult #lpvoid #safearray #carray #typedef #lpstr #lpwstr #badVarType #badVarType #badVarType #badVarType #struct #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #badVarType #filetime #blob #stream #storage #streamed_object #stored_object #blob_object #cf #clsid)
	}!
OS.COM.TypeInfoStructure subclass: #'OS.COM.MemberDesc'
	instanceVariableNames: 'index customAttributes documentation'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoStructure subclass: #'OS.COM.TYPEATTR'
	instanceVariableNames: 'piTypeInfo'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_cbAlignment' -> 16r34.
		'_OffsetOf_cbSizeInstance' -> 16r24.
		'_OffsetOf_cbSizeVft' -> 16r32.
		'_OffsetOf_cFuncs' -> 16r2C.
		'_OffsetOf_cImplTypes' -> 16r30.
		'_OffsetOf_cVars' -> 16r2E.
		'_OffsetOf_dwReserved' -> 16r14.
		'_OffsetOf_guid' -> 16r0.
		'_OffsetOf_idldescType' -> 16r44.
		'_OffsetOf_lcid' -> 16r10.
		'_OffsetOf_lpstrSchema' -> 16r20.
		'_OffsetOf_memidConstructor' -> 16r18.
		'_OffsetOf_memidDestructor' -> 16r1C.
		'_OffsetOf_tdescAlias' -> 16r3C.
		'_OffsetOf_typekind' -> 16r28.
		'_OffsetOf_wMajorVerNum' -> 16r38.
		'_OffsetOf_wMinorVerNum' -> 16r3A.
		'_OffsetOf_wTypeFlags' -> 16r36
	}!
OS.COM.MemberDesc subclass: #'OS.COM.FUNCDESC'
	instanceVariableNames: 'names arguments outputIndices retvalIndex methodName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_callconv' -> 16r14.
		'_OffsetOf_cParams' -> 16r18.
		'_OffsetOf_cParamsOpt' -> 16r1A.
		'_OffsetOf_cScodes' -> 16r1E.
		'_OffsetOf_elemdescFunc' -> 16r20.
		'_OffsetOf_funckind' -> 16rC.
		'_OffsetOf_invkind' -> 16r10.
		'_OffsetOf_lprgelemdescParam' -> 16r8.
		'_OffsetOf_lprgscode' -> 16r4.
		'_OffsetOf_memid' -> 16r0.
		'_OffsetOf_oVft' -> 16r1C.
		'_OffsetOf_wFuncFlags' -> 16r30
	}!
OS.COM.MemberDesc subclass: #'OS.COM.VARDESC'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'_OffsetOf_elemdesc' -> 16rC.
		'_OffsetOf_lpstrSchema' -> 16r4.
		'_OffsetOf_lpvarValue' -> 16r8.
		'_OffsetOf_memid' -> 16r0.
		'_OffsetOf_oInst' -> 16r8.
		'_OffsetOf_varkind' -> 16r20.
		'_OffsetOf_wVarFlags' -> 16r1C
	}!
External.DOUBLE subclass: #'OS.COM.DATE'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
External.SWORD subclass: #'OS.COM.VARIANT_BOOL'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
External.LPVOID subclass: #'OS.COM.LPBSTR'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoObject subclass: #'OS.COM.TypeInfoAnalyzer'
	instanceVariableNames: 'typeLib globalBinding guid index documentation'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'VTtoIDLTypeMap' -> #(nil 'short' 'long' 'float' 'double' 'CURRENCY' 'DATE' 'BSTR' 'IDispatch*' 'SCODE' 'VARIANT_BOOL' 'VARIANT' 'IUnknown*' 'DECIMAL' nil 'char' 'BYTE' 'unsigned short' 'unsigned long' '__int64' 'unsigned __int64' 'int' 'unsigned int' 'void' 'HRESULT' '*' 'SAFEARRAY*' '[]' 'typedef' 'LPSTR' 'LPWSTR')
	}!
OS.COM.TypeInfoObject subclass: #'OS.COM.TypeLibraryAnalyzer'
	instanceVariableNames: 'attributes namespaceName packageName globalName constantsPoolName aliasMap typeAnalyzers'
	classVariableNames: 'TypeLibs'
	imports: #(#{OS.Win32Constants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoAnalyzer subclass: #'OS.COM.APIInfoAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoAnalyzer subclass: #'OS.COM.StructureTypeAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'BuiltIns'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoAnalyzer subclass: #'OS.COM.TKindAliasAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'BaseTypes'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoAnalyzer subclass: #'OS.COM.TKindCoclassAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.TypeInfoAnalyzer subclass: #'OS.COM.TKindEnumAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.APIInfoAnalyzer subclass: #'OS.COM.InterfaceTypeAnalyzer'
	instanceVariableNames: 'protocol isSource'
	classVariableNames: 'ReservedDispSelectors ReservedUnkSelectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.APIInfoAnalyzer subclass: #'OS.COM.TKindModuleAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.InterfaceTypeAnalyzer subclass: #'OS.COM.TKindDispatchAnalyzer'
	instanceVariableNames: ''
	classVariableNames: 'SpecialPropGets'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.InterfaceTypeAnalyzer subclass: #'OS.COM.TKindInterfaceAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.StructureTypeAnalyzer subclass: #'OS.COM.TKindRecordAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.StructureTypeAnalyzer subclass: #'OS.COM.TKindUnionAnalyzer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Boolean methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^OS.COM.VARIANT fromBoolean: self! !
!Core.Boolean categoriesFor: #asVariant!converting!public! !

!Core.ByteArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^OS.COM.SAFEARRAY withAll: self elementClass: External.BYTE! !
!Core.ByteArray categoriesFor: #asSAFEARRAY!converting!public! !

!Core.ByteArray class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !
!Core.ByteArray class categoriesFor: #typeName!constants!private! !

!Core.Character methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I2). This will fail for code points not in the BMP."

	^OS.COM.VARIANT new
		sword: self codePoint;
		yourself! !
!Core.Character categoriesFor: #asVariant!converting!public! !

!Core.Collection methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^OS.COM.SAFEARRAY withAll: self!

asVariant
	"Answer the VARIANT representation of the receiver (a SAFEARRAY of VARIANT)."

	^OS.COM.VARIANT fromCollection: self! !
!Core.Collection categoriesFor: #asSAFEARRAY!converting!public! !
!Core.Collection categoriesFor: #asVariant!converting!public! !

!Core.DateAndTime methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	^self asParameter asFloat!

asVariant
	"Answer the <VARIANT> representation of the receiver (a VT_DATE)."

	^self asSYSTEMTIME asVariant! !
!Core.DateAndTime categoriesFor: #asFloat!converting!public! !
!Core.DateAndTime categoriesFor: #asVariant!converting!public! !

!Core.Float methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8)."

	^OS.COM.VARIANT fromFloat: self! !
!Core.Float categoriesFor: #asVariant!converting!public! !

!Core.Fraction methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_R8).
	Note that precision may be lost."

	^self asFloat asVariant! !
!Core.Fraction categoriesFor: #asVariant!converting!public! !

!Core.GUID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name associated with the receiver."

	^self name! !
!Core.GUID class categoriesFor: #typeName!constants!private! !

!Core.Integer methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4, VT_I8, or VT_UI8)."

	^self subclassResponsibility! !
!Core.Integer categoriesFor: #asVariant!converting!public! !

!Core.LargeInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I8).
	It is an error if the receiver is too large to be represented in 64-bits."

	^OS.COM.VARIANT fromLargeInteger: self! !
!Core.LargeInteger categoriesFor: #asVariant!converting!public! !

!Core.Locale methodsFor!

variantBool: aBoolean
	^self subclassResponsibility! !
!Core.Locale categoriesFor: #variantBool:!constants!public! !

!Core.ScaledDecimal methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Both VT_CY (currency) and VT_DECIMAL types convert to ScaledDecimals
	but the latter has a wider (64-bit unsigned) range and a variable scale, so it
	is more likely to suit."

	^OS.COM.VARIANT new
		decimal: self;
		yourself! !
!Core.ScaledDecimal categoriesFor: #asVariant!converting!public! !

!Core.SmallInteger methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_I4 or VT_I8, depending on the
	bitness of the host machine)."

	^OS.COM.VARIANT fromSmallInteger: self! !
!Core.SmallInteger categoriesFor: #asVariant!converting!public! !

!Core.String methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^OS.COM.VARIANT fromString: self! !
!Core.String categoriesFor: #asVariant!converting!public! !

!Core.String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^External.LPSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_LPSTR! !
!Core.String class categoriesFor: #pointerType!constants!private! !
!Core.String class categoriesFor: #typeName!constants!private! !
!Core.String class categoriesFor: #vt!constants!public! !

!Core.UndefinedObject methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_EMPTY).
	Implementation Note: VT_EMPTY is chosen for compatibility with VB which
	uses VT_EMPTY for null object references, even though VT_NULL might
	appear more appropriate at first glance."

	^OS.COM.VARIANT new! !
!Core.UndefinedObject categoriesFor: #asVariant!converting!public! !

!Core.UndefinedObject class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver."

	^#nil!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_EMPTY! !
!Core.UndefinedObject class categoriesFor: #typeName!constants!private! !
!Core.UndefinedObject class categoriesFor: #vt!constants!public! !

!Core.Utf16String class methodsFor!

pointerType
	"Answer the <ExternalStructure> class to represent pointers to this external type with the
	another indirection."

	^External.LPWSTR!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpwstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^OS.COM.AutomationConstants.VT_LPWSTR! !
!Core.Utf16String class categoriesFor: #pointerType!constants!private! !
!Core.Utf16String class categoriesFor: #typeName!constants!private! !
!Core.Utf16String class categoriesFor: #vt!constants!public! !

!External.Address class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#lpvoid!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_PTR! !
!External.Address class categoriesFor: #typeName!constants!private! !
!External.Address class categoriesFor: #vt!constants!public! !

!External.BOOL class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !
!External.BOOL class categoriesFor: #typeName!constants!private! !

!External.BOOLEAN class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bool! !
!External.BOOLEAN class categoriesFor: #typeName!constants!private! !

!External.BYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#byte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI1! !
!External.BYTE class categoriesFor: #typeName!constants!private! !
!External.BYTE class categoriesFor: #vt!constants!public! !

!External.DOUBLE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#double!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_R8! !
!External.DOUBLE class categoriesFor: #typeName!constants!private! !
!External.DOUBLE class categoriesFor: #vt!constants!public! !

!External.DWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#dword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI4! !
!External.DWORD class categoriesFor: #typeName!constants!private! !
!External.DWORD class categoriesFor: #vt!constants!public! !

!External.ExternalArray methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver."

	^COM.SAFEARRAY withAll: self elementClass: self elementClass!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_ARRAY|VT_XX)."

	^COM.VARIANT fromCollection: self! !
!External.ExternalArray categoriesFor: #asSAFEARRAY!converting!public! !
!External.ExternalArray categoriesFor: #asVariant!converting!public! !

!External.ExternalArray class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_CARRAY! !
!External.ExternalArray class categoriesFor: #vt!constants!public! !

!External.FLOAT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#float!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_R4! !
!External.FLOAT class categoriesFor: #typeName!constants!private! !
!External.FLOAT class categoriesFor: #vt!constants!public! !

!External.Handle class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#handle! !
!External.Handle class categoriesFor: #typeName!constants!private! !

!External.INT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#intptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [COM.AutomationConstants.VT_I8] ifFalse: [COM.AutomationConstants.VT_I4]! !
!External.INT_PTR class categoriesFor: #typeName!constants!private! !
!External.INT_PTR class categoriesFor: #vt!constants!public! !

!External.INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^self subclassResponsibility!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self subclassResponsibility! !
!External.INTEGER class categoriesFor: #typeName!constants!private! !
!External.INTEGER class categoriesFor: #vt!constants!private! !

!External.LPVOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	#todo "Is this right?".
	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	#todo "Is this right?".
	^COM.AutomationConstants.VT_VOID! !
!External.LPVOID class categoriesFor: #typeName!constants!private! !
!External.LPVOID class categoriesFor: #vt!constants!public! !

!External.QWORD class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI8! !
!External.QWORD class categoriesFor: #vt!constants!public! !

!External.SBYTE class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sbyte!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I1! !
!External.SBYTE class categoriesFor: #typeName!constants!private! !
!External.SBYTE class categoriesFor: #vt!constants!public! !

!External.SCALAR methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver."

	^(COM.VARIANT new)
		vt: (self vt bitOr: COM.AutomationConstants.VT_BYREF);
		reference: self! !
!External.SCALAR categoriesFor: #asVariant!converting!public! !

!External.SDWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sdword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I4! !
!External.SDWORD class categoriesFor: #typeName!constants!private! !
!External.SDWORD class categoriesFor: #vt!constants!public! !

!External.Structure methodsFor!

asVariant
	"Answer the <VARIANT> representation of the receiver.
	Note that shis will be a reference to the receiver not a copy."

	^COM.VARIANT new
		struct: self;
		yourself!

recordInfo
	"Answer an <IRecordInfo> on the receiver's type information."

	^self class recordInfo!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^self class vt! !
!External.Structure categoriesFor: #asVariant!converting!public! !
!External.Structure categoriesFor: #recordInfo!accessing!public! !
!External.Structure categoriesFor: #vt!constants!private! !

!External.Structure class methodsFor!

classForGUID: aGUID ifNone: exceptionHandler
	"Private - Answer the <External.Structure> class (a subclass of the receiver) which
	represents the Record with <GUID>, aGUID, or if none is registered for that GUID
	then the result of evaluating the <niladicValuable>, exceptionHandler."

	^RecordClasses at: aGUID ifAbsent: exceptionHandler

	
!

clearGuid
	"Private - Set the receiver's GUID to be the null <GUID>.
	Override because we must retain our GUID for the table
	of record classes (only needed for ActiveX Automation)."

!

finalRelease
	"The last reference to the receiver (as a COM object) has been released.
	This is an opportunity to actively clean up, rather than passively waiting 
	for finalization which might is asynchronous and may never happen if the 
	object doesn't become garbage."

	"Override as necessary"!

fromAddress: address recordInfo: recInfo owner: owner
	"Answer a new subinstance of the receiver which references the structure
	described by the <IRecordInfo>, recInfo, at the specified address,
	which is owned by the Object, owner."

	^(self classForGUID: recInfo guid
		ifNone: 
			[^COM.Record
				fromAddress: address
				recordInfo: recInfo
				owner: owner])
			fromAddress: address!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^(self newBuffer)
		value: anObject;
		yourself!

GetField: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::GetField() method for the UDT described by the receiver.

		HRESULT __stdcall GetField(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField);

	"

	| refInst hr |
	refInst := self fromAddress: pvData.
	"Help specifies that VariantClear is call on pvarField before copying, normally but just VariantInit, but ..."
	pvarField class clear: pvarField yourAddress.
	
	[pvarField value: (refInst getField: szFieldName).
	hr := 0	"S_OK"] on: MessageNotUnderstood
			do: [:x | hr := Win32Errors.E_INVALIDARG].
	^hr!

GetFieldNames: pcNames rgBstrNames: rgBstrNames
	"Implement the IRecordInfo::GetFieldNames() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNames(
			[in, out] unsigned long* pcNames,
			[out] BSTR* rgBstrNames);
	"

	| names |
	names := self getFieldNames.
	rgBstrNames isNull
		ifTrue: [pcNames value: names size]
		ifFalse: 
			[| namesArray maxNames end |
			maxNames := pcNames value.
			"rgBstrNames will be an LPVOID holding the address of the buffer, which is a sufficiently sized array of BSTR pointers"
			namesArray := DWORDArray fromAddress: rgBstrNames yourAddress length: maxNames.
			end := names size min: maxNames.
			1 to: end do: [:i | namesArray at: i put: (names at: i) asBSTR detach].
			end + 1 to: maxNames do: [:i | namesArray at: i put: 0].
			pcNames value: end].
	^0	"S_OK"!

GetFieldNoCopy: pvData szFieldName: szFieldName pvarField: pvarField ppvDataCArray: ppvDataCArray
	"Implement the IRecordInfo::GetFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall GetFieldNoCopy(
			[in] void* pvData,
			[in] LPWSTR szFieldName,
			[out] VARIANT* pvarField,
			[out] void** ppvDataCArray);
	"

	^Win32Errors.E_NOTIMPL
!

GetGuid: pguid
	"Implement the IRecordInfo::GetGuid() method for the UDT described by the receiver.

		HRESULT __stdcall GetGuid(
			[out] GUID* pguid);
	"

	pguid value: self guid.
	^0 "S_OK"
!

GetName: pbstrName
	"Implement the IRecordInfo::GetName() method for the UDT described by the receiver,
	i.e. answer the name of the record via the <BSTR>* output parameter.

		HRESULT __stdcall GetName(
			[out] BSTR* pbstrName);
	"

	pbstrName value: self name asBSTR detach.
	^0 "S_OK"
!

GetSize: pcbSize
	"Implement the IRecordInfo::GetSize() method for the UDT described by the receiver.

		HRESULT __stdcall GetSize(
			[out] unsigned long* pcbSize);
	"
	
	pcbSize value: self byteSize.
	^0 "S_OK"!

GetTypeInfo: ppTypeInfo
	"Implement the IRecordInfo::GetTypeInfo() method for the UDT described by the receiver.

		HRESULT __stdcall GetTypeInfo(
			[out] ITypeInfo** ppTypeInfo);
	"

	| ti |
	ppTypeInfo value: 0.
	ti := self typeInfoIfNone: [^1 "S_FALSE"].
	ti addRef.
	ppTypeInfo value: ti yourAddress.
	^0 "S_OK"
!

initializeRegister
	"Private - Initialize the register of GUIDs to record classes."

	RecordClasses := LookupTable new!

IsMatchingType: pRecordInfo
	"Implement the IRecordInfo::IsMatchingType() method for the UDT described by the receiver.

		long __stdcall IsMatchingType(
			[in] IRecordInfo* pRecordInfo);
	"

	^(self guid = pRecordInfo guid) asParameter!

newSAFEARRAY: length 
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	| vt |
	^(vt := self vt) == COM.AutomationConstants.VT_RECORD 
		ifTrue: [COM.SAFEARRAY length: length recordClass: self]
		ifFalse: 
			[COM.SAFEARRAY 
				length: length
				vt: vt
				elementClass: self]!

pointerFieldType
	"Answer the <ExternalField> class to represent pointers to this external type with the
	one indirection."

	^PointerField!

PutField: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutField() method for the UDT described by the receiver.

		HRESULT __stdcall PutField(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	| refInst value |
	refInst := self fromAddress: pvData.
	wFlags = COM.AutomationConstants.INVOKE_PROPERTYPUT
		ifTrue: 
			[| fieldValue |
			fieldValue := [refInst getField: szFieldName] on: MessageNotUnderstood
						do: [:x | ^Win32Errors.E_INVALIDARG].
			value := pvarField isDispatch ifTrue: [pvarField dispatch value] ifFalse: [pvarField value].
			(fieldValue isKindOf: COM.IDispatch)
				ifTrue: 
					[fieldValue isNull ifTrue: [^Win32Errors.E_POINTER].
					fieldValue value: value]
				ifFalse: [refInst setField: szFieldName value: value]]
		ifFalse: 
			[wFlags = COM.AutomationConstants.INVOKE_PROPERTYPUTREF
				ifTrue: [value := pvarField value]
				ifFalse: [^Win32Errors.E_INVALIDARG]].
	^
	[refInst setField: szFieldName value: value.
	0	"S_OK"] on: MessageNotUnderstood
			do: [:x | Win32Errors.E_INVALIDARG]!

PutFieldNoCopy: wFlags pvData: pvData szFieldName: szFieldName pvarField: pvarField
	"Implement the IRecordInfo::PutFieldNoCopy() method for the UDT described by the receiver.

		HRESULT __stdcall PutFieldNoCopy(
			[in] unsigned long wFlags,
			[in, out] void* pvData,
			[in] LPWSTR szFieldName,
			[in] VARIANT* pvarField);
	"

	^Win32Errors.E_NOTIMPL
!

queryInterface: anInterfaceClass
	"Answer a new interface which supports the specified interface protocol
	(usually a class), or nil if the receiver does not support the interface."

	^self queryInterface: anInterfaceClass ifNone: []
!

queryInterface: anInterfaceClass ifNone: exceptionHandler
	"Answer a new interface pointer which supports the specified interface protocol
	(usually a class). If the receiver does not support the interface, answer the
	result of evaluating the niladic valuable, exceptionHandler."

	| class |
	class := self supportedInterfaces 
		detect: [:ic | ic supportsInterface: anInterfaceClass] 
		ifNone: [^exceptionHandler value].
	^class on: self implementor: self
!

RecordClear: pvExisting
	"Implement the IRecordInfo::RecordClear() method for the UDT described by the receiver.
	Clearing down a record involves freeing any of the fields that need to be finalized, it does
	not include releasing the memory owned by the record.

		HRESULT __stdcall RecordClear(
			[in] void* pvExisting);
	"

	self clear: pvExisting.
	^0 "S_OK"
!

RecordCopy: pvExisting pvNew: pvNew
	"Implement IRecordInfo::RecordCopy() method for the UDT described by the receiver.
	Copy an existing area of memory occuppied by a record of the receiver's type to a new
	location. Relies on a correct implementation of #copy which copies any pointed at
	structures which should not be shared.

		HRESULT __stdcall RecordCopy(
			[in] void* pvExisting,
			[out] void* pvNew);
	"

	| ref |
	ref := self fromAddress: pvExisting.
	pvNew 
		replaceFrom: 1
		to: ref byteSize
		with: ref copy detach
		startingAt: 1.
	^0 "S_OK"!

RecordCreate
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver
	Create a new record of the receiver's type in COM task memory.

		void* __stdcall RecordCreate();
	"

	^(COM.TaskMemory new: self byteSize) detach!

RecordCreateCopy: pvSource ppvDest: ppvDest
	"Implement the IRecordInfo::RecordCreate() method for the UDT described by the receiver

		HRESULT __stdcall RecordCreateCopy(
			[in] void* pvSource,
			[out] void** ppvDest);
	"

	| pv |
	pv := self RecordCreate.
	ppvDest value: pv.
	pv isNull ifTrue: [^Win32Errors.E_OUTOFMEMORY].
	^self RecordCopy: pvSource pvNew: pv!

RecordDestroy: pvRecord
	"Implement the RecordDestroy() method for the UDT described by the receiver.
	Free up a record of the receiver's type previously created with RecordCreate().

		HRESULT __stdcall RecordDestroy(
			[in] void* pvRecord);
	"

	self RecordClear: pvRecord.
	COM.TaskMemory free: pvRecord.
	^0	"S_OK"!

recordInfo
	"Answer an <IRecordInfo> describing the receiver's structure class.
	Note that we attempt to use the system provided implementation, but as this is frequently 
	unavailable (even for the DX-7 libraries which require extensive use of IRecordInfo)
	we must also be able to implement it ourselves."

	| ti ri |
	ti := self typeInfoIfNone: [].
	ri := ti notNil ifTrue: [ti recordInfoIfNone: []].
	^ri ifNil: [COM.IRecordInfo on: self]!

RecordInit: pvNew
	"Implement the IRecordInfo::RecordInit() method for the UDT described by the receiver.
	Initialize a new empty buffer for a record of the receiver's type. This implementation is the
	simplest possible - it just zeros the whole area.

		HRESULT __stdcall RecordInit(
			[out] void* pvNew);
	"

	self init: pvNew.
	^0 "S_OK"
!

registerSubclasses
	"(Re)Register the receiver's subclasses as record classes with
	their appropriate GUIDs. This is intended as a helper function when
	developing, and has no run-time significance.

		self registerSubclasses
	"

	self initializeRegister.
	self allSubclassesDo: [:c | c register]!

supportedInterfaces
	"Private - Answer the set of interface classes supported by the receiver.
	Implementation Note: We aren't expecting that the implementation of IRecordInfo we provide will actually
	be used for getting and setting the values of fields in UDTs, but mainly provide it to make up for the 
	fact that the one type library we've so far experienced which makes heavy use of UDTs (i.e. the DX-7 VB
	library) does not contain sufficient information (mainly GUIDs) to allow the system implementation of
	IRecordInfo to be constructed on the ITypeInfo's of the various structures defined therein. This suggests
	that VB doesn't use the system implementation itself, as otherwise the type library would be useless. Also
	it seems that DX-7 actually ignores the IRecordInfo (perhaps not surprisingly for a C library), so it is only 
	really needed in order to create VT_RECORD SAFEARRAYs and VARIANTs."

	^{COM.IRecordInfo}!

typeInfo
	"Answer an <ITypeInfo> on the receiver's type information."

	^self typeInfoIfNone: [self error: 'No type information available']!

typeInfoIfNone: exceptionHandler
	"Answer an <ITypeInfo> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| assoc |
	^(assoc := self libraryAndIndex) isNil
		ifTrue: [exceptionHandler value]
		ifFalse: [assoc key typeInfoAt: assoc value]!

typeLib
	"Answer an <ITypeLib> on the receiver's type library,
	or <nil> if the receiver does not have a type library."

	| libAndIndex |
	libAndIndex := self libraryAndIndex.
	^libAndIndex isNil ifFalse: [libAndIndex key]!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	Generally speaking this is the class name."

	^self name!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_RECORD! !
!External.Structure class categoriesFor: #classForGUID:ifNone:!enquiries!private! !
!External.Structure class categoriesFor: #clearGuid!accessing!private! !
!External.Structure class categoriesFor: #finalRelease!public!realizing/unrealizing! !
!External.Structure class categoriesFor: #fromAddress:recordInfo:owner:!instance creation!public! !
!External.Structure class categoriesFor: #fromObject:!instance creation!public! !
!External.Structure class categoriesFor: #GetField:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetFieldNames:rgBstrNames:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetFieldNoCopy:szFieldName:pvarField:ppvDataCArray:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetGuid:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetName:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetSize:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #GetTypeInfo:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #initializeRegister!initializing!private! !
!External.Structure class categoriesFor: #IsMatchingType:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!External.Structure class categoriesFor: #pointerFieldType!constants!private! !
!External.Structure class categoriesFor: #PutField:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #PutFieldNoCopy:pvData:szFieldName:pvarField:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #queryInterface:!accessing-interfaces!public! !
!External.Structure class categoriesFor: #queryInterface:ifNone:!accessing!accessing-interfaces!public! !
!External.Structure class categoriesFor: #RecordClear:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #RecordCopy:pvNew:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #RecordCreate!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #RecordCreateCopy:ppvDest:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #RecordDestroy:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #recordInfo!accessing!public! !
!External.Structure class categoriesFor: #RecordInit:!COM Interfaces-IRecordInfo!public! !
!External.Structure class categoriesFor: #registerSubclasses!initializing!public! !
!External.Structure class categoriesFor: #supportedInterfaces!constants!private! !
!External.Structure class categoriesFor: #typeInfo!accessing!public! !
!External.Structure class categoriesFor: #typeInfoIfNone:!accessing!public! !
!External.Structure class categoriesFor: #typeLib!accessing!public! !
!External.Structure class categoriesFor: #typeName!constants!private! !
!External.Structure class categoriesFor: #vt!constants!public! !

!External.SWORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I2! !
!External.SWORD class categoriesFor: #typeName!constants!private! !
!External.SWORD class categoriesFor: #vt!constants!public! !

!External.UINT_PTR class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#uintptr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	"Note: The compiler will optimise out the conditional because it is constant."

	^VMConstants.IsWin64 ifTrue: [COM.AutomationConstants.VT_UI8] ifFalse: [COM.AutomationConstants.VT_UI4]! !
!External.UINT_PTR class categoriesFor: #typeName!constants!private! !
!External.UINT_PTR class categoriesFor: #vt!constants!public! !

!External.VOID class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#void!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_VOID! !
!External.VOID class categoriesFor: #typeName!constants!private! !
!External.VOID class categoriesFor: #vt!constants!public! !

!External.WORD class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#word!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_UI2! !
!External.WORD class categoriesFor: #typeName!constants!private! !
!External.WORD class categoriesFor: #vt!constants!public! !

!Kernel.SmalltalkLocale methodsFor!

variantBool: aBoolean
	^aBoolean class name! !
!Kernel.SmalltalkLocale categoriesFor: #variantBool:!constants!public! !

!OS.COM.BSTR methodsFor!

asSAFEARRAY
	"Answer the <SAFEARRAY> representation of the receiver.
	N.B. The result will be a single-dimensioed array of the variant representations
	of the receiver's elements, assuming that such a representation is possible."

	^SAFEARRAY withAll: self elementClass: SWORD!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_BSTR).
	This will also work fine for Utf16String."

	^VARIANT fromString: self! !
!OS.COM.BSTR categoriesFor: #asSAFEARRAY!converting!public! !
!OS.COM.BSTR categoriesFor: #asVariant!converting!public! !

!OS.COM.BSTR class methodsFor!

fromObject: anObject
	^self fromString: anObject!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY
		length: length
		vt: self vt
		elementClass: self!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#bstr!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_BSTR! !
!OS.COM.BSTR class categoriesFor: #fromObject:!instance creation!public! !
!OS.COM.BSTR class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!OS.COM.BSTR class categoriesFor: #typeName!constants!private! !
!OS.COM.BSTR class categoriesFor: #vt!constants!public! !

!OS.COM.CLSID class methodsFor!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver.
	Part of a double-dispatch protocol originating in SAFEARRAY>>length:elementClass:"

	^SAFEARRAY
		length: length
		vt: self vt
		elementClass: self!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AutomationConstants.VT_CLSID
! !
!OS.COM.CLSID class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!OS.COM.CLSID class categoriesFor: #vt!constants!public! !

!OS.COM.IErrorInfo class methodsFor!

fromEXCEPINFO: excepInfo guid: id
	"Answer a new instance of the receiver on a system extended error object
	with details from the <EXCEPINFO> structure, excepInfo."

	^(ICreateErrorInfo fromEXCEPINFO: excepInfo guid: id) errorInfo!

source: sourceString description: descriptionString helpContext: anInteger helpFile: helpFilePath guid: aGUID
	"Answer a new instance of the receiver encapsulating all of the specified details.
		ice := self source: 'Dolphin' description: 'It is all going horribly wrong' helpContext: 1 helpFile: nil guid: GUID newUnique.
	"

	| ice |
	ice := ICreateErrorInfo new.
	ice SetSource: sourceString.
	ice SetDescription: descriptionString.
	ice SetHelpContext: anInteger.
	ice SetHelpFile: helpFilePath.
	ice SetGuid: aGUID.
	^ice errorInfo! !
!OS.COM.IErrorInfo class categoriesFor: #fromEXCEPINFO:guid:!instance creation!public! !
!OS.COM.IErrorInfo class categoriesFor: #source:description:helpContext:helpFile:guid:!instance creation!public! !

!OS.COM.Interface methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self class errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the object on which the receiver is an interface."

	^(self queryInterface: IProvideClassInfo)
		ifNil: [self class coclassTypeInfoIfNone: [^exceptionHandler value]]
		ifNotNil: 
			[:ipc |
			[TypeInfoAnalyzer onTypeInfo: ipc getClassInfo] on: HRESULTError
				do: [:ex | ^exceptionHandler value]]!

typeInfo
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^self typeInfoIfNone: [self class errorNoTypeInfo]!

typeInfoIfNone: exceptionHandler
	"Answer any type information that exists for the receiver.
	Not all custom interfaces have an associated type library, but many do."

	^(self coclassTypeInfoIfNone: [^exceptionHandler value]) defaultInterface! !
!OS.COM.Interface categoriesFor: #coclassTypeInfo!accessing!public! !
!OS.COM.Interface categoriesFor: #coclassTypeInfoIfNone:!accessing!public! !
!OS.COM.Interface categoriesFor: #typeInfo!accessing!public! !
!OS.COM.Interface categoriesFor: #typeInfoIfNone:!accessing!public! !

!OS.COM.Interface class methodsFor!

coclassTypeInfo
	"Answer any type information that exists for the object on which the receiver is an interface."

	^self coclassTypeInfoIfNone: [self errorNoTypeInfo]!

coclassTypeInfoIfNone: exceptionHandler 
	"Answer any type information that exists for the object on which the receiver is the default interface.
	This link can only be made if the #clsid method is defined and a type library with the relevant
	information is available."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [tlb typeInfoForGuid: self clsid ifNone: [^exceptionHandler value]]!

errorNoTypeInfo
	"Private - Raise an exception to the effect that the receiver has no associated
	type information available."

	^self error: 'No type information available.'!

fromObject: anObject 
	"Answer an instance of the receiver whose value is the argument."

	^anObject queryInterface: self!

newSAFEARRAY: length
	"Answer a new SAFEARRAY initialized to hold <integer>, length, instances of the receiver."

	^SAFEARRAY length: length interfaceClass: self!

registerDispinterface: anIID
	"Register the specified <IID> as another dispinterface (i.e. an IID implemented by IDispatch)."

	InterfaceClasses at: anIID put: IDispatch!

typeInfoIfNone: exceptionHandler
	"Answer an <AXInterfaceTypeAnalyzer> on the receiver's type information,
	or if no type information is available the result of evaluating the
	<niladicValuable>, exceptionHandler."

	| tlb |
	^(tlb := self typeLib) isNil 
		ifTrue: [exceptionHandler value]
		ifFalse: [(tlb typeInfoForGuid: self guid ifNone: [^exceptionHandler value]) asImplType]!

typeLib
	"Answer an <AXTypeLibraryAnalyzer> on the receiver's type library,
	or nil if the receiver does not have a type library."

	^typeLib! !
!OS.COM.Interface class categoriesFor: #coclassTypeInfo!accessing!public! !
!OS.COM.Interface class categoriesFor: #coclassTypeInfoIfNone:!accessing!public! !
!OS.COM.Interface class categoriesFor: #errorNoTypeInfo!exceptions!private! !
!OS.COM.Interface class categoriesFor: #fromObject:!instance creation!public! !
!OS.COM.Interface class categoriesFor: #newSAFEARRAY:!double dispatch!public! !
!OS.COM.Interface class categoriesFor: #registerDispinterface:!adding!public! !
!OS.COM.Interface class categoriesFor: #typeInfoIfNone:!accessing!public! !
!OS.COM.Interface class categoriesFor: #typeLib!accessing!public! !

!OS.COM.IUnknown methodsFor!

asVariant
	"Answer the VARIANT representation of the receiver."

	^VARIANT fromUnknown: self! !
!OS.COM.IUnknown categoriesFor: #asVariant!converting!public! !

!OS.COM.IUnknown class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^AutomationConstants.VT_UNKNOWN! !
!OS.COM.IUnknown class categoriesFor: #vt!constants!public! !

!OS.COM.OLEAutLibrary methodsFor!

clearCustData: pCustData
	"WINOLEAUTAPI_(void) ClearCustData(LPCUSTDATA pCustData);"

	<stdcall: void ClearCustData CUSTDATA*>
	^self invalidCall: _failureCode!

createErrorInfo: pperrinfo
	"Loads _and registers_ a type library from the specified path.

		HRESULT CreateErrorInfo(
			ICrateErrorInfo**		pperrinfo
		)"

	<stdcall: hresult CreateErrorInfo lppvoid>
	^self invalidCall: _failureCode!

getRecordInfoFromTypeInfo: pTypeInfo ppRecInfo: ppRecInfo
	"Create a RecordInfo object on the specified ITypeInfo, and answer an <IRecordInfo> on it.
		HRESULT GetRecordInfoFromTypeInfo( 
			ITypeInfo  pTypeInfo,  
			IRecordInfo** ppRecInfo);"

	"Implementation Note: Answer an integer HRESULT code rather than raising an exception
	as it is most unusual for this call to succeed it would seem!!"

	<stdcall: sdword GetRecordInfoFromTypeInfo ITypeInfo* IRecordInfo**>
	^self invalidCall: _failureCode!

lHashValOfNameSys: syskind lcid: lcid szName: szNem
	"Calculate the hash value of a string.

		ULONG LHashValOfNameSys(
		SYSKIND syskind <>, 
		LCID lcid <>, 
		const OLECHAR FAR* szName <> ); 
		)"

	<stdcall: dword LHashValOfNameSys sdword sdword lpwstr>
	^self invalidCall: _failureCode!

loadRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid pptlib: pptlib
	"Load a type library from the registry entries corresponding to the specified LIBID,
	version information, and LCID.

		HRESULT LoadRegTypeLib(      REFGUID rguid, 
			unsigned short wVerMajor, 
			unsigned short wVerMinor, 
			LCID lcid, 
			ITypeLib FAR* FAR* pptlib 
		); "

	<stdcall: hresult LoadRegTypeLib guid* word word dword lppvoid>
	^self invalidCall: _failureCode!

loadTypeLib: szFileName pptlib: lplptlib
	<stdcall: hresult LoadTypeLib lpwstr lppvoid>
	^self invalidCall: _failureCode!

loadTypeLibEx: szFileName regkind: regkind pptlib: lplptlib
	"Loads, and optionally registers, a type library from the specified path.

		HRESULT LoadTypeLibEx(
			OLECHAR FAR*		szFileName,
			REGKIND				regkind,
			ITypeLib FAR* FAR*	pptlib
		)"

	<stdcall: hresult LoadTypeLibEx lpwstr sdword lppvoid>
	^self invalidCall: _failureCode!

oleCreateFontIndirect: pFontDesc riid: riid ppvObj: ppvObj
	"Create an OLE font object matching the supplied <FONTDESC>. 

		STDAPI OleCreateFontIndirect(
			FONTDESC* pFontDesc,
			REFIID riid,
			VOID** ppvObj);
 	"

	<stdcall: hresult OleCreateFontIndirect FONTDESC* guid* void**>
	^self invalidCall: _failureCode!

queryPathOfRegTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid lpbstrPathName: lpbstrPathName
	"Determine the path of a registered type library.
	Implementation Note: It is quite a common occurrence that the library not be registered
	on a particular machine, and using this function is the best way to find that out, therefore
	we define the return code as an integer rather than an HRESULT to avoid getting an
	exception.

	HRESULT QueryPathOfRegTypeLib(
		REFGUID guid,
		unsigned short wVerMajor,
		unsigned short wVerMinor,
		LCID lcid,
		LPBSTR lpbstrPathName);"

	<stdcall: sdword QueryPathOfRegTypeLib guid* word word dword bstr*>
	^self invalidCall: _failureCode!

registerTypeLib: ptlib wszFullPath: wszFullPath wszHelpDir: wszHelpDir
	"Invoke the RegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Adds information about a type library to the system registry

		HRESULT __stdcall RegisterTypeLib(
			ITypeLib* ptlib,
			LPWSTR wszFullPath,
			LPWSTR wszHelpDir);"

	<stdcall: sdword RegisterTypeLib ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

registerTypeLibForUser: ptlib szFullPath: szFullPath szHelpDir: szHelpDir
	"Invoke the RegisterTypeLibForUser() function of the module wrapped by the receiver.
	Helpstring: Registers a type library for use by the calling user.

		HRESULT __stdcall RegisterTypeLibForUser(
			ITypeLib* ptlib,
			LPWSTR szFullPath,
			LPWSTR szHelpDir);"

	<stdcall: hresult RegisterTypeLibForUser ITypeLib* lpwstr lpwstr>
	^self invalidCall: _failureCode!

safeArrayAccessData: psa ppvData: ppvData
	"Increment the lock count of an array, and return a pointer to the array data
	through the <ExternalAddress>, ppvData.

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayAccessData SAFEARRAY* lppvoid>
	^self invalidCall: _failureCode!

safeArrayCopy: psa ppsaout: ppsaout
	"Create a copy of a SAFEARRAY.

		HRESULT SafeArrayCopy( 
			SAFEARRAY *  psa,          
			SAFEARRAY **  ppsaOut  
		);"

	<stdcall: hresult SafeArrayCopy SAFEARRAY* SAFEARRAY**>
	^self invalidCall: _failureCode!

safeArrayCreateEx: vt cDims: cDims rgsabound: rgsabound pvExtra: anExternalAddressOfNil
	<stdcall: SAFEARRAY* SafeArrayCreateEx word sdword SAFEARRAYBOUND* lpvoid>
	^self invalidCall: _failureCode!

safeArrayCreateVectorEx: vt lLbound: lLbound cElements: cElements pvExtra: pvExtra
	"Create a one-dimensional SAFEARRAY.

		SAFEARRAY SafeArrayCreateVectorEx( 
			VARTYPE  vt,             
			long  lLbound,           
			unsigned int  cElements ,
			LPVOID pvExtra
		);"

	<stdcall: SAFEARRAY* SafeArrayCreateVectorEx sword sdword dword lpvoid>
	^self invalidCall: _failureCode!

safeArrayDestroy: psa
	"Tidy away a SAFEARRAY. May involve releasing objects, etc.

		HRESULT SafeArrayDestroy(SAFEARRAY FAR*  psa);
	"

	<stdcall: sdword SafeArrayDestroy SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetDim: psa
	"Answer the number of dimensions in a SAFEARRAY.

		UINT SafeArrayGetDim(SAFEARRAY FAR*  psa);
	"

	<stdcall: dword SafeArrayGetDim SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayGetElement: psa rgIndices: rgIndices pv: pv
	"Answer an individual element of the receiver as identified by the array
	of indices, rgIndices, through the buffer, pv.

		HRESULT SafeArrayGetElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayGetElement SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayGetIID: psa pguid: pguid
	"Get the IID of the FADF_HAVEIID safe array, psa, storing it 
	into the output parameter, pvt.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			GUID* pguid
		);"

	<stdcall: hresult SafeArrayGetIID SAFEARRAY* guid*>
	^self invalidCall: _failureCode!

safeArrayGetLBound: psa nDim: nDim plLbound: plLbound
	"Answer the lower bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plLbound..

		HRESULT SafeArrayGetLBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plLbound
		);"

	<stdcall: hresult SafeArrayGetLBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetRecordInfo: aSAFEARRAY prinfo: anIRecordInfo
	<stdcall: hresult SafeArrayGetRecordInfo SAFEARRAY* IRecordInfo**>
	^self invalidCall: _failureCode!

safeArrayGetUBound: psa nDim: nDim plUbound: plUbound
	"Answer the upper bound of the specified dimension of the <SAFEARRAY>,
	psa, through the <SDWORD> parameter, plUbound..

		HRESULT SafeArrayGetUBound(
			SAFEARRAY FAR* psa,
			unsigned int nDim,
			long FAR* plUbound
		);"

	<stdcall: hresult SafeArrayGetUBound SAFEARRAY* dword sdword*>
	^self invalidCall: _failureCode!

safeArrayGetVartype: psa pvt: pvt
	"Get the VARTYPE of the safe array, psa, storing it into the output parameter, pvt.

		HRESULT SafeArrayGetVartype(
			SAFEARRAY FAR* psa,
			VARTYPE* vt
		);"

	<stdcall: hresult SafeArrayGetVartype SAFEARRAY* word*>
	^self invalidCall: _failureCode!

safeArrayPtrOfIndex: aSAFEARRAY rgIndices: aSDWORDArray ppvData: anExternalAddress
	<stdcall: hresult SafeArrayPtrOfIndex SAFEARRAY* sdword* lppvoid>
	^self invalidCall: _failureCode!

safeArrayPutElement: psa rgIndices: rgIndices pv: pv
	"Replease the individual element of the receiver as identified by the array
	of indices, rgIndices, with the contents of the buffer pointed at by the
	<externalAddress>, pv.

		HRESULT SafeArrayPutElement( 
			SAFEARRAY FAR*  psa,  
			long FAR*  rgIndices, 
			void FAR*  pv         
		);"

	<stdcall: hresult SafeArrayPutElement SAFEARRAY* sdword* lpvoid>
	^self invalidCall: _failureCode!

safeArrayRedim: psa psaboundNew: psaboundNew
	"Resize the least significant bound of the SAFEARRAY, psa,
	to the lower bound and element count specified in the 
	SAFEARRAYBOUND, psaboundNew.

		HRESULT SafeArrayRedim(
			SAFEARRAY FAR* psa,
			SAFEARRAYBOUND psaboundNew
		);"

	<stdcall: hresult SafeArrayRedim SAFEARRAY* SAFEARRAYBOUND*>
	^self invalidCall: _failureCode!

safeArraySetIID: psa pguid: pguid
	"Set the IID of the FADF_HAVEIID safe array, psa.

		HRESULT SafeArrayGetIID(
			SAFEARRAY FAR* psa,
			REFGUID pguid
		);"

	<stdcall: hresult SafeArraySetIID SAFEARRAY* REFGUID>
	^self invalidCall: _failureCode!

safeArrayUnaccessData: psa
	"Reverse a previous SafeArrayAccessData.

		HRESULT SafeArrayUnaccessData(SAFEARRAY FAR*  psa);
	"

	<stdcall: hresult SafeArrayUnaccessData SAFEARRAY*>
	^self invalidCall: _failureCode!

safeArrayUnlock: psa
	<stdcall: hresult SafeArrayUnlock SAFEARRAY*>
	^self invalidCall: _failureCode!

setErrorInfo: dwReserved perrinfo: perrinfo
	"Set the current <IErrorInfo> pointer for the calling thread.

		HRESULT SetErrorInfo(
			DWORD			dwReserved,
			IErrorInfo*		perrinfo
		)"

	<stdcall: hresult GetErrorInfo dword IErrorInfo*>
	^self invalidCall: _failureCode!

systemTimeToVariantTime: lpSystemTime pvtime: pvtime
	"Convert the <SYSTEMTIME>, lpSystemTime, to an OLE format <DATE>,
	answering whether the conversion succeeded.

		INT SystemTimeToVariantTime(
			SYSTEMTIME  lpSystemTime  
			double  *pvtime           
		);"

	<stdcall: bool SystemTimeToVariantTime SYSTEMTIME* double*>
	^self invalidCall: _failureCode!

unRegisterTypeLib: rguid wVerMajor: wVerMajor wVerMinor: wVerMinor lcid: lcid syskind: syskind
	"Invoke the UnRegisterTypeLib() function of the module wrapped by the receiver.
	Helpstring: Removes type library information from the system registry.

		HRESULT __stdcall UnRegisterTypeLib(
			GUID* rguid,
			unsigned short wVerMajor,
			unsigned short wVerMinor,
			unsigned long lcid,
			SYSKIND syskind);"

	<stdcall: hresult UnRegisterTypeLib guid* word word dword sdword>
	^self invalidCall: _failureCode!

varBstrFromBool: boolIn lcid: lcid dwFlags: dwFlags pbstrOut: pbstrOut
	"HRESULT VarBstrFromBool(
		  VARIANT_BOOL boolIn,
		  LCID         lcid,
		  ULONG        dwFlags,
		  BSTR         *pbstrOut
		);
	"

	<stdcall: hresult VarBstrFromBool sword dword dword bstr*>
	^self invalidCall: _failureCode!

varCmp: pvarLeft pvarRight: pvarRight lcid: lcid dwFlags: dwFlags
	"Answer a comparison result between the two VARIANT arguments.

		HRESULT VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);
	"

	<stdcall: hresult VarCmp variant* variant* dword dword>
	^self invalidCall: _failureCode!

varDateFromStr: strIn lcid: lcid dwFlags: dwFlags pdateOut: aFloat
	"Convert from a string date representation to the OLE Automation date type,
	according to the users regional settings.

		HRESULT VarDateFromStr(OLECHAR* strIn, LCID lcid, DWORD dwFlags, DATE* pdateOut);"

	<stdcall: hresult VarDateFromStr lpwstr dword dword lpvoid>
	^self invalidCall: _failureCode!

variantChangeType: pvargDest pvarSrc: pvarSrc wFlags: wFlags vt: vt
	"Convert a variant from one type to another. 

		HRESULT VariantChangeType(
			VARIANTARG FAR* pvargDest, 
			VARIANTARG FAR* pvarSrc, 
			unsigned short wFlags, 
			VARTYPE vt 
		);"

	<stdcall: hresult VariantChangeType variant* variant* word sword>
	^self invalidCall: _failureCode!

variantChangeTypeEx: pvargDest pvarSrc: pvarSrc lcid: lcid wFlags: wFlags vt: vt
	"Converts a variant from one type to another, using an LCID.

		HRESULT VariantChangeTypeEx(
			VARIANTARG       	*pvargDest,
			const VARIANTARG *pvarSrc,
			LCID             		lcid,
			USHORT           	wFlags,
			VARTYPE          	vt
		);"

	<stdcall: hresult VariantChangeTypeEx variant* variant* dword word sword>
	^self invalidCall: _failureCode!

variantClear: pvarg
	"Free a VARIANT, performing any special clean up  required (such as 
	Release()ing an IUnknown/IDispatch).
	Implementation Note: As this is used to finalize VARIANTs and there
	is little we can do about a failure, we return an integer error code
	rather than automatically raising an exception.

		HRESULT VariantClear(VARIANTARG FAR* pvarg)"

	<stdcall: sdword VariantClear variant*>
	^self invalidCall: _failureCode!

variantCopy: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest.

		HRESULT VariantCopy(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopy variant* variant*>
	^self invalidCall: _failureCode!

variantCopyInd: pvargDesc pvargSrc: pvargSrc
	"Create a copy of the <VARIANT>, pvargSrc, in the <VARIANT>, pvargDest,
	where the copy is guaranteed not to be a VT_BYREF.

		HRESULT VariantCopyInd(
			VARIANTARG * pvargDest,
			VARIANTARG * pvargSrc );
	"

	<stdcall: hresult VariantCopyInd variant* variant*>
	^self invalidCall: _failureCode!

variantInit: pvarg
	"Initialize a VARIANT - sets the type tag to VT_EMPTY, but does not zero the
	data part of the union.

		void VariantInit(VARIANTARG FAR* pvarg)"

	<stdcall: void VariantInit variant*>
	^self invalidCall: _failureCode!

variantTimeToSystemTime: vtime lpSystemTime: lpSystemTime
	"Convert the OLE format date-time, vtime, to a SYSTEMTIME,
	answering whether the conversion succeeded.

		INT VariantTimeToSystemTime( 
			double  vtime,              
			LPSYSTEMTIME  lpSystemTime  
		);"

	<stdcall: bool VariantTimeToSystemTime double SYSTEMTIME*>
	^self invalidCall: _failureCode! !
!OS.COM.OLEAutLibrary categoriesFor: #clearCustData:!Automation Functions-Error Handling API!public! !
!OS.COM.OLEAutLibrary categoriesFor: #createErrorInfo:!Automation Functions-Error Handling API!public! !
!OS.COM.OLEAutLibrary categoriesFor: #getRecordInfoFromTypeInfo:ppRecInfo:!OLE Functions-OLE!public! !
!OS.COM.OLEAutLibrary categoriesFor: #lHashValOfNameSys:lcid:szName:!Automation Functions-Type Compilation And Library!primitives!public! !
!OS.COM.OLEAutLibrary categoriesFor: #loadRegTypeLib:wVerMajor:wVerMinor:lcid:pptlib:!Automation Functions-Type Compilation And Library!public! !
!OS.COM.OLEAutLibrary categoriesFor: #loadTypeLib:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
!OS.COM.OLEAutLibrary categoriesFor: #loadTypeLibEx:regkind:pptlib:!Automation Functions-Type Compilation And Library!primitives!public! !
!OS.COM.OLEAutLibrary categoriesFor: #oleCreateFontIndirect:riid:ppvObj:!OLE Functions-OLE!public! !
!OS.COM.OLEAutLibrary categoriesFor: #queryPathOfRegTypeLib:wVerMajor:wVerMinor:lcid:lpbstrPathName:!Automation Functions-Type Compilation And Library!public! !
!OS.COM.OLEAutLibrary categoriesFor: #registerTypeLib:wszFullPath:wszHelpDir:!Automation Functions-Type Compilation And Library!public! !
!OS.COM.OLEAutLibrary categoriesFor: #registerTypeLibForUser:szFullPath:szHelpDir:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayAccessData:ppvData:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayCopy:ppsaout:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayCreateEx:cDims:rgsabound:pvExtra:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayCreateVectorEx:lLbound:cElements:pvExtra:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayDestroy:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetDim:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetIID:pguid:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetLBound:nDim:plLbound:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetRecordInfo:prinfo:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetUBound:nDim:plUbound:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayGetVartype:pvt:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayPtrOfIndex:rgIndices:ppvData:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayPutElement:rgIndices:pv:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayRedim:psaboundNew:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArraySetIID:pguid:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayUnaccessData:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #safeArrayUnlock:!Automation Functions-Array Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #setErrorInfo:perrinfo:!Automation Functions-Error Handling API!public! !
!OS.COM.OLEAutLibrary categoriesFor: #systemTimeToVariantTime:pvtime:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #unRegisterTypeLib:wVerMajor:wVerMinor:lcid:syskind:!**auto generated**!Automation Functions-Type Compilation And Library!public! !
!OS.COM.OLEAutLibrary categoriesFor: #varBstrFromBool:lcid:dwFlags:pbstrOut:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #varCmp:pvarRight:lcid:dwFlags:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #varDateFromStr:lcid:dwFlags:pdateOut:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantChangeType:pvarSrc:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantChangeTypeEx:pvarSrc:lcid:wFlags:vt:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantClear:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantCopy:pvargSrc:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantCopyInd:pvargSrc:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantInit:!Automation Functions-Variant Manipulation!public! !
!OS.COM.OLEAutLibrary categoriesFor: #variantTimeToSystemTime:lpSystemTime:!Automation Functions-Variant Manipulation!public! !

!OS.FILETIME class methodsFor!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_FILETIME! !
!OS.FILETIME class categoriesFor: #vt!constants!public! !

!OS.HRESULT class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#hresult!

vt
	"Private - Answer the VARIANT type required to represent the receiver."

	^COM.AutomationConstants.VT_ERROR! !
!OS.HRESULT class categoriesFor: #typeName!constants!private! !
!OS.HRESULT class categoriesFor: #vt!constants!private! !

!OS.LARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#sqword!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^COM.AutomationConstants.VT_I8! !
!OS.LARGE_INTEGER class categoriesFor: #typeName!constants!private! !
!OS.LARGE_INTEGER class categoriesFor: #vt!constants!public! !

!OS.SYSTEMTIME methodsFor!

asFloat
	"Answer the OLEDATE representation of the receiver."

	| vtime |
	vtime := COM.DATE new.
	COM.OLEAutLibrary default systemTimeToVariantTime: self pvtime: vtime.
	^vtime!

asVariant
	"Answer the VARIANT representation of the receiver (a VT_DATE)"

	^COM.VARIANT fromDATE: self asFloat! !
!OS.SYSTEMTIME categoriesFor: #asFloat!converting!public! !
!OS.SYSTEMTIME categoriesFor: #asVariant!converting!public! !

!OS.SYSTEMTIME class methodsFor!

fromDATE: aFloat
	| systime |
	systime := self new.
	COM.OLEAutLibrary default variantTimeToSystemTime: aFloat lpSystemTime: systime.
	^systime! !
!OS.SYSTEMTIME class categoriesFor: #fromDATE:!public! !

!OS.ULARGE_INTEGER class methodsFor!

typeName
	"Private - Answer the Dolphin external type name for the receiver.
	There is an appropriate built-in type which we can substitute."

	^#qword! !
!OS.ULARGE_INTEGER class categoriesFor: #typeName!constants!private! !

!OS.WindowsLocale methodsFor!

boolFormat
	"Answer an <Array> of two <String>s, being the representations for false and true in this Locale."

	^{self variantBool: false. self variantBool: true}!

getVariantBoolString: anInteger
	| bstr str |
	bstr := COM.BSTR new.
	COM.OLEAutLibrary default
		varBstrFromBool: anInteger
		lcid: self lcid
		dwFlags: COM.AutomationConstants.VARIANT_LOCALBOOL
		pbstrOut: bstr.
	str := bstr asUtf8String.
	bstr free.
	^str!

variantBool: aBoolean
	^info at: aBoolean class name
		ifAbsentPutClean: 
			[self getVariantBoolString: (aBoolean
						ifTrue: [COM.AutomationConstants.VARIANT_TRUE]
						ifFalse: [COM.AutomationConstants.VARIANT_FALSE])]! !
!OS.WindowsLocale categoriesFor: #boolFormat!constants!public! !
!OS.WindowsLocale categoriesFor: #getVariantBoolString:!constants!public! !
!OS.WindowsLocale categoriesFor: #variantBool:!constants!public! !

"End of package definition"!

