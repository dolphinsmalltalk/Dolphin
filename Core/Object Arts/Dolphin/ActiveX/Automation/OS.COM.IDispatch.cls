"Filed out from Dolphin Smalltalk 7"!

OS.COM.IUnknown subclass: #'OS.COM.IDispatch'
	instanceVariableNames: 'typeInfo dispatchImplementor'
	classVariableNames: ''
	imports: #(#{OS.COM.AutomationConstants} #{OS.COM.AutomationErrors})
	classInstanceVariableNames: ''
	classConstants: {}!
OS.COM.IDispatch guid: (OS.COM.IID fromString: '{00020400-0000-0000-c000-000000000046}')!
OS.COM.IDispatch comment: '`IDispatch` is a wrapper class for the standard AX automation dynamic dispatch interface of the same name. It was generated from type information in the ''OLE Automation'' library, stdole2.tlb. It contains methods to invoke the member functions exposed by that interface.

IDL definition follows:
```
[
	object, 
	uuid(00020400-0000-0000-c000-000000000046), 
	restricted
]
interface IDispatch : IUnknown
 {
	[id(0x60010000), restricted]
	HRESULT __stdcall GetTypeInfoCount(
		[out]unsigned int* pctinfo);
	[id(0x60010001), restricted]
	HRESULT __stdcall GetTypeInfo(
		[in]unsigned int itinfo,
		[in]unsigned long lcid,
		[out]void** pptinfo);
	[id(0x60010002), restricted]
	HRESULT __stdcall GetIDsOfNames(
		[in]GUID* riid,
		[in]char** rgszNames,
		[in]unsigned int cNames,
		[in]unsigned long lcid,
		[out]long* rgdispid);
	[id(0x60010003), restricted]
	HRESULT __stdcall Invoke(
		[in]long dispidMember,
		[in]GUID* riid,
		[in]unsigned long lcid,
		[in]unsigned short wFlags,
		[in]DISPPARAMS* pdispparams,
		[out]VARIANT* pvarResult,
		[out]EXCEPINFO* pexcepinfo,
		[out]unsigned int* puArgErr);
};
```'!
!OS.COM.IDispatch categoriesForClass!COM-Interfaces! !
!OS.COM.IDispatch methodsFor!

_newEnum
	"Private - Answer the <IUnknown> of an Automation enumerator (i.e. an object which supports
	IEnumVARIANT>, that can be used to enumerate the elements of the receiver.
	N.B. This will raise an error if the receiver is not a collection.
	Subclasses generated by the Active-X  wizard may override this method with a more efficient
	dual interface call, and that too will answer an <IUnknown>."

	^(self getPropertyId: DISPID_NEWENUM)!

asImplType
	"Attempt to 'cast' the receiver down from IDispatch to its actual derived interface
	class if type information is available, and a wrapper class has previously been generated
	for the interface. This may be a bit slow, which is why we don't do it by default in 
	#asObject, but it can be very handy and is completely safe."

	^self notNull ifTrue: [
		self class == ##(self)
			ifTrue: [self downCast]
			ifFalse: [self]]
!

asVariant
	"Answer the VARIANT representation of the receiver."

	^VARIANT fromDispatch: self!

basicFree
	"Private - Free the receiver's external resources."

	typeInfo := nil.
	super basicFree!

basicInvokeId: id flags: wFlags parms: parms retVal: varRes
	| err ex hr |
	err := DWORD new.
	ex := EXCEPINFO new.
	hr := self
				Invoke: id
				riid: IID null
				lcid: NlsConstants.LOCALE_USER_DEFAULT
				wFlags: wFlags
				pdispparams: parms
				pvarResult: varRes
				pexcepinfo: ex
				puArgErr: err.
	^DISP_E_EXCEPTION = hr ifTrue: [self signalException: ex] ifFalse: [hr]!

contents
	"Answer a <sequencedReadableCollection> of the 'contents' of the receiver.
	This will raise an error if the receiver is not a collection."

	^self newEnum contents!

dispatchImplementor
	"Answer the <IDispatch> which is implements the IDispatch functions of
	the receiver, or nil if the receiver does not implement the IDispatch
	functions."

	dispatchImplementor isNil
		ifTrue: 
			[(self class ~~ IDispatch and: [(self class typeInfoIfNone: [^nil]) isDual])
				ifTrue: 
					[(dispatchImplementor := ForwardingDualInterfaceImplementation new)
						server: self implementor;
						interfaceClass: self class;
						interface: self]].
	^dispatchImplementor!

dispatchImplementor: anObject
	"Set the object which implements the IDispatch methods when the receiver is an interface
	onto a Dolphin server object (this may the same or different to the normal implementing object)."

	dispatchImplementor := anObject!

displayOn: aPuttableStream
	"Append to the <puttableStream> first argument a String whose characters are a representation of the receiver that an end-user might want to see."

	self isNull ifTrue: [aPuttableStream print: nil] ifFalse: [self displayValueOn: aPuttableStream]!

displayValueOn: aStream
	"Private - Append a user-friendly textual representation of the receiver's 'value' to aStream.
	Implementation Note: Follow the VB convention of representing an object by its DISPID_VALUE property, if it has one, but extend that to also try and print its contents if a collection and has no value."

	| value |
	[value := self value] on: HRESULTError
		do: 
			[:ex |
			[self contents displayOn: aStream] on: HRESULTError
				do: 
					[:ex2 |
					| name |
					name := (self coclassTypeInfoIfNone: [self class]) name.
					aStream
						nextPutAll: (name first isVowel ifTrue: ['an '] ifFalse: ['a ']);
						nextPutAll: name].
			^self].
	value displayOn: aStream!

doesNotUnderstand: aMessage
	"Sent to the receiver by the VM when a message sent to the receiver was not implemented by
	the receiver or its superclasses. In this case we assume this is an attempt at invoking a
	late-bound message, so we try invoking it in whatever ways might make sense for the number
	of arguments."

	| argc hr |
	self isExtensible ifFalse: [^super doesNotUnderstand: aMessage].
	argc := aMessage argumentCount.
	argc == 0
		ifTrue: 
			[(self idOfName: aMessage selector ifAbsent: [])
				ifNotNil: 
					[:dispid |
					"Note that getPropertyId: will also invoke zero arg methods successfully"
					^self getPropertyId: dispid]]
		ifFalse: 
			[(self idOfName: (aMessage selector upTo: $:) ifAbsent: [])
				ifNotNil: 
					[:dispid |
					| args |
					args := aMessage arguments.
					argc == 1
						ifTrue: 
							[| parms var |
							"One arg message could be a propset,
							 indexed propget, or a method call "
							var := args first asVariant.
							parms := DISPPARAMS new.
							parms propertyPutValue: var.
							hr := self
										basicInvokeId: dispid
										flags: (var vt == VT_DISPATCH ifTrue: [DISPATCH_PROPERTYPUTREF] ifFalse: [DISPATCH_PROPERTYPUT])
										parms: parms
										retVal: nil.
							hr >= 0 ifTrue: [^self].
							"Failed - try an indexed propget/method call (can do in one hit as flag combination is allowed by automation spec)"
							^self
								invokeId: dispid
								flags: ##(DISPATCH_PROPERTYGET | DISPATCH_METHOD)
								parms: (DISPPARAMS with: var)]
						ifFalse: 
							[argc == 2
								ifTrue: 
									[| parms var value item |
									"If two args, could be indexed propset or method call"
									value := args second.
									var := value asVariant.
									parms := DISPPARAMS new.
									item := args first.
									parms propertyPut: item value: var.
									hr := self
												basicInvokeId: dispid
												flags: (var vt == VT_DISPATCH ifTrue: [DISPATCH_PROPERTYPUTREF] ifFalse: [DISPATCH_PROPERTYPUT])
												parms: parms
												retVal: nil.
									hr >= 0 ifTrue: [^self].
									"Failed, try method call"
									^self
										invokeId: dispid
										with: item
										with: value]
								ifFalse: 
									[| retVal |
									">2 args, must be method call"
									retVal := VARIANT new.
									self
										invokeId: dispid
										flags: DISPATCH_METHOD
										parms: (DISPPARAMS withArguments: aMessage arguments)
										retVal: retVal.
									^retVal value]]]].
	^self basicDoesNotUnderstand: aMessage!

downCast
	"Attempt to 'cast' the receiver down to a derived dual interface class 
	if type information is available, and a wrapper class has previously been generated
	for the interface. Normally one would only send this to direct instances of IDispatch
	rather than subinstances, as it is effectively a no-op for most derived classes
	except where they too are base types."

	^self queryInterface: (self class classForIID: 
						(typeInfo isNil 
							ifTrue: [self getTypeInfo: 0 ifNone: [^self]]
							ifFalse: [self typeInfoIfNone: [^self]]) guid
						ifNone: [^self])!

getIDsOfNames: names
	"Answer a <sequencedReadableCollection> of the ids of the named
	members of the receiver."

	| rgszNames uNames cNames rgDispId hr |
	uNames := names collect: [:p | p asUtf16String].
	cNames := names size.
	rgszNames := DWORDArray new: cNames.
	uNames keysAndValuesDo: [:i :n | rgszNames at: i put: n yourAddress].
	rgDispId := SDWORDArray new: cNames.
	hr := self
				GetIDsOfNames: IID null
				rgszNames: rgszNames
				cNames: cNames
				lcid: NlsConstants.LOCALE_USER_DEFAULT
				rgdispid: rgDispId.
	^hr < 0
		ifTrue: [hr = DISP_E_UNKNOWNNAME ifTrue: [self errorNotFound: names] ifFalse: [self hresultError: hr]]
		ifFalse: 
			["Convert to a standard Smalltalk Array"
			rgDispId collect: [:m | m]]!

GetIDsOfNames: riid rgszNames: rgszNames cNames: cNames lcid: lcid rgdispid: rgdispid
	"Private - Invoke the GetIDsOfNames() method of the COM object wrapped by the receiver.

		HRESULT __stdcall GetIDsOfNames(
			[in] GUID* riid,
			[in] char** rgszNames,
			[in] unsigned int cNames,
			[in] unsigned long lcid,
			[out] long* rgdispid);

	Implementation Note: Not finding names not exceptional, so return integer and test
	rather than auto-raised HRESULT exception.
	"

	<virtual stdcall: sdword 6 guid* char** dword dword sdword*>
	^self invalidCall: _failureCode!

getProperty: aString
	"Answer the named property from the receiver."

	^self getPropertyId: (self idOfName: aString)!

getProperty: aString item: item
	"Answer the named property from the receiver and the variant item subscript, item."

	^self getPropertyId: (self idOfName: aString) item: item!

getPropertyId: dispid
	"Answer the property from the receiver with the <Integer> DISPID, dispid."

	^self
		invokeId: dispid
		flags: ##(DISPATCH_PROPERTYGET | DISPATCH_METHOD)
		parms: DISPPARAMS zeroArgs!

getPropertyId: dispid item: item
	"Answer the property from the receiver with the <Integer> DISPID, dispid,
	and the variant item subscript, item."

	^self
		invokeId: dispid
		flags: DISPATCH_PROPERTYGET
		parms: (DISPPARAMS with: item)!

getPropertyId: dispid withArguments: subscripts
	"Answer the property from the receiver with the <Integer> DISPID, dispid,
	and the specified subscripts."

	^self
		invokeId: dispid
		flags: DISPATCH_PROPERTYGET
		parms: (DISPPARAMS withArguments: subscripts)!

getPropertyObj: interfaceClass id: dispid
	"Private - Answer a <COMInterface> of the type, interfaceClass, on the object property 
	of the receiver with the <Integer> DISPID, dispid.
	N.B. This method is private because it is effectively a static cast, and therefore potentially
	unsafe. It assumes that the caller knows that the property really is either an interface of 
	the specified type (or nil). If you are not sure of the type of the property (or it may vary)
	you must use #queryInterface:&c."


	| obj |
	obj := self getPropertyId: dispid.
	^obj isNil ifFalse: [interfaceClass attach: obj detach]!

getPropertyObj: interfaceClass id: dispid item: item
	"Private - Answer a <COMInterface> of the type, interfaceClass, on the object property 
	of the receiver with the <Integer> DISPID, dispid, and the <variantCompatible>
	item subscript, item.
	N.B. This method is private because it is effectively a static cast, and therefore potentially
	unsafe. It assumes that the caller knows that the property really is either an interface of 
	the specified type (or nil). If you are not sure of the type of the property (or it may vary)
	you must use #queryInterface:&c."

	| obj |
	obj := self getPropertyId: dispid item: item.
	^obj isNil ifFalse: [interfaceClass attach: obj detach]!

getTypeInfo: lcid ifNone: exceptionHandler
	"Private - Answer the receiver's type info for the <Locale>, lcid,
	or if there is none, the result of evaluating the <niladicValuable>,
	exceptionHandler."

	| answer hr |
	answer := ITypeInfo newPointer.
	hr := self
				GetTypeInfo: 0
				lcid: lcid asParameter
				pptinfo: answer.
	^(hr < 0 or: [answer isNull]) ifTrue: [exceptionHandler value] ifFalse: [answer]!

GetTypeInfo: itinfo lcid: lcid pptinfo: pptinfo
	"Private - Invoke the GetTypeInfo() method of the COM object wrapped by the receiver.

		HRESULT __stdcall GetTypeInfo(
			[in] unsigned int itinfo,
			[in] unsigned long lcid,
			[out] void** pptinfo);
	"

	<virtual stdcall: sdword 5 dword dword void**>
	^self invalidCall: _failureCode!

getTypeInfoCount
	"Answer the <DWORD> result of invoking the GetTypeInfoCount() method of the COM object."

	| answer |
	answer := DWORD new.
	self GetTypeInfoCount: answer.
	^answer asObject!

GetTypeInfoCount: pctinfo
	"Private - Invoke the GetTypeInfoCount() method of the COM object.

		HRESULT __stdcall GetTypeInfoCount(
			[out]unsigned int* pctinfo);"

	<virtual stdcall: hresult 4 dword*>
	^self invalidCall: _failureCode!

has_NewEnum
	"Private - Answer whether the receiver has a standard _NewEnum property,
	which suggests that it is a collection."

	^(self idOfName: '_NewEnum' ifAbsent: [^false]) = DISPID_NEWENUM!

hasTypeInfo
	"Answer whether the receiver has type information available."

	^self notNull and: [self getTypeInfoCount > 0]!

idOfName: name
	"Answer the <integer> DISPID of the member named by the <readableString>
	argument, name, in the receiver."

	^self idOfName: name ifAbsent: [self errorNotFound: name]!

idOfName: name ifAbsent: exceptionHandler
	"Answer the <integer> DISPID of the member named by the <readableString>
	argument, name, in the receiver.
	Implementation Note: Although implementable in terms of #getIDsOfNames:, this
	is much faster for the common case of looking up a single name."

	| uName dispId hr |
	uName := name asUtf16String.
	dispId := SDWORD new.
	hr := self
				GetIDsOfNames: IID null
				rgszNames: (DWORD fromInteger: uName yourAddress)
				cNames: 1
				lcid: NlsConstants.LOCALE_USER_DEFAULT
				rgdispid: dispId.
	^hr < 0
		ifTrue: [hr = DISP_E_UNKNOWNNAME ifTrue: [exceptionHandler value] ifFalse: [self hresultError: hr]]
		ifFalse: 
			[dispId := dispId asInteger.
			^dispId == DISPID_UNKNOWN
				ifTrue: 
					["Control should have returned DISP_E_UNKNOWNNAME, but sometimes they don't"
					exceptionHandler value]
				ifFalse: [dispId]]!

implementor: anObject
	"Set the receiver's implementor to anObject."

	super implementor: anObject.
	dispatchImplementor isNil ifTrue: [self dispatchImplementor: anObject]!

invoke: methodName
	"Invoke the method with <Integer> DISPID, id, with no arguments."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: DISPPARAMS zeroArgs!

Invoke: dispidMember riid: riid lcid: lcid wFlags: wFlags pdispparams: pdispparams pvarResult: pvarResult pexcepinfo: pexcepinfo puArgErr: puArgErr
	"Private - Invoke the Invoke() method of the COM object wrapped by the receiver.

		HRESULT __stdcall Invoke(
			[in] long dispidMember,
			[in] GUID* riid,
			[in] unsigned long lcid,
			[in] unsigned short wFlags,
			[in] DISPPARAMS* pdispparams,
			[out] VARIANT* pvarResult,
			[out] EXCEPINFO* pexcepinfo,
			[out] unsigned int* puArgErr);

	Implementation Note: Explicitly handle integer return codes rather than use auto-raised HRESULT exception.
	"

	<virtual stdcall: sdword 7 sdword guid* dword word DISPPARAMS* variant* EXCEPINFO* dword*>
	^self invalidCall: _failureCode!

invoke: methodName with: arg1
	"Invoke the method with <Integer> DISPID, id, and the single <variantCompatible>
	argument, arg1. This is much like #perform:with: for a dispatch interface."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS with: arg1)!

invoke: methodName with: arg1 with: arg2
	"Invoke the method with <Integer> DISPID, id, and the pair of <variantCompatible>
	arguments, arg1 and arg2. This is much like #perform:with:with: for a dispatch interface."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: {arg1. arg2})!

invoke: methodName with: arg1 with: arg2 with: arg3
	"Invoke the method with <Integer> DISPID, id, and the pair of <variantCompatible>
	arguments, arg1 and arg2. This is much like #perform:with:with: for a dispatch interface."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: {arg1. arg2. arg3})!

invoke: methodName with: arg1 with: arg2 with: arg3 with: arg4
	"Invoke the method with <Integer> DISPID, id, and the pair of <variantCompatible>
	arguments, arg1 and arg2. This is much like #perform:with:with: for a dispatch interface."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: {arg1. arg2. arg3. arg4})!

invoke: methodName withArguments: args
	"Invoke the method with the <readableString> name, methodName, and the <Array> of 
	<variantCompatible> arguments, args. This is much like #perform:withArguments: for a 
	dispatch interface."

	^self
		invokeId: (self idOfName: methodName)
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: args)!

invokeId: id
	"Invoke the method with <Integer> DISPID, id, with no arguments.
	This is much like #perform: for a dispatch interface."

	^self
		invokeId: id
		flags: DISPATCH_METHOD
		parms: DISPPARAMS zeroArgs!

invokeId: id flags: wFlags parms: parms
	"Invoke the method with <Integer> DISPID, id, the <integer> flags, wFlags,
	and the parameters described by the <DISPPARAMS> argument, parms. Answers the result
	of the invocation if successful, or raises an HRESULTError. The error contains
	any extended error information reported by the object.
	Implementation Note: There is need to coerce the supplied arguments to
	the expected types, since the automation server should do that for us (basically
	through VariantChangeType). "

	| retVal |
	retVal := VARIANT new.
	self
		invokeId: id
		flags: wFlags
		parms: parms
		retVal: retVal.
	^retVal value!

invokeId: id flags: wFlags parms: parms retVal: varRes
	"Invoke the method with <Integer> DISPID, id, the <integer> flags, wFlags,
	and the parameters described by the <DISPPARAMS> argument, parms. Answers the
	receiver. If the <VARIANT> argument, varRes, is non-nil, then it will be populated with 
	the result of the invocation. If the invocation is not successful an HRESULTError is 
	raised that contains any extended error information reported by the object.
	Implementation Note: There is no need to coerce the supplied arguments to
	the expected types, since the automation server should do that for us (basically
	through VariantChangeType)."

	| hr |
	hr := self 
				basicInvokeId: id
				flags: wFlags
				parms: parms
				retVal: varRes.
	hr < 0 ifTrue: [HRESULTError signalWith: hr]!

invokeId: anInteger with: anObject
	"Invoke the method with <Integer> DISPID, id, and the single <variantCompatible>
	argument, arg1. This is much like #perform:with: for a dispatch interface."

	^self
		invokeId: anInteger
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS with: anObject)!

invokeId: id with: arg1 with: arg2
	"Invoke the method with <Integer> DISPID, id, and the pair of <variantCompatible>
	arguments, arg1 and arg2. This is much like #perform:with:with: for a dispatch interface."

	^self
		invokeId: id
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: {arg1. arg2})!

invokeId: id with: arg1 with: arg2 with: arg3
	"Invoke the method with <Integer> DISPID, id, and the triplet of <variantCompatible>
	arguments, arg1, arg2, and arg3. This is much like #perform:with:with:with: for a 
	dispatch interface."

	^self
		invokeId: id
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: {arg1. arg2. arg3})!

invokeId: id withArguments: args
	"Invoke the method with <Integer> DISPID, id, and the <Array> of <variantCompatible>
	arguments, args. This is much like #perform:withArguments: for a dispatch interface."

	^self
		invokeId: id
		flags: DISPATCH_METHOD
		parms: (DISPPARAMS withArguments: args)!

isExtensible
	"Answer whether the receiver may add methods at run-time for which 
	static type information was not available. This affects whether or not
	#doesNotUnderstand: processing comes into play."

	^true!

isVBCollection
	"Answer whether the receiver is VB-style collection as determined by whether
	it implements a _NewEnum property (DISPID_NEWENUM)."

	^self has_NewEnum!

newEnum
	"Answer an <IEnumVARIANT> that can be used to enumerate the elements of the 
	receiver. N.B. This will raise an error if the receiver is not a collection."

	^self _newEnum queryInterface: IEnumVARIANT!

printValueOn: aStream
	"Private - Append a developer friendly textual representation of the receiver's
	'value' to aStream. This is intended to provide more information for the developer
	to assist him or her in identifying the object.
	Implementation Note: Follow the VB convention of representing an object by
	its DISPID_VALUE property, if it has one, but extend that to also try and print
	its contents if a collection and has no value."

	| value |
	[value := self value] on: Error
		do: 
			[:ex | 
			[self contents printOn: aStream] on: Error do: [:ex2 | aStream print: bytes].
			^self].
	value printOn: aStream!

setProperty: aString item: subscript value: value
	"Set the value of the named property of the receiver, as subscripted by the 
	<variantCompatible>, subscript, to the <variantCompatible>, value."

	^self setPropertyId: (self idOfName: aString) item: subscript value: value!

setProperty: aString value: value
	"Set the value of the named property of the receiver to the <variantCompatible>, value."

	^self setPropertyId: (self idOfName: aString) value: value!

setPropertyId: dispid item: item value: value
	"Set the value of the property of the receiver with 
	<integer> DISPID, dispid, and <VARIANT> subscript, item,
	to the <VARIANT> representation of the <Object>, value."

	| parms var |
	var := value asVariant.
	parms := DISPPARAMS new.
	parms propertyPut: item value: var.
	self
		invokeId: dispid
		flags: (var vt == VT_DISPATCH ifTrue: [DISPATCH_PROPERTYPUTREF] ifFalse: [DISPATCH_PROPERTYPUT])
		parms: parms
		retVal: nil!

setPropertyId: dispid value: value
	"Set the value of the property of the receiver with <integer> DISPID, dispid, to the 
	VARIANT representation of the <Object>, value."

	| parms var |
	var := value asVariant.
	parms := DISPPARAMS new.
	parms propertyPutValue: var.
	self
		invokeId: dispid
		flags: (var vt == VT_DISPATCH ifTrue: [DISPATCH_PROPERTYPUTREF] ifFalse: [DISPATCH_PROPERTYPUT])
		parms: parms
		retVal: nil!

setPropertyId: dispid withArguments: items value: value
	"Set the value of the property of the receiver with
	<integer> DISPID, dispid, and the <Array> of <VARIANT> 
	subscripts, items, to the <VARIANT> representation of the 
	<Object>, value."

	| parms var |
	var := value asVariant.
	parms := DISPPARAMS new.
	parms
		names: {DISPID_PROPERTYPUT}
		named: {var}
		args: items.
	self
		invokeId: dispid
		flags: (var vt == VT_DISPATCH ifTrue: [DISPATCH_PROPERTYPUTREF] ifFalse: [DISPATCH_PROPERTYPUT])
		parms: parms
		retVal: nil!

signalException: anEXCEPINFO 
	^(HRESULTError new)
		errorInfo: anEXCEPINFO;
		hresult: anEXCEPINFO hresult;
		signal!

typeInfoIfNone: exceptionHandler
	"Almost all IDispatch interfaces have a single ITypeInfo, so answer that wrapped
	in an <AXInterfaceTypeAnalyzer>.  Since it may be quite useful, we'll cache it. If 
	no type information is available, then answer the result of evaluating the <niladicValuable>,
	exceptionHandler."

	typeInfo isNull
		ifTrue: 
			[| piTypeInfo |
			piTypeInfo := self getTypeInfo: NlsConstants.LOCALE_USER_DEFAULT
						ifNone: [^super typeInfoIfNone: [^exceptionHandler value]].
			typeInfo := (TypeInfoAnalyzer onTypeInfo: piTypeInfo) defaultInterface].
	^typeInfo!

value
	"Answer the special property which is the default value for the receiver.
	Raise an HRESULTError if the receiver does not have  a default value property."

	^self getPropertyId: DISPID_VALUE!

value: value
	"Set the special property which is the default value for the receiver.
	Raise an HRESULTError if the receiver does not have  a default value property."

	self setPropertyId: DISPID_VALUE value: value! !
!OS.COM.IDispatch categoriesFor: #_newEnum!enumerating!private! !
!OS.COM.IDispatch categoriesFor: #asImplType!converting!public! !
!OS.COM.IDispatch categoriesFor: #asVariant!converting!public! !
!OS.COM.IDispatch categoriesFor: #basicFree!private!realizing/unrealizing! !
!OS.COM.IDispatch categoriesFor: #basicInvokeId:flags:parms:retVal:!dispatching!private! !
!OS.COM.IDispatch categoriesFor: #contents!accessing!public! !
!OS.COM.IDispatch categoriesFor: #dispatchImplementor!accessing!public! !
!OS.COM.IDispatch categoriesFor: #dispatchImplementor:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #displayOn:!printing!public! !
!OS.COM.IDispatch categoriesFor: #displayValueOn:!printing!private! !
!OS.COM.IDispatch categoriesFor: #doesNotUnderstand:!exceptions!public! !
!OS.COM.IDispatch categoriesFor: #downCast!converting!public! !
!OS.COM.IDispatch categoriesFor: #getIDsOfNames:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #GetIDsOfNames:rgszNames:cNames:lcid:rgdispid:!COM Interfaces-IDispatch!methods!private! !
!OS.COM.IDispatch categoriesFor: #getProperty:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #getProperty:item:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #getPropertyId:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #getPropertyId:item:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #getPropertyId:withArguments:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #getPropertyObj:id:!accessing!private! !
!OS.COM.IDispatch categoriesFor: #getPropertyObj:id:item:!dispatching!private! !
!OS.COM.IDispatch categoriesFor: #getTypeInfo:ifNone:!accessing!private! !
!OS.COM.IDispatch categoriesFor: #GetTypeInfo:lcid:pptinfo:!COM Interfaces-IDispatch!methods!private! !
!OS.COM.IDispatch categoriesFor: #getTypeInfoCount!**auto generated**!methods!public! !
!OS.COM.IDispatch categoriesFor: #GetTypeInfoCount:!**auto generated**!COM Interfaces-IDispatch!private! !
!OS.COM.IDispatch categoriesFor: #has_NewEnum!private!testing! !
!OS.COM.IDispatch categoriesFor: #hasTypeInfo!public!testing! !
!OS.COM.IDispatch categoriesFor: #idOfName:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #idOfName:ifAbsent:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #implementor:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #invoke:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #Invoke:riid:lcid:wFlags:pdispparams:pvarResult:pexcepinfo:puArgErr:!COM Interfaces-IDispatch!methods!private! !
!OS.COM.IDispatch categoriesFor: #invoke:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invoke:with:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invoke:with:with:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invoke:with:with:with:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invoke:withArguments:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:flags:parms:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:flags:parms:retVal:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:with:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:with:with:with:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #invokeId:withArguments:!dispatching!public! !
!OS.COM.IDispatch categoriesFor: #isExtensible!public!testing! !
!OS.COM.IDispatch categoriesFor: #isVBCollection!public!testing! !
!OS.COM.IDispatch categoriesFor: #newEnum!enumerating!public! !
!OS.COM.IDispatch categoriesFor: #printValueOn:!printing!private! !
!OS.COM.IDispatch categoriesFor: #setProperty:item:value:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #setProperty:value:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #setPropertyId:item:value:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #setPropertyId:value:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #setPropertyId:withArguments:value:!accessing!properties!public! !
!OS.COM.IDispatch categoriesFor: #signalException:!dispatching!private! !
!OS.COM.IDispatch categoriesFor: #typeInfoIfNone:!accessing!public! !
!OS.COM.IDispatch categoriesFor: #value!accessing!public! !
!OS.COM.IDispatch categoriesFor: #value:!accessing!public! !

OS.COM.IDispatch methodProtocol: #IDispatch attributes: #(#readOnly) selectors: #(#GetIDsOfNames:rgszNames:cNames:lcid:rgdispid: #GetTypeInfo:lcid:pptinfo: #GetTypeInfoCount: #Invoke:riid:lcid:wFlags:pdispparams:pvarResult:pexcepinfo:puArgErr:)!

!OS.COM.IDispatch class methodsFor!

defineFunctions
	"Declare the virtual function table for the COM interface 'stdole.IDispatch'
		IDispatch withAllSubclassesDo: [:e | e defineVTable]

	N.B. This was originally generated from a type library, but has subsequently been modified,
	hence moved out of '**auto generated**' category to avoid being overwritten in future.
	"

	self
		defineFunction: #GetTypeInfoCount:
			type: DispatchFunction
			returnType: 'hresult'
			argumentTypes: 'dword*';
		defineFunction: #GetTypeInfo:lcid:pptinfo:
			type: DispatchFunction
			returnType: 'sdword'
			argumentTypes: 'dword dword void**';
		defineFunction: #GetIDsOfNames:rgszNames:cNames:lcid:rgdispid:
			type: DispatchFunction
			returnType: 'sdword'
			argumentTypes: 'GUID* char** dword dword sdword*';
		defineFunction: #Invoke:riid:lcid:wFlags:pdispparams:pvarResult:pexcepinfo:puArgErr:
			type: DispatchFunction
			returnType: 'sdword'
			argumentTypes: 'sdword GUID* dword word DISPPARAMS* VARIANT* EXCEPINFO* dword*'	"Many objects have no type info"	"Failue is common, so don't want automatic exception"	"Ditto"!

uninitialize
	"Private - Uninitialize the receiver prior to its removal from the image."

	VMLibrary default registryAt: self name put: nil!

vt
	"Answer the VARTYPE (one of the VT_XXX constants) used to describe the receiver's 
	type when represented in a <VARIANT>."

	^VT_DISPATCH! !
!OS.COM.IDispatch class categoriesFor: #defineFunctions!initializing!public! !
!OS.COM.IDispatch class categoriesFor: #uninitialize!class hierarchy-removing!private! !
!OS.COM.IDispatch class categoriesFor: #vt!constants!public! !

