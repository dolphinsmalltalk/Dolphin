| package |
package := Package name: 'Known Failing Tests'.
package paxVersion: 1;
	basicComment: 'These tests are known failures that have not yet been debugged or resolved. In general these tests should pass and are therefre in need of some debugging effort so that they may be reintroduced into the fold. This package is not loaded during normal regression testing (for obvious reasons).'.


package methodNames
	add: #BlockClosureTest -> #testFullBlockEquality;
	add: #DictionaryTest -> #testNilKey;
	add: #EvaluationConverterTest -> #testWithDates;
	add: #GdiplusBitmapTest -> #testAsByteArray;
	add: #MemoryMappedFileTest -> #testDoubleArray;
	add: #MemoryMappedFileTest -> #testMaximumSize;
	add: #NumberTest -> #testClassReadFromColonScaledDecimals;
	add: #ProcessTest -> #testOverlappedErrno;
	add: #SmallIntegerTest -> #testSubtract;
	add: #VMTest -> #testImmutableNextPutAll;
	add: #VMTest -> #testImmutableReplacePrimitives;
	add: #VMTest -> #testLoopsInterruptible;
	add: #ZLibTest -> #testCompressUncompress;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\IDE\Base\Development System Tests';
	add: '..\Base\Dolphin';
	add: '..\Base\Dolphin Base Tests';
	add: '..\System\Win32\Dolphin Memory-Mapped Files';
	add: '..\System\Win32\Dolphin MMF Tests';
	add: '..\MVP\Gdiplus\Gdiplus';
	add: '..\MVP\Gdiplus\Tests\Gdiplus Tests';
	add: '..\..\..\Contributions\ITC Gorisek\ZLib Interface';
	yourself).

package!

"Class Definitions"!


"Global Aliases"!


"Loose Methods"!

!BlockClosureTest methodsFor!

testFullBlockEquality
	| block1 block2 count block3 |
	count := 1.
	block1 := [count := count + 1].
	block2 := [count := count + 1].
	block3 := [ | tmp | tmp := 1. count := count + tmp. tmp].
	self assert: block1 = block2.
	self assert: block1 ~= block3! !
!BlockClosureTest categoriesFor: #testFullBlockEquality!public!unit tests-known failures! !

!DictionaryTest methodsFor!

testNilKey
	| dictionary |
	dictionary := self newEmpty.
	self should: [dictionary at: nil put: 1] raise: Error.
	self should: [dictionary at: nil ifAbsentPut: [1]] raise: Error! !
!DictionaryTest categoriesFor: #testNilKey!public!unit tests! !

!EvaluationConverterTest methodsFor!

testWithDates
	self checkWith: 'Date fromString: ''12 August 1958'''.
	self checkWith: 'Date today'! !
!EvaluationConverterTest categoriesFor: #testWithDates!public! !

!GdiplusBitmapTest methodsFor!

testAsByteArray
	| b1 b2 |
	model := GdiplusBitmap fromFile: self fileResource pafRgb0000FF_100x100bmp.
	b1 := model asByteArray: 'image/bmp'.
	b2 := self fileResource rgb0000FF_100x100bmpBytes.
	self assert: b1 size = b2 size.
	"difference is in the first 100 bytes ... what is the problem?"
	self assert: b1 = b2! !
!GdiplusBitmapTest categoriesFor: #testAsByteArray!public!unit tests! !

!MemoryMappedFileTest methodsFor!

testDoubleArray
	| data array file fname mmf view array2 f |
	data := Random new next: 10000.
	array := DOUBLEArray withAll: data.
	file := File temporary.
	file write: array bytes.
	fname := file name.
	file close.
	file := File open: fname.
	mmf := MemoryMappedFile onFile: file.
	view := mmf mapView.
	array2 := DOUBLEArray fromAddress: view length: 10000.
	self assert: array2 = array.
	"Write through the view"
	array2 at: 1 put: 123.45.
	mmf free.
	view free.
	file close.
	self should: [array2 last] raise: GPFault.
	file := File open: fname.
	f := Float new.
	file read: f.
	self assert: f = 123.45.
	file close.
	"If this fails then one or other thing is holding the file open"
	File delete: fname!

testMaximumSize
	| array file fname mmf view count |
	fname := File temporaryFilename.
	mmf := MemoryMappedFile open: fname.
	"Choose size to be exactly one allocation block so that read/write off the end will cause a fault"
	count := 64 * 1024 / 4.
	mmf maximumSize: 4 * count.
	view := mmf mapView.
	array := DWORDArray fromAddress: view length: count.
	1 to: count do: [:each | array at: each put: each].
	self assert: array asArray = (1 to: count).
	"Now try and read/write off the end - it seems there is some slush (uh oh) but we can make it GPF by writing far enough away"
	array basicLength: count * 2.
	self should: [array at: count + 1] raise: GPFault.
	self should: [#(1 1024 2048 2049) do: [:each | array at: count + each put: count + each]]
		raise: GPFault.
	mmf free.
	view free.
	self should: [array at: count] raise: GPFault.
	(MemoryManager current)
		collectGarbage;
		administerLastRites.
	file := FileStream read: fname text: false.
	self assert: file size = (count * 4).
	array := (1 to: count) collect: [:each | file nextDWORD].
	self assert: array = (1 to: count).
	file close.
	"If this fails then one or other thing is holding the file open"
	File delete: fname! !
!MemoryMappedFileTest categoriesFor: #testDoubleArray!public! !
!MemoryMappedFileTest categoriesFor: #testMaximumSize!public! !

!NumberTest methodsFor!

testClassReadFromColonScaledDecimals
	"Test Number>>readFrom: with ScaledDecimals"

	| source result |

	"ScaledDecimal with decimalInteger mantissa and implied scale of zero"
	source := '123s' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 0).
	self assert: (result = 123).
	self assert: (source atEnd).

	source := '123se' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 0).
	self assert: (result = 123).
	self assert: (source next = $e).

	"ScaledDecimal with decimalInteger mantissa and explicit scale"
	source := '123s2' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 2).
	self assert: (result = 123.0).
	self assert: (source atEnd).

	"Negative scale is not valid"
	source := '123s-2' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 0).
	self assert: (result = 123).
	self assert: (source upToEnd = '-2').

	"ScaledDecimals with Float mantissa and implicit scale"
	source := '123.0s' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 1).
	self assert: (result = 123.0).
	self assert: (source atEnd).

	source := '123.12s' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 2).
	self assert: (result = 123.12).
	self assert: (source atEnd).

	source := '123.12s3' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 3).
	self assert: (result = 123.12).
	self assert: (source atEnd).

	"ScaledDecimals with Float mantissa and explicit scale"
	source := '123.0s' readStream.
	result := Number readFrom: source.
	self assert: (result class == ScaledDecimal).
	self assert: (result scale = 1).
	self assert: (result = 123.0).
	self assert: (source atEnd).

	"Not valid (parsed as Integer)"
	source := '123.s' readStream.
	result := Number readFrom: source.
	self assert: (result == 123).
	self assert: (source upToEnd = '.s').

! !
!NumberTest categoriesFor: #testClassReadFromColonScaledDecimals!public!unit tests! !

!ProcessTest methodsFor!

testOverlappedErrno
	self assert: (CRTLibrary default thread_chmod: '' pmode: 0) < 0.
	self assert: Processor activeProcess errno = 2! !
!ProcessTest categoriesFor: #testOverlappedErrno!public!unit tests! !

!SmallIntegerTest methodsFor!

testSubtract
	"Coercion to float"

	self assert: 5 - 2.6 = 2.4! !
!SmallIntegerTest categoriesFor: #testSubtract!public!unit tests! !

!VMTest methodsFor!

testImmutableNextPutAll
	#(#[1 2 3] 'abc' #(1 2 3)) do: 
			[:s | 
			| strm |
			self assertImmutableAtPut: s.
			strm := WriteStream on: s.
			self should: [strm nextPutAll: (s copyFrom: 2 to: 3)] raise: Processor constWriteSignal]!

testImmutableReplacePrimitives
	#(#[1 2 3] 'abc' #(1 2 3)) do: 
			[:s | 
			self assertImmutableAtPut: s.
			self should: 
					[s 
						replaceFrom: 1
						to: 2
						with: (s copyFrom: 2 to: 3)]
				raise: Processor constWriteSignal]!

testLoopsInterruptible
	"#2167: Need to test all the optimisable loop types:
		#timesRepeat:
		#whileTrue[:]
		#whileFalse[:]
		#to:[by:]do:
		#repeat		(hmmm, tricky, need some way to break the loop)
	The loops must not contain any true mesage sends, only bytecodes"

	"#timesRepeat:"

	self assertLoopInterruptible: [3000000 timesRepeat: [1 + 2]].
	"#whileFalse"
	self assertLoopInterruptible: 
			[| i |
			i := 0.
			
			[i := i + 1.
			i > 5000000] whileFalse].
	"#whileTrue"
	self assertLoopInterruptible: 
			[| i |
			i := 0.
			
			[i := i + 1.
			i <= 5000000] whileTrue].
	"#whileFalse:"
	self assertLoopInterruptible: 
			[| i |
			i := 0.
			[i >= 5000000] whileFalse: [i := i + 1]].
	"#whileTrue:"
	self assertLoopInterruptible: 
			[| i |
			i := 0.
			[i < 5000000] whileTrue: [i := i + 1]].
	"#to:do:"
	self assertLoopInterruptible: [1 to: 5000000 do: [:i | i + 1]].
	"#to:by:do:"
	self assertLoopInterruptible: 
			[1 to: 10000000
				by: 2
				do: [:i | i + 1]].
	self assertLoopInterruptible: 
			[5000000 to: 1
				by: -1
				do: [:i | i + 1]]! !
!VMTest categoriesFor: #testImmutableNextPutAll!public!unit tests! !
!VMTest categoriesFor: #testImmutableReplacePrimitives!public!unit tests! !
!VMTest categoriesFor: #testLoopsInterruptible!public!unit tests! !

!ZLibTest methodsFor!

testCompressUncompress
	| string compressed compressedLen uncompressed uncompressedLen |
	string := Object comment.
	compressed := ByteArray new: string size.
	compressedLen := DWORD fromInteger: compressed size.
	ZLibLibrary default 
		compress2: compressed
		outLen: compressedLen
		inData: string
		inLen: string size
		level: 9.
	uncompressed := String new: string size.
	uncompressedLen := DWORD fromInteger: uncompressed size.
	ZLibLibrary default 
		uncompress: uncompressed
		outLen: uncompressedLen
		inData: compressed
		inLen: compressed size.
	self assert: uncompressed = string! !
!ZLibTest categoriesFor: #testCompressUncompress!public!unit tests! !

"End of package definition"!

