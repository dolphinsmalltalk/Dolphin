| package |
package := Package name: 'Long Running Tests'.
package paxVersion: 1;
	basicComment: 'These tests take rather a long time to run (but do pass eventually). This package is not loaded during normal regression testing to allow the test pass to complete in a reasonable time.'.


package methodNames
	add: #AbstractParserErrorTest -> #testErrorsBlockNestingTooDeep;
	add: #CompilerErrorTest -> #testErrorsTooManyBytecodes;
	add: #CompilerErrorTest -> #testErrorsTooManyLiterals;
	add: #CompilerTest -> #knownTempsMapIssues;
	add: #CompilerTest -> #knownTextMapIssues;
	add: #CompilerTest -> #testTempMapOuterDepthExhaustive;
	add: #CompilerTest -> #testTextMapsExhaustive;
	add: #DefaultSortAlgorithmTest -> #testBigStringSort;
	add: #FormatterTest -> #testSmokeTestAll;
	add: #HeapsortAlgorithmTest -> #testBigStringSort;
	add: #IntrosortAlgorithmTest -> #testBigStringSort;
	add: #MergesortAlgorithmTest -> #testBigStringSort;
	add: #VMTest -> #getCPUTime;
	add: #VMTest -> #testQuiesceWhenUIBlocked;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\IDE\Base\Development System Tests'
	'..\Base\Dolphin'
	'..\Base\Dolphin Base Tests'
	'..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\Contributions\Refactory\Refactoring Browser\Tests\RBTests').

package!

"Class Definitions"!


"Global Aliases"!


"Loose Methods"!

!AbstractParserErrorTest methodsFor!

testErrorsBlockNestingTooDeep
	"Small test of the test first"

	| mark expected nesting source maxNest |
	nesting := 10.
	source := self buildNestedBlocks: nesting.
	expected := (nesting + 1) factorial.
	self assert: (self evaluateExpression: source) = expected.
	"Now 2 under max"
	maxNest := VMConstants.MaxBlockNesting.
	nesting := maxNest - 2.
	source := self buildNestedBlocks: nesting.
	expected := (nesting + 1) factorial.
	self assert: (self evaluateExpression: source) = expected.
	"Now 1 under max"
	nesting := maxNest - 1.
	source := self buildNestedBlocks: nesting.
	expected := (nesting + 1) factorial.
	self assert: (self evaluateExpression: source) = expected.
	"max nesting"
	maxNest := VMConstants.MaxBlockNesting.
	nesting := maxNest.
	source := self buildNestedBlocks: nesting.
	expected := (nesting + 1) factorial.
	self assert: (self evaluateExpression: source) = expected.
	"1 over max - should fail"
	nesting := maxNest + 1.
	source := self buildNestedBlocks: nesting.
	mark := (source indexOfSubCollection: nesting displayString) - 3.
	self
		parseExprError: source
		range: (mark to: nil)
		line: 1
		code: CErrBlockNestingTooDeep! !
!AbstractParserErrorTest categoriesForMethods!
testErrorsBlockNestingTooDeep!public!unit tests! !
!

!CompilerErrorTest methodsFor!

testErrorsTooManyBytecodes
	"This is one error that the parser cannot detect since it does not do code generation.
	The number of bytecodes in a method has no real limit, except that imposed by the
	maximum lengths of jumps (and in practice by the maximum size of the literal frame).
	In order to provoke the 'method tool long' error we need to generate a long jump
	around a large inlined block. To avoid requring a lot of literals we use expressions
	with immediate values, i.e. 1+2 .Each 1+2 sequence generates 4 bytecodes:
		Push 1
		Push 2
		Send +
		Pop.
	The maximum length of a jump is 32k."

	| source max |
	source := String writeStream.
	source
		nextPutAll: 'Object isNil ifFalse: [';
		cr.
	max := 32768 / 4.
	1 to: max
		do: 
			[:i |
			source
				nextPutAll: '1+2.';
				cr].
	source nextPut: $].
	source := source contents.
	self
		parseExprError: source
		range: (source size + 1 to: source size)
		line: max + 2
		code: CErrMethodTooLarge!

testErrorsTooManyLiterals
	| source max len |
	source := String writeStream.
	source print: String empty.
	max := self maxLiterals.
	"The empty string and concatenation operator will push it over max literals by 1 if we concate max-1 strings"
	1 to: max - 1
		do: 
			[:i |
			source
				nextPut: $,;
				crtab;
				nextPut: $';
				display: i;
				nextPut: $'].
	source := source contents.
	len := source size.
	self
		parseExprError: source
		range: (len - (max - 1) printString size - 1 to: len)
		line: max
		code: CErrTooManyLiterals! !
!CompilerErrorTest categoriesForMethods!
testErrorsTooManyBytecodes!public!unit tests! !
testErrorsTooManyLiterals!public!unit tests! !
!

!CompilerTest methodsFor!

knownTempsMapIssues
	| specials env |
	env := BrowserEnvironment new.
	"There are none"
	^env not!

knownTextMapIssues
	| bad |
	bad := OrderedCollection new.
	"These methods are all have optimisation where an unconditional jump is replaced with a
	return, and the text map for the optimised method then has an extra entry for that return
	statement as these get breaks inserted before them. The compiler needs to be fixed to mark
	these returns as optimised returns, and so it's never possible to break on them, or we need
	to put a text map entry in for the unconditional jump (wouldn't do any harm)."
	bad add: AddPoolVariableChange >> #changeObject.
	bad add: RemovePoolVariableChange >> #changeObject.
	Smalltalk at: #ItcSystemManager ifPresent: [:class | bad add: class class >> #imageFilename].
	Smalltalk at: #WikiDocImageSelectorServlet ifPresent: [:class | bad add: class >> #searchImages:].
	bad add: DolphinCompilerTestMethods >> #testWarningReadBeforeWrittenBlockTemp.
	"This case has an extra entry in the debug temps map, apparently due to the optimizatiom of ifNil:ifNotNil:. In the non-debug method the unecessary ifNotNil: branch is optimized away"
	bad add: Dictionary >> #associationAt:.
	^BrowserEnvironment new forMethods: bad asArray!

testTempMapOuterDepthExhaustive
	"Check that the temp maps for all methods with env temps have the correct outer depth. Note
	that this is very long running as it compiles every method in the system and analyses the
	bytecodes for temp references and compares those against the debug info temps map."

	self knownTempsMapIssues not methodsDo: [:each | self verifyTempsMapOf: each]!

testTextMapsExhaustive
	"Check that the release and debug text maps match for every method in the system .... with a
	couple of exceptions... ahem"

	self knownTextMapIssues not methodsDo: [:each | self verifyTextMapsOf: each]! !
!CompilerTest categoriesForMethods!
knownTempsMapIssues!public!unit tests-long running! !
knownTextMapIssues!private! !
testTempMapOuterDepthExhaustive!public!unit tests-long running! !
testTextMapsExhaustive!public!unit tests-long running! !
!

!DefaultSortAlgorithmTest methodsFor!

testBigStringSort
	self bigStringSort! !
!DefaultSortAlgorithmTest categoriesForMethods!
testBigStringSort!public!unit tests! !
!

!FormatterTest methodsFor!

testSmokeTestAll
	self smokeTestAllMethodsOfHierarchy: Object.
	self smokeTestAllMethodsOfHierarchy: Object class! !
!FormatterTest categoriesForMethods!
testSmokeTestAll!public!tests! !
!

!HeapsortAlgorithmTest methodsFor!

testBigStringSort
	self bigStringSort! !
!HeapsortAlgorithmTest categoriesForMethods!
testBigStringSort!public!unit tests! !
!

!IntrosortAlgorithmTest methodsFor!

testBigStringSort
	self bigStringSort! !
!IntrosortAlgorithmTest categoriesForMethods!
testBigStringSort!public!unit tests! !
!

!MergesortAlgorithmTest methodsFor!

testBigStringSort
	self bigStringSort! !
!MergesortAlgorithmTest categoriesForMethods!
testBigStringSort!public!unit tests! !
!

!VMTest methodsFor!

getCPUTime
	"Answer the total CPU time consumed since Dolphin was started, in milliseconds."

	| lib user kernel creation exit |
	creation := FILETIME new.
	exit := FILETIME new.
	user := FILETIME new.
	kernel := FILETIME new.
	lib := KernelLibrary default.
	lib
		getThreadTimes: lib getCurrentThread
		lpCreationTime: creation
		lpExitTime: exit
		lpKernelTime: kernel
		lpUserTime: user.
	^Duration microseconds: (kernel asInteger + user asInteger) / 10!

testQuiesceWhenUIBlocked
	"#969: Dolphin burns 100% CPU when main UI process blocked on Semaphore"

	| totalCPUBefore cpuWhileSleeping sleepTime wait |
	totalCPUBefore := self getCPUTime.
	"This test needs to measure over a minimum of 2 seconds in order to determine whether Dolphin has quiesced properly"
	wait := 3000 milliseconds.
	sleepTime := [Processor sleep: wait asMilliseconds] timeToRun.
	cpuWhileSleeping := self getCPUTime - totalCPUBefore.
	"If the sleep time was significantly longer than requested, then the VM is not waking up the image
	 properly at the end of the timer"
	self assert: (sleepTime between: wait * 0.9 and: wait * 1.1).
	"The VM should quiesce properly, even if events are waiting to be processed, so very little CPU time should have been consumed"
	self assert: cpuWhileSleeping < (wait * 0.03)! !
!VMTest categoriesForMethods!
getCPUTime!public!unit tests! !
testQuiesceWhenUIBlocked!public!unit tests! !
!

"End of package definition"!

