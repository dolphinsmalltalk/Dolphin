| package |
package := Package name: 'Dolphin Refactoring Browser'.
package paxVersion: 2.1;
	environmentName: #{Tools};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Refactoring Browser Native UI Integration
Copyright (c) Object Arts Ltd, 2001-2009.

This package augments the native Dolphin development system browsers to add refactoring capabilities. The refactorings themselves are implemented by the Refactory refactoring engine, originally ported to Dolphin at Camp Smalltalk 1 in San Diego by Andy Bower and Blair McGlashan with the assistance of John Brant and Don Roberts. We would also like to acknowledge the contribution of Donald McQueen, who pioneered the way with his Refactoring Browser add-on for Dolphin 3.x and 4.x.

Refactoring operations are supported by the Debugger and all the Dolphin browsers. The Debugger and Method Browser support the Code and Method refactorings only, with the Class Hierarchy and System browser supporting all refactorings, including those which operate on classes. The Package Browser, which is really more of an organiser than a coding tool, supports a limited range of refactorings where it is useful to be able to limit their scope to a particular package or set of packages (e.g. renaming a method), although package scoped refactorings can also be initiated from other tools, in particular the System Browser.

A brief description of most of the Refactorings themselves can be found at:

	http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/Refactorings.html

Dolphin also incorporates some of its own specific refactorings.
1) Rename Method References. Not strictly a refactoring, in that it may not preserve existing behaviour, this is effectively one half Rename Method. It renames all references to a selector within the chosen refactoring scope, but does not rename any definitions. This is useful when you have a duplicate method where both original and duplicate are called, and you want to rename refs to the duplicate to call the original, which will then allow removal of the duplicate.
2) Remove Duplicate Methods. This simply removes any methods in a class or classes that are not required because they duplicate an inherited definition. It is particularly useful when applied against packages to help maintain code quality by removing redundant methods.

As of Dolphin 6 renaming a class or instance variable in the browsers can also (optionally) rename accessor methods for that variable. This is based on the Rename Class / Instance Variable and Accessors refactoring developed as part of the Camp Smalltalk RB project. When renaming a variable if any potential accessors are found then the user is prompted as to whether they wish to rename those accessors as well as the underlying variable. The dialog also allows the scope of the method rename to be chosen.

In the browsers Refactoring commands can be found on the Refactoring sub-menus of the class tree, method list, and source workspace context menus, and on the Refactoring sub-menus of the Class, Method and Workspace top-level menus, wherever these are present. In the Debugger the method refactorings menu can be found on the stack trace window context menu, and off the Debug top-level menu. Extensive use is made of dynamically constructed menus to enhance usability, and accelerator key sequences are associated with the most commonly used code refactorings. Many refactorings (not just "code" refactorings) can now be initiated from the browser source workspace context menus just by right-clicking over the appropriate syntactic element; for example you can rename a self-sent message by selecting the message send or just by right-clicking over one of the selector''s keywords.'.

package basicPackageVersion: '6.1'.


package setClassNames: #(
	#{Refactory.Browser.CopyClassRefactoring}
	#{Refactory.Browser.RenameMethodReferencesTransformation}
	#{Tools.ChooseImportDialog}
	#{Tools.CodeMentorPlugin}
	#{Tools.CodeRewriterPlugin}
	#{Tools.ConvertToSiblingDialog}
	#{Tools.LintRuleFailuresBrowserShell}
	#{Tools.MethodNameDialog}
	#{Tools.MethodRefactoringTool}
	#{Tools.RefactoringSmalltalkSystem}
	#{Tools.RefactoringTool}
	#{Tools.RenameAccessorsDialog}
	#{Tools.RenameMethodDialog}
	#{Tools.RewriteChangesBrowser}
	#{Tools.ScopedMethodName}
	#{Tools.SmalllintCachingContext}
	#{Tools.SmalllintPlugin}
).

package setMethodNames: #(
	#(#{Core.Behavior} #directlyDefinesMethod:)
	#(#{Core.ClassDescription} #definesClassVariable:)
	#(#{Core.ClassDescription} #definesInstanceVariable:)
	#(#{Core.ClassDescription} #definesVariable:)
	#(#{Core.ClassDescription} #directlyDefinesClassVariable:)
	#(#{Core.ClassDescription} #directlyDefinesInstanceVariable:)
	#(#{Core.ClassDescription} #directlyDefinesVariable:)
	#(#{Core.ClassDescription} #hierarchyDefinesVariable:)
	#(#{Kernel.CompiledMethod} #methodInModel:)
	#(#{Refactory.Browser.AbstractClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #displayOn:)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #getOptionAbstractVariables)
	#(#{Refactory.Browser.AddClassChange class} #icon)
	#(#{Refactory.Browser.AddClassConstantChange class} #icon)
	#(#{Refactory.Browser.AddClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddClassVariableChange class} #icon)
	#(#{Refactory.Browser.AddClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.AddInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddMethodChange class} #icon)
	#(#{Refactory.Browser.AddMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddMethodRefactoring} #maxDetails)
	#(#{Refactory.Browser.AddParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddSharedVariableChange class} #icon)
	#(#{Refactory.Browser.BasicLintRule} #failedClasses)
	#(#{Refactory.Browser.BasicLintRule} #failedMethods)
	#(#{Refactory.Browser.BasicLintRule} #publishedAspects)
	#(#{Refactory.Browser.BasicLintRule} #searchStrings)
	#(#{Refactory.Browser.BasicRenameClassChange class} #icon)
	#(#{Refactory.Browser.ChangeMethodNameRefactoring} #getOptionRenameAllDefinitions:of:)
	#(#{Refactory.Browser.ChildrenToSiblingsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ClassCategoryChange class} #icon)
	#(#{Refactory.Browser.ClassCommentChange class} #icon)
	#(#{Refactory.Browser.ClassGuidChange class} #icon)
	#(#{Refactory.Browser.CompositeRefactoryChange class} #icon)
	#(#{Refactory.Browser.CreateAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #getOptionAddImports:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #getOptionUseExistingMethod:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #getOptionVariableToMoveToOf:in:)
	#(#{Refactory.Browser.ExtractToTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineAllSendersRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionImplementorToInline:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineOverridden:of:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineReordered:into:)
	#(#{Refactory.Browser.InlineParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.LintRule} #failedClasses)
	#(#{Refactory.Browser.LintRule} #failedMethods)
	#(#{Refactory.Browser.LintRule} #searchStrings)
	#(#{Refactory.Browser.LintRule class} #icon)
	#(#{Refactory.Browser.MethodRefactoring} #generateDefaultSelector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionAlreadyDefined:selector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionExtractAssignment:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionInlineExpression:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionNewMethodName:classes:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionRemoveMethod:referencedIn:)
	#(#{Refactory.Browser.MoveClassChange class} #icon)
	#(#{Refactory.Browser.MoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionSelfArgumentName)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionVariableTypes:selected:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #resolveClass:)
	#(#{Refactory.Browser.MoveVariableDefinitionRefactoring} #displayOn:)
	#(#{Refactory.Browser.ProtectInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionCopyDownSuperclassMethod:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionPushUpRemoveDuplicates:in:)
	#(#{Refactory.Browser.RBAbstractClass} #allSubclassesDo:)
	#(#{Refactory.Browser.RBAbstractClass} #allSubclassesPreOrderDo:)
	#(#{Refactory.Browser.RBAbstractClass} #isDeprecated)
	#(#{Refactory.Browser.RBAbstractClass} #isVisiblyAbstract)
	#(#{Refactory.Browser.RBAbstractClass class} #icon)
	#(#{Refactory.Browser.RBAbstractClass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBAbstractCondition} #validate)
	#(#{Refactory.Browser.RBAbstractCondition} #validate:)
	#(#{Refactory.Browser.RBAbstractCondition class} #icon)
	#(#{Refactory.Browser.RBClass} #icon)
	#(#{Refactory.Browser.RBClass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBMetaclass class} #icon)
	#(#{Refactory.Browser.RBMetaclass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBMethod} #hasCompilationFailures)
	#(#{Refactory.Browser.RBMethod} #hasCompilationIssues)
	#(#{Refactory.Browser.RBMethod} #owningPackage)
	#(#{Refactory.Browser.RBMethod} #owningPackageIfLoose)
	#(#{Refactory.Browser.RBMethod class} #icon)
	#(#{Refactory.Browser.RBModel} #allResourceIdentifiers)
	#(#{Refactory.Browser.RBModel} #browseChanges)
	#(#{Refactory.Browser.RBModel} #methodsThatFailedToCompileIn:)
	#(#{Refactory.Browser.RBModel} #methodsWithCompilationIssuesIn:)
	#(#{Refactory.Browser.RBModel} #modelClassFor:)
	#(#{Refactory.Browser.RBModel} #modelMethodFor:)
	#(#{Refactory.Browser.RBModel class} #icon)
	#(#{Refactory.Browser.RBNamespaceClass class} #icon)
	#(#{Refactory.Browser.RBPatternVariableNode class} #icon)
	#(#{Refactory.Browser.RBRootNamespace class} #icon)
	#(#{Refactory.Browser.RBSmalltalkNamespace class} #icon)
	#(#{Refactory.Browser.Refactoring} #chooseFrom:caption:)
	#(#{Refactory.Browser.Refactoring} #confirm:)
	#(#{Refactory.Browser.Refactoring} #maxDetails)
	#(#{Refactory.Browser.Refactoring} #printNameList:on:limit:type:)
	#(#{Refactory.Browser.Refactoring} #prompt:)
	#(#{Refactory.Browser.Refactoring class} #icon)
	#(#{Refactory.Browser.Refactoring class} #renameIcon)
	#(#{Refactory.Browser.RefactoryClassChange class} #icon)
	#(#{Refactory.Browser.RefactoryMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveClassChange class} #icon)
	#(#{Refactory.Browser.RemoveClassConstantChange class} #icon)
	#(#{Refactory.Browser.RemoveClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveClassRefactoring} #getOptionRemoveClass:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring} #getOptionRemoveVariable:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #getOptionRemoveDuplicatesWithSupersends:)
	#(#{Refactory.Browser.RemoveParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveSharedVariableChange class} #icon)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameClassChange class} #icon)
	#(#{Refactory.Browser.RenameClassRefactoring} #getOptionIgnoreSymbolicClassReferences:)
	#(#{Refactory.Browser.RenameClassRefactoring} #getOptionUpgradeLegacyPackage:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameMethodRefactoring class} #icon)
	#(#{Refactory.Browser.RenameTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameTemporaryRefactoring class} #icon)
	#(#{Refactory.Browser.RenameVariableChange class} #icon)
	#(#{Refactory.Browser.SmalllintChecker class} #newWithCachingContext)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #getOptionConvertReadBeforeWritten:)
	#(#{Refactory.Browser.TransformationRule class} #bitLogicElimination)
	#(#{Refactory.Browser.TransformationRule class} #icon)
	#(#{Refactory.Browser.TransformationRule class} #ifElimination)
	#(#{Refactory.Browser.TransformationRule class} #renameArgument:to:)
	#(#{Refactory.Browser.VariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.VariableRefactoring} #displayPrefix)
	#(#{Refactory.Browser.VariableRefactoring} #getOptionPullUpNonSharedInstVar:)
	#(#{Refactory.Browser.VariableRefactoring class} #displayPrefix)
	#(#{Tools.ChooseNamespaceDialog} #createComponents)
	#(#{Tools.ChooseNamespaceDialog} #showChanges)
	#(#{Tools.ChooseNamespaceDialog class} #resource_Refactoring_view)
	#(#{Tools.ClassBrowserAbstract} #abstractInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #canPushDownInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #canPushDownMethods)
	#(#{Tools.ClassBrowserAbstract} #canPushUpMethods)
	#(#{Tools.ClassBrowserAbstract} #methodRefactoringsMenu)
	#(#{Tools.ClassBrowserAbstract} #methodRefactoringTool)
	#(#{Tools.ClassBrowserAbstract} #methodsToOverride)
	#(#{Tools.ClassBrowserAbstract} #overrideMethods)
	#(#{Tools.ClassBrowserAbstract} #protectInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownMethods)
	#(#{Tools.ClassBrowserAbstract} #pushMethods:)
	#(#{Tools.ClassBrowserAbstract} #pushUpMethods)
	#(#{Tools.ClassBrowserAbstract} #queryOverrideMethods:)
	#(#{Tools.ClassBrowserAbstract} #queryRemoveInstanceVariables:)
	#(#{Tools.ClassBrowserAbstract} #removeInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #renameMethod)
	#(#{Tools.ClassBrowserAbstract} #selectedOverridableMethods)
	#(#{Tools.ClassBrowserPlugin} #developmentSystem)
	#(#{Tools.ClassSelector} #abstractClassVariables)
	#(#{Tools.ClassSelector} #abstractInstanceVariables)
	#(#{Tools.ClassSelector} #abstractVariables)
	#(#{Tools.ClassSelector} #addClassVariable)
	#(#{Tools.ClassSelector} #addImport)
	#(#{Tools.ClassSelector} #addInstanceVariable)
	#(#{Tools.ClassSelector} #buildInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #buildPullUpVariablesMenu:)
	#(#{Tools.ClassSelector} #buildVariablesMenu:instVarSelectors:classVarSelectors:)
	#(#{Tools.ClassSelector} #canChangeClassNamespace)
	#(#{Tools.ClassSelector} #canPullUpClassVariables)
	#(#{Tools.ClassSelector} #canPullUpInstanceVariables)
	#(#{Tools.ClassSelector} #canPullUpVariables)
	#(#{Tools.ClassSelector} #canPushDownInstanceVariables)
	#(#{Tools.ClassSelector} #canPushDownVariables)
	#(#{Tools.ClassSelector} #changeClassNamespace)
	#(#{Tools.ClassSelector} #classRefactoringsMenu)
	#(#{Tools.ClassSelector} #cloneClass:under:changes:)
	#(#{Tools.ClassSelector} #convertToSibling)
	#(#{Tools.ClassSelector} #createClassVariableAccessors)
	#(#{Tools.ClassSelector} #createVariableAccessors)
	#(#{Tools.ClassSelector} #hasImports)
	#(#{Tools.ClassSelector} #populateClassVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populateInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:)
	#(#{Tools.ClassSelector} #protectInstanceVariables)
	#(#{Tools.ClassSelector} #protectVariables)
	#(#{Tools.ClassSelector} #pullUpClassVariables)
	#(#{Tools.ClassSelector} #pullUpInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpVariableNamePairs:for:maximum:)
	#(#{Tools.ClassSelector} #pullUpVariables)
	#(#{Tools.ClassSelector} #pushDownClassVariables)
	#(#{Tools.ClassSelector} #pushDownInstanceVariables)
	#(#{Tools.ClassSelector} #pushDownVariables)
	#(#{Tools.ClassSelector} #queryAddInstanceVariable:)
	#(#{Tools.ClassSelector} #removeClassVariables)
	#(#{Tools.ClassSelector} #removeDuplicateMethods)
	#(#{Tools.ClassSelector} #removeImport)
	#(#{Tools.ClassSelector} #removeInstanceVariables)
	#(#{Tools.ClassSelector} #removeVariables)
	#(#{Tools.CreateSubclassDialog class} #resource_Refactoring_view)
	#(#{Tools.Debugger} #canMoveMethods)
	#(#{Tools.Debugger} #hasRefactorableMethodSelected)
	#(#{Tools.Debugger} #performMethodRefactoring:)
	#(#{Tools.Debugger} #performMethodRenameRefactoring:)
	#(#{Tools.Debugger} #performMethodsRefactoring:name:)
	#(#{Tools.MethodBrowser} #canMoveMethods)
	#(#{Tools.MethodBrowser} #hasRefactorableMethodSelected)
	#(#{Tools.MethodBrowser} #performMethodRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodsRefactoring:name:)
	#(#{Tools.MethodWorkspace} #addClassVariable:to:)
	#(#{Tools.MethodWorkspace} #addInstanceVariable:to:)
	#(#{Tools.MethodWorkspace} #addParameterCommand:)
	#(#{Tools.MethodWorkspace} #addParameterToMessage)
	#(#{Tools.MethodWorkspace} #addSharedVariable:to:)
	#(#{Tools.MethodWorkspace} #autoCorrectMenu)
	#(#{Tools.MethodWorkspace} #canExtractCode)
	#(#{Tools.MethodWorkspace} #canPerformCodeRefactoring)
	#(#{Tools.MethodWorkspace} #canRefactor)
	#(#{Tools.MethodWorkspace} #canRenameNode)
	#(#{Tools.MethodWorkspace} #changeSignatureCommandFor:in:operation:title:)
	#(#{Tools.MethodWorkspace} #codeRefactoringsMenu)
	#(#{Tools.MethodWorkspace} #convertTempToInstVar)
	#(#{Tools.MethodWorkspace} #createClassForVariable:)
	#(#{Tools.MethodWorkspace} #declareAllUndeclaredVariablesAsTemps)
	#(#{Tools.MethodWorkspace} #executeRefactoring:)
	#(#{Tools.MethodWorkspace} #executeRefactoring:with:)
	#(#{Tools.MethodWorkspace} #extractionRange)
	#(#{Tools.MethodWorkspace} #extractMethod)
	#(#{Tools.MethodWorkspace} #extractToComponent)
	#(#{Tools.MethodWorkspace} #extractToTemporary)
	#(#{Tools.MethodWorkspace} #findAssignmentsToTemp:)
	#(#{Tools.MethodWorkspace} #fontOfStyle:)
	#(#{Tools.MethodWorkspace} #implementMessage:)
	#(#{Tools.MethodWorkspace} #implementMessage:inClass:)
	#(#{Tools.MethodWorkspace} #implementMessageMenu)
	#(#{Tools.MethodWorkspace} #inlineMessage)
	#(#{Tools.MethodWorkspace} #inlineParameter)
	#(#{Tools.MethodWorkspace} #inlineTemporary)
	#(#{Tools.MethodWorkspace} #inlineTemporary:in:)
	#(#{Tools.MethodWorkspace} #moveTempToInnerScope)
	#(#{Tools.MethodWorkspace} #performCodeRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRenameRefactoring:)
	#(#{Tools.MethodWorkspace} #populateAutoCorrectMenu:)
	#(#{Tools.MethodWorkspace} #populateAutoCorrectMenu:forMessage:)
	#(#{Tools.MethodWorkspace} #populateAutoCorrectMenu:forUndefinedVar:)
	#(#{Tools.MethodWorkspace} #populateAutoCorrectMenu:forVariable:)
	#(#{Tools.MethodWorkspace} #populateImplementMenu:)
	#(#{Tools.MethodWorkspace} #populateImplementMenu:forMessage:)
	#(#{Tools.MethodWorkspace} #qualifyIdentifier)
	#(#{Tools.MethodWorkspace} #queryAddParameterToMessage:)
	#(#{Tools.MethodWorkspace} #queryChangeIdentifierQualification:)
	#(#{Tools.MethodWorkspace} #queryChangeSignature:)
	#(#{Tools.MethodWorkspace} #queryConvertTempToInstVar:)
	#(#{Tools.MethodWorkspace} #queryInlineMessage:)
	#(#{Tools.MethodWorkspace} #queryInlineTemporary:)
	#(#{Tools.MethodWorkspace} #queryMoveTempToInnerScope:)
	#(#{Tools.MethodWorkspace} #queryParameterRefactoring:)
	#(#{Tools.MethodWorkspace} #queryRenameClass:)
	#(#{Tools.MethodWorkspace} #queryRenameClassVariable:)
	#(#{Tools.MethodWorkspace} #queryRenameInstanceVariable:)
	#(#{Tools.MethodWorkspace} #queryRenameItCommand:)
	#(#{Tools.MethodWorkspace} #queryRenameMessage:)
	#(#{Tools.MethodWorkspace} #queryRenameTemporary:)
	#(#{Tools.MethodWorkspace} #queryRenameVariable:)
	#(#{Tools.MethodWorkspace} #queryRenameVariable:classification:)
	#(#{Tools.MethodWorkspace} #removeParameter)
	#(#{Tools.MethodWorkspace} #removeParameter:)
	#(#{Tools.MethodWorkspace} #removeTempDecl:)
	#(#{Tools.MethodWorkspace} #renameClass)
	#(#{Tools.MethodWorkspace} #renameClass:)
	#(#{Tools.MethodWorkspace} #renameClassVariable)
	#(#{Tools.MethodWorkspace} #renameClassVariable:)
	#(#{Tools.MethodWorkspace} #renameInstanceVariable)
	#(#{Tools.MethodWorkspace} #renameInstanceVariable:)
	#(#{Tools.MethodWorkspace} #renameIt)
	#(#{Tools.MethodWorkspace} #renameItCommand)
	#(#{Tools.MethodWorkspace} #renameMessage)
	#(#{Tools.MethodWorkspace} #renameMessageCommand:)
	#(#{Tools.MethodWorkspace} #renameTemporary)
	#(#{Tools.MethodWorkspace} #renameTemporary:)
	#(#{Tools.MethodWorkspace} #renameVariable)
	#(#{Tools.MethodWorkspace} #renameVariable:operation:validationBlock:)
	#(#{Tools.MethodWorkspace} #renameVariableCommand:)
	#(#{Tools.MethodWorkspace} #unqualifyIdentifier)
	#(#{Tools.PackageBrowserShell} #addImport)
	#(#{Tools.PackageBrowserShell} #addParameter)
	#(#{Tools.PackageBrowserShell} #addParameterTo:)
	#(#{Tools.PackageBrowserShell} #addParameterToMethod)
	#(#{Tools.PackageBrowserShell} #changeClassNamespace)
	#(#{Tools.PackageBrowserShell} #chooseMethodsForRefactoring:)
	#(#{Tools.PackageBrowserShell} #classRefactoringsMenu)
	#(#{Tools.PackageBrowserShell} #hasMethodWithArguments)
	#(#{Tools.PackageBrowserShell} #hasRefactorableMethodSelected)
	#(#{Tools.PackageBrowserShell} #methodRefactoringsMenu)
	#(#{Tools.PackageBrowserShell} #newMethodNamePrompter:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #onClass:renameTo:accept:)
	#(#{Tools.PackageBrowserShell} #onRenameClass:to:showChanges:)
	#(#{Tools.PackageBrowserShell} #parseTree)
	#(#{Tools.PackageBrowserShell} #performMethodRenameRefactoring:)
	#(#{Tools.PackageBrowserShell} #performMethodsRefactoring:name:)
	#(#{Tools.PackageBrowserShell} #promptForMethodName:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #removeMethod)
	#(#{Tools.PackageBrowserShell} #removeMethods)
	#(#{Tools.PackageBrowserShell} #removeParameter)
	#(#{Tools.PackageBrowserShell} #removeParameterMenu)
	#(#{Tools.PackageBrowserShell} #renameClass)
	#(#{Tools.PackageBrowserShell} #renameLooseMethod)
	#(#{Tools.PackageBrowserShell} #renameLooseMethodReferences)
	#(#{Tools.PackageBrowserShell} #renameMethod)
	#(#{Tools.PackageBrowserShell} #renameMethodReferences:)
	#(#{Tools.PackageSelector} #moveAllTempsToInnerScope)
	#(#{Tools.PackageSelector} #removeDuplicateMethods)
	#(#{Tools.SmalltalkToolShell} #chooseMethodForRefactoring:caption:)
	#(#{UI.ChoicePrompter} #showChanges)
	#(#{UI.ChoicePrompter class} #refactoringChoices:caption:)
	#(#{UI.ChoicePrompter class} #resource_Refactoring_view)
	#(#{UI.Presenter class} #resource_Refactoring_OK_Cancel_button_block)
).

package setPrerequisites: #(
	'..\..\..\..\Contributions\Camp Smalltalk\Refactoring Browser\Refactorings\CSRefactorings'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Dialogs\Dolphin Base Dialogs'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Views\Buttons\Dolphin Check Buttons'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Presenters\Difference\Dolphin Differences Presenter'
	'..\..\MVP\Graphics\Dolphin GDI Graphics'
	'..\..\MVP\Views\Static\GroupBox\Dolphin GroupBox'
	'..\..\MVP\Presenters\Prompters\Dolphin In-place Text Editor'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\System\Filer\Dolphin Literal Filer'
	'..\..\System\Win32\MessageBox\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'Dolphin Professional Tools'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Views\Buttons\Dolphin Push Buttons'
	'..\..\MVP\Views\Scintilla\Dolphin Scintilla View'
	'..\..\MVP\Views\Splitter\Dolphin Splitter Control'
	'..\..\MVP\Views\Static\Rectangle\Dolphin StaticRectangle Control'
	'..\..\MVP\Views\Static\Text\Dolphin StaticText Control'
	'..\..\System\Filer\Dolphin STx Filer Core'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Presenters\Validation\Dolphin Validation Hint Presenter'
	'..\..\MVP\Presenters\Validation\Dolphin Validation Result Presenter'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Parser\RBParser'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\SmallLint\RBSmallLint'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Components\WebView2\WebView2'
	'..\..\ActiveX\Shell\Windows Shell'
	'..\..\ActiveX\Components\XML DOM\XML DOM'
).

package!

"Class Definitions"!

Core.Object
	subclass: #'Tools.RefactoringTool'
	instanceVariableNames: 'presenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ProfessionalSmalltalkSystem
	subclass: #'Tools.RefactoringSmalltalkSystem'
	instanceVariableNames: 'isOAD'
	classVariableNames: 'RefactoringSignal'
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassBrowserPlugin
	subclass: #'Tools.SmalllintPlugin'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalllintPlugin
	subclass: #'Tools.CodeMentorPlugin'
	instanceVariableNames: 'failuresPresenter infoSitePresenter infoBrowserPresenter progressPresenter checkerProcess rulesTreeModel isRefreshPending refreshMode'
	classVariableNames: 'DefaultRefreshMode LintIconMap LintRulesDoc'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalllintPlugin
	subclass: #'Tools.CodeRewriterPlugin'
	instanceVariableNames: 'searchTextPresenter replaceTextPresenter isMethodPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Dialog
	subclass: #'Tools.ConvertToSiblingDialog'
	instanceVariableNames: 'subclassesPresenter namespacePresenter classNamePresenter showChangesPresenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Dialog
	subclass: #'Tools.MethodNameDialog'
	instanceVariableNames: 'selectorPresenter parametersPresenter parameterNamesPresenter showChangesPresenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MethodNameDialog
	subclass: #'Tools.RenameMethodDialog'
	instanceVariableNames: 'scopePresenter scopeDescriptionPresenter allowExistingSelector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValueDialog
	subclass: #'Tools.RenameAccessorsDialog'
	instanceVariableNames: 'selectorsPresenter scopePresenter showChangesPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ChooseNamespaceDialog
	subclass: #'Tools.ChooseImportDialog'
	instanceVariableNames: 'private namespacesOnly'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.RewriteChangesBrowser'
	instanceVariableNames: 'changesPresenter differencesPresenter compositeChange'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MethodBrowserShell
	subclass: #'Tools.LintRuleFailuresBrowserShell'
	instanceVariableNames: 'lintRule'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Refactory.Browser.RBMethodName
	subclass: #'Tools.ScopedMethodName'
	instanceVariableNames: 'methodClass originalArguments originalSelector scopeName scopes'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!

Refactory.Browser.ClassRefactoring
	subclass: #'Refactory.Browser.CopyClassRefactoring'
	instanceVariableNames: 'newName addClass commonSuperclass superclass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Refactory.Browser.RenameMethodRefactoring
	subclass: #'Refactory.Browser.RenameMethodReferencesTransformation'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.RefactoringTool
	subclass: #'Tools.MethodRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Refactory.Browser.SmalllintContext
	subclass: #'Tools.SmalllintCachingContext'
	instanceVariableNames: ''
	classVariableNames: 'Literals Mtx Selectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Behavior methodsFor!

directlyDefinesMethod: aSymbol
	^self includesSelector: aSymbol! !

!Core.Behavior categoriesForMethods!
directlyDefinesMethod:!methods-testing!public! !
!

!Core.ClassDescription methodsFor!

definesClassVariable: aSymbol 
	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesClassVariable: aSymbol]!

definesInstanceVariable: aString 
	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesInstanceVariable: aString]!

definesVariable: aVariableName 
	^(self definesClassVariable: aVariableName) 
		or: [self definesInstanceVariable: aVariableName]!

directlyDefinesClassVariable: aString
	| var |
	var := self localBindingFor: aString.
	^var notNil and: [var isClassVariable]!

directlyDefinesInstanceVariable: aString 
	^self instanceVariableNames includes: aString!

directlyDefinesVariable: aVariableName 
	^(self directlyDefinesClassVariable: aVariableName) 
		or: [self directlyDefinesInstanceVariable: aVariableName]!

hierarchyDefinesVariable: aString
	(self definesVariable: aString) ifTrue: [^true].
	self allSubclassesPreOrderDo: [:each | (each directlyDefinesVariable: aString) ifTrue: [^true]].
	^false! !

!Core.ClassDescription categoriesForMethods!
definesClassVariable:!public!testing! !
definesInstanceVariable:!public!testing! !
definesVariable:!public!testing! !
directlyDefinesClassVariable:!public!testing! !
directlyDefinesInstanceVariable:!public!testing! !
directlyDefinesVariable:!public!testing! !
hierarchyDefinesVariable:!public!testing! !
!

!Kernel.CompiledMethod methodsFor!

methodInModel: aRBModel
	^(methodClass classInModel: aRBModel) ifNotNil: [:modelClass | modelClass methodFor: selector]! !

!Kernel.CompiledMethod categoriesForMethods!
methodInModel:!converting!public! !
!

!Refactory.Browser.AbstractClassVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !

!Refactory.Browser.AbstractClassVariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Refactory.Browser.AbstractInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !

!Refactory.Browser.AbstractInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AbstractVariablesRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	#todo.	"Implement more informative display string"
	aPuttableStream nextPutAll: 'Abstract Variables of <1p>' << fromClass!

getOptionAbstractVariables
	| details instVars classVars accessesInstVars |
	details := String writeStream.
	instVars := instVarReaders union: instVarWriters.
	accessesInstVars := instVars notEmpty.
	accessesInstVars
		ifTrue: 
			[details
				nextPutAll: 'The following instance variables are directly accessed:';
				cr.
			self
				printNameList: instVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'instance variables'].
	classVars := privateClassVarReaders union: privateClassVarWriters.
	classVars isEmpty
		ifFalse: 
			[accessesInstVars
				ifTrue: 
					[details
						cr;
						cr].
			details
				nextPutAll: 'The following private class variables are directly accessed:';
				cr.
			self
				printNameList: classVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'class variables'].
	details
		cr;
		cr;
		nextPutAll: 'Any existing accessor will be used if possible, so accessors will only be added for read or written variables that do not currently have them.'.
	^MessageBox new
		caption: self displayString;
		headline: 'Abstract variable references?';
		text: 'This method has direct variable references that will need to be converted to getter/setters in the extracted method<1?s:>.'
					<< {toClasses size > 1};
		customButtons: #(#(#yes '&Abstract Variables') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !

!Refactory.Browser.AbstractVariablesRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAbstractVariables!options!public! !
!

!Refactory.Browser.AddClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewClass.ico'! !

!Refactory.Browser.AddClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !

!Refactory.Browser.AddClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add class ';
		display: self className! !

!Refactory.Browser.AddClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !

!Refactory.Browser.AddClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !

!Refactory.Browser.AddClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Import ';
		display: import;
		nextPutAll: ' into ';
		display: class! !

!Refactory.Browser.AddImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !

!Refactory.Browser.AddInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !

!Refactory.Browser.AddInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewMethod.ico'! !

!Refactory.Browser.AddMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add method to ';
		nextPutAll: class unqualifiedName!

maxDetails
	^15! !

!Refactory.Browser.AddMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
maxDetails!constants!private! !
!

!Refactory.Browser.AddParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add parameter to ';
		print: oldSelector.
	model environment isSystem
		ifFalse: 
			[aPuttableStream
				nextPutAll: ' in ';
				display: model environment]! !

!Refactory.Browser.AddParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !

!Refactory.Browser.AddSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.BasicLintRule methodsFor!

failedClasses
	self result isClassEnvironment ifFalse: [^super failedClasses].
	^self result classes!

failedMethods
	| failedMethods |
	self result isClassEnvironment ifTrue: [^super failedMethods].
	failedMethods := Set new: 64.
	self result
		classesAndSelectorsDo: [:eachClass :eachSel | failedMethods add: (eachClass compiledMethodAt: eachSel)].
	^failedMethods!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := self class publishedAspectsOfInstances.
	self result isClassEnvironment
		ifTrue: [answer add: ((Aspect collection: #failedClasses)
						beReadOnly;
						yourself)]
		ifFalse: [answer add: ((Aspect collection: #failedMethods)
						beReadOnly;
						yourself)].
	self searchStrings notEmpty
		ifTrue: 
			[answer add: ((Aspect sequenceableCollection: #searchStrings)
						beReadOnly;
						yourself)].
	^answer!

searchStrings
	^result searchStrings! !

!Refactory.Browser.BasicLintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
publishedAspects!constants!development!public! !
searchStrings!accessing!private! !
!

!Refactory.Browser.BasicRenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !

!Refactory.Browser.BasicRenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ChangeMethodNameRefactoring methodsFor!

getOptionRenameAllDefinitions: aCollection of: aSymbol
	| details count prompt |
	aCollection size <= 1 ifTrue: [^true].
	details := String writeStream.
	details
		print: aSymbol;
		nextPutAll: ' is implemented in:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'All definitions must be renamed to preserve behaviour. You can re-initiate the rename and constrain the scope of the rename to package, hierarchy, class or even individual method level in the rename dialog if you wish, but this may not preserve behaviour.'.
	count := aCollection size.
	prompt := MessageBox new
				caption: self displayString;
				headline: 'Rename <1p> methods defined in <2d> classes in <3p>?'
							<< { aSymbol. count. model environment };
				customButtons: #(#(#yes '&Rename All') #(#no 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				checkboxText: 'Show proposed changes?';
				isChecked: self shouldShowChanges;
				yourself.
	prompt confirm ifFalse: [^false].
	prompt isChecked ifTrue: [self shouldShowChanges: true].
	^true! !

!Refactory.Browser.ChangeMethodNameRefactoring categoriesForMethods!
getOptionRenameAllDefinitions:of:!options!public! !
!

!Refactory.Browser.ChildrenToSiblingsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert ';
		display: parent;
		nextPutAll: ' to sibling'! !

!Refactory.Browser.ChildrenToSiblingsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ClassCategoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^ClassCategory icon! !

!Refactory.Browser.ClassCategoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassCommentChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassComment.ico'! !

!Refactory.Browser.ClassCommentChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassGuidChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^GUID icon! !

!Refactory.Browser.ClassGuidChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CompositeRefactoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Collection icon! !

!Refactory.Browser.CompositeRefactoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CreateAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Create accessors for'! !

!Refactory.Browser.CreateAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.ExpandImportsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Add import'.
	imports size = 1
		ifTrue: 
			[aPuttableStream space.
			imports asArray first displayOn: aPuttableStream]
		ifFalse: 
			[aPuttableStream nextPutAll: 's '.
			imports do: [:each | each displayOn: aPuttableStream] separatedBy: [aPuttableStream nextPutAll: ', ']].
	aPuttableStream nextPutAll: ' to '.
	toClasses size = 1
		ifTrue: [toClasses asArray first displayOn: aPuttableStream]
		ifFalse: 
			[toClasses do: [:each | each name displayOn: aPuttableStream]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionAddImports: aCollection
	| resp prompt multipleImports multipleTargets details targetDescription |
	prompt := MessageBox new.
	prompt
		caption: self displayString;
		checkboxText: SmalltalkSystem current showChangesText;
		isChecked: self shouldShowChanges.
	multipleTargets := toClasses size > 1.
	multipleImports := aCollection size > 1.
	details := String writeStream.
	multipleImports
		ifTrue: 
			[details nextPutAll: 'The following namespaces can be imported'.
			multipleTargets
				ifFalse: 
					[details
						nextPutAll: ' into ';
						nextPutAll: toClasses first shortName].
			details
				nextPut: $:;
				cr.
			self
				printNameList: aCollection asSortedArray
				on: details
				limit: self maxDetails
				type: 'namespaces'.
			details
				cr;
				cr].
	targetDescription := multipleTargets
				ifTrue: ['the target classes']
				ifFalse: [toClasses first unqualifiedName].
	details
		nextPutAll: 'Adding imports may cause other methods in the hierarchy of <1d> that reference shared variables to be rewritten, removing or even adding name qualification.<n><n>Choosing not to add imports, but rather to use partially or fully-qualified names where necessary, is recommended as it will limit the scope of the refactoring only to the methods involved. The Add Import class refactoring can always be applied later if desired, and will remove name qualification automatically where possible.<n><n>Alternatively you can opt to preview the refactoring changes to see either the wider impact of adding imports, or where qualified names will be used'
				<< targetDescription.
	prompt detailsText: details contents.
	prompt
		text: '<1d> contains references to shared variables imported from <2d>.<n><n><3d> can be imported into <4d>, or alternatively qualified names can be substituted where required.'
					<< {
							parseTree methodNode ?? 'This method'.
							multipleImports ifTrue: ['namespaces'] ifFalse: [aCollection anyOne].
							multipleImports ifTrue: ['The namespaces'] ifFalse: [aCollection anyOne].
							targetDescription
						};
		customButtons: { { #yes. '&Add Import<1?s:>' << multipleImports }. #(#no '&Qualify Names') };
		defaultButton: 2.
	resp := prompt confirmOrCancel.
	resp == #cancel ifTrue: [self refactoringAborted].
	prompt isChecked ifTrue: [self shouldShowChanges: true].
	^resp == #yes! !

!Refactory.Browser.ExpandImportsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAddImports:!options!public! !
!

!Refactory.Browser.ExtractMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract method from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionUseExistingMethod: aSymbol
	| response |
	response := MessageBox new
				caption: self displayString;
				headline: 'Use existing method <1p>?' << aSymbol;
				text: 'The existing method contains the same code as that you are extracting, and can be used safely instead of creating a new method.';
				customButtons: #(#(#yes '&Use Existing') #(#no '&Create New Method'));
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !

!Refactory.Browser.ExtractMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionUseExistingMethod:!options!public! !
!

!Refactory.Browser.ExtractMethodToComponentRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to component from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionVariableToMoveToOf: aClass in: aSelector
	^SmalltalkSystem current selectTargetVariableOf: aClass
		parseTree: (aClass parseTreeFor: aSelector)! !

!Refactory.Browser.ExtractMethodToComponentRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionVariableToMoveToOf:in:!public! !
!

!Refactory.Browser.ExtractToTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to temporary ';
		print: newVariableName! !

!Refactory.Browser.ExtractToTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineAllSendersRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline sends of ';
		print: selector;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName! !

!Refactory.Browser.InlineAllSendersRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline message in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: sourceSelector!

getOptionImplementorToInline: anOrderedCollection
	^UI.ChoicePrompter
		choices: (anOrderedCollection asSortedCollection: [:a :b | a displayString <= b displayString])
		caption: 'Inline <1p> from…' << sourceMessage!

getOptionInlineOverridden: aSymbol of: aClass
	| details overrides fromClass |
	details := String writeStream.
	fromClass := self chosenInlineClass.
	details
		nextPutAll: '<1p> is overridden by the following subclasses of <2d>:'
					<< {aSymbol. fromClass unqualifiedName};
		cr.
	overrides := fromClass allSubclasses select: [:each | each directlyDefinesMethod: aSymbol].
	self
		printNameList: overrides
		on: details
		limit: self maxDetails
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Inline overridden method?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: '<1d>>><2p> is overridden in <3d> subclass<4?:es> of <5d>.<n><n>Inlining an overridden method may change behavior.'
					<< {aClass. aSymbol. overrides size. overrides size = 1. fromClass};
		detailsText: details contents;
		confirm!

getOptionInlineReordered: inlineRBMethod into: intoRBMethod
	^MessageBox new
		caption: self displayString;
		headline: 'Inline with statement reordering?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: 'To inline <1p> into <2p> it will be necessary to move some of the inlined statements before the original message send.'
					<< {inlineRBMethod. intoRBMethod};
		detailsText: 'This could change the order of execution, which can change the behavior. If it is safe to do so you can continue with the refactoring and then modify or undo the results as required. Alternatively cancel the refactoring and modify the call site so that the inlined message send is an individual statement rather than part of a larger statement, for example as an expression calculating a value to use as an argument to another message send.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm! !

!Refactory.Browser.InlineMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionImplementorToInline:!options!public! !
getOptionInlineOverridden:of:!preconditions!public! !
getOptionInlineReordered:into:!options!public! !
!

!Refactory.Browser.InlineParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline parameter ';
		print: argument;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !

!Refactory.Browser.InlineParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline temp ';
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector
	"		print: oldName;"! !

!Refactory.Browser.InlineTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.LintRule methodsFor!

failedClasses
	^Set new!

failedMethods
	^Set new!

searchStrings
	^#()! !

!Refactory.Browser.LintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
searchStrings!accessing!private! !
!

!Refactory.Browser.LintRule class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!Refactory.Browser.LintRule class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MethodRefactoring methodsFor!

generateDefaultSelector: aRBMethodName
	| args mname |
	aRBMethodName selector isNil ifFalse: [^self].
	args := aRBMethodName arguments.
	mname := args isEmpty
				ifTrue: ['method']
				ifFalse: 
					[| stream |
					stream := String writeStream.
					aRBMethodName arguments do: 
							[:arg |
							stream
								nextPutAll: arg;
								nextPut: $:].
					stream contents].
	aRBMethodName selector: mname asSymbol!

getOptionAlreadyDefined: aClass selector: aSymbol
	| response messageBox stream |
	messageBox := MessageBox new
				caption: self displayString;
				headline: 'Extract to existing selector?';
				text: '<1p> is already defined in the <2p> hierarchy.' << { aSymbol. aClass };
				customButtons: #(#(#yes '&Continue') #(#no 'Choose &Another') #(#cancel 'Cancel'));
				defaultButton: 2;
				iconStyle: #warning;
				yourself.
	stream := String writeStream.
	stream
		nextPutAll: 'Extracting to an existing selector may change the behavior of the class hierarchy, for example by overriding an inherited method. ';
		print: aSymbol;
		nextPutAll: ' is already implemented by the following classes in the hierarchy of ';
		print: aClass;
		nextPut: $:;
		cr.
	(aClass allSuperclasses , aClass withAllSubclasses
		intersection: (self model allImplementorsOf: aSymbol)) do: 
				[:each |
				stream
					cr;
					nextPutAll: '    ';
					print: each].
	stream
		cr;
		cr;
		nextPutAll: 'You should continue only if you do not require a true behavior-preserving refactoring. Otherwise choose another selector.'.
	messageBox
		detailsText: stream contents;
		expandLabel: 'Show help';
		collapseLabel: 'Hide help'.
	response := messageBox confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes!

getOptionExtractAssignment: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Extract final assignment?';
		text: 'The assignment to ''<1s>'' at the end of the selection can be extracted to the new method, or remain behind to receive the result of the call to that method.'
					<< aString;
		customButtons: #(#(#yes '&Extract') #(#no '&Don''t Extract'));
		defaultButton: 2;
		confirm!

getOptionInlineExpression: aString
	| prompt response |
	prompt := MessageBox new
				caption: self displayString;
				headline: 'Inline expression?';
				text: 'The following expression can be inlined or assigned to a temporary:<n><n><t><1s>?' << aString;
				customButtons: #(#(#yes '&Inline') #(#no '&Assign Temporary'));
				defaultButton: 2;
				detailsText: 'The expression shown is passed as one of the arguments to the method you are inlining. You can safely inline the expression if constant and/or side-effect free, or if it is only referred to once in the inlined method. If not, it should be assigned to a temporary to preserve existing behaviour. If unsure, choose ''Assign Temporary''. You can always inline the temporary later if you wish.';
				expandLabel: 'Show help';
				collapseLabel: 'Hide help';
				isCancellable: true;
				checkboxText: SmalltalkSystem current showChangesText;
				isChecked: self shouldShowChanges;
				yourself.
	response := prompt confirmOrCancel.
	response == #cancel ifTrue: [^self refactoringAborted].
	self shouldShowChanges: prompt isChecked.
	^response == #yes!

getOptionNewMethodName: aRBMethodName classes: anArray
	| dialog |
	self generateDefaultSelector: aRBMethodName.
	dialog := MethodNameDialog create: 'Refactoring view' on: aRBMethodName.
	dialog validater: 
			[:methodName |
			| selector |
			selector := methodName selectorSymbol.
			(anArray inject: methodName conditions
				into: [:conditions :each | conditions & (Refactory.Browser.RBCondition definesSelector: selector in: each) not])
					validate].
	^dialog showModal
		ifNotNil: 
			[dialog showChanges ifTrue: [self shouldShowChanges: true].
			aRBMethodName]!

getOptionRemoveMethod: aSymbol referencedIn: aCollection
	| details response |
	details := String writeStream.
	'Removing the method may not preserve behaviour. It is recommended that you first browse <?these references:this reference> to verify that the method is safe to remove:<n>'
		expandMacrosWithArguments: {aCollection size > 1}
		on: details.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: '<1s>>><2p> may not be safe to remove' << {class shortName. aSymbol};
				text: 'The selector <1p> is referenced from <2d> other method<3?s:> in <4p>.'
							<< {aSymbol. aCollection size. aCollection size > 1. self model environment};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: [SmalltalkSystem current browseReferencesToLiteral: aSymbol in: self model environment].
	^false! !

!Refactory.Browser.MethodRefactoring categoriesForMethods!
generateDefaultSelector:!options!public! !
getOptionAlreadyDefined:selector:!options!public! !
getOptionExtractAssignment:!options!public! !
getOptionInlineExpression:!options!public! !
getOptionNewMethodName:classes:!options!public! !
getOptionRemoveMethod:referencedIn:!options!public! !
!

!Refactory.Browser.MoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Class icon! !

!Refactory.Browser.MoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		nextPutAll: class shortName;
		nextPutAll: '>>';
		print: selector;
		nextPutAll: '  to ';
		print: variable!

getOptionSelfArgumentName
	| newName existing |
	existing := parseTree allDefinedVariables.
	newName := (Prompter
				createOn: String new
				prompt: 'Enter name for argument to refer to "self" in extracted method'
				caption: self displayString)
				validater: 
						[:name |
						(existing includes: name)
							ifTrue: [ValidationResult errorMessage: '<d> is already in use as a local variable' << name]
							ifFalse: 
								[| result |
								result := ValidationResult new.
								moveToClasses allSatisfy: 
										[:each |
										| condition |
										condition := (Refactory.Browser.RBCondition isValidTemporaryVariableName: name)
													& (Refactory.Browser.RBCondition definesInstanceVariable: name in: each) not.
										condition validate: result].
								result]];
				showHintWhenEmpty: false;
				showModal.
	newName isNil ifTrue: [^self refactoringAborted: 'Method not moved/extracted'].
	^newName!

getOptionVariableTypes: choicesCollection selected: suggestionsCollection
	^(ChoicePrompter
		create: 'Extensible multi-selection choice prompter'
		on: suggestionsCollection asOrderedCollection
		multipleChoices: ((choicesCollection union: suggestionsCollection)
				asSortedCollection: [:a :b | a name < b name])
		caption: 'Select class(es) of new method… ')
		newPrompterBlock: 
				[:newModel |
				Smalltalk developmentSystem classChooserClass createOn: (newModel ?? class) realClass];
		newCaption: 'Add Other Class…';
		validater: 
				[:aClass |
				| result |
				result := ValidationResult new.
				aClass
					ifNil: 
						[result
							caption: 'Selection Required';
							errorMessage: 'Please select a target class for the method']
					ifNotNil: 
						[(self model classFor: aClass) ifNil: [result errorMessage: '<p> is not a visible class' << aClass]].
				result];
		newBlock: [:aClass | self model classFor: aClass];
		showModal!

resolveClass: aClass
	^self model classFor: aClass! !

!Refactory.Browser.MoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionSelfArgumentName!public! !
getOptionVariableTypes:selected:!options!public! !
resolveClass:!helpers!private! !
!

!Refactory.Browser.MoveVariableDefinitionRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		display: 'variable';
		nextPutAll: ' to inner scope in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !

!Refactory.Browser.MoveVariableDefinitionRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ProtectInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Protect'! !

!Refactory.Browser.ProtectInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !

!Refactory.Browser.PullUpClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !

!Refactory.Browser.PullUpClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !

!Refactory.Browser.PullUpInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !

!Refactory.Browser.PullUpInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownClassVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !

!Refactory.Browser.PushDownClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !

!Refactory.Browser.PushDownInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push down ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName! !

!Refactory.Browser.PushDownMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PushUpMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push up ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionCopyDownSuperclassMethod: aSelector
	^self
		confirm: 'Do you want to copy down the superclass method to the classes that don''t define <1p>?'
				<< aSelector!

getOptionPushUpRemoveDuplicates: aSymbol in: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following subclasses of ';
		nextPutAll: class superclass unqualifiedName;
		nextPutAll: ' will have a duplicate implementation:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	response := MessageBox new
				caption: self displayString;
				text: 'Pushing up <1p> from <2d> to <3d> will result in duplicate implementations in <4d> subclass<5?es:> of <3d>.'
							<< {aSymbol.
									class unqualifiedName.
									class superclass unqualifiedName.
									aCollection size.
									aCollection size > 1};
				headline: 'Remove duplicates of pushed up method?';
				customButtons: #(#(#yes '&Remove Duplicates') #(#no 'Don''t Remove'));
				defaultButton: 1;
				isCancellable: true;
				detailsText: details contents;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !

!Refactory.Browser.PushUpMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionCopyDownSuperclassMethod:!options!public! !
getOptionPushUpRemoveDuplicates:in:!options!public! !
!

!Refactory.Browser.RBAbstractClass methodsFor!

allSubclassesDo: aMonadicValuable
	"Evaluate the <monadicValuable> argument for each of the receiver's subclasses using a pre-order depth first traversal."

	self allSubclassesPreOrderDo: aMonadicValuable!

allSubclassesPreOrderDo: aMonadicValuable
	"Private - Evaluate the <monadicValuable> argument for each of the receiver's subclasses, visiting the receiver before its subclasses (i.e. a pre-order traversal)."

	self subclasses do: 
			[:each |
			aMonadicValuable value: each.
			each allSubclassesPreOrderDo: aMonadicValuable]!

isDeprecated
	^self realClass ifNil: [false] ifNotNil: [:real | real isDeprecated]!

isVisiblyAbstract
	^self realClass ifNil: [false] ifNotNil: [:real | real isVisiblyAbstract]! !

!Refactory.Browser.RBAbstractClass categoriesForMethods!
allSubclassesDo:!class hierarchy-accessing!enumerating!public! !
allSubclassesPreOrderDo:!class hierarchy-accessing!private! !
isDeprecated!public!testing! !
isVisiblyAbstract!public!testing! !
!

!Refactory.Browser.RBAbstractClass class methodsFor!

icon
	^Class icon!

instancesAreClasses
	^self subclassResponsibility! !

!Refactory.Browser.RBAbstractClass class categoriesForMethods!
icon!public! !
instancesAreClasses!public! !
!

!Refactory.Browser.RBAbstractCondition methodsFor!

validate
	| result |
	result := UI.ValidationResult new.
	self validate: result.
	^result!

validate: aValidationResult
	"Update the <ValidationResult> argument with results from evaluating this condition, answering whether the condition is satisfied."

	^(aValidationResult value: self check) or: [aValidationResult errorMessage: self errorString]! !

!Refactory.Browser.RBAbstractCondition categoriesForMethods!
validate!public! !
validate:!helpers!public! !
!

!Refactory.Browser.RBAbstractCondition class methodsFor!

icon
	^##((TextTileIcon text: '?' fontName: 'Georgia')
		textcolor: Color darkBlue;
		yourself)! !

!Refactory.Browser.RBAbstractCondition class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBClass methodsFor!

icon
	^realClass ifNil: [super icon] ifNotNil: [realClass icon]! !

!Refactory.Browser.RBClass categoriesForMethods!
icon!accessing!public! !
!

!Refactory.Browser.RBClass class methodsFor!

instancesAreClasses
	^true! !

!Refactory.Browser.RBClass class categoriesForMethods!
instancesAreClasses!public! !
!

!Refactory.Browser.RBMetaclass class methodsFor!

icon
	^Metaclass icon!

instancesAreClasses
	^false! !

!Refactory.Browser.RBMetaclass class categoriesForMethods!
icon!public! !
instancesAreClasses!public! !
!

!Refactory.Browser.RBMethod methodsFor!

hasCompilationFailures
	^
	[self parseTree analyze.
	false]
			on: Compiler errorClass
			do: [:ex | ex return: true]
			on: Compiler notificationClass
			do: [:ex | ex resume]!

hasCompilationIssues
	^
	[self parseTree analyze.
	false] on: Compiler notificationClass
			do: [:ex | ex severityClass == Notification ifTrue: [ex resume] ifFalse: [ex return: true]]!

owningPackage
	package ifNotNil: [^package].
	^compiledMethod ifNil: [class owningPackage] ifNotNil: [compiledMethod owningPackage]!

owningPackageIfLoose
	package ifNotNil: [^package].
	^compiledMethod ifNotNil: [compiledMethod owningPackageIfLoose]! !

!Refactory.Browser.RBMethod categoriesForMethods!
hasCompilationFailures!public!testing! !
hasCompilationIssues!public!testing! !
owningPackage!accessing!public! !
owningPackageIfLoose!accessing!public! !
!

!Refactory.Browser.RBMethod class methodsFor!

icon
	^CompiledMethod icon! !

!Refactory.Browser.RBMethod class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBModel methodsFor!

allResourceIdentifiers
	^SmalltalkSystem current allResourceIdentifiers select: [:each | environment includesResource: each]!

browseChanges
	Tools.RewriteChangesBrowser showOn: self changes!

methodsThatFailedToCompileIn: aBrowserEnvironment
	| caption env |
	caption := 'Finding methods with compilation failures in <1p>' expandMacrosWith: aBrowserEnvironment.
	env := SmalltalkSystem current
				selectMethods: 
					[:each |
					| modelClass |
					modelClass := self classFor: each methodClass.
					modelClass notNil and: 
							[| modelMethod |
							modelMethod := modelClass methodFor: each selector.
							modelMethod notNil and: [modelMethod hasCompilationFailures]]]
				in: aBrowserEnvironment
				withProgress: caption.
	env label: ('Compilation failures in <1p>' expandMacrosWith: aBrowserEnvironment).
	^env!

methodsWithCompilationIssuesIn: aBrowserEnvironment
	| caption env |
	caption := 'Finding methods with compilation issues in <1p>' expandMacrosWith: aBrowserEnvironment.
	env := SmalltalkSystem current
				selectMethods: 
					[:each |
					| modelClass |
					modelClass := self classFor: each methodClass.
					modelClass notNil and: 
							[| modelMethod |
							modelMethod := modelClass methodFor: each selector.
							modelMethod notNil and: [modelMethod hasCompilationIssues]]]
				in: aBrowserEnvironment
				withProgress: caption.
	env label: ('Compilation issues in <1p>' expandMacrosWith: aBrowserEnvironment).
	^env!

modelClassFor: aBehavior
	^aBehavior classInModel: self!

modelMethodFor: aCompiledMethod
	^aCompiledMethod methodInModel: self! !

!Refactory.Browser.RBModel categoriesForMethods!
allResourceIdentifiers!public! !
browseChanges!helpers!public! !
methodsThatFailedToCompileIn:!browsing!public! !
methodsWithCompilationIssuesIn:!public!searching! !
modelClassFor:!accessing/classes!public! !
modelMethodFor:!accessing/classes!public! !
!

!Refactory.Browser.RBModel class methodsFor!

icon
	^Smalltalk icon! !

!Refactory.Browser.RBModel class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBNamespaceClass class methodsFor!

icon
	^Namespace icon! !

!Refactory.Browser.RBNamespaceClass class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBPatternVariableNode class methodsFor!

icon
	^##((TextTileIcon text: '`@q' fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Refactory.Browser.RBPatternVariableNode class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RBRootNamespace class methodsFor!

icon
	^Root icon! !

!Refactory.Browser.RBRootNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBSmalltalkNamespace class methodsFor!

icon
	^Smalltalk icon! !

!Refactory.Browser.RBSmalltalkNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.Refactoring methodsFor!

chooseFrom: aCollection caption: aString
	"Dolphin specific choice prompt"

	^ChoicePrompter choices: aCollection asOrderedCollection caption: aString!

confirm: aString
	"Dolphin specific confirmation prompt"

	^MessageBox confirm: aString caption: self displayString!

maxDetails
	^30!

printNameList: aCollection on: aPuttableStream limit: maxInteger type: aString
	| count |
	count := aCollection size.
	aCollection
		from: 1
		to: (count min: maxInteger)
		do: 
			[:each |
			aPuttableStream
				cr;
				display: each].
	count > maxInteger
		ifTrue: 
			[aPuttableStream
				cr;
				nextPut: $…;
				cr;
				nextPutAll: 'And ';
				print: count - maxInteger;
				nextPutAll: ' further ';
				nextPutAll: aString;
				nextPut: $.]!

prompt: aString
	"Dolphin specific prompt for text input"

	^Prompter prompt: aString caption: self displayString! !

!Refactory.Browser.Refactoring categoriesForMethods!
chooseFrom:caption:!helpers!private! !
confirm:!helpers!public! !
maxDetails!constants!private! !
printNameList:on:limit:type:!helpers!private! !
prompt:!helpers!private! !
!

!Refactory.Browser.Refactoring class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Refactoring.ico'!

renameIcon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'InPlaceRename.ico'! !

!Refactory.Browser.Refactoring class categoriesForMethods!
icon!constants!public! !
renameIcon!constants!public! !
!

!Refactory.Browser.RefactoryClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Refactory.Browser.ClassDetails icon! !

!Refactory.Browser.RefactoryClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RefactoryMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^CompiledMethod icon! !

!Refactory.Browser.RefactoryMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassDelete.ico'! !

!Refactory.Browser.RemoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !

!Refactory.Browser.RemoveClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Remove '.
	classNames size == 1
		ifTrue: 
			[aPuttableStream
				nextPutAll: 'class ';
				display: classNames first]
		ifFalse: 
			[aPuttableStream nextPutAll: 'classes: '.
			classNames do: [:each | aPuttableStream display: each]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionRemoveClass: aRBClass referencedIn: aCollection
	| details response references |
	references := aCollection.
	details := String writeStream.
	details
		nextPutAll: 'Removing the class will leave ';
		nextPutAll: (references size = 1
					ifTrue: ['a dangling reference in this method']
					ifFalse: ['dangling references in these methods']);
		nextPutAll: ' and is potentially unsafe. It is recommended that you first browse these references and remove them before attempting to remove the class again:';
		cr.
	self
		printNameList: (references asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class?' << aRBClass;
				text: 'The class <1p> is referenced from <2d> method<3?:s>.'
							<< {aRBClass. references size. references size = 1};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[| env |
			env := self model environment.
			self openBrowserOn: ((env forMethods: (aCollection collect: [:each | each method]))
						label: 'References to class <1p>, or its name' << aRBClass;
						yourself)].
	^false! !

!Refactory.Browser.RemoveClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveClass:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !

!Refactory.Browser.RemoveClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring methodsFor!

getOptionRemoveVariable: aVariableBinding referencedIn: aCollection
	| args details response |
	args := {aVariableBinding environment.
				aVariableBinding key.
				aCollection size.
				aCollection size == 1}.
	details := String writeStream
				nextPutAll: 'Removing the class variable will leave <4?a dangling reference in this method:dangling references in these methods> and is potentially unsafe. It is recommended that you first browse <4?the reference:these references> and remove <4?it:them> before attempting to remove the variable again:'
							<< args;
				cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class variable?' << args;
				text: 'The class variable <1p>.<2s> is referenced from <3d> method<4?:s>.' << args;
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'References to <1p>.<2s>' << args;
						yourself)].
	^false! !

!Refactory.Browser.RemoveClassVariableRefactoring categoriesForMethods!
getOptionRemoveVariable:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !

!Refactory.Browser.RemoveClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove Import ';
		display: import;
		nextPutAll: ' from ';
		display: class! !

!Refactory.Browser.RemoveImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !

!Refactory.Browser.RemoveInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !

!Refactory.Browser.RemoveInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'MethodDelete.ico'! !

!Refactory.Browser.RemoveMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	(selectors size == 1 ifTrue: ['Remove <1p>>><4p>'] ifFalse: ['Remove <3p> methods from <1p>'])
		expandMacrosWithArguments: {class. selectors. selectors size. selectors first}
		on: aPuttableStream!

getOptionRemoveDuplicatesWithSupersends: superMessages
	| details |
	details := String writeStream.
	details
		nextPutAll: 'The following methods are equivalent to their superclass implementations, but contain a supersend so removing them might modify behavior.';
		cr.
	self
		printNameList: (superMessages asArray
				collect: [:each | '<1s>>><2p>' << {class unqualifiedName. each}]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	^MessageBox new
		caption: self displayString;
		headline: 'Remove duplicate methods with supersends?';
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		defaultButton: 2;
		detailsText: details contents;
		iconStyle: #warning;
		confirm! !

!Refactory.Browser.RemoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveDuplicatesWithSupersends:!options!public! !
!

!Refactory.Browser.RemoveParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove parameter ';
		print: argument;
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !

!Refactory.Browser.RemoveParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !

!Refactory.Browser.RemoveSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !

!Refactory.Browser.RenameAccessorsForVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Rename accessors for'!

icon
	^self renameIcon! !

!Refactory.Browser.RenameAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !

!Refactory.Browser.RenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameClassRefactoring methodsFor!

getOptionIgnoreSymbolicClassReferences: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following methods still reference the original unqualified class name symbol ';
		print: oldUnqualified;
		nextPut: $:;
		cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails // 2
		type: 'methods'.
	response := UI.MessageBox new
				caption: self displayString;
				headline: 'Class may have symbolic references.';
				text: 'The original class name ''<1s>'' may still be referenced symbolically in <2d> methods. If you proceed with the class rename these Symbols will not be renamed as it cannot be guaranteed that these are intended as references to the class being renamed.<n><n>It is recommended that you first browse all references to understand the use, and replace any real references to the class with literal BindingReferences.'
							<< {oldUnqualified. aCollection size};
				customButtons: #(#(#yes '&Rename Class') #(#no '&Browse Methods'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'Remaining references to class being renamed from <1p>' << oldUnqualified;
						yourself)].
	^false!

getOptionUpgradeLegacyPackage: aPackage
	| args |
	args := {oldUnqualified. aPackage. newName}.
	^UI.MessageBox new
		caption: self displayString;
		headline: 'Package upgrade required';
		text: 'The class ''<1d>'' is owned by the legacy format package ''<2d>'', which must be upgraded to complete the rename.'
					<< args;
		detailsText: 'Legacy format packages can only be used to save and load classes in the legacy Smalltalk namespace.<n><n>In order to proceed with renaming <1s> to <3s>, it will be necessary to upgrade the package to the new source format that supports namespaces.<n><n>New format packages cannot be loaded into versions of Dolphin prior to 8.x.'
					<< args;
		customButtons: #(#(#yes '&Upgrade Package') #(#no 'Cancel'));
		iconStyle: #warning;
		defaultButton: 2;
		isCancellable: true;
		confirm! !

!Refactory.Browser.RenameClassRefactoring categoriesForMethods!
getOptionIgnoreSymbolicClassReferences:!options!public! !
getOptionUpgradeLegacyPackage:!options!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !

!Refactory.Browser.RenameClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !

!Refactory.Browser.RenameClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName;
		nextPutAll: ' (and accessors) to ';
		print: newName! !

!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !

!Refactory.Browser.RenameInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !

!Refactory.Browser.RenameInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename ';
		print: oldSelector;
		nextPutAll: ' to ';
		print: newSelector! !

!Refactory.Browser.RenameMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameMethodRefactoring class methodsFor!

icon
	^self renameIcon! !

!Refactory.Browser.RenameMethodRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename temp ';
		print: oldName;
		nextPutAll: ' to ';
		print: newName;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !

!Refactory.Browser.RenameTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring class methodsFor!

icon
	^self renameIcon! !

!Refactory.Browser.RenameTemporaryRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !

!Refactory.Browser.RenameVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.SmalllintChecker class methodsFor!

newWithCachingContext
	^self new
		context: SmalllintCachingContext new;
		yourself! !

!Refactory.Browser.SmalllintChecker class categoriesForMethods!
newWithCachingContext!instance creation!public! !
!

!Refactory.Browser.TemporaryToInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert temp ';
		print: temporaryVariableName;
		nextPutAll: ' to inst var of ';
		nextPutAll: class unqualifiedName!

getOptionConvertReadBeforeWritten: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Convert read-before-written temporary?';
		text: '<1p> is read before it is written and if converted to an instance variable it may not be initialized before use.' << aString;
		customButtons: #(#(#yes '&Convert') #(#no '&Don''t Convert'));
		defaultButton: 2;
		iconStyle: #warning;
		confirm! !

!Refactory.Browser.TemporaryToInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionConvertReadBeforeWritten:!options!public! !
!

!Refactory.Browser.TransformationRule class methodsFor!

bitLogicElimination
	"Inlining of methods may create redundant bit logic operations where the operation is a no-op or has a constant outcome. This transformation can eliminate some cases."


	^self
		rewrite: #(
			#('0 bitOr: ``@arg' 	"->" 	'``@arg')
			#('0 | ``@arg' 	"->" 	'``@arg')
			#('``@arg bitOr: 0' 	"->" 	'``@arg')
			#('``@arg | 0 ' 	"->" 	'``@arg')

			#('0 bitAnd: ``@arg' 	"->" 	'0')
			#('0 & ``@arg' 	"->" 	'0')
			#('``@arg bitAnd: 0' 	"->" 	'0')
			#('``@arg & 0 ' 	"->" 	'0')
		)			
		methods: false
		name: 'Eliminate redundant bit operations'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

ifElimination
	"Inlining of methods may create unecessary ifTrue:[ifFalse:] statements where the condition
	is a constant boolean value. This transformation is useful for eliminating these."

	^self 
		rewrite: #(#(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After'))
		methods: false
		name: 'Eliminate unnecessary ifTrue:[ifFalse:] conditions'!

renameArgument: beforeString to: afterString
	^Refactory.Browser.TransformationRule new
		name: ('Rename argument <1p> to <2p>' expandMacrosWith: beforeString with: afterString);
		rewriteUsing: (Refactory.Browser.ParseTreeRewriter new
					renameArgument: beforeString to: afterString;
					replace: beforeString with: afterString;
					yourself);
		yourself! !

!Refactory.Browser.TransformationRule class categoriesForMethods!
bitLogicElimination!public!transformations! !
icon!constants!public! !
ifElimination!public!transformations! !
renameArgument:to:!public! !
!

!Refactory.Browser.VariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName!

displayPrefix
	^self class displayPrefix!

getOptionPullUpNonSharedInstVar: aString
	| with without details max |
	with := OrderedCollection new.
	without := OrderedCollection new.
	class subclasses do: 
			[:each |
			((each directlyDefinesInstanceVariable: variableName) ifTrue: [with] ifFalse: [without]) add: each].
	details := String writeStream.
	details
		print: aString;
		nextPutAll: ' is defined in:';
		cr.
	max := self maxDetails // 2.
	self
		printNameList: with
		on: details
		limit: max
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'But is not defined in:';
		cr.
	self
		printNameList: without
		on: details
		limit: max
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Pull up non-shared instance variable?';
		text: 'Not all subclasses of <1d> have an instance variable named <2p>.<n><n>Do you want pull up this variable anyway?'
					<< {class. aString};
		customButtons: #(#(#yes '&Pull Up') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		isCancellable: true;
		iconStyle: #warning;
		confirm! !

!Refactory.Browser.VariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
displayPrefix!displaying!public! !
getOptionPullUpNonSharedInstVar:!options!public! !
!

!Refactory.Browser.VariableRefactoring class methodsFor!

displayPrefix
	^self subclassResponsibility! !

!Refactory.Browser.VariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Tools.ChooseNamespaceDialog methodsFor!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	self add: BooleanPresenter new name: 'showChanges'!

showChanges
	^(self presenterNamed: 'showChanges') value! !

!Tools.ChooseNamespaceDialog categoriesForMethods!
createComponents!initializing!public! !
showChanges!accessing!public! !
!

!Tools.ChooseNamespaceDialog class methodsFor!

resource_Refactoring_view
	"Answer the literal data from which the 'Refactoring view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_view)
	"

	^#(#'!!STL' 6 2118 11 #{UI.STBViewProxy} #{UI.DialogView} 38 #{Core.Array} 34 nil nil 8 #(13369344 65536) 32 nil 518 #{Graphics.ThemeColor} #dialog nil 133 nil 1350 1 #{Graphics.Font} nil true 262 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 193 nil nil 32 1798 #{UI.BorderLayout} 1 11 nil 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140850688 131073 240 nil nil nil 5 nil nil nil 240 582 1 #{UI.ResourceIdentifier} #{UI.Presenter} #resource_Refactoring_OK_Cancel_button_block nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createWindow: 50 1 1030 #{UI.CreateWindow} 262 #{OS.RECTL} 8 #[10 0 0 0 78 1 0 0 98 1 0 0 110 1 0 0] 193 272 8 '' 240 3 8 #() 518 #{Graphics.Point} 193 193 nil 27 nil nil 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140850688 132097 576 nil nil nil 5 nil nil nil 576 306 #{Tools.ClassHierarchySelector} #resource_Default_view nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[10 0 0 0 10 0 0 0 98 1 0 0 73 1 0 0] 193 608 8 '' 576 3 528 546 193 193 nil 27 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 50 2 576 8 'classSelector' 518 #{Graphics.Rectangle} 546 21 21 546 21 11 nil nil nil nil 1 nil nil nil 546 661 521 1 nil 193 774 #{Core.Semaphore} nil nil 1 nil nil nil nil nil nil 338 50 2 386 #createWindow: 50 1 518 #{UI.CreateDialog} 866 546 7679 21 546 8439 841 193 32 386 #setWindowText: 50 1 8 'Choose Target Namespace…' 32 1 50 2 576 240 546 193 193 nil 29)! !

!Tools.ChooseNamespaceDialog class categoriesForMethods!
resource_Refactoring_view!public!resources-views! !
!

!Tools.ClassBrowserAbstract methodsFor!

abstractInstanceVariables
	"Private - Invoke the 'Abstract Instance Variable' refactoring on the currently selected variables."

	<commandQuery: #hasInstanceVariablesSelected>
	self model abstractInstanceVariables: self variables within: BrowserEnvironment new!

canPushDownInstanceVariables
	| class |
	^(class := self actualClass) notNil and: [class subclasses notEmpty and: [self variables notEmpty]]!

canPushDownMethods
	^self methodRefactoringTool canPushDownMethods
		and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]!

canPushUpMethods
	^self methodRefactoringTool canPushUpMethods
		and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]!

methodRefactoringsMenu
	"The Method/Refactorings menu should be enabled if there is a class selection as some commands may prompt for the target method(s) even if there is no method selection."

	<commandQuery: #hasClassSelected>
	!

methodRefactoringTool
	^methodBrowserPresenter refactoringTool!

methodsToOverride
	| methods class selectedClass |
	methods := self selectedOverridableMethods.
	methods notEmpty ifTrue: [^methods].
	methods := IdentityDictionary new.
	selectedClass := self actualClass.
	class := selectedClass superclass.
	[class isNil] whileFalse: 
			[class methodDictionary keysAndValuesDo: 
					[:eachSelector :eachMethod |
					(eachSelector first ~~ $_ and: [(eachSelector beginsWith: 'basic') not])
						ifTrue: [methods at: eachSelector put: eachMethod]].
			class := class superclass].
	^(ChoicePrompter multipleChoices: methods keys asSortedCollection
		caption: 'Choose Methods to Override…')
			ifNotNil: [:selectors | selectors collect: [:each | selectedClass lookupMethod: each]]!

overrideMethods
	<commandQuery: #queryOverrideMethods:>
	| stream class changes name methods devsys |
	class := self actualClass.
	#todo. "Encapsulate into a Refactoring class"
	stream := String writeStream.
	changes := CompositeRefactoryChange new.
	methods := self methodsToOverride.
	(methods isNil or: [methods isEmpty]) ifTrue: [^self].
	devsys := self developmentSystem.
	methods do: 
			[:each |
			| keywordsAndArgs |
			stream reset.
			keywordsAndArgs := devsys keywordsAndArgsOfMethod: each.
			devsys printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			stream
				crtab;
				nextPutAll: '^super';
				space.
			devsys printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			changes addChange: (AddMethodChange
						compile: stream contents
						in: class
						environment: each environment
						categories: each categories
						package: each owningPackageIfLoose)].
	name := String writeStream.
	name nextPutAll: 'Override '.
	methods size > 1
		ifTrue: 
			[name
				print: methods size;
				nextPutAll: ' methods']
		ifFalse: [name print: methods first].
	changes name: name contents.
	devsys changeManager performChange: changes.
	self selectedMethods: (methodBrowserPresenter methodsPresenter list
				intersection: ((methods collect: [:each | each selector]) asSet
						collect: [:each | class compiledMethodAt: each ifAbsent: nil]))!

protectInstanceVariables
	"Private - Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables."

	<commandQuery: #hasInstanceVariablesSelected>
	self model protectInstanceVariables: self variables!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the currently selected variables."

	<commandQuery: #canPushDownInstanceVariables>
	self model pushDownInstanceVariables: self variables!

pushDownMethods
	<acceleratorKey: 'Shift+Ctrl+7'>
	<commandQuery: #canPushDownMethods>
	self pushMethods: false!

pushMethods: aBoolean
	| change isShift methods targetClass |
	isShift := Keyboard default isShiftDown.
	methods := self selectedMethods.
	"It is assumed that the methods are all of the same class (the 'push method' commands are disabled if not)"
	targetClass := methods first methodClass.
	targetClass := aBoolean ifTrue: [targetClass superclass] ifFalse: [targetClass subclasses first].
	change := self methodRefactoringTool pushMethods: aBoolean.
	(change isNil or: [isShift not]) ifTrue: [^self].
	methods := (methods asSet
				collect: [:each | targetClass compiledMethodAt: each selector ifAbsent: nil]) asArray.
	self actualClass: methods first methodClass ifAbsent: [^self].
	self selectedMethods: methods!

pushUpMethods
	<acceleratorKey: 'Shift+Ctrl+6'>
	<commandQuery: #canPushUpMethods>
	self pushMethods: true!

queryOverrideMethods: aCommandQuery
	| class methods |
	class := self actualClass.
	class superclass ifNil: [^self].
	methods := self selectedOverridableMethods.
	aCommandQuery
		beEnabled;
		expandMenuTextWith: (methods size == 1 ifTrue: [methods single] ifFalse: ['Methods'])!

queryRemoveInstanceVariables: aCommandQuery
	| instVars |
	instVars := self variables.
	instVars isEmpty ifTrue: [^self].
	aCommandQuery
		beEnabled;
		expandMenuTextWith: (instVars size = 1
					ifTrue: ['instance variable <p>' << instVars single value]
					ifFalse: ['instance variables'])!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the currently selected variables."

	<commandQuery: #queryRemoveInstanceVariables:>
	self model removeInstanceVariables: self variables within: self searchEnvironment!

renameMethod
	(self chooseMethodForRefactoring: nil caption: 'Choose Method to Rename in <d>…')
		ifNotNil: [:method | self methodRefactoringTool renameMethod: method]!

selectedOverridableMethods
	| class |
	class := self actualClass.
	^self selectedMethods reject: [:each | each methodClass == class]! !

!Tools.ClassBrowserAbstract categoriesForMethods!
abstractInstanceVariables!commands-actions!private!refactoring! !
canPushDownInstanceVariables!private!refactoring!testing! !
canPushDownMethods!private!refactoring!testing! !
canPushUpMethods!private!refactoring!updating! !
methodRefactoringsMenu!commands-menus!public! !
methodRefactoringTool!commands-actions!private!refactoring! !
methodsToOverride!helpers!private! !
overrideMethods!commands-actions!private!refactoring! !
protectInstanceVariables!commands-actions!private!refactoring! !
pushDownInstanceVariables!commands-actions!public!refactoring! !
pushDownMethods!commands-actions!public!refactoring! !
pushMethods:!commands-actions!private!refactoring! !
pushUpMethods!commands-actions!public!refactoring! !
queryOverrideMethods:!commands-queries!private!refactoring! !
queryRemoveInstanceVariables:!commands-queries!private! !
removeInstanceVariables!public!refactoring! !
renameMethod!accessing!private! !
selectedOverridableMethods!accessing!private! !
!

!Tools.ClassBrowserPlugin methodsFor!

developmentSystem
	^SmalltalkSystem current! !

!Tools.ClassBrowserPlugin categoriesForMethods!
developmentSystem!accessing!private! !
!

!Tools.ClassSelector methodsFor!

abstractClassVariables
	"Invoke the 'Abstract Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithStaticVariables>
	(self chooseVariables: true caption: 'Abstract Class Variables…')
		ifNotNil: [:varNames | self developmentSystem abstractClassVariables: varNames within: BrowserEnvironment new]!

abstractInstanceVariables
	"Invoke the 'Abstract Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithInstanceVariables>
	<menuPopulator: #buildAbstractInstanceVariablesMenu:>
	(self chooseVariables: false caption: 'Abstract Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem abstractInstanceVariables: varNames within: BrowserEnvironment new]!

abstractVariables
	<commandQuery: #hasClassWithVariablesSelected>
	<menuPopulator: #buildAbstractVariablesMenu:>
	Sound warningBeep!

addClassVariable
	"Private - Invoke the 'Add Class Variable' refactoring to add a class variable to the
	currently selected class."

	<commandQuery: #hasSingleSelection>
	self developmentSystem addClassVariableTo: self selection!

addImport
	<commandQuery: #hasSelection>
	self developmentSystem addImportToClasses: self selections!

addInstanceVariable
	"Private - Invoke the 'Add Instance Variable' refactoring to add an instance variable to the
	currently selected class."

	<commandQuery: #queryAddInstanceVariable:>
	self developmentSystem addInstanceVariableTo: self actualClass!

buildInstVarMenu: aMenu selectors: selectors
	"Private - Build a dynamic pull-out menu which lists all of a class' existing inst. var. 
	names so that one or other can be removed, renamed, etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: selectors!

buildPullUpVariablesMenu: aMenu
	| class items |
	aMenu clear.
	class := self actualClass.
	(ClassBuilder isFixedLayout: class)
		ifFalse: 
			[self
				populatePullUpVariableMenu: aMenu
				forClass: class
				command: #pullUpInstanceVariable:into:
				classVariables: false
				ifTooMany: #pullUpInstanceVariables.
			aMenu notEmpty ifTrue: [aMenu addSeparator]].
	self
		populatePullUpVariableMenu: aMenu
		forClass: class instanceClass
		command: #pullUpClassVariable:into:
		classVariables: true
		ifTooMany: #pullUpClassVariables.
	items := aMenu items.
	(items notEmpty and: [items last isDivider]) ifTrue: [aMenu removeItemAt: items size]!

buildVariablesMenu: aMenu instVarSelectors: instVarSelectors classVarSelectors: classVarSelectors 
	"Private - Build a dynamic pull-out menu which lists all of a class' existing 
	instance and class variable names so that one or other can be removed, renamed, 
	etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: instVarSelectors.
	(aMenu notEmpty and: [self selection classPool notEmpty]) ifTrue: [aMenu addSeparator].
	self populateClassVarMenu: aMenu selectors: classVarSelectors!

canChangeClassNamespace
	^self developmentSystem canChangeClassNamespaces: self selections!

canPullUpClassVariables
	| class |
	class := self actualClass.
	^class notNil
		and: [class instanceClass allSubclasses anySatisfy: [:each | each classBindingNames notEmpty]]!

canPullUpInstanceVariables
	| class |
	class := self actualClass.
	^class notNil and: [class allSubclasses anySatisfy: [:each | each instanceVariableNames notEmpty]]!

canPullUpVariables
	| class |
	class := self actualClass.
	^class notNil and: 
			[| isFixed |
			isFixed := ClassBuilder isFixedLayout: class.
			class allSubclasses anySatisfy: 
					[:each |
					(isFixed not and: [each instanceVariableNames notEmpty])
						or: [each instanceClass classBindingNames notEmpty]]]!

canPushDownInstanceVariables
	| class |
	class := self actualClass.
	^class notNil and: [class subclasses notEmpty and: [class instanceVariableNames notEmpty]]!

canPushDownVariables
	| class |
	class := self actualClass.
	^class notNil and: 
			[class subclasses notEmpty
				and: [class instanceVariableNames notEmpty or: [class instanceClass definedBindings notEmpty]]]!

changeClassNamespace
	<commandQuery: #canChangeClassNamespace>
	self developmentSystem changeNamespaceOfClasses: self selections!

classRefactoringsMenu
	<commandQuery: #hasSelection>
	Sound warningBeep!

cloneClass: aClass under: superClass changes: aCompositeRefactoryChange
	| namespace newName |
	namespace := RBModel new
				changes: aCompositeRefactoryChange;
				yourself.
	newName := aClass asQualifiedReference.
	
	[newName := BindingReference path: (newName path allButLast copyWith: 'CopyOf' , newName path last).
	newName isDefined]
			whileTrue.
	(CopyClassRefactoring
		model: namespace
		clone: aClass
		as: newName pathString
		superclass: superClass) primitiveExecute!

convertToSibling
	"Invoke the 'Convert to Sibling' refactoring (inserts a new class as the common superclass of the selected
	class and its current subclasses, copying common methods to the new superclass and adding 
	#subclassResponsibility methods as necessary)."

	<commandQuery: #hasSingleSelection>
	self developmentSystem convertToSibling: self selection!

createClassVariableAccessors
	"Prompt to generate compiled 'get' and 'set' accessor methods for the immediate
	class variables of the selected class."

	<commandQuery: #hasClassWithStaticVariables>
	self createVariableAccessors: true!

createVariableAccessors
	<commandQuery: #hasClassWithVariablesSelected>
	<menuPopulator: #buildCreateVariableAccessorsMenu:>
	Sound warningBeep!

hasImports
	| imports |
	imports := Set new.
	self selections do: [:each | imports addAll: each imports].
	^imports notEmpty!

populateClassVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self selection.
	varNames := class classBindingNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Class Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populateInstVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self actualClass.
	varNames := class instanceVariableNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Instance Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populatePullUpVariableMenu: aMenu forClass: aClass command: commandSymbol classVariables: aBoolean ifTooMany: tooManyCommand
	| pairs |
	pairs := self
				pullUpVariableNamePairs: aBoolean
				for: aClass
				maximum: self maximumVariableMenuEntries.
	pairs isNil
		ifTrue: 
			[aMenu addCommand: tooManyCommand
				description: (aBoolean ifTrue: ['&Class Variable…'] ifFalse: ['&Instance Variable…'])]
		ifFalse: 
			[(pairs
				asSortedArray: [:p1 :p2 | p1 key == p2 key ifTrue: [p1 value < p2 value] ifFalse: [p1 key name < p2 key name]])
					do: 
						[:each |
						| msg varName |
						varName := each value.
						msg := MessageSend
									receiver: self developmentSystem
									selector: commandSymbol
									arguments: {varName. aClass}.
						aMenu addCommand: msg description: each key name , '.' , varName]]!

protectInstanceVariables
	"Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithInstanceVariables>
	<menuPopulator: #buildProtectInstanceVariablesMenu:>
	(self chooseVariables: false caption: 'Protect Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem protectInstanceVariables: varNames]!

protectVariables
	<commandQuery: #hasClassWithVariablesSelected>
	<menuPopulator: #buildProtectInstanceVariablesMenu:>
	Sound warningBeep!

pullUpClassVariables
	"Invoke the 'Pull Up Class Variable' refactoring on the users choice of subclass' class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #canPullUpClassVariables>
	| class pairs |
	class := self selection.
	pairs := self
				pullUpVariableNamePairs: true
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Class Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self developmentSystem.
			pairs do: [:each | devsys pullUpClassVariable: each value into: class]]!

pullUpInstanceVariables
	"Invoke the 'Pull Up Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #canPullUpInstanceVariables>
	| class pairs |
	class := self actualClass.
	pairs := self
				pullUpVariableNamePairs: false
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Instance Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self developmentSystem.
			pairs do: [:each | devsys pullUpInstanceVariable: each value into: class]]!

pullUpVariableNamePairs: aBoolean for: class maximum: anInteger
	| pairs varNames |
	varNames := Set new.
	pairs := OrderedCollection new.
	class allSubclassesDo: 
			[:subclass |
			(aBoolean ifTrue: [subclass classBindingNames] ifFalse: [subclass instanceVariableNames]) do: 
					[:each |
					(varNames includes: each)
						ifFalse: 
							[varNames add: each.
							varNames size > anInteger ifTrue: [^nil].
							pairs add: subclass -> each]]].
	^pairs!

pullUpVariables
	<commandQuery: #canPullUpVariables>
	<menuPopulator: #buildPullUpVariablesMenu:>
	!

pushDownClassVariables
	"Invoke the 'Push Down Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithStaticVariables>
	(self chooseVariables: true caption: 'Push Down Class Variables…')
		ifNotNil: [:varNames | self developmentSystem pushDownInstanceVariables: varNames]!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #canPushDownInstanceVariables>
	<menuPopulator: #populatePushDownInstanceVariableMenu:>
	(self chooseVariables: false caption: 'Push Down Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem pushDownInstanceVariables: varNames]!

pushDownVariables
	<commandQuery: #canPushDownVariables>
	<menuPopulator: #buildPushDownVariablesMenu:>
	!

queryAddInstanceVariable: aCommandQuery
	| class prefix |
	class := self actualClass.
	(class notNil and: [class isPointers]) ifFalse: [^self].
	prefix := class isMeta ifTrue: ['Class '] ifFalse: [''].
	aCommandQuery
		beEnabled;
		expandMenuTextWith: prefix!

removeClassVariables
	"Invoke the 'Remove Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithStaticVariables>
	(self chooseVariables: true caption: 'Remove Class Variables…')
		ifNotNil: [:pairs | self developmentSystem removeStaticVariables: pairs within: self searchEnvironment]!

removeDuplicateMethods
	<commandQuery: #hasSingleSelection>
	| class |
	class := self actualClass.
	(self developmentSystem removeMethodsDuplicatedInSuperclassOf: class)
		ifFalse: 
			[MessageBox new
				iconStyle: #notify;
				uniqueId: [self] method;
				isSuppressible: true;
				headline: '<1p> does not duplicate any of its superclass'' methods' << class;
				open]!

removeImport
	<commandQuery: #hasImports>
	self developmentSystem removeImportFromClasses: self selections!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuery: #hasClassWithInstanceVariables>
	(self chooseVariables: false caption: 'Remove Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem removeInstanceVariables: varNames within: self searchEnvironment]!

removeVariables
	<commandQuery: #hasClassWithVariablesSelected>
	<menuPopulator: #buildRemoveVariablesMenu:>
	Sound warningBeep! !

!Tools.ClassSelector categoriesForMethods!
abstractClassVariables!commands-actions!public!refactoring! !
abstractInstanceVariables!commands-actions!public!refactoring! !
abstractVariables!commands-actions!private! !
addClassVariable!commands-actions!private!refactoring! !
addImport!commands-actions!public!refactoring! !
addInstanceVariable!commands-actions!private!refactoring! !
buildInstVarMenu:selectors:!menus!private!refactoring! !
buildPullUpVariablesMenu:!menus!private!refactoring! !
buildVariablesMenu:instVarSelectors:classVarSelectors:!menus!private!refactoring! !
canChangeClassNamespace!private!testing! !
canPullUpClassVariables!private!refactoring!testing! !
canPullUpInstanceVariables!private!refactoring!testing! !
canPullUpVariables!private!refactoring!testing! !
canPushDownInstanceVariables!private!refactoring!testing! !
canPushDownVariables!private!refactoring!testing! !
changeClassNamespace!commands-actions!public!refactoring! !
classRefactoringsMenu!commands-menus!public!refactoring! !
cloneClass:under:changes:!private! !
convertToSibling!commands-actions!public!refactoring! !
createClassVariableAccessors!commands-actions!public!refactoring! !
createVariableAccessors!commands-menus!private! !
hasImports!private!refactoring!testing! !
populateClassVarMenu:selectors:!menus!private!refactoring! !
populateInstVarMenu:selectors:!menus!private!refactoring! !
populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:!menus!private!refactoring! !
protectInstanceVariables!commands-actions!public!refactoring! !
protectVariables!commands-actions!private! !
pullUpClassVariables!commands-actions!public!refactoring! !
pullUpInstanceVariables!commands-actions!public!refactoring! !
pullUpVariableNamePairs:for:maximum:!menus!private!refactoring! !
pullUpVariables!commands-actions!private! !
pushDownClassVariables!commands-actions!public!refactoring! !
pushDownInstanceVariables!commands-actions!public!refactoring! !
pushDownVariables!commands-actions!private! !
queryAddInstanceVariable:!commands-queries!private! !
removeClassVariables!commands-actions!public!refactoring! !
removeDuplicateMethods!commands-actions!private!refactoring! !
removeImport!commands-actions!public!refactoring! !
removeInstanceVariables!commands-actions!public!refactoring! !
removeVariables!commands-actions!private! !
!

!Tools.CreateSubclassDialog class methodsFor!

resource_Refactoring_view
	"Answer the literal data from which the 'Refactoring view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_view)
	"

	^#(#'!!STL' 6 2118 11 #{UI.STBViewProxy} #{UI.DialogView} 38 #{Core.Array} 34 nil nil 8 #(13369344 65536) 32 nil 518 #{Graphics.ThemeColor} #dialog nil 133 nil 1350 1 #{Graphics.Font} nil true 262 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 193 nil nil 32 1798 #{UI.BorderLayout} 1 11 nil 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140850688 131073 240 nil nil nil 5 nil nil nil 240 582 1 #{UI.ResourceIdentifier} #{UI.Presenter} #resource_Refactoring_OK_Cancel_button_block nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createWindow: 50 1 1030 #{UI.CreateWindow} 262 #{OS.RECTL} 8 #[12 0 0 0 145 1 0 0 176 1 0 0 177 1 0 0] 193 272 8 '' 240 3 8 #() 518 #{Graphics.Point} 193 193 nil 27 nil nil 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 576 nil nil nil 5 nil nil nil 576 210 1 1 18 #{UI.ContainerView} 50 15 nil 576 50 2 8 1140850688 131073 656 nil nil nil 5 nil nil nil 656 262 #{UI.FramingLayout} 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.LookupTable} 50 18 18 #{UI.TextEdit} 50 20 nil 656 50 2 8 1140916352 1025 800 nil 6 #{Graphics.Color} #default nil 5 nil nil nil 800 nil nil 518 #{UI.NullConverter} nil nil 1 #perChar nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[100 0 0 0 0 0 0 0 137 1 0 0 22 0 0 0] 193 832 nil 800 386 #setMarginWidths: 50 1 8 #(3 3) 800 3 8 #() 546 193 193 nil 45 2118 2 #{UI.FramingConstraints} 1030 #{UI.FramingCalculation} #fixedPreviousRight 1 1154 #fixedParentRight -53 1154 #fixedPreviousTop -3 1154 #fixedViewTop 45 18 #{UI.StaticText} 50 16 nil 656 50 2 8 1140850944 1 1232 nil nil nil 5 nil nil nil 1232 nil nil 898 nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 2 0 0 0 100 0 0 0 24 0 0 0] 193 1264 nil 1232 386 #text: 50 1 8 'New &class name:' 1232 3 8 #() 546 193 193 nil 27 1122 1154 #fixedParentLeft 1 1154 #fixedViewLeft 201 1154 #fixedParentTop 5 1216 45 18 #{UI.StaticText} 50 16 nil 656 50 2 8 1140850944 1 1568 nil nil nil 5 nil nil nil 1568 nil nil 898 nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 30 0 0 0 100 0 0 0 52 0 0 0] 193 1600 nil 1568 386 #text: 50 1 8 '&Namespace:' 1568 3 8 #() 546 193 193 nil 27 1122 1520 1 1536 201 1154 #fixedPreviousBottom 17 1216 45 18 #{UI.TextEdit} 50 20 nil 656 50 2 8 1140850816 262145 1872 nil 880 nil 5 nil nil nil 1872 nil nil 898 nil nil 3 #perChar nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[100 0 0 0 30 0 0 0 137 1 0 0 50 0 0 0] 193 1904 nil 1872 386 #setMarginWidths: 50 1 8 #(3 3) 1872 3 8 #() 546 193 193 nil 45 1122 1168 1 1184 -53 1200 1 1216 41 18 #{UI.PushButton} 50 20 nil 656 50 2 8 1140924416 1 2160 nil 880 nil 5 nil nil nil 2160 nil nil 1350 4 #{UI.CommandDescription} #chooseNamespace 8 '…' 1 1 nil nil false nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[144 1 0 0 30 0 0 0 164 1 0 0 50 0 0 0] 193 2192 8 '…' 2160 386 #isEnabled: 8 #(false) 2160 3 8 #() 546 193 193 nil 29 1122 1168 15 1536 41 1200 1 1216 41 18 #{UI.TextEdit} 50 20 nil 656 50 2 8 1140850816 262145 2480 nil nil nil 5 nil nil nil 2480 nil nil 898 nil nil 3 #perChar nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[100 0 0 0 57 0 0 0 137 1 0 0 77 0 0 0] 193 2512 nil 2480 386 #setMarginWidths: 50 1 8 #(3 3) 2480 3 8 #() 546 193 193 nil 45 1122 1168 1 1184 -53 1200 -1 1216 41 18 #{UI.PushButton} 50 20 nil 656 50 2 8 1140924416 1 2768 nil 880 nil 5 nil nil nil 2768 nil nil 2226 #chooseSuperclass 8 '…' 1 1 nil nil false nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[144 1 0 0 57 0 0 0 164 1 0 0 77 0 0 0] 193 2800 8 '…' 2768 386 #isEnabled: 8 #(false) 2768 3 8 #() 546 193 193 nil 29 1122 1168 15 1536 41 1200 1 1216 41 18 #{UI.StaticText} 50 16 nil 656 50 2 8 1140850944 1 3072 nil nil nil 5 nil nil nil 3072 nil nil 898 nil nil nil 338 50 2 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 58 0 0 0 100 0 0 0 80 0 0 0] 193 3104 nil 3072 386 #text: 50 1 8 '&Superclass:' 3072 3 8 #() 546 193 193 nil 27 1122 1520 1 1536 201 1856 17 1216 45 18 #{UI.ContainerView} 50 15 nil 656 50 2 8 1140850688 131073 3360 nil nil nil 5 nil nil nil 3360 722 754 #{Core.LookupTable} 50 8 18 #{UI.GroupBox} 50 14 nil 3360 50 2 8 1140981767 1 3472 nil nil nil 5 nil nil nil 3472 nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 0 0 0 0 164 1 0 0 50 0 0 0] 193 3504 8 'Attributes' 3472 3 8 #() 546 193 193 nil 27 1122 1520 1 1184 1 1552 1 1154 #fixedParentBottom 1 18 #{UI.CheckBox} 50 16 nil 3360 50 2 8 1409363203 1 3728 1094 2 #{UI.ValueHolder} nil nil 6 #{Kernel.NeverSearchPolicy} false nil nil 5 nil nil nil 3728 nil nil 898 nil nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[12 0 0 0 18 0 0 0 92 0 0 0 40 0 0 0] 193 3760 8 '&Abstract?' 3728 3 8 #() 546 193 193 nil 27 1122 1520 25 1536 161 1552 37 1216 45 18 #{UI.CheckBox} 50 16 nil 3360 50 2 8 1409363203 1 4048 3794 nil nil 3840 false nil nil 5 nil nil nil 4048 nil nil 898 nil nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[92 0 0 0 18 0 0 0 180 0 0 0 40 0 0 0] 193 4080 8 '&Indexable?' 4048 3 8 #() 546 193 193 nil 27 1122 1168 1 1536 177 1200 1 1216 45 18 #{UI.CheckBox} 50 16 nil 3360 50 2 8 1409363203 1 4320 3794 nil nil 3840 false nil nil 5 nil nil nil 4320 nil nil 898 nil nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[180 0 0 0 18 0 0 0 235 0 0 0 40 0 0 0] 193 4352 8 '&Bytes?' 4320 3 8 #() 546 193 193 nil 27 1122 1168 1 1536 111 1200 1 1216 45 754 #{Core.IdentityDictionary} 50 6 4320 8 'isBytes' 3728 8 'isNonInstantiable' 4048 8 'isVariable' nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 83 0 0 0 164 1 0 0 133 0 0 0] 193 3392 8 '' 3360 3 50 4 3728 4048 4320 3472 546 193 193 nil 27 1122 1520 1 1184 1 1856 13 1216 101 754 #{Core.IdentityDictionary} 50 10 3360 8 'attributes' 2160 8 'chooseNamespace' 800 8 'className' 1872 8 'namespace' 2480 8 'superclass' nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 0 0 0 0 164 1 0 0 139 0 0 0] 193 688 8 '' 656 3 50 9 1232 800 1568 1872 2160 3072 2480 2768 3360 546 193 193 nil 27 nil nil nil 18 #{UI.ContainerView} 50 15 nil 576 50 2 8 1140850688 131073 5120 nil nil nil 5 nil nil nil 5120 518 #{UI.ProportionalLayout} 550 #{Core.LookupTable} 0 false 754 #{Core.IdentityDictionary} 50 2 18 #{UI.ListView} 50 45 nil 5120 50 2 8 1140953161 1025 5280 838 2 #{UI.ListModel} 550 #{Core.OrderedCollection} 0 nil 6 #{Kernel.IdentitySearchPolicy} 880 nil 5 nil nil nil 5280 nil nil 518 #{Core.Message} #displayString 8 #() 5442 #iconImageIndex 5472 1350 1 #{Graphics.IconImageManager} nil nil nil 546 65 65 nil nil 5378 1 3142 5 #{UI.ListViewColumn} 8 'Subclasses' 409 #left 5456 5442 #<= 8 #() nil nil 5280 nil 3 nil nil #report 8 #() nil 133185 nil 1 nil nil nil nil 1 262 #{UI.ListViewVirtualUpdateMode} 5280 nil nil nil nil nil nil nil nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[212 0 0 0 3 0 0 0 164 1 0 0 247 0 0 0] 193 5312 8 'Subclasses' 5280 3 8 #() 546 193 193 nil 35 8 'subclasses' 518 #{Graphics.Rectangle} 546 1 7 546 1 1 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 139 0 0 0 164 1 0 0 130 1 0 0] 193 5152 8 '' 5120 3 50 3 18 #{UI.ContainerView} 50 15 nil 5120 50 2 8 1140850688 131073 6080 nil nil nil 21 nil nil nil 6080 210 1 1 18 #{UI.CheckBox} 50 16 nil 6080 50 2 8 1140924419 1 6160 3794 nil false 518 #{Kernel.PluggableSearchPolicy} 5442 #= 8 #() 5442 #hash 8 #() false nil nil 5 nil nil nil 6160 nil nil 898 nil nil nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 255 255 255 255 207 0 0 0 24 0 0 0] 193 6192 8 '&Packaged?' 6160 3 8 #() 546 193 193 nil 27 nil nil nil 18 #{UI.ReferenceView} 50 14 nil 6080 50 2 8 1140850688 131073 6512 nil nil nil 5 nil nil nil 6512 306 #{Tools.PackageSelector} #resource_Choice_view nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 24 0 0 0 207 0 0 0 244 0 0 0] 193 6544 8 '' 6512 3 528 546 193 193 nil 27 754 #{Core.IdentityDictionary} 50 4 6512 8 'package' 6160 8 'setPackage' 5874 546 1 -1 546 1 1 338 50 1 386 #createWindow: 50 1 434 466 8 #[0 0 0 0 3 0 0 0 207 0 0 0 247 0 0 0] 193 6112 8 '' 6080 3 50 2 6160 6512 546 193 193 nil 27 18 #{UI.Splitter} 50 12 nil 5120 50 2 8 1140850688 1 7008 nil nil nil 517 nil nil nil 3142 1 #{UI.DraggableViewInteractor} 7008 nil 1 #left nil nil nil 546 1 1 546 9 9 nil 7104 nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[207 0 0 0 3 0 0 0 212 0 0 0 247 0 0 0] 193 7040 8 '' 7008 3 8 #() 546 193 193 nil 27 5280 546 193 193 nil 27 550 #{Core.IdentityDictionary} 0 nil 338 50 1 386 #createWindow: 50 1 434 466 8 #[12 0 0 0 10 0 0 0 176 1 0 0 140 1 0 0] 193 608 8 '' 576 3 50 2 656 5120 546 193 193 nil 27 7314 0 5874 546 25 21 546 25 17 nil nil nil nil 1 nil nil nil 546 621 581 nil nil 193 774 #{Core.Semaphore} nil nil 1 nil nil nil nil nil nil 338 50 2 386 #createWindow: 50 1 518 #{UI.CreateDialog} 5874 546 7679 21 546 8599 981 193 32 386 #setWindowText: 50 1 8 'Create Class…' 32 1 50 2 576 240 546 193 193 nil 29)! !

!Tools.CreateSubclassDialog class categoriesForMethods!
resource_Refactoring_view!public!resources-views! !
!

!Tools.Debugger methodsFor!

canMoveMethods
	#todo.	"Not currently supported in the debugger because it rewrites the caller, which complicates the unwind"
	^false!

hasRefactorableMethodSelected
	^self isPaused and: 
			[| method |
			method := self selectedMethod.
			method notNil and: [method isUnbound not and: [self parseTree notNil]]]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	aMonadicValuable value: self selectedMethod.
	self selectedMethod isUnbound ifTrue: [self restartMethod]!

performMethodRenameRefactoring: aMonadicValuable 
	| method home sender refactoring |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := aMonadicValuable value: method.
	refactoring isNil ifTrue: [^self].
	"Since the method of the selected frame has been renamed, the sending frame's method will
	have been rewritten, therefore we need to restart the sender frame."
	home := self findHomeFrame: self frame.
	home isNil ifTrue: [^self].
	sender := home sender.
	(sender notNil and: [sender isRestartable]) ifTrue: [self restartMethodFrame: sender]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !

!Tools.Debugger categoriesForMethods!
canMoveMethods!private!testing! !
hasRefactorableMethodSelected!public!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!private!refactoring! !
!

!Tools.MethodBrowser methodsFor!

canMoveMethods
	^self hasRefactorableMethodSelected!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected and: [self parseTree notNil]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethod!

performMethodRenameRefactoring: aMonadicValuable
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	| refactoring method |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := sourcePresenter executeRefactoring: aMonadicValuable with: method.
	refactoring isNil ifTrue: [^self].
	method := (method ifNil: [self parseContext methodClass] ifNotNil: [method methodClass])
				compiledMethodAt: refactoring newSelector
				ifAbsent: nil.
	(method notNil and: [self filter value: method]) ifTrue: [self selectMethod: method]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !

!Tools.MethodBrowser categoriesForMethods!
canMoveMethods!helpers!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!helpers!private!refactoring! !
!

!Tools.MethodWorkspace methodsFor!

addClassVariable: aStVariableNode to: aClass 
	self developmentSystem addClassVariable: aStVariableNode name to: aClass.
	self clearParseTree!

addInstanceVariable: aStVariableNode to: aClass
	self developmentSystem addInstanceVariable: aStVariableNode name to: aClass.
	self clearParseTree!

addParameterCommand: aStProgramNode
	(aStProgramNode isNil or: [aStProgramNode isMessage not]) ifTrue: [^nil].
	^(self targetOfMessage: aStProgramNode)
		ifNotNil: 
			[:target |
			self
				changeSignatureCommandFor: aStProgramNode
				in: target
				operation: [:method | self developmentSystem addParameterToMethod: method]
				title: 'Add Parameter']!

addParameterToMessage
	<commandQuery: #queryAddParameterToMessage:>
	(self addParameterCommand: self selectedNode) value: self!

addSharedVariable: aStVariableNode to: aNamespace
	self developmentSystem addSharedVariable: aStVariableNode name to: aNamespace.
	self clearParseTree!

autoCorrectMenu
	<menuPopulator: #populateAutoCorrectMenu:>
	<commandQuery: #hasCompilationErrors>
	!

canExtractCode
	^self canPerformCodeRefactoring and: [self hasSelection]!

canPerformCodeRefactoring
	^self canRefactor and: [self isModified not]!

canRefactor
	^self isEditable and: 
			[self isModified not and: 
					[self developmentSystem canRefactor 
						and: [parentPresenter notNil and: [parentPresenter hasRefactorableMethodSelected]]]]!

canRenameNode
	^self canRefactor and: [self isModified not and: [self selectedNode notNil]]!

changeSignatureCommandFor: aStMessageNode in: aClass operation: aMonadicValuable title: aString
	"Private - Determines the receiver of a message under the caret, and if possible works out
	its class. Answers an appropriate <Message> which when sent to the receiver will initiate a
	method signature changing refactoring (e.g. a selector rename) of the appropriate method, by
	evaluating the <MonadicValuable> argument passing it that method. If the class of the
	receiver cannot be determined quickly (e.g. it is an instance variable reference in a method
	browser), then answer nil. Note that when hosted by the Debugger we can normally do a
	complete job because all initialised variables have a type we can use to lookup the method."

	^Message selector: #changeSignature:in:operation:title:
		arguments: {aStMessageNode selector. aClass. aMonadicValuable. aString}!

codeRefactoringsMenu
	<commandQuery: #canPerformCodeRefactoring>
	!

convertTempToInstVar
	"Convert the selected temporary variable (or that under the cursor) to an instance variable,
	i.e. perform a 'Convert to Instance Variable' refactoring."

	<commandQuery: #queryConvertTempToInstVar:>
	| node |
	node := self selectedNode.
	self performMethodRefactoring: 
			[:method |
			self developmentSystem
				convertTemporaryToInstanceVariable: node name
				in: method methodClass
				selector: method selector]!

createClassForVariable: aStVariableNode
	(self developmentSystem createNewClass: aStVariableNode name
		inPackage: self parseContext owningPackage) ifNotNil: [self clearParseTree]!

declareAllUndeclaredVariablesAsTemps
	| ast undeclared |
	ast := self parseTree.
	undeclared := LookupTable new.
	self compilationErrors do: 
			[:each |
			each errorCode = ParseErrorCodes.CErrUndeclared
				ifTrue: 
					[| identifier |
					identifier := self plainTextRange: each range.
					undeclared at: identifier ifAbsentPut: each]].
	undeclared do: 
			[:each |
			| var |
			var := ast whichNodeIsContainedBy: each range.
			(var notNil and: [var isVariable]) ifTrue: [self declareTemporary: var]]!

executeRefactoring: aMonadicValuable
	^aMonadicValuable on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

executeRefactoring: aMonadicValuable with: anObject
	^[aMonadicValuable value: anObject]
		on: OperationAborted
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			nil]
		on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

extractionRange
	| interval |
	#todo.	"Can do a bit better here. The selected node interval can be used to simplify
		selection of the selection range (it doesn't have to be exact), but one then has to
		handle the case of multiple statements being selected. Where that is so the
		'selectedNode' will be the whole method."
	interval := self view selectionRange.
	interval isEmpty ifTrue: [interval := self selectedNode sourceInterval].
	^interval!

extractMethod
	"Create a new method from the selected text of the current method, i.e. perform an 'Extract
	Method' refactoring."

	<commandQuery: #canExtractCode>
	self performMethodRefactoring: 
			[:method |
			| interval |
			interval := self extractionRange.
			(self developmentSystem
				extractMethod: interval
				from: method selector
				in: method methodClass) isNil
				ifFalse: [self caretPosition: interval start]]!

extractToComponent
	"Extract the selected source text to form a new method in the class of some variable in the
	selected method's scope, i.e. perform an 'Extract to Component' refactoring."

	<commandQuery: #canExtractCode>
	self performMethodRefactoring: 
			[:method |
			self developmentSystem
				extractToComponent: self extractionRange
				from: method selector
				in: method methodClass]!

extractToTemporary
	"Extract the selected text of the current method into an assignment to a temporary
	(i.e. perform an 'Extract to Temporary' refactoring)."

	<commandQuery: #canExtractCode>
	self performCodeRefactoring: 
			[:method :node |
			| line interval result |
			interval := node sourceInterval.
			line := self lineFromPosition: interval start.
			result := self developmentSystem
						extractToTemporary: interval
						from: method selector
						in: method methodClass.
			result notNil
				ifTrue: 
					["Try and keep the caret on the same line, accounting for the new lines that will be inserted"
					self repositionAtSourceLine: line
								+ (node statementNode parent allTemporaryVariableNodes isEmpty ifTrue: [2] ifFalse: [1])].
			result]!

findAssignmentsToTemp: aStVariableNode 
	"Private - Find and answer the collection of nodes which represent assignments to the
	temporary variable represented by the argument in the same or an enclosing scope."

	| searcher |
	searcher := ParseTreeSearcher new.
	searcher matches: aStVariableNode name , ' := ``@expr'
		do: 
			[:aNode :answer | 
			answer
				add: aNode;
				yourself].
	^searcher executeTree: self parseTree initialAnswer: OrderedCollection new!

fontOfStyle: style 
	| font |
	font := style fontName ifNil: [view actualFont copy] ifNotNil: [:face | Font name: face].
	style restyleFont: font.
	^font!

implementMessage: aStMessageNode
	| dialog |
	dialog := self developmentSystem classChooserClass create.
	dialog
		caption: 'Choose Target Class…';
		allowNil: false.
	self parseContext owningPackage ifNotNil: [:package | dialog packages: {package}].
	dialog showModal ifNotNil: [:class | self implementMessage: aStMessageNode inClass: class]!

implementMessage: aStMessageNode inClass: aClass
	| method |
	method := self developmentSystem
				generateStubFor: aStMessageNode selector
				inClass: aClass
				withArgs: (aStMessageNode arguments collect: [:each | self nameForArgumentNode: each]).
	self clearParseTree.
	method
		ifNotNil: 
			[(self developmentSystem methodCategorizationPolicy bestSuggestionFor: method) addMethod: method]!

implementMessageMenu
	<commandQuery: #hasSelectedMessage>
	<menuPopulator: #populateImplementMenu:>
	!

inlineMessage
	"Invoke the 'Inline Message' refactoring to inline the selected
	message send."

	<commandQuery: #queryInlineMessage:>
	self performCodeRefactoring: 
			[:method :node |
			| line result |
			line := self lineFromPosition: node sourceInterval start.
			result := self developmentSystem
						inlineMessage: node
						inMethod: method selector
						of: method methodClass.
			self repositionAtSourceLine: line.
			result]!

inlineParameter
	"Inline the parameter which is under the cursor (or selected), i.e. perform an 'Inline
	Parameter' refactoring."

	<commandQuery: #queryParameterRefactoring:>
	self performMethodRenameRefactoring: 
			[:method |
			self developmentSystem
				inlineParameter: self selectedNode name
				from: method selector
				in: method methodClass]!

inlineTemporary
	"Invoke the 'Inline Temporary' refactoring to inline the temporary which is currently
	selected in the workspace. Note that we support the selection of the assignment expression
	to be inlined or at a minimum it is sufficient to just have the caret over either the
	declaration of the temporary to inline, or a reference to it."

	<commandQuery: #queryInlineTemporary:>
	self performCodeRefactoring: [:method :node | self inlineTemporary: method in: node]!

inlineTemporary: aCompiledMethod in: aStProgramNode
	| assignment line result |
	assignment := aStProgramNode isAssignment
				ifTrue: [aStProgramNode]
				ifFalse: 
					[| assignments |
					assignments := self findAssignmentsToTemp: aStProgramNode.
					assignments isEmpty ifFalse: [assignments first]].
	assignment isNil
		ifTrue: 
			[Sound warningBeep.
			Notification
				signal: ('There are no assignments to <1p> to inline' expandMacrosWith: aStProgramNode name).
			^nil].
	line := self lineFromPosition: aStProgramNode sourceInterval start.
	result := self developmentSystem
				inlineTemporary: assignment sourceInterval
				from: aCompiledMethod selector
				in: aCompiledMethod methodClass.
	self repositionAtSourceLine: line.
	^result!

moveTempToInnerScope
	"Move the temporary with focus (i.e. that selected or under the cursor) to the innermost
	scope in which it is first referenced, i.e. perform a 'Move to Inner Scope' refactoring."

	<commandQuery: #queryMoveTempToInnerScope:>
	self performCodeRefactoring: 
			[:method :node |
			| interval anchor |
			interval := node sourceInterval.
			anchor := interval start.
			(self developmentSystem
				moveTempToInnerScope: interval
				in: method methodClass
				selector: method selector) isNil
				ifFalse: [self caretPosition: anchor]]!

performCodeRefactoring: refactoringOperation 
	self 
		performMethodRefactoring: [:method | refactoringOperation value: method value: self selectedNode]!

performMethodRefactoring: aMonadicValuable 
	^parentPresenter performMethodRefactoring: aMonadicValuable!

performMethodRenameRefactoring: aBlockClosure 
	^parentPresenter performMethodRenameRefactoring: aBlockClosure!

populateAutoCorrectMenu: aMenu
	| node range |
	aMenu clear.
	#todo.	"Find the errors & warnings that either enclose the caret position, or are near it (separated only by whitespace or special character tokens from)"
	range := self selectedErrorRange.
	node := self nodeForRange: range.
	node isNil ifTrue: [^self].
	node isMessage ifTrue: [self populateAutoCorrectMenu: aMenu forMessage: node].
	node isVariable ifTrue: [self populateAutoCorrectMenu: aMenu forVariable: node].
	self hasUndeclaredVariables ifFalse: [^self].
	aMenu isEmpty ifFalse: [aMenu addSeparator].
	aMenu addCommand: (MessageSend receiver: self selector: #declareAllUndeclaredVariablesAsTemps)
		description: 'Declare &All Undeclared Temps'!

populateAutoCorrectMenu: aMenu forMessage: aStMessageNode
	| implementMenu |
	implementMenu := aMenu addSubmenu: ('&Implement <1p> In' expandMacrosWith: aStMessageNode selector).
	self populateImplementMenu: implementMenu forMessage: aStMessageNode!

populateAutoCorrectMenu: aMenu forUndefinedVar: aStVariableNode
	| parseContext |
	parseContext := self parseContext.
	^aStVariableNode name first isUppercase
		ifTrue: 
			[| subMenu |
			subMenu := aMenu addSubmenu: ('Add C&lass Variable <1p> to' expandMacrosWith: aStVariableNode name).
			parseContext methodClass instanceClass withAllSuperclassesDo: 
					[:eachClass |
					subMenu addCommand: (MessageSend
								receiver: self
								selector: #addClassVariable:to:
								arguments: {aStVariableNode. eachClass})
						description: eachClass name].
			aMenu addCommand: (MessageSend
						receiver: self
						selector: #createClassForVariable:
						arguments: {aStVariableNode})
				description: ('Create &Class <1p>' expandMacrosWith: aStVariableNode name).
			aMenu addCommand: (MessageSend
						receiver: self
						selector: #addSharedVariable:to:
						arguments: {aStVariableNode. parseContext environment})
				description: ('Declare &Shared Variable <1p>.<2s>' expandMacrosWith: parseContext environment with: aStVariableNode name)]
		ifFalse: 
			[| subMenu |
			aMenu addCommand: (MessageSend
						receiver: self
						selector: #declareTemporary:
						arguments: {aStVariableNode})
				description: ('Declare &Temp <1p>' expandMacrosWith: aStVariableNode name).
			subMenu := Menu
						description: ('Add &Instance Variable <1p> to' expandMacrosWith: aStVariableNode name).
			parseContext methodClass withAllSuperclassesDo: 
					[:eachClass |
					(ClassBuilder isFixedLayout: eachClass)
						ifFalse: 
							[subMenu addCommand: (MessageSend
										receiver: self
										selector: #addInstanceVariable:to:
										arguments: {aStVariableNode. eachClass})
								description: eachClass name]].
			subMenu isEmpty ifFalse: [aMenu addItem: subMenu]]!

populateAutoCorrectMenu: aMenu forVariable: aStVariableNode
	| range |
	range := aStVariableNode sourceInterval.
	(self compilationErrors select: [:each | each range = range]) do: 
			[:each |
			| code |
			code := each errorCode.
			code = ParseErrorCodes.CErrUndeclared
				ifTrue: [self populateAutoCorrectMenu: aMenu forUndefinedVar: aStVariableNode].
			code = ParseErrorCodes.CWarnUnreferencedTemp
				ifTrue: 
					[aMenu addCommand: (MessageSend
								receiver: self
								selector: #removeTempDecl:
								arguments: { aStVariableNode })
						description: 'Remove Declaration ']]!

populateImplementMenu: aMenu 
	"Private - Build the menu which lists the classes into which a stub can be generated for
	the message under the cursor."

	self populateImplementMenu: aMenu forMessage: self selectedMessageNode!

populateImplementMenu: aMenu forMessage: aStMessageNode
	aMenu clear.
	(self targetOfMessage: aStMessageNode)
		ifNotNil: 
			[:target |
			| class |
			class := target.
			[class notNil and: [(class includesSelector: aStMessageNode selector) not]] whileTrue: 
					[aMenu addCommand: (MessageSend
								receiver: self
								selector: #implementMessage:inClass:
								arguments: { aStMessageNode. class })
						description: class name.
					class := class superclass]].
	aMenu notEmpty ifTrue: [aMenu addSeparator].
	aMenu addCommand: (MessageSend
				receiver: self
				selector: #implementMessage:
				argument: aStMessageNode)
		description: '&Class…'.
	aMenu setDefault: 1!

qualifyIdentifier
	"Invoke the 'Qualify Static Variable'  refactoring to fully qualify the selected static variable, 
	or that under the cursor if no selection."

	<commandQuery: #queryChangeIdentifierQualification:>
	self performMethodRefactoring: 
			[:method |
			self developmentSystem
				qualifyStaticVariable: self selectedNode sourceInterval
				inMethod: method selector
				of: method methodClass]!

queryAddParameterToMessage: aCommandQuery
	(self addParameterCommand: self selectedNode)
		ifNotNil: [:selector | self queryContextCommand: aCommandQuery as: selector]!

queryChangeIdentifierQualification: aCommandQuery
	| varType description node |
	node := self selectedNode.
	varType := self variableClassification: node.
	(varType == #class or: [varType == #classGlobal]) ifFalse: [^self].
	aCommandQuery beEnabled.
	description := self descriptionForVariableNode: node.
	aCommandQuery
		beEnabled;
		expandMenuTextWith: (description copyFrom: 1 to: 1) asLowercase , description allButFirst!

queryChangeSignature: aCommandQuery
	| cmd |
	cmd := aCommandQuery command.
	(cmd arguments second lookupMethod: cmd arguments first)
		ifNotNil: 
			[:method |
			aCommandQuery
				beEnabled;
				expandMenuTextWith: method]!

queryConvertTempToInstVar: aCommandQuery
	aCommandQuery
		isEnabled: (self canPerformCodeRefactoring and: 
					[| node |
					node := self selectedNode.
					node notNil and: 
							[(self isLocalVariable: node) and: 
									[#todo.	"Check here that the proposed instance variable is not already defined?"
									true]]])!

queryInlineMessage: aCommandQuery
	| node |
	self canPerformCodeRefactoring ifFalse: [^self].
	node := self selectedNode.
	(node notNil and: [node isMessage])
		ifTrue: 
			[aCommandQuery
				beEnabled;
				expandMenuTextWith: node selector]!

queryInlineTemporary: aCommandQuery
	aCommandQuery
		isEnabled: (self canPerformCodeRefactoring and: 
					[| node |
					node := self selectedNode.
					node notNil and: [node isAssignment or: [self isLocalVariable: node]]])!

queryMoveTempToInnerScope: aCommandQuery
	aCommandQuery
		isEnabled: (self canPerformCodeRefactoring and: 
					[| node |
					node := self selectedNode.
					node notNil and: [self isLocalVariable: node]])!

queryParameterRefactoring: aCommandQuery
	| node |
	self canPerformCodeRefactoring ifFalse: [^self].
	node := self selectedNode.
	(node notNil and: [self parseTree methodNode arguments includes: node])
		ifTrue: 
			[aCommandQuery
				beEnabled;
				expandMenuTextWith: node name]!

queryRenameClass: aCommandQuery
	self queryRenameVariable: aCommandQuery classification: #classGlobal!

queryRenameClassVariable: aCommandQuery
	self queryRenameVariable: aCommandQuery classification: #class!

queryRenameInstanceVariable: aCommandQuery
	self queryRenameVariable: aCommandQuery classification: #instance!

queryRenameItCommand: aCommandQuery
	self renameItCommand ifNotNil: [:message | self queryContextCommand: aCommandQuery as: message]!

queryRenameMessage: aCommandQuery
	(self renameMessageCommand: self selectedNode)
		ifNotNil: [:selector | self queryContextCommand: aCommandQuery as: selector]!

queryRenameTemporary: aCommandQuery
	^self queryRenameVariable: aCommandQuery classification: #temporary!

queryRenameVariable: aCommandQuery
	(self renameVariableCommand: self selectedNode)
		ifNotNil: [:selector | self queryContextCommand: aCommandQuery as: selector]!

queryRenameVariable: aCommandQuery classification: aSymbol
	| node description |
	self canRefactor ifFalse: [^self].
	node := self selectedNode.
	(self variableClassification: node) == aSymbol ifFalse: [^false].
	description := self descriptionForVariableNode: node.
	aCommandQuery
		beEnabled;
		expandMenuTextWith: (description copyFrom: 1 to: 1) asLowercase , description allButFirst!

removeParameter
	<commandQuery: #queryParameterRefactoring:>
	self removeParameter: self selectedNode!

removeParameter: aStVariableNode
	"Private - Command to invoke the 'Remove Method Parameter' refactoring on the specified
	argument name."

	self performMethodRenameRefactoring: 
			[:method |
			self developmentSystem
				removeParameter: aStVariableNode name
				from: method selector
				in: method methodClass
				within: self searchEnvironment]!

removeTempDecl: aStVariableNode 
	| range scintilla |
	range := aStVariableNode sourceInterval.
	scintilla := self view.
	((scintilla characterAt: range start - 1) isWhitespace 
		and: [(scintilla characterAt: range stop + 1) isWhitespace]) ifTrue: [range stop: range stop + 1].
	scintilla clearRange: range!

renameClass
	<commandQuery: #queryRenameClass:>
	self renameClass: self selectedNode!

renameClass: aStVariableNode
	| class devsys method |
	devsys := self developmentSystem.
	method := self selectedMethod.
	class := (method fullBindingFor: aStVariableNode name) value.
	self
		renameVariable: aStVariableNode
		operation: [:newName | devsys renameClass: class to: newName]
		validationBlock: [:name | devsys validateRenameClass: class to: name]!

renameClassVariable
	<commandQuery: #queryRenameClassVariable:>
	self renameClassVariable: self selectedNode!

renameClassVariable: aStVariableNode
	| definingBehavior oldName |
	oldName := aStVariableNode name.
	definingBehavior := aStVariableNode binding environment.
	self
		renameVariable: aStVariableNode
		operation: 
			[:newName |
			self developmentSystem
				renameClassVariable: oldName
				to: newName
				in: definingBehavior]
		validationBlock: 
			[:name |
			self developmentSystem
				validateRenameClassVar: oldName
				to: name
				in: definingBehavior]!

renameInstanceVariable
	<commandQuery: #queryRenameInstanceVariable:>
	self renameInstanceVariable: self selectedNode!

renameInstanceVariable: aStVariableNode
	| definingBehavior methodClass oldName |
	methodClass := self selectedMethod methodClass.
	oldName := aStVariableNode name.
	definingBehavior := methodClass whichClassDefinesInstVar: oldName.
	self
		renameVariable: aStVariableNode
		operation: 
			[:newName |
			self developmentSystem
				renameInstanceVariable: oldName
				to: newName
				in: definingBehavior]
		validationBlock: 
			[:candidateName |
			self developmentSystem
				validateRenameInstVar: oldName
				to: candidateName
				in: definingBehavior]!

renameIt
	<commandQuery: #queryRenameItCommand:>
	<acceleratorKey: 'F2'>
	| message |
	message := self renameItCommand.
	"We have to defer the command, because it will typically need to pop up an in-place editor"
	[message value: self] postToMessageQueue!

renameItCommand
	^self selectedNode
		ifNotNil: [:node | (self renameMessageCommand: node) ifNil: [self renameVariableCommand: node]]!

renameMessage
	<commandQuery: #queryRenameMessage:>
	(self renameMessageCommand: self selectedNode) value: self!

renameMessageCommand: aStProgramNode
	"Private - Answer an appropriate <Message> that when sent to the receiver will initiate a rename of the method that is the target of the current message send, or nil if the current node is not a message suitable for renaming."

	(aStProgramNode isNil or: [aStProgramNode isMessage not]) ifTrue: [^nil].
	^(self targetOfMessage: aStProgramNode)
		ifNotNil: 
			[:target |
			self
				changeSignatureCommandFor: aStProgramNode
				in: target
				operation: [:method | self developmentSystem renameMethod: method]
				title: 'Rename']!

renameTemporary
	<commandQuery: #queryRenameTemporary:>
	self renameTemporary: self selectedNode!

renameTemporary: aStVariableNode
	| method |
	method := self selectedMethod.
	self
		renameVariable: aStVariableNode
		operation: 
			[:newName |
			self developmentSystem
				renameTemporary: aStVariableNode
				to: newName
				in: method methodClass
				selector: method selector]
		validationBlock: 
			[:candidate |
			self developmentSystem
				validateRenameTemp: aStVariableNode
				to: candidate
				in: method methodClass]!

renameVariable
	"Invoke the 'Rename Variable'  refactoring to rename the selected variable, 
	or that under the cursor if no selection. The name is looked up in scope rule order."

	<commandQuery: #queryRenameVariable:>
	| command |
	command := self renameVariableCommand: self selectedNode.
	[command value: self] postToMessageQueue!

renameVariable: aStVariableNode operation: operationBlock validationBlock: validationBlock
	| name range style editor font zoom newName |
	range := aStVariableNode sourceInterval.
	name := self plainTextRange: range.
	self assert: [aStVariableNode name = name].
	editor := InplaceTextEditor createOn: name asValue.
	editor validater: 
			[:candidateName |
			"If the name is unchanged, treat as valid and ignore later"
			candidateName = name
				ifTrue: [ValidationResult new]
				ifFalse: 
					[| result |
					result := validationBlock value: candidateName.
					result hint ifNotNil: [:ex | self errorModel value: ex].
					result]].
	editor textRectangle: (view boundingRectangleOfTextRange: range).
	"Set the same font as the existing text so there is no visible 'jump' - we need to account for any zooming too"
	style := view styleAt: range start.
	font := self fontOfStyle: style.
	zoom := view zoomLevel.
	zoom = 0
		ifFalse: 
			[| points |
			points := font pointSize.
			font := font copy.
			font pointSize: points + zoom].
	editor font: font.
	newName := view hideCaretWhile: [editor showModal].
	self errorModel value: nil.
	(newName isNil or: [newName = name])
		ifFalse: [self performMethodRefactoring: [:method | operationBlock value: newName]]!

renameVariableCommand: aStVariableNode
	^(##(IdentityDictionary withAll: {
				#temporary -> #renameTemporary.
				#instance -> #renameInstanceVariable.
				#class -> #renameClassVariable.
				#classGlobal -> #renameClass
			})
		lookup: (self variableClassification: aStVariableNode))
			ifNotNil: [:selector | Message selector: selector]!

unqualifyIdentifier
	"Invoke the 'Unqualify Static Variable' refactoring to remove any redundant namespace qualifiers from the selected static variable, 
	or that under the cursor if no selection."

	<commandQuery: #queryChangeIdentifierQualification:>
	self performMethodRefactoring: 
			[:method |
			self developmentSystem
				unqualifyStaticVariable: self selectedNode sourceInterval
				inMethod: method selector
				of: method methodClass]! !

!Tools.MethodWorkspace categoriesForMethods!
addClassVariable:to:!private!refactoring! !
addInstanceVariable:to:!private!refactoring! !
addParameterCommand:!commands-mappings!private!refactoring! !
addParameterToMessage!commands-actions!public!refactoring! !
addSharedVariable:to:!private!refactoring! !
autoCorrectMenu!commands-menus!public! !
canExtractCode!commands-queries!private!refactoring! !
canPerformCodeRefactoring!public!refactoring! !
canRefactor!public!refactoring!testing! !
canRenameNode!public!refactoring! !
changeSignatureCommandFor:in:operation:title:!private!refactoring! !
codeRefactoringsMenu!commands-menus!public!refactoring! !
convertTempToInstVar!public!refactoring! !
createClassForVariable:!private! !
declareAllUndeclaredVariablesAsTemps!private! !
executeRefactoring:!helpers!private!refactoring! !
executeRefactoring:with:!helpers!private!refactoring! !
extractionRange!public!refactoring! !
extractMethod!commands-actions!public!refactoring! !
extractToComponent!commands-actions!public!refactoring! !
extractToTemporary!commands-actions!public!refactoring! !
findAssignmentsToTemp:!helpers!private!refactoring! !
fontOfStyle:!operations!private! !
implementMessage:!public!refactoring! !
implementMessage:inClass:!public!refactoring! !
implementMessageMenu!commands-menus!public!refactoring! !
inlineMessage!public!refactoring! !
inlineParameter!public!refactoring! !
inlineTemporary!public!refactoring! !
inlineTemporary:in:!public!refactoring! !
moveTempToInnerScope!public!refactoring! !
performCodeRefactoring:!helpers!private!refactoring! !
performMethodRefactoring:!helpers!private!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
populateAutoCorrectMenu:!commands-menus!private! !
populateAutoCorrectMenu:forMessage:!commands-menus!private! !
populateAutoCorrectMenu:forUndefinedVar:!commands-menus!private! !
populateAutoCorrectMenu:forVariable:!commands-menus!private! !
populateImplementMenu:!commands-menus!private! !
populateImplementMenu:forMessage:!commands-menus!private! !
qualifyIdentifier!commands-actions!public!refactoring! !
queryAddParameterToMessage:!commands-queries!public!refactoring! !
queryChangeIdentifierQualification:!commands-queries!public!refactoring! !
queryChangeSignature:!public!refactoring! !
queryConvertTempToInstVar:!public!refactoring! !
queryInlineMessage:!public!refactoring! !
queryInlineTemporary:!public!refactoring! !
queryMoveTempToInnerScope:!public!refactoring! !
queryParameterRefactoring:!public!refactoring! !
queryRenameClass:!commands-queries!private!refactoring! !
queryRenameClassVariable:!commands-queries!private!refactoring! !
queryRenameInstanceVariable:!commands-queries!private!refactoring! !
queryRenameItCommand:!commands-queries!private!refactoring! !
queryRenameMessage:!commands-queries!public!refactoring! !
queryRenameTemporary:!commands-queries!private!refactoring! !
queryRenameVariable:!commands-queries!public!refactoring! !
queryRenameVariable:classification:!commands-queries!private!refactoring! !
removeParameter!commands-actions!public!refactoring! !
removeParameter:!public!refactoring! !
removeTempDecl:!private! !
renameClass!commands-actions!public!refactoring! !
renameClass:!private! !
renameClassVariable!commands-actions!public!refactoring! !
renameClassVariable:!private!refactoring! !
renameInstanceVariable!commands-actions!public!refactoring! !
renameInstanceVariable:!private!refactoring! !
renameIt!commands-actions!public!refactoring! !
renameItCommand!commands-mappings!public!refactoring! !
renameMessage!commands-actions!public!refactoring! !
renameMessageCommand:!commands-mappings!private!refactoring! !
renameTemporary!commands-actions!public!refactoring! !
renameTemporary:!private!refactoring! !
renameVariable!commands-actions!public!refactoring! !
renameVariable:operation:validationBlock:!private!refactoring! !
renameVariableCommand:!commands-mappings!private!refactoring! !
unqualifyIdentifier!commands-actions!public!refactoring! !
!

!Tools.PackageBrowserShell methodsFor!

addImport
	<commandQuery: #hasClassesSelected>
	self developmentSystem addImportToClasses: self selectedClasses!

addParameter
	"Private - Command to invoke the Add Parameter to Method refactoring, prompting the user for 
	the selector of the method to which the parameter is added, and constrained to operate
	only within the selected packages."

	<commandQuery: #hasPackages>
	(self chooseMethodForRefactoring: [:each | each selector isInfix not]
		caption: 'Choose Method for Parameter Addition in <d>…')
			ifNotNil: [:method | self addParameterTo: method]!

addParameterTo: aCompiledMethod
	self model addParameterToMethod: aCompiledMethod inPackages: self packages!

addParameterToMethod
	"Private - 'Loose Methods' card context menu command to invoke the 
	'Add Parameter to Method refactoring' against a selected loose method, 
	constrained within the selected packages."

	<commandQuery: #hasMethodSelected>
	self addParameterTo: self selectedMethod!

changeClassNamespace
	<commandQuery: #hasClassesSelected>
	self developmentSystem changeNamespaceOfClasses: self selectedClasses!

chooseMethodsForRefactoring: aString
	| selector methods definitions searchEnv |
	searchEnv := self searchEnvironment.
	methods := self selectedMethods.
	methods isEmpty ifFalse: [^searchEnv forMethods: methods].
	selector := self model chooseSelectorInEnvironment: searchEnv caption: aString.
	selector isNil ifTrue: [^searchEnv forMethods: #()].
	definitions := searchEnv definitionsOf: selector.
	definitions isEmpty
		ifTrue: 
			[MessageBox
				errorMsg: ('There are no definitions of <1p> in the selected package(s).' expandMacrosWith: selector)].
	^definitions!

classRefactoringsMenu
	<commandQuery: #hasPackages>
	Sound warningBeep!

hasMethodWithArguments
	| method |
	method := self selectedMethod.
	^method notNil and: [method argumentCount > 0]!

hasRefactorableMethodSelected
	^self hasMethodSelected!

methodRefactoringsMenu
	<commandQuery: #hasPackages>
	Sound warningBeep!

newMethodNamePrompter: aCompiledMethod caption: aString allowExisting: aBoolean
	| methodName |
	methodName := ScopedMethodName fromMethod: aCompiledMethod.
	methodName packages: self packages.
	^self developmentSystem
		newMethodNamePrompter: methodName
		caption: aString
		allowExisting: aBoolean!

onClass: aClass renameTo: aString accept: booleanValue
	"Private - The user has initiated a rename of the class, aClass, by editing the label in the class
	tree. Ask the user to confirm the action, and if so queue a deferred action to perform the
	actual rename."

	"Implementation Notes: We don't set the booleanValue holder to true, because the rename may not work."

	| prompter |
	(aString isEmpty or: [aClass fullName = aString])
		ifTrue: 
			[booleanValue value: false.
			^self].
	prompter := self developmentSystem confirmRenameClass: aClass to: aString.
	prompter confirm ifFalse: [^self].
	"Queue deferred action as we can't delete the old item now while still in use (causes GPF in TreeView)"
	
	[self
		onRenameClass: aClass
		to: aString
		showChanges: prompter isChecked]
			postToMessageQueue!

onRenameClass: aClass to: aString showChanges: aBoolean
	"Private - The class, aClass, has been renamed by the user to, text, by editing the label
	in the classes presenter and subsequently confirmed. Ask the receiver's
	model to actually rename the class, converting any exception raised to a
	friendlier message box."

	
	[Cursor wait showWhile: 
			[self developmentSystem
				renameClass: aClass
				to: aString
				showChanges: aBoolean]]
			on: Refactoring abortSignal
			do: 
				[:ex |
				"Cancelled by user"
				self statusModel value: ex]
			on: Error
			do: [:e | e okCancel]!

parseTree
	^self selectedMethod ifNotNil: [:method | Parser parseExistingMethodNoError: method]!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	^aMonadicValuable value: self selectedMethod!

performMethodsRefactoring: aMonadicValuable name: aString
	| methods |
	methods := self chooseMethodsForRefactoring: '<1s> from Package(s)…' << aString.
	methods isEmpty ifTrue: [^nil].
	^[aMonadicValuable value: methods allMethods] on: Notification
		do: 
			[:ex |
			statusModel value: ex.
			ex resume]!

promptForMethodName: aCompiledMethod caption: aString allowExisting: aBoolean
	^(self
		newMethodNamePrompter: aCompiledMethod
		caption: aString
		allowExisting: aBoolean) showModal!

removeMethod
	"Private - Prompt the user for a selector and invoke the 'Safe Remove Method' refactoring to 
	remove the specified methods from the system if defined but not referenced from within 
	any of the selected packages ((i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	"Implemementation Note: This command implementation is used only if there are no 
	methods selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	<commandQuery: #hasMethodsSelected>
	| methods |
	methods := self chooseMethodsForRefactoring: 'Safe Remove Methods from Package(s)…'.
	methods isEmpty
		ifFalse: 
			[self model
				basicRemoveMethodsIn: methods
				within: self selectionEnvironment
				showChanges: false]!

removeMethods
	"Private - 'Loose Methods' card context menu command to invoke the 'Safe Remove Method' 
	refactoring. Removes the selected methods from the system if not referenced from within any 
	of the selected packages (i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	<commandQuery: #hasMethodsSelected>
	| mb |
	mb := MessageBox new
				headline: 'Remove unreferenced loose methods?';
				defaultButton: 2;
				customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
				isCancellable: true;
				checkboxText: self developmentSystem showChangesText;
				yourself.
	(mb
		confirm: 'The selected methods will be removed if unreferenced from the selected packages. This may not preserve behaviour if the methods are referenced from other packages.')
			ifTrue: 
				[self model
					basicRemoveMethods: self selectedMethods
					within: self selectionEnvironment
					showChanges: mb isChecked]!

removeParameter
	"Private - Command to invoke the Remove Parameter to Method refactoring, but constrained to operate
	only within the selected packages."

	<commandQuery: #hasPackages>
	| method ast arg |
	method := self chooseMethodForRefactoring: 
					[:each |
					each argumentCount > 1 or: [each argumentCount = 1 and: [each selector isInfix not]]]
				caption: 'Choose Method for Parameter Removal in <d>…'.
	method isNil ifTrue: [^self].
	ast := method parseTreeNoError.
	ast isNil ifTrue: [^self].
	arg := ChoicePrompter choices: ast argumentNames
				caption: 'Remove Parameter from <1p> in <2d>…' << { method selector. self selectionEnvironment }.
	arg notNil ifTrue: [methodRefactoringTool removeParameter: arg from: method]!

removeParameterMenu
	<commandQuery: #hasMethodWithArguments>
	Sound warningBeep!

renameClass
	"Private - Initiate in-place label edit for the selected class."

	<commandQuery: #hasClassSelected>
	classesPresenter view editSelectionLabel!

renameLooseMethod
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method' refactoring against the selected loose method, but configured to rename 
	only within selected packages."

	methodRefactoringTool renameMethod!

renameLooseMethodReferences
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method References' refactoring against the selected loose method, but configured to rename 
	references only within selected packages."

	self renameMethodReferences: self selectedMethod!

renameMethod
	"Private - Initiate a 'Rename' method refactoring against the selected method,
	but configured to rename only within the selected packages."

	"Implemementation Note: This command implementation is used if there is not exactly one
	method selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	<commandQuery: #hasPackages>
	(self chooseMethodForRefactoring: nil caption: 'Choose Method to Rename in <d>…')
		ifNotNil: [:method | methodRefactoringTool renameMethod: method]!

renameMethodReferences: aCompiledMethod
	| methodName prompter |
	prompter := self
				newMethodNamePrompter: aCompiledMethod
				caption: 'Rename References to <1p> in Package(s)…' << aCompiledMethod selector
				allowExisting: true.
	methodName := prompter showModal.
	methodName notNil
		ifTrue: 
			[self model
				renameMethodReferences: aCompiledMethod
				to: methodName
				showChanges: prompter showChanges]! !

!Tools.PackageBrowserShell categoriesForMethods!
addImport!commands-actions!public! !
addParameter!commands-actions!private! !
addParameterTo:!private!refactoring! !
addParameterToMethod!commands-actions!public! !
changeClassNamespace!commands-actions!public! !
chooseMethodsForRefactoring:!private!refactoring! !
classRefactoringsMenu!commands-menus!public! !
hasMethodWithArguments!private!testing! !
hasRefactorableMethodSelected!private!refactoring!testing! !
methodRefactoringsMenu!commands-menus!public! !
newMethodNamePrompter:caption:allowExisting:!helpers!private!refactoring! !
onClass:renameTo:accept:!event handling!private! !
onRenameClass:to:showChanges:!event handling!private! !
parseTree!helpers!private! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!private! !
promptForMethodName:caption:allowExisting:!helpers!private!refactoring! !
removeMethod!commands-actions!public! !
removeMethods!commands-actions!public! !
removeParameter!commands-actions!private! !
removeParameterMenu!commands-actions!public! !
renameClass!public! !
renameLooseMethod!commands-actions!private! !
renameLooseMethodReferences!commands-actions!private! !
renameMethod!commands-actions!public! !
renameMethodReferences:!operations!private!refactoring! !
!

!Tools.PackageSelector methodsFor!

moveAllTempsToInnerScope
	<commandQuery: #hasPackages>
	(MessageBox new
		headline: 'Move All Temps to Inner Scope?';
		confirm: 'This refactoring will move all temporaries in all methods in the selected package(s) into the tightest scope that contains both the variable assignment and references. Any unreferenced temporaries will be removed.

Are you sure that you would like to proceed?')
			ifTrue: [self developmentSystem moveAllTempsToInnerScope: self selectionEnvironment]!

removeDuplicateMethods
	<commandQuery: #canRefactor>
	| count pkgs |
	pkgs := self packages.
	count := pkgs inject: 0 into: [:sum :eachPackage | sum + eachPackage classNames size].
	(ProgressDialog operation: 
			[:progress |
			| i devsys |
			i := 0.
			devsys := self developmentSystem.
			pkgs do: 
					[:eachPackage |
					progress text: eachPackage name.
					eachPackage classes do: 
							[:eachClass |
							i := i + 1.
							progress value: i * 100 // count.
							devsys removeMethodsDuplicatedInSuperclassOf: eachClass]]])
		caption: 'Remove Methods Duplicating Superclass'' from Package(s)…';
		showModal! !

!Tools.PackageSelector categoriesForMethods!
moveAllTempsToInnerScope!commands-actions!private!refactoring! !
removeDuplicateMethods!development!private! !
!

!Tools.SmalltalkToolShell methodsFor!

chooseMethodForRefactoring: aMonadicValuable caption: aString
	| selection |
	selection := self selectionEnvironment.
	aMonadicValuable
		ifNotNil: 
			[selection := (selection selectMethods: aMonadicValuable)
						label: selection label;
						yourself].
	^self developmentSystem chooseMethodFromEnvironment: selection caption: aString! !

!Tools.SmalltalkToolShell categoriesForMethods!
chooseMethodForRefactoring:caption:!private!refactoring! !
!

!UI.ChoicePrompter methodsFor!

showChanges
	^(self presenterNamed: 'showChanges') value! !

!UI.ChoicePrompter categoriesForMethods!
showChanges!accessing!public! !
!

!UI.ChoicePrompter class methodsFor!

refactoringChoices: aSequenceableCollection caption: aStringCaptionOrNil
	"Shows a dialog to allow the user to choose from aSequenceableCollection. The dialog is given a caption according to aStringCaptionOrNil. If nil then
	the default caption is used. Answer the dialog, or nil if cancelled.
	For refactoring purposes the dialog also includes a checkbox to allow the user to choose to see the eventual refactoring changes before they are applied."

	| instance |
	instance := self
				create: 'Refactoring view'
				on: (aSequenceableCollection notEmpty ifTrue: [aSequenceableCollection first]) asValue
				choices: aSequenceableCollection
				caption: aStringCaptionOrNil.
	"We now hack in a BooleanPresenter attached to the checkbox - for anything more complex than this, it would be better to subclass ChoicePrompter"
	(instance add: BooleanPresenter new name: 'showChanges')
		view: (instance view viewNamed: 'showChanges') presenterConnectionPoint.
	^instance showModal ifNotNil: [instance]!

resource_Refactoring_view
	"Answer the literal data from which the 'Refactoring view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_view)
	"

	^#(#'!!STL' 6 2118 11 #{UI.STBViewProxy} #{UI.DialogView} 38 #{Core.Array} 34 nil nil 8 #(13369344 65536) 32 nil 518 #{Graphics.ThemeColor} #dialog 518 #{Graphics.Point} 501 701 133 nil 1350 1 #{Graphics.Font} nil true 262 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 193 nil nil 32 1798 #{UI.BorderLayout} 1 1 nil 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140850688 131073 272 nil nil nil 5 nil nil nil 272 582 1 #{UI.ResourceIdentifier} #{UI.Presenter} #resource_Refactoring_OK_Cancel_button_block nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createWindow: 50 1 1030 #{UI.CreateWindow} 262 #{OS.RECTL} 8 #[7 0 0 0 18 1 0 0 70 1 0 0 53 1 0 0] 193 304 8 '' 272 3 8 #() 130 193 193 nil 27 nil nil 18 #{UI.ListBox} 50 17 nil 32 50 2 8 1144062209 1025 592 838 2 #{UI.ListModel} 550 #{Core.OrderedCollection} 0 nil 6 #{Kernel.IdentitySearchPolicy} 6 #{Graphics.Color} #default nil 5 nil nil nil 592 nil nil 518 #{Core.Message} #displayString 8 #() 8 #() nil 370 50 1 418 #createWindow: 50 1 466 498 8 #[7 0 0 0 7 0 0 0 70 1 0 0 18 1 0 0] 193 624 8 '' 592 3 8 #() 130 193 193 nil 27 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 50 2 592 8 'choices' 518 #{Graphics.Rectangle} 130 15 15 130 17 15 nil nil nil nil 1 nil nil nil 130 501 311 1 nil 193 774 #{Core.Semaphore} nil nil 1 nil nil nil nil nil nil 370 50 2 418 #createWindow: 50 1 518 #{UI.CreateDialog} 1074 130 7679 21 130 8379 731 193 32 418 #setWindowText: 50 1 8 'Choose one of:' 32 1 50 2 592 272 130 193 193 nil 29)! !

!UI.ChoicePrompter class categoriesForMethods!
refactoringChoices:caption:!instance creation!public! !
resource_Refactoring_view!public!resources-views! !
!

!UI.Presenter class methodsFor!

resource_Refactoring_OK_Cancel_button_block
	"Answer the literal data from which the 'Refactoring OK Cancel button block' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_OK_Cancel_button_block)
	"

	^#(#'!!STL' 6 2118 11 #{UI.STBViewProxy} #{UI.ContainerView} 38 #{Core.Array} 15 nil nil 50 2 8 1140850688 131073 32 nil nil nil 5 nil nil nil 32 1798 #{UI.BorderLayout} 1 1 nil nil 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1409286144 131073 144 nil nil nil 5 nil nil nil 144 838 1 #{UI.FlowLayout} 17 17 21 550 #{Core.IdentityDictionary} 0 518 #{Graphics.Rectangle} 518 #{Graphics.Point} 11 11 306 1 1 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createWindow: 50 1 1030 #{UI.CreateWindow} 262 #{OS.RECTL} 8 #[24 1 0 0 0 0 0 0 194 1 0 0 30 0 0 0] 193 176 8 '' 144 3 50 2 18 #{UI.PushButton} 50 20 nil 144 50 2 8 1141055488 1 560 nil nil nil 5 nil nil nil 560 nil nil 1350 4 #{UI.CommandDescription} #ok 8 'OK' 1 1 nil nil true nil nil nil 354 50 1 402 #createWindow: 50 1 450 482 8 #[12 0 0 0 5 0 0 0 87 0 0 0 28 0 0 0] 193 592 8 'OK' 560 3 8 #() 306 193 193 nil 29 18 #{UI.PushButton} 50 20 nil 144 50 2 8 1140924416 1 832 nil nil nil 5 nil nil nil 832 nil nil 626 #cancel 8 'Cancel' 1 1 nil nil false nil nil nil 354 50 1 402 #createWindow: 50 1 450 482 8 #[95 0 0 0 5 0 0 0 170 0 0 0 28 0 0 0] 193 864 8 'Cancel' 832 3 8 #() 306 193 193 nil 29 306 193 193 nil 27 18 #{UI.CheckBox} 50 16 nil 32 50 2 8 1409363203 1 1104 1094 2 #{UI.ValueHolder} nil nil 6 #{Kernel.NeverSearchPolicy} false 6 #{Graphics.Color} #transparent nil 517 nil nil nil 1104 nil nil 518 #{UI.NullConverter} nil nil nil 354 50 1 402 #createWindow: 50 1 450 482 8 #[0 0 0 0 0 0 0 0 152 0 0 0 30 0 0 0] 193 1136 8 'Show proposed changes?' 1104 3 8 #() 306 193 193 nil 27 nil 518 #{Kernel.STBIdentityDictionaryProxy} 240 50 2 1104 8 'showChanges' nil 354 50 1 402 #createWindow: 50 1 450 482 8 #[255 14 0 0 10 0 0 0 193 16 0 0 40 0 0 0] 193 80 8 '' 32 3 50 2 144 1104 306 193 193 nil 27)! !

!UI.Presenter class categoriesForMethods!
resource_Refactoring_OK_Cancel_button_block!public!resources-views! !
!

"End of package definition"!

