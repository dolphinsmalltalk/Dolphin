| package |
package := Package name: 'Dolphin Refactoring Browser'.
package paxVersion: 2;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Refactoring Browser Native UI Integration
Copyright (c) Object Arts Ltd, 2001-2009.

This package augments the native Dolphin development system browsers to add refactoring capabilities. The refactorings themselves are implemented by the Refactory refactoring engine, originally ported to Dolphin at Camp Smalltalk 1 in San Diego by Andy Bower and Blair McGlashan with the assistance of John Brant and Don Roberts. We would also like to acknowledge the contribution of Donald McQueen, who pioneered the way with his Refactoring Browser add-on for Dolphin 3.x and 4.x.

Refactoring operations are supported by the Debugger and all the Dolphin browsers. The Debugger and Method Browser support the Code and Method refactorings only, with the Class Hierarchy and System browser supporting all refactorings, including those which operate on classes. The Package Browser, which is really more of an organiser than a coding tool, supports a limited range of refactorings where it is useful to be able to limit their scope to a particular package or set of packages (e.g. renaming a method), although package scoped refactorings can also be initiated from other tools, in particular the System Browser.

A brief description of most of the Refactorings themselves can be found at:

	http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/Refactorings.html

Dolphin also incorporates some of its own specific refactorings.
1) Rename Method References. Not strictly a refactoring, in that it may not preserve existing behaviour, this is effectively one half Rename Method. It renames all references to a selector within the chosen refactoring scope, but does not rename any definitions. This is useful when you have a duplicate method where both original and duplicate are called, and you want to rename refs to the duplicate to call the original, which will then allow removal of the duplicate.
2) Remove Duplicate Methods. This simply removes any methods in a class or classes that are not required because they duplicate an inherited definition. It is particularly useful when applied against packages to help maintain code quality by removing redundant methods.

As of Dolphin 6 renaming a class or instance variable in the browsers can also (optionally) rename accessor methods for that variable. This is based on the Rename Class / Instance Variable and Accessors refactoring developed as part of the Camp Smalltalk RB project. When renaming a variable if any potential accessors are found then the user is prompted as to whether they wish to rename those accessors as well as the underlying variable. The dialog also allows the scope of the method rename to be chosen.

In the browsers Refactoring commands can be found on the Refactoring sub-menus of the class tree, method list, and source workspace context menus, and on the Refactoring sub-menus of the Class, Method and Workspace top-level menus, wherever these are present. In the Debugger the method refactorings menu can be found on the stack trace window context menu, and off the Debug top-level menu. Extensive use is made of dynamically constructed menus to enhance usability, and accelerator key sequences are associated with the most commonly used code refactorings. Many refactorings (not just "code" refactorings) can now be initiated from the browser source workspace context menus just by right-clicking over the appropriate syntactic element; for example you can rename a self-sent message by selecting the message send or just by right-clicking over one of the selector''s keywords.'.

package basicPackageVersion: '6.1'.


package setClassNames: #(
	#{CodeMentorPlugin}
	#{CodeRefactoringTool}
	#{CodeRewriterPlugin}
	#{ConvertToSiblingDialog}
	#{CopyClassRefactoring}
	#{DolphinAddGlobalChange}
	#{DolphinGlobalChange}
	#{DolphinRemoveGlobalChange}
	#{LintRuleFailuresBrowserShell}
	#{MethodNameDialog}
	#{MethodRefactoringTool}
	#{RBScopedMethodName}
	#{RefactoringSmalltalkSystem}
	#{RefactoringTool}
	#{RenameAccessorsDialog}
	#{RenameMethodDialog}
	#{RenameMethodReferencesRefactoring}
	#{RewriteChangesBrowser}
	#{SmalllintCachingContext}
	#{SmalllintPlugin}
).

package setMethodNames: #(
	#(#{AbstractClassVariableRefactoring class} #displayPrefix)
	#(#{AbstractInstanceVariableRefactoring class} #displayPrefix)
	#(#{AbstractVariablesRefactoring} #displayOn:)
	#(#{AddClassRefactoring} #displayOn:)
	#(#{AddClassVariableRefactoring class} #displayPrefix)
	#(#{AddInstanceVariableRefactoring class} #displayPrefix)
	#(#{AddMethodRefactoring} #displayOn:)
	#(#{AddParameterRefactoring} #displayOn:)
	#(#{BasicLintRule} #failedClasses)
	#(#{BasicLintRule} #failedMethods)
	#(#{BasicLintRule} #publishedAspects)
	#(#{BasicLintRule} #searchStrings)
	#(#{ChildrenToSiblingsRefactoring} #displayOn:)
	#(#{Class} #directlyDefinesClassVariable:)
	#(#{ClassBrowserAbstract} #abstractInstanceVariables)
	#(#{ClassBrowserAbstract} #methodRefactoringTool)
	#(#{ClassBrowserAbstract} #methodsToOverride)
	#(#{ClassBrowserAbstract} #overrideMethods)
	#(#{ClassBrowserAbstract} #protectInstanceVariables)
	#(#{ClassBrowserAbstract} #pushDownInstanceVariables)
	#(#{ClassBrowserAbstract} #pushDownMethods)
	#(#{ClassBrowserAbstract} #pushMethods:)
	#(#{ClassBrowserAbstract} #pushUpMethods)
	#(#{ClassBrowserAbstract} #queryRefactoringCommand:)
	#(#{ClassBrowserAbstract} #removeInstanceVariables)
	#(#{ClassBrowserAbstract} #renameMethod)
	#(#{ClassBrowserAbstract} #selectedOverridableMethods)
	#(#{ClassDescription} #definesClassVariable:)
	#(#{ClassDescription} #definesInstanceVariable:)
	#(#{ClassDescription} #definesVariable:)
	#(#{ClassDescription} #directlyDefinesClassVariable:)
	#(#{ClassDescription} #directlyDefinesInstanceVariable:)
	#(#{ClassDescription} #directlyDefinesVariable:)
	#(#{ClassDescription} #hierarchyDefinesVariable:)
	#(#{ClassSelector} #abstractClassVariables)
	#(#{ClassSelector} #abstractInstanceVariables)
	#(#{ClassSelector} #addClassVariable)
	#(#{ClassSelector} #addInstanceVariable)
	#(#{ClassSelector} #buildInstVarMenu:selectors:)
	#(#{ClassSelector} #buildPullUpVariablesMenu:)
	#(#{ClassSelector} #buildVariablesMenu:instVarSelectors:classVarSelectors:)
	#(#{ClassSelector} #cloneClass:under:changes:)
	#(#{ClassSelector} #convertToSibling)
	#(#{ClassSelector} #createClassVariableAccessors)
	#(#{ClassSelector} #populateClassVarMenu:selectors:)
	#(#{ClassSelector} #populateInstVarMenu:selectors:)
	#(#{ClassSelector} #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:)
	#(#{ClassSelector} #populateRefactoringMenu:)
	#(#{ClassSelector} #protectInstanceVariables)
	#(#{ClassSelector} #pullUpClassVariables)
	#(#{ClassSelector} #pullUpInstanceVariables)
	#(#{ClassSelector} #pullUpVariableNamePairs:for:maximum:)
	#(#{ClassSelector} #pushDownClassVariables)
	#(#{ClassSelector} #pushDownInstanceVariables)
	#(#{ClassSelector} #queryRefactoringCommand:)
	#(#{ClassSelector} #removeClassVariables)
	#(#{ClassSelector} #removeDuplicateMethods)
	#(#{ClassSelector} #removeInstanceVariables)
	#(#{ClassSelector} #safeRemoveClass)
	#(#{CreateAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Debugger} #canMoveMethods)
	#(#{Debugger} #hasRefactorableMethodSelected)
	#(#{Debugger} #performMethodRefactoring:)
	#(#{Debugger} #performMethodRenameRefactoring:)
	#(#{ExpandReferencedPoolsRefactoring} #displayOn:)
	#(#{ExtractMethodRefactoring} #displayOn:)
	#(#{ExtractMethodToComponentRefactoring} #displayOn:)
	#(#{ExtractMethodToComponentRefactoring} #getOptionVariableToMoveToOf:in:)
	#(#{ExtractToTemporaryRefactoring} #displayOn:)
	#(#{InlineAllSendersRefactoring} #displayOn:)
	#(#{InlineMethodRefactoring} #displayOn:)
	#(#{InlineParameterRefactoring} #displayOn:)
	#(#{InlineTemporaryRefactoring} #displayOn:)
	#(#{LintRule} #failedClasses)
	#(#{LintRule} #failedMethods)
	#(#{LintRule class} #icon)
	#(#{LintRule} #searchStrings)
	#(#{Metaclass} #directlyDefinesClassVariable:)
	#(#{MethodBrowser} #canMoveMethods)
	#(#{MethodBrowser} #hasRefactorableMethodSelected)
	#(#{MethodBrowser} #performMethodRefactoring:)
	#(#{MethodBrowser} #performMethodRenameRefactoring:)
	#(#{MethodBrowser} #performMethodsRefactoring:name:)
	#(#{MethodRefactoring} #getOptionMethodName:)
	#(#{MethodWorkspace} #canRefactor)
	#(#{MethodWorkspace} #executeRefactoring:)
	#(#{MethodWorkspace} #executeRefactoring:with:)
	#(#{MethodWorkspace} #fontOfStyle:)
	#(#{MethodWorkspace} #performCodeRefactoring:)
	#(#{MethodWorkspace} #performMethodRefactoring:)
	#(#{MethodWorkspace} #performMethodRenameRefactoring:)
	#(#{MethodWorkspace} #renameVariable:operation:validationBlock:)
	#(#{MoveMethodRefactoring} #displayOn:)
	#(#{MoveMethodRefactoring} #getOptionSelfArgumentName)
	#(#{MoveMethodRefactoring} #getOptionVariableTypes:selected:)
	#(#{MoveVariableDefinitionRefactoring} #displayOn:)
	#(#{PackageBrowserShell} #addParameter)
	#(#{PackageBrowserShell} #addParameterTo:)
	#(#{PackageBrowserShell} #addParameterToMethod)
	#(#{PackageBrowserShell} #chooseMethodsForRefactoring:)
	#(#{PackageBrowserShell} #hasRefactorableMethodSelected)
	#(#{PackageBrowserShell} #parseTree)
	#(#{PackageBrowserShell} #performMethodRenameRefactoring:)
	#(#{PackageBrowserShell} #performMethodsRefactoring:name:)
	#(#{PackageBrowserShell} #promptForMethodName:caption:allowExisting:)
	#(#{PackageBrowserShell} #queryRefactoringCommand:)
	#(#{PackageBrowserShell} #removeParameter)
	#(#{PackageBrowserShell} #renameLooseMethod)
	#(#{PackageBrowserShell} #renameLooseMethodReferences)
	#(#{PackageBrowserShell} #renameMethod)
	#(#{PackageBrowserShell} #renameMethodReferences:)
	#(#{PackageBrowserShell} #safeRemoveMethod)
	#(#{PackageBrowserShell} #safeRemoveMethods)
	#(#{PackageSelector} #moveAllTempsToInnerScope)
	#(#{PackageSelector} #queryRefactoringCommand:)
	#(#{PackageSelector} #removeDuplicateMethods)
	#(#{ProtectInstanceVariableRefactoring class} #displayPrefix)
	#(#{PullUpClassVariableRefactoring} #displayOn:)
	#(#{PullUpClassVariableRefactoring class} #displayPrefix)
	#(#{PullUpInstanceVariableRefactoring} #displayOn:)
	#(#{PullUpInstanceVariableRefactoring class} #displayPrefix)
	#(#{PushDownClassVariableRefactoring class} #displayPrefix)
	#(#{PushDownInstanceVariableRefactoring class} #displayPrefix)
	#(#{PushDownMethodRefactoring} #displayOn:)
	#(#{PushUpMethodRefactoring} #displayOn:)
	#(#{RBAbstractClass} #instVarNames)
	#(#{RBAbstractClass} #owningPackage)
	#(#{RBMethod} #owningPackage)
	#(#{Refactoring} #confirm:)
	#(#{Refactoring class} #icon)
	#(#{Refactoring class} #renameIcon)
	#(#{RemoveClassRefactoring} #displayOn:)
	#(#{RemoveClassVariableRefactoring class} #displayPrefix)
	#(#{RemoveInstanceVariableRefactoring class} #displayPrefix)
	#(#{RemoveMethodRefactoring} #displayOn:)
	#(#{RemoveParameterRefactoring} #displayOn:)
	#(#{RenameAccessorsForVariableRefactoring} #displayOn:)
	#(#{RenameAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{RenameAccessorsForVariableRefactoring class} #icon)
	#(#{RenameClassRefactoring} #displayOn:)
	#(#{RenameClassVariableRefactoring} #displayOn:)
	#(#{RenameClassVariableRefactoring class} #displayPrefix)
	#(#{RenameClassVariableRefactoring class} #icon)
	#(#{RenameInstanceVariableAndAccessorsRefactoring} #displayOn:)
	#(#{RenameInstanceVariableRefactoring} #displayOn:)
	#(#{RenameInstanceVariableRefactoring class} #displayPrefix)
	#(#{RenameInstanceVariableRefactoring class} #icon)
	#(#{RenameMethodRefactoring} #displayOn:)
	#(#{RenameMethodRefactoring class} #icon)
	#(#{RenameTemporaryRefactoring} #displayOn:)
	#(#{RenameTemporaryRefactoring class} #icon)
	#(#{SmalllintChecker class} #newWithCachingContext)
	#(#{SmalltalkToolShell} #chooseMethodForRefactoring:)
	#(#{SmalltalkToolShell} #queryRefactoringCommand:)
	#(#{TemporaryToInstanceVariableRefactoring} #displayOn:)
	#(#{TransformationRule class} #bitLogicElimination)
	#(#{TransformationRule class} #icon)
	#(#{TransformationRule class} #ifElimination)
	#(#{TransformationRule class} #renameArgument:to:)
	#(#{VariableRefactoring} #displayOn:)
	#(#{VariableRefactoring class} #displayPrefix)
	#(#{VariableRefactoring} #displayPrefix)
).

package setPrerequisites: #(
	'..\..\..\..\Contributions\Camp Smalltalk\Refactoring Browser\Refactorings\CSRefactorings'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Presenters\Difference\Dolphin Differences Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin In-place Text Editor'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\Base\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'Dolphin Professional Tools'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\ActiveX\Components\SHDocVw\Internet Explorer'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Parser\RBParser'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\SmallLint\RBSmallLint'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Shell\Windows Shell'
	'..\..\ActiveX\Components\XML DOM\XML DOM'
).

package!

"Class Definitions"!

Object subclass: #RefactoringTool
	instanceVariableNames: 'presenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ProfessionalSmalltalkSystem subclass: #RefactoringSmalltalkSystem
	instanceVariableNames: 'isOAD'
	classVariableNames: 'RefactoringSignal'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ClassBrowserPlugin subclass: #SmalllintPlugin
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SmalllintPlugin subclass: #CodeMentorPlugin
	instanceVariableNames: 'failuresPresenter infoSitePresenter infoBrowserPresenter progressPresenter checkerProcess rulesTreeModel isRefreshPending refreshMode'
	classVariableNames: 'DefaultRefreshMode LintIconMap LintRulesDoc'
	poolDictionaries: 'SHDocVwConstants'
	classInstanceVariableNames: ''!
SmalllintPlugin subclass: #CodeRewriterPlugin
	instanceVariableNames: 'searchTextPresenter replaceTextPresenter isMethodPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Dialog subclass: #ConvertToSiblingDialog
	instanceVariableNames: 'classNamePresenter subclassesPresenter statusModel'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Dialog subclass: #MethodNameDialog
	instanceVariableNames: 'selectorPresenter parametersPresenter parameterNamesPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MethodNameDialog subclass: #RenameMethodDialog
	instanceVariableNames: 'scopePresenter scopeDescriptionPresenter allowExistingSelector'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ValueDialog subclass: #RenameAccessorsDialog
	instanceVariableNames: 'selectorsPresenter scopePresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SmalltalkToolShell subclass: #RewriteChangesBrowser
	instanceVariableNames: 'changesPresenter differencesPresenter compositeChange'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MethodBrowserShell subclass: #LintRuleFailuresBrowserShell
	instanceVariableNames: 'lintRule'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RBMethodName subclass: #RBScopedMethodName
	instanceVariableNames: 'methodClass originalArguments originalSelector scope scopes'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RenameClassRefactoring subclass: #CopyClassRefactoring
	instanceVariableNames: 'superclass'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RenameMethodRefactoring subclass: #RenameMethodReferencesRefactoring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RefactoringTool subclass: #CodeRefactoringTool
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'SmalltalkParseErrorCodes'
	classInstanceVariableNames: ''!
RefactoringTool subclass: #MethodRefactoringTool
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RefactoryChange subclass: #DolphinGlobalChange
	instanceVariableNames: 'variable'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
DolphinGlobalChange subclass: #DolphinAddGlobalChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
DolphinGlobalChange subclass: #DolphinRemoveGlobalChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SmalllintContext subclass: #SmalllintCachingContext
	instanceVariableNames: ''
	classVariableNames: 'Literals Mtx Selectors'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Loose Methods"!

!AbstractClassVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!AbstractClassVariableRefactoring class categoriesFor: #displayPrefix!constants!displaying!public! !

!AbstractInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!AbstractInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!AbstractVariablesRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	#todo.	"Implement more informative display string"
	aStream nextPutAll: 'Abstract Variables'! !
!AbstractVariablesRefactoring categoriesFor: #displayOn:!displaying!public! !

!AddClassRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Add class ';
		display: className! !
!AddClassRefactoring categoriesFor: #displayOn:!displaying!public! !

!AddClassVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!AddClassVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!AddInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!AddInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!AddMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Add method to ';
		print: class! !
!AddMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!AddParameterRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Add parameter to ';
		print: oldSelector! !
!AddParameterRefactoring categoriesFor: #displayOn:!displaying!public! !

!BasicLintRule methodsFor!

failedClasses
	self result isClassEnvironment ifFalse: [^super failedClasses].
	^self result classes!

failedMethods
	| failedMethods |
	self result isClassEnvironment ifTrue: [^super failedMethods].
	failedMethods := Set new: 64.
	self result 
		classesAndSelectorsDo: [:eachClass :eachSel | failedMethods add: (eachClass compiledMethodAt: eachSel)].
	^failedMethods!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := self class publishedAspectsOfInstances.
	self result isClassEnvironment 
		ifTrue: 
			[answer add: ((Aspect collection: #failedClasses)
						beReadOnly;
						yourself)]
		ifFalse: 
			[answer add: ((Aspect collection: #failedMethods)
						beReadOnly;
						yourself)].
	self searchStrings notEmpty 
		ifTrue: 
			[answer add: ((Aspect sequenceableCollection: #searchStrings)
						beReadOnly;
						yourself)].
	^answer!

searchStrings
	^result searchStrings! !
!BasicLintRule categoriesFor: #failedClasses!accessing!private! !
!BasicLintRule categoriesFor: #failedMethods!accessing!private! !
!BasicLintRule categoriesFor: #publishedAspects!constants!development!public! !
!BasicLintRule categoriesFor: #searchStrings!accessing!private! !

!ChildrenToSiblingsRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Convert ';
		display: parent;
		nextPutAll: ' to sibling'! !
!ChildrenToSiblingsRefactoring categoriesFor: #displayOn:!displaying!public! !

!Class methodsFor!

directlyDefinesClassVariable: aString 
	^self classVarNames includes: aString asString! !
!Class categoriesFor: #directlyDefinesClassVariable:!public!testing! !

!ClassBrowserAbstract methodsFor!

abstractInstanceVariables
	"Private - Invoke the 'Abstract Instance Variable' refactoring on the currently selected variables."

	self model abstractInstanceVariables: self variables within: BrowserEnvironment new!

methodRefactoringTool
	^methodBrowserPresenter refactoringTool!

methodsToOverride
	| methods class selectedClass |
	methods := self selectedOverridableMethods.
	methods notEmpty ifTrue: [^methods].
	methods := IdentityDictionary new.
	selectedClass := self actualClass.
	class := selectedClass superclass.
	[class isNil] whileFalse: 
			[class methodDictionary keysAndValuesDo: 
					[:eachSelector :eachMethod | 
					(eachSelector first ~~ $_ and: [(eachSelector beginsWith: 'basic') not]) 
						ifTrue: [methods at: eachSelector put: eachMethod]].
			class := class superclass].
	^(ChoicePrompter multipleChoices: methods keys asSortedCollection
		caption: 'Choose Methods to Override...') 
			ifNotNil: [:selectors | selectors collect: [:each | selectedClass lookupMethod: each]]!

overrideMethods
	| stream class changes name methods |
	class := self actualClass.
	stream := String writeStream.
	changes := CompositeRefactoryChange new.
	methods := self methodsToOverride.
	(methods isNil or: [methods isEmpty]) ifTrue: [^self].
	methods do: 
			[:each | 
			| keywordsAndArgs |
			stream reset.
			keywordsAndArgs := self systemModel keywordsAndArgsOfMethod: each.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			stream
				crtab;
				nextPutAll: '^super';
				space.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			changes addChange: (changes addMethodChangeClass 
						compile: stream contents
						in: class
						categories: each categories
						package: each owningPackageIfLoose)].
	name := String writeStream.
	name nextPutAll: 'Override '.
	methods size > 1 
		ifTrue: 
			[name
				print: methods size;
				nextPutAll: ' methods']
		ifFalse: [name print: methods first].
	changes name: name contents.
	self systemModel changeManager performChange: changes.
	self selectedMethods: (methodBrowserPresenter methodsPresenter list 
				intersection: ((methods collect: [:each | each selector]) asSet 
						collect: [:each | class compiledMethodAt: each ifAbsent: []]))!

protectInstanceVariables
	"Private - Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables."

	self model protectInstanceVariables: self variables!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the currently selected variables."

	self model pushDownInstanceVariables: self variables!

pushDownMethods
	self pushMethods: false!

pushMethods: aBoolean 
	| change isShift methods targetClass |
	isShift := Keyboard default isShiftDown.
	methods := self selectedMethods.
	"It is assumed that the methods are all of the same class (the 'push method' commands are disabled if not)"
	targetClass := methods first methodClass.
	targetClass := aBoolean ifTrue: [targetClass superclass] ifFalse: [targetClass subclasses first].
	change := self methodRefactoringTool pushMethods: aBoolean.
	(change isNil or: [isShift not]) ifTrue: [^self].
	methods := (methods asSet 
				collect: [:each | targetClass compiledMethodAt: each selector ifAbsent: []]) asArray.
	self actualClass: methods first methodClass ifAbsent: [^self].
	self selectedMethods: methods!

pushUpMethods
	self pushMethods: true!

queryRefactoringCommand: aCommandQuery 
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#protectInstanceVariables #abstractInstanceVariables #removeInstanceVariables) 
		identityIncludes: selector) 
			ifTrue: 
				[aCommandQuery isEnabled: self variables notEmpty.
				^true].
	#pushDownInstanceVariables == selector 
		ifTrue: 
			[| class |
			aCommandQuery isEnabled: ((class := self actualClass) notNil 
						and: [class subclasses notEmpty and: [self variables notEmpty]]).
			^true].
	#pushDownMethods == selector 
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushDownMethods 
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#pushUpMethods == selector 
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushUpMethods 
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#overrideMethods == selector 
		ifTrue: 
			[| class methods |
			methods := self selectedOverridableMethods.
			class := self actualClass.
			aCommandQuery
				isEnabled: class superclass notNil;
				text: (aCommandQuery commandDescription menuText expandMacrosWith: (methods isEmpty 
									ifTrue: ['...']
									ifFalse: [methods size == 1 ifTrue: [methods first] ifFalse: ['Methods']])).
			^true].
	^false!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the currently selected variables."

	self model removeInstanceVariables: self variables within: self searchEnvironment!

renameMethod
	(self chooseMethodForRefactoring: 'Rename Method...') 
		ifNotNil: [:method | self methodRefactoringTool renameMethod: method]!

selectedOverridableMethods
	| class |
	class := self actualClass.
	^self selectedMethods reject: [:each | each methodClass == class]! !
!ClassBrowserAbstract categoriesFor: #abstractInstanceVariables!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #methodRefactoringTool!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #methodsToOverride!helpers!private! !
!ClassBrowserAbstract categoriesFor: #overrideMethods!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #protectInstanceVariables!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #pushDownInstanceVariables!commands!public!refactoring! !
!ClassBrowserAbstract categoriesFor: #pushDownMethods!commands!public!refactoring! !
!ClassBrowserAbstract categoriesFor: #pushMethods:!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #pushUpMethods!commands!public!refactoring! !
!ClassBrowserAbstract categoriesFor: #queryRefactoringCommand:!commands!private!refactoring! !
!ClassBrowserAbstract categoriesFor: #removeInstanceVariables!public!refactoring! !
!ClassBrowserAbstract categoriesFor: #renameMethod!accessing!private! !
!ClassBrowserAbstract categoriesFor: #selectedOverridableMethods!accessing!private! !

!ClassDescription methodsFor!

definesClassVariable: aSymbol 
	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesClassVariable: aSymbol]!

definesInstanceVariable: aString 
	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesInstanceVariable: aString]!

definesVariable: aVariableName 
	^(self definesClassVariable: aVariableName) 
		or: [self definesInstanceVariable: aVariableName]!

directlyDefinesClassVariable: aString 
	^self subclassResponsibility!

directlyDefinesInstanceVariable: aString 
	^self instVarNames includes: aString!

directlyDefinesVariable: aVariableName 
	^(self directlyDefinesClassVariable: aVariableName) 
		or: [self directlyDefinesInstanceVariable: aVariableName]!

hierarchyDefinesVariable: aString 
	(self definesVariable: aString) ifTrue: [^true].
	^self allSubclasses anySatisfy: [:each | each directlyDefinesVariable: aString]! !
!ClassDescription categoriesFor: #definesClassVariable:!public!testing! !
!ClassDescription categoriesFor: #definesInstanceVariable:!public!testing! !
!ClassDescription categoriesFor: #definesVariable:!public!testing! !
!ClassDescription categoriesFor: #directlyDefinesClassVariable:!public!testing! !
!ClassDescription categoriesFor: #directlyDefinesInstanceVariable:!public!testing! !
!ClassDescription categoriesFor: #directlyDefinesVariable:!public!testing! !
!ClassDescription categoriesFor: #hierarchyDefinesVariable:!public!testing! !

!ClassSelector methodsFor!

abstractClassVariables
	"Invoke the 'Abstract Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Abstract Class Variables...') 
		ifNotNil: [:varNames | self systemModel abstractClassVariables: varNames within: BrowserEnvironment new]!

abstractInstanceVariables
	"Invoke the 'Abstract Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Abstract Instance Variables...') 
		ifNotNil: [:varNames | self systemModel abstractInstanceVariables: varNames within: BrowserEnvironment new]!

addClassVariable
	"Private - Invoke the 'Add Class Variable' refactoring to add a class variable to the
	currently selected class."

	self systemModel
		addClassVariableTo: self selection!

addInstanceVariable
	"Private - Invoke the 'Add Instance Variable' refactoring to add an instance variable to the
	currently selected class."

	self systemModel
		addInstanceVariableTo: self actualClass!

buildInstVarMenu: aMenu selectors: selectors
	"Private - Build a dynamic pull-out menu which lists all of a class' existing inst. var. 
	names so that one or other can be removed, renamed, etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: selectors!

buildPullUpVariablesMenu: aMenu 
	| class items |
	aMenu clear.
	class := self actualClass.
	(ClassBuilder isFixedLayout: class) 
		ifFalse: 
			[self 
				populatePullUpVariableMenu: aMenu
				forClass: class
				command: #pullUpInstanceVariable:into:
				classVariables: false
				ifTooMany: #pullUpInstanceVariables.
			aMenu notEmpty ifTrue: [aMenu addSeparator]].
	self 
		populatePullUpVariableMenu: aMenu
		forClass: class instanceClass
		command: #pullUpClassVariable:into:
		classVariables: true
		ifTooMany: #pullUpClassVariables.
	items := aMenu items.
	(items notEmpty and: [items last isDivider]) ifTrue: [aMenu removeItemAt: items size]!

buildVariablesMenu: aMenu instVarSelectors: instVarSelectors classVarSelectors: classVarSelectors 
	"Private - Build a dynamic pull-out menu which lists all of a class' existing 
	instance and class variable names so that one or other can be removed, renamed, 
	etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: instVarSelectors.
	(aMenu notEmpty and: [self selection classPool notEmpty]) ifTrue: [aMenu addSeparator].
	self populateClassVarMenu: aMenu selectors: classVarSelectors!

cloneClass: aClass under: superClass changes: aCompositeRefactoryChange
	| namespace newName |
	namespace := RBNamespace new
				changes: aCompositeRefactoryChange;
				yourself.
	
	[newName := ('CopyOf' , aClass name) asSymbol.
	newName asQualifiedReference isDefined] whileTrue.
	(CopyClassRefactoring
		model: namespace
		clone: aClass
		as: newName
		superclass: superClass) primitiveExecute!

convertToSibling
	"Invoke the 'Convert to Sibling' refactoring (inserts a new class as the common superclass of the selected
	class and its current subclasses, copying common methods to the new superclass and adding 
	#subclassResponsibility methods as necessary)."

	self systemModel
		convertToSibling: self selection!

createClassVariableAccessors
	"Prompt to generate compiled 'get' and 'set' accessor methods for the immediate
	class variables of the selected class."

	self createVariableAccessors: true!

populateClassVarMenu: aMenu selectors: selectors 
	| class varNames |
	class := self selection.
	varNames := class classVarNames.
	varNames size > self maximumVariableMenuEntries 
		ifTrue: [(aMenu addCommand: selectors last description: '&Class Variable...') isModalCommand: true]
		ifFalse: 
			[self 
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>']!

populateInstVarMenu: aMenu selectors: selectors 
	| class varNames |
	class := self actualClass.
	varNames := class instVarNames.
	varNames size > self maximumVariableMenuEntries 
		ifTrue: [(aMenu addCommand: selectors last description: '&Instance Variable...') isModalCommand: true]
		ifFalse: 
			[self 
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>']!

populatePullUpVariableMenu: aMenu forClass: aClass command: commandSymbol classVariables: aBoolean ifTooMany: tooManyCommand
	| pairs |
	pairs := self 
				pullUpVariableNamePairs: aBoolean
				for: aClass
				maximum: self maximumVariableMenuEntries.
	pairs isNil 
		ifTrue: 
			[aMenu addCommand: tooManyCommand
				description: (aBoolean 
						ifTrue: ['&Class Variable...']
						ifFalse: ['&Instance Variable...'])]
		ifFalse: 
			[(pairs asSortedCollection: 
					[:p1 :p2 | 
					p1 key == p2 key 
						ifTrue: [p1 value < p2 value]
						ifFalse: [p1 key name < p2 key name]]) 
				do: 
					[:each | 
					| msg varName |
					varName := each value.
					msg := MessageSend 
								receiver: self systemModel
								selector: commandSymbol
								arguments: (Array with: varName with: aClass).
					aMenu addCommand: msg description: each key name , '.' , varName]]!

populateRefactoringMenu: aMenu 
	"Private - If the <Menu> argument is dynamic refactoring menu, then populate it with appropriate
	choices based on the currently selected class."

	| menuName |
	menuName := aMenu name.
	menuName == #pushDownInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#pushDownInstanceVariable:in: #pushDownInstanceVariables)].
	menuName == #createInstanceVariableAccessors 
		ifTrue: 
			[^self buildInstVarMenu: aMenu
				selectors: #(#createInstanceVariableAccessors:in: #createInstanceVariableAccessors)].
	menuName == #abstractInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#abstractInstanceVariable:in: #abstractInstanceVariables)].
	(menuName == #protectInstanceVariables or: [menuName == #protectVariables]) 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#protectInstanceVariable:in: #protectInstanceVariables)].
	"Generic menus that contain both class and inst vars"
	menuName == #removeVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#removeInstanceVariable:from:within: #removeInstanceVariables)
				classVarSelectors: #(#removeClassVariable:from:within: #removeClassVariables)].
	menuName == #renameVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#renameInstanceVariable:in:within: #renameInstanceVariable)
				classVarSelectors: #(#renameClassVariable:in:within: #renameClassVariable)].
	menuName == #pushDownVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#pushDownInstanceVariable:in:within: #pushDownInstanceVariables)
				classVarSelectors: #(#pushDownClassVariable:in:within: #pushDownClassVariables)].
	menuName == #pullUpVariables ifTrue: [^self buildPullUpVariablesMenu: aMenu].
	menuName == #createVariableAccessors 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#createInstanceVariableAccessors:in:within: #createInstanceVariableAccessors)
				classVarSelectors: #(#createClassVariableAccessors:in:within: #createClassVariableAccessors)].
	menuName == #abstractVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#abstractInstanceVariable:in:within: #abstractInstanceVariables)
				classVarSelectors: #(#abstractClassVariable:in:within: #abstractClassVariables)]!

protectInstanceVariables
	"Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Protect Instance Variables...') 
		ifNotNil: [:varNames | self systemModel protectInstanceVariables: varNames]!

pullUpClassVariables
	"Invoke the 'Pull Up Class Variable' refactoring on the users choice of subclass' class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self selection.
	pairs := self 
				pullUpVariableNamePairs: true
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter 
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Class Variables...')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil 
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpClassVariable: each value into: class]]!

pullUpInstanceVariables
	"Invoke the 'Pull Up Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self actualClass.
	pairs := self 
				pullUpVariableNamePairs: false
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter 
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Instance Variables...')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil 
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpInstanceVariable: each value into: class]]!

pullUpVariableNamePairs: aBoolean for: class maximum: anInteger 
	| pairs varNames |
	varNames := Set new.
	pairs := OrderedCollection new.
	class allSubclassesDo: 
			[:subclass | 
			(aBoolean ifTrue: [subclass classVarNames] ifFalse: [subclass instVarNames]) do: 
					[:each | 
					(varNames includes: each) 
						ifFalse: 
							[varNames add: each.
							varNames size > anInteger ifTrue: [^nil].
							pairs add: subclass -> each]]].
	^pairs!

pushDownClassVariables
	"Invoke the 'Push Down Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Push Down Class Variables...') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Push Down Instance Variables...') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

queryRefactoringCommand: aCommandQuery 
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery> argument."

	| selector class |
	selector := aCommandQuery commandSymbol.
	class := self actualClass.
	(#(#classRefactoringsMenu #safeRemoveClass #addClassVariable) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: class notNil.
			^true].
	#addInstanceVariable == selector 
		ifTrue: 
			[| prefix |
			prefix := (class notNil and: [class isMeta]) ifTrue: ['Class '] ifFalse: [''].
			aCommandQuery
				text: (aCommandQuery commandDescription menuText expandMacrosWith: prefix);
				isEnabled: (class notNil and: [class isPointers]).
			^true].
	(#(#removeInstanceVariables #protectInstanceVariables #abstractInstanceVariables #renameInstanceVariable) 
		identityIncludes: selector) 
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instVarNames notEmpty]).
				^true].
	#pushDownInstanceVariables == selector 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (class notNil and: [class subclasses notEmpty and: [class instVarNames notEmpty]]).
			^true].
	#pushDownVariables == selector 
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil 
						and: [class subclasses notEmpty and: [class instVarNames notEmpty or: [class classPool notEmpty]]]).
			^true].
	#pullUpInstanceVariables == selector 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (class notNil and: [class allSubclasses anySatisfy: [:each | each instVarNames notEmpty]]).
			^true].
	#pullUpClassVariables == selector 
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil 
						and: [class instanceClass allSubclasses anySatisfy: [:each | each classVarNames notEmpty]]).
			^true].
	(#(#renameClassVariable #removeClassVariables #pushDownClassVariables #createClassVariableAccessors #abstractClassVariables) 
		identityIncludes: selector) 
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instanceClass classVarNames notEmpty]).
				^true].
	(#(#renameVariables #removeVariables #pushDownVariables #protectVariables #abstractVariables #createVariableAccessors) 
		identityIncludes: selector) 
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil 
							and: [class instVarNames notEmpty or: [class instanceClass classVarNames notEmpty]]).
				^true].
	#pushDownVariables == selector 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (class notNil and: 
							[class subclasses notEmpty 
								and: [class instVarNames notEmpty or: [class instanceClass classVarNames notEmpty]]]).
			^true].
	#pullUpVariables == selector 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (class notNil and: 
							[| isFixed |
							isFixed := ClassBuilder isFixedLayout: class.
							class allSubclasses anySatisfy: 
									[:each | 
									(isFixed not and: [each instVarNames notEmpty]) or: [each instanceClass classVarNames notEmpty]]]).
			^true].

	"Not a recognised refactoring command"
	^false!

removeClassVariables
	"Invoke the 'Remove Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Remove Class Variables...') 
		ifNotNil: [:varNames | self systemModel removeClassVariables: varNames within: self searchEnvironment]!

removeDuplicateMethods
	| class |
	class := self actualClass.
	(self systemModel removeMethodsDuplicatedInSuperclassOf: class) 
		ifFalse: 
			[MessageBox 
				notify: ('<1p> does not duplicate any of its superclass'' methods' expandMacrosWith: class)
				caption: 'Remove Duplicate Methods...']!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Remove Instance Variables...') 
		ifNotNil: [:varNames | self systemModel removeInstanceVariables: varNames within: self searchEnvironment]!

safeRemoveClass
	"Removes the selected class from the system, but not if it is referenced,
	and any subclasses are removable (i.e. invoke the 'Remove Class' refactoring)."

	self systemModel safeRemoveClass: self selection! !
!ClassSelector categoriesFor: #abstractClassVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #abstractInstanceVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #addClassVariable!commands!private!refactoring! !
!ClassSelector categoriesFor: #addInstanceVariable!commands!private!refactoring! !
!ClassSelector categoriesFor: #buildInstVarMenu:selectors:!menus!private!refactoring! !
!ClassSelector categoriesFor: #buildPullUpVariablesMenu:!menus!private!refactoring! !
!ClassSelector categoriesFor: #buildVariablesMenu:instVarSelectors:classVarSelectors:!menus!private!refactoring! !
!ClassSelector categoriesFor: #cloneClass:under:changes:!private! !
!ClassSelector categoriesFor: #convertToSibling!commands!public!refactoring! !
!ClassSelector categoriesFor: #createClassVariableAccessors!commands!public!refactoring! !
!ClassSelector categoriesFor: #populateClassVarMenu:selectors:!menus!private!refactoring! !
!ClassSelector categoriesFor: #populateInstVarMenu:selectors:!menus!private!refactoring! !
!ClassSelector categoriesFor: #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:!menus!private!refactoring! !
!ClassSelector categoriesFor: #populateRefactoringMenu:!menus!private!refactoring! !
!ClassSelector categoriesFor: #protectInstanceVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #pullUpClassVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #pullUpInstanceVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #pullUpVariableNamePairs:for:maximum:!menus!private!refactoring! !
!ClassSelector categoriesFor: #pushDownClassVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #pushDownInstanceVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #queryRefactoringCommand:!commands!private! !
!ClassSelector categoriesFor: #removeClassVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #removeDuplicateMethods!commands!private!refactoring! !
!ClassSelector categoriesFor: #removeInstanceVariables!commands!public!refactoring! !
!ClassSelector categoriesFor: #safeRemoveClass!commands!public!refactoring! !

!CreateAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Create accessors for'! !
!CreateAccessorsForVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!Debugger methodsFor!

canMoveMethods
	#todo.	"Not currently supported in the debugger because it rewrites the caller, which complicates the unwind"
	^false!

hasRefactorableMethodSelected
	^self isRunning not and: 
			[| method |
			method := self selectedMethod.
			method notNil and: [method isUnbound not and: [self parseTree notNil]]]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	aMonadicValuable value: self selectedMethod.
	self selectedMethod isUnbound ifTrue: [self restartMethod]!

performMethodRenameRefactoring: aMonadicValuable 
	| method home sender refactoring |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := aMonadicValuable value: method.
	refactoring isNil ifTrue: [^self].
	"Since the method of the selected frame has been renamed, the sending frame's method will
	have been rewritten, therefore we need to restart the sender frame."
	home := self findHomeFrame: self frame.
	home isNil ifTrue: [^self].
	sender := home sender.
	(sender notNil and: [sender isRestartable]) ifTrue: [self restartMethodFrame: sender]! !
!Debugger categoriesFor: #canMoveMethods!commands!private!refactoring! !
!Debugger categoriesFor: #hasRefactorableMethodSelected!public!refactoring!testing! !
!Debugger categoriesFor: #performMethodRefactoring:!helpers!public!refactoring! !
!Debugger categoriesFor: #performMethodRenameRefactoring:!helpers!private!refactoring! !

!ExpandReferencedPoolsRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream nextPutAll: 'Add pool'.
	pools size = 1 
		ifTrue: 
			[aStream
				space;
				display: pools asArray first]
		ifFalse: 
			[aStream nextPutAll: 's '.
			pools do: [:each | aStream display: each]
				separatedBy: [aStream nextPutAll: ', ']].
	aStream nextPutAll: ' to '.
	toClasses size = 1 
		ifTrue: 
			[aStream
				display: toClasses asArray first]
		ifFalse: 
			[toClasses do: [:each | aStream display: each name]
				separatedBy: [aStream nextPutAll: ', ']]! !
!ExpandReferencedPoolsRefactoring categoriesFor: #displayOn:!displaying!public! !

!ExtractMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Extract method from ';
		print: class;
		nextPutAll: '>>';
		display: selector! !
!ExtractMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!ExtractMethodToComponentRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Extract to component from ';
		print: class;
		nextPutAll: '>>';
		display: selector!

getOptionVariableToMoveToOf: aClass in: aSelector 
	^Smalltalk developmentSystem selectTargetVariableOf: aClass
		parseTree: (aClass parseTreeFor: aSelector)! !
!ExtractMethodToComponentRefactoring categoriesFor: #displayOn:!displaying!public! !
!ExtractMethodToComponentRefactoring categoriesFor: #getOptionVariableToMoveToOf:in:!public! !

!ExtractToTemporaryRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Extract to temporary ';
		print: newVariableName! !
!ExtractToTemporaryRefactoring categoriesFor: #displayOn:!displaying!public! !

!InlineAllSendersRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Inline sends of ';
		print: selector;
		nextPutAll: ' in ';
		print: class! !
!InlineAllSendersRefactoring categoriesFor: #displayOn:!displaying!public! !

!InlineMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Inline message in ';
		print: class;
		nextPutAll: '>>';
		print: sourceSelector! !
!InlineMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!InlineParameterRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Inline parameter ';
		print: argument;
		nextPutAll: ' in ';
		print: class;
		nextPutAll: '>>';
		display: oldSelector! !
!InlineParameterRefactoring categoriesFor: #displayOn:!displaying!public! !

!InlineTemporaryRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Inline temp ';
"		print: oldName;"
		nextPutAll: ' in ';
		print: class;
		nextPutAll: '>>';
		display: selector! !
!InlineTemporaryRefactoring categoriesFor: #displayOn:!displaying!public! !

!LintRule methodsFor!

failedClasses
	^Set new!

failedMethods
	^Set new
!

searchStrings
	^#()! !
!LintRule categoriesFor: #failedClasses!accessing!private! !
!LintRule categoriesFor: #failedMethods!accessing!private! !
!LintRule categoriesFor: #searchStrings!accessing!private! !

!LintRule class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!LintRule class categoriesFor: #icon!constants!public! !

!Metaclass methodsFor!

directlyDefinesClassVariable: aString 
	^self instanceClass directlyDefinesClassVariable: aString! !
!Metaclass categoriesFor: #directlyDefinesClassVariable:!public!testing! !

!MethodBrowser methodsFor!

canMoveMethods
	^self hasRefactorableMethodSelected!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected and: [self parseTree notNil]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethod!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	| refactoring method |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := sourcePresenter executeRefactoring: aMonadicValuable with: method.
	refactoring isNil ifTrue: [^self].
	method := (method ifNil: [self parseContext] ifNotNil: [method methodClass]) 
				compiledMethodAt: refactoring newSelector
				ifAbsent: [].
	(method notNil and: [self filter value: method]) ifTrue: [self selectMethod: method]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !
!MethodBrowser categoriesFor: #canMoveMethods!helpers!private!refactoring! !
!MethodBrowser categoriesFor: #hasRefactorableMethodSelected!private!refactoring!testing! !
!MethodBrowser categoriesFor: #performMethodRefactoring:!helpers!public!refactoring! !
!MethodBrowser categoriesFor: #performMethodRenameRefactoring:!helpers!private!refactoring! !
!MethodBrowser categoriesFor: #performMethodsRefactoring:name:!helpers!private!refactoring! !

!MethodRefactoring methodsFor!

getOptionMethodName: anRBMethodName
	anRBMethodName selector isNil
		ifTrue: 
			[| args mname |
			args := anRBMethodName arguments.
			mname := args isEmpty
						ifTrue: ['method']
						ifFalse: 
							[| stream |
							stream := String writeStream.
							anRBMethodName arguments do: 
									[:arg |
									stream
										nextPutAll: arg;
										nextPut: $:].
							stream contents].
			anRBMethodName selector: mname asSymbol].
	^(MethodNameDialog showModalOn: anRBMethodName) isNil ifFalse: [anRBMethodName]! !
!MethodRefactoring categoriesFor: #getOptionMethodName:!options!public! !

!MethodWorkspace methodsFor!

canRefactor
	^self isEditable and: 
			[self isModified not and: 
					[self systemModel canRefactor 
						and: [parentPresenter notNil and: [parentPresenter hasRefactorableMethodSelected]]]]!

executeRefactoring: aMonadicValuable 
	^aMonadicValuable on: Notification
		do: 
			[:ex | 
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

executeRefactoring: aMonadicValuable with: anObject 
	^[aMonadicValuable value: anObject] on: Notification
		do: 
			[:ex | 
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

fontOfStyle: style 
	| font |
	font := style fontName ifNil: [view actualFont copy] ifNotNil: [:face | Font name: face].
	style restyleFont: font.
	^font!

performCodeRefactoring: refactoringOperation 
	self 
		performMethodRefactoring: [:method | refactoringOperation value: method value: self selectedNode]!

performMethodRefactoring: aMonadicValuable 
	^parentPresenter performMethodRefactoring: aMonadicValuable!

performMethodRenameRefactoring: aBlockClosure 
	^parentPresenter performMethodRenameRefactoring: aBlockClosure!

renameVariable: aStVariableNode operation: operationBlock validationBlock: validationBlock 
	| name rectangle range style editor font |
	range := aStVariableNode sourceInterval.
	name := self plainTextRange: range.
	self assert: [aStVariableNode name = name].
	editor := InplaceTextEditor createOn: name asValue.
	editor validationBlock: 
			[:candidateName | 
			"If the name is unchanged, treat as valid and ignore later"
			candidateName = name or: 
					[| err |
					[validationBlock value: candidateName] on: RefactoringError
						do: 
							[:ex | 
							self errorModel value: ex.
							err := ex].
					err isNil]].
	rectangle := self view boundingRectangleOfTextRange: range.
	editor textRectangle: rectangle.
	"Set the same font as the existing text so there is no visible 'jump'"
	style := self view styleAt: range start.
	font := self fontOfStyle: style.
	editor font: font.
	editor showModal 
		ifNotNil: 
			[:newName | 
			newName = name ifFalse: [self performMethodRefactoring: [:method | operationBlock value: newName]]]! !
!MethodWorkspace categoriesFor: #canRefactor!public!refactoring!testing! !
!MethodWorkspace categoriesFor: #executeRefactoring:!helpers!private!refactoring! !
!MethodWorkspace categoriesFor: #executeRefactoring:with:!helpers!private!refactoring! !
!MethodWorkspace categoriesFor: #fontOfStyle:!operations!private!refactoring! !
!MethodWorkspace categoriesFor: #performCodeRefactoring:!helpers!private!refactoring! !
!MethodWorkspace categoriesFor: #performMethodRefactoring:!helpers!private!refactoring! !
!MethodWorkspace categoriesFor: #performMethodRenameRefactoring:!helpers!private!refactoring! !
!MethodWorkspace categoriesFor: #renameVariable:operation:validationBlock:!operations!private!refactoring! !

!MoveMethodRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: 'Move ';
		display: class;
		nextPutAll: '>>';
		display: selector;
		nextPutAll: '  to ';
		print: variable!

getOptionSelfArgumentName
	| newName existing |
	existing := parseTree allDefinedVariables.
	newName := (Prompter 
				createOn: String new
				prompt: 'Enter name for argument to refer to "self" in extracted method'
				caption: self displayString)
				validationBlock: 
						[:name | 
						(existing includes: name) not and: 
								[moveToClasses 
									allSatisfy: [:each | (RBCondition isValidTemporaryVariableName: name for: each) check]]];
				showModal.
	newName isNil ifTrue: [^self refactoringAborted: 'Method not moved'].
	^newName!

getOptionVariableTypes: choicesCollection selected: suggestionsCollection
	^(ChoicePrompter
		create: 'Extensible multi-selection choice prompter'
		on: suggestionsCollection asOrderedCollection
		multipleChoices: ((choicesCollection union: suggestionsCollection)
				asSortedCollection: [:a :b | a name < b name])
		caption: 'Select class(es) of new method... ')
		newCaption: 'Add Other Class ...';
		newBlock: 
				[:aString |
				| global index |
				index := aString identityIndexOf: $\x20.
				global := index == 0
							ifTrue: [aString asQualifiedReference valueOrNil]
							ifFalse: [(aString leftString: index - 1) asQualifiedReference ifDefined: [:c | c class]].
				(global notNil
					and: [(global isKindOf: Behavior) and: [self model environment includesClass: global]])
						ifFalse: 
							[MessageBox errorMsg: ('Sorry, but <1s> is not a valid class name' expandMacrosWith: aString).
							nil]
						ifTrue: [self model classNamed: global name]];
		showModal! !
!MoveMethodRefactoring categoriesFor: #displayOn:!displaying!public! !
!MoveMethodRefactoring categoriesFor: #getOptionSelfArgumentName!public! !
!MoveMethodRefactoring categoriesFor: #getOptionVariableTypes:selected:!options!public! !

!MoveVariableDefinitionRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: 'Move ';
		display: 'variable';
		nextPutAll: ' to inner scope in ';
		print: class;
		nextPutAll: '>>';
		display: selector! !
!MoveVariableDefinitionRefactoring categoriesFor: #displayOn:!displaying!public! !

!PackageBrowserShell methodsFor!

addParameter
	"Private - Command to invoke the Add Parameter to Method refactoring, prompting the user for 
	the selector of the method to which the parameter is added, and constrained to operate
	only within the selected packages."

	(self chooseMethodForRefactoring: 'Add Parameter in Package(s)...') 
		ifNotNil: [:method | self addParameterTo: method]
!

addParameterTo: aCompiledMethod 
	self model 
		addParameterToMethod: aCompiledMethod
		inPackages: self packages
		caption: 'Add Parameter to <2p> in Package(s)...'!

addParameterToMethod
	"Private - 'Loose Methods' card context menu command to invoke the 
	'Add Parameter to Method refactoring' against a selected loose method, 
	constrained within the selected packages."

	self addParameterTo: self selectedMethod!

chooseMethodsForRefactoring: aString 
	| selector methods definitions searchEnv |
	searchEnv := self searchEnvironment.
	methods := self selectedMethods.
	methods isEmpty ifFalse: [^searchEnv forMethods: methods].
	selector := self model chooseSelectorInEnvironment: searchEnv caption: aString.
	selector isNil ifTrue: [^searchEnv forMethods: #()].
	definitions := searchEnv definitionsOf: selector.
	definitions isEmpty 
		ifTrue: 
			[MessageBox 
				errorMsg: ('There are no definitions of <1p> in the selected package(s).' expandMacrosWith: selector)].
	^definitions!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected!

parseTree
	^self selectedMethod ifNotNil: [:method | SmalltalkParser parseExistingMethodNoError: method]!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	^aMonadicValuable value: self selectedMethod!

performMethodsRefactoring: aMonadicValuable name: aString 
	| methods |
	methods := self chooseMethodsForRefactoring: ('<1s> from Package(s)...' expandMacrosWith: aString).
	methods isEmpty ifTrue: [^nil].
	^[aMonadicValuable value: methods allMethods] on: Notification
		do: 
			[:ex | 
			statusModel value: ex.
			ex resume]!

promptForMethodName: aCompiledMethod caption: aString allowExisting: aBoolean 
	| methodName |
	methodName := RBScopedMethodName fromMethod: aCompiledMethod.
	methodName packages: self packages.
	^self systemModel 
		promptForMethodName: methodName
		caption: aString
		allowExisting: aBoolean!

queryRefactoringCommand: aCommandQuery 
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#methodRefactoringsMenu #renameMethod #addParameter #removeParameter) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: self hasPackages.
			^true].
	(#(#safeRemoveMethods) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethods notEmpty]).
			^true].
	(#(#addParameterToMethod) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethod notNil]).
			^true].
	(#(#removeParameterMenu) identityIncludes: selector) 
		ifTrue: 
			[| method |
			method := self selectedMethod.
			aCommandQuery isEnabled: (self hasPackages and: [method notNil and: [method argumentCount > 0]]).
			^true].
	"Not a refactoring command"
	^false!

removeParameter
	"Private - Command to invoke the Remove Parameter to Method refactoring, but constrained to operate
	only within the selected packages."

	| method ast arg |
	method := self chooseMethodForRefactoring: 'Remove Parameter in Package(s)...'.
	method isNil ifTrue: [^self].
	ast := method parseTreeNoError.
	ast isNil ifTrue: [^self].
	arg := ChoicePrompter choices: ast argumentNames
				caption: ('Remove Parameter from <1p> in Package(s)...' expandMacrosWith: method selector).
	arg notNil ifTrue: [methodRefactoringTool removeParameter: arg from: method]!

renameLooseMethod
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method' refactoring against the selected loose method, but configured to rename 
	only within selected packages."

	methodRefactoringTool renameMethod!

renameLooseMethodReferences
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method References' refactoring against the selected loose method, but configured to rename 
	references only within selected packages."

	self renameMethodReferences: self selectedMethod!

renameMethod
	"Private - Initiate a 'Rename' method refactoring against the selected method,
	but configured to rename only within the selected packages."

	"Implemementation Note: This command implementation is used if there is not exactly one
	method selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	(self chooseMethodForRefactoring: 'Rename Method in Package(s)...') 
		ifNotNil: [:method | methodRefactoringTool renameMethod: method]!

renameMethodReferences: aCompiledMethod 
	| methodName |
	methodName := self 
				promptForMethodName: aCompiledMethod
				caption: ('Rename References to <1p> in Package(s)...' expandMacrosWith: aCompiledMethod selector)
				allowExisting: true.
	methodName notNil ifTrue: [self model renameMethodReferences: aCompiledMethod to: methodName]!

safeRemoveMethod
	"Private - Prompt the user for a selector and invoke the 'Safe Remove Method' refactoring to 
	remove the specified methods from the system if defined but not referenced from within 
	any of the selected packages ((i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	"Implemementation Note: This command implementation is used only if there are no 
	methods selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	| methods |
	methods := self chooseMethodsForRefactoring: 'Safe Remove Methods from Package(s)...'.
	methods isEmpty 
		ifFalse: [self model safeRemoveMethodsIn: methods within: self selectionEnvironment]!

safeRemoveMethods
	"Private - 'Loose Methods' card context menu command to invoke the 'Safe Remove Method' 
	refactoring. Removes the selected methods from the system if not referenced from within any 
	of the selected packages (i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	self model safeRemoveMethods: self selectedMethods within: self selectionEnvironment! !
!PackageBrowserShell categoriesFor: #addParameter!commands!private!refactoring! !
!PackageBrowserShell categoriesFor: #addParameterTo:!private!refactoring! !
!PackageBrowserShell categoriesFor: #addParameterToMethod!commands!public!refactoring! !
!PackageBrowserShell categoriesFor: #chooseMethodsForRefactoring:!private!refactoring! !
!PackageBrowserShell categoriesFor: #hasRefactorableMethodSelected!private!refactoring!testing! !
!PackageBrowserShell categoriesFor: #parseTree!commands!private! !
!PackageBrowserShell categoriesFor: #performMethodRenameRefactoring:!helpers!private!refactoring! !
!PackageBrowserShell categoriesFor: #performMethodsRefactoring:name:!private! !
!PackageBrowserShell categoriesFor: #promptForMethodName:caption:allowExisting:!helpers!private!refactoring! !
!PackageBrowserShell categoriesFor: #queryRefactoringCommand:!commands!private!refactoring! !
!PackageBrowserShell categoriesFor: #removeParameter!commands!private!refactoring! !
!PackageBrowserShell categoriesFor: #renameLooseMethod!commands!private!refactoring! !
!PackageBrowserShell categoriesFor: #renameLooseMethodReferences!commands!private!refactoring! !
!PackageBrowserShell categoriesFor: #renameMethod!commands!public!refactoring! !
!PackageBrowserShell categoriesFor: #renameMethodReferences:!operations!private!refactoring! !
!PackageBrowserShell categoriesFor: #safeRemoveMethod!commands!public!refactoring! !
!PackageBrowserShell categoriesFor: #safeRemoveMethods!commands!public!refactoring! !

!PackageSelector methodsFor!

moveAllTempsToInnerScope
	(MessageBox 
		confirm: 'This refactoring will move all temporaries in all methods in the selected package(s) into the tightest scope that contains both the variable assignment and references. Any unreferenced temporaries will be removed.

Are you sure that you would like to proceed?'
		caption: 'Move All Temps to Inner Scope...') 
			ifTrue: [self systemModel moveAllTempsToInnerScope: self selectionEnvironment]!

queryRefactoringCommand: aCommandQuery 
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| cmd canRefactor |
	cmd := aCommandQuery commandSymbol.
	canRefactor := self systemModel canRefactor and: [self hasPackages].
	(#(#removeDuplicateMethods) identityIncludes: cmd) 
		ifTrue: 
			[aCommandQuery isEnabled: canRefactor.
			^true].
	"Not a refactoring command"
	^false!

removeDuplicateMethods
	| count pkgs |
	pkgs := self packages.
	count := pkgs inject: 0 into: [:sum :eachPackage | sum + eachPackage classNames size].
	(ProgressDialog operation: 
			[:progress | 
			| i devsys |
			i := 0.
			devsys := self systemModel.
			pkgs do: 
					[:eachPackage | 
					progress text: eachPackage name.
					eachPackage classes do: 
							[:eachClass | 
							i := i + 1.
							progress value: i * 100 // count.
							devsys removeMethodsDuplicatedInSuperclassOf: eachClass]]])
		caption: 'Remove Methods Duplicating Superclass'' from Package(s)...';
		showModal! !
!PackageSelector categoriesFor: #moveAllTempsToInnerScope!commands!private!refactoring! !
!PackageSelector categoriesFor: #queryRefactoringCommand:!commands!private!refactoring! !
!PackageSelector categoriesFor: #removeDuplicateMethods!development!private! !

!ProtectInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Protect'! !
!ProtectInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!PullUpClassVariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		print: class! !
!PullUpClassVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!PullUpClassVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!PullUpClassVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!PullUpInstanceVariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		print: class! !
!PullUpInstanceVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!PullUpInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!PullUpInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!PushDownClassVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!PushDownClassVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!PushDownInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!PushDownInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!PushDownMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Push down ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		print: class! !
!PushDownMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!PushUpMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Push up ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		print: class! !
!PushUpMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!RBAbstractClass methodsFor!

instVarNames
	^self instanceVariableNames!

owningPackage
	^self realClass ifNotNil: [:class | class owningPackage]! !
!RBAbstractClass categoriesFor: #instVarNames!instance variables!public! !
!RBAbstractClass categoriesFor: #owningPackage!accessing!public! !

!RBMethod methodsFor!

owningPackage
	^compiledMethod isNil 
		ifTrue: [class owningPackage]
		ifFalse: [compiledMethod owningPackage]! !
!RBMethod categoriesFor: #owningPackage!accessing!public! !

!Refactoring methodsFor!

confirm: aString
	"Dolphin specific confirmation prompt"

	^MessageBox 
		confirm: aString
		caption: self displayString! !
!Refactoring categoriesFor: #confirm:!helpers!public! !

!Refactoring class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

renameIcon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'InPlaceRename.ico'! !
!Refactoring class categoriesFor: #icon!constants!public! !
!Refactoring class categoriesFor: #renameIcon!constants!public! !

!RemoveClassRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Remove '.
	classNames size == 1 
		ifTrue: [aStream nextPutAll: 'class '; display: classNames first]
		ifFalse: [
			aStream nextPutAll: 'classes: '.
			classNames do: [:each | aStream display: each] separatedBy: [aStream nextPutAll: ', ']]! !
!RemoveClassRefactoring categoriesFor: #displayOn:!displaying!public! !

!RemoveClassVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!RemoveClassVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!RemoveInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!RemoveInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !

!RemoveMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Remove ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		print: class! !
!RemoveMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!RemoveParameterRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Remove parameter ';
		print: argument;
		nextPutAll: ' from ';
		print: class;
		nextPutAll: '>>';
		display: oldSelector! !
!RemoveParameterRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameAccessorsForVariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	super displayOn: aStream.
	aStream
		nextPutAll: ' to ';
		print: newName! !
!RenameAccessorsForVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Rename accessors for'!

icon
	^self renameIcon! !
!RenameAccessorsForVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !
!RenameAccessorsForVariableRefactoring class categoriesFor: #icon!constants!public! !

!RenameClassRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Rename class ';
		display: className;
		nextPutAll: ' to ';
		display: newName! !
!RenameClassRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameClassVariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	super displayOn: aStream.
	aStream
		nextPutAll: ' to ';
		print: newName! !
!RenameClassVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameClassVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!RenameClassVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !
!RenameClassVariableRefactoring class categoriesFor: #icon!constants!public! !

!RenameInstanceVariableAndAccessorsRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self displayPrefix;
		space;
		print: class;
		nextPut: $.;
		display: variableName;
		nextPutAll: ' (and accessors) to ';
		print: newName! !
!RenameInstanceVariableAndAccessorsRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameInstanceVariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	super displayOn: aStream.
	aStream
		nextPutAll: ' to ';
		print: newName! !
!RenameInstanceVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!RenameInstanceVariableRefactoring class categoriesFor: #displayPrefix!displaying!public! !
!RenameInstanceVariableRefactoring class categoriesFor: #icon!constants!public! !

!RenameMethodRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Rename ';
		print: oldSelector;
		nextPutAll: ' to ';
		print: newSelector
! !
!RenameMethodRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameMethodRefactoring class methodsFor!

icon
	^self renameIcon! !
!RenameMethodRefactoring class categoriesFor: #icon!constants!public! !

!RenameTemporaryRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Rename temp ';
		print: oldName;
		nextPutAll: ' to ';
		print: newName; 
		nextPutAll: ' in ';
		print: class;
		nextPutAll: '>>';
		display: selector! !
!RenameTemporaryRefactoring categoriesFor: #displayOn:!displaying!public! !

!RenameTemporaryRefactoring class methodsFor!

icon
	^self renameIcon! !
!RenameTemporaryRefactoring class categoriesFor: #icon!constants!public! !

!SmalllintChecker class methodsFor!

newWithCachingContext
	^(self new)
		context: SmalllintCachingContext new;
		yourself! !
!SmalllintChecker class categoriesFor: #newWithCachingContext!instance creation!public! !

!SmalltalkToolShell methodsFor!

chooseMethodForRefactoring: aString 
	^self systemModel chooseMethodFromEnvironment: self selectionEnvironment caption: aString!

queryRefactoringCommand: aCommandQuery 
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	^false! !
!SmalltalkToolShell categoriesFor: #chooseMethodForRefactoring:!private!refactoring! !
!SmalltalkToolShell categoriesFor: #queryRefactoringCommand:!commands!private!refactoring! !

!TemporaryToInstanceVariableRefactoring methodsFor!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream 
		nextPutAll: 'Convert temp ';
		print: temporaryVariableName;
		nextPutAll: ' to inst var of ';
		print: class! !
!TemporaryToInstanceVariableRefactoring categoriesFor: #displayOn:!displaying!public! !

!TransformationRule class methodsFor!

bitLogicElimination
	"Inlining of methods may create redundant bit logic operations where the operation is a no-op or has a constant outcome. This transformation can eliminate some cases."


	^self
		rewrite: #(
			#('0 bitOr: ``@arg' 	"->" 	'``@arg')
			#('0 | ``@arg' 	"->" 	'``@arg')
			#('``@arg bitOr: 0' 	"->" 	'``@arg')
			#('``@arg | 0 ' 	"->" 	'``@arg')

			#('0 bitAnd: ``@arg' 	"->" 	'0')
			#('0 & ``@arg' 	"->" 	'0')
			#('``@arg bitAnd: 0' 	"->" 	'0')
			#('``@arg & 0 ' 	"->" 	'0')
		)			
		methods: false
		name: 'Eliminate redundant bit operations'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

ifElimination
	"Inlining of methods may create unecessary ifTrue:[ifFalse:] statements where the condition
	is a constant boolean value. This transformation is useful for eliminating these."

	^self 
		rewrite: #(#(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After'))
		methods: false
		name: 'Eliminate unnecessary ifTrue:[ifFalse:] conditions'!

renameArgument: beforeString to: afterString 
	^(TransformationRule new)
		name: ('Rename argument <1p> to <2p>' expandMacrosWith: beforeString with: afterString);
		rewriteUsing: ((ParseTreeRewriter new)
					replaceArgument: beforeString with: afterString;
					replace: beforeString with: afterString;
					yourself);
		yourself! !
!TransformationRule class categoriesFor: #bitLogicElimination!public!transformations! !
!TransformationRule class categoriesFor: #icon!constants!public! !
!TransformationRule class categoriesFor: #ifElimination!public!transformations! !
!TransformationRule class categoriesFor: #renameArgument:to:!public! !

!VariableRefactoring methodsFor!

displayOn: aStream 
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream
		nextPutAll: self displayPrefix;
		space;
		print: class;
		nextPut: $.;
		display: variableName!

displayPrefix
	^self class displayPrefix! !
!VariableRefactoring categoriesFor: #displayOn:!displaying!public! !
!VariableRefactoring categoriesFor: #displayPrefix!displaying!public! !

!VariableRefactoring class methodsFor!

displayPrefix
	^self subclassResponsibility! !
!VariableRefactoring class categoriesFor: #displayPrefix!constants!displaying!public! !

"End of package definition"!

