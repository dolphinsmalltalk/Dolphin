| package |
package := Package name: 'Dolphin Refactoring Browser'.
package paxVersion: 2.1;
	environmentName: #{Tools};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Refactoring Browser Native UI Integration
Copyright (c) Object Arts Ltd, 2001-2009.

This package augments the native Dolphin development system browsers to add refactoring capabilities. The refactorings themselves are implemented by the Refactory refactoring engine, originally ported to Dolphin at Camp Smalltalk 1 in San Diego by Andy Bower and Blair McGlashan with the assistance of John Brant and Don Roberts. We would also like to acknowledge the contribution of Donald McQueen, who pioneered the way with his Refactoring Browser add-on for Dolphin 3.x and 4.x.

Refactoring operations are supported by the Debugger and all the Dolphin browsers. The Debugger and Method Browser support the Code and Method refactorings only, with the Class Hierarchy and System browser supporting all refactorings, including those which operate on classes. The Package Browser, which is really more of an organiser than a coding tool, supports a limited range of refactorings where it is useful to be able to limit their scope to a particular package or set of packages (e.g. renaming a method), although package scoped refactorings can also be initiated from other tools, in particular the System Browser.

A brief description of most of the Refactorings themselves can be found at:

	http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/Refactorings.html

Dolphin also incorporates some of its own specific refactorings.
1) Rename Method References. Not strictly a refactoring, in that it may not preserve existing behaviour, this is effectively one half Rename Method. It renames all references to a selector within the chosen refactoring scope, but does not rename any definitions. This is useful when you have a duplicate method where both original and duplicate are called, and you want to rename refs to the duplicate to call the original, which will then allow removal of the duplicate.
2) Remove Duplicate Methods. This simply removes any methods in a class or classes that are not required because they duplicate an inherited definition. It is particularly useful when applied against packages to help maintain code quality by removing redundant methods.

As of Dolphin 6 renaming a class or instance variable in the browsers can also (optionally) rename accessor methods for that variable. This is based on the Rename Class / Instance Variable and Accessors refactoring developed as part of the Camp Smalltalk RB project. When renaming a variable if any potential accessors are found then the user is prompted as to whether they wish to rename those accessors as well as the underlying variable. The dialog also allows the scope of the method rename to be chosen.

In the browsers Refactoring commands can be found on the Refactoring sub-menus of the class tree, method list, and source workspace context menus, and on the Refactoring sub-menus of the Class, Method and Workspace top-level menus, wherever these are present. In the Debugger the method refactorings menu can be found on the stack trace window context menu, and off the Debug top-level menu. Extensive use is made of dynamically constructed menus to enhance usability, and accelerator key sequences are associated with the most commonly used code refactorings. Many refactorings (not just "code" refactorings) can now be initiated from the browser source workspace context menus just by right-clicking over the appropriate syntactic element; for example you can rename a self-sent message by selecting the message send or just by right-clicking over one of the selector''s keywords.'.

package basicPackageVersion: '6.1'.


package setClassNames: #(
	#{Refactory.Browser.CopyClassRefactoring}
	#{Refactory.Browser.RenameMethodReferencesTransformation}
	#{Tools.CodeMentorPlugin}
	#{Tools.CodeRefactoringTool}
	#{Tools.CodeRewriterPlugin}
	#{Tools.ConvertToSiblingDialog}
	#{Tools.LintRuleFailuresBrowserShell}
	#{Tools.MethodNameDialog}
	#{Tools.MethodRefactoringTool}
	#{Tools.RefactoringSmalltalkSystem}
	#{Tools.RefactoringTool}
	#{Tools.RenameAccessorsDialog}
	#{Tools.RenameMethodDialog}
	#{Tools.RewriteChangesBrowser}
	#{Tools.ScopedMethodName}
	#{Tools.SmalllintCachingContext}
	#{Tools.SmalllintPlugin}
).

package setMethodNames: #(
	#(#{Core.Behavior} #directlyDefinesMethod:)
	#(#{Core.ClassDescription} #definesClassVariable:)
	#(#{Core.ClassDescription} #definesInstanceVariable:)
	#(#{Core.ClassDescription} #definesVariable:)
	#(#{Core.ClassDescription} #directlyDefinesClassVariable:)
	#(#{Core.ClassDescription} #directlyDefinesInstanceVariable:)
	#(#{Core.ClassDescription} #directlyDefinesVariable:)
	#(#{Core.ClassDescription} #hierarchyDefinesVariable:)
	#(#{Refactory.Browser.AbstractClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #displayOn:)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #getOptionAbstractVariables)
	#(#{Refactory.Browser.AddClassChange class} #icon)
	#(#{Refactory.Browser.AddClassConstantChange class} #icon)
	#(#{Refactory.Browser.AddClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddClassVariableChange class} #icon)
	#(#{Refactory.Browser.AddClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.AddInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddMethodChange class} #icon)
	#(#{Refactory.Browser.AddMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddMethodRefactoring} #maxDetails)
	#(#{Refactory.Browser.AddParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddSharedVariableChange class} #icon)
	#(#{Refactory.Browser.BasicLintRule} #failedClasses)
	#(#{Refactory.Browser.BasicLintRule} #failedMethods)
	#(#{Refactory.Browser.BasicLintRule} #publishedAspects)
	#(#{Refactory.Browser.BasicLintRule} #searchStrings)
	#(#{Refactory.Browser.BasicRenameClassChange class} #icon)
	#(#{Refactory.Browser.ChangeMethodNameRefactoring} #getOptionRenameAllDefinitions:of:)
	#(#{Refactory.Browser.ChildrenToSiblingsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ClassCategoryChange class} #icon)
	#(#{Refactory.Browser.ClassCommentChange class} #icon)
	#(#{Refactory.Browser.ClassGuidChange class} #icon)
	#(#{Refactory.Browser.CompositeRefactoryChange class} #icon)
	#(#{Refactory.Browser.CreateAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #getOptionAddImports:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #getOptionUseExistingMethod:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #getOptionVariableToMoveToOf:in:)
	#(#{Refactory.Browser.ExtractToTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineAllSendersRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionImplementorToInline:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineOverridden:of:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineReordered:into:)
	#(#{Refactory.Browser.InlineParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.LintRule} #failedClasses)
	#(#{Refactory.Browser.LintRule} #failedMethods)
	#(#{Refactory.Browser.LintRule} #searchStrings)
	#(#{Refactory.Browser.LintRule class} #icon)
	#(#{Refactory.Browser.MethodRefactoring} #generateDefaultSelector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionAlreadyDefined:selector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionExtractAssignment:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionInlineExpression:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionNewMethodName:classes:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionRemoveMethod:referencedIn:)
	#(#{Refactory.Browser.MoveClassChange class} #icon)
	#(#{Refactory.Browser.MoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionSelfArgumentName)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionVariableTypes:selected:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #resolveClass:)
	#(#{Refactory.Browser.MoveVariableDefinitionRefactoring} #displayOn:)
	#(#{Refactory.Browser.ProtectInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionCopyDownSuperclassMethod:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionPushUpRemoveDuplicates:in:)
	#(#{Refactory.Browser.RBAbstractClass class} #icon)
	#(#{Refactory.Browser.RBAbstractCondition} #validate)
	#(#{Refactory.Browser.RBAbstractCondition} #validate:)
	#(#{Refactory.Browser.RBAbstractCondition class} #icon)
	#(#{Refactory.Browser.RBClass} #icon)
	#(#{Refactory.Browser.RBMetaclass class} #icon)
	#(#{Refactory.Browser.RBMethod} #owningPackage)
	#(#{Refactory.Browser.RBMethod class} #icon)
	#(#{Refactory.Browser.RBModel} #browseChanges)
	#(#{Refactory.Browser.RBModel class} #icon)
	#(#{Refactory.Browser.RBNamespaceClass class} #icon)
	#(#{Refactory.Browser.RBRootNamespace class} #icon)
	#(#{Refactory.Browser.RBSmalltalkNamespace class} #icon)
	#(#{Refactory.Browser.Refactoring} #chooseFrom:caption:)
	#(#{Refactory.Browser.Refactoring} #confirm:)
	#(#{Refactory.Browser.Refactoring} #maxDetails)
	#(#{Refactory.Browser.Refactoring} #printNameList:on:limit:type:)
	#(#{Refactory.Browser.Refactoring} #prompt:)
	#(#{Refactory.Browser.Refactoring class} #icon)
	#(#{Refactory.Browser.Refactoring class} #renameIcon)
	#(#{Refactory.Browser.RefactoryClassChange class} #icon)
	#(#{Refactory.Browser.RefactoryMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveClassChange class} #icon)
	#(#{Refactory.Browser.RemoveClassConstantChange class} #icon)
	#(#{Refactory.Browser.RemoveClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveClassRefactoring} #getOptionRemoveClass:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring} #getOptionRemoveVariable:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #getOptionRemoveDuplicatesWithSupersends:)
	#(#{Refactory.Browser.RemoveParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveSharedVariableChange class} #icon)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameClassChange class} #icon)
	#(#{Refactory.Browser.RenameClassRefactoring} #getOptionIgnoreSymbolicClassReferences:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameMethodRefactoring class} #icon)
	#(#{Refactory.Browser.RenameTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameTemporaryRefactoring class} #icon)
	#(#{Refactory.Browser.RenameVariableChange class} #icon)
	#(#{Refactory.Browser.SmalllintChecker class} #newWithCachingContext)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #getOptionConvertReadBeforeWritten:)
	#(#{Refactory.Browser.TransformationRule class} #bitLogicElimination)
	#(#{Refactory.Browser.TransformationRule class} #icon)
	#(#{Refactory.Browser.TransformationRule class} #ifElimination)
	#(#{Refactory.Browser.TransformationRule class} #renameArgument:to:)
	#(#{Refactory.Browser.VariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.VariableRefactoring} #displayPrefix)
	#(#{Refactory.Browser.VariableRefactoring} #getOptionPullUpNonSharedInstVar:)
	#(#{Refactory.Browser.VariableRefactoring class} #displayPrefix)
	#(#{Tools.ClassBrowserAbstract} #abstractInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #methodRefactoringTool)
	#(#{Tools.ClassBrowserAbstract} #methodsToOverride)
	#(#{Tools.ClassBrowserAbstract} #overrideMethods)
	#(#{Tools.ClassBrowserAbstract} #protectInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownMethods)
	#(#{Tools.ClassBrowserAbstract} #pushMethods:)
	#(#{Tools.ClassBrowserAbstract} #pushUpMethods)
	#(#{Tools.ClassBrowserAbstract} #queryRefactoringCommand:)
	#(#{Tools.ClassBrowserAbstract} #removeInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #renameMethod)
	#(#{Tools.ClassBrowserAbstract} #selectedOverridableMethods)
	#(#{Tools.ClassBrowserPlugin} #systemModel)
	#(#{Tools.ClassSelector} #abstractClassVariables)
	#(#{Tools.ClassSelector} #abstractInstanceVariables)
	#(#{Tools.ClassSelector} #addClassVariable)
	#(#{Tools.ClassSelector} #addImport)
	#(#{Tools.ClassSelector} #addInstanceVariable)
	#(#{Tools.ClassSelector} #buildInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #buildPullUpVariablesMenu:)
	#(#{Tools.ClassSelector} #buildVariablesMenu:instVarSelectors:classVarSelectors:)
	#(#{Tools.ClassSelector} #changeClassNamespace)
	#(#{Tools.ClassSelector} #cloneClass:under:changes:)
	#(#{Tools.ClassSelector} #convertToSibling)
	#(#{Tools.ClassSelector} #createClassVariableAccessors)
	#(#{Tools.ClassSelector} #populateClassVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populateInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:)
	#(#{Tools.ClassSelector} #populateRefactoringMenu:)
	#(#{Tools.ClassSelector} #protectInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpClassVariables)
	#(#{Tools.ClassSelector} #pullUpInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpVariableNamePairs:for:maximum:)
	#(#{Tools.ClassSelector} #pushDownClassVariables)
	#(#{Tools.ClassSelector} #pushDownInstanceVariables)
	#(#{Tools.ClassSelector} #queryRefactoringCommand:)
	#(#{Tools.ClassSelector} #removeClassVariables)
	#(#{Tools.ClassSelector} #removeDuplicateMethods)
	#(#{Tools.ClassSelector} #removeImport)
	#(#{Tools.ClassSelector} #removeInstanceVariables)
	#(#{Tools.Debugger} #canMoveMethods)
	#(#{Tools.Debugger} #hasRefactorableMethodSelected)
	#(#{Tools.Debugger} #performMethodRefactoring:)
	#(#{Tools.Debugger} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #canMoveMethods)
	#(#{Tools.MethodBrowser} #hasRefactorableMethodSelected)
	#(#{Tools.MethodBrowser} #performMethodRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodsRefactoring:name:)
	#(#{Tools.MethodWorkspace} #canRefactor)
	#(#{Tools.MethodWorkspace} #executeRefactoring:)
	#(#{Tools.MethodWorkspace} #executeRefactoring:with:)
	#(#{Tools.MethodWorkspace} #fontOfStyle:)
	#(#{Tools.MethodWorkspace} #performCodeRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRenameRefactoring:)
	#(#{Tools.MethodWorkspace} #renameVariable:operation:validationBlock:)
	#(#{Tools.PackageBrowserShell} #addParameter)
	#(#{Tools.PackageBrowserShell} #addParameterTo:)
	#(#{Tools.PackageBrowserShell} #addParameterToMethod)
	#(#{Tools.PackageBrowserShell} #changeClassNamespace)
	#(#{Tools.PackageBrowserShell} #chooseMethodsForRefactoring:)
	#(#{Tools.PackageBrowserShell} #hasRefactorableMethodSelected)
	#(#{Tools.PackageBrowserShell} #onClass:renameTo:accept:)
	#(#{Tools.PackageBrowserShell} #onRenameClass:to:showChanges:)
	#(#{Tools.PackageBrowserShell} #parseTree)
	#(#{Tools.PackageBrowserShell} #performMethodRenameRefactoring:)
	#(#{Tools.PackageBrowserShell} #performMethodsRefactoring:name:)
	#(#{Tools.PackageBrowserShell} #promptForMethodName:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #queryRefactoringCommand:)
	#(#{Tools.PackageBrowserShell} #removeMethod)
	#(#{Tools.PackageBrowserShell} #removeMethods)
	#(#{Tools.PackageBrowserShell} #removeParameter)
	#(#{Tools.PackageBrowserShell} #renameLooseMethod)
	#(#{Tools.PackageBrowserShell} #renameLooseMethodReferences)
	#(#{Tools.PackageBrowserShell} #renameMethod)
	#(#{Tools.PackageBrowserShell} #renameMethodReferences:)
	#(#{Tools.PackageSelector} #moveAllTempsToInnerScope)
	#(#{Tools.PackageSelector} #queryRefactoringCommand:)
	#(#{Tools.PackageSelector} #removeDuplicateMethods)
	#(#{Tools.SmalltalkToolShell} #chooseMethodForRefactoring:)
	#(#{Tools.SmalltalkToolShell} #queryRefactoringCommand:)
	#(#{UI.Dialog} #validationDwell)
).

package setPrerequisites: #(
	'..\..\..\..\Contributions\Camp Smalltalk\Refactoring Browser\Refactorings\CSRefactorings'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Base\Dolphin Base Dialogs'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Views\Buttons\Dolphin Check Buttons'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Presenters\Difference\Dolphin Differences Presenter'
	'..\..\MVP\Graphics\Dolphin GDI Graphics'
	'..\..\MVP\Presenters\Prompters\Dolphin In-place Text Editor'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\System\Win32\MessageBox\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'Dolphin Professional Tools'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Views\Buttons\Dolphin Push Buttons'
	'..\..\MVP\Views\Splitter\Dolphin Splitter Control'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Views\Tooltips\Dolphin Tooltips'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Parser\RBParser'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\SmallLint\RBSmallLint'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Components\WebView2\WebView2'
	'..\..\ActiveX\Shell\Windows Shell'
	'..\..\ActiveX\Components\XML DOM\XML DOM'
).

package!

"Class Definitions"!

Core.Object subclass: #'Tools.RefactoringTool'
	instanceVariableNames: 'presenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ProfessionalSmalltalkSystem subclass: #'Tools.RefactoringSmalltalkSystem'
	instanceVariableNames: 'isOAD'
	classVariableNames: 'RefactoringSignal'
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassBrowserPlugin subclass: #'Tools.SmalllintPlugin'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin subclass: #'Tools.CodeMentorPlugin'
	instanceVariableNames: 'failuresPresenter infoSitePresenter infoBrowserPresenter progressPresenter checkerProcess rulesTreeModel isRefreshPending refreshMode'
	classVariableNames: 'DefaultRefreshMode LintIconMap LintRulesDoc'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin subclass: #'Tools.CodeRewriterPlugin'
	instanceVariableNames: 'searchTextPresenter replaceTextPresenter isMethodPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.ConvertToSiblingDialog'
	instanceVariableNames: 'classNamePresenter namespacePresenter subclassesPresenter statusModel'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.MethodNameDialog'
	instanceVariableNames: 'selectorPresenter parametersPresenter parameterNamesPresenter hintBubble'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodNameDialog subclass: #'Tools.RenameMethodDialog'
	instanceVariableNames: 'scopePresenter scopeDescriptionPresenter allowExistingSelector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.RenameAccessorsDialog'
	instanceVariableNames: 'selectorsPresenter scopePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.RewriteChangesBrowser'
	instanceVariableNames: 'changesPresenter differencesPresenter compositeChange'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodBrowserShell subclass: #'Tools.LintRuleFailuresBrowserShell'
	instanceVariableNames: 'lintRule'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBMethodName subclass: #'Tools.ScopedMethodName'
	instanceVariableNames: 'methodClass originalArguments originalSelector scope scopes'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ClassRefactoring subclass: #'Refactory.Browser.CopyClassRefactoring'
	instanceVariableNames: 'newName class superclass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RenameMethodRefactoring subclass: #'Refactory.Browser.RenameMethodReferencesTransformation'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool subclass: #'Tools.CodeRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Kernel.ParseErrorCodes})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool subclass: #'Tools.MethodRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.SmalllintContext subclass: #'Tools.SmalllintCachingContext'
	instanceVariableNames: ''
	classVariableNames: 'Literals Mtx Selectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Behavior methodsFor!

directlyDefinesMethod: aSymbol
	^self includesSelector: aSymbol! !
!Core.Behavior categoriesForMethods!
directlyDefinesMethod:!methods-testing!public! !
!

!Core.ClassDescription methodsFor!

definesClassVariable: aSymbol 
	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesClassVariable: aSymbol]!

definesInstanceVariable: aString 
	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesInstanceVariable: aString]!

definesVariable: aVariableName 
	^(self definesClassVariable: aVariableName) 
		or: [self definesInstanceVariable: aVariableName]!

directlyDefinesClassVariable: aString
	| var |
	var := self localBindingFor: aString.
	^var notNil and: [var isClassVariable]!

directlyDefinesInstanceVariable: aString 
	^self instanceVariableNames includes: aString!

directlyDefinesVariable: aVariableName 
	^(self directlyDefinesClassVariable: aVariableName) 
		or: [self directlyDefinesInstanceVariable: aVariableName]!

hierarchyDefinesVariable: aString
	(self definesVariable: aString) ifTrue: [^true].
	self allSubclassesBreadthFirstDo: [:each | (each directlyDefinesVariable: aString) ifTrue: [^true]].
	^false! !
!Core.ClassDescription categoriesForMethods!
definesClassVariable:!public!testing! !
definesInstanceVariable:!public!testing! !
definesVariable:!public!testing! !
directlyDefinesClassVariable:!public!testing! !
directlyDefinesInstanceVariable:!public!testing! !
directlyDefinesVariable:!public!testing! !
hierarchyDefinesVariable:!public!testing! !
!

!Refactory.Browser.AbstractClassVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractClassVariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Refactory.Browser.AbstractInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AbstractVariablesRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	#todo.	"Implement more informative display string"
	aPuttableStream nextPutAll: 'Abstract Variables of <1p>' << fromClass!

getOptionAbstractVariables
	| details instVars classVars accessesInstVars |
	details := String writeStream.
	instVars := instVarReaders union: instVarWriters.
	accessesInstVars := instVars isEmpty.
	accessesInstVars
		ifFalse: 
			[details
				nextPutAll: 'The following instance variables are directly accessed:';
				cr.
			self
				printNameList: instVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'instance variables'].
	classVars := classVarReaders union: classVarWriters.
	classVars isEmpty
		ifFalse: 
			[accessesInstVars
				ifTrue: 
					[details
						cr;
						cr].
			details
				nextPutAll: 'The following class variables are directly accessed:';
				cr.
			self
				printNameList: classVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'class variables'].
	details
		cr;
		cr;
		nextPutAll: 'Any existing accessor will be used if possible, so accessors will only be added for read or written variables that do not currently have them.'.
	^MessageBox new
		caption: self displayString;
		headline: 'Abstract variable references?';
		text: 'This method has direct variable references which will need to be converted to getter/setters in the extracted method<1?s:>.'
					<< {toClasses size > 1};
		customButtons: #(#(#yes '&Abstract Variables') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !
!Refactory.Browser.AbstractVariablesRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAbstractVariables!options!public! !
!

!Refactory.Browser.AddClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewClass.ico'! !
!Refactory.Browser.AddClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add class ';
		display: self className! !
!Refactory.Browser.AddClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Import ';
		display: import;
		nextPutAll: ' into ';
		display: class! !
!Refactory.Browser.AddImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewMethod.ico'! !
!Refactory.Browser.AddMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add method to ';
		nextPutAll: class unqualifiedName!

maxDetails
	^15! !
!Refactory.Browser.AddMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
maxDetails!constants!private! !
!

!Refactory.Browser.AddParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add parameter to ';
		print: oldSelector.
	model environment isSystem
		ifFalse: 
			[aPuttableStream
				nextPutAll: ' in ';
				display: model environment]! !
!Refactory.Browser.AddParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.BasicLintRule methodsFor!

failedClasses
	self result isClassEnvironment ifFalse: [^super failedClasses].
	^self result classes!

failedMethods
	| failedMethods |
	self result isClassEnvironment ifTrue: [^super failedMethods].
	failedMethods := Set new: 64.
	self result
		classesAndSelectorsDo: [:eachClass :eachSel | failedMethods add: (eachClass compiledMethodAt: eachSel)].
	^failedMethods!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := self class publishedAspectsOfInstances.
	self result isClassEnvironment
		ifTrue: [answer add: ((Aspect collection: #failedClasses)
						beReadOnly;
						yourself)]
		ifFalse: [answer add: ((Aspect collection: #failedMethods)
						beReadOnly;
						yourself)].
	self searchStrings notEmpty
		ifTrue: 
			[answer add: ((Aspect sequenceableCollection: #searchStrings)
						beReadOnly;
						yourself)].
	^answer!

searchStrings
	^result searchStrings! !
!Refactory.Browser.BasicLintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
publishedAspects!constants!development!public! !
searchStrings!accessing!private! !
!

!Refactory.Browser.BasicRenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.BasicRenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ChangeMethodNameRefactoring methodsFor!

getOptionRenameAllDefinitions: aCollection of: aSymbol
	| details count |
	aCollection size <= 1 ifTrue: [^true].
	details := String writeStream.
	details
		print: aSymbol;
		nextPutAll: ' is implemented in:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'All definitions must be renamed to preserve behaviour. You can re-initiate the rename and constrain the scope of the rename to package, hierarchy, class or even individual method level in the rename dialog if you wish, but this may not preserve behaviour.'.
	count := aCollection size.
	^MessageBox new
		caption: self displayString;
		headline: 'Rename <1p> methods defined in <2d> classes?' << {aSymbol. count};
		customButtons: #(#(#yes '&Rename All') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !
!Refactory.Browser.ChangeMethodNameRefactoring categoriesForMethods!
getOptionRenameAllDefinitions:of:!options!public! !
!

!Refactory.Browser.ChildrenToSiblingsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert ';
		display: parent;
		nextPutAll: ' to sibling'! !
!Refactory.Browser.ChildrenToSiblingsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ClassCategoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^ClassCategory icon! !
!Refactory.Browser.ClassCategoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassCommentChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassComment.ico'! !
!Refactory.Browser.ClassCommentChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassGuidChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^GUID icon! !
!Refactory.Browser.ClassGuidChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CompositeRefactoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Collection icon! !
!Refactory.Browser.CompositeRefactoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CreateAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Create accessors for'! !
!Refactory.Browser.CreateAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.ExpandImportsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Add import'.
	imports size = 1
		ifTrue: 
			[aPuttableStream space.
			imports asArray first displayOn: aPuttableStream]
		ifFalse: 
			[aPuttableStream nextPutAll: 's '.
			imports do: [:each | each displayOn: aPuttableStream] separatedBy: [aPuttableStream nextPutAll: ', ']].
	aPuttableStream nextPutAll: ' to '.
	toClasses size = 1
		ifTrue: [toClasses asArray first displayOn: aPuttableStream]
		ifFalse: 
			[toClasses do: [:each | each name displayOn: aPuttableStream]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionAddImports: aCollection
	| details |
	details := String writeStream.
	details nextPutAll: 'The following namespaces will need to be imported'.
	toClasses size == 1
		ifTrue: 
			[details
				nextPutAll: ' into ';
				nextPutAll: toClasses first unqualifiedName].
	details
		nextPut: $:;
		cr.
	self
		printNameList: aCollection asSortedCollection
		on: details
		limit: self maxDetails
		type: 'namespaces'.
	^MessageBox new
		caption: self displayString;
		text: 'This method contains references to shared variables from namespaces that may need to be imported into the target.';
		customButtons: #(#(#yes '&Add Imports') #(#no '&Cancel'));
		detailsText: details contents;
		confirm! !
!Refactory.Browser.ExpandImportsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAddImports:!options!public! !
!

!Refactory.Browser.ExtractMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract method from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionUseExistingMethod: aSymbol
	^MessageBox new
		caption: self displayString;
		headline: 'Use existing method <1p>?' << aSymbol;
		text: 'The existing method contains the same code as that you are extracting, and can be used safely instead of creating a new method.';
		customButtons: #(#(#yes '&Use Existing') #(#no '&Create New Method'));
		confirm! !
!Refactory.Browser.ExtractMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionUseExistingMethod:!options!public! !
!

!Refactory.Browser.ExtractMethodToComponentRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to component from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionVariableToMoveToOf: aClass in: aSelector
	^SmalltalkSystem current selectTargetVariableOf: aClass
		parseTree: (aClass parseTreeFor: aSelector)! !
!Refactory.Browser.ExtractMethodToComponentRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionVariableToMoveToOf:in:!public! !
!

!Refactory.Browser.ExtractToTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to temporary ';
		print: newVariableName! !
!Refactory.Browser.ExtractToTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineAllSendersRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline sends of ';
		print: selector;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.InlineAllSendersRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline message in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: sourceSelector!

getOptionImplementorToInline: anOrderedCollection
	^UI.ChoicePrompter
		choices: (anOrderedCollection asSortedCollection: [:a :b | a displayString <= b displayString])
		caption: 'Inline <1p> from…' << sourceMessage!

getOptionInlineOverridden: aSymbol of: aClass
	| details overrides fromClass |
	details := String writeStream.
	fromClass := self chosenInlineClass.
	details
		nextPutAll: '<1p> is overridden by the following subclasses of <2d>:'
					<< {aSymbol. fromClass unqualifiedName};
		cr.
	overrides := fromClass allSubclasses select: [:each | each directlyDefinesMethod: aSymbol].
	self
		printNameList: overrides
		on: details
		limit: self maxDetails
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Inline overridden method?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: '<1d>>><2p> is overridden in <3d> subclass<4?:es> of <5d>.<n><n>Inlining an overridden method may change behavior.'
					<< {aClass. aSymbol. overrides size. overrides size = 1. fromClass};
		detailsText: details contents;
		confirm!

getOptionInlineReordered: inlineRBMethod into: intoRBMethod
	^MessageBox new
		caption: self displayString;
		headline: 'Inline with statement reordering?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: 'To inline <1p> into <2p> it will be necessary to move some of the inlined statements before the original message send.'
					<< {inlineRBMethod. intoRBMethod};
		detailsText: 'This could change the order of execution, which can change the behavior. If it is safe to do so you can continue with the refactoring and then modify or undo the results as required. Alternatively cancel the refactoring and modify the call site so that the inlined message send is an individual statement rather than part of a larger statement, for example as an expression calculating a value to use as an argument to another message send.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm! !
!Refactory.Browser.InlineMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionImplementorToInline:!options!public! !
getOptionInlineOverridden:of:!preconditions!public! !
getOptionInlineReordered:into:!options!public! !
!

!Refactory.Browser.InlineParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline parameter ';
		print: argument;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.InlineParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline temp ';
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector
	"		print: oldName;"! !
!Refactory.Browser.InlineTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.LintRule methodsFor!

failedClasses
	^Set new!

failedMethods
	^Set new!

searchStrings
	^#()! !
!Refactory.Browser.LintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
searchStrings!accessing!private! !
!

!Refactory.Browser.LintRule class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!Refactory.Browser.LintRule class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MethodRefactoring methodsFor!

generateDefaultSelector: aRBMethodName
	| args mname |
	aRBMethodName selector isNil ifFalse: [^self].
	args := aRBMethodName arguments.
	mname := args isEmpty
				ifTrue: ['method']
				ifFalse: 
					[| stream |
					stream := String writeStream.
					aRBMethodName arguments do: 
							[:arg |
							stream
								nextPutAll: arg;
								nextPut: $:].
					stream contents].
	aRBMethodName selector: mname asSymbol!

getOptionAlreadyDefined: aClass selector: aSymbol
	| response |
	response := MessageBox new
				caption: self displayString;
				headline: 'Extract to existing selector?';
				text: ('<1p> is already defined in the <2d> hierarchy.' expandMacrosWith: aSymbol
							with: aClass unqualifiedName);
				customButtons: #(#(#yes '&Continue') #(#no 'Choose &Another') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: 'Extracting to an existing selector may change the behavior of the class hierarchy, for example by overriding an inherited method. You should only continue if you do not require a true behavior-preserving refactoring. Otherwise choose another selector.'
							<< aSymbol;
				expandLabel: 'Show help';
				collapseLabel: 'Hide help';
				iconStyle: #warning;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes!

getOptionExtractAssignment: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Extract final assignment?';
		text: 'The assignment to ''<1s>'' at the end of the selection can be extracted to the new method, or remain behind to receive the result of the call to that method.'
					<< aString;
		customButtons: #(#(#yes '&Extract') #(#no '&Don''t Extract'));
		defaultButton: 2;
		confirm!

getOptionInlineExpression: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Inline expression?';
		text: 'The following expression can be inlined or assigned to a temporary:<n><n><t><1s>?' << aString;
		customButtons: #(#(#yes '&Inline') #(#no '&Assign Temporary'));
		defaultButton: 2;
		detailsText: 'The expression shown is passed as one of the arguments to the method you are inlining. You can safely inline the expression if constant and/or side-effect free, or if it is only referred to once in the inlined method. If not, it should be assigned to a temporary to preserve existing behaviour. If unsure, choose ''Assign Temporary''. You can always inline the temporary later if you wish.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm!

getOptionNewMethodName: aRBMethodName classes: anArray
	| dialog |
	self generateDefaultSelector: aRBMethodName.
	dialog := MethodNameDialog createOn: aRBMethodName.
	dialog validater: 
			[:methodName |
			| sel |
			sel := methodName selectorSymbol.
			(anArray inject: methodName conditions
				into: [:conditions :each | conditions & (Refactory.Browser.RBCondition definesSelector: sel in: each) not])
					validate].
	^dialog showModal ifNotNil: [aRBMethodName]!

getOptionRemoveMethod: aSymbol referencedIn: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'Removing the method may not preserve behaviour. It is recommended that you first browse these references to verify that the method is safe to remove:';
		cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: '<1p> may not be safe to remove' << aSymbol;
				text: ('The selector <1p> is referenced from <2d> other methods.' expandMacrosWith: aSymbol
							with: aCollection size);
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no ifTrue: [self openBrowserOn: (self model environment referencesTo: aSymbol)].
	^false! !
!Refactory.Browser.MethodRefactoring categoriesForMethods!
generateDefaultSelector:!options!public! !
getOptionAlreadyDefined:selector:!options!public! !
getOptionExtractAssignment:!options!public! !
getOptionInlineExpression:!options!public! !
getOptionNewMethodName:classes:!options!public! !
getOptionRemoveMethod:referencedIn:!options!public! !
!

!Refactory.Browser.MoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Class icon! !
!Refactory.Browser.MoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector;
		nextPutAll: '  to ';
		print: variable!

getOptionSelfArgumentName
	| newName existing |
	existing := parseTree allDefinedVariables.
	newName := (Prompter
				createOn: String new
				prompt: 'Enter name for argument to refer to "self" in extracted method'
				caption: self displayString)
				validater: 
						[:name |
						(existing includes: name)
							ifTrue: [ValidationResult errorMessage: '<1d> is already in use as a local variable' << name]
							ifFalse: 
								[| result |
								result := ValidationResult new.
								moveToClasses allSatisfy: 
										[:each |
										| condition |
										condition := (Refactory.Browser.RBCondition isValidTemporaryVariableName: name for: each)
													& (Refactory.Browser.RBCondition definesInstanceVariable: name in: each) not.
										condition validate: result].
								result]];
				showHintWhenEmpty: false;
				showModal.
	newName isNil ifTrue: [^self refactoringAborted: 'Method not moved/extracted'].
	^newName!

getOptionVariableTypes: choicesCollection selected: suggestionsCollection
	^(ChoicePrompter
		create: 'Extensible multi-selection choice prompter'
		on: suggestionsCollection asOrderedCollection
		multipleChoices: ((choicesCollection union: suggestionsCollection)
				asSortedCollection: [:a :b | a name < b name])
		caption: 'Select class(es) of new method… ')
		newCaption: 'Add Other Class…';
		validater: 
				[:aString |
				| result |
				result := ValidationResult new.
				(self resolveClass: aString)
					ifNil: [result errorMessage: '<1s> is not a valid class name' << aString].
				result];
		newBlock: [:aString | self resolveClass: aString];
		showModal!

resolveClass: aString
	| binding |
	aString isEmpty ifTrue: [^nil].
	binding := aString asQualifiedReference bindingOrNil.
	^(binding notNil
		and: [binding isClassBinding and: [self model environment includesClass: binding value]])
			ifTrue: [self model classFor: binding value]! !
!Refactory.Browser.MoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionSelfArgumentName!public! !
getOptionVariableTypes:selected:!options!public! !
resolveClass:!helpers!private! !
!

!Refactory.Browser.MoveVariableDefinitionRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		display: 'variable';
		nextPutAll: ' to inner scope in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.MoveVariableDefinitionRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ProtectInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Protect'! !
!Refactory.Browser.ProtectInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownClassVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push down ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PushDownMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PushUpMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push up ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionCopyDownSuperclassMethod: aSelector
	^self
		confirm: 'Do you want to copy down the superclass method to the classes that don''t define <1p>?'
				<< aSelector!

getOptionPushUpRemoveDuplicates: aSymbol in: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following subclasses of ';
		nextPutAll: class superclass unqualifiedName;
		nextPutAll: ' will have a duplicate implementation:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	response := MessageBox new
				caption: self displayString;
				text: 'Pushing up <1p> from <2d> to <3d> will result in duplicate implementations in <4d> subclass<5?es:> of <3d>.'
							<< {aSymbol.
									class unqualifiedName.
									class superclass unqualifiedName.
									aCollection size.
									aCollection size > 1};
				headline: 'Remove duplicates of pushed up method?';
				customButtons: #(#(#yes '&Remove Duplicates') #(#no 'Don''t Remove'));
				defaultButton: 1;
				isCancellable: true;
				detailsText: details contents;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !
!Refactory.Browser.PushUpMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionCopyDownSuperclassMethod:!options!public! !
getOptionPushUpRemoveDuplicates:in:!options!public! !
!

!Refactory.Browser.RBAbstractClass class methodsFor!

icon
	^Class icon! !
!Refactory.Browser.RBAbstractClass class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBAbstractCondition methodsFor!

validate
	| result |
	result := UI.ValidationResult new.
	self validate: result.
	^result!

validate: aValidationResult
	"Update the <ValidationResult> argument with results from evaluating this condition, answering whether the condition is satisfied."

	^(aValidationResult value: self check) or: [aValidationResult errorMessage: self errorString]! !
!Refactory.Browser.RBAbstractCondition categoriesForMethods!
validate!public! !
validate:!helpers!public! !
!

!Refactory.Browser.RBAbstractCondition class methodsFor!

icon
	^##((TextTileIcon text: '?' fontName: 'Georgia')
		textcolor: Color darkBlue;
		yourself)! !
!Refactory.Browser.RBAbstractCondition class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBClass methodsFor!

icon
	^realClass ifNil: [super icon] ifNotNil: [realClass icon]! !
!Refactory.Browser.RBClass categoriesForMethods!
icon!accessing!public! !
!

!Refactory.Browser.RBMetaclass class methodsFor!

icon
	^Metaclass icon! !
!Refactory.Browser.RBMetaclass class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBMethod methodsFor!

owningPackage
	^compiledMethod isNil 
		ifTrue: [class owningPackage]
		ifFalse: [compiledMethod owningPackage]! !
!Refactory.Browser.RBMethod categoriesForMethods!
owningPackage!accessing!public! !
!

!Refactory.Browser.RBMethod class methodsFor!

icon
	^CompiledMethod icon! !
!Refactory.Browser.RBMethod class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBModel methodsFor!

browseChanges
	Tools.RewriteChangesBrowser showOn: self changes! !
!Refactory.Browser.RBModel categoriesForMethods!
browseChanges!helpers!public! !
!

!Refactory.Browser.RBModel class methodsFor!

icon
	^Smalltalk icon! !
!Refactory.Browser.RBModel class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBNamespaceClass class methodsFor!

icon
	^Namespace icon! !
!Refactory.Browser.RBNamespaceClass class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBRootNamespace class methodsFor!

icon
	^Root icon! !
!Refactory.Browser.RBRootNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBSmalltalkNamespace class methodsFor!

icon
	^Smalltalk icon! !
!Refactory.Browser.RBSmalltalkNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.Refactoring methodsFor!

chooseFrom: aCollection caption: aString
	"Dolphin specific choice prompt"

	^ChoicePrompter choices: aCollection asOrderedCollection caption: aString!

confirm: aString
	"Dolphin specific confirmation prompt"

	^MessageBox confirm: aString caption: self displayString!

maxDetails
	^30!

printNameList: aCollection on: aPuttableStream limit: maxInteger type: aString
	| count |
	count := aCollection size.
	aCollection
		from: 1
		to: (count min: maxInteger)
		do: 
			[:each |
			aPuttableStream
				cr;
				display: each].
	count > maxInteger
		ifTrue: 
			[aPuttableStream
				cr;
				nextPut: $…;
				cr;
				nextPutAll: 'And ';
				print: count - maxInteger;
				nextPutAll: ' further ';
				nextPutAll: aString;
				nextPut: $.]!

prompt: aString
	"Dolphin specific prompt for text input"

	^Prompter prompt: aString caption: self displayString! !
!Refactory.Browser.Refactoring categoriesForMethods!
chooseFrom:caption:!helpers!private! !
confirm:!helpers!public! !
maxDetails!constants!private! !
printNameList:on:limit:type:!helpers!private! !
prompt:!helpers!private! !
!

!Refactory.Browser.Refactoring class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Refactoring.ico'!

renameIcon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'InPlaceRename.ico'! !
!Refactory.Browser.Refactoring class categoriesForMethods!
icon!constants!public! !
renameIcon!constants!public! !
!

!Refactory.Browser.RefactoryClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Refactory.Browser.ClassDetails icon! !
!Refactory.Browser.RefactoryClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RefactoryMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^CompiledMethod icon! !
!Refactory.Browser.RefactoryMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassDelete.ico'! !
!Refactory.Browser.RemoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Remove '.
	classNames size == 1
		ifTrue: 
			[aPuttableStream
				nextPutAll: 'class ';
				display: classNames first]
		ifFalse: 
			[aPuttableStream nextPutAll: 'classes: '.
			classNames do: [:each | aPuttableStream display: each]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionRemoveClass: aRBClass referencedIn: aCollection
	| details response references |
	references := aCollection.
	details := String writeStream.
	details
		nextPutAll: 'Removing the class will leave ';
		nextPutAll: (references size = 1
					ifTrue: ['a dangling reference in this method']
					ifFalse: ['dangling references in these methods']);
		nextPutAll: ' and is potentially unsafe. It is recommended that you first browse these references and remove them before attempting to remove the class again:';
		cr.
	self
		printNameList: (references asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class?' << aRBClass;
				text: 'The class <1p> is referenced from <2d> method<3?:s>.'
							<< {aRBClass. references size. references size = 1};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self
				openBrowserOn: ((self model environment forMethods: (aCollection collect: [:each | each method]))
						label: 'References to class <1p>, or its name' << aRBClass;
						yourself)].
	^false! !
!Refactory.Browser.RemoveClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveClass:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring methodsFor!

getOptionRemoveVariable: aVariableBinding referencedIn: aCollection
	| args details response |
	args := {aVariableBinding environment.
				aVariableBinding key.
				aCollection size.
				aCollection size == 1}.
	details := String writeStream
				nextPutAll: 'Removing the class variable will leave <4?a dangling reference in this method:dangling references in these methods> and is potentially unsafe. It is recommended that you first browse <4?the reference:these references> and remove <4?it:them> before attempting to remove the variable again:'
							<< args;
				cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class variable?' << args;
				text: 'The class variable <1p>.<2s> is referenced from <3d> method<4?:s>.' << args;
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'References to <1p>.<2s>' << args;
						yourself)].
	^false! !
!Refactory.Browser.RemoveClassVariableRefactoring categoriesForMethods!
getOptionRemoveVariable:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove Import ';
		display: import;
		nextPutAll: ' from ';
		display: class! !
!Refactory.Browser.RemoveImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'MethodDelete.ico'! !
!Refactory.Browser.RemoveMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionRemoveDuplicatesWithSupersends: superMessages
	| details |
	details := String writeStream.
	details
		nextPutAll: 'The following methods are equivalent to their superclass implementations, but contain a supersend so removing them might modify behavior.';
		cr.
	self
		printNameList: (superMessages asArray
				collect: [:each | '<1s>>><2p>' << {class unqualifiedName. each}]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	^MessageBox new
		caption: self displayString;
		headline: 'Remove duplicate methods with supersends?';
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		defaultButton: 2;
		detailsText: details contents;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.RemoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveDuplicatesWithSupersends:!options!public! !
!

!Refactory.Browser.RemoveParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove parameter ';
		print: argument;
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.RemoveParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Rename accessors for'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameClassRefactoring methodsFor!

getOptionIgnoreSymbolicClassReferences: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following methods still reference the original unqualified class name symbol ';
		print: oldUnqualified;
		nextPut: $:;
		cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails // 2
		type: 'methods'.
	response := UI.MessageBox new
				caption: self displayString;
				headline: 'Class may have symbolic references.';
				text: 'The original class name ''<1s>'' may still be referenced symbolically in <2d> methods. If you proceed with the class rename these Symbols will not be renamed as it cannot be guaranteed that these are intended as references to the class being renamed.<n><n>It is recommended that you first browse all references to understand the use, and replace any real references to the class with literal BindingReferences.'
							<< {oldUnqualified. aCollection size};
				customButtons: #(#(#yes '&Rename Class') #(#no '&Browse Methods'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'Remaining references to class being renamed from <1p>' << oldUnqualified;
						yourself)].
	^false! !
!Refactory.Browser.RenameClassRefactoring categoriesForMethods!
getOptionIgnoreSymbolicClassReferences:!options!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName;
		nextPutAll: ' (and accessors) to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename ';
		print: oldSelector;
		nextPutAll: ' to ';
		print: newSelector! !
!Refactory.Browser.RenameMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameMethodRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameMethodRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename temp ';
		print: oldName;
		nextPutAll: ' to ';
		print: newName;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.RenameTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameTemporaryRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.SmalllintChecker class methodsFor!

newWithCachingContext
	^self new
		context: SmalllintCachingContext new;
		yourself! !
!Refactory.Browser.SmalllintChecker class categoriesForMethods!
newWithCachingContext!instance creation!public! !
!

!Refactory.Browser.TemporaryToInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert temp ';
		print: temporaryVariableName;
		nextPutAll: ' to inst var of ';
		nextPutAll: class unqualifiedName!

getOptionConvertReadBeforeWritten: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Convert read-before-written temporary?';
		text: '<1p> is read before it is written and if converted to an instance variable it may not be initialized before use.' << aString;
		customButtons: #(#(#yes '&Convert') #(#no '&Don''t Convert'));
		defaultButton: 2;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.TemporaryToInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionConvertReadBeforeWritten:!options!public! !
!

!Refactory.Browser.TransformationRule class methodsFor!

bitLogicElimination
	"Inlining of methods may create redundant bit logic operations where the operation is a no-op or has a constant outcome. This transformation can eliminate some cases."


	^self
		rewrite: #(
			#('0 bitOr: ``@arg' 	"->" 	'``@arg')
			#('0 | ``@arg' 	"->" 	'``@arg')
			#('``@arg bitOr: 0' 	"->" 	'``@arg')
			#('``@arg | 0 ' 	"->" 	'``@arg')

			#('0 bitAnd: ``@arg' 	"->" 	'0')
			#('0 & ``@arg' 	"->" 	'0')
			#('``@arg bitAnd: 0' 	"->" 	'0')
			#('``@arg & 0 ' 	"->" 	'0')
		)			
		methods: false
		name: 'Eliminate redundant bit operations'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

ifElimination
	"Inlining of methods may create unecessary ifTrue:[ifFalse:] statements where the condition
	is a constant boolean value. This transformation is useful for eliminating these."

	^self 
		rewrite: #(#(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After'))
		methods: false
		name: 'Eliminate unnecessary ifTrue:[ifFalse:] conditions'!

renameArgument: beforeString to: afterString
	^Refactory.Browser.TransformationRule new
		name: ('Rename argument <1p> to <2p>' expandMacrosWith: beforeString with: afterString);
		rewriteUsing: (Refactory.Browser.ParseTreeRewriter new
					replaceArgument: beforeString with: afterString;
					replace: beforeString with: afterString;
					yourself);
		yourself! !
!Refactory.Browser.TransformationRule class categoriesForMethods!
bitLogicElimination!public!transformations! !
icon!constants!public! !
ifElimination!public!transformations! !
renameArgument:to:!public! !
!

!Refactory.Browser.VariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName!

displayPrefix
	^self class displayPrefix!

getOptionPullUpNonSharedInstVar: aString
	| with without details max |
	with := OrderedCollection new.
	without := OrderedCollection new.
	class subclasses do: 
			[:each |
			((each directlyDefinesInstanceVariable: variableName) ifTrue: [with] ifFalse: [without]) add: each].
	details := String writeStream.
	details
		print: aString;
		nextPutAll: ' is defined in:';
		cr.
	max := self maxDetails // 2.
	self
		printNameList: with
		on: details
		limit: max
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'But is not defined in:';
		cr.
	self
		printNameList: without
		on: details
		limit: max
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Pull up non-shared instance variable?';
		text: 'Not all subclasses of <1d> have an instance variable named <2p>.<n><n>Do you want pull up this variable anyway?'
					<< {class. aString};
		customButtons: #(#(#yes '&Pull Up') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		isCancellable: true;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.VariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
displayPrefix!displaying!public! !
getOptionPullUpNonSharedInstVar:!options!public! !
!

!Refactory.Browser.VariableRefactoring class methodsFor!

displayPrefix
	^self subclassResponsibility! !
!Refactory.Browser.VariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Tools.ClassBrowserAbstract methodsFor!

abstractInstanceVariables
	"Private - Invoke the 'Abstract Instance Variable' refactoring on the currently selected variables."

	self model abstractInstanceVariables: self variables within: BrowserEnvironment new!

methodRefactoringTool
	^methodBrowserPresenter refactoringTool!

methodsToOverride
	| methods class selectedClass |
	methods := self selectedOverridableMethods.
	methods notEmpty ifTrue: [^methods].
	methods := IdentityDictionary new.
	selectedClass := self actualClass.
	class := selectedClass superclass.
	[class isNil] whileFalse: 
			[class methodDictionary keysAndValuesDo: 
					[:eachSelector :eachMethod |
					(eachSelector first ~~ $_ and: [(eachSelector beginsWith: 'basic') not])
						ifTrue: [methods at: eachSelector put: eachMethod]].
			class := class superclass].
	^(ChoicePrompter multipleChoices: methods keys asSortedCollection
		caption: 'Choose Methods to Override…')
			ifNotNil: [:selectors | selectors collect: [:each | selectedClass lookupMethod: each]]!

overrideMethods
	| stream class changes name methods |
	class := self actualClass.
	stream := String writeStream.
	changes := CompositeRefactoryChange new.
	methods := self methodsToOverride.
	(methods isNil or: [methods isEmpty]) ifTrue: [^self].
	methods do: 
			[:each |
			| keywordsAndArgs |
			stream reset.
			keywordsAndArgs := self systemModel keywordsAndArgsOfMethod: each.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			stream
				crtab;
				nextPutAll: '^super';
				space.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			changes addChange: (AddMethodChange
						compile: stream contents
						in: class
						environment: each environment
						categories: each categories
						package: each owningPackageIfLoose)].
	name := String writeStream.
	name nextPutAll: 'Override '.
	methods size > 1
		ifTrue: 
			[name
				print: methods size;
				nextPutAll: ' methods']
		ifFalse: [name print: methods first].
	changes name: name contents.
	self systemModel changeManager performChange: changes.
	self selectedMethods: (methodBrowserPresenter methodsPresenter list
				intersection: ((methods collect: [:each | each selector]) asSet
						collect: [:each | class compiledMethodAt: each ifAbsent: nil]))!

protectInstanceVariables
	"Private - Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables."

	self model protectInstanceVariables: self variables!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the currently selected variables."

	self model pushDownInstanceVariables: self variables!

pushDownMethods
	<acceleratorKey: 'Shift+Ctrl+7'>
	self pushMethods: false!

pushMethods: aBoolean
	| change isShift methods targetClass |
	isShift := Keyboard default isShiftDown.
	methods := self selectedMethods.
	"It is assumed that the methods are all of the same class (the 'push method' commands are disabled if not)"
	targetClass := methods first methodClass.
	targetClass := aBoolean ifTrue: [targetClass superclass] ifFalse: [targetClass subclasses first].
	change := self methodRefactoringTool pushMethods: aBoolean.
	(change isNil or: [isShift not]) ifTrue: [^self].
	methods := (methods asSet
				collect: [:each | targetClass compiledMethodAt: each selector ifAbsent: nil]) asArray.
	self actualClass: methods first methodClass ifAbsent: [^self].
	self selectedMethods: methods!

pushUpMethods
	<acceleratorKey: 'Shift+Ctrl+6'>
	self pushMethods: true!

queryRefactoringCommand: aCommandQuery
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#protectInstanceVariables #abstractInstanceVariables #removeInstanceVariables)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: self variables notEmpty.
				^true].
	#pushDownInstanceVariables == selector
		ifTrue: 
			[| class |
			aCommandQuery isEnabled: ((class := self actualClass) notNil
						and: [class subclasses notEmpty and: [self variables notEmpty]]).
			^true].
	#pushDownMethods == selector
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushDownMethods
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#pushUpMethods == selector
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushUpMethods
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#overrideMethods == selector
		ifTrue: 
			[| class methods |
			methods := self selectedOverridableMethods.
			class := self actualClass.
			aCommandQuery
				isEnabled: class superclass notNil;
				text: (aCommandQuery commandDescription menuText
							expandMacrosWithArguments: {methods isEmpty
										ifTrue: ['…']
										ifFalse: [methods size == 1 ifTrue: [methods first] ifFalse: ['Methods']]}
							locale: Locale smalltalk).
			^true].
	^false!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the currently selected variables."

	self model removeInstanceVariables: self variables within: self searchEnvironment!

renameMethod
	(self chooseMethodForRefactoring: 'Rename Method…') 
		ifNotNil: [:method | self methodRefactoringTool renameMethod: method]!

selectedOverridableMethods
	| class |
	class := self actualClass.
	^self selectedMethods reject: [:each | each methodClass == class]! !
!Tools.ClassBrowserAbstract categoriesForMethods!
abstractInstanceVariables!commands!private!refactoring! !
methodRefactoringTool!commands!private!refactoring! !
methodsToOverride!helpers!private! !
overrideMethods!commands!private!refactoring! !
protectInstanceVariables!commands!private!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
pushDownMethods!commands!public!refactoring! !
pushMethods:!commands!private!refactoring! !
pushUpMethods!commands!public!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeInstanceVariables!public!refactoring! !
renameMethod!accessing!private! !
selectedOverridableMethods!accessing!private! !
!

!Tools.ClassBrowserPlugin methodsFor!

systemModel
	"Private - Answer the development system model."

	^SmalltalkSystem current! !
!Tools.ClassBrowserPlugin categoriesForMethods!
systemModel!commands!private! !
!

!Tools.ClassSelector methodsFor!

abstractClassVariables
	"Invoke the 'Abstract Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Abstract Class Variables…')
		ifNotNil: [:varNames | self systemModel abstractClassVariables: varNames within: BrowserEnvironment new]!

abstractInstanceVariables
	"Invoke the 'Abstract Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Abstract Instance Variables…')
		ifNotNil: [:varNames | self systemModel abstractInstanceVariables: varNames within: BrowserEnvironment new]!

addClassVariable
	"Private - Invoke the 'Add Class Variable' refactoring to add a class variable to the
	currently selected class."

	self systemModel
		addClassVariableTo: self selection!

addImport
	self systemModel addImportToClasses: self selections!

addInstanceVariable
	"Private - Invoke the 'Add Instance Variable' refactoring to add an instance variable to the
	currently selected class."

	self systemModel
		addInstanceVariableTo: self actualClass!

buildInstVarMenu: aMenu selectors: selectors
	"Private - Build a dynamic pull-out menu which lists all of a class' existing inst. var. 
	names so that one or other can be removed, renamed, etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: selectors!

buildPullUpVariablesMenu: aMenu
	| class items |
	aMenu clear.
	class := self actualClass.
	(ClassBuilder isFixedLayout: class)
		ifFalse: 
			[self
				populatePullUpVariableMenu: aMenu
				forClass: class
				command: #pullUpInstanceVariable:into:
				classVariables: false
				ifTooMany: #pullUpInstanceVariables.
			aMenu notEmpty ifTrue: [aMenu addSeparator]].
	self
		populatePullUpVariableMenu: aMenu
		forClass: class instanceClass
		command: #pullUpClassVariable:into:
		classVariables: true
		ifTooMany: #pullUpClassVariables.
	items := aMenu items.
	(items notEmpty and: [items last isDivider]) ifTrue: [aMenu removeItemAt: items size]!

buildVariablesMenu: aMenu instVarSelectors: instVarSelectors classVarSelectors: classVarSelectors 
	"Private - Build a dynamic pull-out menu which lists all of a class' existing 
	instance and class variable names so that one or other can be removed, renamed, 
	etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: instVarSelectors.
	(aMenu notEmpty and: [self selection classPool notEmpty]) ifTrue: [aMenu addSeparator].
	self populateClassVarMenu: aMenu selectors: classVarSelectors!

changeClassNamespace
	self systemModel changeNamespaceOfClasses: self selections!

cloneClass: aClass under: superClass changes: aCompositeRefactoryChange
	| namespace newName |
	namespace := RBModel new
				changes: aCompositeRefactoryChange;
				yourself.
	newName := aClass asQualifiedReference.
	
	[newName := BindingReference path: (newName path allButLast copyWith: 'CopyOf' , newName path last).
	newName isDefined]
			whileTrue.
	(CopyClassRefactoring
		model: namespace
		clone: aClass
		as: newName pathString
		superclass: superClass) primitiveExecute!

convertToSibling
	"Invoke the 'Convert to Sibling' refactoring (inserts a new class as the common superclass of the selected
	class and its current subclasses, copying common methods to the new superclass and adding 
	#subclassResponsibility methods as necessary)."

	self systemModel
		convertToSibling: self selection!

createClassVariableAccessors
	"Prompt to generate compiled 'get' and 'set' accessor methods for the immediate
	class variables of the selected class."

	self createVariableAccessors: true!

populateClassVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self selection.
	varNames := class classBindingNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Class Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populateInstVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self actualClass.
	varNames := class instanceVariableNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Instance Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populatePullUpVariableMenu: aMenu forClass: aClass command: commandSymbol classVariables: aBoolean ifTooMany: tooManyCommand
	| pairs |
	pairs := self
				pullUpVariableNamePairs: aBoolean
				for: aClass
				maximum: self maximumVariableMenuEntries.
	pairs isNil
		ifTrue: 
			[aMenu addCommand: tooManyCommand
				description: (aBoolean ifTrue: ['&Class Variable…'] ifFalse: ['&Instance Variable…'])]
		ifFalse: 
			[(pairs
				asSortedArray: [:p1 :p2 | p1 key == p2 key ifTrue: [p1 value < p2 value] ifFalse: [p1 key name < p2 key name]])
					do: 
						[:each |
						| msg varName |
						varName := each value.
						msg := MessageSend
									receiver: self systemModel
									selector: commandSymbol
									arguments: {varName. aClass}.
						aMenu addCommand: msg description: each key name , '.' , varName]]!

populateRefactoringMenu: aMenu 
	"Private - If the <Menu> argument is dynamic refactoring menu, then populate it with appropriate
	choices based on the currently selected class."

	| menuName |
	menuName := aMenu name.
	menuName == #pushDownInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#pushDownInstanceVariable:in: #pushDownInstanceVariables)].
	menuName == #createInstanceVariableAccessors 
		ifTrue: 
			[^self buildInstVarMenu: aMenu
				selectors: #(#createInstanceVariableAccessors:in: #createInstanceVariableAccessors)].
	menuName == #abstractInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#abstractInstanceVariable:in: #abstractInstanceVariables)].
	(menuName == #protectInstanceVariables or: [menuName == #protectVariables]) 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#protectInstanceVariable:in: #protectInstanceVariables)].
	"Generic menus that contain both class and inst vars"
	menuName == #removeVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#removeInstanceVariable:from:within: #removeInstanceVariables)
				classVarSelectors: #(#removeClassVariable:from:within: #removeClassVariables)].
	menuName == #renameVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#renameInstanceVariable:in:within: #renameInstanceVariable)
				classVarSelectors: #(#renameClassVariable:in:within: #renameClassVariable)].
	menuName == #pushDownVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#pushDownInstanceVariable:in:within: #pushDownInstanceVariables)
				classVarSelectors: #(#pushDownClassVariable:in:within: #pushDownClassVariables)].
	menuName == #pullUpVariables ifTrue: [^self buildPullUpVariablesMenu: aMenu].
	menuName == #createVariableAccessors 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#createInstanceVariableAccessors:in:within: #createInstanceVariableAccessors)
				classVarSelectors: #(#createClassVariableAccessors:in:within: #createClassVariableAccessors)].
	menuName == #abstractVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#abstractInstanceVariable:in:within: #abstractInstanceVariables)
				classVarSelectors: #(#abstractClassVariable:in:within: #abstractClassVariables)]!

protectInstanceVariables
	"Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Protect Instance Variables…') 
		ifNotNil: [:varNames | self systemModel protectInstanceVariables: varNames]!

pullUpClassVariables
	"Invoke the 'Pull Up Class Variable' refactoring on the users choice of subclass' class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self selection.
	pairs := self
				pullUpVariableNamePairs: true
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Class Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpClassVariable: each value into: class]]!

pullUpInstanceVariables
	"Invoke the 'Pull Up Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self actualClass.
	pairs := self
				pullUpVariableNamePairs: false
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Instance Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpInstanceVariable: each value into: class]]!

pullUpVariableNamePairs: aBoolean for: class maximum: anInteger
	| pairs varNames |
	varNames := Set new.
	pairs := OrderedCollection new.
	class allSubclassesDo: 
			[:subclass |
			(aBoolean ifTrue: [subclass classBindingNames] ifFalse: [subclass instanceVariableNames]) do: 
					[:each |
					(varNames includes: each)
						ifFalse: 
							[varNames add: each.
							varNames size > anInteger ifTrue: [^nil].
							pairs add: subclass -> each]]].
	^pairs!

pushDownClassVariables
	"Invoke the 'Push Down Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Push Down Class Variables…') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Push Down Instance Variables…') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

queryRefactoringCommand: aCommandQuery
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery> argument."

	| selector class |
	selector := aCommandQuery commandSymbol.
	class := self actualClass.
	(#(#classRefactoringsMenu #addClassVariable) identityIncludes: selector)
		ifTrue: 
			[aCommandQuery isEnabled: class notNil.
			^true].
	#addInstanceVariable == selector
		ifTrue: 
			[| prefix |
			prefix := (class notNil and: [class isMeta]) ifTrue: ['Class '] ifFalse: [''].
			aCommandQuery
				text: (aCommandQuery commandDescription menuText expandMacrosWithArguments: {prefix}
							locale: Locale smalltalk);
				isEnabled: (class notNil and: [class isPointers]).
			^true].
	(#(#removeInstanceVariables #protectInstanceVariables #abstractInstanceVariables #renameInstanceVariable)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instanceVariableNames notEmpty]).
				^true].
	#pushDownInstanceVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: [class subclasses notEmpty and: [class instanceVariableNames notEmpty]]).
			^true].
	#pushDownVariables == selector
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil
						and: [class subclasses notEmpty and: [class instanceVariableNames notEmpty or: [class classPool notEmpty]]]).
			^true].
	#pullUpInstanceVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: [class allSubclasses anySatisfy: [:each | each instanceVariableNames notEmpty]]).
			^true].
	#pullUpClassVariables == selector
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil
						and: [class instanceClass allSubclasses anySatisfy: [:each | each classBindingNames notEmpty]]).
			^true].
	(#(#renameClassVariable #removeClassVariables #pushDownClassVariables #createClassVariableAccessors #abstractClassVariables)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instanceClass classBindingNames notEmpty]).
				^true].
	(#(#renameVariables #removeVariables #pushDownVariables #protectVariables #abstractVariables #createVariableAccessors)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil
							and: [class instanceVariableNames notEmpty or: [class instanceClass classBindingNames notEmpty]]).
				^true].
	#pushDownVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: 
							[class subclasses notEmpty
								and: [class instanceVariableNames notEmpty or: [class instanceClass classBindingNames notEmpty]]]).
			^true].
	#pullUpVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: 
							[| isFixed |
							isFixed := ClassBuilder isFixedLayout: class.
							class allSubclasses anySatisfy: 
									[:each |
									(isFixed not and: [each instanceVariableNames notEmpty]) or: [each instanceClass classBindingNames notEmpty]]]).
			^true].

	"Not a recognised refactoring command"
	^false!

removeClassVariables
	"Invoke the 'Remove Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Remove Class Variables…')
		ifNotNil: [:pairs | self systemModel removeStaticVariables: pairs within: self searchEnvironment]!

removeDuplicateMethods
	| class |
	class := self actualClass.
	(self systemModel removeMethodsDuplicatedInSuperclassOf: class)
		ifFalse: 
			[MessageBox new
				iconStyle: #notify;
				uniqueId: [self] method;
				isSuppressible: true;
				headline: '<1p> does not duplicate any of its superclass'' methods' << class;
				open]!

removeImport
	self systemModel removeImportFromClasses: self selections!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Remove Instance Variables…') 
		ifNotNil: [:varNames | self systemModel removeInstanceVariables: varNames within: self searchEnvironment]! !
!Tools.ClassSelector categoriesForMethods!
abstractClassVariables!commands!public!refactoring! !
abstractInstanceVariables!commands!public!refactoring! !
addClassVariable!commands!private!refactoring! !
addImport!commands!public!refactoring! !
addInstanceVariable!commands!private!refactoring! !
buildInstVarMenu:selectors:!menus!private!refactoring! !
buildPullUpVariablesMenu:!menus!private!refactoring! !
buildVariablesMenu:instVarSelectors:classVarSelectors:!menus!private!refactoring! !
changeClassNamespace!commands!public!refactoring! !
cloneClass:under:changes:!private! !
convertToSibling!commands!public!refactoring! !
createClassVariableAccessors!commands!public!refactoring! !
populateClassVarMenu:selectors:!menus!private!refactoring! !
populateInstVarMenu:selectors:!menus!private!refactoring! !
populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:!menus!private!refactoring! !
populateRefactoringMenu:!menus!private!refactoring! !
protectInstanceVariables!commands!public!refactoring! !
pullUpClassVariables!commands!public!refactoring! !
pullUpInstanceVariables!commands!public!refactoring! !
pullUpVariableNamePairs:for:maximum:!menus!private!refactoring! !
pushDownClassVariables!commands!public!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
queryRefactoringCommand:!commands!private! !
removeClassVariables!commands!public!refactoring! !
removeDuplicateMethods!commands!private!refactoring! !
removeImport!commands!public!refactoring! !
removeInstanceVariables!commands!public!refactoring! !
!

!Tools.Debugger methodsFor!

canMoveMethods
	#todo.	"Not currently supported in the debugger because it rewrites the caller, which complicates the unwind"
	^false!

hasRefactorableMethodSelected
	^self isRunning not and: 
			[| method |
			method := self selectedMethod.
			method notNil and: [method isUnbound not and: [self parseTree notNil]]]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	aMonadicValuable value: self selectedMethod.
	self selectedMethod isUnbound ifTrue: [self restartMethod]!

performMethodRenameRefactoring: aMonadicValuable 
	| method home sender refactoring |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := aMonadicValuable value: method.
	refactoring isNil ifTrue: [^self].
	"Since the method of the selected frame has been renamed, the sending frame's method will
	have been rewritten, therefore we need to restart the sender frame."
	home := self findHomeFrame: self frame.
	home isNil ifTrue: [^self].
	sender := home sender.
	(sender notNil and: [sender isRestartable]) ifTrue: [self restartMethodFrame: sender]! !
!Tools.Debugger categoriesForMethods!
canMoveMethods!commands!private!refactoring! !
hasRefactorableMethodSelected!public!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
!

!Tools.MethodBrowser methodsFor!

canMoveMethods
	^self hasRefactorableMethodSelected!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected and: [self parseTree notNil]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethod!

performMethodRenameRefactoring: aMonadicValuable
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	| refactoring method |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := sourcePresenter executeRefactoring: aMonadicValuable with: method.
	refactoring isNil ifTrue: [^self].
	method := (method ifNil: [self parseContext methodClass] ifNotNil: [method methodClass])
				compiledMethodAt: refactoring newSelector
				ifAbsent: nil.
	(method notNil and: [self filter value: method]) ifTrue: [self selectMethod: method]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !
!Tools.MethodBrowser categoriesForMethods!
canMoveMethods!helpers!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!helpers!private!refactoring! !
!

!Tools.MethodWorkspace methodsFor!

canRefactor
	^self isEditable and: 
			[self isModified not and: 
					[self systemModel canRefactor 
						and: [parentPresenter notNil and: [parentPresenter hasRefactorableMethodSelected]]]]!

executeRefactoring: aMonadicValuable
	^aMonadicValuable on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

executeRefactoring: aMonadicValuable with: anObject
	^[aMonadicValuable value: anObject]
		on: OperationAborted
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			nil]
		on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

fontOfStyle: style 
	| font |
	font := style fontName ifNil: [view actualFont copy] ifNotNil: [:face | Font name: face].
	style restyleFont: font.
	^font!

performCodeRefactoring: refactoringOperation 
	self 
		performMethodRefactoring: [:method | refactoringOperation value: method value: self selectedNode]!

performMethodRefactoring: aMonadicValuable 
	^parentPresenter performMethodRefactoring: aMonadicValuable!

performMethodRenameRefactoring: aBlockClosure 
	^parentPresenter performMethodRenameRefactoring: aBlockClosure!

renameVariable: aStVariableNode operation: operationBlock validationBlock: validationBlock
	| name range style editor font zoom newName |
	range := aStVariableNode sourceInterval.
	name := self plainTextRange: range.
	self assert: [aStVariableNode name = name].
	editor := InplaceTextEditor createOn: name asValue.
	editor validater: 
			[:candidateName |
			"If the name is unchanged, treat as valid and ignore later"
			candidateName = name
				ifTrue: [ValidationResult new]
				ifFalse: 
					[| result |
					result := validationBlock value: candidateName.
					result hint ifNotNil: [:ex | self errorModel value: ex].
					result]].
	editor textRectangle: (view boundingRectangleOfTextRange: range).
	"Set the same font as the existing text so there is no visible 'jump' - we need to account for any zooming too"
	style := view styleAt: range start.
	font := self fontOfStyle: style.
	zoom := view zoomLevel.
	zoom = 0
		ifFalse: 
			[| points |
			points := font pointSize.
			font := font copy.
			font pointSize: points + zoom].
	editor font: font.
	newName := view hideCaretWhile: [editor showModal].
	self errorModel value: nil.
	(newName isNil or: [newName = name])
		ifFalse: [self performMethodRefactoring: [:method | operationBlock value: newName]]! !
!Tools.MethodWorkspace categoriesForMethods!
canRefactor!public!refactoring!testing! !
executeRefactoring:!helpers!private!refactoring! !
executeRefactoring:with:!helpers!private!refactoring! !
fontOfStyle:!operations!private!refactoring! !
performCodeRefactoring:!helpers!private!refactoring! !
performMethodRefactoring:!helpers!private!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
renameVariable:operation:validationBlock:!operations!private!refactoring! !
!

!Tools.PackageBrowserShell methodsFor!

addParameter
	"Private - Command to invoke the Add Parameter to Method refactoring, prompting the user for 
	the selector of the method to which the parameter is added, and constrained to operate
	only within the selected packages."

	(self chooseMethodForRefactoring: 'Add Parameter in Package(s)…') 
		ifNotNil: [:method | self addParameterTo: method]
!

addParameterTo: aCompiledMethod
	self model addParameterToMethod: aCompiledMethod inPackages: self packages!

addParameterToMethod
	"Private - 'Loose Methods' card context menu command to invoke the 
	'Add Parameter to Method refactoring' against a selected loose method, 
	constrained within the selected packages."

	self addParameterTo: self selectedMethod!

changeClassNamespace
	self systemModel changeNamespaceOfClasses: self selectedClasses!

chooseMethodsForRefactoring: aString
	| selector methods definitions searchEnv |
	searchEnv := self searchEnvironment.
	methods := self selectedMethods.
	methods isEmpty ifFalse: [^searchEnv forMethods: methods].
	selector := self model chooseSelectorInEnvironment: searchEnv caption: aString.
	selector isNil ifTrue: [^searchEnv forMethods: #()].
	definitions := searchEnv definitionsOf: selector.
	definitions isEmpty
		ifTrue: 
			[MessageBox
				errorMsg: ('There are no definitions of <1p> in the selected package(s).' expandMacrosWith: selector)].
	^definitions!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected!

onClass: aClass renameTo: aString accept: booleanValue
	"Private - The user has initiated a rename of the class, aClass, by editing the label in the class
	tree. Ask the user to confirm the action, and if so queue a deferred action to perform the
	actual rename."

	"Implementation Notes: We don't set the booleanValue holder to true, because the rename may not work."

	| prompter |
	(aString isEmpty or: [aClass fullName = aString])
		ifTrue: 
			[booleanValue value: false.
			^self].
	prompter := self systemModel confirmRenameClass: aClass to: aString.
	prompter confirm ifFalse: [^self].
	"Queue deferred action as we can't delete the old item now while still in use (causes GPF in TreeView)"
	
	[self
		onRenameClass: aClass
		to: aString
		showChanges: prompter isChecked]
			postToMessageQueue!

onRenameClass: aClass to: aString showChanges: aBoolean
	"Private - The class, aClass, has been renamed by the user to, text, by editing the label
	in the classes presenter and subsequently confirmed. Ask the receiver's
	model to actually rename the class, converting any exception raised to a
	friendlier message box."

	
	[Cursor wait showWhile: 
			[self systemModel
				renameClass: aClass
				to: aString
				showChanges: aBoolean]]
			on: Refactoring abortSignal
			do: 
				[:ex |
				"Cancelled by user"
				self statusModel value: ex]
			on: Error
			do: [:e | e okCancel]!

parseTree
	^self selectedMethod ifNotNil: [:method | Parser parseExistingMethodNoError: method]!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	^aMonadicValuable value: self selectedMethod!

performMethodsRefactoring: aMonadicValuable name: aString
	| methods |
	methods := self chooseMethodsForRefactoring: '<1s> from Package(s)…' << aString.
	methods isEmpty ifTrue: [^nil].
	^[aMonadicValuable value: methods allMethods] on: Notification
		do: 
			[:ex |
			statusModel value: ex.
			ex resume]!

promptForMethodName: aCompiledMethod caption: aString allowExisting: aBoolean
	| methodName |
	methodName := ScopedMethodName fromMethod: aCompiledMethod.
	methodName packages: self packages.
	^self systemModel
		promptForMethodName: methodName
		caption: aString
		allowExisting: aBoolean!

queryRefactoringCommand: aCommandQuery
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#classRefactoringsMenu #methodRefactoringsMenu #renameMethod #addParameter #removeParameter)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: self hasPackages.
				^true].
	(#(#renameClass #changeClassNamespace #addImport) identityIncludes: selector)
		ifTrue: 
			[aCommandQuery isEnabled: self selectedClasses notEmpty.
			^true].
	(#(#removeMethods) identityIncludes: selector)
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethods notEmpty]).
			^true].
	(#(#addParameterToMethod) identityIncludes: selector)
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethod notNil]).
			^true].
	(#(#removeParameterMenu) identityIncludes: selector)
		ifTrue: 
			[| method |
			method := self selectedMethod.
			aCommandQuery isEnabled: (self hasPackages and: [method notNil and: [method argumentCount > 0]]).
			^true].
	"Not a refactoring command"
	^false!

removeMethod
	"Private - Prompt the user for a selector and invoke the 'Safe Remove Method' refactoring to 
	remove the specified methods from the system if defined but not referenced from within 
	any of the selected packages ((i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	"Implemementation Note: This command implementation is used only if there are no 
	methods selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	| methods |
	methods := self chooseMethodsForRefactoring: 'Safe Remove Methods from Package(s)…'.
	methods isEmpty
		ifFalse: [self model basicRemoveMethodsIn: methods within: self selectionEnvironment]!

removeMethods
	"Private - 'Loose Methods' card context menu command to invoke the 'Safe Remove Method' 
	refactoring. Removes the selected methods from the system if not referenced from within any 
	of the selected packages (i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	(MessageBox new
		headline: 'Remove unreferenced loose methods?';
		defaultButton: 2;
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		isCancellable: true;
		confirm: 'The selected methods will be removed if unreferenced from the selected packages. This may not preserve behaviour if the methods are referenced from other packages.')
			ifTrue: [self model basicRemoveMethods: self selectedMethods within: self selectionEnvironment]!

removeParameter
	"Private - Command to invoke the Remove Parameter to Method refactoring, but constrained to operate
	only within the selected packages."

	| method ast arg |
	method := self chooseMethodForRefactoring: 'Remove Parameter in Package(s)…'.
	method isNil ifTrue: [^self].
	ast := method parseTreeNoError.
	ast isNil ifTrue: [^self].
	arg := ChoicePrompter choices: ast argumentNames
				caption: 'Remove Parameter from <1p> in Package(s)…' << method selector.
	arg notNil ifTrue: [methodRefactoringTool removeParameter: arg from: method]!

renameLooseMethod
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method' refactoring against the selected loose method, but configured to rename 
	only within selected packages."

	methodRefactoringTool renameMethod!

renameLooseMethodReferences
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method References' refactoring against the selected loose method, but configured to rename 
	references only within selected packages."

	self renameMethodReferences: self selectedMethod!

renameMethod
	"Private - Initiate a 'Rename' method refactoring against the selected method,
	but configured to rename only within the selected packages."

	"Implemementation Note: This command implementation is used if there is not exactly one
	method selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	(self chooseMethodForRefactoring: 'Rename Method in Package(s)…') 
		ifNotNil: [:method | methodRefactoringTool renameMethod: method]!

renameMethodReferences: aCompiledMethod
	| methodName |
	methodName := self
				promptForMethodName: aCompiledMethod
				caption: 'Rename References to <1p> in Package(s)…' << aCompiledMethod selector
				allowExisting: true.
	methodName notNil ifTrue: [self model renameMethodReferences: aCompiledMethod to: methodName]! !
!Tools.PackageBrowserShell categoriesForMethods!
addParameter!commands!private!refactoring! !
addParameterTo:!private!refactoring! !
addParameterToMethod!commands!public!refactoring! !
changeClassNamespace!commands!public!refactoring! !
chooseMethodsForRefactoring:!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
onClass:renameTo:accept:!event handling!private! !
onRenameClass:to:showChanges:!event handling!private! !
parseTree!commands!private! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!private! !
promptForMethodName:caption:allowExisting:!helpers!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeMethod!commands!public!refactoring! !
removeMethods!commands!public!refactoring! !
removeParameter!commands!private!refactoring! !
renameLooseMethod!commands!private!refactoring! !
renameLooseMethodReferences!commands!private!refactoring! !
renameMethod!commands!public!refactoring! !
renameMethodReferences:!operations!private!refactoring! !
!

!Tools.PackageSelector methodsFor!

moveAllTempsToInnerScope
	(MessageBox new
		headline: 'Move All Temps to Inner Scope?';
		confirm: 'This refactoring will move all temporaries in all methods in the selected package(s) into the tightest scope that contains both the variable assignment and references. Any unreferenced temporaries will be removed.

Are you sure that you would like to proceed?')
			ifTrue: [self systemModel moveAllTempsToInnerScope: self selectionEnvironment]!

queryRefactoringCommand: aCommandQuery 
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| cmd canRefactor |
	cmd := aCommandQuery commandSymbol.
	canRefactor := self systemModel canRefactor and: [self hasPackages].
	(#(#removeDuplicateMethods) identityIncludes: cmd) 
		ifTrue: 
			[aCommandQuery isEnabled: canRefactor.
			^true].
	"Not a refactoring command"
	^false!

removeDuplicateMethods
	| count pkgs |
	pkgs := self packages.
	count := pkgs inject: 0 into: [:sum :eachPackage | sum + eachPackage classNames size].
	(ProgressDialog operation: 
			[:progress |
			| i devsys |
			i := 0.
			devsys := self systemModel.
			pkgs do: 
					[:eachPackage |
					progress text: eachPackage name.
					eachPackage classes do: 
							[:eachClass |
							i := i + 1.
							progress value: i * 100 // count.
							devsys removeMethodsDuplicatedInSuperclassOf: eachClass]]])
		caption: 'Remove Methods Duplicating Superclass'' from Package(s)…';
		showModal! !
!Tools.PackageSelector categoriesForMethods!
moveAllTempsToInnerScope!commands!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeDuplicateMethods!development!private! !
!

!Tools.SmalltalkToolShell methodsFor!

chooseMethodForRefactoring: aString 
	^self systemModel chooseMethodFromEnvironment: self selectionEnvironment caption: aString!

queryRefactoringCommand: aCommandQuery 
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	^false! !
!Tools.SmalltalkToolShell categoriesForMethods!
chooseMethodForRefactoring:!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
!

!UI.Dialog methodsFor!

validationDwell
	"The <Duration> to wait after the user has stopped typing before re-validating and possibly showing a hint bubble."

	^1 seconds! !
!UI.Dialog categoriesForMethods!
validationDwell!constants!public! !
!

"End of package definition"!

