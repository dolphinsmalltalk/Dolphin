| package |
package := Package name: 'Dolphin Refactoring Browser'.
package paxVersion: 2.1;
	environmentName: #{Tools};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Refactoring Browser Native UI Integration
Copyright (c) Object Arts Ltd, 2001-2009.

This package augments the native Dolphin development system browsers to add refactoring capabilities. The refactorings themselves are implemented by the Refactory refactoring engine, originally ported to Dolphin at Camp Smalltalk 1 in San Diego by Andy Bower and Blair McGlashan with the assistance of John Brant and Don Roberts. We would also like to acknowledge the contribution of Donald McQueen, who pioneered the way with his Refactoring Browser add-on for Dolphin 3.x and 4.x.

Refactoring operations are supported by the Debugger and all the Dolphin browsers. The Debugger and Method Browser support the Code and Method refactorings only, with the Class Hierarchy and System browser supporting all refactorings, including those which operate on classes. The Package Browser, which is really more of an organiser than a coding tool, supports a limited range of refactorings where it is useful to be able to limit their scope to a particular package or set of packages (e.g. renaming a method), although package scoped refactorings can also be initiated from other tools, in particular the System Browser.

A brief description of most of the Refactorings themselves can be found at:

	http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/Refactorings.html

Dolphin also incorporates some of its own specific refactorings.
1) Rename Method References. Not strictly a refactoring, in that it may not preserve existing behaviour, this is effectively one half Rename Method. It renames all references to a selector within the chosen refactoring scope, but does not rename any definitions. This is useful when you have a duplicate method where both original and duplicate are called, and you want to rename refs to the duplicate to call the original, which will then allow removal of the duplicate.
2) Remove Duplicate Methods. This simply removes any methods in a class or classes that are not required because they duplicate an inherited definition. It is particularly useful when applied against packages to help maintain code quality by removing redundant methods.

As of Dolphin 6 renaming a class or instance variable in the browsers can also (optionally) rename accessor methods for that variable. This is based on the Rename Class / Instance Variable and Accessors refactoring developed as part of the Camp Smalltalk RB project. When renaming a variable if any potential accessors are found then the user is prompted as to whether they wish to rename those accessors as well as the underlying variable. The dialog also allows the scope of the method rename to be chosen.

In the browsers Refactoring commands can be found on the Refactoring sub-menus of the class tree, method list, and source workspace context menus, and on the Refactoring sub-menus of the Class, Method and Workspace top-level menus, wherever these are present. In the Debugger the method refactorings menu can be found on the stack trace window context menu, and off the Debug top-level menu. Extensive use is made of dynamically constructed menus to enhance usability, and accelerator key sequences are associated with the most commonly used code refactorings. Many refactorings (not just "code" refactorings) can now be initiated from the browser source workspace context menus just by right-clicking over the appropriate syntactic element; for example you can rename a self-sent message by selecting the message send or just by right-clicking over one of the selector''s keywords.'.

package basicPackageVersion: '6.1'.


package setClassNames: #(
	#{Refactory.Browser.CopyClassRefactoring}
	#{Refactory.Browser.RenameMethodReferencesTransformation}
	#{Tools.ChooseImportDialog}
	#{Tools.CodeMentorPlugin}
	#{Tools.CodeRefactoringTool}
	#{Tools.CodeRewriterPlugin}
	#{Tools.ConvertToSiblingDialog}
	#{Tools.LintRuleFailuresBrowserShell}
	#{Tools.MethodNameDialog}
	#{Tools.MethodRefactoringTool}
	#{Tools.RefactoringSmalltalkSystem}
	#{Tools.RefactoringTool}
	#{Tools.RenameAccessorsDialog}
	#{Tools.RenameMethodDialog}
	#{Tools.RewriteChangesBrowser}
	#{Tools.ScopedMethodName}
	#{Tools.SmalllintCachingContext}
	#{Tools.SmalllintPlugin}
).

package setMethodNames: #(
	#(#{Core.Behavior} #directlyDefinesMethod:)
	#(#{Core.ClassDescription} #definesClassVariable:)
	#(#{Core.ClassDescription} #definesInstanceVariable:)
	#(#{Core.ClassDescription} #definesVariable:)
	#(#{Core.ClassDescription} #directlyDefinesClassVariable:)
	#(#{Core.ClassDescription} #directlyDefinesInstanceVariable:)
	#(#{Core.ClassDescription} #directlyDefinesVariable:)
	#(#{Core.ClassDescription} #hierarchyDefinesVariable:)
	#(#{Refactory.Browser.AbstractClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #displayOn:)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #getOptionAbstractVariables)
	#(#{Refactory.Browser.AddClassChange class} #icon)
	#(#{Refactory.Browser.AddClassConstantChange class} #icon)
	#(#{Refactory.Browser.AddClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddClassVariableChange class} #icon)
	#(#{Refactory.Browser.AddClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.AddInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddMethodChange class} #icon)
	#(#{Refactory.Browser.AddMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddMethodRefactoring} #maxDetails)
	#(#{Refactory.Browser.AddParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddSharedVariableChange class} #icon)
	#(#{Refactory.Browser.BasicLintRule} #failedClasses)
	#(#{Refactory.Browser.BasicLintRule} #failedMethods)
	#(#{Refactory.Browser.BasicLintRule} #publishedAspects)
	#(#{Refactory.Browser.BasicLintRule} #searchStrings)
	#(#{Refactory.Browser.BasicRenameClassChange class} #icon)
	#(#{Refactory.Browser.ChangeMethodNameRefactoring} #getOptionRenameAllDefinitions:of:)
	#(#{Refactory.Browser.ChildrenToSiblingsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ClassCategoryChange class} #icon)
	#(#{Refactory.Browser.ClassCommentChange class} #icon)
	#(#{Refactory.Browser.ClassGuidChange class} #icon)
	#(#{Refactory.Browser.CompositeRefactoryChange class} #icon)
	#(#{Refactory.Browser.CreateAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExpandImportsRefactoring} #getOptionAddImports:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #getOptionUseExistingMethod:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #getOptionVariableToMoveToOf:in:)
	#(#{Refactory.Browser.ExtractToTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineAllSendersRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionImplementorToInline:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineOverridden:of:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineReordered:into:)
	#(#{Refactory.Browser.InlineParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.LintRule} #failedClasses)
	#(#{Refactory.Browser.LintRule} #failedMethods)
	#(#{Refactory.Browser.LintRule} #searchStrings)
	#(#{Refactory.Browser.LintRule class} #icon)
	#(#{Refactory.Browser.MethodRefactoring} #generateDefaultSelector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionAlreadyDefined:selector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionExtractAssignment:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionInlineExpression:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionNewMethodName:classes:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionRemoveMethod:referencedIn:)
	#(#{Refactory.Browser.MoveClassChange class} #icon)
	#(#{Refactory.Browser.MoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionSelfArgumentName)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionVariableTypes:selected:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #resolveClass:)
	#(#{Refactory.Browser.MoveVariableDefinitionRefactoring} #displayOn:)
	#(#{Refactory.Browser.ProtectInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionCopyDownSuperclassMethod:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionPushUpRemoveDuplicates:in:)
	#(#{Refactory.Browser.RBAbstractClass} #allSubclassesDo:)
	#(#{Refactory.Browser.RBAbstractClass} #allSubclassesPreOrderDo:)
	#(#{Refactory.Browser.RBAbstractClass class} #icon)
	#(#{Refactory.Browser.RBAbstractClass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBAbstractCondition} #validate)
	#(#{Refactory.Browser.RBAbstractCondition} #validate:)
	#(#{Refactory.Browser.RBAbstractCondition class} #icon)
	#(#{Refactory.Browser.RBClass} #icon)
	#(#{Refactory.Browser.RBClass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBMetaclass class} #icon)
	#(#{Refactory.Browser.RBMetaclass class} #instancesAreClasses)
	#(#{Refactory.Browser.RBMethod} #hasCompilationFailures)
	#(#{Refactory.Browser.RBMethod} #hasCompilationIssues)
	#(#{Refactory.Browser.RBMethod} #owningPackage)
	#(#{Refactory.Browser.RBMethod class} #icon)
	#(#{Refactory.Browser.RBModel} #allResourceIdentifiers)
	#(#{Refactory.Browser.RBModel} #browseChanges)
	#(#{Refactory.Browser.RBModel} #methodsThatFailedToCompileIn:)
	#(#{Refactory.Browser.RBModel} #methodsWithCompilationIssuesIn:)
	#(#{Refactory.Browser.RBModel} #modelClassFor:)
	#(#{Refactory.Browser.RBModel class} #icon)
	#(#{Refactory.Browser.RBNamespaceClass class} #icon)
	#(#{Refactory.Browser.RBRootNamespace class} #icon)
	#(#{Refactory.Browser.RBSmalltalkNamespace class} #icon)
	#(#{Refactory.Browser.Refactoring} #chooseFrom:caption:)
	#(#{Refactory.Browser.Refactoring} #confirm:)
	#(#{Refactory.Browser.Refactoring} #maxDetails)
	#(#{Refactory.Browser.Refactoring} #printNameList:on:limit:type:)
	#(#{Refactory.Browser.Refactoring} #prompt:)
	#(#{Refactory.Browser.Refactoring class} #icon)
	#(#{Refactory.Browser.Refactoring class} #renameIcon)
	#(#{Refactory.Browser.RefactoryClassChange class} #icon)
	#(#{Refactory.Browser.RefactoryMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveClassChange class} #icon)
	#(#{Refactory.Browser.RemoveClassConstantChange class} #icon)
	#(#{Refactory.Browser.RemoveClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveClassRefactoring} #getOptionRemoveClass:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring} #getOptionRemoveVariable:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveImportRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #getOptionRemoveDuplicatesWithSupersends:)
	#(#{Refactory.Browser.RemoveParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveSharedVariableChange class} #icon)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameClassChange class} #icon)
	#(#{Refactory.Browser.RenameClassRefactoring} #getOptionIgnoreSymbolicClassReferences:)
	#(#{Refactory.Browser.RenameClassRefactoring} #getOptionUpgradeLegacyPackage:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameMethodRefactoring class} #icon)
	#(#{Refactory.Browser.RenameTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameTemporaryRefactoring class} #icon)
	#(#{Refactory.Browser.RenameVariableChange class} #icon)
	#(#{Refactory.Browser.SmalllintChecker class} #newWithCachingContext)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #getOptionConvertReadBeforeWritten:)
	#(#{Refactory.Browser.TransformationRule class} #bitLogicElimination)
	#(#{Refactory.Browser.TransformationRule class} #icon)
	#(#{Refactory.Browser.TransformationRule class} #ifElimination)
	#(#{Refactory.Browser.TransformationRule class} #renameArgument:to:)
	#(#{Refactory.Browser.VariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.VariableRefactoring} #displayPrefix)
	#(#{Refactory.Browser.VariableRefactoring} #getOptionPullUpNonSharedInstVar:)
	#(#{Refactory.Browser.VariableRefactoring class} #displayPrefix)
	#(#{Tools.ChooseNamespaceDialog class} #resource_Refactoring_view)
	#(#{Tools.ClassBrowserAbstract} #abstractInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #methodRefactoringTool)
	#(#{Tools.ClassBrowserAbstract} #methodsToOverride)
	#(#{Tools.ClassBrowserAbstract} #overrideMethods)
	#(#{Tools.ClassBrowserAbstract} #protectInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownMethods)
	#(#{Tools.ClassBrowserAbstract} #pushMethods:)
	#(#{Tools.ClassBrowserAbstract} #pushUpMethods)
	#(#{Tools.ClassBrowserAbstract} #queryOverrideMethods:)
	#(#{Tools.ClassBrowserAbstract} #queryPushDownInstanceVariables:)
	#(#{Tools.ClassBrowserAbstract} #queryPushDownMethods:)
	#(#{Tools.ClassBrowserAbstract} #queryPushUpMethods:)
	#(#{Tools.ClassBrowserAbstract} #queryVariablesCommand:)
	#(#{Tools.ClassBrowserAbstract} #removeInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #renameMethod)
	#(#{Tools.ClassBrowserAbstract} #selectedOverridableMethods)
	#(#{Tools.ClassBrowserPlugin} #developmentSystem)
	#(#{Tools.ClassSelector} #abstractClassVariables)
	#(#{Tools.ClassSelector} #abstractInstanceVariables)
	#(#{Tools.ClassSelector} #abstractVariables)
	#(#{Tools.ClassSelector} #addClassVariable)
	#(#{Tools.ClassSelector} #addImport)
	#(#{Tools.ClassSelector} #addInstanceVariable)
	#(#{Tools.ClassSelector} #buildInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #buildPullUpVariablesMenu:)
	#(#{Tools.ClassSelector} #buildVariablesMenu:instVarSelectors:classVarSelectors:)
	#(#{Tools.ClassSelector} #changeClassNamespace)
	#(#{Tools.ClassSelector} #classRefactoringsMenu)
	#(#{Tools.ClassSelector} #cloneClass:under:changes:)
	#(#{Tools.ClassSelector} #commandQuerySelector:)
	#(#{Tools.ClassSelector} #convertToSibling)
	#(#{Tools.ClassSelector} #createClassVariableAccessors)
	#(#{Tools.ClassSelector} #createVariableAccessors)
	#(#{Tools.ClassSelector} #populateClassVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populateInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:)
	#(#{Tools.ClassSelector} #populateRefactoringMenu:)
	#(#{Tools.ClassSelector} #protectInstanceVariables)
	#(#{Tools.ClassSelector} #protectVariables)
	#(#{Tools.ClassSelector} #pullUpClassVariables)
	#(#{Tools.ClassSelector} #pullUpInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpVariableNamePairs:for:maximum:)
	#(#{Tools.ClassSelector} #pullUpVariables)
	#(#{Tools.ClassSelector} #pushDownClassVariables)
	#(#{Tools.ClassSelector} #pushDownInstanceVariables)
	#(#{Tools.ClassSelector} #pushDownVariables)
	#(#{Tools.ClassSelector} #queryAddInstanceVariable:)
	#(#{Tools.ClassSelector} #queryPullUpClassVariables:)
	#(#{Tools.ClassSelector} #queryPullUpInstanceVariables:)
	#(#{Tools.ClassSelector} #queryPullUpVariables:)
	#(#{Tools.ClassSelector} #queryPushDownInstanceVariables:)
	#(#{Tools.ClassSelector} #queryPushDownVariables:)
	#(#{Tools.ClassSelector} #queryRemoveImport:)
	#(#{Tools.ClassSelector} #queryVariablesCommand:)
	#(#{Tools.ClassSelector} #removeClassVariables)
	#(#{Tools.ClassSelector} #removeDuplicateMethods)
	#(#{Tools.ClassSelector} #removeImport)
	#(#{Tools.ClassSelector} #removeInstanceVariables)
	#(#{Tools.ClassSelector} #removeVariables)
	#(#{Tools.CreateSubclassDialog class} #resource_Refactoring_view)
	#(#{Tools.Debugger} #canMoveMethods)
	#(#{Tools.Debugger} #hasRefactorableMethodSelected)
	#(#{Tools.Debugger} #performMethodRefactoring:)
	#(#{Tools.Debugger} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #canMoveMethods)
	#(#{Tools.MethodBrowser} #hasRefactorableMethodSelected)
	#(#{Tools.MethodBrowser} #performMethodRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodsRefactoring:name:)
	#(#{Tools.MethodWorkspace} #canRefactor)
	#(#{Tools.MethodWorkspace} #executeRefactoring:)
	#(#{Tools.MethodWorkspace} #executeRefactoring:with:)
	#(#{Tools.MethodWorkspace} #fontOfStyle:)
	#(#{Tools.MethodWorkspace} #performCodeRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRenameRefactoring:)
	#(#{Tools.MethodWorkspace} #renameVariable:operation:validationBlock:)
	#(#{Tools.PackageBrowserShell} #addImport)
	#(#{Tools.PackageBrowserShell} #addParameter)
	#(#{Tools.PackageBrowserShell} #addParameterTo:)
	#(#{Tools.PackageBrowserShell} #addParameterToMethod)
	#(#{Tools.PackageBrowserShell} #changeClassNamespace)
	#(#{Tools.PackageBrowserShell} #chooseMethodsForRefactoring:)
	#(#{Tools.PackageBrowserShell} #classRefactoringsMenu)
	#(#{Tools.PackageBrowserShell} #hasRefactorableMethodSelected)
	#(#{Tools.PackageBrowserShell} #methodRefactoringsMenu)
	#(#{Tools.PackageBrowserShell} #newMethodNamePrompter:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #onClass:renameTo:accept:)
	#(#{Tools.PackageBrowserShell} #onRenameClass:to:showChanges:)
	#(#{Tools.PackageBrowserShell} #parseTree)
	#(#{Tools.PackageBrowserShell} #performMethodRenameRefactoring:)
	#(#{Tools.PackageBrowserShell} #performMethodsRefactoring:name:)
	#(#{Tools.PackageBrowserShell} #promptForMethodName:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #queryHasClassesSelected:)
	#(#{Tools.PackageBrowserShell} #queryHasClassSelected:)
	#(#{Tools.PackageBrowserShell} #queryHasMethodSelected:)
	#(#{Tools.PackageBrowserShell} #queryHasMethodsSelected:)
	#(#{Tools.PackageBrowserShell} #queryRemoveParameter:)
	#(#{Tools.PackageBrowserShell} #removeMethod)
	#(#{Tools.PackageBrowserShell} #removeMethods)
	#(#{Tools.PackageBrowserShell} #removeParameter)
	#(#{Tools.PackageBrowserShell} #removeParameterMenu)
	#(#{Tools.PackageBrowserShell} #renameClass)
	#(#{Tools.PackageBrowserShell} #renameLooseMethod)
	#(#{Tools.PackageBrowserShell} #renameLooseMethodReferences)
	#(#{Tools.PackageBrowserShell} #renameMethod)
	#(#{Tools.PackageBrowserShell} #renameMethodReferences:)
	#(#{Tools.PackageSelector} #moveAllTempsToInnerScope)
	#(#{Tools.PackageSelector} #queryPackageRefactoring:)
	#(#{Tools.PackageSelector} #removeDuplicateMethods)
	#(#{Tools.SmalltalkToolShell} #chooseMethodForRefactoring:)
	#(#{UI.Dialog} #validationDwell)
	#(#{UI.Presenter class} #resource_Refactoring_OK_Cancel_button_block)
).

package setPrerequisites: #(
	'..\..\..\..\Contributions\Camp Smalltalk\Refactoring Browser\Refactorings\CSRefactorings'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Base\Dolphin Base Dialogs'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Views\Buttons\Dolphin Check Buttons'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Presenters\Difference\Dolphin Differences Presenter'
	'..\..\MVP\Graphics\Dolphin GDI Graphics'
	'..\..\MVP\Views\GroupBox\Dolphin GroupBox'
	'..\..\MVP\Presenters\Prompters\Dolphin In-place Text Editor'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\System\Win32\MessageBox\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'Dolphin Professional Tools'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Views\Buttons\Dolphin Push Buttons'
	'..\..\MVP\Views\Scintilla\Dolphin Scintilla View'
	'..\..\MVP\Views\Splitter\Dolphin Splitter Control'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Views\Tooltips\Dolphin Tooltips'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Parser\RBParser'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\SmallLint\RBSmallLint'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Components\WebView2\WebView2'
	'..\..\ActiveX\Shell\Windows Shell'
	'..\..\ActiveX\Components\XML DOM\XML DOM'
).

package!

"Class Definitions"!

Core.Object
	subclass: #'Tools.RefactoringTool'
	instanceVariableNames: 'presenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ProfessionalSmalltalkSystem
	subclass: #'Tools.RefactoringSmalltalkSystem'
	instanceVariableNames: 'isOAD'
	classVariableNames: 'RefactoringSignal'
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassBrowserPlugin
	subclass: #'Tools.SmalllintPlugin'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin
	subclass: #'Tools.CodeMentorPlugin'
	instanceVariableNames: 'failuresPresenter infoSitePresenter infoBrowserPresenter progressPresenter checkerProcess rulesTreeModel isRefreshPending refreshMode'
	classVariableNames: 'DefaultRefreshMode LintIconMap LintRulesDoc'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin
	subclass: #'Tools.CodeRewriterPlugin'
	instanceVariableNames: 'searchTextPresenter replaceTextPresenter isMethodPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog
	subclass: #'Tools.ConvertToSiblingDialog'
	instanceVariableNames: 'classNamePresenter namespacePresenter subclassesPresenter statusModel'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog
	subclass: #'Tools.MethodNameDialog'
	instanceVariableNames: 'selectorPresenter parametersPresenter parameterNamesPresenter hintBubble showChangesPresenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodNameDialog
	subclass: #'Tools.RenameMethodDialog'
	instanceVariableNames: 'scopePresenter scopeDescriptionPresenter allowExistingSelector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog
	subclass: #'Tools.RenameAccessorsDialog'
	instanceVariableNames: 'selectorsPresenter scopePresenter showChangesPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ChooseNamespaceDialog
	subclass: #'Tools.ChooseImportDialog'
	instanceVariableNames: 'private hintBubble namespacesOnly'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell
	subclass: #'Tools.RewriteChangesBrowser'
	instanceVariableNames: 'changesPresenter differencesPresenter compositeChange'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodBrowserShell
	subclass: #'Tools.LintRuleFailuresBrowserShell'
	instanceVariableNames: 'lintRule'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBMethodName
	subclass: #'Tools.ScopedMethodName'
	instanceVariableNames: 'methodClass originalArguments originalSelector scopeName scopes'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ClassRefactoring
	subclass: #'Refactory.Browser.CopyClassRefactoring'
	instanceVariableNames: 'newName class superclass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RenameMethodRefactoring
	subclass: #'Refactory.Browser.RenameMethodReferencesTransformation'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool
	subclass: #'Tools.CodeRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Kernel.ParseErrorCodes})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool
	subclass: #'Tools.MethodRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.SmalllintContext
	subclass: #'Tools.SmalllintCachingContext'
	instanceVariableNames: ''
	classVariableNames: 'Literals Mtx Selectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Behavior methodsFor!

directlyDefinesMethod: aSymbol
	^self includesSelector: aSymbol! !
!Core.Behavior categoriesForMethods!
directlyDefinesMethod:!methods-testing!public! !
!

!Core.ClassDescription methodsFor!

definesClassVariable: aSymbol 
	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesClassVariable: aSymbol]!

definesInstanceVariable: aString 
	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesInstanceVariable: aString]!

definesVariable: aVariableName 
	^(self definesClassVariable: aVariableName) 
		or: [self definesInstanceVariable: aVariableName]!

directlyDefinesClassVariable: aString
	| var |
	var := self localBindingFor: aString.
	^var notNil and: [var isClassVariable]!

directlyDefinesInstanceVariable: aString 
	^self instanceVariableNames includes: aString!

directlyDefinesVariable: aVariableName 
	^(self directlyDefinesClassVariable: aVariableName) 
		or: [self directlyDefinesInstanceVariable: aVariableName]!

hierarchyDefinesVariable: aString
	(self definesVariable: aString) ifTrue: [^true].
	self allSubclassesBreadthFirstDo: [:each | (each directlyDefinesVariable: aString) ifTrue: [^true]].
	^false! !
!Core.ClassDescription categoriesForMethods!
definesClassVariable:!public!testing! !
definesInstanceVariable:!public!testing! !
definesVariable:!public!testing! !
directlyDefinesClassVariable:!public!testing! !
directlyDefinesInstanceVariable:!public!testing! !
directlyDefinesVariable:!public!testing! !
hierarchyDefinesVariable:!public!testing! !
!

!Refactory.Browser.AbstractClassVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractClassVariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Refactory.Browser.AbstractInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AbstractVariablesRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	#todo.	"Implement more informative display string"
	aPuttableStream nextPutAll: 'Abstract Variables of <1p>' << fromClass!

getOptionAbstractVariables
	| details instVars classVars accessesInstVars |
	details := String writeStream.
	instVars := instVarReaders union: instVarWriters.
	accessesInstVars := instVars isEmpty.
	accessesInstVars
		ifFalse: 
			[details
				nextPutAll: 'The following instance variables are directly accessed:';
				cr.
			self
				printNameList: instVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'instance variables'].
	classVars := classVarReaders union: classVarWriters.
	classVars isEmpty
		ifFalse: 
			[accessesInstVars
				ifTrue: 
					[details
						cr;
						cr].
			details
				nextPutAll: 'The following class variables are directly accessed:';
				cr.
			self
				printNameList: classVars asSortedArray
				on: details
				limit: self maxDetails // 2
				type: 'class variables'].
	details
		cr;
		cr;
		nextPutAll: 'Any existing accessor will be used if possible, so accessors will only be added for read or written variables that do not currently have them.'.
	^MessageBox new
		caption: self displayString;
		headline: 'Abstract variable references?';
		text: 'This method has direct variable references which will need to be converted to getter/setters in the extracted method<1?s:>.'
					<< {toClasses size > 1};
		customButtons: #(#(#yes '&Abstract Variables') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !
!Refactory.Browser.AbstractVariablesRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAbstractVariables!options!public! !
!

!Refactory.Browser.AddClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewClass.ico'! !
!Refactory.Browser.AddClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add class ';
		display: self className! !
!Refactory.Browser.AddClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Import ';
		display: import;
		nextPutAll: ' into ';
		display: class! !
!Refactory.Browser.AddImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewMethod.ico'! !
!Refactory.Browser.AddMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add method to ';
		nextPutAll: class unqualifiedName!

maxDetails
	^15! !
!Refactory.Browser.AddMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
maxDetails!constants!private! !
!

!Refactory.Browser.AddParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add parameter to ';
		print: oldSelector.
	model environment isSystem
		ifFalse: 
			[aPuttableStream
				nextPutAll: ' in ';
				display: model environment]! !
!Refactory.Browser.AddParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.AddSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.BasicLintRule methodsFor!

failedClasses
	self result isClassEnvironment ifFalse: [^super failedClasses].
	^self result classes!

failedMethods
	| failedMethods |
	self result isClassEnvironment ifTrue: [^super failedMethods].
	failedMethods := Set new: 64.
	self result
		classesAndSelectorsDo: [:eachClass :eachSel | failedMethods add: (eachClass compiledMethodAt: eachSel)].
	^failedMethods!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := self class publishedAspectsOfInstances.
	self result isClassEnvironment
		ifTrue: [answer add: ((Aspect collection: #failedClasses)
						beReadOnly;
						yourself)]
		ifFalse: [answer add: ((Aspect collection: #failedMethods)
						beReadOnly;
						yourself)].
	self searchStrings notEmpty
		ifTrue: 
			[answer add: ((Aspect sequenceableCollection: #searchStrings)
						beReadOnly;
						yourself)].
	^answer!

searchStrings
	^result searchStrings! !
!Refactory.Browser.BasicLintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
publishedAspects!constants!development!public! !
searchStrings!accessing!private! !
!

!Refactory.Browser.BasicRenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.BasicRenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ChangeMethodNameRefactoring methodsFor!

getOptionRenameAllDefinitions: aCollection of: aSymbol
	| details count prompt |
	aCollection size <= 1 ifTrue: [^true].
	details := String writeStream.
	details
		print: aSymbol;
		nextPutAll: ' is implemented in:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'All definitions must be renamed to preserve behaviour. You can re-initiate the rename and constrain the scope of the rename to package, hierarchy, class or even individual method level in the rename dialog if you wish, but this may not preserve behaviour.'.
	count := aCollection size.
	prompt := MessageBox new
				caption: self displayString;
				headline: 'Rename <1p> methods defined in <2d> classes in <3p>?'
							<< { aSymbol. count. model environment };
				customButtons: #(#(#yes '&Rename All') #(#no 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				checkboxText: 'Show proposed changes?';
				isChecked: self shouldShowChanges;
				yourself.
	prompt confirm ifFalse: [^false].
	prompt isChecked ifTrue: [self shouldShowChanges: true].
	^true! !
!Refactory.Browser.ChangeMethodNameRefactoring categoriesForMethods!
getOptionRenameAllDefinitions:of:!options!public! !
!

!Refactory.Browser.ChildrenToSiblingsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert ';
		display: parent;
		nextPutAll: ' to sibling'! !
!Refactory.Browser.ChildrenToSiblingsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ClassCategoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^ClassCategory icon! !
!Refactory.Browser.ClassCategoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassCommentChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassComment.ico'! !
!Refactory.Browser.ClassCommentChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassGuidChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^GUID icon! !
!Refactory.Browser.ClassGuidChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CompositeRefactoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Collection icon! !
!Refactory.Browser.CompositeRefactoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CreateAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Create accessors for'! !
!Refactory.Browser.CreateAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.ExpandImportsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Add import'.
	imports size = 1
		ifTrue: 
			[aPuttableStream space.
			imports asArray first displayOn: aPuttableStream]
		ifFalse: 
			[aPuttableStream nextPutAll: 's '.
			imports do: [:each | each displayOn: aPuttableStream] separatedBy: [aPuttableStream nextPutAll: ', ']].
	aPuttableStream nextPutAll: ' to '.
	toClasses size = 1
		ifTrue: [toClasses asArray first displayOn: aPuttableStream]
		ifFalse: 
			[toClasses do: [:each | each name displayOn: aPuttableStream]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionAddImports: aCollection
	| details |
	details := String writeStream.
	details nextPutAll: 'The following namespaces will need to be imported'.
	toClasses size == 1
		ifTrue: 
			[details
				nextPutAll: ' into ';
				nextPutAll: toClasses first unqualifiedName].
	details
		nextPut: $:;
		cr.
	self
		printNameList: aCollection asSortedCollection
		on: details
		limit: self maxDetails
		type: 'namespaces'.
	^MessageBox new
		caption: self displayString;
		text: 'This method contains references to shared variables from namespaces that may need to be imported into the target.';
		customButtons: #(#(#yes '&Add Imports') #(#no '&Cancel'));
		detailsText: details contents;
		confirm! !
!Refactory.Browser.ExpandImportsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAddImports:!options!public! !
!

!Refactory.Browser.ExtractMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract method from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionUseExistingMethod: aSymbol
	| response |
	response := MessageBox new
				caption: self displayString;
				headline: 'Use existing method <1p>?' << aSymbol;
				text: 'The existing method contains the same code as that you are extracting, and can be used safely instead of creating a new method.';
				customButtons: #(#(#yes '&Use Existing') #(#no '&Create New Method'));
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !
!Refactory.Browser.ExtractMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionUseExistingMethod:!options!public! !
!

!Refactory.Browser.ExtractMethodToComponentRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to component from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionVariableToMoveToOf: aClass in: aSelector
	^SmalltalkSystem current selectTargetVariableOf: aClass
		parseTree: (aClass parseTreeFor: aSelector)! !
!Refactory.Browser.ExtractMethodToComponentRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionVariableToMoveToOf:in:!public! !
!

!Refactory.Browser.ExtractToTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to temporary ';
		print: newVariableName! !
!Refactory.Browser.ExtractToTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineAllSendersRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline sends of ';
		print: selector;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.InlineAllSendersRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline message in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: sourceSelector!

getOptionImplementorToInline: anOrderedCollection
	^UI.ChoicePrompter
		choices: (anOrderedCollection asSortedCollection: [:a :b | a displayString <= b displayString])
		caption: 'Inline <1p> from…' << sourceMessage!

getOptionInlineOverridden: aSymbol of: aClass
	| details overrides fromClass |
	details := String writeStream.
	fromClass := self chosenInlineClass.
	details
		nextPutAll: '<1p> is overridden by the following subclasses of <2d>:'
					<< {aSymbol. fromClass unqualifiedName};
		cr.
	overrides := fromClass allSubclasses select: [:each | each directlyDefinesMethod: aSymbol].
	self
		printNameList: overrides
		on: details
		limit: self maxDetails
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Inline overridden method?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: '<1d>>><2p> is overridden in <3d> subclass<4?:es> of <5d>.<n><n>Inlining an overridden method may change behavior.'
					<< {aClass. aSymbol. overrides size. overrides size = 1. fromClass};
		detailsText: details contents;
		confirm!

getOptionInlineReordered: inlineRBMethod into: intoRBMethod
	^MessageBox new
		caption: self displayString;
		headline: 'Inline with statement reordering?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: 'To inline <1p> into <2p> it will be necessary to move some of the inlined statements before the original message send.'
					<< {inlineRBMethod. intoRBMethod};
		detailsText: 'This could change the order of execution, which can change the behavior. If it is safe to do so you can continue with the refactoring and then modify or undo the results as required. Alternatively cancel the refactoring and modify the call site so that the inlined message send is an individual statement rather than part of a larger statement, for example as an expression calculating a value to use as an argument to another message send.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm! !
!Refactory.Browser.InlineMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionImplementorToInline:!options!public! !
getOptionInlineOverridden:of:!preconditions!public! !
getOptionInlineReordered:into:!options!public! !
!

!Refactory.Browser.InlineParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline parameter ';
		print: argument;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.InlineParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline temp ';
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector
	"		print: oldName;"! !
!Refactory.Browser.InlineTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.LintRule methodsFor!

failedClasses
	^Set new!

failedMethods
	^Set new!

searchStrings
	^#()! !
!Refactory.Browser.LintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
searchStrings!accessing!private! !
!

!Refactory.Browser.LintRule class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!Refactory.Browser.LintRule class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MethodRefactoring methodsFor!

generateDefaultSelector: aRBMethodName
	| args mname |
	aRBMethodName selector isNil ifFalse: [^self].
	args := aRBMethodName arguments.
	mname := args isEmpty
				ifTrue: ['method']
				ifFalse: 
					[| stream |
					stream := String writeStream.
					aRBMethodName arguments do: 
							[:arg |
							stream
								nextPutAll: arg;
								nextPut: $:].
					stream contents].
	aRBMethodName selector: mname asSymbol!

getOptionAlreadyDefined: aClass selector: aSymbol
	| response |
	response := MessageBox new
				caption: self displayString;
				headline: 'Extract to existing selector?';
				text: '<1p> is already defined in the <2p> hierarchy.' << {aSymbol. aClass};
				customButtons: #(#(#yes '&Continue') #(#no 'Choose &Another') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: 'Extracting to an existing selector may change the behavior of the class hierarchy, for example by overriding an inherited method. You should only continue if you do not require a true behavior-preserving refactoring. Otherwise choose another selector.'
							<< aSymbol;
				expandLabel: 'Show help';
				collapseLabel: 'Hide help';
				iconStyle: #warning;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes!

getOptionExtractAssignment: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Extract final assignment?';
		text: 'The assignment to ''<1s>'' at the end of the selection can be extracted to the new method, or remain behind to receive the result of the call to that method.'
					<< aString;
		customButtons: #(#(#yes '&Extract') #(#no '&Don''t Extract'));
		defaultButton: 2;
		confirm!

getOptionInlineExpression: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Inline expression?';
		text: 'The following expression can be inlined or assigned to a temporary:<n><n><t><1s>?' << aString;
		customButtons: #(#(#yes '&Inline') #(#no '&Assign Temporary'));
		defaultButton: 2;
		detailsText: 'The expression shown is passed as one of the arguments to the method you are inlining. You can safely inline the expression if constant and/or side-effect free, or if it is only referred to once in the inlined method. If not, it should be assigned to a temporary to preserve existing behaviour. If unsure, choose ''Assign Temporary''. You can always inline the temporary later if you wish.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm!

getOptionNewMethodName: aRBMethodName classes: anArray
	| dialog |
	self generateDefaultSelector: aRBMethodName.
	dialog := MethodNameDialog create: 'Refactoring view' on: aRBMethodName.
	dialog validater: 
			[:methodName |
			| selector |
			selector := methodName selectorSymbol.
			(anArray inject: methodName conditions
				into: [:conditions :each | conditions & (Refactory.Browser.RBCondition definesSelector: selector in: each) not])
					validate].
	^dialog showModal
		ifNotNil: 
			[dialog showChanges ifTrue: [self shouldShowChanges: true].
			aRBMethodName]!

getOptionRemoveMethod: aSymbol referencedIn: aCollection
	| details response |
	details := String writeStream.
	'Removing the method may not preserve behaviour. It is recommended that you first browse <?these references:this reference> to verify that the method is safe to remove:<n>'
		expandMacrosWithArguments: {aCollection size > 1}
		on: details.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: '<1s>>><2p> may not be safe to remove' << {class shortName. aSymbol};
				text: 'The selector <1p> is referenced from <2d> other method<3?s:> in <4p>.'
							<< {aSymbol. aCollection size. aCollection size > 1. self model environment};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: [SmalltalkSystem current browseReferencesToLiteral: aSymbol in: self model environment].
	^false! !
!Refactory.Browser.MethodRefactoring categoriesForMethods!
generateDefaultSelector:!options!public! !
getOptionAlreadyDefined:selector:!options!public! !
getOptionExtractAssignment:!options!public! !
getOptionInlineExpression:!options!public! !
getOptionNewMethodName:classes:!options!public! !
getOptionRemoveMethod:referencedIn:!options!public! !
!

!Refactory.Browser.MoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Class icon! !
!Refactory.Browser.MoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		nextPutAll: class shortName;
		nextPutAll: '>>';
		print: selector;
		nextPutAll: '  to ';
		print: variable!

getOptionSelfArgumentName
	| newName existing |
	existing := parseTree allDefinedVariables.
	newName := (Prompter
				createOn: String new
				prompt: 'Enter name for argument to refer to "self" in extracted method'
				caption: self displayString)
				validater: 
						[:name |
						(existing includes: name)
							ifTrue: [ValidationResult errorMessage: '<1d> is already in use as a local variable' << name]
							ifFalse: 
								[| result |
								result := ValidationResult new.
								moveToClasses allSatisfy: 
										[:each |
										| condition |
										condition := (Refactory.Browser.RBCondition isValidTemporaryVariableName: name for: each)
													& (Refactory.Browser.RBCondition definesInstanceVariable: name in: each) not.
										condition validate: result].
								result]];
				showHintWhenEmpty: false;
				showModal.
	newName isNil ifTrue: [^self refactoringAborted: 'Method not moved/extracted'].
	^newName!

getOptionVariableTypes: choicesCollection selected: suggestionsCollection
	^(ChoicePrompter
		create: 'Extensible multi-selection choice prompter'
		on: suggestionsCollection asOrderedCollection
		multipleChoices: ((choicesCollection union: suggestionsCollection)
				asSortedCollection: [:a :b | a name < b name])
		caption: 'Select class(es) of new method… ')
		newPrompterBlock: 
				[:newModel |
				Smalltalk developmentSystem classChooserClass createOn: (newModel ?? class) realClass];
		newCaption: 'Add Other Class…';
		validater: 
				[:aClass |
				| result |
				result := ValidationResult new.
				(self model classFor: aClass) ifNil: [result errorMessage: '<1s> is not a visible class' << aClass].
				result];
		newBlock: [:aClass | self model classFor: aClass];
		showModal!

resolveClass: aClass
	^self model classFor: aClass! !
!Refactory.Browser.MoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionSelfArgumentName!public! !
getOptionVariableTypes:selected:!options!public! !
resolveClass:!helpers!private! !
!

!Refactory.Browser.MoveVariableDefinitionRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		display: 'variable';
		nextPutAll: ' to inner scope in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.MoveVariableDefinitionRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ProtectInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Protect'! !
!Refactory.Browser.ProtectInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownClassVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push down ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PushDownMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PushUpMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push up ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionCopyDownSuperclassMethod: aSelector
	^self
		confirm: 'Do you want to copy down the superclass method to the classes that don''t define <1p>?'
				<< aSelector!

getOptionPushUpRemoveDuplicates: aSymbol in: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following subclasses of ';
		nextPutAll: class superclass unqualifiedName;
		nextPutAll: ' will have a duplicate implementation:';
		cr.
	self
		printNameList: (aCollection asSortedArray: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	response := MessageBox new
				caption: self displayString;
				text: 'Pushing up <1p> from <2d> to <3d> will result in duplicate implementations in <4d> subclass<5?es:> of <3d>.'
							<< {aSymbol.
									class unqualifiedName.
									class superclass unqualifiedName.
									aCollection size.
									aCollection size > 1};
				headline: 'Remove duplicates of pushed up method?';
				customButtons: #(#(#yes '&Remove Duplicates') #(#no 'Don''t Remove'));
				defaultButton: 1;
				isCancellable: true;
				detailsText: details contents;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !
!Refactory.Browser.PushUpMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionCopyDownSuperclassMethod:!options!public! !
getOptionPushUpRemoveDuplicates:in:!options!public! !
!

!Refactory.Browser.RBAbstractClass methodsFor!

allSubclassesDo: aMonadicValuable
	"Evaluate the <monadicValuable> argument for each of the receiver's subclasses using a pre-order depth first traversal."

	self allSubclassesPreOrderDo: aMonadicValuable!

allSubclassesPreOrderDo: aMonadicValuable
	"Private - Evaluate the <monadicValuable> argument for each of the receiver's subclasses, visiting the receiver before its subclasses (i.e. a pre-order traversal)."

	self subclasses do: 
			[:each |
			aMonadicValuable value: each.
			each allSubclassesPreOrderDo: aMonadicValuable]! !
!Refactory.Browser.RBAbstractClass categoriesForMethods!
allSubclassesDo:!class hierarchy-accessing!enumerating!public! !
allSubclassesPreOrderDo:!class hierarchy-accessing!private! !
!

!Refactory.Browser.RBAbstractClass class methodsFor!

icon
	^Class icon!

instancesAreClasses
	^self subclassResponsibility! !
!Refactory.Browser.RBAbstractClass class categoriesForMethods!
icon!public! !
instancesAreClasses!public! !
!

!Refactory.Browser.RBAbstractCondition methodsFor!

validate
	| result |
	result := UI.ValidationResult new.
	self validate: result.
	^result!

validate: aValidationResult
	"Update the <ValidationResult> argument with results from evaluating this condition, answering whether the condition is satisfied."

	^(aValidationResult value: self check) or: [aValidationResult errorMessage: self errorString]! !
!Refactory.Browser.RBAbstractCondition categoriesForMethods!
validate!public! !
validate:!helpers!public! !
!

!Refactory.Browser.RBAbstractCondition class methodsFor!

icon
	^##((TextTileIcon text: '?' fontName: 'Georgia')
		textcolor: Color darkBlue;
		yourself)! !
!Refactory.Browser.RBAbstractCondition class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBClass methodsFor!

icon
	^realClass ifNil: [super icon] ifNotNil: [realClass icon]! !
!Refactory.Browser.RBClass categoriesForMethods!
icon!accessing!public! !
!

!Refactory.Browser.RBClass class methodsFor!

instancesAreClasses
	^true! !
!Refactory.Browser.RBClass class categoriesForMethods!
instancesAreClasses!public! !
!

!Refactory.Browser.RBMetaclass class methodsFor!

icon
	^Metaclass icon!

instancesAreClasses
	^false! !
!Refactory.Browser.RBMetaclass class categoriesForMethods!
icon!public! !
instancesAreClasses!public! !
!

!Refactory.Browser.RBMethod methodsFor!

hasCompilationFailures
	^
	[self parseTree analyze.
	false]
			on: Compiler errorClass
			do: [:ex | ex return: true]
			on: Compiler notificationClass
			do: [:ex | ex resume]!

hasCompilationIssues
	^
	[self parseTree analyze.
	false] on: Compiler notificationClass
			do: [:ex | ex severityClass == Notification ifTrue: [ex resume] ifFalse: [ex return: true]]!

owningPackage
	^compiledMethod isNil 
		ifTrue: [class owningPackage]
		ifFalse: [compiledMethod owningPackage]! !
!Refactory.Browser.RBMethod categoriesForMethods!
hasCompilationFailures!public!testing! !
hasCompilationIssues!public!testing! !
owningPackage!accessing!public! !
!

!Refactory.Browser.RBMethod class methodsFor!

icon
	^CompiledMethod icon! !
!Refactory.Browser.RBMethod class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBModel methodsFor!

allResourceIdentifiers
	^SmalltalkSystem current allResourceIdentifiers select: [:each | environment includesResource: each]!

browseChanges
	Tools.RewriteChangesBrowser showOn: self changes!

methodsThatFailedToCompileIn: aBrowserEnvironment
	| caption env |
	caption := 'Finding methods with compilation failures in <1p>' expandMacrosWith: aBrowserEnvironment.
	env := SmalltalkSystem current
				selectMethods: 
					[:each |
					| modelClass |
					modelClass := self classFor: each methodClass.
					modelClass notNil and: 
							[| modelMethod |
							modelMethod := modelClass methodFor: each selector.
							modelMethod notNil and: [modelMethod hasCompilationFailures]]]
				in: aBrowserEnvironment
				withProgress: caption.
	env label: ('Compilation failures in <1p>' expandMacrosWith: aBrowserEnvironment).
	^env!

methodsWithCompilationIssuesIn: aBrowserEnvironment
	| caption env |
	caption := 'Finding methods with compilation issues in <1p>' expandMacrosWith: aBrowserEnvironment.
	env := SmalltalkSystem current
				selectMethods: 
					[:each |
					| modelClass |
					modelClass := self classFor: each methodClass.
					modelClass notNil and: 
							[| modelMethod |
							modelMethod := modelClass methodFor: each selector.
							modelMethod notNil and: [modelMethod hasCompilationIssues]]]
				in: aBrowserEnvironment
				withProgress: caption.
	env label: ('Compilation issues in <1p>' expandMacrosWith: aBrowserEnvironment).
	^env!

modelClassFor: aBehavior
	^aBehavior classInModel: self! !
!Refactory.Browser.RBModel categoriesForMethods!
allResourceIdentifiers!public! !
browseChanges!helpers!public! !
methodsThatFailedToCompileIn:!browsing!public! !
methodsWithCompilationIssuesIn:!public!searching! !
modelClassFor:!accessing/classes!public! !
!

!Refactory.Browser.RBModel class methodsFor!

icon
	^Smalltalk icon! !
!Refactory.Browser.RBModel class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBNamespaceClass class methodsFor!

icon
	^Namespace icon! !
!Refactory.Browser.RBNamespaceClass class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBRootNamespace class methodsFor!

icon
	^Root icon! !
!Refactory.Browser.RBRootNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.RBSmalltalkNamespace class methodsFor!

icon
	^Smalltalk icon! !
!Refactory.Browser.RBSmalltalkNamespace class categoriesForMethods!
icon!public! !
!

!Refactory.Browser.Refactoring methodsFor!

chooseFrom: aCollection caption: aString
	"Dolphin specific choice prompt"

	^ChoicePrompter choices: aCollection asOrderedCollection caption: aString!

confirm: aString
	"Dolphin specific confirmation prompt"

	^MessageBox confirm: aString caption: self displayString!

maxDetails
	^30!

printNameList: aCollection on: aPuttableStream limit: maxInteger type: aString
	| count |
	count := aCollection size.
	aCollection
		from: 1
		to: (count min: maxInteger)
		do: 
			[:each |
			aPuttableStream
				cr;
				display: each].
	count > maxInteger
		ifTrue: 
			[aPuttableStream
				cr;
				nextPut: $…;
				cr;
				nextPutAll: 'And ';
				print: count - maxInteger;
				nextPutAll: ' further ';
				nextPutAll: aString;
				nextPut: $.]!

prompt: aString
	"Dolphin specific prompt for text input"

	^Prompter prompt: aString caption: self displayString! !
!Refactory.Browser.Refactoring categoriesForMethods!
chooseFrom:caption:!helpers!private! !
confirm:!helpers!public! !
maxDetails!constants!private! !
printNameList:on:limit:type:!helpers!private! !
prompt:!helpers!private! !
!

!Refactory.Browser.Refactoring class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Refactoring.ico'!

renameIcon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'InPlaceRename.ico'! !
!Refactory.Browser.Refactoring class categoriesForMethods!
icon!constants!public! !
renameIcon!constants!public! !
!

!Refactory.Browser.RefactoryClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Refactory.Browser.ClassDetails icon! !
!Refactory.Browser.RefactoryClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RefactoryMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^CompiledMethod icon! !
!Refactory.Browser.RefactoryMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassDelete.ico'! !
!Refactory.Browser.RemoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Remove '.
	classNames size == 1
		ifTrue: 
			[aPuttableStream
				nextPutAll: 'class ';
				display: classNames first]
		ifFalse: 
			[aPuttableStream nextPutAll: 'classes: '.
			classNames do: [:each | aPuttableStream display: each]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionRemoveClass: aRBClass referencedIn: aCollection
	| details response references |
	references := aCollection.
	details := String writeStream.
	details
		nextPutAll: 'Removing the class will leave ';
		nextPutAll: (references size = 1
					ifTrue: ['a dangling reference in this method']
					ifFalse: ['dangling references in these methods']);
		nextPutAll: ' and is potentially unsafe. It is recommended that you first browse these references and remove them before attempting to remove the class again:';
		cr.
	self
		printNameList: (references asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class?' << aRBClass;
				text: 'The class <1p> is referenced from <2d> method<3?:s>.'
							<< {aRBClass. references size. references size = 1};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[| env |
			env := self model environment.
			self openBrowserOn: ((env forMethods: (aCollection collect: [:each | each method]))
						label: 'References to class <1p>, or its name' << aRBClass;
						yourself)].
	^false! !
!Refactory.Browser.RemoveClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveClass:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring methodsFor!

getOptionRemoveVariable: aVariableBinding referencedIn: aCollection
	| args details response |
	args := {aVariableBinding environment.
				aVariableBinding key.
				aCollection size.
				aCollection size == 1}.
	details := String writeStream
				nextPutAll: 'Removing the class variable will leave <4?a dangling reference in this method:dangling references in these methods> and is potentially unsafe. It is recommended that you first browse <4?the reference:these references> and remove <4?it:them> before attempting to remove the variable again:'
							<< args;
				cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class variable?' << args;
				text: 'The class variable <1p>.<2s> is referenced from <3d> method<4?:s>.' << args;
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'References to <1p>.<2s>' << args;
						yourself)].
	^false! !
!Refactory.Browser.RemoveClassVariableRefactoring categoriesForMethods!
getOptionRemoveVariable:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveImportRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove Import ';
		display: import;
		nextPutAll: ' from ';
		display: class! !
!Refactory.Browser.RemoveImportRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'MethodDelete.ico'! !
!Refactory.Browser.RemoveMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	(selectors size == 1 ifTrue: ['Remove <1p>>><4p>'] ifFalse: ['Remove <3p> methods from <1p>'])
		expandMacrosWithArguments: {class. selectors. selectors size. selectors first}
		on: aPuttableStream!

getOptionRemoveDuplicatesWithSupersends: superMessages
	| details |
	details := String writeStream.
	details
		nextPutAll: 'The following methods are equivalent to their superclass implementations, but contain a supersend so removing them might modify behavior.';
		cr.
	self
		printNameList: (superMessages asArray
				collect: [:each | '<1s>>><2p>' << {class unqualifiedName. each}]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	^MessageBox new
		caption: self displayString;
		headline: 'Remove duplicate methods with supersends?';
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		defaultButton: 2;
		detailsText: details contents;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.RemoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveDuplicatesWithSupersends:!options!public! !
!

!Refactory.Browser.RemoveParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove parameter ';
		print: argument;
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.RemoveParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RemoveSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Rename accessors for'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameClassRefactoring methodsFor!

getOptionIgnoreSymbolicClassReferences: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following methods still reference the original unqualified class name symbol ';
		print: oldUnqualified;
		nextPut: $:;
		cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails // 2
		type: 'methods'.
	response := UI.MessageBox new
				caption: self displayString;
				headline: 'Class may have symbolic references.';
				text: 'The original class name ''<1s>'' may still be referenced symbolically in <2d> methods. If you proceed with the class rename these Symbols will not be renamed as it cannot be guaranteed that these are intended as references to the class being renamed.<n><n>It is recommended that you first browse all references to understand the use, and replace any real references to the class with literal BindingReferences.'
							<< {oldUnqualified. aCollection size};
				customButtons: #(#(#yes '&Rename Class') #(#no '&Browse Methods'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self openBrowserOn: ((self model environment forMethods: aCollection)
						label: 'Remaining references to class being renamed from <1p>' << oldUnqualified;
						yourself)].
	^false!

getOptionUpgradeLegacyPackage: aPackage
	| args |
	args := {oldUnqualified. aPackage. newName}.
	^UI.MessageBox new
		caption: self displayString;
		headline: 'Package upgrade required';
		text: 'The class ''<1d>'' is owned by the legacy format package ''<2d>'', which must be upgraded to complete the rename.'
					<< args;
		detailsText: 'Legacy format packages can only be used to save and load classes in the legacy Smalltalk namespace.<n><n>In order to proceed with renaming <1s> to <3s>, it will be necessary to upgrade the package to the new source format that supports namespaces.<n><n>New format packages cannot be loaded into versions of Dolphin prior to 8.x.'
					<< args;
		customButtons: #(#(#yes '&Upgrade Package') #(#no 'Cancel'));
		iconStyle: #warning;
		defaultButton: 2;
		isCancellable: true;
		confirm! !
!Refactory.Browser.RenameClassRefactoring categoriesForMethods!
getOptionIgnoreSymbolicClassReferences:!options!public! !
getOptionUpgradeLegacyPackage:!options!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName;
		nextPutAll: ' (and accessors) to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename ';
		print: oldSelector;
		nextPutAll: ' to ';
		print: newSelector! !
!Refactory.Browser.RenameMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameMethodRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameMethodRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename temp ';
		print: oldName;
		nextPutAll: ' to ';
		print: newName;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.RenameTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameTemporaryRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.SmalllintChecker class methodsFor!

newWithCachingContext
	^self new
		context: SmalllintCachingContext new;
		yourself! !
!Refactory.Browser.SmalllintChecker class categoriesForMethods!
newWithCachingContext!instance creation!public! !
!

!Refactory.Browser.TemporaryToInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert temp ';
		print: temporaryVariableName;
		nextPutAll: ' to inst var of ';
		nextPutAll: class unqualifiedName!

getOptionConvertReadBeforeWritten: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Convert read-before-written temporary?';
		text: '<1p> is read before it is written and if converted to an instance variable it may not be initialized before use.' << aString;
		customButtons: #(#(#yes '&Convert') #(#no '&Don''t Convert'));
		defaultButton: 2;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.TemporaryToInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionConvertReadBeforeWritten:!options!public! !
!

!Refactory.Browser.TransformationRule class methodsFor!

bitLogicElimination
	"Inlining of methods may create redundant bit logic operations where the operation is a no-op or has a constant outcome. This transformation can eliminate some cases."


	^self
		rewrite: #(
			#('0 bitOr: ``@arg' 	"->" 	'``@arg')
			#('0 | ``@arg' 	"->" 	'``@arg')
			#('``@arg bitOr: 0' 	"->" 	'``@arg')
			#('``@arg | 0 ' 	"->" 	'``@arg')

			#('0 bitAnd: ``@arg' 	"->" 	'0')
			#('0 & ``@arg' 	"->" 	'0')
			#('``@arg bitAnd: 0' 	"->" 	'0')
			#('``@arg & 0 ' 	"->" 	'0')
		)			
		methods: false
		name: 'Eliminate redundant bit operations'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

ifElimination
	"Inlining of methods may create unecessary ifTrue:[ifFalse:] statements where the condition
	is a constant boolean value. This transformation is useful for eliminating these."

	^self 
		rewrite: #(#(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After'))
		methods: false
		name: 'Eliminate unnecessary ifTrue:[ifFalse:] conditions'!

renameArgument: beforeString to: afterString
	^Refactory.Browser.TransformationRule new
		name: ('Rename argument <1p> to <2p>' expandMacrosWith: beforeString with: afterString);
		rewriteUsing: (Refactory.Browser.ParseTreeRewriter new
					replaceArgument: beforeString with: afterString;
					replace: beforeString with: afterString;
					yourself);
		yourself! !
!Refactory.Browser.TransformationRule class categoriesForMethods!
bitLogicElimination!public!transformations! !
icon!constants!public! !
ifElimination!public!transformations! !
renameArgument:to:!public! !
!

!Refactory.Browser.VariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName!

displayPrefix
	^self class displayPrefix!

getOptionPullUpNonSharedInstVar: aString
	| with without details max |
	with := OrderedCollection new.
	without := OrderedCollection new.
	class subclasses do: 
			[:each |
			((each directlyDefinesInstanceVariable: variableName) ifTrue: [with] ifFalse: [without]) add: each].
	details := String writeStream.
	details
		print: aString;
		nextPutAll: ' is defined in:';
		cr.
	max := self maxDetails // 2.
	self
		printNameList: with
		on: details
		limit: max
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'But is not defined in:';
		cr.
	self
		printNameList: without
		on: details
		limit: max
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Pull up non-shared instance variable?';
		text: 'Not all subclasses of <1d> have an instance variable named <2p>.<n><n>Do you want pull up this variable anyway?'
					<< {class. aString};
		customButtons: #(#(#yes '&Pull Up') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		isCancellable: true;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.VariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
displayPrefix!displaying!public! !
getOptionPullUpNonSharedInstVar:!options!public! !
!

!Refactory.Browser.VariableRefactoring class methodsFor!

displayPrefix
	^self subclassResponsibility! !
!Refactory.Browser.VariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Tools.ChooseNamespaceDialog class methodsFor!

resource_Refactoring_view
	"Answer the literal data from which the 'Refactoring view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_view)
	"

	^#(#'!!STL' 5 985166 10 #{UI.STBViewProxy} #{UI.DialogView} 34 30 nil nil 8 #(13369344 65536) 416 nil 1245702 #{Graphics.ThemeColor} #dialog nil 167 nil 852998 #{Graphics.Font} nil true 721158 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 918022 #{Graphics.Point} 193 193 nil 416 984838 #{UI.BorderLayout} 1 11 nil 410 #{UI.ReferenceView} 34 14 nil 416 34 2 8 1140850688 131073 640 nil nil nil 7 nil nil nil 640 1376838 1 #{UI.ResourceIdentifier} #{UI.Presenter} #resource_Refactoring_OK_Cancel_button_block nil 1310982 #{Core.MessageSequence} 34 1 1049350 #{Core.MessageSend} #createAt:extent: 34 2 578 21 669 578 689 65 640 1179910 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 78 1 0 0 98 1 0 0 110 1 0 0] 8 #() 578 193 193 nil 27 nil nil 410 #{UI.ReferenceView} 34 14 nil 416 34 2 8 1140850688 132097 944 nil nil nil 7 nil nil nil 944 706 #{Tools.ClassHierarchySelector} #resource_Default_view nil 738 34 1 786 #createAt:extent: 34 2 578 21 21 578 689 639 944 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 10 0 0 0 98 1 0 0 73 1 0 0] 912 928 nil 27 170 192 34 2 944 8 'classSelector' 1180166 #{Graphics.Rectangle} 578 21 21 578 21 11 nil nil nil nil 19321 nil nil nil 578 661 521 1 nil nil 918278 #{Core.Semaphore} nil nil 1 nil 8 1997373888 738 34 2 786 #createAt:extent: 34 2 578 6143 21 578 761 821 416 786 #text: 34 1 8 'Choose Target Namespace…' 416 866 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 123 13 0 0 164 1 0 0] 34 2 944 640 928 nil 27)! !
!Tools.ChooseNamespaceDialog class categoriesForMethods!
resource_Refactoring_view!public!resources-views! !
!

!Tools.ClassBrowserAbstract methodsFor!

abstractInstanceVariables
	"Private - Invoke the 'Abstract Instance Variable' refactoring on the currently selected variables."

	<commandQuerySelector: #queryVariablesCommand:>
	self model abstractInstanceVariables: self variables within: BrowserEnvironment new!

methodRefactoringTool
	^methodBrowserPresenter refactoringTool!

methodsToOverride
	| methods class selectedClass |
	methods := self selectedOverridableMethods.
	methods notEmpty ifTrue: [^methods].
	methods := IdentityDictionary new.
	selectedClass := self actualClass.
	class := selectedClass superclass.
	[class isNil] whileFalse: 
			[class methodDictionary keysAndValuesDo: 
					[:eachSelector :eachMethod |
					(eachSelector first ~~ $_ and: [(eachSelector beginsWith: 'basic') not])
						ifTrue: [methods at: eachSelector put: eachMethod]].
			class := class superclass].
	^(ChoicePrompter multipleChoices: methods keys asSortedCollection
		caption: 'Choose Methods to Override…')
			ifNotNil: [:selectors | selectors collect: [:each | selectedClass lookupMethod: each]]!

overrideMethods
	<commandQuerySelector: #queryOverrideMethods:>
	| stream class changes name methods devsys |
	class := self actualClass.
	stream := String writeStream.
	changes := CompositeRefactoryChange new.
	methods := self methodsToOverride.
	(methods isNil or: [methods isEmpty]) ifTrue: [^self].
	devsys := self developmentSystem.
	methods do: 
			[:each |
			| keywordsAndArgs |
			stream reset.
			keywordsAndArgs := devsys keywordsAndArgsOfMethod: each.
			devsys printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			stream
				crtab;
				nextPutAll: '^super';
				space.
			devsys printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			changes addChange: (AddMethodChange
						compile: stream contents
						in: class
						environment: each environment
						categories: each categories
						package: each owningPackageIfLoose)].
	name := String writeStream.
	name nextPutAll: 'Override '.
	methods size > 1
		ifTrue: 
			[name
				print: methods size;
				nextPutAll: ' methods']
		ifFalse: [name print: methods first].
	changes name: name contents.
	devsys changeManager performChange: changes.
	self selectedMethods: (methodBrowserPresenter methodsPresenter list
				intersection: ((methods collect: [:each | each selector]) asSet
						collect: [:each | class compiledMethodAt: each ifAbsent: nil]))!

protectInstanceVariables
	"Private - Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables."

	<commandQuerySelector: #queryVariablesCommand:>
	self model protectInstanceVariables: self variables!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the currently selected variables."

	<commandQuerySelector: #queryPushDownInstanceVariables:>
	self model pushDownInstanceVariables: self variables!

pushDownMethods
	<acceleratorKey: 'Shift+Ctrl+7'>
	<commandQuerySelector: #queryPushDownMethods:>
	self pushMethods: false!

pushMethods: aBoolean
	| change isShift methods targetClass |
	isShift := Keyboard default isShiftDown.
	methods := self selectedMethods.
	"It is assumed that the methods are all of the same class (the 'push method' commands are disabled if not)"
	targetClass := methods first methodClass.
	targetClass := aBoolean ifTrue: [targetClass superclass] ifFalse: [targetClass subclasses first].
	change := self methodRefactoringTool pushMethods: aBoolean.
	(change isNil or: [isShift not]) ifTrue: [^self].
	methods := (methods asSet
				collect: [:each | targetClass compiledMethodAt: each selector ifAbsent: nil]) asArray.
	self actualClass: methods first methodClass ifAbsent: [^self].
	self selectedMethods: methods!

pushUpMethods
	<acceleratorKey: 'Shift+Ctrl+6'>
	<commandQuerySelector: #queryPushUpMethods:>
self halt.
	self pushMethods: true!

queryOverrideMethods: aCommandQuery
	| class methods |
	methods := self selectedOverridableMethods.
	class := self actualClass.
	aCommandQuery
		isEnabled: class superclass notNil;
		text: (aCommandQuery commandDescription menuText expandMacrosWithArguments: {
							methods isEmpty
								ifTrue: [$…]
								ifFalse: [methods size == 1 ifTrue: [methods first] ifFalse: ['Methods']]
						}
					locale: Locale smalltalk)!

queryPushDownInstanceVariables: aCommandQuery
	| class |
	aCommandQuery isEnabled: ((class := self actualClass) notNil
				and: [class subclasses notEmpty and: [self variables notEmpty]])!

queryPushDownMethods: aCommandQuery
	aCommandQuery isEnabled: (self methodRefactoringTool canPushDownMethods
				and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1])!

queryPushUpMethods: aCommandQuery
	aCommandQuery isEnabled: (self methodRefactoringTool canPushUpMethods
				and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1])!

queryVariablesCommand: aCommandQuery
	aCommandQuery isEnabled: self variables notEmpty!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the currently selected variables."

	<commandQuerySelector: #queryVariablesCommand:>
	self model removeInstanceVariables: self variables within: self searchEnvironment!

renameMethod
	(self chooseMethodForRefactoring: 'Rename Method…') 
		ifNotNil: [:method | self methodRefactoringTool renameMethod: method]!

selectedOverridableMethods
	| class |
	class := self actualClass.
	^self selectedMethods reject: [:each | each methodClass == class]! !
!Tools.ClassBrowserAbstract categoriesForMethods!
abstractInstanceVariables!commands!private!refactoring! !
methodRefactoringTool!commands!private!refactoring! !
methodsToOverride!helpers!private! !
overrideMethods!commands!private!refactoring! !
protectInstanceVariables!commands!private!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
pushDownMethods!commands!public!refactoring! !
pushMethods:!commands!private!refactoring! !
pushUpMethods!commands!public!refactoring! !
queryOverrideMethods:!command queries!private!refactoring! !
queryPushDownInstanceVariables:!command queries!private!refactoring! !
queryPushDownMethods:!command queries!private!refactoring! !
queryPushUpMethods:!command queries!private!refactoring! !
queryVariablesCommand:!command queries!private!refactoring! !
removeInstanceVariables!public!refactoring! !
renameMethod!accessing!private! !
selectedOverridableMethods!accessing!private! !
!

!Tools.ClassBrowserPlugin methodsFor!

developmentSystem
	^SmalltalkSystem current! !
!Tools.ClassBrowserPlugin categoriesForMethods!
developmentSystem!commands!private! !
!

!Tools.ClassSelector methodsFor!

abstractClassVariables
	"Invoke the 'Abstract Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryClassVariablesCommand:>
	(self chooseVariables: true caption: 'Abstract Class Variables…')
		ifNotNil: [:varNames | self developmentSystem abstractClassVariables: varNames within: BrowserEnvironment new]!

abstractInstanceVariables
	"Invoke the 'Abstract Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryInstanceVariablesCommand:>
	(self chooseVariables: false caption: 'Abstract Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem abstractInstanceVariables: varNames within: BrowserEnvironment new]!

abstractVariables
	<commandQuerySelector: #queryVariablesCommand:>
	Sound warningBeep!

addClassVariable
	"Private - Invoke the 'Add Class Variable' refactoring to add a class variable to the
	currently selected class."

	<commandQuerySelector: #queryClassCommand:>
	self developmentSystem addClassVariableTo: self selection!

addImport
	<commandQuerySelector: #queryClassesCommand:>
	self developmentSystem addImportToClasses: self selections!

addInstanceVariable
	"Private - Invoke the 'Add Instance Variable' refactoring to add an instance variable to the
	currently selected class."

	<commandQuerySelector: #queryAddInstanceVariable:>
	self developmentSystem addInstanceVariableTo: self actualClass!

buildInstVarMenu: aMenu selectors: selectors
	"Private - Build a dynamic pull-out menu which lists all of a class' existing inst. var. 
	names so that one or other can be removed, renamed, etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: selectors!

buildPullUpVariablesMenu: aMenu
	| class items |
	aMenu clear.
	class := self actualClass.
	(ClassBuilder isFixedLayout: class)
		ifFalse: 
			[self
				populatePullUpVariableMenu: aMenu
				forClass: class
				command: #pullUpInstanceVariable:into:
				classVariables: false
				ifTooMany: #pullUpInstanceVariables.
			aMenu notEmpty ifTrue: [aMenu addSeparator]].
	self
		populatePullUpVariableMenu: aMenu
		forClass: class instanceClass
		command: #pullUpClassVariable:into:
		classVariables: true
		ifTooMany: #pullUpClassVariables.
	items := aMenu items.
	(items notEmpty and: [items last isDivider]) ifTrue: [aMenu removeItemAt: items size]!

buildVariablesMenu: aMenu instVarSelectors: instVarSelectors classVarSelectors: classVarSelectors 
	"Private - Build a dynamic pull-out menu which lists all of a class' existing 
	instance and class variable names so that one or other can be removed, renamed, 
	etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: instVarSelectors.
	(aMenu notEmpty and: [self selection classPool notEmpty]) ifTrue: [aMenu addSeparator].
	self populateClassVarMenu: aMenu selectors: classVarSelectors!

changeClassNamespace
	<commandQuerySelector: #queryChangeClassNamespace:>
	self developmentSystem changeNamespaceOfClasses: self selections!

classRefactoringsMenu
	<commandQuerySelector: #queryClassesCommand:>
	Sound warningBeep!

cloneClass: aClass under: superClass changes: aCompositeRefactoryChange
	| namespace newName |
	namespace := RBModel new
				changes: aCompositeRefactoryChange;
				yourself.
	newName := aClass asQualifiedReference.
	
	[newName := BindingReference path: (newName path allButLast copyWith: 'CopyOf' , newName path last).
	newName isDefined]
			whileTrue.
	(CopyClassRefactoring
		model: namespace
		clone: aClass
		as: newName pathString
		superclass: superClass) primitiveExecute!

commandQuerySelector: a
	!

convertToSibling
	"Invoke the 'Convert to Sibling' refactoring (inserts a new class as the common superclass of the selected
	class and its current subclasses, copying common methods to the new superclass and adding 
	#subclassResponsibility methods as necessary)."

	<commandQuerySelector: #queryClassCommand:>
	self developmentSystem convertToSibling: self selection!

createClassVariableAccessors
	"Prompt to generate compiled 'get' and 'set' accessor methods for the immediate
	class variables of the selected class."

	<commandQuerySelector: #queryClassVariablesCommand:>
	self createVariableAccessors: true!

createVariableAccessors
	<commandQuerySelector: #queryVariablesCommand:>
	Sound warningBeep!

populateClassVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self selection.
	varNames := class classBindingNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Class Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populateInstVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self actualClass.
	varNames := class instanceVariableNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Instance Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>'
				abortable: true]!

populatePullUpVariableMenu: aMenu forClass: aClass command: commandSymbol classVariables: aBoolean ifTooMany: tooManyCommand
	| pairs |
	pairs := self
				pullUpVariableNamePairs: aBoolean
				for: aClass
				maximum: self maximumVariableMenuEntries.
	pairs isNil
		ifTrue: 
			[aMenu addCommand: tooManyCommand
				description: (aBoolean ifTrue: ['&Class Variable…'] ifFalse: ['&Instance Variable…'])]
		ifFalse: 
			[(pairs
				asSortedArray: [:p1 :p2 | p1 key == p2 key ifTrue: [p1 value < p2 value] ifFalse: [p1 key name < p2 key name]])
					do: 
						[:each |
						| msg varName |
						varName := each value.
						msg := MessageSend
									receiver: self developmentSystem
									selector: commandSymbol
									arguments: {varName. aClass}.
						aMenu addCommand: msg description: each key name , '.' , varName]]!

populateRefactoringMenu: aMenu 
	"Private - If the <Menu> argument is dynamic refactoring menu, then populate it with appropriate
	choices based on the currently selected class."

	| menuName |
	menuName := aMenu name.
	menuName == #pushDownInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#pushDownInstanceVariable:in: #pushDownInstanceVariables)].
	menuName == #createInstanceVariableAccessors 
		ifTrue: 
			[^self buildInstVarMenu: aMenu
				selectors: #(#createInstanceVariableAccessors:in: #createInstanceVariableAccessors)].
	menuName == #abstractInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#abstractInstanceVariable:in: #abstractInstanceVariables)].
	(menuName == #protectInstanceVariables or: [menuName == #protectVariables]) 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#protectInstanceVariable:in: #protectInstanceVariables)].
	"Generic menus that contain both class and inst vars"
	menuName == #removeVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#removeInstanceVariable:from:within: #removeInstanceVariables)
				classVarSelectors: #(#removeClassVariable:from:within: #removeClassVariables)].
	menuName == #renameVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#renameInstanceVariable:in:within: #renameInstanceVariable)
				classVarSelectors: #(#renameClassVariable:in:within: #renameClassVariable)].
	menuName == #pushDownVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#pushDownInstanceVariable:in:within: #pushDownInstanceVariables)
				classVarSelectors: #(#pushDownClassVariable:in:within: #pushDownClassVariables)].
	menuName == #pullUpVariables ifTrue: [^self buildPullUpVariablesMenu: aMenu].
	menuName == #createVariableAccessors 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#createInstanceVariableAccessors:in:within: #createInstanceVariableAccessors)
				classVarSelectors: #(#createClassVariableAccessors:in:within: #createClassVariableAccessors)].
	menuName == #abstractVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#abstractInstanceVariable:in:within: #abstractInstanceVariables)
				classVarSelectors: #(#abstractClassVariable:in:within: #abstractClassVariables)]!

protectInstanceVariables
	"Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryInstanceVariablesCommand:>
	(self chooseVariables: false caption: 'Protect Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem protectInstanceVariables: varNames]!

protectVariables
	<commandQuerySelector: #queryVariablesCommand:>
	Sound warningBeep!

pullUpClassVariables
	"Invoke the 'Pull Up Class Variable' refactoring on the users choice of subclass' class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryPullUpClassVariables:>
	| class pairs |
	class := self selection.
	pairs := self
				pullUpVariableNamePairs: true
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Class Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self developmentSystem.
			pairs do: [:each | devsys pullUpClassVariable: each value into: class]]!

pullUpInstanceVariables
	"Invoke the 'Pull Up Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryPullUpInstanceVariables:>
	| class pairs |
	class := self actualClass.
	pairs := self
				pullUpVariableNamePairs: false
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Instance Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self developmentSystem.
			pairs do: [:each | devsys pullUpInstanceVariable: each value into: class]]!

pullUpVariableNamePairs: aBoolean for: class maximum: anInteger
	| pairs varNames |
	varNames := Set new.
	pairs := OrderedCollection new.
	class allSubclassesDo: 
			[:subclass |
			(aBoolean ifTrue: [subclass classBindingNames] ifFalse: [subclass instanceVariableNames]) do: 
					[:each |
					(varNames includes: each)
						ifFalse: 
							[varNames add: each.
							varNames size > anInteger ifTrue: [^nil].
							pairs add: subclass -> each]]].
	^pairs!

pullUpVariables
	<commandQuerySelector: #queryPullUpVariables:>
	Sound warningBeep!

pushDownClassVariables
	"Invoke the 'Push Down Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryClassVariablesCommand:>
	(self chooseVariables: true caption: 'Push Down Class Variables…')
		ifNotNil: [:varNames | self developmentSystem pushDownInstanceVariables: varNames]!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryPushDownInstanceVariables:>
	(self chooseVariables: false caption: 'Push Down Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem pushDownInstanceVariables: varNames]!

pushDownVariables
	<commandQuerySelector: #queryPushDownVariables:>
	Sound warningBeep!

queryAddInstanceVariable: aCommandQuery
	| class prefix |
	class := self actualClass.
	prefix := (class notNil and: [class isMeta]) ifTrue: ['Class '] ifFalse: [''].
	aCommandQuery
		text: (aCommandQuery commandDescription menuText expandMacrosWithArguments: { prefix }
					locale: Locale smalltalk);
		isEnabled: (class notNil and: [class isPointers])!

queryPullUpClassVariables: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery isEnabled: (class notNil
				and: [class instanceClass allSubclasses anySatisfy: [:each | each classBindingNames notEmpty]])!

queryPullUpInstanceVariables: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery isEnabled: (class notNil
				and: [class allSubclasses anySatisfy: [:each | each instanceVariableNames notEmpty]])!

queryPullUpVariables: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery
		isEnabled: (class notNil and: 
					[| isFixed |
					isFixed := ClassBuilder isFixedLayout: class.
					class allSubclasses anySatisfy: 
							[:each |
							(isFixed not and: [each instanceVariableNames notEmpty])
								or: [each instanceClass classBindingNames notEmpty]]])!

queryPushDownInstanceVariables: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery
		isEnabled: (class notNil and: [class subclasses notEmpty and: [class instanceVariableNames notEmpty]])!

queryPushDownVariables: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery
		isEnabled: (class notNil and: 
					[class subclasses notEmpty
						and: [class instanceVariableNames notEmpty or: [class instanceClass definedBindings notEmpty]]])!

queryRemoveImport: aCommandQuery
	| imports |
	imports := Set new.
	self selections do: [:each | imports addAll: each imports].
	aCommandQuery isEnabled: imports notEmpty!

queryVariablesCommand: aCommandQuery
	| class |
	class := self actualClass.
	aCommandQuery isEnabled: (class notNil
				and: [class instanceVariableNames notEmpty or: [class instanceClass classBindingNames notEmpty]])!

removeClassVariables
	"Invoke the 'Remove Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryClassVariablesCommand:>
	(self chooseVariables: true caption: 'Remove Class Variables…')
		ifNotNil: [:pairs | self developmentSystem removeStaticVariables: pairs within: self searchEnvironment]!

removeDuplicateMethods
	<commandQuerySelector: #queryClassCommand:>
	| class |
	class := self actualClass.
	(self developmentSystem removeMethodsDuplicatedInSuperclassOf: class)
		ifFalse: 
			[MessageBox new
				iconStyle: #notify;
				uniqueId: [self] method;
				isSuppressible: true;
				headline: '<1p> does not duplicate any of its superclass'' methods' << class;
				open]!

removeImport
	<commandQuerySelector: #queryRemoveImport:>
	self developmentSystem removeImportFromClasses: self selections!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	<commandQuerySelector: #queryInstanceVariablesCommand:>
	(self chooseVariables: false caption: 'Remove Instance Variables…')
		ifNotNil: [:varNames | self developmentSystem removeInstanceVariables: varNames within: self searchEnvironment]!

removeVariables
	<commandQuerySelector: #queryVariablesCommand:>
	Sound warningBeep! !
!Tools.ClassSelector categoriesForMethods!
abstractClassVariables!commands!public!refactoring! !
abstractInstanceVariables!commands!public!refactoring! !
abstractVariables!commands!private! !
addClassVariable!commands!private!refactoring! !
addImport!commands!public!refactoring! !
addInstanceVariable!commands!private!refactoring! !
buildInstVarMenu:selectors:!menus!private!refactoring! !
buildPullUpVariablesMenu:!menus!private!refactoring! !
buildVariablesMenu:instVarSelectors:classVarSelectors:!menus!private!refactoring! !
changeClassNamespace!commands!public!refactoring! !
classRefactoringsMenu!commands!public!refactoring! !
cloneClass:under:changes:!private! !
commandQuerySelector:!commands!public!refactoring! !
convertToSibling!commands!public!refactoring! !
createClassVariableAccessors!commands!public!refactoring! !
createVariableAccessors!commands!private! !
populateClassVarMenu:selectors:!menus!private!refactoring! !
populateInstVarMenu:selectors:!menus!private!refactoring! !
populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:!menus!private!refactoring! !
populateRefactoringMenu:!menus!private!refactoring! !
protectInstanceVariables!commands!public!refactoring! !
protectVariables!commands!private! !
pullUpClassVariables!commands!public!refactoring! !
pullUpInstanceVariables!commands!public!refactoring! !
pullUpVariableNamePairs:for:maximum:!menus!private!refactoring! !
pullUpVariables!commands!private! !
pushDownClassVariables!commands!public!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
pushDownVariables!commands!private! !
queryAddInstanceVariable:!command queries!private! !
queryPullUpClassVariables:!command queries!private! !
queryPullUpInstanceVariables:!command queries!private! !
queryPullUpVariables:!command queries!private! !
queryPushDownInstanceVariables:!command queries!private! !
queryPushDownVariables:!command queries!private! !
queryRemoveImport:!command queries!private! !
queryVariablesCommand:!command queries!private! !
removeClassVariables!commands!public!refactoring! !
removeDuplicateMethods!commands!private!refactoring! !
removeImport!commands!public!refactoring! !
removeInstanceVariables!commands!public!refactoring! !
removeVariables!commands!private! !
!

!Tools.CreateSubclassDialog class methodsFor!

resource_Refactoring_view
	"Answer the literal data from which the 'Refactoring view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_view)
	"

	^#(#'!!STL' 5 985166 10 #{UI.STBViewProxy} #{UI.DialogView} 34 30 nil nil 8 #(13369344 65536) 416 nil 1245702 #{Graphics.ThemeColor} #dialog nil 167 nil 852998 #{Graphics.Font} nil true 721158 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 918022 #{Graphics.Point} 193 193 nil 416 984838 #{UI.BorderLayout} 1 11 nil 410 #{UI.ReferenceView} 34 14 nil 416 34 2 8 1140850688 131073 640 nil nil nil 7 nil nil nil 640 1376838 1 #{UI.ResourceIdentifier} #{UI.Presenter} #resource_Refactoring_OK_Cancel_button_block nil 1310982 #{Core.MessageSequence} 34 1 1049350 #{Core.MessageSend} #createAt:extent: 34 2 578 25 803 578 841 65 640 1179910 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 12 0 0 0 145 1 0 0 176 1 0 0 177 1 0 0] 8 #() 578 193 193 nil 27 nil nil 410 #{UI.ContainerView} 34 15 nil 416 34 2 8 1140850688 131073 944 nil nil nil 7 nil nil nil 944 610 1 1 410 #{UI.ContainerView} 34 15 nil 944 34 2 8 1140850688 131073 1024 nil nil nil 7 nil nil nil 1024 1048838 #{UI.FramingLayout} 170 176 34 18 410 #{UI.ContainerView} 34 15 nil 1024 34 2 8 1140850688 131073 1152 nil nil nil 7 nil nil nil 1152 1090 170 176 34 8 410 #{UI.CheckBox} 34 16 nil 1152 34 2 8 1409363203 1 1264 918598 2 #{UI.ValueHolder} nil nil 1572870 #{Kernel.NeverSearchPolicy} false nil nil 7 nil nil nil 1264 nil 8 1824603504 1049094 #{UI.NullConverter} nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 185 37 578 177 45 1264 786 #text: 34 1 8 '&Indexable?' 1264 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 92 0 0 0 18 0 0 0 180 0 0 0 40 0 0 0] 8 #() 928 nil 27 1378374 2 #{UI.FramingConstraints} 1377286 #{UI.FramingCalculation} #fixedPreviousRight 1 1666 #fixedViewLeft 177 1666 #fixedPreviousTop 1 1666 #fixedViewTop 45 410 #{UI.CheckBox} 34 16 nil 1152 34 2 8 1409363203 1 1744 1330 nil nil 1376 false nil nil 7 nil nil nil 1744 nil 8 1824603504 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 361 37 578 111 45 1744 786 #text: 34 1 8 '&Bytes?' 1744 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 180 0 0 0 18 0 0 0 235 0 0 0 40 0 0 0] 8 #() 928 nil 27 1634 1680 1 1696 111 1712 1 1728 45 410 #{UI.CheckBox} 34 16 nil 1152 34 2 8 1409363203 1 2064 1330 nil nil 1376 false nil nil 7 nil nil nil 2064 nil 8 1824603504 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 25 37 578 161 45 2064 786 #text: 34 1 8 '&Abstract?' 2064 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 12 0 0 0 18 0 0 0 92 0 0 0 40 0 0 0] 8 #() 928 nil 27 1634 1666 #fixedParentLeft 25 1696 161 1666 #fixedParentTop 37 1728 45 410 #{UI.GroupBox} 34 14 nil 1152 34 2 8 1140981767 1 2416 nil nil nil 7 nil nil nil 2416 nil 8 1824603504 738 34 2 786 #createAt:extent: 34 2 578 1 1 578 841 101 2416 786 #text: 34 1 8 'Attributes' 2416 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 164 1 0 0 50 0 0 0] 8 #() 928 nil 27 1634 2384 1 1666 #fixedParentRight 1 2400 1 1666 #fixedParentBottom 1 170 192 34 6 1264 8 'isVariable' 1744 8 'isBytes' 2064 8 'isNonInstantiable' nil 738 34 1 786 #createAt:extent: 34 2 578 1 167 578 841 101 1152 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 83 0 0 0 164 1 0 0 133 0 0 0] 34 4 2064 1264 1744 2416 928 nil 27 1634 2384 1 2704 1 1666 #fixedPreviousBottom 13 1728 101 410 #{UI.StaticText} 34 16 nil 1024 34 2 8 1140850944 1 2992 nil nil nil 7 nil nil nil 2992 nil 8 1824808112 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 1 5 578 201 45 2992 786 #text: 34 1 8 'New &class name:' 2992 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 2 0 0 0 100 0 0 0 24 0 0 0] 8 #() 928 nil 27 1634 2384 1 1696 201 2400 5 1728 45 410 #{UI.TextEdit} 34 16 nil 1024 34 2 8 1140916352 1025 3296 nil 917510 #{Graphics.Color} #default nil 7 nil nil nil 3296 nil 8 1824596208 1410 nil nil 5 738 34 2 786 #createAt:extent: 34 2 578 201 1 578 587 45 3296 786 #setMarginWidths: 34 1 8 #(3 3) 3296 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 100 0 0 0 0 0 0 0 137 1 0 0 22 0 0 0] 8 #() 928 nil 27 1634 1680 1 2704 -53 1712 -3 1728 45 410 #{UI.StaticText} 34 16 nil 1024 34 2 8 1140850944 1 3632 nil nil nil 7 nil nil nil 3632 nil 8 1824808112 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 1 117 578 201 45 3632 786 #text: 34 1 8 '&Superclass:' 3632 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 58 0 0 0 100 0 0 0 80 0 0 0] 8 #() 928 nil 27 1634 2384 1 1696 201 2976 17 1728 45 410 #{UI.StaticText} 34 16 nil 1024 34 2 8 1140850944 1 3936 nil nil nil 7 nil nil nil 3936 nil 8 1824808112 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 1 61 578 201 45 3936 786 #text: 34 1 8 '&Namespace:' 3936 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 30 0 0 0 100 0 0 0 52 0 0 0] 8 #() 928 nil 27 1634 2384 1 1696 201 2976 17 1728 45 410 #{UI.TextEdit} 34 16 nil 1024 34 2 8 1140850816 262145 4240 nil nil nil 7 nil nil nil 4240 nil 8 1824596208 1410 nil nil 7 738 34 2 786 #createAt:extent: 34 2 578 201 115 578 587 41 4240 786 #setMarginWidths: 34 1 8 #(3 3) 4240 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 100 0 0 0 57 0 0 0 137 1 0 0 77 0 0 0] 8 #() 928 nil 27 1634 1680 1 2704 -53 1712 -1 1728 41 410 #{UI.PushButton} 34 20 nil 1024 34 2 8 1140924416 1 4544 nil 3376 nil 7 nil nil nil 4544 nil 8 1824603504 1377606 4 #{UI.CommandDescription} #chooseNamespace 8 '…' 1 1 nil nil false nil nil nil 738 34 3 786 #createAt:extent: 34 2 578 801 61 578 41 41 4544 786 #isEnabled: 8 #(false) 4544 786 #text: 34 1 8 '…' 4544 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 144 1 0 0 30 0 0 0 164 1 0 0 50 0 0 0] 8 #() 928 nil 29 1634 1680 15 1696 41 1712 1 1728 41 410 #{UI.TextEdit} 34 16 nil 1024 34 2 8 1140850816 262145 4912 nil 3376 nil 7 nil nil nil 4912 nil 8 1824596208 1410 nil nil 7 738 34 2 786 #createAt:extent: 34 2 578 201 61 578 587 41 4912 786 #setMarginWidths: 34 1 8 #(3 3) 4912 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 100 0 0 0 30 0 0 0 137 1 0 0 50 0 0 0] 8 #() 928 nil 27 1634 1680 1 2704 -53 1712 1 1728 41 410 #{UI.PushButton} 34 20 nil 1024 34 2 8 1140924416 1 5216 nil 3376 nil 7 nil nil nil 5216 nil 8 1824603504 4626 #chooseSuperclass 8 '…' 1 1 nil nil false nil nil nil 738 34 3 786 #createAt:extent: 34 2 578 801 115 578 41 41 5216 786 #isEnabled: 8 #(false) 5216 786 #text: 34 1 8 '…' 5216 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 144 1 0 0 57 0 0 0 164 1 0 0 77 0 0 0] 8 #() 928 nil 29 1634 1680 15 1696 41 1712 1 1728 41 170 192 34 10 1152 8 'attributes' 3296 8 'className' 4240 8 'superclass' 4544 8 'chooseNamespace' 4912 8 'namespace' nil 738 34 1 786 #createAt:extent: 34 2 578 1 1 578 841 279 1024 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 164 1 0 0 139 0 0 0] 34 9 2992 3296 3936 4912 4544 3632 4240 5216 1152 928 nil 27 nil nil nil 410 #{UI.ContainerView} 34 15 nil 944 34 2 8 1140850688 131073 5824 nil nil nil 7 nil nil nil 5824 1376774 #{UI.ProportionalLayout} 170 176 912 false 170 192 34 2 410 #{UI.ListView} 34 45 nil 5824 34 2 8 1140953161 1025 5968 787270 2 #{UI.ListModel} 138 144 912 nil 1769478 #{Kernel.IdentitySearchPolicy} 3376 nil 7 nil nil nil 5968 nil 8 1824663824 786950 #{Core.Message} #displayString 8 #() 6130 #iconImageIndex 6160 1639750 1 #{Graphics.IconImageManager} nil nil nil 578 65 65 nil nil 138 144 34 1 1117254 5 #{UI.ListViewColumn} 8 'Subclasses' 409 #left 6144 6130 #<= 8 #() nil nil 5968 nil 3 nil nil #report 8 #() nil 133185 nil 1 nil nil nil nil 1 nil nil nil nil nil nil nil nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 425 7 578 417 489 5968 786 #text: 34 1 8 'Subclasses' 5968 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 212 0 0 0 3 0 0 0 164 1 0 0 247 0 0 0] 8 #() 928 nil 35 8 'subclasses' 1180166 #{Graphics.Rectangle} 578 1 7 578 1 1 738 34 1 786 #createAt:extent: 34 2 578 1 279 578 841 495 5824 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 139 0 0 0 164 1 0 0 130 1 0 0] 34 3 410 #{UI.ContainerView} 34 15 nil 5824 34 2 8 1140850688 131073 6784 nil nil nil 23 nil nil nil 6784 610 1 1 410 #{UI.CheckBox} 34 16 nil 6784 34 2 8 1140924419 1 6864 1330 nil false 1835526 #{Kernel.PluggableSearchPolicy} 6130 #= 8 #() 6130 #hash 8 #() false nil nil 7 nil nil nil 6864 nil 8 1824603504 1410 nil nil nil 738 34 2 786 #createAt:extent: 34 2 578 1 -1 578 415 51 6864 786 #text: 34 1 8 '&Packaged?' 6864 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 255 255 255 255 207 0 0 0 24 0 0 0] 8 #() 928 nil 27 nil nil nil 410 #{UI.ReferenceView} 34 14 nil 6784 34 2 8 1140850688 131073 7264 nil nil nil 7 nil nil nil 7264 706 #{Tools.PackageSelector} #resource_Choice_view nil 738 34 1 786 #createAt:extent: 34 2 578 1 49 578 415 441 7264 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 24 0 0 0 207 0 0 0 244 0 0 0] 912 928 nil 27 170 192 34 4 6864 8 'setPackage' 7264 8 'package' 6578 578 1 -1 578 1 1 738 34 1 786 #createAt:extent: 34 2 578 1 7 578 415 489 6784 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 3 0 0 0 207 0 0 0 247 0 0 0] 34 2 6864 7264 928 nil 27 410 #{UI.Splitter} 34 12 nil 5824 34 2 8 1140850688 1 7728 nil nil nil 519 nil nil nil 1707078 1 #{UI.DraggableViewInteractor} 7728 nil 1 #left nil nil nil 578 1 1 578 9 9 nil 7824 nil 738 34 1 786 #createAt:extent: 34 2 578 415 7 578 11 489 7728 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 207 0 0 0 3 0 0 0 212 0 0 0 247 0 0 0] 8 #() 928 nil 27 5968 928 nil 27 170 192 912 6578 578 1 1 578 1 1 738 34 1 786 #createAt:extent: 34 2 578 25 21 578 841 773 944 866 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 12 0 0 0 10 0 0 0 176 1 0 0 140 1 0 0] 34 2 1024 5824 928 nil 27 170 192 912 6578 578 25 21 578 25 17 nil nil nil nil 21059 nil nil nil 578 621 581 1 nil nil 918278 #{Core.Semaphore} nil nil 1 nil 8 1997373888 738 34 2 786 #createAt:extent: 34 2 578 6143 21 578 921 961 416 786 #text: 34 1 8 'Create Class…' 416 866 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 203 13 0 0 234 1 0 0] 34 2 944 640 928 nil 27)! !
!Tools.CreateSubclassDialog class categoriesForMethods!
resource_Refactoring_view!public!resources-views! !
!

!Tools.Debugger methodsFor!

canMoveMethods
	#todo.	"Not currently supported in the debugger because it rewrites the caller, which complicates the unwind"
	^false!

hasRefactorableMethodSelected
	^self isRunning not and: 
			[| method |
			method := self selectedMethod.
			method notNil and: [method isUnbound not and: [self parseTree notNil]]]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	aMonadicValuable value: self selectedMethod.
	self selectedMethod isUnbound ifTrue: [self restartMethod]!

performMethodRenameRefactoring: aMonadicValuable 
	| method home sender refactoring |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := aMonadicValuable value: method.
	refactoring isNil ifTrue: [^self].
	"Since the method of the selected frame has been renamed, the sending frame's method will
	have been rewritten, therefore we need to restart the sender frame."
	home := self findHomeFrame: self frame.
	home isNil ifTrue: [^self].
	sender := home sender.
	(sender notNil and: [sender isRestartable]) ifTrue: [self restartMethodFrame: sender]! !
!Tools.Debugger categoriesForMethods!
canMoveMethods!commands!private!refactoring! !
hasRefactorableMethodSelected!public!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
!

!Tools.MethodBrowser methodsFor!

canMoveMethods
	^self hasRefactorableMethodSelected!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected and: [self parseTree notNil]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethod!

performMethodRenameRefactoring: aMonadicValuable
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	| refactoring method |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := sourcePresenter executeRefactoring: aMonadicValuable with: method.
	refactoring isNil ifTrue: [^self].
	method := (method ifNil: [self parseContext methodClass] ifNotNil: [method methodClass])
				compiledMethodAt: refactoring newSelector
				ifAbsent: nil.
	(method notNil and: [self filter value: method]) ifTrue: [self selectMethod: method]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !
!Tools.MethodBrowser categoriesForMethods!
canMoveMethods!helpers!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!helpers!private!refactoring! !
!

!Tools.MethodWorkspace methodsFor!

canRefactor
	^self isEditable and: 
			[self isModified not and: 
					[self developmentSystem canRefactor 
						and: [parentPresenter notNil and: [parentPresenter hasRefactorableMethodSelected]]]]!

executeRefactoring: aMonadicValuable
	^aMonadicValuable on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

executeRefactoring: aMonadicValuable with: anObject
	^[aMonadicValuable value: anObject]
		on: OperationAborted
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			nil]
		on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

fontOfStyle: style 
	| font |
	font := style fontName ifNil: [view actualFont copy] ifNotNil: [:face | Font name: face].
	style restyleFont: font.
	^font!

performCodeRefactoring: refactoringOperation 
	self 
		performMethodRefactoring: [:method | refactoringOperation value: method value: self selectedNode]!

performMethodRefactoring: aMonadicValuable 
	^parentPresenter performMethodRefactoring: aMonadicValuable!

performMethodRenameRefactoring: aBlockClosure 
	^parentPresenter performMethodRenameRefactoring: aBlockClosure!

renameVariable: aStVariableNode operation: operationBlock validationBlock: validationBlock
	| name range style editor font zoom newName |
	range := aStVariableNode sourceInterval.
	name := self plainTextRange: range.
	self assert: [aStVariableNode name = name].
	editor := InplaceTextEditor createOn: name asValue.
	editor validater: 
			[:candidateName |
			"If the name is unchanged, treat as valid and ignore later"
			candidateName = name
				ifTrue: [ValidationResult new]
				ifFalse: 
					[| result |
					result := validationBlock value: candidateName.
					result hint ifNotNil: [:ex | self errorModel value: ex].
					result]].
	editor textRectangle: (view boundingRectangleOfTextRange: range).
	"Set the same font as the existing text so there is no visible 'jump' - we need to account for any zooming too"
	style := view styleAt: range start.
	font := self fontOfStyle: style.
	zoom := view zoomLevel.
	zoom = 0
		ifFalse: 
			[| points |
			points := font pointSize.
			font := font copy.
			font pointSize: points + zoom].
	editor font: font.
	newName := view hideCaretWhile: [editor showModal].
	self errorModel value: nil.
	(newName isNil or: [newName = name])
		ifFalse: [self performMethodRefactoring: [:method | operationBlock value: newName]]! !
!Tools.MethodWorkspace categoriesForMethods!
canRefactor!public!refactoring!testing! !
executeRefactoring:!helpers!private!refactoring! !
executeRefactoring:with:!helpers!private!refactoring! !
fontOfStyle:!operations!private!refactoring! !
performCodeRefactoring:!helpers!private!refactoring! !
performMethodRefactoring:!helpers!private!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
renameVariable:operation:validationBlock:!operations!private!refactoring! !
!

!Tools.PackageBrowserShell methodsFor!

addImport
	<commandQuerySelector: #queryHasClassesSelected:>
	self developmentSystem addImportToClasses: self selectedClasses!

addParameter
	"Private - Command to invoke the Add Parameter to Method refactoring, prompting the user for 
	the selector of the method to which the parameter is added, and constrained to operate
	only within the selected packages."

	<commandQuerySelector: #queryHasPackages:>
	(self chooseMethodForRefactoring: 'Add Parameter in Package(s)…') 
		ifNotNil: [:method | self addParameterTo: method]
!

addParameterTo: aCompiledMethod
	self model addParameterToMethod: aCompiledMethod inPackages: self packages!

addParameterToMethod
	"Private - 'Loose Methods' card context menu command to invoke the 
	'Add Parameter to Method refactoring' against a selected loose method, 
	constrained within the selected packages."

	<commandQuerySelector: #queryHasMethodSelected:>
	self addParameterTo: self selectedMethod!

changeClassNamespace
	<commandQuerySelector: #queryHasClassesSelected:>
	self developmentSystem changeNamespaceOfClasses: self selectedClasses!

chooseMethodsForRefactoring: aString
	| selector methods definitions searchEnv |
	searchEnv := self searchEnvironment.
	methods := self selectedMethods.
	methods isEmpty ifFalse: [^searchEnv forMethods: methods].
	selector := self model chooseSelectorInEnvironment: searchEnv caption: aString.
	selector isNil ifTrue: [^searchEnv forMethods: #()].
	definitions := searchEnv definitionsOf: selector.
	definitions isEmpty
		ifTrue: 
			[MessageBox
				errorMsg: ('There are no definitions of <1p> in the selected package(s).' expandMacrosWith: selector)].
	^definitions!

classRefactoringsMenu
	<commandQuerySelector: #queryHasPackages:>
	Sound warningBeep!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected!

methodRefactoringsMenu
	<commandQuerySelector: #queryHasPackages:>
	Sound warningBeep!

newMethodNamePrompter: aCompiledMethod caption: aString allowExisting: aBoolean
	| methodName |
	methodName := ScopedMethodName fromMethod: aCompiledMethod.
	methodName packages: self packages.
	^self developmentSystem
		newMethodNamePrompter: methodName
		caption: aString
		allowExisting: aBoolean!

onClass: aClass renameTo: aString accept: booleanValue
	"Private - The user has initiated a rename of the class, aClass, by editing the label in the class
	tree. Ask the user to confirm the action, and if so queue a deferred action to perform the
	actual rename."

	"Implementation Notes: We don't set the booleanValue holder to true, because the rename may not work."

	| prompter |
	(aString isEmpty or: [aClass fullName = aString])
		ifTrue: 
			[booleanValue value: false.
			^self].
	prompter := self developmentSystem confirmRenameClass: aClass to: aString.
	prompter confirm ifFalse: [^self].
	"Queue deferred action as we can't delete the old item now while still in use (causes GPF in TreeView)"
	
	[self
		onRenameClass: aClass
		to: aString
		showChanges: prompter isChecked]
			postToMessageQueue!

onRenameClass: aClass to: aString showChanges: aBoolean
	"Private - The class, aClass, has been renamed by the user to, text, by editing the label
	in the classes presenter and subsequently confirmed. Ask the receiver's
	model to actually rename the class, converting any exception raised to a
	friendlier message box."

	
	[Cursor wait showWhile: 
			[self developmentSystem
				renameClass: aClass
				to: aString
				showChanges: aBoolean]]
			on: Refactoring abortSignal
			do: 
				[:ex |
				"Cancelled by user"
				self statusModel value: ex]
			on: Error
			do: [:e | e okCancel]!

parseTree
	^self selectedMethod ifNotNil: [:method | Parser parseExistingMethodNoError: method]!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	^aMonadicValuable value: self selectedMethod!

performMethodsRefactoring: aMonadicValuable name: aString
	| methods |
	methods := self chooseMethodsForRefactoring: '<1s> from Package(s)…' << aString.
	methods isEmpty ifTrue: [^nil].
	^[aMonadicValuable value: methods allMethods] on: Notification
		do: 
			[:ex |
			statusModel value: ex.
			ex resume]!

promptForMethodName: aCompiledMethod caption: aString allowExisting: aBoolean
	^(self
		newMethodNamePrompter: aCompiledMethod
		caption: aString
		allowExisting: aBoolean) showModal!

queryHasClassesSelected: aCommandQuery
	aCommandQuery isEnabled: classesPresenter hasSelection!

queryHasClassSelected: aCommandQuery
	aCommandQuery isEnabled: self hasClassSelected!

queryHasMethodSelected: aCommandQuery
	aCommandQuery isEnabled: self hasMethodSelected!

queryHasMethodsSelected: aCommandQuery
	aCommandQuery isEnabled: self selectedMethods notEmpty!

queryRemoveParameter: aCommandQuery
	| method |
	method := self selectedMethod.
	aCommandQuery isEnabled: (self hasPackages and: [method notNil and: [method argumentCount > 0]])!

removeMethod
	"Private - Prompt the user for a selector and invoke the 'Safe Remove Method' refactoring to 
	remove the specified methods from the system if defined but not referenced from within 
	any of the selected packages ((i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	"Implemementation Note: This command implementation is used only if there are no 
	methods selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	<commandQuerySelector: #queryHasMethodsSelected:>
	| methods |
	methods := self chooseMethodsForRefactoring: 'Safe Remove Methods from Package(s)…'.
	methods isEmpty
		ifFalse: 
			[self model
				basicRemoveMethodsIn: methods
				within: self selectionEnvironment
				showChanges: false]!

removeMethods
	"Private - 'Loose Methods' card context menu command to invoke the 'Safe Remove Method' 
	refactoring. Removes the selected methods from the system if not referenced from within any 
	of the selected packages (i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	| mb |
	mb := MessageBox new
				headline: 'Remove unreferenced loose methods?';
				defaultButton: 2;
				customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
				isCancellable: true;
				checkboxText: self developmentSystem showChangesText;
				yourself.
	(mb
		confirm: 'The selected methods will be removed if unreferenced from the selected packages. This may not preserve behaviour if the methods are referenced from other packages.')
			ifTrue: 
				[self model
					basicRemoveMethods: self selectedMethods
					within: self selectionEnvironment
					showChanges: mb isChecked]!

removeParameter
	"Private - Command to invoke the Remove Parameter to Method refactoring, but constrained to operate
	only within the selected packages."

	<commandQuerySelector: #queryHasPackages:>
	| method ast arg |
	method := self chooseMethodForRefactoring: 'Remove Parameter in Package(s)…'.
	method isNil ifTrue: [^self].
	ast := method parseTreeNoError.
	ast isNil ifTrue: [^self].
	arg := ChoicePrompter choices: ast argumentNames
				caption: 'Remove Parameter from <1p> in Package(s)…' << method selector.
	arg notNil ifTrue: [methodRefactoringTool removeParameter: arg from: method]!

removeParameterMenu
	<commandQuerySelector: #queryRemoveParameter:>
	Sound warningBeep!

renameClass
	"Private - Initiate in-place label edit for the selected class."

	<commandQuerySelector: #queryHasClassSelected:>
	classesPresenter view editSelectionLabel!

renameLooseMethod
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method' refactoring against the selected loose method, but configured to rename 
	only within selected packages."

	methodRefactoringTool renameMethod!

renameLooseMethodReferences
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method References' refactoring against the selected loose method, but configured to rename 
	references only within selected packages."

	self renameMethodReferences: self selectedMethod!

renameMethod
	"Private - Initiate a 'Rename' method refactoring against the selected method,
	but configured to rename only within the selected packages."

	"Implemementation Note: This command implementation is used if there is not exactly one
	method selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	<commandQuerySelector: #queryHasPackages:>
	(self chooseMethodForRefactoring: 'Rename Method in Package(s)…') 
		ifNotNil: [:method | methodRefactoringTool renameMethod: method]!

renameMethodReferences: aCompiledMethod
	| methodName prompter |
	prompter := self
				newMethodNamePrompter: aCompiledMethod
				caption: 'Rename References to <1p> in Package(s)…' << aCompiledMethod selector
				allowExisting: true.
	methodName := prompter showModal.
	methodName notNil
		ifTrue: 
			[self model
				renameMethodReferences: aCompiledMethod
				to: methodName
				showChanges: prompter showChanges]! !
!Tools.PackageBrowserShell categoriesForMethods!
addImport!commands!public!refactoring! !
addParameter!commands!private!refactoring! !
addParameterTo:!private!refactoring! !
addParameterToMethod!commands!public!refactoring! !
changeClassNamespace!commands!public!refactoring! !
chooseMethodsForRefactoring:!private!refactoring! !
classRefactoringsMenu!commands!public!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
methodRefactoringsMenu!commands!public!refactoring! !
newMethodNamePrompter:caption:allowExisting:!helpers!private!refactoring! !
onClass:renameTo:accept:!event handling!private! !
onRenameClass:to:showChanges:!event handling!private! !
parseTree!commands!private! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!private! !
promptForMethodName:caption:allowExisting:!helpers!private!refactoring! !
queryHasClassesSelected:!command queries!commands!private!refactoring! !
queryHasClassSelected:!command queries!commands!private!refactoring! !
queryHasMethodSelected:!command queries!commands!private!refactoring! !
queryHasMethodsSelected:!command queries!commands!private!refactoring! !
queryRemoveParameter:!command queries!commands!private!refactoring! !
removeMethod!commands!public!refactoring! !
removeMethods!commands!public!refactoring! !
removeParameter!commands!private!refactoring! !
removeParameterMenu!commands!public!refactoring! !
renameClass!public! !
renameLooseMethod!commands!private!refactoring! !
renameLooseMethodReferences!commands!private!refactoring! !
renameMethod!commands!public!refactoring! !
renameMethodReferences:!operations!private!refactoring! !
!

!Tools.PackageSelector methodsFor!

moveAllTempsToInnerScope
	(MessageBox new
		headline: 'Move All Temps to Inner Scope?';
		confirm: 'This refactoring will move all temporaries in all methods in the selected package(s) into the tightest scope that contains both the variable assignment and references. Any unreferenced temporaries will be removed.

Are you sure that you would like to proceed?')
			ifTrue: [self developmentSystem moveAllTempsToInnerScope: self selectionEnvironment]!

queryPackageRefactoring: aCommandQuery
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| canRefactor |
	canRefactor := self developmentSystem canRefactor and: [self hasPackages].
	aCommandQuery isEnabled: canRefactor!

removeDuplicateMethods
	<commandQuerySelector: #queryPackageRefactoring:>
	| count pkgs |
	pkgs := self packages.
	count := pkgs inject: 0 into: [:sum :eachPackage | sum + eachPackage classNames size].
	(ProgressDialog operation: 
			[:progress |
			| i devsys |
			i := 0.
			devsys := self developmentSystem.
			pkgs do: 
					[:eachPackage |
					progress text: eachPackage name.
					eachPackage classes do: 
							[:eachClass |
							i := i + 1.
							progress value: i * 100 // count.
							devsys removeMethodsDuplicatedInSuperclassOf: eachClass]]])
		caption: 'Remove Methods Duplicating Superclass'' from Package(s)…';
		showModal! !
!Tools.PackageSelector categoriesForMethods!
moveAllTempsToInnerScope!commands!private!refactoring! !
queryPackageRefactoring:!commands!private!refactoring! !
removeDuplicateMethods!development!private! !
!

!Tools.SmalltalkToolShell methodsFor!

chooseMethodForRefactoring: aString 
	^self developmentSystem chooseMethodFromEnvironment: self selectionEnvironment caption: aString! !
!Tools.SmalltalkToolShell categoriesForMethods!
chooseMethodForRefactoring:!private!refactoring! !
!

!UI.Dialog methodsFor!

validationDwell
	"The <Duration> to wait after the user has stopped typing before re-validating and possibly showing a hint bubble."

	^1 seconds! !
!UI.Dialog categoriesForMethods!
validationDwell!constants!public! !
!

!UI.Presenter class methodsFor!

resource_Refactoring_OK_Cancel_button_block
	"Answer the literal data from which the 'Refactoring OK Cancel button block' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Refactoring_OK_Cancel_button_block)
	"

	^#(#'!!STL' 5 985166 10 #{UI.STBViewProxy} #{UI.ContainerView} 34 15 nil nil 34 2 8 1140850688 131073 416 nil nil nil 7 nil nil nil 416 984838 #{UI.BorderLayout} 1 1 nil nil 410 #{UI.ContainerView} 34 15 nil 416 34 2 8 1409286144 131073 512 nil nil nil 7 nil nil nil 512 852806 1 #{UI.FlowLayout} 17 17 21 170 192 8 #() 1180166 #{Graphics.Rectangle} 918022 #{Graphics.Point} 11 11 674 1 1 1310982 #{Core.MessageSequence} 34 1 1049350 #{Core.MessageSend} #createAt:extent: 34 2 674 561 1 674 341 61 512 1179910 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 24 1 0 0 0 0 0 0 194 1 0 0 30 0 0 0] 34 2 410 #{UI.PushButton} 34 20 nil 512 34 2 8 1141055488 1 912 nil nil nil 7 nil nil nil 912 nil 8 1819032944 1377606 4 #{UI.CommandDescription} #ok 8 'OK' 1 1 nil nil true nil nil nil 722 34 2 770 #createAt:extent: 34 2 674 25 11 674 151 47 912 770 #text: 34 1 8 'OK' 912 850 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 12 0 0 0 5 0 0 0 87 0 0 0 28 0 0 0] 8 #() 674 193 193 nil 29 410 #{UI.PushButton} 34 20 nil 512 34 2 8 1140924416 1 1248 nil nil nil 7 nil nil nil 1248 nil 8 1819032944 994 #cancel 8 'Cancel' 1 1 nil nil false nil nil nil 722 34 2 770 #createAt:extent: 34 2 674 191 11 674 151 47 1248 770 #text: 34 1 8 'Cancel' 1248 850 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 95 0 0 0 5 0 0 0 170 0 0 0 28 0 0 0] 8 #() 1232 nil 29 1232 nil 27 410 #{UI.CheckBox} 34 16 nil 416 34 2 8 1409363203 1 1552 918598 2 #{UI.ValueHolder} nil nil 1572870 #{Kernel.NeverSearchPolicy} false 917510 #{Graphics.Color} #transparent nil 519 nil nil nil 1552 nil 8 1819032944 1049094 #{UI.NullConverter} nil nil nil 722 34 2 770 #createAt:extent: 34 2 674 1 1 674 339 61 1552 770 #text: 34 1 8 'Show proposed changes?' 1552 850 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 169 0 0 0 30 0 0 0] 8 #() 1232 nil 27 nil 170 192 34 2 1552 8 'showChanges' nil 722 34 1 770 #createAt:extent: 34 2 674 6143 21 674 901 61 416 850 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 193 13 0 0 40 0 0 0] 34 2 512 1552 1232 nil 27)! !
!UI.Presenter class categoriesForMethods!
resource_Refactoring_OK_Cancel_button_block!public!resources-views! !
!

"End of package definition"!

