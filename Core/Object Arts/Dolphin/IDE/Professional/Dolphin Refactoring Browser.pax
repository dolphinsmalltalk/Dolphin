| package |
package := Package name: 'Dolphin Refactoring Browser'.
package paxVersion: 2.1;
	environmentName: #{Tools};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Refactoring Browser Native UI Integration
Copyright (c) Object Arts Ltd, 2001-2009.

This package augments the native Dolphin development system browsers to add refactoring capabilities. The refactorings themselves are implemented by the Refactory refactoring engine, originally ported to Dolphin at Camp Smalltalk 1 in San Diego by Andy Bower and Blair McGlashan with the assistance of John Brant and Don Roberts. We would also like to acknowledge the contribution of Donald McQueen, who pioneered the way with his Refactoring Browser add-on for Dolphin 3.x and 4.x.

Refactoring operations are supported by the Debugger and all the Dolphin browsers. The Debugger and Method Browser support the Code and Method refactorings only, with the Class Hierarchy and System browser supporting all refactorings, including those which operate on classes. The Package Browser, which is really more of an organiser than a coding tool, supports a limited range of refactorings where it is useful to be able to limit their scope to a particular package or set of packages (e.g. renaming a method), although package scoped refactorings can also be initiated from other tools, in particular the System Browser.

A brief description of most of the Refactorings themselves can be found at:

	http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/Refactorings.html

Dolphin also incorporates some of its own specific refactorings.
1) Rename Method References. Not strictly a refactoring, in that it may not preserve existing behaviour, this is effectively one half Rename Method. It renames all references to a selector within the chosen refactoring scope, but does not rename any definitions. This is useful when you have a duplicate method where both original and duplicate are called, and you want to rename refs to the duplicate to call the original, which will then allow removal of the duplicate.
2) Remove Duplicate Methods. This simply removes any methods in a class or classes that are not required because they duplicate an inherited definition. It is particularly useful when applied against packages to help maintain code quality by removing redundant methods.

As of Dolphin 6 renaming a class or instance variable in the browsers can also (optionally) rename accessor methods for that variable. This is based on the Rename Class / Instance Variable and Accessors refactoring developed as part of the Camp Smalltalk RB project. When renaming a variable if any potential accessors are found then the user is prompted as to whether they wish to rename those accessors as well as the underlying variable. The dialog also allows the scope of the method rename to be chosen.

In the browsers Refactoring commands can be found on the Refactoring sub-menus of the class tree, method list, and source workspace context menus, and on the Refactoring sub-menus of the Class, Method and Workspace top-level menus, wherever these are present. In the Debugger the method refactorings menu can be found on the stack trace window context menu, and off the Debug top-level menu. Extensive use is made of dynamically constructed menus to enhance usability, and accelerator key sequences are associated with the most commonly used code refactorings. Many refactorings (not just "code" refactorings) can now be initiated from the browser source workspace context menus just by right-clicking over the appropriate syntactic element; for example you can rename a self-sent message by selecting the message send or just by right-clicking over one of the selector''s keywords.'.

package basicPackageVersion: '6.1'.


package setClassNames: #(
	#{Tools.ClassNameToBindingReferenceRefactoring}
	#{Tools.CodeMentorPlugin}
	#{Tools.CodeRefactoringTool}
	#{Tools.CodeRewriterPlugin}
	#{Tools.ConvertToSiblingDialog}
	#{Tools.CopyClassRefactoring}
	#{Tools.LintRuleFailuresBrowserShell}
	#{Tools.MethodNameDialog}
	#{Tools.MethodRefactoringTool}
	#{Tools.RefactoringSmalltalkSystem}
	#{Tools.RefactoringTool}
	#{Tools.RenameAccessorsDialog}
	#{Tools.RenameClassRefactoring}
	#{Tools.RenameMethodDialog}
	#{Tools.RenameMethodReferencesRefactoring}
	#{Tools.RewriteChangesBrowser}
	#{Tools.ScopedMethodName}
	#{Tools.SmalllintCachingContext}
	#{Tools.SmalllintPlugin}
).

package setMethodNames: #(
	#(#{Core.Behavior} #directlyDefinesMethod:)
	#(#{Core.Class} #directlyDefinesClassVariable:)
	#(#{Core.ClassDescription} #definesClassVariable:)
	#(#{Core.ClassDescription} #definesInstanceVariable:)
	#(#{Core.ClassDescription} #definesVariable:)
	#(#{Core.ClassDescription} #directlyDefinesClassVariable:)
	#(#{Core.ClassDescription} #directlyDefinesInstanceVariable:)
	#(#{Core.ClassDescription} #directlyDefinesVariable:)
	#(#{Core.ClassDescription} #hierarchyDefinesVariable:)
	#(#{Core.Metaclass} #directlyDefinesClassVariable:)
	#(#{Kernel.StQualifiedReferenceNode} #isBindingChanged)
	#(#{Kernel.StVariableNode} #isBindingChanged)
	#(#{Refactory.Browser.AbstractClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #displayOn:)
	#(#{Refactory.Browser.AbstractVariablesRefactoring} #getOptionAbstractVariables)
	#(#{Refactory.Browser.AddClassChange class} #icon)
	#(#{Refactory.Browser.AddClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.AddMethodChange class} #icon)
	#(#{Refactory.Browser.AddMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.AddMethodRefactoring} #maxDetails)
	#(#{Refactory.Browser.AddParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.BasicLintRule} #failedClasses)
	#(#{Refactory.Browser.BasicLintRule} #failedMethods)
	#(#{Refactory.Browser.BasicLintRule} #publishedAspects)
	#(#{Refactory.Browser.BasicLintRule} #searchStrings)
	#(#{Refactory.Browser.ChangeMethodNameRefactoring} #getOptionRenameAllDefinitions:of:)
	#(#{Refactory.Browser.ChildrenToSiblingsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ClassCommentChange class} #icon)
	#(#{Refactory.Browser.CompositeRefactoryChange class} #icon)
	#(#{Refactory.Browser.CreateAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.ExpandReferencedPoolsRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExpandReferencedPoolsRefactoring} #getOptionMovePools:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodRefactoring} #getOptionUseExistingMethod:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #displayOn:)
	#(#{Refactory.Browser.ExtractMethodToComponentRefactoring} #getOptionVariableToMoveToOf:in:)
	#(#{Refactory.Browser.ExtractToTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineAllSendersRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionImplementorToInline:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineOverridden:of:)
	#(#{Refactory.Browser.InlineMethodRefactoring} #getOptionInlineReordered:into:)
	#(#{Refactory.Browser.InlineParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.InlineTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.LintRule} #failedClasses)
	#(#{Refactory.Browser.LintRule} #failedMethods)
	#(#{Refactory.Browser.LintRule} #searchStrings)
	#(#{Refactory.Browser.LintRule class} #icon)
	#(#{Refactory.Browser.MethodRefactoring} #generateDefaultSelector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionAlreadyDefined:selector:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionExtractAssignment:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionInlineExpression:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionNewMethodName:classes:)
	#(#{Refactory.Browser.MethodRefactoring} #getOptionRemoveMethod:referencedIn:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionSelfArgumentName)
	#(#{Refactory.Browser.MoveMethodRefactoring} #getOptionVariableTypes:selected:)
	#(#{Refactory.Browser.MoveMethodRefactoring} #resolveClass:)
	#(#{Refactory.Browser.MoveVariableDefinitionRefactoring} #displayOn:)
	#(#{Refactory.Browser.ProtectInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.PullUpInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.PushDownMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionCopyDownSuperclassMethod:)
	#(#{Refactory.Browser.PushUpMethodRefactoring} #getOptionPushUpRemoveDuplicates:in:)
	#(#{Refactory.Browser.RBAbstractClass} #instVarNames)
	#(#{Refactory.Browser.RBAbstractClass} #owningPackage)
	#(#{Refactory.Browser.RBAbstractCondition} #validate)
	#(#{Refactory.Browser.RBAbstractCondition} #validate:)
	#(#{Refactory.Browser.RBClass} #addClassConstant:)
	#(#{Refactory.Browser.RBClass} #removeClassConstant:)
	#(#{Refactory.Browser.RBClass} #removeImport:)
	#(#{Refactory.Browser.RBMethod} #owningPackage)
	#(#{Refactory.Browser.RBModel} #browseChanges)
	#(#{Refactory.Browser.RBModel} #removeImport:from:)
	#(#{Refactory.Browser.Refactoring} #chooseFrom:caption:)
	#(#{Refactory.Browser.Refactoring} #confirm:)
	#(#{Refactory.Browser.Refactoring} #maxDetails)
	#(#{Refactory.Browser.Refactoring} #printNameList:on:limit:type:)
	#(#{Refactory.Browser.Refactoring} #prompt:)
	#(#{Refactory.Browser.Refactoring class} #icon)
	#(#{Refactory.Browser.Refactoring class} #renameIcon)
	#(#{Refactory.Browser.RefactoryClassChange class} #icon)
	#(#{Refactory.Browser.RefactoryVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveClassChange class} #icon)
	#(#{Refactory.Browser.RemoveClassRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveClassRefactoring} #getOptionRemoveClass:referencedIn:)
	#(#{Refactory.Browser.RemoveClassVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveInstanceVariableChange class} #icon)
	#(#{Refactory.Browser.RemoveInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RemoveMethodChange class} #icon)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RemoveMethodRefactoring} #getOptionRemoveDuplicatesWithSupersends:)
	#(#{Refactory.Browser.RemoveParameterRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameAccessorsForVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameClassChange class} #icon)
	#(#{Refactory.Browser.RenameClassVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameClassVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #displayPrefix)
	#(#{Refactory.Browser.RenameInstanceVariableRefactoring class} #icon)
	#(#{Refactory.Browser.RenameMethodRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameMethodRefactoring class} #icon)
	#(#{Refactory.Browser.RenameTemporaryRefactoring} #displayOn:)
	#(#{Refactory.Browser.RenameTemporaryRefactoring class} #icon)
	#(#{Refactory.Browser.RenameVariableChange class} #icon)
	#(#{Refactory.Browser.SmalllintChecker class} #newWithCachingContext)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.TemporaryToInstanceVariableRefactoring} #getOptionConvertReadBeforeWritten:)
	#(#{Refactory.Browser.TransformationRule class} #bitLogicElimination)
	#(#{Refactory.Browser.TransformationRule class} #icon)
	#(#{Refactory.Browser.TransformationRule class} #ifElimination)
	#(#{Refactory.Browser.TransformationRule class} #renameArgument:to:)
	#(#{Refactory.Browser.VariableRefactoring} #displayOn:)
	#(#{Refactory.Browser.VariableRefactoring} #displayPrefix)
	#(#{Refactory.Browser.VariableRefactoring} #getOptionPullUpNonSharedInstVar:)
	#(#{Refactory.Browser.VariableRefactoring class} #displayPrefix)
	#(#{Tools.AddSharedVariableChange class} #icon)
	#(#{Tools.BasicRenameClassChange class} #icon)
	#(#{Tools.ClassBrowserAbstract} #abstractInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #methodRefactoringTool)
	#(#{Tools.ClassBrowserAbstract} #methodsToOverride)
	#(#{Tools.ClassBrowserAbstract} #overrideMethods)
	#(#{Tools.ClassBrowserAbstract} #protectInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #pushDownMethods)
	#(#{Tools.ClassBrowserAbstract} #pushMethods:)
	#(#{Tools.ClassBrowserAbstract} #pushUpMethods)
	#(#{Tools.ClassBrowserAbstract} #queryRefactoringCommand:)
	#(#{Tools.ClassBrowserAbstract} #removeInstanceVariables)
	#(#{Tools.ClassBrowserAbstract} #renameMethod)
	#(#{Tools.ClassBrowserAbstract} #selectedOverridableMethods)
	#(#{Tools.ClassSelector} #abstractClassVariables)
	#(#{Tools.ClassSelector} #abstractInstanceVariables)
	#(#{Tools.ClassSelector} #addClassVariable)
	#(#{Tools.ClassSelector} #addInstanceVariable)
	#(#{Tools.ClassSelector} #buildInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #buildPullUpVariablesMenu:)
	#(#{Tools.ClassSelector} #buildVariablesMenu:instVarSelectors:classVarSelectors:)
	#(#{Tools.ClassSelector} #cloneClass:under:changes:)
	#(#{Tools.ClassSelector} #convertToSibling)
	#(#{Tools.ClassSelector} #createClassVariableAccessors)
	#(#{Tools.ClassSelector} #populateClassVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populateInstVarMenu:selectors:)
	#(#{Tools.ClassSelector} #populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:)
	#(#{Tools.ClassSelector} #populateRefactoringMenu:)
	#(#{Tools.ClassSelector} #protectInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpClassVariables)
	#(#{Tools.ClassSelector} #pullUpInstanceVariables)
	#(#{Tools.ClassSelector} #pullUpVariableNamePairs:for:maximum:)
	#(#{Tools.ClassSelector} #pushDownClassVariables)
	#(#{Tools.ClassSelector} #pushDownInstanceVariables)
	#(#{Tools.ClassSelector} #queryRefactoringCommand:)
	#(#{Tools.ClassSelector} #removeClassVariables)
	#(#{Tools.ClassSelector} #removeDuplicateMethods)
	#(#{Tools.ClassSelector} #removeInstanceVariables)
	#(#{Tools.Debugger} #canMoveMethods)
	#(#{Tools.Debugger} #hasRefactorableMethodSelected)
	#(#{Tools.Debugger} #performMethodRefactoring:)
	#(#{Tools.Debugger} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #canMoveMethods)
	#(#{Tools.MethodBrowser} #hasRefactorableMethodSelected)
	#(#{Tools.MethodBrowser} #performMethodRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodRenameRefactoring:)
	#(#{Tools.MethodBrowser} #performMethodsRefactoring:name:)
	#(#{Tools.MethodWorkspace} #canRefactor)
	#(#{Tools.MethodWorkspace} #executeRefactoring:)
	#(#{Tools.MethodWorkspace} #executeRefactoring:with:)
	#(#{Tools.MethodWorkspace} #fontOfStyle:)
	#(#{Tools.MethodWorkspace} #performCodeRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRefactoring:)
	#(#{Tools.MethodWorkspace} #performMethodRenameRefactoring:)
	#(#{Tools.MethodWorkspace} #renameVariable:operation:validationBlock:)
	#(#{Tools.PackageBrowserShell} #addParameter)
	#(#{Tools.PackageBrowserShell} #addParameterTo:)
	#(#{Tools.PackageBrowserShell} #addParameterToMethod)
	#(#{Tools.PackageBrowserShell} #chooseMethodsForRefactoring:)
	#(#{Tools.PackageBrowserShell} #hasRefactorableMethodSelected)
	#(#{Tools.PackageBrowserShell} #parseTree)
	#(#{Tools.PackageBrowserShell} #performMethodRenameRefactoring:)
	#(#{Tools.PackageBrowserShell} #performMethodsRefactoring:name:)
	#(#{Tools.PackageBrowserShell} #promptForMethodName:caption:allowExisting:)
	#(#{Tools.PackageBrowserShell} #queryRefactoringCommand:)
	#(#{Tools.PackageBrowserShell} #removeMethod)
	#(#{Tools.PackageBrowserShell} #removeMethods)
	#(#{Tools.PackageBrowserShell} #removeParameter)
	#(#{Tools.PackageBrowserShell} #renameLooseMethod)
	#(#{Tools.PackageBrowserShell} #renameLooseMethodReferences)
	#(#{Tools.PackageBrowserShell} #renameMethod)
	#(#{Tools.PackageBrowserShell} #renameMethodReferences:)
	#(#{Tools.PackageSelector} #moveAllTempsToInnerScope)
	#(#{Tools.PackageSelector} #queryRefactoringCommand:)
	#(#{Tools.PackageSelector} #removeDuplicateMethods)
	#(#{Tools.RemoveClassConstantChange class} #icon)
	#(#{Tools.RemoveNamespaceImportChange class} #icon)
	#(#{Tools.RemoveSharedVariableChange class} #icon)
	#(#{Tools.SmalltalkToolShell} #chooseMethodForRefactoring:)
	#(#{Tools.SmalltalkToolShell} #queryRefactoringCommand:)
	#(#{UI.Dialog} #validationDwell)
).

package setPrerequisites: #(
	'..\..\..\..\Contributions\Camp Smalltalk\Refactoring Browser\Refactorings\CSRefactorings'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\Base\Dolphin Change Objects'
	'..\..\MVP\Views\Buttons\Dolphin Check Buttons'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Presenters\Difference\Dolphin Differences Presenter'
	'..\..\MVP\Graphics\Dolphin GDI Graphics'
	'..\..\MVP\Presenters\Prompters\Dolphin In-place Text Editor'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\System\Win32\MessageBox\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'Dolphin Professional Tools'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Views\Buttons\Dolphin Push Buttons'
	'..\..\MVP\Views\Splitter\Dolphin Splitter Control'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Views\Tooltips\Dolphin Tooltips'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\ActiveX\Components\SHDocVw\Internet Explorer'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Parser\RBParser'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\SmallLint\RBSmallLint'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Shell\Windows Shell'
	'..\..\ActiveX\Components\XML DOM\XML DOM'
).

package!

"Class Definitions"!

Core.Object subclass: #'Tools.RefactoringTool'
	instanceVariableNames: 'presenter'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ProfessionalSmalltalkSystem subclass: #'Tools.RefactoringSmalltalkSystem'
	instanceVariableNames: 'isOAD'
	classVariableNames: 'RefactoringSignal'
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassBrowserPlugin subclass: #'Tools.SmalllintPlugin'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin subclass: #'Tools.CodeMentorPlugin'
	instanceVariableNames: 'failuresPresenter infoSitePresenter infoBrowserPresenter progressPresenter checkerProcess rulesTreeModel isRefreshPending refreshMode'
	classVariableNames: 'DefaultRefreshMode LintIconMap LintRulesDoc'
	imports: #(#{SHDocVw private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalllintPlugin subclass: #'Tools.CodeRewriterPlugin'
	instanceVariableNames: 'searchTextPresenter replaceTextPresenter isMethodPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.ConvertToSiblingDialog'
	instanceVariableNames: 'classNamePresenter namespacePresenter subclassesPresenter statusModel'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.MethodNameDialog'
	instanceVariableNames: 'selectorPresenter parametersPresenter parameterNamesPresenter hintBubble'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodNameDialog subclass: #'Tools.RenameMethodDialog'
	instanceVariableNames: 'scopePresenter scopeDescriptionPresenter allowExistingSelector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.RenameAccessorsDialog'
	instanceVariableNames: 'selectorsPresenter scopePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.RewriteChangesBrowser'
	instanceVariableNames: 'changesPresenter differencesPresenter compositeChange'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodBrowserShell subclass: #'Tools.LintRuleFailuresBrowserShell'
	instanceVariableNames: 'lintRule'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RBMethodName subclass: #'Tools.ScopedMethodName'
	instanceVariableNames: 'methodClass originalArguments originalSelector scope scopes'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ClassRefactoring subclass: #'Tools.ClassNameToBindingReferenceRefactoring'
	instanceVariableNames: 'class unqualifiedName'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ClassRefactoring subclass: #'Tools.CopyClassRefactoring'
	instanceVariableNames: 'newName class superclass'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.ClassRefactoring subclass: #'Tools.RenameClassRefactoring'
	instanceVariableNames: 'newName class oldClassReference newClassReference oldUnqualified hasSymbolRenames classBinding'
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RenameMethodRefactoring subclass: #'Tools.RenameMethodReferencesRefactoring'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Refactory.Browser})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool subclass: #'Tools.CodeRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #(#{Kernel.ParseErrorCodes})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.RefactoringTool subclass: #'Tools.MethodRefactoringTool'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.SmalllintContext subclass: #'Tools.SmalllintCachingContext'
	instanceVariableNames: ''
	classVariableNames: 'Literals Mtx Selectors'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Behavior methodsFor!

directlyDefinesMethod: aSymbol
	^self includesSelector: aSymbol! !
!Core.Behavior categoriesForMethods!
directlyDefinesMethod:!methods-testing!public! !
!

!Core.Class methodsFor!

directlyDefinesClassVariable: aString
	^self classBindingNames includes: aString asString! !
!Core.Class categoriesForMethods!
directlyDefinesClassVariable:!public!testing! !
!

!Core.ClassDescription methodsFor!

definesClassVariable: aSymbol 
	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesClassVariable: aSymbol]!

definesInstanceVariable: aString 
	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].
	^self superclass notNil 
		and: [self superclass definesInstanceVariable: aString]!

definesVariable: aVariableName 
	^(self definesClassVariable: aVariableName) 
		or: [self definesInstanceVariable: aVariableName]!

directlyDefinesClassVariable: aString 
	^self subclassResponsibility!

directlyDefinesInstanceVariable: aString 
	^self instVarNames includes: aString!

directlyDefinesVariable: aVariableName 
	^(self directlyDefinesClassVariable: aVariableName) 
		or: [self directlyDefinesInstanceVariable: aVariableName]!

hierarchyDefinesVariable: aString
	(self definesVariable: aString) ifTrue: [^true].
	self allSubclassesBreadthFirstDo: [:each | (each directlyDefinesVariable: aString) ifTrue: [^true]].
	^false! !
!Core.ClassDescription categoriesForMethods!
definesClassVariable:!public!testing! !
definesInstanceVariable:!public!testing! !
definesVariable:!public!testing! !
directlyDefinesClassVariable:!public!testing! !
directlyDefinesInstanceVariable:!public!testing! !
directlyDefinesVariable:!public!testing! !
hierarchyDefinesVariable:!public!testing! !
!

!Core.Metaclass methodsFor!

directlyDefinesClassVariable: aString 
	^self instanceClass directlyDefinesClassVariable: aString! !
!Core.Metaclass categoriesForMethods!
directlyDefinesClassVariable:!public!testing! !
!

!Kernel.StQualifiedReferenceNode methodsFor!

isBindingChanged
	"Private - Assuming that this node has been bound by the RBVariableAnalyser, would it bind differently now?"

	^binding notNil and: [self isRelative and: [self resolveBinding ~~ binding]]! !
!Kernel.StQualifiedReferenceNode categoriesForMethods!
isBindingChanged!accessing!private! !
!

!Kernel.StVariableNode methodsFor!

isBindingChanged
	"Private - Assuming that this node has been bound by a semantic analyser, would it bind differently now?"

	| binding |
	binding := self binding.
	^binding notNil and: [binding ~~ self resolveBinding]! !
!Kernel.StVariableNode categoriesForMethods!
isBindingChanged!accessing!private! !
!

!Refactory.Browser.AbstractClassVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractClassVariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Refactory.Browser.AbstractInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Abstract'! !
!Refactory.Browser.AbstractInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AbstractVariablesRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	#todo.	"Implement more informative display string"
	aPuttableStream nextPutAll: 'Abstract Variables'!

getOptionAbstractVariables
	| details instVars classVars accessesInstVars |
	details := String writeStream.
	instVars := instVarReaders union: instVarWriters.
	accessesInstVars := instVars isEmpty.
	accessesInstVars
		ifFalse: 
			[details
				nextPutAll: 'The following instance variables are directly accessed:';
				cr.
			self
				printNameList: instVars asArray sort
				on: details
				limit: self maxDetails // 2
				type: 'instance variables'].
	classVars := classVarReaders union: classVarWriters.
	classVars isEmpty
		ifFalse: 
			[accessesInstVars
				ifTrue: 
					[details
						cr;
						cr].
			details
				nextPutAll: 'The following class variables are directly accessed:';
				cr.
			self
				printNameList: classVars asArray sort
				on: details
				limit: self maxDetails // 2
				type: 'class variables'].
	details
		cr;
		cr;
		nextPutAll: 'Any existing accessor will be used if possible, so accessors will only be added for read or written variables that do not currently have them.'.
	^MessageBox new
		caption: self displayString;
		headline: 'Abstract variable references?';
		text: 'This method has direct variable references which will need to be converted to getter/setters in the extracted method<1?s:>.'
					<< {toClasses size > 1};
		customButtons: #(#(#yes '&Abstract Variables') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !
!Refactory.Browser.AbstractVariablesRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionAbstractVariables!options!public! !
!

!Refactory.Browser.AddClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewClass.ico'! !
!Refactory.Browser.AddClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add class ';
		display: className! !
!Refactory.Browser.AddClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.AddClassVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Add'! !
!Refactory.Browser.AddInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.AddMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewMethod.ico'! !
!Refactory.Browser.AddMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.AddMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add method to ';
		nextPutAll: class unqualifiedName!

maxDetails
	^15! !
!Refactory.Browser.AddMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
maxDetails!constants!private! !
!

!Refactory.Browser.AddParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Add parameter to ';
		print: oldSelector.
	model environment isSystem
		ifFalse: 
			[aPuttableStream
				nextPutAll: ' in ';
				display: model environment]! !
!Refactory.Browser.AddParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.BasicLintRule methodsFor!

failedClasses
	self result isClassEnvironment ifFalse: [^super failedClasses].
	^self result classes!

failedMethods
	| failedMethods |
	self result isClassEnvironment ifTrue: [^super failedMethods].
	failedMethods := Set new: 64.
	self result
		classesAndSelectorsDo: [:eachClass :eachSel | failedMethods add: (eachClass compiledMethodAt: eachSel)].
	^failedMethods!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := self class publishedAspectsOfInstances.
	self result isClassEnvironment
		ifTrue: [answer add: ((Aspect collection: #failedClasses)
						beReadOnly;
						yourself)]
		ifFalse: [answer add: ((Aspect collection: #failedMethods)
						beReadOnly;
						yourself)].
	self searchStrings notEmpty
		ifTrue: 
			[answer add: ((Aspect sequenceableCollection: #searchStrings)
						beReadOnly;
						yourself)].
	^answer!

searchStrings
	^result searchStrings! !
!Refactory.Browser.BasicLintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
publishedAspects!constants!development!public! !
searchStrings!accessing!private! !
!

!Refactory.Browser.ChangeMethodNameRefactoring methodsFor!

getOptionRenameAllDefinitions: aCollection of: aSymbol
	| details count |
	aCollection size <= 1 ifTrue: [^true].
	details := String writeStream.
	details
		print: aSymbol;
		nextPutAll: ' is implemented in:';
		cr.
	self
		printNameList: (aCollection asSortedCollection: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'All definitions must be renamed to preserve behaviour. You can re-initiate the rename and constrain the scope of the rename to package, hierarchy, class or even individual method level in the rename dialog if you wish, but this may not preserve behaviour.'.
	count := aCollection size.
	^MessageBox new
		caption: self displayString;
		headline: 'Rename <1p> methods defined in <2d> classes?' << {aSymbol. count};
		customButtons: #(#(#yes '&Rename All') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		confirm! !
!Refactory.Browser.ChangeMethodNameRefactoring categoriesForMethods!
getOptionRenameAllDefinitions:of:!options!public! !
!

!Refactory.Browser.ChildrenToSiblingsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert ';
		display: parent;
		nextPutAll: ' to sibling'! !
!Refactory.Browser.ChildrenToSiblingsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ClassCommentChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassComment.ico'! !
!Refactory.Browser.ClassCommentChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CompositeRefactoryChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Collection icon! !
!Refactory.Browser.CompositeRefactoryChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.CreateAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Create accessors for'! !
!Refactory.Browser.CreateAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.ExpandReferencedPoolsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Add import'.
	pools size = 1
		ifTrue: 
			[aPuttableStream space.
			pools asArray first displayOn: aPuttableStream]
		ifFalse: 
			[aPuttableStream nextPutAll: 's '.
			pools do: [:each | each displayOn: aPuttableStream] separatedBy: [aPuttableStream nextPutAll: ', ']].
	aPuttableStream nextPutAll: ' to '.
	toClasses size = 1
		ifTrue: [toClasses asArray first displayOn: aPuttableStream]
		ifFalse: 
			[toClasses do: [:each | each name displayOn: aPuttableStream]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionMovePools: aCollection
	| details |
	details := String writeStream.
	details nextPutAll: 'The following namespaces will need to be imported'.
	toClasses size == 1
		ifTrue: 
			[details
				nextPutAll: ' into ';
				nextPutAll: toClasses first unqualifiedName].
	details
		nextPut: $:;
		cr.
	self
		printNameList: aCollection asSortedCollection
		on: details
		limit: self maxDetails
		type: 'namespaces'.
	^MessageBox new
		caption: self displayString;
		text: 'This method contains references to shared variables from namespaces that may need to be imported into the target.';
		customButtons: #(#(#yes '&Add Imports') #(#no '&Cancel'));
		detailsText: details contents;
		confirm! !
!Refactory.Browser.ExpandReferencedPoolsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionMovePools:!options!public! !
!

!Refactory.Browser.ExtractMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract method from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionUseExistingMethod: aSymbol
	^MessageBox new
		caption: self displayString;
		headline: 'Use existing method <1p>?' << aSymbol;
		text: 'The existing method contains the same code as that you are extracting, and can be used safely instead of creating a new method.';
		customButtons: #(#(#yes '&Use Existing') #(#no '&Create New Method'));
		confirm! !
!Refactory.Browser.ExtractMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionUseExistingMethod:!options!public! !
!

!Refactory.Browser.ExtractMethodToComponentRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to component from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector!

getOptionVariableToMoveToOf: aClass in: aSelector
	^SmalltalkSystem current selectTargetVariableOf: aClass
		parseTree: (aClass parseTreeFor: aSelector)! !
!Refactory.Browser.ExtractMethodToComponentRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionVariableToMoveToOf:in:!public! !
!

!Refactory.Browser.ExtractToTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Extract to temporary ';
		print: newVariableName! !
!Refactory.Browser.ExtractToTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineAllSendersRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline sends of ';
		print: selector;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.InlineAllSendersRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline message in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: sourceSelector!

getOptionImplementorToInline: anOrderedCollection
	^UI.ChoicePrompter
		choices: (anOrderedCollection asSortedCollection: [:a :b | a displayString <= b displayString])
		caption: 'Inline <1p> from…' << sourceMessage!

getOptionInlineOverridden: aSymbol of: aClass
	| details overrides fromClass |
	details := String writeStream.
	fromClass := self chosenInlineClass.
	details
		nextPutAll: '<1p> is overridden by the following subclasses of <2d>:'
					<< {aSymbol. fromClass unqualifiedName};
		cr.
	overrides := fromClass allSubclasses select: [:each | each directlyDefinesMethod: aSymbol].
	self
		printNameList: overrides
		on: details
		limit: self maxDetails
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Inline overridden method?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: '<1d>>><2p> is overridden in <3d> subclass<4?:es> of <5d>.<n><n>Inlining an overridden method may change behavior.'
					<< {aClass. aSymbol. overrides size. overrides size = 1. fromClass};
		detailsText: details contents;
		confirm!

getOptionInlineReordered: inlineRBMethod into: intoRBMethod
	^MessageBox new
		caption: self displayString;
		headline: 'Inline with statement reordering?';
		iconStyle: #warning;
		customButtons: #(#(#yes '&Inline') #(#no 'Cancel'));
		defaultButton: 2;
		text: 'To inline <1p> into <2p> it will be necessary to move some of the inlined statements before the original message send.'
					<< {inlineRBMethod. intoRBMethod};
		detailsText: 'This could change the order of execution, which can change the behavior. If it is safe to do so you can continue with the refactoring and then modify or undo the results as required. Alternatively cancel the refactoring and modify the call site so that the inlined message send is an individual statement rather than part of a larger statement, for example as an expression calculating a value to use as an argument to another message send.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm! !
!Refactory.Browser.InlineMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionImplementorToInline:!options!public! !
getOptionInlineOverridden:of:!preconditions!public! !
getOptionInlineReordered:into:!options!public! !
!

!Refactory.Browser.InlineParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline parameter ';
		print: argument;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.InlineParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.InlineTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Inline temp ';
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector
	"		print: oldName;"! !
!Refactory.Browser.InlineTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.LintRule methodsFor!

failedClasses
	^Set new!

failedMethods
	^Set new!

searchStrings
	^#()! !
!Refactory.Browser.LintRule categoriesForMethods!
failedClasses!accessing!private! !
failedMethods!accessing!private! !
searchStrings!accessing!private! !
!

!Refactory.Browser.LintRule class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!Refactory.Browser.LintRule class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.MethodRefactoring methodsFor!

generateDefaultSelector: anRBMethodName
	anRBMethodName selector isNil
		ifTrue: 
			[| args mname |
			args := anRBMethodName arguments.
			mname := args isEmpty
						ifTrue: ['method']
						ifFalse: 
							[| stream |
							stream := String writeStream.
							anRBMethodName arguments do: 
									[:arg |
									stream
										nextPutAll: arg;
										nextPut: $:].
							stream contents].
			anRBMethodName selector: mname asSymbol]!

getOptionAlreadyDefined: aClass selector: aSymbol
	| response |
	response := MessageBox new
				caption: self displayString;
				headline: 'Extract to existing selector?';
				text: ('<1p> is already defined in the <2d> hierarchy.' expandMacrosWith: aSymbol
							with: aClass unqualifiedName);
				customButtons: #(#(#yes '&Continue') #(#no '&Choose Another') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: 'Extracting to an existing selector may change the behavior of the class hierarchy, for example by overriding an inherited method. You should only continue if you do not require a true behavior-preserving refactoring. Otherwise choose another selector.'
							<< aSymbol;
				expandLabel: 'Show help';
				collapseLabel: 'Hide help';
				iconStyle: #warning;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes!

getOptionExtractAssignment: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Extract final assignment?';
		text: 'The assignment to ''<1s>'' at the end of the selection can be extracted to the new method, or remain behind to receive the result of the call to that method.'
					<< aString;
		customButtons: #(#(#yes '&Extract') #(#no '&Don''t Extract'));
		defaultButton: 2;
		confirm!

getOptionInlineExpression: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Inline expression?';
		text: 'The following expression can be inlined or assigned to a temporary:<n><n><t><1s>?' << aString;
		customButtons: #(#(#yes '&Inline') #(#no '&Assign Temporary'));
		defaultButton: 2;
		detailsText: 'The expression shown is passed as one of the arguments to the method you are inlining. You can safely inline the expression if constant and/or side-effect free, or if it is only referred to once in the inlined method. If not, it should be assigned to a temporary to preserve existing behaviour. If unsure, choose ''Assign Temporary''. You can always inline the temporary later if you wish.';
		expandLabel: 'Show help';
		collapseLabel: 'Hide help';
		confirm!

getOptionNewMethodName: anRBMethodName classes: anArray
	| dialog |
	self generateDefaultSelector: anRBMethodName.
	dialog := MethodNameDialog createOn: anRBMethodName.
	dialog validater: 
			[:methodName |
			| sel |
			sel := methodName selectorSymbol.
			(anArray inject: methodName conditions
				into: [:conditions :each | conditions & (Refactory.Browser.RBCondition definesSelector: sel in: each) not])
					validate].
	^dialog showModal ifNotNil: [anRBMethodName]!

getOptionRemoveMethod: aSymbol referencedIn: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'Removing the method may not preserve behaviour. It is recommended that you first browse these references to verify that the method is safe to remove:';
		cr.
	self
		printNameList: (aCollection asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: '<1p> may not be safe to remove' << aSymbol;
				text: ('The selector <1p> is referenced from <2d> other methods.' expandMacrosWith: aSymbol
							with: aCollection size);
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no ifTrue: [self openBrowserOn: (self model environment referencesTo: aSymbol)].
	^false! !
!Refactory.Browser.MethodRefactoring categoriesForMethods!
generateDefaultSelector:!options!public! !
getOptionAlreadyDefined:selector:!options!public! !
getOptionExtractAssignment:!options!public! !
getOptionInlineExpression:!options!public! !
getOptionNewMethodName:classes:!options!public! !
getOptionRemoveMethod:referencedIn:!options!public! !
!

!Refactory.Browser.MoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector;
		nextPutAll: '  to ';
		print: variable!

getOptionSelfArgumentName
	| newName existing |
	existing := parseTree allDefinedVariables.
	newName := (Prompter
				createOn: String new
				prompt: 'Enter name for argument to refer to "self" in extracted method'
				caption: self displayString)
				validater: 
						[:name |
						(existing includes: name)
							ifTrue: [ValidationResult errorMessage: '<1d> is already in use as a local variable' << name]
							ifFalse: 
								[| result |
								result := ValidationResult new.
								moveToClasses allSatisfy: 
										[:each |
										| condition |
										condition := (Refactory.Browser.RBCondition isValidTemporaryVariableName: name for: each)
													& (Refactory.Browser.RBCondition definesInstanceVariable: name in: each) not.
										condition validate: result].
								result]];
				showHintWhenEmpty: false;
				showModal.
	newName isNil ifTrue: [^self refactoringAborted: 'Method not moved/extracted'].
	^newName!

getOptionVariableTypes: choicesCollection selected: suggestionsCollection
	^(ChoicePrompter
		create: 'Extensible multi-selection choice prompter'
		on: suggestionsCollection asOrderedCollection
		multipleChoices: ((choicesCollection union: suggestionsCollection)
				asSortedCollection: [:a :b | a name < b name])
		caption: 'Select class(es) of new method… ')
		newCaption: 'Add Other Class…';
		validater: 
				[:aString |
				| result |
				result := ValidationResult new.
				(self resolveClass: aString)
					ifNil: [result errorMessage: '<1s> is not a valid class name' << aString].
				result];
		newBlock: [:aString | self resolveClass: aString];
		showModal!

resolveClass: aString
	| binding |
	aString isEmpty ifTrue: [^nil].
	binding := aString asQualifiedReference bindingOrNil.
	^(binding notNil
		and: [binding isClassBinding and: [self model environment includesClass: binding value]])
			ifTrue: [self model classFor: binding value]! !
!Refactory.Browser.MoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionSelfArgumentName!public! !
getOptionVariableTypes:selected:!options!public! !
resolveClass:!helpers!private! !
!

!Refactory.Browser.MoveVariableDefinitionRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Move ';
		display: 'variable';
		nextPutAll: ' to inner scope in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.MoveVariableDefinitionRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.ProtectInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Protect'! !
!Refactory.Browser.ProtectInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpClassVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		print: variableName;
		nextPutAll: ' into ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PullUpInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PullUpInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Pull up'! !
!Refactory.Browser.PullUpInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownClassVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Push down'! !
!Refactory.Browser.PushDownInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.PushDownMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push down ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName! !
!Refactory.Browser.PushDownMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.PushUpMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Push up ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionCopyDownSuperclassMethod: aSelector
	^self
		confirm: 'Do you want to copy down the superclass method to the classes that don''t define <1p>?'
				<< aSelector!

getOptionPushUpRemoveDuplicates: aSymbol in: aCollection
	| details response |
	details := String writeStream.
	details
		nextPutAll: 'The following subclasses of ';
		nextPutAll: class superclass unqualifiedName;
		nextPutAll: ' will have a duplicate implementation:';
		cr.
	self
		printNameList: (aCollection asSortedCollection: [:a :b | a name < b name])
		on: details
		limit: self maxDetails
		type: 'classes'.
	response := MessageBox new
				caption: self displayString;
				text: 'Pushing up <1p> from <2d> to <3d> will result in duplicate implementations in <4d> subclass<5?es:> of <3d>.'
							<< {aSymbol.
									class unqualifiedName.
									class superclass unqualifiedName.
									aCollection size.
									aCollection size > 1};
				headline: 'Remove duplicates of pushed up method?';
				customButtons: #(#(#yes '&Remove Duplicates') #(#no 'Don''t Remove'));
				defaultButton: 1;
				isCancellable: true;
				detailsText: details contents;
				confirmOrCancel.
	response == #cancel ifTrue: [self refactoringAborted].
	^response == #yes! !
!Refactory.Browser.PushUpMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionCopyDownSuperclassMethod:!options!public! !
getOptionPushUpRemoveDuplicates:in:!options!public! !
!

!Refactory.Browser.RBAbstractClass methodsFor!

instVarNames
	^self instanceVariableNames!

owningPackage
	^self realClass ifNotNil: [:class | class owningPackage]! !
!Refactory.Browser.RBAbstractClass categoriesForMethods!
instVarNames!instance variables!public! !
owningPackage!accessing!public! !
!

!Refactory.Browser.RBAbstractCondition methodsFor!

validate
	| result |
	result := UI.ValidationResult new.
	self validate: result.
	^result!

validate: aValidationResult
	"Update the <ValidationResult> argument with results from evaluating this condition, answering whether the condition is satisfied."

	^(aValidationResult value: self check) or: [aValidationResult errorMessage: self errorString]! !
!Refactory.Browser.RBAbstractCondition categoriesForMethods!
validate!public! !
validate:!helpers!public! !
!

!Refactory.Browser.RBClass methodsFor!

addClassConstant: aRBVariableBinding
	self addBinding: aRBVariableBinding.
	model addClassConstant: aRBVariableBinding to: self!

removeClassConstant: anAssociation
	| binding |
	binding := self removeBindingFor: anAssociation key.
	model removeClassConstant: binding from: self!

removeImport: aString
	| ref |
	ref := aString asQualifiedReference.
	imports := self imports copyWithout: ref.
	model removeImport: ref from: self! !
!Refactory.Browser.RBClass categoriesForMethods!
addClassConstant:!public!variable accessing! !
removeClassConstant:!public!variable accessing! !
removeImport:!public!variable accessing! !
!

!Refactory.Browser.RBMethod methodsFor!

owningPackage
	^compiledMethod isNil 
		ifTrue: [class owningPackage]
		ifFalse: [compiledMethod owningPackage]! !
!Refactory.Browser.RBMethod categoriesForMethods!
owningPackage!accessing!public! !
!

!Refactory.Browser.RBModel methodsFor!

browseChanges
	Tools.RewriteChangesBrowser showOn: self changes!

removeImport: aBindingReference from: aRBClass
	^changes removeImport: aBindingReference from: aRBClass! !
!Refactory.Browser.RBModel categoriesForMethods!
browseChanges!helpers!public! !
removeImport:from:!changes!private! !
!

!Refactory.Browser.Refactoring methodsFor!

chooseFrom: aCollection caption: aString
	"Dolphin specific choice prompt"

	^UI.ChoicePrompter choices: aCollection asOrderedCollection caption: aString!

confirm: aString
	"Dolphin specific confirmation prompt"

	^MessageBox confirm: aString caption: self displayString!

maxDetails
	^30!

printNameList: aCollection on: aPuttableStream limit: maxInteger type: aString
	| count |
	count := aCollection size.
	aCollection
		from: 1
		to: (count min: maxInteger)
		do: 
			[:each |
			aPuttableStream
				cr;
				display: each].
	count > maxInteger
		ifTrue: 
			[aPuttableStream
				cr;
				nextPut: $…;
				cr;
				nextPutAll: 'And ';
				print: count - maxInteger;
				nextPutAll: ' further ';
				nextPutAll: aString;
				nextPut: $.]!

prompt: aString
	"Dolphin specific prompt for text input"

	^UI.Prompter prompt: aString caption: self displayString! !
!Refactory.Browser.Refactoring categoriesForMethods!
chooseFrom:caption:!helpers!private! !
confirm:!helpers!public! !
maxDetails!constants!private! !
printNameList:on:limit:type:!helpers!private! !
prompt:!helpers!private! !
!

!Refactory.Browser.Refactoring class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Refactoring.ico'!

renameIcon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'InPlaceRename.ico'! !
!Refactory.Browser.Refactoring class categoriesForMethods!
icon!constants!public! !
renameIcon!constants!public! !
!

!Refactory.Browser.RefactoryClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Class icon! !
!Refactory.Browser.RefactoryClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RefactoryVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Refactory.Browser.RefactoryVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassDelete.ico'! !
!Refactory.Browser.RemoveClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Remove '.
	classNames size == 1
		ifTrue: 
			[aPuttableStream
				nextPutAll: 'class ';
				display: classNames first]
		ifFalse: 
			[aPuttableStream nextPutAll: 'classes: '.
			classNames do: [:each | aPuttableStream display: each]
				separatedBy: [aPuttableStream nextPutAll: ', ']]!

getOptionRemoveClass: aRBClass referencedIn: aCollection
	| details response references |
	references := aCollection.
	details := String writeStream.
	details
		nextPutAll: 'Removing the class will leave ';
		nextPutAll: (references size = 1
					ifTrue: ['a dangling reference in this method']
					ifFalse: ['dangling references in these methods']);
		nextPutAll: ' and is potentially unsafe. It is recommended that you first browse these references and remove them before attempting to remove the class again:';
		cr.
	self
		printNameList: (references asArray collect: [:each | each printString]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	response := MessageBox new
				caption: self displayString;
				headline: 'Remove referenced class?' << aRBClass;
				text: 'The class <1p> is referenced from <2d> method<3?:s>.'
							<< {aRBClass. references size. references size = 1};
				customButtons: #(#(#yes '&Remove Anyway') #(#no '&Browse References') #(#cancel 'Cancel'));
				defaultButton: 2;
				detailsText: details contents;
				iconStyle: #warning;
				confirmOrCancel.
	response == #yes ifTrue: [^true].
	response == #no
		ifTrue: 
			[self
				openBrowserOn: ((self model environment forMethods: (aCollection collect: [:each | each method]))
						label: 'References to class <1p>, or its name' << aRBClass;
						yourself)].
	^false! !
!Refactory.Browser.RemoveClassRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveClass:referencedIn:!options!public! !
!

!Refactory.Browser.RemoveClassVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveClassVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveClassVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveInstanceVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Refactory.Browser.RemoveInstanceVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Remove'! !
!Refactory.Browser.RemoveInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
!

!Refactory.Browser.RemoveMethodChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'MethodDelete.ico'! !
!Refactory.Browser.RemoveMethodChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RemoveMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove ';
		print: (selectors size == 1 ifTrue: [selectors first] ifFalse: [selectors]);
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName!

getOptionRemoveDuplicatesWithSupersends: superMessages
	| details |
	details := String writeStream.
	details
		nextPutAll: 'The following methods are equivalent to their superclass implementations, but contain a supersend so removing them might modify behavior.';
		cr.
	self
		printNameList: (superMessages asArray
				collect: [:each | '<1s>>><2p>' << {class unqualifiedName. each}]) sort
		on: details
		limit: self maxDetails
		type: 'methods'.
	^MessageBox new
		caption: self displayString;
		headline: 'Remove duplicate methods with supersends?';
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		defaultButton: 2;
		detailsText: details contents;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.RemoveMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionRemoveDuplicatesWithSupersends:!options!public! !
!

!Refactory.Browser.RemoveParameterRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Remove parameter ';
		print: argument;
		nextPutAll: ' from ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: oldSelector! !
!Refactory.Browser.RemoveParameterRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameAccessorsForVariableRefactoring class methodsFor!

displayPrefix
	^'Rename accessors for'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameAccessorsForVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameClassVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameClassVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameClassVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName;
		nextPutAll: ' (and accessors) to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableAndAccessorsRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	super displayOn: aPuttableStream.
	aPuttableStream
		nextPutAll: ' to ';
		print: newName! !
!Refactory.Browser.RenameInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameInstanceVariableRefactoring class methodsFor!

displayPrefix
	^'Rename'!

icon
	^self renameIcon! !
!Refactory.Browser.RenameInstanceVariableRefactoring class categoriesForMethods!
displayPrefix!displaying!public! !
icon!constants!public! !
!

!Refactory.Browser.RenameMethodRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename ';
		print: oldSelector;
		nextPutAll: ' to ';
		print: newSelector! !
!Refactory.Browser.RenameMethodRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameMethodRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameMethodRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Rename temp ';
		print: oldName;
		nextPutAll: ' to ';
		print: newName;
		nextPutAll: ' in ';
		nextPutAll: class unqualifiedName;
		nextPutAll: '>>';
		print: selector! !
!Refactory.Browser.RenameTemporaryRefactoring categoriesForMethods!
displayOn:!displaying!public! !
!

!Refactory.Browser.RenameTemporaryRefactoring class methodsFor!

icon
	^self renameIcon! !
!Refactory.Browser.RenameTemporaryRefactoring class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.RenameVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Refactory.Browser.RenameVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.SmalllintChecker class methodsFor!

newWithCachingContext
	^self new
		context: SmalllintCachingContext new;
		yourself! !
!Refactory.Browser.SmalllintChecker class categoriesForMethods!
newWithCachingContext!instance creation!public! !
!

!Refactory.Browser.TemporaryToInstanceVariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Convert temp ';
		print: temporaryVariableName;
		nextPutAll: ' to inst var of ';
		nextPutAll: class unqualifiedName!

getOptionConvertReadBeforeWritten: aString
	^MessageBox new
		caption: self displayString;
		headline: 'Convert read-before-written temporary?';
		text: '<1p> is read before it is written and if converted to an instance variable it may not be initialized before use.' << aString;
		customButtons: #(#(#yes '&Convert') #(#no '&Don''t Convert'));
		defaultButton: 2;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.TemporaryToInstanceVariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
getOptionConvertReadBeforeWritten:!options!public! !
!

!Refactory.Browser.TransformationRule class methodsFor!

bitLogicElimination
	"Inlining of methods may create redundant bit logic operations where the operation is a no-op or has a constant outcome. This transformation can eliminate some cases."


	^self
		rewrite: #(
			#('0 bitOr: ``@arg' 	"->" 	'``@arg')
			#('0 | ``@arg' 	"->" 	'``@arg')
			#('``@arg bitOr: 0' 	"->" 	'``@arg')
			#('``@arg | 0 ' 	"->" 	'``@arg')

			#('0 bitAnd: ``@arg' 	"->" 	'0')
			#('0 & ``@arg' 	"->" 	'0')
			#('``@arg bitAnd: 0' 	"->" 	'0')
			#('``@arg & 0 ' 	"->" 	'0')
		)			
		methods: false
		name: 'Eliminate redundant bit operations'!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

ifElimination
	"Inlining of methods may create unecessary ifTrue:[ifFalse:] statements where the condition
	is a constant boolean value. This transformation is useful for eliminating these."

	^self 
		rewrite: #(#(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts1] ifFalse: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts2.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts1] ifTrue: [`@.stmts2].
`@.After' '| `@temps |
`@.Before.
`@.stmts1.
`@.After') #(' | `@temps |
`@.Before.
false ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
true ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.stmts.
`@.After') #(' | `@temps |
`@.Before.
false ifTrue: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After') #(' | `@temps |
`@.Before.
true ifFalse: [`@.stmts].
`@.After' '| `@temps |
`@.Before.
`@.After'))
		methods: false
		name: 'Eliminate unnecessary ifTrue:[ifFalse:] conditions'!

renameArgument: beforeString to: afterString
	^Refactory.Browser.TransformationRule new
		name: ('Rename argument <1p> to <2p>' expandMacrosWith: beforeString with: afterString);
		rewriteUsing: (Refactory.Browser.ParseTreeRewriter new
					replaceArgument: beforeString with: afterString;
					replace: beforeString with: afterString;
					yourself);
		yourself! !
!Refactory.Browser.TransformationRule class categoriesForMethods!
bitLogicElimination!public!transformations! !
icon!constants!public! !
ifElimination!public!transformations! !
renameArgument:to:!public! !
!

!Refactory.Browser.VariableRefactoring methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: self displayPrefix;
		space;
		nextPutAll: class unqualifiedName;
		nextPut: $.;
		nextPutAll: variableName!

displayPrefix
	^self class displayPrefix!

getOptionPullUpNonSharedInstVar: aString
	| with without details max |
	with := OrderedCollection new.
	without := OrderedCollection new.
	class subclasses do: 
			[:each |
			((each directlyDefinesInstanceVariable: variableName) ifTrue: [with] ifFalse: [without]) add: each].
	details := String writeStream.
	details
		print: aString;
		nextPutAll: ' is defined in:';
		cr.
	max := self maxDetails // 2.
	self
		printNameList: with
		on: details
		limit: max
		type: 'classes'.
	details
		cr;
		cr;
		nextPutAll: 'But is not defined in:';
		cr.
	self
		printNameList: without
		on: details
		limit: max
		type: 'classes'.
	^MessageBox new
		caption: self displayString;
		headline: 'Pull up non-shared instance variable?';
		text: 'Not all subclasses of <1d> have an instance variable named <2p>.<n><n>Do you want pull up this variable anyway?'
					<< {class. aString};
		customButtons: #(#(#yes '&Pull Up') #(#no 'Cancel'));
		defaultButton: 2;
		detailsText: details contents;
		isCancellable: true;
		iconStyle: #warning;
		confirm! !
!Refactory.Browser.VariableRefactoring categoriesForMethods!
displayOn:!displaying!public! !
displayPrefix!displaying!public! !
getOptionPullUpNonSharedInstVar:!options!public! !
!

!Refactory.Browser.VariableRefactoring class methodsFor!

displayPrefix
	^self subclassResponsibility! !
!Refactory.Browser.VariableRefactoring class categoriesForMethods!
displayPrefix!constants!displaying!public! !
!

!Tools.AddSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'NewThing.ico'! !
!Tools.AddSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Tools.BasicRenameClassChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'Rename.ico'! !
!Tools.BasicRenameClassChange class categoriesForMethods!
icon!constants!public! !
!

!Tools.ClassBrowserAbstract methodsFor!

abstractInstanceVariables
	"Private - Invoke the 'Abstract Instance Variable' refactoring on the currently selected variables."

	self model abstractInstanceVariables: self variables within: BrowserEnvironment new!

methodRefactoringTool
	^methodBrowserPresenter refactoringTool!

methodsToOverride
	| methods class selectedClass |
	methods := self selectedOverridableMethods.
	methods notEmpty ifTrue: [^methods].
	methods := IdentityDictionary new.
	selectedClass := self actualClass.
	class := selectedClass superclass.
	[class isNil] whileFalse: 
			[class methodDictionary keysAndValuesDo: 
					[:eachSelector :eachMethod |
					(eachSelector first ~~ $_ and: [(eachSelector beginsWith: 'basic') not])
						ifTrue: [methods at: eachSelector put: eachMethod]].
			class := class superclass].
	^(ChoicePrompter multipleChoices: methods keys asSortedCollection
		caption: 'Choose Methods to Override…')
			ifNotNil: [:selectors | selectors collect: [:each | selectedClass lookupMethod: each]]!

overrideMethods
	| stream class changes name methods |
	class := self actualClass.
	stream := String writeStream.
	changes := CompositeRefactoryChange new.
	methods := self methodsToOverride.
	(methods isNil or: [methods isEmpty]) ifTrue: [^self].
	methods do: 
			[:each |
			| keywordsAndArgs |
			stream reset.
			keywordsAndArgs := self systemModel keywordsAndArgsOfMethod: each.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			stream
				crtab;
				nextPutAll: '^super';
				space.
			self systemModel printSignatureForKeywordsAndArgs: keywordsAndArgs on: stream.
			changes addChange: (AddMethodChange
						compile: stream contents
						in: class
						environment: each environment
						categories: each categories
						package: each owningPackageIfLoose)].
	name := String writeStream.
	name nextPutAll: 'Override '.
	methods size > 1
		ifTrue: 
			[name
				print: methods size;
				nextPutAll: ' methods']
		ifFalse: [name print: methods first].
	changes name: name contents.
	self systemModel changeManager performChange: changes.
	self selectedMethods: (methodBrowserPresenter methodsPresenter list
				intersection: ((methods collect: [:each | each selector]) asSet
						collect: [:each | class compiledMethodAt: each ifAbsent: nil]))!

protectInstanceVariables
	"Private - Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables."

	self model protectInstanceVariables: self variables!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the currently selected variables."

	self model pushDownInstanceVariables: self variables!

pushDownMethods
	<acceleratorKey: 'Shift+Ctrl+7'>
	self pushMethods: false!

pushMethods: aBoolean
	| change isShift methods targetClass |
	isShift := Keyboard default isShiftDown.
	methods := self selectedMethods.
	"It is assumed that the methods are all of the same class (the 'push method' commands are disabled if not)"
	targetClass := methods first methodClass.
	targetClass := aBoolean ifTrue: [targetClass superclass] ifFalse: [targetClass subclasses first].
	change := self methodRefactoringTool pushMethods: aBoolean.
	(change isNil or: [isShift not]) ifTrue: [^self].
	methods := (methods asSet
				collect: [:each | targetClass compiledMethodAt: each selector ifAbsent: nil]) asArray.
	self actualClass: methods first methodClass ifAbsent: [^self].
	self selectedMethods: methods!

pushUpMethods
	<acceleratorKey: 'Shift+Ctrl+6'>
	self pushMethods: true!

queryRefactoringCommand: aCommandQuery
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#protectInstanceVariables #abstractInstanceVariables #removeInstanceVariables)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: self variables notEmpty.
				^true].
	#pushDownInstanceVariables == selector
		ifTrue: 
			[| class |
			aCommandQuery isEnabled: ((class := self actualClass) notNil
						and: [class subclasses notEmpty and: [self variables notEmpty]]).
			^true].
	#pushDownMethods == selector
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushDownMethods
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#pushUpMethods == selector
		ifTrue: 
			[aCommandQuery isEnabled: (self methodRefactoringTool canPushUpMethods
						and: [(self selectedMethods collect: [:each | each methodClass]) asSet size = 1]).
			^true].
	#overrideMethods == selector
		ifTrue: 
			[| class methods |
			methods := self selectedOverridableMethods.
			class := self actualClass.
			aCommandQuery
				isEnabled: class superclass notNil;
				text: (aCommandQuery commandDescription menuText
							expandMacrosWithArguments: {methods isEmpty
										ifTrue: ['…']
										ifFalse: [methods size == 1 ifTrue: [methods first] ifFalse: ['Methods']]}
							locale: Locale smalltalk).
			^true].
	^false!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the currently selected variables."

	self model removeInstanceVariables: self variables within: self searchEnvironment!

renameMethod
	(self chooseMethodForRefactoring: 'Rename Method…') 
		ifNotNil: [:method | self methodRefactoringTool renameMethod: method]!

selectedOverridableMethods
	| class |
	class := self actualClass.
	^self selectedMethods reject: [:each | each methodClass == class]! !
!Tools.ClassBrowserAbstract categoriesForMethods!
abstractInstanceVariables!commands!private!refactoring! !
methodRefactoringTool!commands!private!refactoring! !
methodsToOverride!helpers!private! !
overrideMethods!commands!private!refactoring! !
protectInstanceVariables!commands!private!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
pushDownMethods!commands!public!refactoring! !
pushMethods:!commands!private!refactoring! !
pushUpMethods!commands!public!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeInstanceVariables!public!refactoring! !
renameMethod!accessing!private! !
selectedOverridableMethods!accessing!private! !
!

!Tools.ClassSelector methodsFor!

abstractClassVariables
	"Invoke the 'Abstract Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Abstract Class Variables…')
		ifNotNil: [:varNames | self systemModel abstractClassVariables: varNames within: BrowserEnvironment new]!

abstractInstanceVariables
	"Invoke the 'Abstract Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Abstract Instance Variables…')
		ifNotNil: [:varNames | self systemModel abstractInstanceVariables: varNames within: BrowserEnvironment new]!

addClassVariable
	"Private - Invoke the 'Add Class Variable' refactoring to add a class variable to the
	currently selected class."

	self systemModel
		addClassVariableTo: self selection!

addInstanceVariable
	"Private - Invoke the 'Add Instance Variable' refactoring to add an instance variable to the
	currently selected class."

	self systemModel
		addInstanceVariableTo: self actualClass!

buildInstVarMenu: aMenu selectors: selectors
	"Private - Build a dynamic pull-out menu which lists all of a class' existing inst. var. 
	names so that one or other can be removed, renamed, etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: selectors!

buildPullUpVariablesMenu: aMenu
	| class items |
	aMenu clear.
	class := self actualClass.
	(ClassBuilder isFixedLayout: class)
		ifFalse: 
			[self
				populatePullUpVariableMenu: aMenu
				forClass: class
				command: #pullUpInstanceVariable:into:
				classVariables: false
				ifTooMany: #pullUpInstanceVariables.
			aMenu notEmpty ifTrue: [aMenu addSeparator]].
	self
		populatePullUpVariableMenu: aMenu
		forClass: class instanceClass
		command: #pullUpClassVariable:into:
		classVariables: true
		ifTooMany: #pullUpClassVariables.
	items := aMenu items.
	(items notEmpty and: [items last isDivider]) ifTrue: [aMenu removeItemAt: items size]!

buildVariablesMenu: aMenu instVarSelectors: instVarSelectors classVarSelectors: classVarSelectors 
	"Private - Build a dynamic pull-out menu which lists all of a class' existing 
	instance and class variable names so that one or other can be removed, renamed, 
	etc."

	aMenu clear.
	self populateInstVarMenu: aMenu selectors: instVarSelectors.
	(aMenu notEmpty and: [self selection classPool notEmpty]) ifTrue: [aMenu addSeparator].
	self populateClassVarMenu: aMenu selectors: classVarSelectors!

cloneClass: aClass under: superClass changes: aCompositeRefactoryChange
	| namespace newName |
	namespace := RBModel new
				changes: aCompositeRefactoryChange;
				yourself.
	
	[newName := ('CopyOf' , aClass name) asSymbol.
	newName asQualifiedReference isDefined] whileTrue.
	(CopyClassRefactoring
		model: namespace
		clone: aClass
		as: newName
		superclass: superClass) primitiveExecute!

convertToSibling
	"Invoke the 'Convert to Sibling' refactoring (inserts a new class as the common superclass of the selected
	class and its current subclasses, copying common methods to the new superclass and adding 
	#subclassResponsibility methods as necessary)."

	self systemModel
		convertToSibling: self selection!

createClassVariableAccessors
	"Prompt to generate compiled 'get' and 'set' accessor methods for the immediate
	class variables of the selected class."

	self createVariableAccessors: true!

populateClassVarMenu: aMenu selectors: selectors
	| class varNames |
	class := self selection.
	varNames := class classBindingNames.
	varNames size > self maximumVariableMenuEntries
		ifTrue: [(aMenu addCommand: selectors last description: '&Class Variable…') isModalCommand: true]
		ifFalse: 
			[self
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>']!

populateInstVarMenu: aMenu selectors: selectors 
	| class varNames |
	class := self actualClass.
	varNames := class instVarNames.
	varNames size > self maximumVariableMenuEntries 
		ifTrue: [(aMenu addCommand: selectors last description: '&Instance Variable…') isModalCommand: true]
		ifFalse: 
			[self 
				populateVarMenu: aMenu
				class: class
				command: selectors first
				variables: (varNames asSortedCollection collect: [:each | class -> each])
				format: '<2s>']!

populatePullUpVariableMenu: aMenu forClass: aClass command: commandSymbol classVariables: aBoolean ifTooMany: tooManyCommand
	| pairs |
	pairs := self
				pullUpVariableNamePairs: aBoolean
				for: aClass
				maximum: self maximumVariableMenuEntries.
	pairs isNil
		ifTrue: 
			[aMenu addCommand: tooManyCommand
				description: (aBoolean ifTrue: ['&Class Variable…'] ifFalse: ['&Instance Variable…'])]
		ifFalse: 
			[(pairs asSortedCollection: 
					[:p1 :p2 |
					p1 key == p2 key ifTrue: [p1 value < p2 value] ifFalse: [p1 key name < p2 key name]])
				do: 
					[:each |
					| msg varName |
					varName := each value.
					msg := MessageSend
								receiver: self systemModel
								selector: commandSymbol
								arguments: {varName. aClass}.
					aMenu addCommand: msg description: each key name , '.' , varName]]!

populateRefactoringMenu: aMenu 
	"Private - If the <Menu> argument is dynamic refactoring menu, then populate it with appropriate
	choices based on the currently selected class."

	| menuName |
	menuName := aMenu name.
	menuName == #pushDownInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#pushDownInstanceVariable:in: #pushDownInstanceVariables)].
	menuName == #createInstanceVariableAccessors 
		ifTrue: 
			[^self buildInstVarMenu: aMenu
				selectors: #(#createInstanceVariableAccessors:in: #createInstanceVariableAccessors)].
	menuName == #abstractInstanceVariables 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#abstractInstanceVariable:in: #abstractInstanceVariables)].
	(menuName == #protectInstanceVariables or: [menuName == #protectVariables]) 
		ifTrue: 
			[^self buildInstVarMenu: aMenu selectors: #(#protectInstanceVariable:in: #protectInstanceVariables)].
	"Generic menus that contain both class and inst vars"
	menuName == #removeVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#removeInstanceVariable:from:within: #removeInstanceVariables)
				classVarSelectors: #(#removeClassVariable:from:within: #removeClassVariables)].
	menuName == #renameVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#renameInstanceVariable:in:within: #renameInstanceVariable)
				classVarSelectors: #(#renameClassVariable:in:within: #renameClassVariable)].
	menuName == #pushDownVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#pushDownInstanceVariable:in:within: #pushDownInstanceVariables)
				classVarSelectors: #(#pushDownClassVariable:in:within: #pushDownClassVariables)].
	menuName == #pullUpVariables ifTrue: [^self buildPullUpVariablesMenu: aMenu].
	menuName == #createVariableAccessors 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#createInstanceVariableAccessors:in:within: #createInstanceVariableAccessors)
				classVarSelectors: #(#createClassVariableAccessors:in:within: #createClassVariableAccessors)].
	menuName == #abstractVariables 
		ifTrue: 
			[^self 
				buildVariablesMenu: aMenu
				instVarSelectors: #(#abstractInstanceVariable:in:within: #abstractInstanceVariables)
				classVarSelectors: #(#abstractClassVariable:in:within: #abstractClassVariables)]!

protectInstanceVariables
	"Invoke the 'Protect/Concrete Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Protect Instance Variables…') 
		ifNotNil: [:varNames | self systemModel protectInstanceVariables: varNames]!

pullUpClassVariables
	"Invoke the 'Pull Up Class Variable' refactoring on the users choice of subclass' class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self selection.
	pairs := self
				pullUpVariableNamePairs: true
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Class Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpClassVariable: each value into: class]]!

pullUpInstanceVariables
	"Invoke the 'Pull Up Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	| class pairs |
	class := self actualClass.
	pairs := self
				pullUpVariableNamePairs: false
				for: class
				maximum: SmallInteger maximum.
	pairs := (ChoicePrompter
				createOn: pairs
				multipleChoices: pairs
				caption: 'Pull Up Instance Variables…')
				getTextBlock: [:each | each key name , '.' , each value];
				showModal.
	pairs isNil
		ifFalse: 
			[| devsys |
			devsys := self systemModel.
			pairs do: [:each | devsys pullUpInstanceVariable: each value into: class]]!

pullUpVariableNamePairs: aBoolean for: class maximum: anInteger
	| pairs varNames |
	varNames := Set new.
	pairs := OrderedCollection new.
	class allSubclassesDo: 
			[:subclass |
			(aBoolean ifTrue: [subclass classBindingNames] ifFalse: [subclass instVarNames]) do: 
					[:each |
					(varNames includes: each)
						ifFalse: 
							[varNames add: each.
							varNames size > anInteger ifTrue: [^nil].
							pairs add: subclass -> each]]].
	^pairs!

pushDownClassVariables
	"Invoke the 'Push Down Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Push Down Class Variables…') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

pushDownInstanceVariables
	"Invoke the 'Push Down Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Push Down Instance Variables…') 
		ifNotNil: [:varNames | self systemModel pushDownInstanceVariables: varNames]!

queryRefactoringCommand: aCommandQuery
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery> argument."

	| selector class |
	selector := aCommandQuery commandSymbol.
	class := self actualClass.
	(#(#classRefactoringsMenu #addClassVariable) identityIncludes: selector)
		ifTrue: 
			[aCommandQuery isEnabled: class notNil.
			^true].
	#addInstanceVariable == selector
		ifTrue: 
			[| prefix |
			prefix := (class notNil and: [class isMeta]) ifTrue: ['Class '] ifFalse: [''].
			aCommandQuery
				text: (aCommandQuery commandDescription menuText expandMacrosWithArguments: {prefix}
							locale: Locale smalltalk);
				isEnabled: (class notNil and: [class isPointers]).
			^true].
	(#(#removeInstanceVariables #protectInstanceVariables #abstractInstanceVariables #renameInstanceVariable)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instVarNames notEmpty]).
				^true].
	#pushDownInstanceVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: [class subclasses notEmpty and: [class instVarNames notEmpty]]).
			^true].
	#pushDownVariables == selector
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil
						and: [class subclasses notEmpty and: [class instVarNames notEmpty or: [class classPool notEmpty]]]).
			^true].
	#pullUpInstanceVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: [class allSubclasses anySatisfy: [:each | each instVarNames notEmpty]]).
			^true].
	#pullUpClassVariables == selector
		ifTrue: 
			[aCommandQuery isEnabled: (class notNil
						and: [class instanceClass allSubclasses anySatisfy: [:each | each classBindingNames notEmpty]]).
			^true].
	(#(#renameClassVariable #removeClassVariables #pushDownClassVariables #createClassVariableAccessors #abstractClassVariables)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil and: [class instanceClass classBindingNames notEmpty]).
				^true].
	(#(#renameVariables #removeVariables #pushDownVariables #protectVariables #abstractVariables #createVariableAccessors)
		identityIncludes: selector)
			ifTrue: 
				[aCommandQuery isEnabled: (class notNil
							and: [class instVarNames notEmpty or: [class instanceClass classBindingNames notEmpty]]).
				^true].
	#pushDownVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: 
							[class subclasses notEmpty
								and: [class instVarNames notEmpty or: [class instanceClass classBindingNames notEmpty]]]).
			^true].
	#pullUpVariables == selector
		ifTrue: 
			[aCommandQuery
				isEnabled: (class notNil and: 
							[| isFixed |
							isFixed := ClassBuilder isFixedLayout: class.
							class allSubclasses anySatisfy: 
									[:each |
									(isFixed not and: [each instVarNames notEmpty]) or: [each instanceClass classBindingNames notEmpty]]]).
			^true].

	"Not a recognised refactoring command"
	^false!

removeClassVariables
	"Invoke the 'Remove Class Variable' refactoring on the users choice of class variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: true caption: 'Remove Class Variables…') 
		ifNotNil: [:varNames | self systemModel removeClassVariables: varNames within: self searchEnvironment]!

removeDuplicateMethods
	| class |
	class := self actualClass.
	(self systemModel removeMethodsDuplicatedInSuperclassOf: class)
		ifFalse: 
			[MessageBox new
				iconStyle: #notify;
				uniqueId: [self] method;
				isSuppressible: true;
				headline: '<1p> does not duplicate any of its superclass'' methods' << class;
				open]!

removeInstanceVariables
	"Invoke the 'Remove Instance Variable' refactoring on the users choice of instance variables.
	Note that the view may also implement this command with a dynamic pull-out menu (of the
	same name) which has the advantage of not requiring a dialog, but which enables the user to 
	choose only one instance variable at a time."

	(self chooseVariables: false caption: 'Remove Instance Variables…') 
		ifNotNil: [:varNames | self systemModel removeInstanceVariables: varNames within: self searchEnvironment]! !
!Tools.ClassSelector categoriesForMethods!
abstractClassVariables!commands!public!refactoring! !
abstractInstanceVariables!commands!public!refactoring! !
addClassVariable!commands!private!refactoring! !
addInstanceVariable!commands!private!refactoring! !
buildInstVarMenu:selectors:!menus!private!refactoring! !
buildPullUpVariablesMenu:!menus!private!refactoring! !
buildVariablesMenu:instVarSelectors:classVarSelectors:!menus!private!refactoring! !
cloneClass:under:changes:!private! !
convertToSibling!commands!public!refactoring! !
createClassVariableAccessors!commands!public!refactoring! !
populateClassVarMenu:selectors:!menus!private!refactoring! !
populateInstVarMenu:selectors:!menus!private!refactoring! !
populatePullUpVariableMenu:forClass:command:classVariables:ifTooMany:!menus!private!refactoring! !
populateRefactoringMenu:!menus!private!refactoring! !
protectInstanceVariables!commands!public!refactoring! !
pullUpClassVariables!commands!public!refactoring! !
pullUpInstanceVariables!commands!public!refactoring! !
pullUpVariableNamePairs:for:maximum:!menus!private!refactoring! !
pushDownClassVariables!commands!public!refactoring! !
pushDownInstanceVariables!commands!public!refactoring! !
queryRefactoringCommand:!commands!private! !
removeClassVariables!commands!public!refactoring! !
removeDuplicateMethods!commands!private!refactoring! !
removeInstanceVariables!commands!public!refactoring! !
!

!Tools.Debugger methodsFor!

canMoveMethods
	#todo.	"Not currently supported in the debugger because it rewrites the caller, which complicates the unwind"
	^false!

hasRefactorableMethodSelected
	^self isRunning not and: 
			[| method |
			method := self selectedMethod.
			method notNil and: [method isUnbound not and: [self parseTree notNil]]]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	aMonadicValuable value: self selectedMethod.
	self selectedMethod isUnbound ifTrue: [self restartMethod]!

performMethodRenameRefactoring: aMonadicValuable 
	| method home sender refactoring |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := aMonadicValuable value: method.
	refactoring isNil ifTrue: [^self].
	"Since the method of the selected frame has been renamed, the sending frame's method will
	have been rewritten, therefore we need to restart the sender frame."
	home := self findHomeFrame: self frame.
	home isNil ifTrue: [^self].
	sender := home sender.
	(sender notNil and: [sender isRestartable]) ifTrue: [self restartMethodFrame: sender]! !
!Tools.Debugger categoriesForMethods!
canMoveMethods!commands!private!refactoring! !
hasRefactorableMethodSelected!public!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
!

!Tools.MethodBrowser methodsFor!

canMoveMethods
	^self hasRefactorableMethodSelected!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected and: [self parseTree notNil]!

performMethodRefactoring: aMonadicValuable 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethod!

performMethodRenameRefactoring: aMonadicValuable
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	| refactoring method |
	self promptToSaveChanges ifFalse: [^self].
	method := self selectedMethod.
	refactoring := sourcePresenter executeRefactoring: aMonadicValuable with: method.
	refactoring isNil ifTrue: [^self].
	method := (method ifNil: [self parseContext methodClass] ifNotNil: [method methodClass])
				compiledMethodAt: refactoring newSelector
				ifAbsent: nil.
	(method notNil and: [self filter value: method]) ifTrue: [self selectMethod: method]!

performMethodsRefactoring: aMonadicValuable name: aString 
	self promptToSaveChanges ifFalse: [^self].
	^sourcePresenter executeRefactoring: aMonadicValuable with: self selectedMethods! !
!Tools.MethodBrowser categoriesForMethods!
canMoveMethods!helpers!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
performMethodRefactoring:!helpers!public!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!helpers!private!refactoring! !
!

!Tools.MethodWorkspace methodsFor!

canRefactor
	^self isEditable and: 
			[self isModified not and: 
					[self systemModel canRefactor 
						and: [parentPresenter notNil and: [parentPresenter hasRefactorableMethodSelected]]]]!

executeRefactoring: aMonadicValuable
	^aMonadicValuable on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

executeRefactoring: aMonadicValuable with: anObject
	^[aMonadicValuable value: anObject]
		on: OperationAborted
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			nil]
		on: Notification
		do: 
			[:ex |
			self errorModel ifNotNil: [:status | status value: ex].
			ex resume]!

fontOfStyle: style 
	| font |
	font := style fontName ifNil: [view actualFont copy] ifNotNil: [:face | Font name: face].
	style restyleFont: font.
	^font!

performCodeRefactoring: refactoringOperation 
	self 
		performMethodRefactoring: [:method | refactoringOperation value: method value: self selectedNode]!

performMethodRefactoring: aMonadicValuable 
	^parentPresenter performMethodRefactoring: aMonadicValuable!

performMethodRenameRefactoring: aBlockClosure 
	^parentPresenter performMethodRenameRefactoring: aBlockClosure!

renameVariable: aStVariableNode operation: operationBlock validationBlock: validationBlock
	| name range style editor font zoom newName |
	range := aStVariableNode sourceInterval.
	name := self plainTextRange: range.
	self assert: [aStVariableNode name = name].
	editor := InplaceTextEditor createOn: name asValue.
	editor validater: 
			[:candidateName |
			"If the name is unchanged, treat as valid and ignore later"
			candidateName = name
				ifTrue: [ValidationResult new]
				ifFalse: 
					[| result |
					result := validationBlock value: candidateName.
					result hint ifNotNil: [:ex | self errorModel value: ex].
					result]].
	editor textRectangle: (view boundingRectangleOfTextRange: range).
	"Set the same font as the existing text so there is no visible 'jump' - we need to account for any zooming too"
	style := view styleAt: range start.
	font := self fontOfStyle: style.
	zoom := view zoomLevel.
	zoom = 0
		ifFalse: 
			[| points |
			points := font pointSize.
			font := font copy.
			font pointSize: points + zoom].
	editor font: font.
	newName := editor showModal.
	self errorModel value: nil.
	newName isNil ifFalse: [
			newName = name ifFalse: [self performMethodRefactoring: [:method | operationBlock value: newName]]]! !
!Tools.MethodWorkspace categoriesForMethods!
canRefactor!public!refactoring!testing! !
executeRefactoring:!helpers!private!refactoring! !
executeRefactoring:with:!helpers!private!refactoring! !
fontOfStyle:!operations!private!refactoring! !
performCodeRefactoring:!helpers!private!refactoring! !
performMethodRefactoring:!helpers!private!refactoring! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
renameVariable:operation:validationBlock:!operations!private!refactoring! !
!

!Tools.PackageBrowserShell methodsFor!

addParameter
	"Private - Command to invoke the Add Parameter to Method refactoring, prompting the user for 
	the selector of the method to which the parameter is added, and constrained to operate
	only within the selected packages."

	(self chooseMethodForRefactoring: 'Add Parameter in Package(s)…') 
		ifNotNil: [:method | self addParameterTo: method]
!

addParameterTo: aCompiledMethod
	self model addParameterToMethod: aCompiledMethod inPackages: self packages!

addParameterToMethod
	"Private - 'Loose Methods' card context menu command to invoke the 
	'Add Parameter to Method refactoring' against a selected loose method, 
	constrained within the selected packages."

	self addParameterTo: self selectedMethod!

chooseMethodsForRefactoring: aString
	| selector methods definitions searchEnv |
	searchEnv := self searchEnvironment.
	methods := self selectedMethods.
	methods isEmpty ifFalse: [^searchEnv forMethods: methods].
	selector := self model chooseSelectorInEnvironment: searchEnv caption: aString.
	selector isNil ifTrue: [^searchEnv forMethods: #()].
	definitions := searchEnv definitionsOf: selector.
	definitions isEmpty
		ifTrue: 
			[MessageBox
				errorMsg: ('There are no definitions of <1p> in the selected package(s).' expandMacrosWith: selector)].
	^definitions!

hasRefactorableMethodSelected
	^self hasEditableMethodSelected!

parseTree
	^self selectedMethod ifNotNil: [:method | Parser parseExistingMethodNoError: method]!

performMethodRenameRefactoring: aMonadicValuable 
	"Private - Perform a refactoring that might change the name of the selected method. We
	maintain the selection if possible."

	^aMonadicValuable value: self selectedMethod!

performMethodsRefactoring: aMonadicValuable name: aString
	| methods |
	methods := self chooseMethodsForRefactoring: '<1s> from Package(s)…' << aString.
	methods isEmpty ifTrue: [^nil].
	^[aMonadicValuable value: methods allMethods] on: Notification
		do: 
			[:ex |
			statusModel value: ex.
			ex resume]!

promptForMethodName: aCompiledMethod caption: aString allowExisting: aBoolean
	| methodName |
	methodName := ScopedMethodName fromMethod: aCompiledMethod.
	methodName packages: self packages.
	^self systemModel
		promptForMethodName: methodName
		caption: aString
		allowExisting: aBoolean!

queryRefactoringCommand: aCommandQuery 
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| selector |
	selector := aCommandQuery commandSymbol.
	(#(#methodRefactoringsMenu #renameMethod #addParameter #removeParameter) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: self hasPackages.
			^true].
	(#(#removeMethods) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethods notEmpty]).
			^true].
	(#(#addParameterToMethod) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (self hasPackages and: [self selectedMethod notNil]).
			^true].
	(#(#removeParameterMenu) identityIncludes: selector) 
		ifTrue: 
			[| method |
			method := self selectedMethod.
			aCommandQuery isEnabled: (self hasPackages and: [method notNil and: [method argumentCount > 0]]).
			^true].
	"Not a refactoring command"
	^false!

removeMethod
	"Private - Prompt the user for a selector and invoke the 'Safe Remove Method' refactoring to 
	remove the specified methods from the system if defined but not referenced from within 
	any of the selected packages ((i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	"Implemementation Note: This command implementation is used only if there are no 
	methods selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	| methods |
	methods := self chooseMethodsForRefactoring: 'Safe Remove Methods from Package(s)…'.
	methods isEmpty
		ifFalse: [self model basicRemoveMethodsIn: methods within: self selectionEnvironment]!

removeMethods
	"Private - 'Loose Methods' card context menu command to invoke the 'Safe Remove Method' 
	refactoring. Removes the selected methods from the system if not referenced from within any 
	of the selected packages (i.e. references from methods owned by other packages are not
	considered as part of the decision as to whether it will be safe to remove the method)."

	(MessageBox new
		headline: 'Remove unreferenced loose methods?';
		defaultButton: 2;
		customButtons: #(#(#yes '&Remove') #(#no '&Don''t Remove'));
		isCancellable: true;
		confirm: 'The selected methods will be removed if unreferenced from the selected packages. This may not preserve behaviour if the methods are referenced from other packages.')
			ifTrue: [self model basicRemoveMethods: self selectedMethods within: self selectionEnvironment]!

removeParameter
	"Private - Command to invoke the Remove Parameter to Method refactoring, but constrained to operate
	only within the selected packages."

	| method ast arg |
	method := self chooseMethodForRefactoring: 'Remove Parameter in Package(s)…'.
	method isNil ifTrue: [^self].
	ast := method parseTreeNoError.
	ast isNil ifTrue: [^self].
	arg := ChoicePrompter choices: ast argumentNames
				caption: 'Remove Parameter from <1p> in Package(s)…' << method selector.
	arg notNil ifTrue: [methodRefactoringTool removeParameter: arg from: method]!

renameLooseMethod
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method' refactoring against the selected loose method, but configured to rename 
	only within selected packages."

	methodRefactoringTool renameMethod!

renameLooseMethodReferences
	"Private - 'Loose Methods' card context menu command to invoke the  'Rename 
	Method References' refactoring against the selected loose method, but configured to rename 
	references only within selected packages."

	self renameMethodReferences: self selectedMethod!

renameMethod
	"Private - Initiate a 'Rename' method refactoring against the selected method,
	but configured to rename only within the selected packages."

	"Implemementation Note: This command implementation is used if there is not exactly one
	method selected on the methods tab. It allows the selection of an arbitrary method to be
	renamed at package scope, not just loose methods."

	(self chooseMethodForRefactoring: 'Rename Method in Package(s)…') 
		ifNotNil: [:method | methodRefactoringTool renameMethod: method]!

renameMethodReferences: aCompiledMethod
	| methodName |
	methodName := self
				promptForMethodName: aCompiledMethod
				caption: 'Rename References to <1p> in Package(s)…' << aCompiledMethod selector
				allowExisting: true.
	methodName notNil ifTrue: [self model renameMethodReferences: aCompiledMethod to: methodName]! !
!Tools.PackageBrowserShell categoriesForMethods!
addParameter!commands!private!refactoring! !
addParameterTo:!private!refactoring! !
addParameterToMethod!commands!public!refactoring! !
chooseMethodsForRefactoring:!private!refactoring! !
hasRefactorableMethodSelected!private!refactoring!testing! !
parseTree!commands!private! !
performMethodRenameRefactoring:!helpers!private!refactoring! !
performMethodsRefactoring:name:!private! !
promptForMethodName:caption:allowExisting:!helpers!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeMethod!commands!public!refactoring! !
removeMethods!commands!public!refactoring! !
removeParameter!commands!private!refactoring! !
renameLooseMethod!commands!private!refactoring! !
renameLooseMethodReferences!commands!private!refactoring! !
renameMethod!commands!public!refactoring! !
renameMethodReferences:!operations!private!refactoring! !
!

!Tools.PackageSelector methodsFor!

moveAllTempsToInnerScope
	(MessageBox new
		headline: 'Move All Temps to Inner Scope?';
		confirm: 'This refactoring will move all temporaries in all methods in the selected package(s) into the tightest scope that contains both the variable assignment and references. Any unreferenced temporaries will be removed.

Are you sure that you would like to proceed?')
			ifTrue: [self systemModel moveAllTempsToInnerScope: self selectionEnvironment]!

queryRefactoringCommand: aCommandQuery 
	"Private - Enters details about a potential refactoring command for the receiver into the 
	<CommandQuery> argument."

	| cmd canRefactor |
	cmd := aCommandQuery commandSymbol.
	canRefactor := self systemModel canRefactor and: [self hasPackages].
	(#(#removeDuplicateMethods) identityIncludes: cmd) 
		ifTrue: 
			[aCommandQuery isEnabled: canRefactor.
			^true].
	"Not a refactoring command"
	^false!

removeDuplicateMethods
	| count pkgs |
	pkgs := self packages.
	count := pkgs inject: 0 into: [:sum :eachPackage | sum + eachPackage classNames size].
	(ProgressDialog operation: 
			[:progress |
			| i devsys |
			i := 0.
			devsys := self systemModel.
			pkgs do: 
					[:eachPackage |
					progress text: eachPackage name.
					eachPackage classes do: 
							[:eachClass |
							i := i + 1.
							progress value: i * 100 // count.
							devsys removeMethodsDuplicatedInSuperclassOf: eachClass]]])
		caption: 'Remove Methods Duplicating Superclass'' from Package(s)…';
		showModal! !
!Tools.PackageSelector categoriesForMethods!
moveAllTempsToInnerScope!commands!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
removeDuplicateMethods!development!private! !
!

!Tools.RemoveClassConstantChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Tools.RemoveClassConstantChange class categoriesForMethods!
icon!constants!public! !
!

!Tools.RemoveNamespaceImportChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Tools.RemoveNamespaceImportChange class categoriesForMethods!
icon!constants!public! !
!

!Tools.RemoveSharedVariableChange class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'EditClear.ico'! !
!Tools.RemoveSharedVariableChange class categoriesForMethods!
icon!constants!public! !
!

!Tools.SmalltalkToolShell methodsFor!

chooseMethodForRefactoring: aString 
	^self systemModel chooseMethodFromEnvironment: self selectionEnvironment caption: aString!

queryRefactoringCommand: aCommandQuery 
	"Private - Enter details about a potential refactoring command for the receiver 
	into the <CommandQuery>."

	^false! !
!Tools.SmalltalkToolShell categoriesForMethods!
chooseMethodForRefactoring:!private!refactoring! !
queryRefactoringCommand:!commands!private!refactoring! !
!

!UI.Dialog methodsFor!

validationDwell
	"The <Duration> to wait after the user has stopped typing before re-validating and possibly showing a hint bubble."

	^1 seconds! !
!UI.Dialog categoriesForMethods!
validationDwell!constants!public! !
!

"End of package definition"!

