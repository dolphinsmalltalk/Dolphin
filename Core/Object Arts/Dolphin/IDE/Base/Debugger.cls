"Filed out from Dolphin Smalltalk 7"!

SmalltalkToolShell subclass: #Debugger
	instanceVariableNames: 'process topFrame temp tempCount depth flags breakWhen stackPresenter sourcePresenter tempsPresenter inspectorPresenter breakAction suspendingList _method refactoringTool'
	classVariableNames: 'AnimateMask AnimatePause DefaultStackDepth DisassemblyMask EnableDynamicMenus MainMask RestartOnMethodSave ResumableMask RunMask ShowWalkbacks SkipTable StackDepthIncrement'
	poolDictionaries: 'CompilerFlags OpcodePool'
	classInstanceVariableNames: ''!
Debugger guid: (GUID fromString: '{87B4C6BD-026E-11D3-9FD7-00A0CC3E4A32}')!
Debugger comment: 'Debugger is a <SmalltalkToolShell> that implements the standard debugging tool. The debugger is usually invoked from a walkback dialog by pressing the Debug button. Walkbacks are displayed in the development environment when a breakpoint (''self halt'') is encountered, or when an unhandled exception occurs. It is also possible to configure the system so that debuggers are opened automatically when breakpoints are encountered or errors occur (see the Debugger options in Dolphin Options), though this is not particularly recommended as it can make the system crash if the error or breakpoint is in some code that is itself used by the Debugger.

Dolphin''s Debugger does not simulate execution as in some Smalltalk''s, but instead uses the VM''s built-in debugging event generation to run the code and interrupt it at appropriate points. This results in more consistent and faster execution, although note that the debugger will recompile methods being stepped through to insert breakpoints and this may cause some peephole compiler optimisations to be lost.

The protocol <debugEventHandler> shows the messages sent (indirectly via Processor) by the VM when debug events occur such as breakpoints and single-steps. These debug events could quite easily be used for other purposes such as profiling tools. However note that this protocol is private, and may change in future versions. It is worth noting that single-step events are generated by hooking into the message dispatch mechanism in such a way that has no measurable effect on the speed of normal operation, and breakpoints are generated by inserting a breakpoint instruction rather than by performing conditional tests (i.e. the VM does not contain any code to support debugging which would slow down normal operation, and hence there is no separate debug/release build).

Dolphin serializes callback returns to maintain LIFO order on the machine stack even in the presence of multiple threads of execution (Smalltalk Processes) and thus it is quite feasible to debug into callbacks which route through external code such as parts of the OS, for example one can step into a SendMessage call and break in the Dolphin window procedure. One can also debug through COM method invocations, even back into Dolphin, and set breakpoints in COM method implementations that will be actioned even when the COM object is being hosted by an external client such as VB. However this is a Smalltalk debugger, and one cannot use it to debug into external code written in other languages.

Caution: Although modifying the Debugger can be fun it is quite easy to crash the system if a mistake is made. You should also note that if you develop your own custom view the use of a virtual ListView for the stack presenter is not recommended since the stack may change dynamically and become momentarily invalid at just the point that the control requests display details.

Instance Variables:
	process				<Process> being debugged.
	topFrame			<StackFrame> which is at the top of the debugger''s stack.
	temp				<Object> the contents of the currently selected instance variable.
	tempCount			<integer> count of temporaries in the currently selected stack frame.
	depth				<integer> count of stack frames currently listed.
	flags				<integer> flags controlling the debugger''s behaviour.
	breakWhen			<monadicValuable> used to determine the next execution should be interrupted.
	stackPresenter		<ListPresenter> used to display the stack frames.
	sourcePresenter		<SmalltalkWorkspace> holding the source/this assembly of the selected frame.
	tempsPresenter		<ListPresenter> holding the list of temporaries in the selected frame.
	inspectorPresenter	<SmalltalkWorkspace>  holding the value of the selected temporary variable.
	breakAction			<niladicValuable>. The second half of a composite action to be performed after an unwind.
	suspendingList		<Semaphore> on which debugged process was suspended when interrupted (or nil if none).
	_method			<CompiledCode>. Method associated with selected frame.
	refactoringTool		<MethodRefactoringTool>. Implements method refactorings (in DPRO only).

Class Variables:
	AnimateMask		<integer> bit-mask for testing/setting the animation flag
	AnimatePause		<integer> delay between steps when animating.
	DefaultStackDepth 	<integer> initial depth of the process stack display
	DisassemblyMask	<integer> bit-mask for testing/setting the disassembly view flag
	EnableDynamicMenus	<boolean> option controlling whether dynamic menus are build and displayed or not.
	MainMask			<integer> bit-mask for testing/setting the main Process flag
	RestartOnMethodSave	<boolean> option controlling whether saving a modified method restarts the frame
	ResumableMask		<integer> bit-mask for testing/setting the resumable Process flag
	RunMask 			<integer> bit-mask for testing/setting the running flag.
	ShowWalkbacks		<boolean> option controlling whether walkback dialogs are displayed or not
	SkipMethods		<LookupTable> of methods not to break in.
	StackDepthIncrement	<integer> number of frames by which to increase the depth of the stack on request.
	TerminateOnClose	<Symbol>. Option controlling action on closing debugger in respect of the debugged process.
	ArgumentClasses	<Set> of <Class>. Generic classes to be used in place of specific classes when naming auto-generated arguments for the Implement In command.
'!
!Debugger categoriesForClass!Development!MVP-Presenters!MVP-Resources-IDE Tools! !
!Debugger methodsFor!

accept
	"Private - Saves the current method source, restarting the method frame if the system
	options so indicate."

	"Implementation Note: Because we don't employ a separate presenter for the inspector text
	pane, we need to test the focus to see how to act on the command."

	inspectorPresenter hasFocus 
		ifTrue: [self acceptVariableValue]
		ifFalse: [self accept: self class restartOnMethodSave methodSource: self source]!

accept: aBoolean methodSource: aString 
	"Private - Saves the current method source, optionally restarting the frame depending on the
	value of the <Boolean> argument.."

	| method originalSelection hadErrors devsys |
	originalSelection := sourcePresenter view selectionRange.
	method := self selectedMethod.
	hadErrors := false.
	devsys := self systemModel.
	
	[devsys 
		compile: aString
		in: method methodClass
		categories: nil
		package: nil
		extraFlags: Interactive] 
			on: devsys compilationWarningClass
			do: 
				[:cw | 
				cw
					toTrace;
					resume]
			on: Compiler errorClass
			do: 
				[:ce | 
				hadErrors 
					ifFalse: 
						[hadErrors := true.
						sourcePresenter
							text: aString;
							selectionRange: ce range].
				ce okCancel].
	hadErrors ifTrue: [^self].
	sourcePresenter view selectionRange: originalSelection.
	aBoolean ifTrue: [self restartMethod] ifFalse: [sourcePresenter isModified: false]!

acceptNoRestart
	"Private - Saves the current method source without restarting the frame (i.e. the debugged
	process becomes out of sync. with the current method)."

	self accept: false methodSource: self source!

acceptVariableValue
	"Private - Evaluate an expression in the inspectorPresenter and save the result as the new
	value of the selected variable in the temps list."

	"If there is no selection then the entire workspace is selected for consistency with saving
	method source. This also works rather better with word wrap too."

	| newValue |
	inspectorPresenter view hasSelection ifFalse: [inspectorPresenter view selectAll].

	"Evaluate the new value and keep a copy of the old value for undo purposes"
	newValue := inspectorPresenter evaluateItIfFail: [^self].
	self setSelectedVariableTo: newValue!

addToCommandRoute: route 
	"Update the <OrderedCollection>, path, with the receiver's contribution to the command path
	held by the <CommandPolicy>, route. Answer the next <Presenter> to visit.
	The receiver is guaranteed not to be on the command path already."

	"Implementation Note: We add our method refactoring tool to the command route, but only in
	DPRO"

	refactoringTool notNil ifTrue: [route appendTarget: refactoringTool].
	^super addToCommandRoute: route!

allFrames
	"Private - Include all stack frames in the call stack. There cannot possibly be any more
	than the size of the process."

	self depth: process size!

animatePause
	"Answer the number of milliseconds to pause between each step when animating the debugged
	process."

	^self class animatePause
!

beAnimated: aBoolean
	"Private - Set/reset the animation flag."

	flags := flags mask: AnimateMask set: aBoolean!

beBroken
	"Private - Set the break flag."

	flags := flags maskClear: RunMask.	"no longer running"
	Processor enableInterrupts.
	self mainView enable

	!

beDisassembled: aBoolean
	"Private - Set/reset the receiver's disassembly flag."

	flags := flags mask: DisassemblyMask set: aBoolean!

beRunning
	"Private - Put the debugger and process into debug run mode."

	process debugger: self.
	flags := flags maskSet: RunMask!

blockedRestartWarning: message 
	"Private - There seems to be a later callback from the outside world which needs to return
	before the debugged process can unwind an earlier callback. Refresh the display to show
	where it is blocked, and then warn the user, giving them the opportunity to bang out."

	| resp mb |
	topFrame := process topFrame.
	self populateStackModel.
	mb := MessageBox new.
	mb buttonStyle: #okCancel.
	mb caption: ('Restarting <1p>>><2s>...' expandMacrosWith: message receiver class name
				with: message selector).
	resp := mb 
				warning: 'The stack unwind required to restart this frame is currently blocked, probably due to a Debugger or dialog opened after this one.

To allow the restart to complete, you will need to find and close any such windows, in the meantime this debugger will be disabled.
Alternatively you can cancel this operation, which will stop this debugging session.'.
	resp == #cancel ifTrue: [process terminate]!

break: interruptFrame 
	"Private - Break the debugged process at the specified break, and refresh the receiver's
	display (unless updates are deferred, i.e. the debugger is performing a composite operation
	which is only partially completed)."

	self beBroken.
	self isInCompositeOp 
		ifTrue: 
			[topFrame := interruptFrame.
			"Complete the composite op, but not in the debugged process"
			breakAction postToMessageQueue.
			breakAction := nil]
		ifFalse: 
			["Update the display if not part way through a composite operation"
			(topFrame = interruptFrame and: [self frame index <= interruptFrame index]) 
				ifTrue: [self refreshFrame]
				ifFalse: 
					[topFrame := interruptFrame.
					self populateStackModel]].
	self suspend
	"N.B. There must be no further code after this point"!

breakFrame: aStackFrame 
	"Private - Set the frame on which to break."

	self makeDebugFrame: aStackFrame.
	self breakWhen: [:iFrame | iFrame index <= aStackFrame index]!

breakWhen: discriminator 
	"Private - Set the break decision test to the monadic valuable, discriminator. The argument
	to the valuable is the StackFrame interrupted by a soft-breakpoint. If the discriminator
	answers false, then execution will continue to the next soft-breakpoint."

	"Implementation Note: The discriminator should complete its operation as quickly as
	possible, because it is evaluated with async. events disabled, and because the debugger will
	run debugged processes at a snail like pace at times."

	breakWhen addLast: discriminator!

browseDefinitions
	"Private - Open a new method browser on the definitions of the of the currently selected
	stack frame's selector."

	self browseDefinitionsMatching: (MethodSearch newSelector: self selectedMethod selector)
		in: self searchEnvironment!

browseDefinitionsMatching: aMethodSearch in: aBrowserEnvironment 
	| definitions |
	definitions := OrderedCollection 
				with: (self systemModel definitionsMatching: aMethodSearch in: aBrowserEnvironment).
	self selectedMethod 
		ifNotNil: 
			[:method | 
			definitions add: (self systemModel definitionsMatching: aMethodSearch
						in: (aBrowserEnvironment forClassHierarchyOf: method methodClass))].
	self systemModel browseMethodsInEnvironments: definitions!

browseDefinitionsOfSelector: aSymbol in: aBrowserEnvironment 
	"Private - Opens a MethodBrowser on all the methods whose selectors match the specified
	<readableString> pattern in the scope of the specified <BrowserEnvironment>."

	self browseDefinitionsMatching: (MethodSearch newSelector: aSymbol) in: aBrowserEnvironment!

browseHierarchy
	"Private - Open a new class browser on the currently selected method or the system classes
	if there is no selection."

	"If we are attempting to browse a #doesNotUnderstand: method then we want to browse the
	original receiver's class since that's where we'll most likely want to implement the
	method."

	self selectedMethod selector = #doesNotUnderstand: 
		ifTrue: [self systemModel browseHierarchy: self frame receiver class]
		ifFalse: [self systemModel browseClassHierarchyOfMethod: self selectedMethod]!

browseIt
	"Open a default browser on the current method"

	tempsPresenter hasFocus ifTrue: [self browseVariableClass] ifFalse: [self browseHierarchy]!

browseMessages
	"Private - Browse the definitions of one of the messages sent within the method of the
	currently selected stack frame. Prompt for which message to actually browse."

	self model browseMessagesSentBy: self selectedMethod in: self searchEnvironment!

browseMethodInheritanceChain
	"Private - Open a method browser displaying the definitions of the currently selected stack
	frame's method's selector in its superclass chain."

	self model browseMethodHierarchyFrom: self selectedMethod!

browseReferences
	"Context-sensitive 'Browse References' command. In this case browse refs. to the 
	current selector."

	self browseReferencesMatching: (MethodSearch newSelector: self selectedMethod selector)
		in: self searchEnvironment!

browseReferencesMatching: aMethodSearch in: aBrowserEnvironment 
	| references |
	references := OrderedCollection 
				with: (self systemModel referencesMatching: aMethodSearch in: aBrowserEnvironment).
	self selectedMethod 
		ifNotNil: 
			[:method | 
			references add: (self systemModel referencesMatching: aMethodSearch
						in: (aBrowserEnvironment forClassHierarchyOf: method methodClass))].
	self systemModel browseMethodsInEnvironments: references!

browseReferencesToLiteral: anObject in: aBrowserEnvironment 
	"Private - Opens a MethodBrowser on all the methods that refer to aString from their literal frames
	(aString is normally a symbolic selector), within the scope of the specified
	<BrowserEnvironment>."

	self browseReferencesMatching: (MethodSearch newLiteral: anObject) in: aBrowserEnvironment!

browseSystem
	"Open a new system browser on the currently selected method or the system classes if there
	is no selection."

	"If we are attempting to browse a #doesNotUnderstand: method then we want to browse the
	original receiver's class since that's where we'll most likely want to implement the
	method."

	(self selectedMethod selector = #doesNotUnderstand: or: [self selectedMethod isExpression]) 
		ifTrue: [self model browseSystem: self frame receiver class]
		ifFalse: [self model browseSystemOnMethod: self selectedMethod]!

browseVariableClass
	temp browse!

buildParseTree
	^self selectedMethod 
		ifNotNil: 
			[:method | 
			method isExpression 
				ifTrue: [SmalltalkParser parseExpression: method getSource in: method methodClass]
				ifFalse: [SmalltalkParser parseExistingMethodNoError: method]]!

canImplementMessage
	"Private - Answer whether the receiver can implement a stub for the message associated with 
	the current stack frame."

	| frame selector method |
	frame := self frame.
	(frame isNil or: [(frame := frame homeFrame) isNil]) ifTrue: [^false].
	method := frame method.
	selector := method selector.
	^(selector == #doesNotUnderstand: and: [Compiler isValidSelector: frame arguments first selector]) 
		or: [(Compiler isValidSelector: selector) and: [method methodClass ~= frame receiver class]]!

canSaveMethod
	"Private - Answer whether the text of the method displayed in the receiver can be saved."

	^self hasEditableMethodSelected!

clearCachedMethodInfo
	_method := nil.
	sourcePresenter clearParseTree!

continue: aProcess with: anObject
	| frame |
	process debugger: nil.
	frame := aProcess suspendedFrame.
	self
		beBroken;
		caption: aProcess printString;
		process: aProcess topFrame: frame;
		return: anObject toFrame: frame!

createComponents
	"Create the presenters contained by the receiver"

	super createComponents.
	stackPresenter := self 
				add: ListPresenter new
				name: 'stack'
				helpId: 10882.
	tempsPresenter := self 
				add: ListPresenter new
				name: 'temps'
				helpId: 10883.
	inspectorPresenter := self 
				add: self workspaceClass new
				name: 'inspector'
				helpId: 10884.
	sourcePresenter := self 
				add: Smalltalk developmentSystem methodWorkspaceClass new yourself
				name: 'source'
				helpId: 10885.
	sourcePresenter areVariableTipsEnabled: true.
	refactoringTool := self systemModel newMethodRefactoringToolFor: self!

createSchematicWiring
	"Create the trigger wiring for the receiver"

	super createSchematicWiring.
	self 
		when: #closeRequested:
		send: #onCloseRequested:
		to: self.
	stackPresenter
		when: #selectionChanging:
			send: #onFrameSelectionChanging:
			to: self;
		when: #selectionChanged
			send: #onFrameSelected
			to: self;
		when: #actionPerformed
			send: #browseIt
			to: self.
	tempsPresenter
		when: #selectionChanged
			send: #onTempSelected
			to: self;
		when: #actionPerformed
			send: #inspectIt
			to: self.
	sourcePresenter 
		when: #expressionEvaluated:
		send: #onExpressionEvaluated:
		to: self.
	inspectorPresenter 
		when: #expressionEvaluated:
		send: #onExpressionEvaluated:
		to: self.
	(self model)
		when: #methodUpdated:
			send: #onMethodUpdated:
			to: self;
		when: #methodRemoved:
			send: #onMethodRemoved:
			to: self!

cursorIPRange
	"Private - Answer the IP range which includes the current cursor position in the source
	pane."

	| pos map i start end frame |
	frame := self frame.
	self makeDebugFrame: frame.	"first make sure it is a debug frame."
	pos := sourcePresenter view caretPosition.
	map := frame textMap.
	i := map findFirst: [:a | a value includes: pos].
	i == 0 
		ifTrue: 
			[pos < map first value first 
				ifTrue: 
					[start := 1.
					end := map first key]
				ifFalse: 
					[start := map last key.
					end := self selectedMethod byteCodes size]]
		ifFalse: 
			[start := (map at: i) key.
			end := i == map size ifTrue: [self selectedMethod byteCodes size] ifFalse: [(map at: i + 1) key]].
	^start to: end!

debugState: aString
	"Private - Set the subcaption for the debugger which displays something about the state of
	the debugger."

	self caption: process name printString, ' [', aString, ']'!

defaultHelpId
	^10881!

depth
	"Private - Answer the requested stack depth to be displayed by the receiver (the actual
	stack depth may be less if there are insufficient frames)."

	^depth!

depth: anInteger 
	"Private - Set the stack depth displayed by the receiver.

	Note the use of #selectionByIndex rather than #selection, this is because the identity
	relationship between the existing values frames and those present after populateStackModel
	may not hold."

	| selectionIndex |
	depth := anInteger.
	process isNil ifTrue: [^self].
	selectionIndex := stackPresenter view selectionByIndex.
	self populateStackModel.
	(selectionIndex between: 1 and: depth) 
		ifTrue: [stackPresenter view selectionByIndex: selectionIndex]!

displayFrame
	"Private - Update the receiver to reflect the selected stack frame."

	self frame isNil ifTrue: [^self].
	self displaySource.
	self updateTemporaries!

displaySource
	"Private - Refresh the receiver's source display to reflect a newly selected frame."

	| method text styler |
	sourcePresenter evaluationContext: self frame receiver.
	method := self selectedMethod.
	self isDisassembled 
		ifTrue: 
			[styler := Smalltalk developmentSystem disassemblyStylerClass.
			text := method disassembly]
		ifFalse: 
			[styler := method stylerClass.
			text := method getSource].
	sourcePresenter
		text: text;
		stylerClass: styler;
		isModified: false.
	self setSourceSelection!

displayTemp
	"Private - Inspect the selected temporary, anObject."

	inspectorPresenter text: (self class debugPrintStringFor: temp)

	"Rather than change the context to the temp, I think I prefer it to remain as the frame receiver.
	The temp can be accessed by name"
	"inspectorPresenter evaluationContext: temp."
	!

emitKeywordSignatureFor: aMessage in: aClass on: aPuttableStream 
	| argNames instVars |
	argNames := OrderedCollection new.
	instVars := aClass allInstVarNames.
	argNames addAll: instVars.
	aMessage selector keywords with: aMessage arguments
		do: 
			[:keyword :arg | 
			| x argName argNameStem |
			aPuttableStream
				nextPutAll: keyword;
				space.
			argName := argNameStem := self nameForArgument: arg.
			x := 1.
			[argNames includes: argName] whileTrue: [argName := argNameStem , (x := x + 1) displayString].
			argNames add: argName.
			aPuttableStream
				nextPutAll: argName;
				space].
	^argNames copyFrom: instVars size + 1!

findBlockHome: aBlockFrame 
	| home method |
	home := aBlockFrame homeFrame.
	home notNil ifTrue: [^home].
	"Its a block without an outer ref, so we don't really know where its home frame is. Best we
	can do is to assume it is the nearest frame for the same method."
	home := aBlockFrame sender.
	method := aBlockFrame method.
	[home isNil or: [home isBlockFrame not and: [home method == method]]] 
		whileFalse: [home := home sender].
	^home!

findHomeFrame: aStackFrame 
	^aStackFrame isBlockFrame ifTrue: [self findBlockHome: aStackFrame] ifFalse: [aStackFrame]!

frame
	"Private - Answer the currently selected stack frame."

	^stackPresenter selectionOrNil!

frameCalledFrom: frame
	"Private - Answer the frame called from the <StackFrame>, frame, which 
	must not be the top frame. This is done by a sequential search from the top frame."

	 | calledFrame nextFrame |
	nextFrame := topFrame.
	[	calledFrame := nextFrame.
		nextFrame := calledFrame sender.
		nextFrame = frame] whileFalse.
	^calledFrame!

frames
	"Private - Answer the list of stack frames"

	^stackPresenter list!

generateStubFor: aMessage inClass: aClass 
	^(self systemModel 
		compile: (self stubTextFor: aMessage inClass: aClass)
		in: aClass
		categories: #()
		package: nil
		extraFlags: 0) method 
		notNil!

hasEditableMethodSelected
	^(self isRunning or: [self isAnimating]) not 
		and: [self isDisassembled not and: [self hasMethodSelected]]!

hasEditableMethodsSelected
	^self hasEditableMethodSelected!

hasMethodSelected
	^self selectedMethod notNil and: [self selectedMethod isExpression not]!

initialize
	"Private - Initialize the receiver"

	super initialize.
	depth := DefaultStackDepth.
	flags := 0.
	breakWhen := OrderedCollection new!

inspectIt
	"Private - Open an inspector on the currently selected temporary."

	temp inspect!

inspectReferences
	"Private - Open a new Inspector on all the objects which references the currently selected temporary."

	| refs |
	refs := temp allReferences copyWithout: self.
	refs isEmpty 
		ifTrue: 
			[MessageBox 
				notify: ('There are no additional references to:<n><t><1p>' expandMacrosWith: tempsPresenter selection first)]
		ifFalse: [refs inspect]!

isAnimating
	"Private - Answer whether the receiver is in 'Animate' mode (i.e. repeatedly single-stepping
	through the debugged code)."

	^flags anyMask: AnimateMask!

isDisassembled
	"Private - Answer whether the receiver is in disassembly mode."

	^flags anyMask: DisassemblyMask
!

isFrameRestartable
	"Private - Answer whether the selected frame is restartable. Some methods, such as callback
	entry points, cannot be restarted at all, others not reliably."

	^self frame isRestartable!

isInCompositeOp
	"Private - Answer whether the receiver is performing a composite operation (if so then
	display updates should be deferred)."

	^breakAction notNil!

isMain: aBoolean
	"Private - Set the isMain flag."

	flags := flags mask: MainMask set: aBoolean!

isResumable
	"Private - Answer whether the process the receiver is debugging is resumable."

	^flags anyMask: ResumableMask
!

isRunning
	"Private - Answer whether the process the receiver is debugging is currently running."

	^flags anyMask: RunMask!

killProcess
	"Private - Kill the debugged process, if the user confirms that that is his wish."

	| mb |
	mb := MessageBox new.
	mb buttonStyle: #okCancel.
	^(mb warning: 'Process will be terminated without unwinding') == #ok 
		ifTrue: 
			["Killing process will not run the unwind blocks, so the debugger will not
			 get closed, we must therefore force that here."
			process
				debugger: nil;
				kill.
			self view close]!

mainView
	"Private - Answer the debuggers main composite view which contains all the views which
	display something about the current execution state."

	^self view viewNamed: 'main'!

makeDebugFrame: aStackFrame 
	"Private - Mutate the specified stack frame into a debug stack frame with a debug method and
	suitably modified IP."

	aStackFrame isNil 
		ifFalse: 
			[aStackFrame makeDebug.
			_method := nil]!

markMethodAsUnbound: oldMethod
	| list selector methodClass |
	self isRunning ifTrue: [^self].
	list := stackPresenter model.
	selector := oldMethod selector.
	methodClass := oldMethod methodClass.
	list keysAndValuesDo: 
			[:eachIndex :eachFrame | 
			| eachMethod |
			eachMethod := eachFrame method.
			(eachMethod selector == selector and: [eachMethod methodClass == methodClass]) 
				ifTrue: [list refreshAtIndex: eachIndex]]!

moreFrames
	"Private - Increase the number of stack frames displayed in the call stack."

	self depth: depth + StackDepthIncrement!

nameForArgument: anObject 
	^self systemModel nameForArgument: anObject!

nilVariable
	"Private - Nil the currently selected variable or stack slot."

	self setSelectedVariableTo: nil!

onAboutToDisplayMenu: aMenu 
	"The system is about to display the <Menu>, popup, this is our chance
	to fiddle with it."

	super onAboutToDisplayMenu: aMenu.
	self class enableDynamicMenus ifFalse: [^self].
	aMenu name == #implementDNUMenu 
		ifTrue: 
			[self populateImplementMenu: aMenu.
			^self].
	"Otherwise pass on to the dev. system model to populate message menus"
	self model 
		populateMessagesMenus: aMenu
		fromMethods: (Array with: self selectedMethod)
		environment: self searchEnvironment!

onBreak: pFrame 
	"Private - A break interrupt has been intercepted, take control once more. The argument is
	the process frame address. N.B. This method is entered with async events disabled, and it is
	important not to attempt anything which will cause a callback with interrupts disabled."

	| interruptFrame |
	self assert: [Processor activeProcess == process].
	process size.
	interruptFrame := process frameAtAddress: pFrame.
	[breakWhen isEmpty] whileFalse: 
			[(breakWhen last value: interruptFrame) 
				ifTrue: 
					["Transcript
						print: breakWhen size;
						display: ': Could break at ';
						print: interruptFrame;
						cr."
					breakWhen removeLast]
				ifFalse: 
					["Transcript
						print: breakWhen size;
						display: ': Don''t break at ';
						print: interruptFrame;
						cr."
					^Processor enableInterrupts]	"re-enable further debug events"].
	(((self skipMaskFor: interruptFrame method) allMask: 1) and: [self isInCompositeOp not]) 
		ifTrue: 
			["Step through..."
			"Transcript
				display: 'Step through ';
				print: interruptFrame;
				cr."
			self assert: [interruptFrame method isDebugMethod].
			^process
				step;
				suspend].
	"We can now safely update the windows (with interrupts re-enabled)"
	self break: interruptFrame
	"N.B. There must be no further code after this point"!

onCloseRequested: boolValueHolder 
	"Private - A request to close the view onto this presenter has occurred. The close will
	proceed unless we set the value holder argument to false. The debugged process will be
	terminated depending on the setting of the user response."

	| response |
	boolValueHolder value: self promptToSaveChanges.
	(boolValueHolder value not or: [process isNil]) ifTrue: [^self].
	process debugger == self ifFalse: [^self].
	response := self terminateOnClose.
	response == #yes 
		ifTrue: [process terminate]
		ifFalse: 
			[response == #no 
				ifTrue: 
					[Transcript
						display: 'Detaching from debugged process ';
						print: process;
						cr.
					self resumeProcess]
				ifFalse: [boolValueHolder value: false]]!

onExpressionEvaluated: result 
	"Private - An expression has been evaluated in one of the receiver's workspace panes. Copy
	back the values from the workspace variable pool into same named temporaries in case they
	have been assigned."

	| frame pool |
	frame := self frame.
	pool := inspectorPresenter workspacePool.
	frame temps 
		do: [:each | (frame getOuter: (each at: 2)) at: (each at: 3) put: (pool at: each first ifAbsent: [])]!

onFrameSelected
	"Private - The selected stack frame/method has changed. Refresh the other models
	appropriately"

	| frame |
	self clearCachedMethodInfo.
	frame := self frame.
	frame notNil 
		ifTrue: [self displayFrame]
		ifFalse: 
			[sourcePresenter clear.
			tempsPresenter clear]!

onFrameSelectionChanging: aSelectionChangingEvent
	self onPromptToSaveChanges: aSelectionChangingEvent!

onHalt: aStackFrame 
	"Private - A hard coded breakpoint has been hit in the process being debugged by the
	receiver, so take control. The argument is the stack frame containing the halt."

	self assert: [aStackFrame process == process].
	self beBroken.
	self beAnimated: false.
	self debugState: 'Hard breakpoint'.
	topFrame := aStackFrame.
	self populateStackModel.
	process debugger: self.
	self suspendProcess!

onMethodRemoved: aCompiledMethod 
	self markMethodAsUnbound: aCompiledMethod!

onMethodUpdated: aCompilationResult 
	"Private - The development system has updated or removed a <CompiledMethod>. Refresh any
	relevant stack frames to indicate that they are now unbound if they use the old method."

	| oldMethod |
	oldMethod := aCompilationResult oldMethod.
	self markMethodAsUnbound: oldMethod!

onPromptToSaveChanges: aSelectionChangingEvent
	^sourcePresenter prompt: 'source' toSaveChanges: aSelectionChangingEvent!

onStep: pFrame 
	"Private - A step interrupt has been intercepted, take control once more. The argument is
	the process frame 'address'. This event will only occur after the the activation of a new
	method or block. Most 'step's actually result in a break interrupt when the next soft
	breakpoint is hit. N.B. This method is entered with async events disabled."

	"Implementation Note: There are a sequence of early out tests we perform to avoid breaking
	to early, or in the wrong place:
		-	the debugger is already at a breakpoint (i.e. the interrupt arrived after a hard break)
		-	an attempt is being made to step into a method which may, for example, cause
			a deadlock by hogging a global critical section, or which is configured to be
			skipped for some other reason.
		-	the stepped into frame has been interrupted before any instructions are run (i.e
			it is not a debug frame), so we want to continue to run to the first breakpoint."

	| interruptFrame method skipMask |
	self assert: [Processor activeProcess == process].
	self isRunning ifFalse: [^Processor enableInterrupts].	"already broken"
	process size.
	interruptFrame := process frameAtAddress: pFrame.
	method := interruptFrame method.
	"Transcript
		display: 'onStep in ';
		display: interruptFrame;
		display: ' breakAction = ';
		print: breakAction;
		display: ' breakWhen = ';
		print: breakWhen;
		cr."
	skipMask := self skipMaskFor: method.
	(skipMask allMask: 2) 
		ifTrue: 
			["Step over the method (break on return)"
			"Transcript
				display: breakWhen size + 1;
				display: ': Skip over';
				display: method;
				display: ' when frame index < ';
				display: interruptFrame index;
				cr."
			self breakWhen: [:iFrame | iFrame index < interruptFrame index].
			^Processor enableInterrupts].
	(skipMask allMask: 1) 
		ifTrue: 
			["Step through the method - do not break in this method, but do break in any it calls"
			"Transcript
				display: 'Skip through ';
				display: method;
				display: ' break when frame index ~= ';
				print: interruptFrame index;
				cr."
			method isDebugMethod ifFalse: [self makeDebugFrame: interruptFrame].
			^process
				step;
				suspend].
	"If not currently a debug frame, ..."
	method isDebugMethod 
		ifFalse: 
			["... have just stepped into a new method. Continue to the first breakpoint, or whenever supposed to stop"
			self makeDebugFrame: interruptFrame.
			^Processor enableInterrupts].
	"If stopped on first instruction of evaluated block, then continue to first breakpoint"
	(interruptFrame isBlockFrame and: [interruptFrame ip = interruptFrame block initialIP]) 
		ifTrue: 
			[self assert: [method isDebugMethod].
			^Processor enableInterrupts].
	self break: interruptFrame
	"N.B. There must be no further code after this point"!

onTempSelected
	"Private - A selection has been made in the temporaries list, update the inspector model."

	(temp := tempsPresenter selectionOrNil) isNil 
		ifFalse: 
			[temp := temp second.
			self displayTemp.
			inspectorPresenter view enable]
		ifTrue: 
			[(inspectorPresenter view)
				clear;
				disable]!

onTerminate
	"Private - The debugged process is about to terminate, so if this is the receiver's process,
	close the receiver."

	process debugger: nil.
	self view close!

onViewClosed
	"Private - Sent by the receiver's view when it has been closed. Disconnect from any events
	triggered by the devlopment system"

	super onViewClosed.
	self model removeEventsTriggeredFor: self!

onWalkback: titleString topFrame: aStackFrame resumable: aBoolean 
	"Private - Bring up a walkback window on the receiver with the specified title and with
	aStackFrame as the top frame of the stack trace."

	self beBroken.
	self beAnimated: false.
	self caption: titleString.
	topFrame := aStackFrame.
	self populateStackModel.
	self resumable: aBoolean.
	self assert: [process debugger == self].
	self suspendProcess!

parseContext
	^self selectedMethod ifNotNil: [:method | method methodClass]!

parseTree
	^sourcePresenter parseTree!

populateImplementMenu: aMenu 
	"Private - Build the menu which lists the classes into which a stub can be generated for
	messages which were either not understood, or not implemented directly by the receiver's
	class. The receiver's class is the first, default, item on the menu, and is separated from
	the superclasses that also don't implement the message (if any) by a divider."

	| frame method selector superclasses receiver msg class current |
	frame := self frame homeFrame.
	method := frame method.
	selector := method selector.
	msg := selector == #doesNotUnderstand: 
				ifTrue: [frame arguments first]
				ifFalse: 
					[self assert: [method methodClass ~= frame receiver class].
					Message selector: selector arguments: frame arguments].
	receiver := frame receiver.
	class := receiver class.
	aMenu clear.
	aMenu addCommand: (MessageSend 
				receiver: self
				selector: #restartWithStubFor:inClass:
				arguments: (Array with: msg with: receiver class))
		description: class name.
	superclasses := OrderedCollection new.
	
	[current := class superclass.
	class := current.
	current notNil 
		and: [selector == #doesNotUnderstand: or: [(current includesSelector: selector) not]]] 
			whileTrue: [superclasses addLast: current].
	superclasses notEmpty 
		ifTrue: 
			[aMenu addSeparator.
			superclasses do: 
					[:each | 
					| cmd |
					cmd := MessageSend 
								receiver: self
								selector: #restartWithStubFor:inClass:
								arguments: (Array with: msg with: each).
					aMenu addCommand: cmd description: each name]].
	aMenu setDefault: 1!

populateStackModel
	"Private - Create and set the stack model list from the first 'depth' frames below the
	current topFrame of the current process."

	"Suppress selection reset event caused by refreshing the list"

	stackPresenter noEventsDo: [stackPresenter list: (process stackFramesFrom: topFrame depth: depth)].
	stackPresenter selectionOrNil: topFrame!

prevIPOfFrame: aStackFrame 
	"Private - Answer the IP of the instruction before that at which the IP of the <StackFrame>,
	frame, is currently pointing."

	^aStackFrame method byteCodeDispatcher prevIP: aStackFrame ip!

process: aProcess topFrame: aStackFrame 
	"Private - Sets the process being debugged and the top stack frame (of interest). The stack
	frame list is populated."

	topFrame := aStackFrame.
	self isMain: aProcess isMain.
	process := aProcess.
	process debugger: self.
	self populateStackModel.
	tempsPresenter selectionByIndex: 1 ifAbsent: []!

promptToSaveChanges
	"Private - Hook for prompting the user if the method text has been modified."

	^self onPromptToSaveChanges: (SelectionChangingEvent forSource: self)!

queryCommand: aCommandQuery 
	"Private - Enter details about a potential command for the receiver into the 
	<CommandQuery>."

	| selector running runnable animating |
	selector := aCommandQuery commandSymbol.
	animating := self isAnimating.
	running := self isRunning or: [animating].
	runnable := running not and: [self isResumable].
	#nilVariable == selector 
		ifTrue: 
			[aCommandQuery isEnabled: tempsPresenter selectionByIndex > 1.
			^true].
	#accept == selector 
		ifTrue: 
			[inspectorPresenter hasFocus 
				ifTrue: [aCommandQuery isEnabled: tempsPresenter selectionByIndex > 1]
				ifFalse: [aCommandQuery isEnabled: self canSaveMethod].
			^true].
	#browseVariableClass == selector 
		ifTrue: 
			[aCommandQuery isEnabled: tempsPresenter selectionByIndex > 0.
			^true].
	selector == #userBreak 
		ifTrue: 
			[aCommandQuery isEnabled: (running and: [animating not]).
			^true].
	(#(#resumeProcess #runProcess) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: runnable.
			^true].
	selector == #toggleDisassembly 
		ifTrue: 
			[aCommandQuery
				isEnabled: true;
				isChecked: self isDisassembled.
			^true].
	selector == #toggleAnimation 
		ifTrue: 
			[aCommandQuery
				isEnabled: (runnable or: [animating]);
				isChecked: animating.
			^true].
	(#(#moreFrames #allFrames) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [self depth <= self frames size]).
			^true].
	#showNextStatement == selector 
		ifTrue: 
			[aCommandQuery isEnabled: running not.
			^true].
	#terminateProcess == selector 
		ifTrue: 
			[aCommandQuery isEnabled: process isTerminated not.
			^true].
	(#(#definitionsMenu #referencesMenu) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: true.
			^true].
	^(self queryFrameCommand: aCommandQuery) or: [super queryCommand: aCommandQuery]!

queryFrameCommand: aCommandQuery 
	"Private - All of these commands required that a stack frame be selected"
	| selector running runnable animating frame |
	frame := self frame.
	selector := aCommandQuery commandSymbol.
	animating := self isAnimating.
	running := self isRunning or: [animating].
	runnable := running not and: [self isResumable].
	"Note that the implement menu is not just for DNUs any more, but any message which is not directly
	 implemented by its receiver."
	selector == #implementDNUMenu 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (running not and: [self class enableDynamicMenus and: [self canImplementMessage]]).
			^true].
	#browseMethodInheritanceChain == selector 
		ifTrue: 
			[aCommandQuery 
				isEnabled: (self selectedMethod ifNil: [false] ifNotNil: [:method | method isOverride]).
			^true].
	#messagesMenu == selector 
			ifTrue: 
				[aCommandQuery isEnabled: (self class enableDynamicMenus and: [self selectedMethod notNil]).
				^true].
	(#(#stepOver #stepOut) identityIncludes: selector) 
		ifTrue: 
			[aCommandQuery isEnabled: (runnable and: [frame notNil]).
			^true].
	selector == #returnFromMessage 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [frame notNil and: [frame sender notNil]]).
			^true].
	selector == #restartFrame 
		ifTrue: 
			[aCommandQuery isEnabled: (running not and: [frame notNil and: [frame isRestartable]]).
			^true].
	selector == #stepInto 
		ifTrue: 
			["Can only step-into in the top stack frame"
			aCommandQuery isEnabled: (runnable and: [frame = topFrame]).
			^true].
	selector == #runToCursor 
		ifTrue: 
			["Can run to cursor if not in disassembly view"
			aCommandQuery isEnabled: (runnable and: [frame notNil and: [self isDisassembled not]]).
			^true].
	selector == #acceptNoRestart 
		ifTrue: 
			[aCommandQuery isEnabled: self canSaveMethod.
			^true].
	^false!

refreshFrame
	"Private - Update the receiver's display of the existing frame."

	self clearCachedMethodInfo.
	self isDisassembled ifTrue: [self displaySource] ifFalse: [self setSourceSelection].
	self updateTemporaries!

restartBlock: aBlockClosure inFrame: aStackFrame 
	"Private - Restart the block frame argument, which is now atop the stack, so that it is
	broken on its first breakpoint."

	| sp bp tempStart envTemps |
	aStackFrame ip: aBlockClosure initialIP.
	"Reset the blocks SP so that any extraneous crud is removed when we return to it. Note that
	we must account for the blocks arguments and stack temps. We want to leave the sp pointing
	at the last entry in the frame (i..e the desired Top of Stack)"
	bp := aStackFrame bp.
	sp := bp + aBlockClosure localCount + aStackFrame frameSize - 1.
	aStackFrame sp: sp.
	"Nil out the stack temps"
	tempStart := bp + aBlockClosure argumentCount + aBlockClosure size.
	tempStart to: tempStart + aBlockClosure stackTempCount - 1 do: [:i | process at: i put: nil].
	"And the environment temps, if any"
	envTemps := aBlockClosure envTempCount.
	envTemps > 0 
		ifTrue: 
			[| context |
			context := aStackFrame outer.
			1 to: envTemps do: [:i | context at: i put: nil]].
	"Step to the first breakpoint in the block as otherwise user will need to do a redundant
	step operation"
	self breakWhen: [:iFrame | true].
	self stepInFrame: aStackFrame!

restartBlockFrame: aStackFrame 
	"Private - Unwind to the <BlockFrame>, frame, of the debugged process and reset 
	to the block's initial IP so that the block starts executing from its beginning again.
	Note that temporaries in the block may have previously set values."

	"Implementation Note: This is somewhat easier that restarting a method, since blocks
	are designed to be restarted easily, and because we can't restart a modified block anyway
	(we have to restart the block's home method)."

	| method block |
	block := aStackFrame block.
	method := block method.
	(method isUnbound and: [method isExpression not]) 
		ifTrue: 
			[| home prompt |
			home := self findBlockHome: aStackFrame.
			prompt := 'The home method of the block would appear to have been modified'.
			(home notNil and: [home isRestartable]) 
				ifTrue: 
					[(MessageBox confirm: prompt , '.

Would you like to restart the entire method instead?'
						caption: 'Restarting a block in ' , method displayString , ' ...') 
							ifTrue: [^self restartMethodFrame: home]]
				ifFalse: [MessageBox notify: prompt , ', but is not restartable.']].
	aStackFrame makeDebug.
	aStackFrame = topFrame 
		ifTrue: [self restartBlock: block inFrame: aStackFrame]
		ifFalse: 
			["We need to unwind any frames above the selected one"

			| calledFrame priority |
			calledFrame := self frameCalledFrom: aStackFrame.
			self breakWhen: [:iFrame | iFrame index <= calledFrame index].
			priority := process priority.
			breakAction := 
					[process priority: priority.
					self restartBlock: block inFrame: aStackFrame.
					self populateStackModel].
			process
				priority: Processor highIOPriority;
				interruptWith: [calledFrame return: nil]]!

restartFrame
	"Private - Unwind the currently selected frame and reset the IP so that the method starts
	executing from its beginning again."

	self restartFrameWithFocus: false!

restartFrame: frame 
	"Private - Unwind the <StackFrame>, frame, of the debugged process and reset the IP so that
	the method starts executing from its beginning again."

	self debugState: 'Restart ' , frame displayString.
	self resumable: true.	"override any non-resumable error"
	frame isBlockFrame ifTrue: [self restartBlockFrame: frame] ifFalse: [self restartMethodFrame: frame]!

restartFrameWithFocus: aBoolean 
	| frame |
	frame := self frame.
	"Restart requiring an unwind may be blocked by another debugger, so disable view until
	completed"
	self mainView disable.
	"We must allow the command msg to return before processing the restart as otherwise the
	debugged process may get blocked when attempting to unwind an earlier callback"
	
	[self restartFrame: frame.
	aBoolean ifTrue: [sourcePresenter setFocus]] postToMessageQueue!

restartMethod
	| home |
	home := self findHomeFrame: self frame.
	(home notNil and: [home isRestartable]) ifTrue: [self restartMethodFrame: home]!

restartMethodFrame: frame 
	"Private - Unwind the <StackFrame>, frame, of the debugged process and resend the message
	which caused the method to be activated, breaking at the start of the method."

	"Implementation Note: Generally this is fairly simple - we just save the receiver and args,
	unwind the stack back to the sender (i.e. one below selected frame), wind back the sender's
	ip so that the next thing it does will be a debug break immediately before the pertinent
	send, push the receiver and args back on the stack, and then step into the method again.
	Complications arise where the restarted frame resulted from a special control primitive such
	as #perform:, since we then need to redo the perform which requires that we push the
	selector and possibly that we push the arguments as an array (in the case of
	#perform:withArguments:)."

	| sender args receiver ip interp sent received argArray isPerform priority |
	self assert: [frame isRestartable].
	self debugState: 'Restart ' , frame displayString.
	self resumable: true.	"override any non-resumable error"

	"Save the receiver and arguments as we'll need to re-push these for the resend"
	args := frame arguments.
	receiver := frame receiver.
	received := frame method selector.
	sender := frame sender.
	self makeDebugFrame: sender.

	"Locate the actual message send instruction"
	interp := sender method byteCodeDispatcher.
	ip := sender ip.
	
	[ip := interp prevIP: ip.
	interp ip: ip.
	"Interpret the instruction to find the actual selector sent (might be #perform:, etc)"
	(sent := interp peekForSelector) isNil] 
			whileTrue.

	"Was it a special message, like #perform, which adjusts the stack in some way?"
	argArray := isPerform := false.
	"To avoid penalizing ordinary selectors starting with #perform:, etc, we don't do anything special unless the selector
	 executed was different from that sent."
	sent ~~ received 
		ifTrue: 
			[(sent beginsWith: #perform:) 
				ifTrue: 
					["One of the #perform: family of methods..., so need to push the selector to be performed"
					isPerform := true.
					sent == #perform:withArgumentsAt:descriptor: ifTrue: [^Sound warningBeep].
					argArray := sent == #perform:withArguments:.
					received == #doesNotUnderstand: 
						ifTrue: 
							[| msg |
							msg := args first.
							received := msg selector.
							args := msg arguments]]
				ifFalse: 
					[received == #doesNotUnderstand: 
						ifTrue: 
							["self assert: [sent == args first selector]."
							args := args first arguments]
						ifFalse: 
							[sent == #value:withArguments: 
								ifTrue: 
									[args := (Array new: 2)
												at: 1 put: receiver;
												at: 2 put: args;
												yourself.
									receiver := frame method]
								ifFalse: 
									["Some other control message which we haven't catered for yet (please report)"
									self mainView enable.
									^self 
										error: 'Sorry, it is not currently possible to restart this frame. Please report to Dolphin support']]]].

	"After this point we start to modify the process state, and so there is no going back..."

	"Note: Deduct 1 to get back to the soft breakpoint which always immediately precedes a message send"
	sender ip: ip - 1.
	self assert: [(sender method byteCodes at: sender ip) == 0].
	priority := process priority.

	"Set the action to be performed on next break to be the operations needed to resend"
	breakAction := 
			[| sp |
			process priority: priority.
			"Push back the receiver and args (note that this may corrupt the frames above, so they must be  removed)"
			sp := sender sp.
			process at: sp put: receiver.

			"If a perform then we need to push the actual selector"
			isPerform ifTrue: [process at: (sp := sp + 1) put: received].

			"Push the arguments to the previously sent selector, either individually or as an array (e.g. for 
			 #perform:withArguments:)"
			argArray 
				ifTrue: [process at: (sp := sp + 1) put: args]
				ifFalse: [args do: [:arg | process at: (sp := sp + 1) put: arg]].
			sender sp: sp.

			"Now resize the proc to remove any extraneous crud and set up the suspended frame to be the sender"
			process
				resize: sp;
				suspendedFrame: sender.

"Transcript display: 'Stepping in frame '; display: sender; cr."
			"And step back into the method again"
			self breakWhen: [:iFrame | true].
			self stepInFrame: sender].

	"Unwind any frames above and including the selected one - running the breakAction when
	finished. Note that we temporarily boost the priority of the process to ensure it runs."
	process priority: Processor highIOPriority.
	self return: nil fromFrame: frame.
	process isWaiting ifFalse: [^self].
	"The unwind appears to be blocked, give it a little more time..."
	Processor sleep: 100.
	process isWaiting 
		ifTrue: 
			[self blockedRestartWarning: (MessageSend 
						receiver: receiver
						selector: sent
						arguments: args)]!

restartWithStubFor: aMessage inClass: aClass 
	"Private - Generate a simple stub implementation for the specified <Message> in the
	specified class, and restart the frame."

	(self generateStubFor: aMessage inClass: aClass) ifTrue: [self restartFrameWithFocus: true]!

resumable: aBoolean
	"Private - Set the receiver's resumable flag."

	flags := flags mask: ResumableMask set: aBoolean!

resume
	"Private - Restart the debugged process from the point at which it was last suspended. This
	might involve being resuspended on a Semaphore."

	| list |
	list := suspendingList.
	suspendingList := nil.
	"isMain ifTrue: [ SessionManager inputState main: process ]."
	process resume: list!

resumeProcess
	"Private - Restart the debugged process from the point at which it was last suspended. This
	might involve being resuspended on a Semaphore."

	process debugger: nil.
	self view close ifFalse: [process debugger: self] ifTrue: [self resume]!

return: anObject fromFrame: aStackFrame 
	"Private - Return the specified value to the sender of the specified <StackFrame> (assumed
	to be in the process being debugged)."

	suspendingList := nil.
	self makeDebugFrame: aStackFrame sender.
	self breakWhen: [:iFrame | iFrame index < aStackFrame index].
	process interruptWith: [aStackFrame return: anObject]!

return: anObject toFrame: aStackFrame 
	"Private - Return the specified value to the specified <StackFrame> (assumed to be in the
	process being debugged)."

	suspendingList := nil.
	self makeDebugFrame: aStackFrame sender.
	self breakWhen: [:iFrame | iFrame index <= aStackFrame index].
	process interruptWith: [Processor returnValue: anObject toFrame: aStackFrame index]!

returnFromMessage
	"Private - Step out of the currently selected frame (i.e. return to its sender) answering a
	return value for which the user is prompted (may be any expression). Also resets the
	non-resumable flag allowing debugging to continue after a non-continuable error."

	| frame expression returnValue receiver loopCookie |
	frame := self frame.
	receiver := frame receiver.
	expression := String new.
	loopCookie := Object new.
	
	[(expression := Prompter 
				on: expression
				prompt: 'Please enter return value expression:'
				caption: 'Return from...') isNil 
		ifTrue: [^self].	"cancelled"
	returnValue := expression isEmpty 
				ifTrue: [receiver]
				ifFalse: 
					[| compilerClass |
					compilerClass := receiver basicClass compilerClass.
					
					[compilerClass 
						evaluate: expression
						for: receiver
						evaluationPools: inspectorPresenter allPools
						logged: false] 
							on: compilerClass errorClass
							do: 
								[:cn | 
								MessageBox errorMsg: cn text , String lineDelimiter , String lineDelimiter , 'Please try again.'
									caption: 'Error in expression...'.
								loopCookie]].
	returnValue == loopCookie] 
			whileTrue.
	self debugState: 'Return from...'.
	self resumable: true.	"override any non-resumable error"
	self return: returnValue fromFrame: frame!

runDebuggedProcess
	"Private - Run the debugged process to the next breakpoint or step interrupt."

	self promptToSaveChanges ifFalse: [^self].
	self beRunning.
	self resume!

runProcess
	"Private - Run the debugged process to the next breakpoint or step interrupt."

	self debugState: 'Run to Next Breakpoint'.
	self breakWhen: [:iFrame | false].
	self mainView disable.
	self runDebuggedProcess!

runToCursor
	"Private - Step to the last breakpoint immediately before the current caret position in the
	source pane."

	| ipInterval method frame |
	self debugState: 'Run to Cursor'.
	ipInterval := self cursorIPRange.
	frame := self frame.
	(self findHomeFrame: frame) ifNotNil: [:home | frame := home].
	method := frame method.
	"More useful to run to next frame with same method than same frame, as then works nicely
	with blocks (which we would otherwise not run into). This may however prevent running to
	cursor in a block further down the stack."
	self breakWhen: 
			[:iFrame | 
			iFrame index < frame index or: [iFrame method = method and: [ipInterval includes: iFrame ip]]].
	self mainView disable.
	self runDebuggedProcess!

saveNewMethod: aString 
	self accept: self class restartOnMethodSave methodSource: aString!

searchEnvironment
	^self systemModel systemEnvironment!

selectedMethod
	"Answer the method in the currently selected stack frame, or nil if none."

	_method isNil 
		ifTrue: [_method := self frame ifNotNil: [:frame | frame method]].
	^_method!

selectedMethods
	^self selectedMethod ifNil: [#()] ifNotNil: [:method | Array with: method]!

selectedNode
	"Private - Answer an <StProgramNode> to represent the syntactic element which is currently
	selected, or which the caret is over in the source pane."

	^sourcePresenter selectedNode!

selectionIP
	"Private - Answer the IP of the expression to select in the workspace. This will be the ip
	of the next instruction for the top frame (so that the code which is about to be executed is
	selected) and the ip of last executed instruction in frames below that."

	| frame ip prevIP |
	frame := self frame.
	ip := frame ip.
	(ip = 1 or: [self isDisassembled]) ifTrue: [^ip].
	prevIP := self prevIPOfFrame: frame.
	^(frame = topFrame and: [(frame method byteCodes at: prevIP) = Break]) 
		ifTrue: [ip]
		ifFalse: [prevIP]!

setInitialFocus
	"Received when the receiver's view is first opened; set focus to the source workspace."

	sourcePresenter setFocus!

setSelectedVariableTo: anObject 
	| index varName info |
	index := tempsPresenter selectionByIndex.
	info := tempsPresenter list at: index.
	info at: 2 put: anObject.
	temp := self variableAtIndex: index put: anObject.
	varName := info first trimBlanks.
	varName notEmpty ifTrue: [inspectorPresenter workspacePool at: varName put: anObject].
	tempsPresenter model refreshAtIndex: index.
	self displayTemp!

setSourceSelection
	"Private - Refresh the receiver's source selection to reflect the 'current' IP in the
	selected frame. Note that the range of source selected will depend on whether the top-most
	frame is selected, or an inactive frame down the stack. For the active frame the expression
	that will next be executed is selected. For an older frame the expression that is currently
	being executed (i.e. the message send that suspended the frame) is selected."

	| ip |
	ip := self selectionIP.
	ip isNil ifTrue: [^self].
	self isDisassembled 
		ifTrue: 
			["There are two lines of header text before the bytecode disassembly starts"
			sourcePresenter selectLine: (self selectedMethod indexOfIP: ip) + 2]
		ifFalse: 
			[sourcePresenter selectionRange: (self sourceRangeAt: ip inTextMap: self selectedMethod textMap)]!

setVariablesList: anOrderedCollection 
	"Private - Set the temporary variables list to an <OrderedCollection> of name-value pairs.
	Attempt to maintain any existing temporary selection by name, failing that select the first
	entry (self). If there is no selection, then maintain that state."

	| oldSelection newSelection |
	oldSelection := tempsPresenter selectionByIndex.
	newSelection := oldSelection > 1 
				ifTrue: 
					[| varName index |
					varName := (tempsPresenter list at: oldSelection) first.
					index := anOrderedCollection findFirst: [:each | each first = varName].
					index = 0 ifTrue: [1] ifFalse: [index]]
				ifFalse: [oldSelection].
	tempsPresenter list: anOrderedCollection.
	tempsPresenter selectionByIndex: newSelection!

showNextStatement
	self frame = topFrame 
		ifTrue: [self setSourceSelection]
		ifFalse: [stackPresenter selection: topFrame]!

skipMaskFor: aCompiledMethod 
	^(SkipTable at: aCompiledMethod methodClass ifAbsent: []) 
		ifNil: [0]
		ifNotNil: [:selectors | selectors at: aCompiledMethod selector ifAbsent: [0]]!

source
	^sourcePresenter source!

sourceRangeAt: anInteger inTextMap: aTextMap 
	^(aTextMap at: (self frame findIP: anInteger inTextMap: aTextMap) ifAbsent: []) 
		ifNil: [1 to: 0]
		ifNotNil: [:entry | entry value]!

step
	"Private - Step into the next message send. This involves resuming for a single message send
	or until a breakpoint is hit."

	breakWhen removeAll.
	self stepInFrame: self frame!

stepInFrame: frame 
	"Private - Step into the next message send in the specified <StackFrame>. This involves
	resuming for a single message send or until a breakpoint is hit. Note that we don't actually
	step if the process was suspended while waiting on a Semaphore. Instead we just return to
	waiting on the Semaphore."

	self makeDebugFrame: frame.
	self makeDebugFrame: frame sender.
	self beRunning.
	suspendingList class == Semaphore 
		ifTrue: [self resume]
		ifFalse: 
			[suspendingList := nil.
			process step]!

stepInto
	"Private - Process a command to step into the next message send. This can only be done from the top
	stack frame."

	self debugState: 'Step Into'.
	self step!

stepOut
	"Private - Step out of the currently selected frame (i.e. return to its sender)."

	| frame |
	self debugState: 'Step Out'.
	frame := self frame.
	self makeDebugFrame: frame sender.
	self breakWhen: [:iFrame | iFrame index < frame index].		"break when returned from selected frame"
	self runDebuggedProcess!

stepOver
	"Private - Step to the next expression in the currently selected frame. Note that this
	should not stop on a breakpoint in any block homed lower in the stack."

	| frame |
	self beRunning.
	self debugState: 'Step over'.
	frame := self frame.
	self breakFrame: frame.
	self makeDebugFrame: frame sender.
	self resume!

stubTextFor: aMessage inClass: aClass 
	| source body |
	source := String writeStream: 128.
	body := '^Error notYetImplemented'.
	aMessage argumentCount == 0 
		ifTrue: 
			[source nextPutAll: aMessage selector.
			(aClass allInstVarNames includes: aMessage selector asString) 
				ifTrue: [body := '^<1s>' expandMacrosWith: aMessage selector]]
		ifFalse: 
			[aMessage argumentCount == 1 
				ifTrue: 
					[aMessage selector isInfix 
						ifTrue: 
							[source
								nextPutAll: aMessage selector;
								space;
								nextPutAll: (self nameForArgument: aMessage arguments first)]
						ifFalse: 
							[| name argNames |
							argNames := self 
										emitKeywordSignatureFor: aMessage
										in: aClass
										on: source.
							name := aMessage selector allButLast.
							(aClass allInstVarNames includes: name) 
								ifTrue: [body := '<1s> := <2s>' expandMacrosWith: name with: argNames first]]]
				ifFalse: 
					[self 
						emitKeywordSignatureFor: aMessage
						in: aClass
						on: source]].
	source
		crtab;
		nextPutAll: body.
	^source contents!

suspend
	"Private - Suspend the process being debugged following a debug event."

	self isAnimating
		ifTrue: [
			[KernelLibrary default sleep: self animatePause. self step] forkAt: Processor userSchedulingPriority.
			process suspend]
		ifFalse: [
			self debugState: 'break'.
			self suspendProcess]!

suspendProcess
	"Private - Suspend the process being debugged."

	"Record the process' suspending list before suspending it so that we can restore it later on
	resume"

	suspendingList := process suspendingList.
	process isTerminated ifFalse: [process suspendUnconditionally]
	"N.B. There must be no further code after this point or the receiver will end up stepping
	through it for ever."!

terminateOnClose
	"Private - Answer on of #yes, #no, or #cancel to indicate whether the debugged process will
	be terminated when the receiver is closed."

	| mb response |
	process isTerminated ifTrue: [^#yes	"Terminating a process which is already dead is benign"].
	mb := MessageBox new.
	mb isSuppressible: true.
	mb uniqueId: [self] method.
	mb defaultButton: 1.
	mb caption: 'Closing Debugger...'.
	mb 
		text: 'Do you wish to terminate the debugged process (recommended)?

N.B. If you suppress this dialog then in future the debugged process will ALWAYS be terminated, regardless of the choice you make now. Should you wish to detach from a debugged process and allow it to continue to run, then you can use the Debug/Go(Detach) command on the main menu. '.
	mb iconStyle: #prompt.
	mb buttonStyle: #yesNo.
	response := mb open.
	^response!

terminateProcess
	"Private - Terminate the debugged process. Note that terminating a process will close any
	attached debugger, so we don't need to do anything other than just request the process
	terminate."

	| mb |
	self beAnimated: false.
	mb := MessageBox new.
	mb
		isSuppressible: true;
		uniqueId: [self] method.
	^(mb confirm: 'Are you sure you want to terminate the process?') ifTrue: [process terminate]!

toggleAnimation
	"Private - Start/stop animating the debugged process. At the moment this is mainly a bit of
	fun, rather than anything of serious utility. It is also handy for stress testing the
	debugger."

	| newState |
	newState := self isAnimating not.
	self beAnimated: newState.
	newState ifFalse: [^self].
	self debugState: 'Animate'.
	self step!

toggleDisassembly
	"Private - Switch between source/disassembly modes."

	(Smalltalk includesKey: #Disassembler) 
		ifFalse: 
			[MessageBox warning: self selectedMethod disassembly.
			^self].
	self beDisassembled: self isDisassembled not.
	sourcePresenter
		isReadOnly: self isDisassembled;
		isAutoParseEnabled: (self isDisassembled not and: [sourcePresenter class isAutoParseEnabled]).
	self displayFrame!

updateTemporaries
	"Private - Refresh the receiver's temporaries list model."

	| temps pool frame varList receiver base extra class |
	frame := self frame.
	temps := frame temps.
	tempCount := temps size.
	receiver := frame receiver.
	extra := frame stackWorkspace.
	class := receiver basicClass.
	varList := OrderedCollection new: 1 + tempCount + class instSize + extra.
	varList addLast: (Array with: 'self' with: receiver).
	class allInstVarNames 
		keysAndValuesDo: [:i :each | varList addLast: (Array with: '   ' , each with: (receiver instVarAt: i))].

	"The evaluation context of the inspector becomes the frames receiver."
	inspectorPresenter evaluationContext: receiver.
	pool := inspectorPresenter
				newVariablePool;
				workspacePool.
	"Copy out the temporaries into the workspace variable pools so that they
	can be used in expressions in the source and inspector panes, and add them
	into the variables list."
	temps do: 
			[:each | 
			"The compiler temp map may contain entries for unused temps that are not allocated a slot in the frame - these have an index of 0"
			| i |
			i := each third.
			i > 0 
				ifTrue: 
					[| tempValue tempName |
					tempName := each first.
					tempValue := (frame getOuter: each second) at: i.
					pool at: tempName put: tempValue.
					varList addLast: (Array with: tempName with: tempValue)]].

	"Add any extra used stack slots onto the variables list"
	base := frame index + frame frameSize.
	0 to: extra - 1
		do: [:i | varList addLast: (Array with: '_stack' , i displayString with: (process at: base + i))].
	frame method evaluationPools 
		ifNotNil: 
			[:evalPools | 
			evalPools notEmpty 
				ifTrue: 
					[evalPools first isNil ifFalse: [pool addAll: evalPools first associations].
					inspectorPresenter 
						evaluationPools: (evalPools copyFrom: 2 to: evalPools size) , inspectorPresenter evaluationPools]].

	"Source presenter should share the same pools"
	sourcePresenter
		workspacePool: pool;
		evaluationPools: inspectorPresenter evaluationPools;
		evaluationContext: receiver.
	self setVariablesList: varList!

userBreak
	"Private - The user deliberately broke a process running in the debugger from the menu."

	self assert: [process ~~ Processor activeProcess].
	self beAnimated: false.
	self beBroken; suspend.
	topFrame := process topFrame.
	self populateStackModel
	
	!

variableAtIndex: anInteger put: anObject 
	"Private - Set the value of the temporary at the specified <integer> index in the temporaries
	list."

	| frame receiver tempsOffset index |
	anInteger < 2 ifTrue: [self errorSubscriptBounds: anInteger].
	index := anInteger - 1.
	frame := self frame.
	receiver := frame receiver.
	tempsOffset := receiver basicClass instSize.
	^index <= tempsOffset 
		ifTrue: [receiver instVarAt: index put: anObject]
		ifFalse: 
			[| offset |
			offset := index - tempsOffset.
			offset <= tempCount 
				ifTrue: [frame at: offset put: anObject]
				ifFalse: 
					["Stack working value selected"
					offset := frame sp - offset + tempCount + 1.
					"If on the topFrame, then break before message send not in it"
					frame = topFrame ifTrue: [offset := offset + 1].
					process at: offset put: anObject]]! !
!Debugger categoriesFor: #accept!commands!private! !
!Debugger categoriesFor: #accept:methodSource:!operations!private! !
!Debugger categoriesFor: #acceptNoRestart!commands!private! !
!Debugger categoriesFor: #acceptVariableValue!commands!private! !
!Debugger categoriesFor: #addToCommandRoute:!commands!public! !
!Debugger categoriesFor: #allFrames!commands!private! !
!Debugger categoriesFor: #animatePause!accessing!private! !
!Debugger categoriesFor: #beAnimated:!modes!private! !
!Debugger categoriesFor: #beBroken!modes!private! !
!Debugger categoriesFor: #beDisassembled:!private!testing! !
!Debugger categoriesFor: #beRunning!modes!private! !
!Debugger categoriesFor: #blockedRestartWarning:!operations!private! !
!Debugger categoriesFor: #break:!operations!private! !
!Debugger categoriesFor: #breakFrame:!commands!private! !
!Debugger categoriesFor: #breakWhen:!accessing!private! !
!Debugger categoriesFor: #browseDefinitions!commands!private! !
!Debugger categoriesFor: #browseDefinitionsMatching:in:!private! !
!Debugger categoriesFor: #browseDefinitionsOfSelector:in:!private! !
!Debugger categoriesFor: #browseHierarchy!commands!private! !
!Debugger categoriesFor: #browseIt!commands!public! !
!Debugger categoriesFor: #browseMessages!commands!private! !
!Debugger categoriesFor: #browseMethodInheritanceChain!commands!private! !
!Debugger categoriesFor: #browseReferences!browsing!commands!public! !
!Debugger categoriesFor: #browseReferencesMatching:in:!private! !
!Debugger categoriesFor: #browseReferencesToLiteral:in:!browsing!private! !
!Debugger categoriesFor: #browseSystem!commands!public! !
!Debugger categoriesFor: #browseVariableClass!commands!private! !
!Debugger categoriesFor: #buildParseTree!commands!private! !
!Debugger categoriesFor: #canImplementMessage!private!testing! !
!Debugger categoriesFor: #canSaveMethod!private!testing! !
!Debugger categoriesFor: #clearCachedMethodInfo!helpers!private! !
!Debugger categoriesFor: #continue:with:!development!operations!private! !
!Debugger categoriesFor: #createComponents!initializing!public! !
!Debugger categoriesFor: #createSchematicWiring!initializing!public! !
!Debugger categoriesFor: #cursorIPRange!commands!private! !
!Debugger categoriesFor: #debugState:!private!updating! !
!Debugger categoriesFor: #defaultHelpId!public! !
!Debugger categoriesFor: #depth!accessing!private! !
!Debugger categoriesFor: #depth:!accessing!private! !
!Debugger categoriesFor: #displayFrame!private!updating! !
!Debugger categoriesFor: #displaySource!private!updating! !
!Debugger categoriesFor: #displayTemp!private!updating! !
!Debugger categoriesFor: #emitKeywordSignatureFor:in:on:!helpers!private! !
!Debugger categoriesFor: #findBlockHome:!helpers!private! !
!Debugger categoriesFor: #findHomeFrame:!helpers!private! !
!Debugger categoriesFor: #frame!accessing!private! !
!Debugger categoriesFor: #frameCalledFrom:!accessing!operations!private! !
!Debugger categoriesFor: #frames!accessing!private! !
!Debugger categoriesFor: #generateStubFor:inClass:!helpers!private! !
!Debugger categoriesFor: #hasEditableMethodSelected!public!testing! !
!Debugger categoriesFor: #hasEditableMethodsSelected!public!testing! !
!Debugger categoriesFor: #hasMethodSelected!public!testing! !
!Debugger categoriesFor: #initialize!initializing!private! !
!Debugger categoriesFor: #inspectIt!commands!private! !
!Debugger categoriesFor: #inspectReferences!commands!private! !
!Debugger categoriesFor: #isAnimating!private!testing! !
!Debugger categoriesFor: #isDisassembled!private!testing! !
!Debugger categoriesFor: #isFrameRestartable!private!testing! !
!Debugger categoriesFor: #isInCompositeOp!private!testing! !
!Debugger categoriesFor: #isMain:!accessing!private! !
!Debugger categoriesFor: #isResumable!private!testing! !
!Debugger categoriesFor: #isRunning!private!testing! !
!Debugger categoriesFor: #killProcess!commands!private! !
!Debugger categoriesFor: #mainView!accessing!private! !
!Debugger categoriesFor: #makeDebugFrame:!helpers!private! !
!Debugger categoriesFor: #markMethodAsUnbound:!helpers!private! !
!Debugger categoriesFor: #moreFrames!commands!private! !
!Debugger categoriesFor: #nameForArgument:!helpers!private! !
!Debugger categoriesFor: #nilVariable!commands!private! !
!Debugger categoriesFor: #onAboutToDisplayMenu:!event handling!public! !
!Debugger categoriesFor: #onBreak:!event handling!private! !
!Debugger categoriesFor: #onCloseRequested:!event handling!private! !
!Debugger categoriesFor: #onExpressionEvaluated:!event handling!private! !
!Debugger categoriesFor: #onFrameSelected!event handling!private! !
!Debugger categoriesFor: #onFrameSelectionChanging:!event handling!private! !
!Debugger categoriesFor: #onHalt:!event handling!private! !
!Debugger categoriesFor: #onMethodRemoved:!event handling!private! !
!Debugger categoriesFor: #onMethodUpdated:!event handling!private! !
!Debugger categoriesFor: #onPromptToSaveChanges:!event handling!private! !
!Debugger categoriesFor: #onStep:!event handling!private! !
!Debugger categoriesFor: #onTempSelected!event handling!private! !
!Debugger categoriesFor: #onTerminate!event handling!private! !
!Debugger categoriesFor: #onViewClosed!event handling!private! !
!Debugger categoriesFor: #onWalkback:topFrame:resumable:!event handling!private! !
!Debugger categoriesFor: #parseContext!accessing!public! !
!Debugger categoriesFor: #parseTree!commands!private! !
!Debugger categoriesFor: #populateImplementMenu:!helpers!private! !
!Debugger categoriesFor: #populateStackModel!private!updating! !
!Debugger categoriesFor: #prevIPOfFrame:!accessing!private! !
!Debugger categoriesFor: #process:topFrame:!accessing!initializing!private! !
!Debugger categoriesFor: #promptToSaveChanges!commands!private! !
!Debugger categoriesFor: #queryCommand:!commands!private! !
!Debugger categoriesFor: #queryFrameCommand:!commands!private! !
!Debugger categoriesFor: #refreshFrame!private!updating! !
!Debugger categoriesFor: #restartBlock:inFrame:!operations!private! !
!Debugger categoriesFor: #restartBlockFrame:!operations!private! !
!Debugger categoriesFor: #restartFrame!commands!private! !
!Debugger categoriesFor: #restartFrame:!operations!private! !
!Debugger categoriesFor: #restartFrameWithFocus:!commands!private! !
!Debugger categoriesFor: #restartMethod!operations!private! !
!Debugger categoriesFor: #restartMethodFrame:!operations!private! !
!Debugger categoriesFor: #restartWithStubFor:inClass:!commands!private! !
!Debugger categoriesFor: #resumable:!modes!private! !
!Debugger categoriesFor: #resume!operations!private! !
!Debugger categoriesFor: #resumeProcess!commands!private! !
!Debugger categoriesFor: #return:fromFrame:!operations!private! !
!Debugger categoriesFor: #return:toFrame:!operations!private! !
!Debugger categoriesFor: #returnFromMessage!commands!private! !
!Debugger categoriesFor: #runDebuggedProcess!operations!private! !
!Debugger categoriesFor: #runProcess!operations!private! !
!Debugger categoriesFor: #runToCursor!commands!private! !
!Debugger categoriesFor: #saveNewMethod:!commands!public! !
!Debugger categoriesFor: #searchEnvironment!commands!private! !
!Debugger categoriesFor: #selectedMethod!accessing!public! !
!Debugger categoriesFor: #selectedMethods!accessing!public! !
!Debugger categoriesFor: #selectedNode!accessing!private! !
!Debugger categoriesFor: #selectionIP!accessing!private! !
!Debugger categoriesFor: #setInitialFocus!operations!public! !
!Debugger categoriesFor: #setSelectedVariableTo:!commands!private! !
!Debugger categoriesFor: #setSourceSelection!private!updating! !
!Debugger categoriesFor: #setVariablesList:!private!updating! !
!Debugger categoriesFor: #showNextStatement!commands!private! !
!Debugger categoriesFor: #skipMaskFor:!helpers!private! !
!Debugger categoriesFor: #source!accessing!private! !
!Debugger categoriesFor: #sourceRangeAt:inTextMap:!helpers!private! !
!Debugger categoriesFor: #step!operations!private! !
!Debugger categoriesFor: #stepInFrame:!operations!private! !
!Debugger categoriesFor: #stepInto!commands!private! !
!Debugger categoriesFor: #stepOut!commands!private! !
!Debugger categoriesFor: #stepOver!commands!private! !
!Debugger categoriesFor: #stubTextFor:inClass:!helpers!private! !
!Debugger categoriesFor: #suspend!operations!private! !
!Debugger categoriesFor: #suspendProcess!operations!private! !
!Debugger categoriesFor: #terminateOnClose!private!testing! !
!Debugger categoriesFor: #terminateProcess!commands!private! !
!Debugger categoriesFor: #toggleAnimation!commands!private! !
!Debugger categoriesFor: #toggleDisassembly!commands!private! !
!Debugger categoriesFor: #updateTemporaries!private!updating! !
!Debugger categoriesFor: #userBreak!commands!private! !
!Debugger categoriesFor: #variableAtIndex:put:!helpers!private! !

Debugger methodProtocol: #debugEventHandler attributes: #(#readOnly) selectors: #(#onBreak: #onHalt: #onStep: #onTerminate #onWalkback:topFrame:resumable:)!

!Debugger class methodsFor!

animatePause
	"Answer the number of milliseconds that instances of the receiver will pause between each step when 
	animating debugged processes."

	^AnimatePause!

animatePause: anInteger 
	"Set the number of milliseconds that instances of the receiver will pause between each step when 
	animating debugged processes."

	AnimatePause := anInteger!

debugPrintStringFor: anObject
	"Private - Answer the debugging string representation of the argument."

	^[anObject debugPrintString] on: Error
		do: [:ex | 'an invalid ' , anObject basicClass name , ' {' , ex description , '}']!

defaultAdditionalAccelerators
	^super defaultAdditionalAccelerators , #(#(#renameIt 'F2'))!

defaultStackDepth
	^DefaultStackDepth!

defaultStackDepth: anInteger
	DefaultStackDepth := anInteger!

displayOn: aStream
	"Append, to aStream, a String whose characters are a representation of the receiver as a user
	would want to see it."

	aStream nextPutAll: 'Debugger'
!

enableDynamicMenus
	"Answer whether dynamic menus can be used in instances of the receiver. These can be
	disabled to allow the dynamic menu framework to be debugged more easily."

	^EnableDynamicMenus!

enableDynamicMenus: aBoolean
	"Set whether dynamic menus can be used in instances of the receiver. These can be
	disabled to allow the dynamic menu framework to be debugged more easily."

	EnableDynamicMenus := aBoolean!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

initialize
	"Initialize the class variables of the receiver

		self initialize
	"

	StackDepthIncrement := 10.
	DefaultStackDepth := 40.
	MainMask := 16r1.
	RunMask := 16r2.
	DisassemblyMask := 16r4.
	ResumableMask := 16r8.
	AnimateMask := 16r10.
	AnimatePause := 200.
	self restartOnMethodSave: true.
	self enableDynamicMenus: true.
	self showWalkbacks: true.
	Smalltalk developmentSystem registerTool: self.
	self interrupts do: [:each | ProcessorScheduler interruptSelectors at: each first put: each second].
	self initializeSkipTable!

initializeSkipTable
	"Initialize the table of methods to be skipped (in one way or another) when debugging.
		Debugger initializeSkipTable

	The idea of the skip table is to prevent the implementation of certain parts of the system
	(e.g. exception handling) from surfacing unduly when debugging - i.e. one doesn't want
	to repeatedly step through system code. The debugger may be instructed to step over
	individual methods in one of several ways according to the skip type, which is a bit mask:

		1	- Does not break in the method itself, but will step into subsidiary methods.
		2 	- Does not break in the method or any of its subsidiary methods.
	"

	"Note that most entries are made through membership of special method categories. We need to
	add here only those class/selector pairs where the actual method implementation is in a
	superclass"

	SkipTable := LookupTable new.
	self
		skipSelector: #valueWithArguments:
			of: EventMessageSend
			type: 1.
	"skipSelector: #at:ifAbsent: of: SharedLookupTable type: 0"
	DebuggerMethodCategory initialize!

interrupts
	^#(#(3 #debugBreak:) #(4 #singleStep:))!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^(super publishedAspects)
		add: (Aspect boolean: #showWalkbacks);
		add: (Aspect boolean: #restartOnMethodSave);
		add: (Aspect boolean: #enableDynamicMenus);
		add: ((Aspect integer: #animatePause)
					isNullable: false;
					yourself);
		yourself!

resource_Basic_debugger
	"Answer the literal data from which the 'Basic debugger' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	ViewComposer openOn: (ResourceIdentifier class: self selector: #resource_Basic_debugger)
	"

	^#(#'!!STL' 3 788558 10 ##(Smalltalk.STBViewProxy) 8 ##(Smalltalk.DebuggerShellView) 98 27 0 0 98 2 27131905 131073 416 0 196934 1 ##(Smalltalk.RGB) 8 4294967295 0 551 0 0 0 416 788230 ##(Smalltalk.BorderLayout) 1 1 0 0 0 0 410 8 ##(Smalltalk.ContainerView) 98 15 0 416 98 2 8 1140850688 131073 560 0 0 0 7 0 0 0 560 1180166 ##(Smalltalk.ProportionalLayout) 202 8 ##(Smalltalk.Dictionary) 98 2 721414 ##(Smalltalk.Association) 410 8 ##(Smalltalk.Splitter) 98 12 0 560 98 2 8 1140850688 1 752 0 524550 ##(Smalltalk.ColorRef) 8 4278190080 0 519 0 0 0 752 983302 ##(Smalltalk.MessageSequence) 202 208 98 1 721670 ##(Smalltalk.MessageSend) 8 #createAt:extent: 98 2 328198 ##(Smalltalk.Point) 1 337 1010 1169 11 752 983302 ##(Smalltalk.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 168 0 0 0 72 2 0 0 173 0 0 0] 98 0 1010 193 193 0 27 1 722 410 8 ##(Smalltalk.ReferenceView) 98 14 0 560 98 2 8 1140916224 131073 1152 0 0 0 23 265030 4 ##(Smalltalk.Menu) 0 16 98 16 984134 2 ##(Smalltalk.CommandMenuItem) 1 1180998 4 ##(Smalltalk.CommandDescription) 8 #accept 8 '&Accept' 1 1 0 0 0 1282 1 1314 8 #acceptNoRestart 8 'Acce&pt No Restart' 1 1 0 0 0 983366 1 ##(Smalltalk.DividerMenuItem) 4097 1282 1 1314 8 #runToCursor 8 '&Run to Cursor' 1 1 0 0 0 1282 1 1314 8 #toggleBreakpoint 8 'T&oggle Breakpoint' 1 1 0 0 0 1282 1 1314 8 #toggleDisassembly 8 'Disasse&mbly' 1 1 0 0 0 1442 4097 1234 0 16 98 9 1282 1 1314 8 #undo 8 '&Undo' 1 1 0 0 0 1442 4097 1282 1 1314 8 #cutSelection 8 'Cu&t' 1 1 0 0 0 1282 1 1314 8 #copySelection 8 '&Copy' 1 1 0 0 0 1282 1 1314 8 #pasteClipboard 8 '&Paste' 1 1 0 0 0 1282 1 1314 8 #clearSelection 8 'De&lete' 1 1 0 0 0 1442 4097 1282 1 1314 8 #selectAll 8 '&Select All' 1 1 0 0 0 1282 1 1314 8 #clear 8 'Cle&ar' 1 1 0 0 0 8 '&Edit' 0 134217729 0 0 0 0 0 1442 4097 1282 1 1314 8 #browseIt 8 'Bro&wse It' 1 1 263494 3 ##(Smalltalk.Icon) 0 16 1572870 ##(Smalltalk.ImageRelativeFileLocator) 8 'ClassBrowserShell.ico' 2032142 ##(Smalltalk.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' 0 0 0 1282 1 1314 8 #displayIt 8 '&Display It' 1 1 0 0 0 1282 1 1314 8 #evaluateIt 8 'E&valuate It' 1 1 0 0 0 1282 1 1314 8 #debugIt 8 'Deb&ug It' 1 1 2290 0 16 2336 8 'Debugger.ico' 2384 0 0 1282 1 1314 8 #inspectIt 8 '&Inspect It' 1 1 2290 0 16 2336 8 'BasicInspector.ico' 2384 0 0 1442 4097 1234 0 16 98 2 1282 1 1314 8 #browseDefinitions 8 '&Definitions...' 1 1 0 0 0 1282 1 1314 8 #browseReferences 8 '&References...' 1 1 0 0 0 8 '&Browse' 0 134217729 0 0 0 0 0 8 '&Workspace' 0 134217729 0 0 0 0 0 0 0 1152 1180166 ##(Smalltalk.ResourceIdentifier) 8 ##(Smalltalk.MethodWorkspace) 8 #resource_Debugger_source 0 882 202 208 98 2 946 976 98 2 1010 1 347 1010 1169 337 1152 946 8 #contextMenu: 98 1 1248 1152 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 173 0 0 0 72 2 0 0 85 1 0 0] 98 0 1120 0 27 3 16 234 256 98 2 1152 8 'source' 0 882 202 208 98 1 946 976 98 2 1010 1 1 1010 1169 683 560 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 85 1 0 0] 98 3 410 576 98 15 0 560 98 2 8 1140850688 131073 3424 0 0 0 7 0 0 0 3424 642 202 688 98 5 722 410 8 ##(Smalltalk.ListBox) 98 17 0 3424 98 2 8 1144062209 1 3552 590662 2 ##(Smalltalk.ListModel) 202 208 3200 0 1310726 ##(Smalltalk.IdentitySearchPolicy) 834 864 0 7 1234 0 16 98 2 1282 1 1314 2672 8 '&Inspect' 1 1 2704 0 0 1282 1 1314 8 #inspectReferences 8 'Inspect &References' 1 1 0 0 0 8 '&Inspect' 0 134217729 0 0 0 0 0 0 0 3552 0 8 4294902985 459270 ##(Smalltalk.Message) 8 #first 98 0 3200 32 882 202 208 98 3 946 976 98 2 1010 521 1 1010 219 337 3552 946 3136 98 1 3728 3552 946 8 #horizontalExtent: 98 1 1 3552 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 4 1 0 0 0 0 0 0 113 1 0 0 168 0 0 0] 98 0 1120 0 27 524806 ##(Smalltalk.Fraction) 1415 675 722 410 768 98 12 0 3424 98 2 8 1140850688 1 4256 0 834 864 0 519 0 0 0 4256 882 202 208 98 1 946 976 98 2 1010 511 1 1010 11 337 4256 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 4 1 0 0 168 0 0 0] 98 0 1120 0 27 1 722 410 1168 98 14 0 3424 98 2 8 1140916224 131073 4512 0 0 0 23 0 0 0 4512 2946 8 ##(Smalltalk.SmalltalkWorkspace) 8 #resource_Default_view 0 882 202 208 98 1 946 976 98 2 1010 749 1 1010 421 337 4512 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 118 1 0 0 0 0 0 0 72 2 0 0 168 0 0 0] 3200 1120 0 27 9 722 410 3568 98 17 0 3424 98 2 8 1144062209 1 4784 3634 202 208 3200 0 3696 834 864 0 7 1234 0 16 98 11 1282 1 1314 8 #stepInto 8 'Step &Into' 1269 5 2290 0 16 2336 8 'StepInto.ico' 2384 0 0 1282 1 1314 8 #stepOver 8 'Step O&ver' 1267 5 2290 0 16 2336 8 'StepOver.ico' 2384 0 0 1282 1 1314 8 #stepOut 8 'Step O&ut' 5365 1 2290 0 16 2336 8 'StepOut.ico' 2384 0 0 1282 1 1314 8 #returnFromMessage 8 'Retur&n ...' 1 1 0 0 0 1282 1 1314 8 #restartFrame 8 '&Restart' 1 1 0 0 0 1234 0 16 98 0 8 'Im&plement in' 8 #implementDNUMenu 134217729 0 0 0 0 0 1442 4097 1282 1 1314 8 #moreFrames 8 '&More' 1 1 0 0 0 1282 1 1314 8 #allFrames 8 'A&ll' 1 1 0 0 0 1442 4097 1234 0 16 98 4 1282 1 1314 2816 8 '&Definitions' 1 1 0 0 0 1282 1 1314 2880 8 '&References' 1 1 0 0 0 1282 1 1314 8 #browseMessages 8 '&Messages...' 1 1 0 0 0 1282 1 1314 8 #browseMethodInheritanceChain 8 'In&heritance Chain' 1 1 0 0 0 8 '&Browse' 0 134217729 0 0 0 0 0 8 '&Debug' 0 134217729 0 0 0 0 0 0 0 4784 0 8 4294902985 8 ##(Smalltalk.BasicListAbstract) 3200 32 882 202 208 98 3 946 976 98 2 1010 1 1 1010 511 337 4784 946 3136 98 1 4896 4784 946 4128 98 1 1 4784 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 255 0 0 0 168 0 0 0] 98 0 1120 0 27 4210 3305 675 722 410 768 98 12 0 3424 98 2 8 1140850688 1 6144 0 834 864 0 519 0 0 0 6144 882 202 208 98 1 946 976 98 2 1010 739 1 1010 11 337 6144 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 113 1 0 0 0 0 0 0 118 1 0 0 168 0 0 0] 98 0 1120 0 27 1 32 234 256 98 6 3552 8 'temps' 4512 8 'inspector' 4784 8 'stack' 0 882 202 208 98 1 946 976 98 2 1010 1 1 1010 1169 337 3424 1058 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 168 0 0 0] 98 5 4784 4256 3552 6144 4512 1120 0 27 752 1152 1120 0 27 234 256 98 2 560 8 'main' 0 461638 4 ##(Smalltalk.MenuBar) 0 16 98 7 1234 0 16 98 8 1282 1 1314 8 #fileNew 8 '&New' 9373 1 2290 0 16 2336 8 'FileNew.ico' 2384 0 0 1282 1 1314 8 #fileOpen 8 '&Open...' 9375 1 2290 0 16 2336 8 'FileOpen.ico' 2384 0 0 1282 1 1314 8 #fileFileIn 8 '&File In...' 1 1 0 0 0 1442 4097 1282 1 1314 8 #saveImage 8 'Sa&ve Image' 1 1 2290 0 16 2336 8 'Snapshot.ico' 2384 0 0 1282 1 1314 8 #smalltalkExit 8 'E&xit Dolphin' 1 1 2290 0 16 2336 8 'PowerSwitch.ico' 2384 0 0 1442 4097 1282 1 1314 8 #exit 8 'Close' 17639 1 2290 0 16 2336 8 'CloseWindow.ico' 2384 0 0 8 '&File' 0 134217729 0 0 12851 0 0 1234 0 16 98 13 1282 1 1314 1744 8 '&Undo' 9397 1 2290 0 16 2336 8 'EditUndo.ico' 2384 0 0 1442 4097 1282 1 1314 1824 8 'Cu&t' 9393 1 2290 0 16 2336 8 'EditCut.ico' 2384 0 0 1282 1 1314 1888 8 '&Copy' 9351 1 2290 0 16 2336 8 'EditCopy.ico' 2384 0 0 1282 1 1314 1952 8 '&Paste' 9389 1 2290 0 16 2336 8 'EditPaste.ico' 2384 0 0 1282 1 1314 8 #editDelete 8 '&Delete' 1 1 2290 0 16 2336 8 'EditClear.ico' 2384 0 0 1234 0 16 98 2 1282 1 1314 8 #reformatSource 8 '&Source' 9391 1 0 0 0 1282 1 1314 8 #reformatComment 8 '&Comment' 9367 1 0 0 0 8 'Ref&ormat' 0 134217729 0 0 12867 0 0 1442 4097 1282 1 1314 2096 8 'Select &All' 9347 1 0 0 0 1442 4097 1282 1 1314 8 #editFind 8 '&Find...' 9357 1 2290 0 16 2336 47 786694 ##(Smalltalk.ShellLibrary) 0 0 1282 1 1314 8 #findNext 8 'Find &Next' 1253 1 2290 0 16 2336 8 'FindNext.ico' 2384 0 0 1282 1 1314 8 #findReplace 8 '&Replace...' 9361 1 0 0 0 8 '&Edit' 0 134217729 0 0 12877 0 0 1234 0 16 98 17 1282 1 1314 2256 8 '&Browse It' 9349 1 2290 0 16 2336 8 'ClassBrowserShell.ico' 2384 0 0 1282 1 1314 2448 8 '&Display It' 9353 1 2290 0 16 2336 8 'DisplayIt.ico' 2384 0 0 1282 1 1314 2512 8 '&Evaluate It' 9355 1 2290 0 16 2336 8 'EvaluateIt.ico' 2384 0 0 1282 1 1314 2672 8 '&Inspect It' 9363 1 2290 0 16 2336 8 'BasicInspector.ico' 2384 0 0 1282 1 1314 2576 8 'Deb&ug It' 1 1 2290 0 16 2336 8 'Debugger.ico' 2384 0 0 1282 1 1314 8 #fileItIn 8 'Fi&le It In' 1 1 0 0 0 1442 4097 1282 1 1314 2816 8 'Defi&nitions...' 1271 1 0 0 0 1282 1 1314 2880 8 '&References...' 5367 1 0 0 0 1442 4097 1282 2097153 1314 1344 8 '&Accept' 9383 1 0 0 0 1282 1 1314 8 #reformatAccept 8 'Refor&mat/Accept' 13479 1 0 0 0 1282 1 1314 1408 8 'Acce&pt No Restart' 1 1 0 0 0 1442 4097 1234 0 16 98 13 1282 1 1314 8 #renameVariable 8 'Re&name <1d>...' 1 1 0 0 0 1442 4097 1282 1 1314 8 #extractToTemporary 8 'Extract to &Temporary...' 9385 1 0 0 0 1282 1 1314 8 #extractMethod 8 'E&xtract Method...' 9371 1 0 0 0 1282 1 1314 8 #extractToComponent 8 'Extract to &Component...' 1 1 0 0 0 1282 1 1314 8 #inlineMessage 8 'Inline &Message' 13467 1 0 0 0 1442 4097 1282 1 1314 8 #inlineTemporary 8 '&Inline Temporary' 13481 1 0 0 0 1282 1 1314 8 #moveTempToInnerScope 8 'Move to Inner &Scope' 9655 1 0 0 0 1282 1 1314 8 #convertTempToInstVar 8 'Con&vert to Instance Variable' 1 1 0 0 0 1442 4097 1282 1 1314 8 #inlineParameter 8 'In&line Parameter' 1 1 0 0 0 1282 1 1314 8 #removeParameter 8 'Remove &Parameter' 1 1 0 0 0 8 'Re&factorings' 8 #codeRefactoringsMenu 134217729 2290 0 16 2336 8 'Refactoring.ico' 2384 0 12921 0 0 1442 4097 1234 0 16 98 7 1282 1 1314 8 #toggleAutoCompletion 8 '&Auto-complete' 1 1 0 0 0 1282 1 1314 8 #toggleIndentationGuides 8 'Indentation &Guides' 1 1 0 0 0 1282 1 1314 8 #toggleLineEndings 8 'Line &Endings' 1 1 0 0 0 1282 1 1314 8 #toggleLineNumbers 8 'Line N&umbers' 1 1 0 0 0 1282 1 1314 8 #toggleStyling 8 '&Syntax Coloring' 1 1 0 0 0 1282 1 1314 8 #toggleWhitespace 8 'W&hitespace' 1 1 0 0 0 1282 1 1314 8 #toggleWordWrap 8 '&Word Wrap' 1 1 0 0 0 8 '&Options' 0 134217729 0 0 12937 0 0 8 '&Workspace' 0 134217729 0 0 12939 0 0 1234 0 16 98 22 1282 1 1314 8 #resumeProcess 8 'G&o/detach' 1257 1 0 0 0 1282 1 1314 8 #toggleAnimation 8 '&Animate' 1 1 0 0 0 1282 1 1314 8 #terminateProcess 8 '&Terminate' 5353 1 0 0 0 1282 1 1314 8 #killProcess 8 '&Kill' 1 1 0 0 0 1282 1 1314 8 #userBreak 8 '&Break' 1 1 0 0 0 1442 4097 1282 1 1314 4960 8 'Step &Into' 1269 5 2290 0 16 2336 8 'StepInto.ico' 2384 0 0 1282 1 1314 5056 8 'Step O&ver' 1267 5 2290 0 16 2336 8 'StepOver.ico' 2384 0 0 1282 1 1314 5152 8 'Step O&ut' 5365 1 2290 0 16 2336 8 'StepOut.ico' 2384 0 0 1282 1 1314 1504 8 'Run to &Cursor' 9459 1 2290 0 16 2336 8 'RunToCursor.ico' 2384 0 0 1282 1 1314 8 #runProcess 8 '&Run' 9449 1 2290 0 16 2336 8 'Run.ico' 2384 0 0 1282 1 1314 5312 8 'R&estart' 13545 1 0 0 0 1282 1 1314 5248 8 'Retur&n ...' 1 1 0 0 0 1442 4097 1234 0 16 98 0 8 'Im&plement in' 5392 134217729 0 0 12965 0 0 1234 0 16 98 14 1234 0 16 98 3 1282 1 1314 8 #renameMethod 8 'All...' 1 1 0 0 0 1282 1 1314 8 #renameMethodInHierarchy 8 'In &Hierarchy...' 1 1 0 0 0 1282 1 1314 8 #renameMethodInPackage 8 'In &Package...' 1 1 0 0 0 8 'Re&name' 0 134217729 0 0 12973 0 0 1282 1 1314 8 #safeRemoveMethods 8 'Rem&ove' 1 1 0 0 0 1442 4097 1282 1 1314 8 #addParameter 8 'Add &Parameter...' 1 1 0 0 0 1234 0 16 98 0 8 'Remo&ve Parameter' 8 #removeParameterMenu 134217729 0 0 12979 0 0 1234 0 16 98 0 8 'Rena&me Parameter' 8 #renameParameterMenu 134217729 0 0 12981 0 0 1234 0 16 98 0 8 '&Inline Parameter' 8 #inlineParameterMenu 134217729 0 0 12983 0 0 1442 4097 1234 0 16 98 0 8 'Rename &Temporary' 8 #renameTempMenu 134217729 0 0 12985 0 0 1234 0 16 98 0 8 'Convert Temp to Inst. Var.' 8 #convertTempToInstVarMenu 134217729 0 0 12987 0 0 1442 4097 1282 1 1314 8 #inlineAllSelfSends 8 'Inline &Self Sends' 1 1 0 0 0 1282 1 1314 8 #pushUpMethods 8 'Push &Up' 1 1 0 0 0 1282 1 1314 8 #pushDownMethods 8 'Push &Down' 1 1 0 0 0 8 'Refactorin&gs' 8 #methodRefactoringsMenu 134217729 2290 0 16 2336 8 'Refactoring.ico' 2384 0 12995 0 0 1442 4097 1282 1 1314 1568 8 'Toggle Breakpoint' 1265 1 0 0 0 1282 1 1314 1632 8 'Disasse&mbly' 9461 1 0 0 0 1282 1 1314 8 #showNextStatement 8 'Show Ne&xt Statement' 17621 1 0 0 0 1442 4097 1234 0 16 98 2 1282 1 1314 5456 8 '&More' 1 1 0 0 0 1282 1 1314 5520 8 'A&ll' 1 1 0 0 0 8 'Call &Stack' 0 134217729 0 0 13007 0 0 8 '&Debug' 0 134217729 0 0 13009 0 0 1234 0 16 98 0 8 '&Tools' 8 #toolsMenu 134217729 0 0 13011 0 0 1234 0 16 98 0 8 'Wi&ndow' 8 #windowMenu 134217729 0 0 13013 0 0 1234 0 16 98 16 1282 1 1314 8 #helpContents 8 '&Contents' 1025 1 2290 0 16 2336 49 8160 0 0 1282 1 1314 8 #help 8 'On this &Tool' 1249 1 0 0 0 1282 1 1314 8 #helpWhatsThis 8 'What''s This?' 5345 1 0 0 0 1442 4097 1282 1 1314 8 #learnSmalltalk 8 'Learn Smalltalk' 1 1 0 0 0 1442 4097 1282 1 1314 8 #helpWhatsNew 8 'What''s &New' 1 1 0 0 0 1282 1 1314 8 #helpGuidedTour 8 '&Guided Tour' 1 1 0 0 0 1282 1 1314 8 #helpTutorials 8 'Tutorials' 1 1 0 0 0 1234 0 16 98 4 1282 2097153 1314 8 #tipOfTheDay 8 '&Next Tip of the Day' 9441 1 2290 0 16 2336 8 'TipOfTheDay.ico' 2384 0 0 1282 1 1314 8 #previousTipOfTheDay 8 '&Previous Tip of the Day' 13537 1 2290 0 16 2336 8 'TipOfTheDay.ico' 2384 0 0 1442 4097 1282 1 1314 8 #toggleShowTipsAtStartup 8 '&Show Tips at Startup' 1 1 0 0 0 8 'Tip of the &Day' 0 134217729 0 0 13035 0 0 1442 4097 1282 1 1314 8 #objectArtsHomePage 8 'Object Arts Homepage' 1 1 0 0 0 1282 1 1314 8 #dolphinNewsgroup 8 'Dolphin Newsgroup/Forum' 1 1 0 0 0 1282 1 1314 8 #dolphinWikiWeb 8 'Dolphin WikiWeb' 1 1 0 0 0 1442 4097 1282 1 1314 8 #aboutDolphin 8 '&About Dolphin Smalltalk' 1 1 2290 0 16 2336 8 '!!APPLICATION' 2384 0 0 8 '&Help' 0 134217729 0 0 13045 0 0 8 '' 0 134217729 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 882 202 208 98 2 946 976 98 2 1010 4999 21 1010 1201 801 416 946 8 #updateMenuBar 3200 416 1058 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 195 9 0 0 10 0 0 0 27 12 0 0 154 1 0 0] 98 1 560 1120 0 27)!

resource_Default_view
	"Answer the literal data from which the 'Default view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	ViewComposer openOn: (ResourceIdentifier class: self selector: #resource_Default_view)
	"

	^#(#'!!STL' 3 788558 10 ##(Smalltalk.STBViewProxy) 8 ##(Smalltalk.DebuggerShellView) 98 27 0 0 98 2 27131905 131073 416 0 196934 1 ##(Smalltalk.RGB) 8 4294967295 0 551 0 0 0 416 788230 ##(Smalltalk.BorderLayout) 1 1 410 8 ##(Smalltalk.Toolbar) 98 25 0 416 98 2 8 1140851532 65 560 0 524550 ##(Smalltalk.ColorRef) 8 4278190080 0 519 0 263174 ##(Smalltalk.Font) 0 16 459014 ##(Smalltalk.LOGFONT) 8 #[243 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 65 114 105 97 108 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 328198 ##(Smalltalk.Point) 193 193 0 560 642 672 8 4294902647 234 256 98 8 410 8 ##(Smalltalk.ReferenceView) 98 14 0 560 98 2 8 1140850688 131073 864 0 0 0 7 0 0 0 864 1180166 ##(Smalltalk.ResourceIdentifier) 576 8 #resource_Smalltalk_tools 0 983302 ##(Smalltalk.MessageSequence) 202 208 98 1 721670 ##(Smalltalk.MessageSend) 8 #createAt:extent: 98 2 770 63 1 770 991 51 864 983302 ##(Smalltalk.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 31 0 0 0 0 0 0 0 14 2 0 0 25 0 0 0] 98 0 770 193 193 0 27 8 'smalltalkTools' 410 880 98 14 0 560 98 2 8 1140850688 131073 1248 0 0 0 7 0 0 0 1248 946 576 8 #resource_Debugger_tools 0 994 202 208 98 1 1058 1088 98 2 770 201 51 770 293 51 1248 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 100 0 0 0 25 0 0 0 246 0 0 0 50 0 0 0] 1200 1216 0 27 8 'debuggerTools' 410 880 98 14 0 560 98 2 8 1140850688 131073 1504 0 0 0 7 0 0 0 1504 946 576 8 #resource_Workspace_tools 0 994 202 208 98 1 1058 1088 98 2 770 1 51 770 201 51 1504 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 25 0 0 0 100 0 0 0 50 0 0 0] 1200 1216 0 27 8 'workspaceTools' 410 880 98 14 0 560 98 2 8 1140850688 131073 1760 0 0 0 7 0 0 0 1760 946 576 8 #resource_Image_tools 0 994 202 208 98 1 1058 1088 98 2 770 1 1 770 63 51 1760 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 31 0 0 0 25 0 0 0] 1200 1216 0 27 8 'imageTools' 234 256 1200 202 208 1200 234 240 1200 0 1 0 770 33 33 770 45 45 0 656198 1 ##(Smalltalk.FlowLayout) 1 1 1 994 202 208 98 2 1058 1088 98 2 770 1 1 770 1169 101 560 1058 8 #updateSizePosted 1200 560 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 50 0 0 0] 98 4 1760 864 1504 1248 1216 0 27 0 0 0 410 8 ##(Smalltalk.ContainerView) 98 15 0 416 98 2 8 1140850688 131073 2320 0 0 0 7 0 0 0 2320 1180166 ##(Smalltalk.ProportionalLayout) 202 8 ##(Smalltalk.Dictionary) 98 2 721414 ##(Smalltalk.Association) 410 8 ##(Smalltalk.Splitter) 98 12 0 2320 98 2 8 1140850688 1 2512 0 642 672 0 519 0 0 0 2512 994 202 208 98 1 1058 1088 98 2 770 1 287 770 1169 11 2512 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 143 0 0 0 72 2 0 0 148 0 0 0] 98 0 1216 0 27 1 2482 410 880 98 14 0 2320 98 2 8 1140916224 131073 2784 0 0 0 23 0 0 0 2784 946 8 ##(Smalltalk.MethodWorkspace) 8 #resource_Debugger_source 0 994 202 208 98 1 1058 1088 98 2 770 1 297 770 1169 287 2784 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 148 0 0 0 72 2 0 0 35 1 0 0] 1200 1216 0 27 3 16 234 256 98 2 2784 8 'source' 0 994 202 208 98 1 1058 1088 98 2 770 1 101 770 1169 583 2320 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 50 0 0 0 72 2 0 0 85 1 0 0] 98 3 410 2336 98 15 0 2320 98 2 8 1140850688 131073 3248 0 0 0 7 0 0 0 3248 2402 202 2448 98 3 2482 410 8 ##(Smalltalk.ListBox) 98 17 0 3248 98 2 8 1144062209 1 3376 590662 2 ##(Smalltalk.ListModel) 202 208 1200 0 1310726 ##(Smalltalk.IdentitySearchPolicy) 642 672 0 7 265030 4 ##(Smalltalk.Menu) 0 16 98 13 984134 2 ##(Smalltalk.CommandMenuItem) 1 1180998 4 ##(Smalltalk.CommandDescription) 8 #stepInto 8 'Step &Into' 1269 5 263494 3 ##(Smalltalk.Icon) 0 16 1572870 ##(Smalltalk.ImageRelativeFileLocator) 8 'StepInto.ico' 2032142 ##(Smalltalk.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' 0 0 0 3602 1 3634 8 #stepOver 8 'Step O&ver' 1267 5 3698 0 16 3744 8 'StepOver.ico' 3792 0 0 3602 1 3634 8 #stepOut 8 'Step O&ut' 5365 1 3698 0 16 3744 8 'StepOut.ico' 3792 0 0 3602 1 3634 8 #returnFromMessage 8 'Retur&n ...' 1 1 0 0 0 3602 1 3634 8 #restartFrame 8 '&Restart' 1 1 3698 0 16 3744 8 'Restart.ico' 3792 0 0 983366 1 ##(Smalltalk.DividerMenuItem) 4097 3554 0 16 98 0 8 'Im&plement in' 8 #implementDNUMenu 134217729 0 0 0 0 0 3554 0 16 98 16 3602 1 3634 8 #renameMethod 8 'Re&name...' 1 1 0 0 0 3602 1 3634 8 #renameMethodReferences 8 'Rename Re&ferences...' 1 1 0 0 0 3602 1 3634 8 #safeRemoveMethods 8 'Rem&ove' 1 5 0 0 0 4178 4097 3602 1 3634 8 #addParameter 8 'Add &Parameter...' 1 1 0 0 0 3554 0 16 98 0 8 'Remo&ve Parameter' 8 #removeParameterMenu 134217729 0 0 0 0 0 3554 0 16 98 0 8 'Rena&me Parameter' 8 #renameParameterMenu 134217729 0 0 0 0 0 3554 0 16 98 0 8 '&Inline Parameter' 8 #inlineParameterMenu 134217729 0 0 0 0 0 4178 4097 3554 0 16 98 0 8 'Rename &Temporary' 8 #renameTempMenu 134217729 0 0 0 0 0 3554 0 16 98 0 8 'Convert Temp to Inst. Var.' 8 #convertTempToInstVarMenu 134217729 0 0 0 0 0 4178 4097 3602 1 3634 8 #inlineAllSelfSends 8 'Inline &Self Sends' 1 1 0 0 0 3602 1 3634 8 #pushUp 8 'Push &Up' 1 1 0 0 0 3602 1 3634 8 #pushDown 8 'Push &Down' 1 1 0 0 0 3602 1 3634 8 #moveMethod 8 'Move to &Component...' 1 1 0 0 0 8 'Refactorin&gs' 8 #methodRefactoringsMenu 134217729 3698 0 16 3744 8 'Refactoring.ico' 3792 0 0 0 0 4178 4097 3602 1 3634 8 #moreFrames 8 '&More' 1 1 0 0 0 3602 1 3634 8 #allFrames 8 'A&ll' 1 1 0 0 0 4178 4097 3554 0 16 98 6 3554 0 16 98 1 3602 1 3634 8 #browseDefinitions 8 'Browse Defi&nitions' 247 1 0 0 0 8 '&Definitions Of' 8 #definitionsMenu 134217729 0 0 0 0 0 3554 0 16 98 1 3602 1 3634 8 #browseReferences 8 'Browse &References' 4343 1 0 0 0 8 '&References To' 8 #referencesMenu 134217729 0 0 0 0 0 3602 1 3634 8 #browseMethodInheritanceChain 8 '&Inheritance Chain' 1 1 0 0 0 4178 4097 3602 1 3634 8 #browseMethodHistory 8 '&Change History in Image' 1 1 0 0 0 3602 1 3634 8 #browseMethodEditions 8 'Browse &Editions' 1 1 0 0 0 8 '&Browse' 0 134217729 0 0 0 0 0 8 '&Debug' 0 134217729 0 0 0 0 0 0 0 3376 0 8 4294902985 8 ##(Smalltalk.BasicListAbstract) 1200 0 994 202 208 98 3 1058 1088 98 2 770 1 1 770 521 287 3376 1058 8 #contextMenu: 98 1 3568 3376 1058 8 #horizontalExtent: 98 1 1 3376 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 4 1 0 0 143 0 0 0] 98 0 1216 0 27 524806 ##(Smalltalk.Fraction) 3305 675 2482 410 2528 98 12 0 3248 98 2 8 1140850688 1 6272 0 642 672 0 519 0 0 0 6272 994 202 208 98 1 1058 1088 98 2 770 521 1 770 11 287 6272 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 4 1 0 0 0 0 0 0 9 1 0 0 143 0 0 0] 98 0 1216 0 27 1 2482 410 2336 98 15 0 3248 98 2 8 1140850688 131073 6528 0 0 0 7 0 0 0 6528 2402 234 240 98 4 410 880 98 14 0 6528 98 2 8 1140916224 131073 6640 0 0 0 23 0 0 0 6640 946 8 ##(Smalltalk.SmalltalkWorkspace) 8 #resource_Default_view 0 994 202 208 98 1 1058 1088 98 2 770 1 217 770 639 71 6640 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 108 0 0 0 63 1 0 0 143 0 0 0] 1200 1216 0 27 3 410 8 ##(Smalltalk.ListView) 98 30 0 6528 98 2 8 1140949069 1 6896 3458 202 208 1200 0 3520 642 672 0 7 3554 0 16 98 8 3602 1 3634 8 #inspectIt 8 '&Inspect' 1 1 3698 0 16 3744 8 'BasicInspector.ico' 3792 0 0 3602 1 3634 8 #inspectReferences 8 'Inspect &References' 1 1 0 0 0 4178 4097 3602 1 3634 8 #nilVariable 8 'Set to &Nil' 1 1 0 0 0 4178 4097 3602 1 3634 8 #browseVariableClass 8 '&Browse Class' 1 1 0 0 0 4178 4097 3602 1 3634 8 #refreshVariables 8 'Re&fresh' 1 1 0 0 0 8 '&Inspect' 0 134217729 0 0 0 0 0 0 0 6896 0 8 4294902537 459270 ##(Smalltalk.Message) 8 #first 98 0 0 1049926 1 ##(Smalltalk.IconImageManager) 0 787814 3 ##(Smalltalk.BlockClosure) 0 0 1180966 ##(Smalltalk.CompiledExpression) 3 1 8 ##(Smalltalk.UndefinedObject) 8 'doIt' 8 '[:each | Debugger debugPrintStringFor: each]' 8 #[31 105 45 17 177 106] 2482 8 #Debugger 8 ##(Smalltalk.Debugger) 8 #debugPrintStringFor: 7600 7 257 0 0 0 0 0 202 208 98 2 920646 5 ##(Smalltalk.ListViewColumn) 8 'Variable' 301 8 #left 5952 8 ##(Smalltalk.SortedCollection) 7586 0 0 7618 2 1 7648 8 'doIt' 8 '[:each | each first]' 8 #[30 105 17 158 106] 7520 7888 7 257 0 0 6896 0 1 0 0 7810 8 'Value' 331 7856 7586 0 0 7618 3 1 7648 8 'doIt' 8 '[:each | Debugger debugPrintStringFor: each]' 8 #[31 105 45 17 177 106] 2482 7728 7744 7760 8000 7 257 0 7586 0 0 918822 ##(Smalltalk.CompiledMethod) 1 83886081 170 8 'Dolphin' 8 'SortedCollection' 8 #defaultSortBlock 1540880899 8 #[29 105 233 1 130 106] 8096 7 513 0 7586 0 0 7618 2 1 7648 8 'doIt' 8 '[:each | each second]' 8 #[30 105 17 158 106] 8 #second 8224 7 257 0 0 6896 0 3 0 0 8 #report 1200 0 131143 0 98 1 0 994 202 208 98 3 1058 1088 98 2 770 1 1 770 639 207 6896 1058 6096 98 1 7024 6896 1058 8 #text: 98 1 8 'Variable' 6896 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 63 1 0 0 103 0 0 0] 98 0 1216 0 27 7 16 234 256 98 4 6640 8 'inspector' 6896 8 'temps' 590342 ##(Smalltalk.Rectangle) 770 1 1 770 1 1 994 202 208 98 1 1058 1088 98 2 770 531 1 770 639 287 6528 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 9 1 0 0 0 0 0 0 72 2 0 0 143 0 0 0] 98 3 6896 410 2528 98 12 0 6528 98 2 8 1140850688 1 8896 0 642 672 0 519 0 0 0 8896 994 202 208 98 1 1058 1088 98 2 770 1 207 770 639 11 8896 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 103 0 0 0 63 1 0 0 108 0 0 0] 98 0 1216 0 27 6640 1216 0 27 13 32 234 256 98 2 3376 8 'stack' 0 994 202 208 98 1 1058 1088 98 2 770 1 1 770 1169 287 3248 1154 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 72 2 0 0 143 0 0 0] 98 3 3376 6272 6528 1216 0 27 2512 2784 1216 0 27 234 256 98 4 560 8 'toolbar' 2320 8 'main' 0 461638 4 ##(Smalltalk.MenuBar) 0 16 98 8 3554 0 16 98 8 3602 1 3634 8 #fileNew 8 '&New' 9373 1 3698 0 16 3744 8 'FileNew.ico' 3792 0 0 3602 1 3634 8 #fileOpen 8 '&Open...' 9375 1 3698 0 16 3744 8 'FileOpen.ico' 3792 0 0 3602 1 3634 8 #fileFileIn 8 '&File In...' 1 1 0 0 0 4178 4097 3602 1 3634 8 #saveImage 8 'Sa&ve Image' 1 1 3698 0 16 3744 8 'Snapshot.ico' 3792 0 0 3602 1 3634 8 #smalltalkExit 8 'E&xit Dolphin' 1 1 3698 0 16 3744 8 'PowerSwitch.ico' 3792 0 0 4178 4097 3602 1 3634 8 #exit 8 'Close' 17639 1 3698 0 16 3744 8 'CloseWindow.ico' 3792 0 0 8 '&File' 0 134217729 0 0 12041 0 0 3554 0 16 98 13 3602 1 3634 8 #undo 8 '&Undo' 9397 1 3698 0 16 3744 8 'EditUndo.ico' 3792 0 0 4178 4097 3602 1 3634 8 #cutSelection 8 'Cu&t' 9393 1 3698 0 16 3744 8 'EditCut.ico' 3792 0 0 3602 1 3634 8 #copySelection 8 '&Copy' 9351 1 3698 0 16 3744 8 'EditCopy.ico' 3792 0 0 3602 1 3634 8 #pasteClipboard 8 '&Paste' 9389 1 3698 0 16 3744 8 'EditPaste.ico' 3792 0 0 3602 1 3634 8 #editDelete 8 '&Delete' 1 1 3698 0 16 3744 8 'EditClear.ico' 3792 0 0 3554 0 16 98 2 3602 1 3634 8 #reformatSource 8 '&Source' 9391 1 0 0 0 3602 1 3634 8 #reformatComment 8 '&Comment' 9367 1 0 0 0 8 'Ref&ormat' 0 134217729 0 0 12057 0 0 4178 4097 3602 1 3634 8 #selectAll 8 'Select &All' 9347 1 0 0 0 4178 4097 3602 1 3634 8 #editFind 8 '&Find...' 9357 1 3698 0 16 3744 47 786694 ##(Smalltalk.ShellLibrary) 0 0 3602 1 3634 8 #findNext 8 'Find &Next' 1253 1 3698 0 16 3744 8 'FindNext.ico' 3792 0 0 3602 1 3634 8 #findReplace 8 '&Replace...' 9361 1 0 0 0 8 '&Edit' 0 134217729 0 0 12067 0 0 3554 0 16 98 17 3602 1 3634 8 #browseIt 8 '&Browse It' 9349 1 3698 0 16 3744 8 'ClassBrowserShell.ico' 3792 0 0 3602 1 3634 8 #displayIt 8 '&Display It' 9353 1 3698 0 16 3744 8 'DisplayIt.ico' 3792 0 0 3602 1 3634 8 #evaluateIt 8 '&Evaluate It' 9355 1 3698 0 16 3744 8 'EvaluateIt.ico' 3792 0 0 3602 1 3634 7088 8 '&Inspect It' 9363 1 7120 0 0 3602 1 3634 8 #debugIt 8 'Deb&ug It' 1 1 3698 0 16 3744 8 'Debugger.ico' 3792 0 0 3602 1 3634 8 #fileItIn 8 'Fi&le It In' 1 1 0 0 0 4178 4097 3602 1 3634 5504 8 'Defi&nitions...' 1271 1 0 0 0 3602 1 3634 5632 8 '&References...' 5367 1 0 0 0 4178 4097 3602 2097153 3634 8 #accept 8 '&Accept' 9383 1 3698 0 16 3744 8 'True.ico' 3792 0 0 3602 1 3634 8 #reformatAccept 8 'Refor&mat/Accept' 13479 1 0 0 0 3602 1 3634 8 #acceptNoRestart 8 'Acce&pt No Restart' 1 1 0 0 0 4178 4097 3554 0 16 98 13 3602 1 3634 8 #renameVariable 8 'Re&name <1d>...' 1 1 0 0 0 4178 4097 3602 1 3634 8 #extractToTemporary 8 'Extract to &Temporary...' 9385 1 0 0 0 3602 1 3634 8 #extractMethod 8 'E&xtract Method...' 9371 1 0 0 0 3602 1 3634 8 #extractToComponent 8 'Extract to &Component...' 1 1 0 0 0 3602 1 3634 8 #inlineMessage 8 'Inline &Message' 13467 1 0 0 0 4178 4097 3602 1 3634 8 #inlineTemporary 8 '&Inline Temporary' 13481 1 0 0 0 3602 1 3634 8 #moveTempToInnerScope 8 'Move to Inner &Scope' 9655 1 0 0 0 3602 1 3634 8 #convertTempToInstVar 8 'Con&vert to Instance Variable' 1 1 0 0 0 4178 4097 3602 1 3634 8 #inlineParameter 8 'In&line Parameter' 1 1 0 0 0 3602 1 3634 8 #removeParameter 8 'Remove &Parameter' 1 1 0 0 0 8 'Re&factorings' 8 #codeRefactoringsMenu 134217729 3698 0 16 3744 8 'Refactoring.ico' 3792 0 12111 0 0 4178 4097 3554 0 16 98 7 3602 1 3634 8 #toggleAutoCompletion 8 '&Auto-complete' 1 1 0 0 0 3602 1 3634 8 #toggleIndentationGuides 8 'Indentation &Guides' 1 1 0 0 0 3602 1 3634 8 #toggleLineEndings 8 'Line &Endings' 1 1 0 0 0 3602 1 3634 8 #toggleLineNumbers 8 'Line N&umbers' 1 1 0 0 0 3602 1 3634 8 #toggleStyling 8 '&Syntax Coloring' 1 1 0 0 0 3602 1 3634 8 #toggleWhitespace 8 'W&hitespace' 1 1 0 0 0 3602 1 3634 8 #toggleWordWrap 8 '&Word Wrap' 1 1 0 0 0 8 '&Options' 0 134217729 0 0 12127 0 0 8 '&Workspace' 0 134217729 0 0 12129 0 0 3554 0 16 98 22 3602 1 3634 8 #resumeProcess 8 'G&o/detach' 1257 1 0 0 0 3602 1 3634 8 #toggleAnimation 8 '&Animate' 1 1 0 0 0 3602 1 3634 8 #terminateProcess 8 '&Terminate' 5353 1 0 0 0 3602 1 3634 8 #killProcess 8 '&Kill' 1 1 0 0 0 3602 1 3634 8 #userBreak 8 '&Break' 1 1 0 0 0 4178 4097 3602 1 3634 3664 8 'Step &Into' 1269 5 3698 0 16 3744 8 'StepInto.ico' 3792 0 0 3602 1 3634 3856 8 'Step O&ver' 1267 5 3698 0 16 3744 8 'StepOver.ico' 3792 0 0 3602 1 3634 3952 8 'Step O&ut' 5365 1 3698 0 16 3744 8 'StepOut.ico' 3792 0 0 3602 1 3634 8 #runToCursor 8 'Run to &Cursor' 9459 1 3698 0 16 3744 8 'RunToCursor.ico' 3792 0 0 3602 1 3634 8 #runProcess 8 '&Run' 9449 1 3698 0 16 3744 8 'Run.ico' 3792 0 0 3602 1 3634 4112 8 'R&estart' 13545 1 0 0 0 3602 1 3634 4048 8 'Retur&n ...' 1 1 0 0 0 4178 4097 3554 0 16 98 0 8 'Im&plement in' 4256 134217729 0 0 12155 0 0 3554 0 16 98 14 3554 0 16 98 3 3602 1 3634 4336 8 'All...' 1 1 0 0 0 3602 1 3634 8 #renameMethodInHierarchy 8 'In &Hierarchy...' 1 1 0 0 0 3602 1 3634 8 #renameMethodInPackage 8 'In &Package...' 1 1 0 0 0 8 'Re&name' 0 134217729 0 0 12163 0 0 3602 1 3634 4464 8 'Rem&ove' 1 1 0 0 0 4178 4097 3602 1 3634 4544 8 'Add &Parameter...' 1 1 0 0 0 3554 0 16 98 0 8 'Remo&ve Parameter' 4624 134217729 0 0 12169 0 0 3554 0 16 98 0 8 'Rena&me Parameter' 4688 134217729 0 0 12171 0 0 3554 0 16 98 0 8 '&Inline Parameter' 4752 134217729 0 0 12173 0 0 4178 4097 3554 0 16 98 0 8 'Rename &Temporary' 4832 134217729 0 0 12175 0 0 3554 0 16 98 0 8 'Convert Temp to Inst. Var.' 4896 134217729 0 0 12177 0 0 4178 4097 3602 1 3634 4960 8 'Inline &Self Sends' 1 1 0 0 0 3602 1 3634 8 #pushUpMethods 8 'Push &Up' 1 1 0 0 0 3602 1 3634 8 #pushDownMethods 8 'Push &Down' 1 1 0 0 0 8 'Refactorin&gs' 5200 134217729 3698 0 16 3744 8 'Refactoring.ico' 3792 0 12185 0 0 4178 4097 3602 1 3634 8 #toggleBreakpoint 8 'Toggle Breakpoint' 1265 1 0 0 0 3602 1 3634 8 #toggleDisassembly 8 'Disasse&mbly' 9461 1 0 0 0 3602 1 3634 8 #showNextStatement 8 'Show Ne&xt Statement' 17621 1 0 0 0 4178 4097 3554 0 16 98 2 3602 1 3634 5296 8 '&More' 1 1 0 0 0 3602 1 3634 5360 8 'A&ll' 1 1 0 0 0 8 'Call &Stack' 0 134217729 0 0 12197 0 0 8 '&Debug' 0 134217729 0 0 12199 0 0 3554 0 16 98 3 3602 1 3634 8 #undoChange 8 '&Undo <1d>' 1 1 3698 0 16 3744 8 'EditUndo.ico' 3792 0 0 3602 1 3634 8 #redoChange 8 '&Redo <1d>' 1 1 3698 0 16 3744 8 'EditRedo.ico' 3792 0 0 3602 1 3634 8 #clearChangeHistory 8 'Clear Change &History' 1 1 0 0 0 8 'H&istory' 0 134217729 0 0 12207 0 0 3554 0 16 98 0 8 '&Tools' 8 #toolsMenu 134217729 0 0 12209 0 0 3554 0 16 98 0 8 'Wi&ndow' 8 #windowMenu 134217729 0 0 12211 0 0 3554 0 16 98 16 3602 1 3634 8 #helpContents 8 '&Contents' 1025 1 3698 0 16 3744 49 10976 0 0 3602 1 3634 8 #help 8 'On this &Tool' 1249 1 0 0 0 3602 1 3634 8 #helpWhatsThis 8 'What''s This?' 5345 1 0 0 0 4178 4097 3602 1 3634 8 #learnSmalltalk 8 'Learn Smalltalk' 1 1 0 0 0 4178 4097 3602 1 3634 8 #helpWhatsNew 8 'What''s &New' 1 1 0 0 0 3602 1 3634 8 #helpGuidedTour 8 '&Guided Tour' 1 1 0 0 0 3602 1 3634 8 #helpTutorials 8 'Tutorials' 1 1 0 0 0 3554 0 16 98 4 3602 2097153 3634 8 #tipOfTheDay 8 '&Next Tip of the Day' 9441 1 3698 0 16 3744 8 'TipOfTheDay.ico' 3792 0 0 3602 1 3634 8 #previousTipOfTheDay 8 '&Previous Tip of the Day' 13537 1 3698 0 16 3744 8 'TipOfTheDay.ico' 3792 0 0 4178 4097 3602 1 3634 8 #toggleShowTipsAtStartup 8 '&Show Tips at Startup' 1 1 0 0 0 8 'Tip of the &Day' 0 134217729 0 0 12233 0 0 4178 4097 3602 1 3634 8 #objectArtsHomePage 8 'Object Arts Homepage' 1 1 0 0 0 3602 1 3634 8 #dolphinNewsgroup 8 'Dolphin Newsgroup/Forum' 1 1 0 0 0 3602 1 3634 8 #dolphinWikiWeb 8 'Dolphin WikiWeb' 1 1 0 0 0 4178 4097 3602 1 3634 8 #aboutDolphin 8 '&About Dolphin Smalltalk' 1 1 3698 0 16 3744 8 '!!APPLICATION' 3792 0 0 8 '&Help' 0 134217729 0 0 12243 0 0 8 '' 0 134217729 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 994 202 208 98 2 1058 1088 98 2 770 4999 21 770 1201 801 416 1058 8 #updateMenuBar 1200 416 1154 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 195 9 0 0 10 0 0 0 27 12 0 0 154 1 0 0] 98 2 560 2320 1216 0 27)!

restartOnMethodSave
	"Answer true if instances of the receiver automatically restart a stack frame when the
	method is saved in that frame."

	^RestartOnMethodSave!

restartOnMethodSave: aBoolean 
	"Sets whether instances of the receiver automatically restart a frame in which the method is
	modified and saved."

	RestartOnMethodSave := aBoolean!

show: titleString process: aProcess topFrame: aStackFrame resumable: aBoolean
	"Private - Show an instance of the receiver on the <Process>, aProcess, configured appropriately
	for the other arguments."

	Cursor wait showWhile: [
		self create
			caption: titleString;
			process: aProcess topFrame: aStackFrame;
			resumable: aBoolean;
			show]!

showWalkbacks
	"Answer true if a walkback is brought up before the debugger"

	^ShowWalkbacks!

showWalkbacks: aBoolean
	"Set the option indicating whether a walkback is brought up before the debugger to aBoolean"

	ShowWalkbacks := aBoolean!

skipSelector: aSymbol of: aBehavior maskClear: maskInteger 
	(self skipTable at: aBehavior ifAbsent: []) 
		ifNotNil: 
			[:classTable | 
			(classTable at: aSymbol ifAbsent: []) 
				ifNotNil: 
					[:mask | 
					| newMask |
					newMask := mask maskClear: maskInteger.
					newMask = 0 
						ifTrue: 
							[classTable removeKey: aSymbol.
							classTable isEmpty ifTrue: [self skipTable removeKey: aBehavior]]
						ifFalse: [classTable at: aSymbol put: newMask]]]!

skipSelector: aSymbol of: aBehavior maskSet: maskInteger 
	| classTable |
	classTable := self skipTable at: aBehavior ifAbsentPut: [IdentityDictionary new].
	classTable at: aSymbol put: ((classTable at: aSymbol ifAbsent: [0]) bitOr: maskInteger)!

skipSelector: selector of: behavior type: typeMask 
	"Private - Add the specified method to the set of those skipped by the debugger
	The typeMask specifies what type of skip-over the Debugger will perform when
	encountering a debug halt/step in the method:
		1	- Does not break in the method itself, but will step into methods it in turn calls.
		2 	- Does not break in the method or any of its subsidiary methods.
		4	- The method is a critical section and cannot be safely debugged. Do not stop regardless of debug mode."

	(self skipTable at: behavior ifAbsentPut: [IdentityDictionary new]) at: selector put: typeMask!

skipTable
	^SkipTable ifNil: [SkipTable := LookupTable new]!

uninitialize
	"Private - Uninitialize the receiver prior to remove from the system."

	self interrupts do: [:each | ProcessorScheduler interruptSelectors at: each first put: #unusedInterrupt:].
	Smalltalk developmentSystem unregisterTool: self!

unskipSelector: aSymbol of: aClass 
	"Private - Remove the specified method to the set of those skipped by the debugger."

	(self skipTable at: aClass ifAbsent: []) 
		ifNotNil: [:selectors | selectors removeKey: aSymbol ifAbsent: []]! !
!Debugger class categoriesFor: #animatePause!options!public! !
!Debugger class categoriesFor: #animatePause:!options!public! !
!Debugger class categoriesFor: #debugPrintStringFor:!helpers!private! !
!Debugger class categoriesFor: #defaultAdditionalAccelerators!constants!private! !
!Debugger class categoriesFor: #defaultStackDepth!accessing!public! !
!Debugger class categoriesFor: #defaultStackDepth:!accessing!public! !
!Debugger class categoriesFor: #displayOn:!displaying!public! !
!Debugger class categoriesFor: #enableDynamicMenus!options!public! !
!Debugger class categoriesFor: #enableDynamicMenus:!options!public! !
!Debugger class categoriesFor: #icon!constants!public! !
!Debugger class categoriesFor: #initialize!initializing!public! !
!Debugger class categoriesFor: #initializeSkipTable!initializing!public! !
!Debugger class categoriesFor: #interrupts!constants!private! !
!Debugger class categoriesFor: #publishedAspects!development!public! !
!Debugger class categoriesFor: #resource_Basic_debugger!public!resources-views! !
!Debugger class categoriesFor: #resource_Default_view!public!resources-views! !
!Debugger class categoriesFor: #restartOnMethodSave!options!public! !
!Debugger class categoriesFor: #restartOnMethodSave:!options!public! !
!Debugger class categoriesFor: #show:process:topFrame:resumable:!instance creation!private! !
!Debugger class categoriesFor: #showWalkbacks!options!public! !
!Debugger class categoriesFor: #showWalkbacks:!options!public! !
!Debugger class categoriesFor: #skipSelector:of:maskClear:!accessing!private! !
!Debugger class categoriesFor: #skipSelector:of:maskSet:!accessing!private! !
!Debugger class categoriesFor: #skipSelector:of:type:!accessing!private! !
!Debugger class categoriesFor: #skipTable!accessing!public! !
!Debugger class categoriesFor: #uninitialize!initializing!private! !
!Debugger class categoriesFor: #unskipSelector:of:!accessing!private! !

