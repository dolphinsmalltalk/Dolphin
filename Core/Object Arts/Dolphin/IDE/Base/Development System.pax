| package |
package := Package name: 'Development System'.
package paxVersion: 2.1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Development System.
    Copyright (c) Object Arts Ltd, 1997-2007. Portions Copyright (c) CGI Group (Europe) Ltd, 1997.
    
This package contains the basic/essential Dolphin Smalltalk development system tools and support, for example the Class, Method and Package browsers. 
'.

package basicPackageVersion: '2016.7.0.4'.


package setClassNames: #(
	#{Refactory.Browser.DolphinMoveClassChange}
	#{Refactory.Browser.MethodCategoryEnvironment}
	#{Refactory.Browser.MethodProtocolEnvironment}
	#{Refactory.Browser.PackageEnvironment}
	#{Refactory.Browser.PluggableEnvironment}
	#{Tools.AbstractPublishedAspectInspector}
	#{Tools.AllMethodsCategory}
	#{Tools.AnonymousKeyedAspect}
	#{Tools.AnonymousKeyedAspectBatchAccessor}
	#{Tools.Aspect}
	#{Tools.AspectAccessor}
	#{Tools.AspectEditorDialog}
	#{Tools.AspectInspector}
	#{Tools.AstPlugin}
	#{Tools.BasicInspector}
	#{Tools.BasicKeyedAspect}
	#{Tools.BatchAspectAccessor}
	#{Tools.BrowserSemanticAnalyser}
	#{Tools.CategoryPrompter}
	#{Tools.CategoryTreeModel}
	#{Tools.ChangedMethodsCategory}
	#{Tools.ChooseClassDialog}
	#{Tools.ClassAspectPlugin}
	#{Tools.ClassBrowserAbstract}
	#{Tools.ClassBrowserPlugin}
	#{Tools.ClassBrowserShell}
	#{Tools.ClassCommentPlugin}
	#{Tools.ClassHierarchyModel}
	#{Tools.ClassHierarchySelector}
	#{Tools.ClassListSelector}
	#{Tools.ClassSelector}
	#{Tools.CommandMenuItemDialog}
	#{Tools.CompiledMethodInspector}
	#{Tools.CompiledMethodSearchPolicy}
	#{Tools.CreateSubclassDialog}
	#{Tools.Debugger}
	#{Tools.DebuggerMethodCategory}
	#{Tools.DebuggerShellView}
	#{Tools.DevelopmentSessionManager}
	#{Tools.DictionaryInspector}
	#{Tools.FlipperInspector}
	#{Tools.Grabber}
	#{Tools.ImageListView}
	#{Tools.IndexedInstVarBatchAccessor}
	#{Tools.InspectorAbstract}
	#{Tools.InspectorShell}
	#{Tools.InstVarAspect}
	#{Tools.InstVarInspector}
	#{Tools.IntermediateCategory}
	#{Tools.InvalidInstallationError}
	#{Tools.KeyedAspect}
	#{Tools.KeyedAspectBatch}
	#{Tools.KeyedAspectBatchAccessor}
	#{Tools.MenuBarComposer}
	#{Tools.MenuBarPainter}
	#{Tools.MenuComposer}
	#{Tools.MenuComposerArena}
	#{Tools.MenuComposerView}
	#{Tools.MenuDialog}
	#{Tools.MenuItemDialog}
	#{Tools.MenuPainter}
	#{Tools.MessageNodeCollector}
	#{Tools.MethodBrowser}
	#{Tools.MethodBrowserShell}
	#{Tools.MethodCategorizationPolicy}
	#{Tools.MethodExplorerShell}
	#{Tools.MethodPrivacyCategory}
	#{Tools.MethodSearch}
	#{Tools.MethodSourceSearch}
	#{Tools.MethodWorkspace}
	#{Tools.PackageBrowserShell}
	#{Tools.PackageDependencyPresenter}
	#{Tools.PackageDependents}
	#{Tools.PackageFolder}
	#{Tools.PackageHierarchyModel}
	#{Tools.PackagePrerequisites}
	#{Tools.PackagePrompter}
	#{Tools.PackageRelativeFileLocator}
	#{Tools.PackageSelector}
	#{Tools.PackedReferencesCategory}
	#{Tools.PluggableVirtualMethodCategory}
	#{Tools.PopupMenuPainter}
	#{Tools.PropertyInspector}
	#{Tools.PublishedAspectInspector}
	#{Tools.ReferencesCategory}
	#{Tools.ResourceBrowser}
	#{Tools.ResourceIdentifierDialog}
	#{Tools.ResourceListPresenter}
	#{Tools.ResourceToolboxPresenter}
	#{Tools.SequenceableCollectionInspector}
	#{Tools.SetBatchAspectAccessor}
	#{Tools.SingleChunkReader}
	#{Tools.SingleUnarySendMethodCategory}
	#{Tools.SmalltalkExpressionStyler}
	#{Tools.SmalltalkMethodStyler}
	#{Tools.SmalltalkSearchCandidate}
	#{Tools.SmalltalkSearchPresenter}
	#{Tools.SmalltalkStyler}
	#{Tools.SmalltalkStylingScanner}
	#{Tools.SmalltalkSystem}
	#{Tools.SmalltalkSystemFolder}
	#{Tools.SmalltalkSystemIcon}
	#{Tools.SmalltalkSystemShell}
	#{Tools.SmalltalkToolShell}
	#{Tools.SmalltalkWorkspace}
	#{Tools.SmalltalkWorkspaceDocument}
	#{Tools.SpecialReferencesCategory}
	#{Tools.STBDebugger}
	#{Tools.StructureInspector}
	#{Tools.TwinLevelInspector}
	#{Tools.UnclassifiedMethodsCategory}
	#{Tools.ValueWorkspace}
	#{Tools.ViewComposer}
	#{Tools.ViewComposerArena}
	#{Tools.VirtualMethodCategory}
	#{Tools.VisualObjectFinder}
	#{Tools.VisualShellFinder}
	#{Tools.WalkbackDialog}
).

package setMethodNames: #(
	#(#{Core.Array} #assignToResourceIdentifier:)
	#(#{Core.Array} #debugPrintOn:)
	#(#{Core.ArrayedCollection} #newBatchAccessor)
	#(#{Core.Association} #debugPrintOn:)
	#(#{Core.Bag class} #publishedAspectsOfInstances)
	#(#{Core.Behavior} #changedMethods)
	#(#{Core.Behavior} #hasAbstractMethods)
	#(#{Core.Behavior} #isAbstract)
	#(#{Core.Behavior} #methodFor:)
	#(#{Core.Behavior} #searchForInTool:)
	#(#{Core.Behavior} #whichClassDefinesInstVar:)
	#(#{Core.Behavior} #whichMethodsContainSource:)
	#(#{Core.Behavior} #whichMethodsOnlySelfSend:)
	#(#{Core.Behavior} #whichMethodsReferTo:)
	#(#{Core.Behavior} #whichMethodsReferToAnyOf:)
	#(#{Core.Behavior} #whichSelectorsReferTo:)
	#(#{Core.Behavior} #whichSelectorsReferToAnyOf:)
	#(#{Core.Boolean} #literalTextStyle)
	#(#{Core.Boolean class} #newInstanceAspect:class:)
	#(#{Core.Category class} #icon)
	#(#{Core.Character} #literalTextStyle)
	#(#{Core.Class} #changeIndex)
	#(#{Core.Class} #changeIndexValue:)
	#(#{Core.Class} #isAbstract)
	#(#{Core.Class} #isChanged:)
	#(#{Core.Class} #isDeprecated)
	#(#{Core.Class} #isNonInstantiable:)
	#(#{Core.Class} #methodChanged:)
	#(#{Core.Class} #notifyPackageOfChange)
	#(#{Core.Class} #renameClassVar:to:)
	#(#{Core.ClassDescription} #browse)
	#(#{Core.ClassDescription} #categoriesFor:are:)
	#(#{Core.ClassDescription} #commentStamp:prior:)
	#(#{Core.ClassDescription} #copy:from:)
	#(#{Core.ClassDescription} #copy:from:categories:)
	#(#{Core.ClassDescription} #copy:from:classified:)
	#(#{Core.ClassDescription} #copyAll:from:)
	#(#{Core.ClassDescription} #copyAll:from:classified:)
	#(#{Core.ClassDescription} #copyAllCategoriesFrom:)
	#(#{Core.ClassDescription} #copyCategory:from:)
	#(#{Core.ClassDescription} #copyCategory:from:classified:)
	#(#{Core.ClassDescription} #isDeprecated)
	#(#{Core.ClassDescription} #isVisiblyAbstract)
	#(#{Core.ClassDescription} #methodsFor:)
	#(#{Core.ClassDescription} #methodsFor:stamp:)
	#(#{Core.ClassDescription} #newInstanceAspect:class:)
	#(#{Core.ClassDescription} #privateMethods)
	#(#{Core.ClassDescription} #publicMethods)
	#(#{Core.ClassDescription} #renameInstVar:to:)
	#(#{Core.Collection} #aspectDisplayOn:)
	#(#{Core.Collection} #debugPrintOn:)
	#(#{Core.Collection} #newBatchAccessor)
	#(#{Core.Collection} #publishedAspects)
	#(#{Core.Collection} #publishedKeyedAspects)
	#(#{Core.Collection} #publishedKeyedAspectsBatchSize)
	#(#{Core.Collection class} #newInstanceAspect:class:)
	#(#{Core.Date class} #newInstanceAspect:class:)
	#(#{Core.Dictionary} #alternateInspectorClass)
	#(#{Core.Dictionary} #debugPrintOn:)
	#(#{Core.Dictionary} #newBatchAccessor)
	#(#{Core.Dictionary} #publishedAspects)
	#(#{Core.Dictionary class} #newInstanceAspect:class:)
	#(#{Core.Float class} #newInstanceAspect:class:)
	#(#{Core.Interval} #debugPrintOn:)
	#(#{Core.Interval} #newBatchAccessor)
	#(#{Core.LargeInteger} #debugPrintOn:)
	#(#{Core.Metaclass} #changeIndex)
	#(#{Core.Metaclass} #isChanged:)
	#(#{Core.Metaclass} #isDeprecated)
	#(#{Core.Metaclass} #methodChanged:)
	#(#{Core.MethodCategory class} #all)
	#(#{Core.Number} #literalTextStyle)
	#(#{Core.Object} #alternateInspectorClass)
	#(#{Core.Object} #aspectDisplayOn:)
	#(#{Core.Object} #basicInspect)
	#(#{Core.Object} #browse)
	#(#{Core.Object} #currentPublishedAspectsAsLiteralsMap)
	#(#{Core.Object} #debugPrintOn:)
	#(#{Core.Object} #debugPrintString)
	#(#{Core.Object} #halt)
	#(#{Core.Object} #inspect)
	#(#{Core.Object} #inspectorClass)
	#(#{Core.Object} #newAspect:class:)
	#(#{Core.Object} #publicAccessorAspects)
	#(#{Core.Object} #publishedAspects)
	#(#{Core.Object} #publishedEvents)
	#(#{Core.Object} #searchForInTool:)
	#(#{Core.Object class} #publishedAspects)
	#(#{Core.Object class} #publishedAspectsOfInstances)
	#(#{Core.Object class} #publishedEvents)
	#(#{Core.Object class} #publishedEventsOfInstances)
	#(#{Core.Process} #attachDebugger:topFrame:resumable:)
	#(#{Core.Process} #debug)
	#(#{Core.Process} #debug:topFrame:resumable:)
	#(#{Core.Process} #debuggerClass)
	#(#{Core.Process} #halt:cause:)
	#(#{Core.Process} #primStep:)
	#(#{Core.Process} #showWalkback:callStack:debuggable:resumable:)
	#(#{Core.Process} #step)
	#(#{Core.Process} #step:)
	#(#{Core.Process} #walkback:topFrame:resumable:)
	#(#{Core.SearchPolicy class} #method)
	#(#{Core.Semaphore} #debugPrintOn:)
	#(#{Core.SequenceableCollection} #alternateInspectorClass)
	#(#{Core.SequenceableCollection} #newBatchAccessor)
	#(#{Core.SequenceableCollection class} #newInstanceAspect:class:)
	#(#{Core.SessionManager class} #publishedEventsOfInstances)
	#(#{Core.Set} #newBatchAccessor)
	#(#{Core.Set class} #newInstanceAspect:class:)
	#(#{Core.Stream} #debugPrint:)
	#(#{Core.String} #aspectDisplayOn:)
	#(#{Core.String} #debugPrintOn:)
	#(#{Core.String} #literalTextStyle)
	#(#{Core.String} #newAspect:class:)
	#(#{Core.String} #publishedAspects)
	#(#{Core.Symbol} #aspectDisplayOn:)
	#(#{Core.Symbol} #literalTextStyle)
	#(#{Core.Symbol} #searchForInTool:)
	#(#{Core.Symbol class} #newInstanceAspect:class:)
	#(#{Core.Time class} #newInstanceAspect:class:)
	#(#{Core.UndefinedObject} #aspectDisplayOn:)
	#(#{Core.UndefinedObject} #literalTextStyle)
	#(#{Core.WeakSet class} #publishedEventsOfInstances)
	#(#{External.AbstractCHARField} #characterCreationMessage)
	#(#{External.AbstractCHARField} #printAccessorExpression:on:)
	#(#{External.ArrayField} #printAccessorExpressionSuffixOn:)
	#(#{External.ArrayField} #printMutatorBody:on:)
	#(#{External.ArrayPointerField} #printAccessorExpressionSuffixOn:)
	#(#{External.ArrayPointerField} #printMutatorBody:on:)
	#(#{External.BOOLField} #newAspect:class:)
	#(#{External.BOOLField} #printAccessorExpressionSuffixOn:)
	#(#{External.BOOLField class} #icon)
	#(#{External.CHARField} #accessorMessage)
	#(#{External.CHARField} #characterCreationMessage)
	#(#{External.DOUBLE class} #newInstanceAspect:class:)
	#(#{External.DOUBLEField} #newAspect:class:)
	#(#{External.EmbeddedField} #printAccessorExpression:on:)
	#(#{External.ExternalArray} #printOn:)
	#(#{External.ExternalArray} #publishedAspects)
	#(#{External.ExternalArray} #publishedKeyedAspects)
	#(#{External.ExternalArray} #publishedKeyedAspectsBatchSize)
	#(#{External.ExternalArray class} #newInstanceAspect:class:)
	#(#{External.ExternalArray class} #shouldOverrideGetFieldNames)
	#(#{External.ExternalMethod class} #publishedAspectsOfInstances)
	#(#{External.Field} #autoGenCategories)
	#(#{External.Field} #autoGenComment)
	#(#{External.Field} #makeInstanceName:)
	#(#{External.Field} #printAccessor:on:)
	#(#{External.Field} #printAccessorBody:on:)
	#(#{External.Field} #printAccessorExpression:on:)
	#(#{External.Field} #printAccessorExpressionSuffixOn:)
	#(#{External.Field} #printMutator:on:)
	#(#{External.Field} #printMutatorBody:on:)
	#(#{External.Field} #printOffsetExpression:on:)
	#(#{External.Field} #printOffsetExpression:on:extra:)
	#(#{External.Field} #valueParameterName)
	#(#{External.FillerField} #printAccessorExpression:on:)
	#(#{External.FillerField} #printMutatorBody:on:)
	#(#{External.FLOAT class} #newInstanceAspect:class:)
	#(#{External.FLOATField} #newAspect:class:)
	#(#{External.HANDLEField} #printAccessorExpressionSuffixOn:)
	#(#{External.INTEGER} #printOn:)
	#(#{External.INTEGER class} #newInstanceAspect:class:)
	#(#{External.IntegerBytes} #debugPrintOn:)
	#(#{External.IntegerBytes} #publishedKeyedAspects)
	#(#{External.IntegerBytes class} #newInstanceAspect:class:)
	#(#{External.LPVOIDField} #newAspect:class:)
	#(#{External.LPVOIDField} #printAccessorExpressionSuffixOn:)
	#(#{External.PointerField} #printAccessorExpression:on:)
	#(#{External.PointerField} #printMutatorBody:on:)
	#(#{External.QWORD} #printOn:)
	#(#{External.RECT} #printOn:)
	#(#{External.SCALAR class} #shouldOverrideGetFieldNames)
	#(#{External.ScalarField} #newAspect:class:)
	#(#{External.ScalarField} #printAccessorExpression:on:)
	#(#{External.ScalarField} #printMutatorBody:on:)
	#(#{External.ScalarField class} #icon)
	#(#{External.StringField} #printAccessorExpressionSuffixOn:)
	#(#{External.StringField} #printMutatorBody:on:)
	#(#{External.StringField class} #newInstanceAspect:class:)
	#(#{External.Structure} #alternateInspectorClass)
	#(#{External.Structure} #printableFields)
	#(#{External.Structure} #printFields:on:)
	#(#{External.Structure} #printFieldsOn:)
	#(#{External.Structure} #printOn:)
	#(#{External.Structure} #publishedAspects)
	#(#{External.Structure class} #autoGenCategory)
	#(#{External.Structure class} #compileAllDefinitions)
	#(#{External.Structure class} #compileDefinition)
	#(#{External.Structure class} #compileGetFieldNames)
	#(#{External.Structure class} #compileGetMethod:forField:)
	#(#{External.Structure class} #compileNewFields)
	#(#{External.Structure class} #compileSetMethod:forField:)
	#(#{External.Structure class} #decompileDefinition)
	#(#{External.Structure class} #formatAndCompile:categories:)
	#(#{External.Structure class} #hasHandCodedMethodFor:)
	#(#{External.Structure class} #inheritsFieldNamed:)
	#(#{External.Structure class} #recompileDefinition)
	#(#{External.Structure class} #shouldCompile:forField:)
	#(#{External.Structure class} #shouldOverrideGetFieldNames)
	#(#{External.StructureArrayField} #printAccessorExpressionSuffixOn:)
	#(#{External.StructureArrayPointerField} #printAccessorExpressionSuffixOn:)
	#(#{External.StructureField} #printMutatorBody:on:)
	#(#{External.StructurePointer} #printOn:)
	#(#{External.WCHARField} #accessorMessage)
	#(#{External.WCHARField} #characterCreationMessage)
	#(#{Graphics.Bitmap class} #newInstanceAspect:class:)
	#(#{Graphics.Color class} #newInstanceAspect:class:)
	#(#{Graphics.Font class} #newInstanceAspect:class:)
	#(#{Graphics.Gdiplus.Image class} #newInstanceAspect:class:)
	#(#{Graphics.Gdiplus.ImageView class} #publishedAspectsOfInstances)
	#(#{Graphics.Icon class} #choose)
	#(#{Graphics.Icon class} #newInstanceAspect:class:)
	#(#{Graphics.ImageList class} #newInstanceAspect:class:)
	#(#{Graphics.InternalIcon class} #choose)
	#(#{Graphics.Pen class} #publishedAspectsOfInstances)
	#(#{Graphics.Point class} #publishedAspectsOfInstances)
	#(#{Graphics.Point3D class} #publishedAspectsOfInstances)
	#(#{Graphics.Rectangle class} #publishedAspectsOfInstances)
	#(#{Graphics.TextTileIcon class} #newInstanceAspect:class:)
	#(#{Kernel.BlockClosure} #cpuCyclesToRun)
	#(#{Kernel.BlockClosure class} #publishedAspectsOfInstances)
	#(#{Kernel.BlockFrame} #debugIpFor:)
	#(#{Kernel.BlockFrame} #isRestartable)
	#(#{Kernel.BlockFrame} #makeDebug)
	#(#{Kernel.BlockFrame} #mapInitialIpFrom:to:)
	#(#{Kernel.ClassBuilder class} #publishedEventsOfInstances)
	#(#{Kernel.CompiledCode} #alternateInspectorClass)
	#(#{Kernel.CompiledCode} #asDebugMethod)
	#(#{Kernel.CompiledCode} #decodeHeaderOn:)
	#(#{Kernel.CompiledCode} #disassembly)
	#(#{Kernel.CompiledCode} #hasCompilationIssues)
	#(#{Kernel.CompiledCode} #indexOfIP:)
	#(#{Kernel.CompiledCode} #isAbstract)
	#(#{Kernel.CompiledCode} #isDeprecated)
	#(#{Kernel.CompiledCode} #isSimpleSelfSend:)
	#(#{Kernel.CompiledCode} #stylerClass)
	#(#{Kernel.CompiledCode class} #publishedAspectsOfInstances)
	#(#{Kernel.CompiledExpression} #asDebugMethod)
	#(#{Kernel.CompiledExpression} #stylerClass)
	#(#{Kernel.CompiledMethod} #asDebugMethod)
	#(#{Kernel.CompiledMethod} #browse)
	#(#{Kernel.CompiledMethod} #icon)
	#(#{Kernel.CompiledMethod} #infoTip)
	#(#{Kernel.CompiledMethod} #searchForInTool:)
	#(#{Kernel.CompiledMethod} #stylerClass)
	#(#{Kernel.CompiledMethod class} #overriddenIcon)
	#(#{Kernel.CompiledMethod class} #publishedAspectsOfInstances)
	#(#{Kernel.CompileFailedMethod} #asDebugMethod)
	#(#{Kernel.CompilerNotification} #okToContinue)
	#(#{Kernel.InputState class} #publishedEventsOfInstances)
	#(#{Kernel.MethodProtocol} #icon)
	#(#{Kernel.MethodProtocol class} #ansiIcon)
	#(#{Kernel.MethodProtocol class} #publishedEventsOfInstances)
	#(#{Kernel.MethodProtocol class} #readOnlyIcon)
	#(#{Kernel.Namespace class} #isAbstract)
	#(#{Kernel.Namespace class} #isVisiblyAbstract)
	#(#{Kernel.Namespace class} #newInstanceAspect:class:)
	#(#{Kernel.Namespace class} #publishedAspects)
	#(#{Kernel.Namespace class} #publishedKeyedAspects)
	#(#{Kernel.Package} #browse)
	#(#{Kernel.Package} #defaultAbout)
	#(#{Kernel.Package} #defaultAboutBitmap)
	#(#{Kernel.Package} #fileLocator)
	#(#{Kernel.Package} #icon)
	#(#{Kernel.Package} #publishedAspects)
	#(#{Kernel.Package} #searchForInTool:)
	#(#{Kernel.Package class} #changedIcon)
	#(#{Kernel.Package class} #dolphinPackageIcon)
	#(#{Kernel.Package class} #publishedAspectsOfInstances)
	#(#{Kernel.Package class} #publishedEventsOfInstances)
	#(#{Kernel.PackageManager} #getVersionInfoFor:)
	#(#{Kernel.PackageManager} #isConnected)
	#(#{Kernel.PackageManager} #sourceControl)
	#(#{Kernel.PackageManager class} #publishedEventsOfInstances)
	#(#{Kernel.ProcessorScheduler} #singleStep:)
	#(#{Kernel.ProtoObject} #basicInspect)
	#(#{Kernel.ProtoObject} #debugPrintString)
	#(#{Kernel.ProtoObject} #halt)
	#(#{Kernel.ProtoObject} #inspect)
	#(#{Kernel.ProtoObject class} #icon)
	#(#{Kernel.ProtoObject class} #publishedAspects)
	#(#{Kernel.ProtoObject class} #publishedAspectsOfInstances)
	#(#{Kernel.SharedPool class} #canModifyBinding:newValue:)
	#(#{Kernel.SharedPool class} #referencesTo:)
	#(#{Kernel.StAbstractVariableNode} #displayOn:)
	#(#{Kernel.StackFrame} #debugIpFor:)
	#(#{Kernel.StackFrame} #debugPrintOn:)
	#(#{Kernel.StackFrame} #makeDebug)
	#(#{Kernel.StackFrame} #stackWorkspace)
	#(#{Kernel.StackFrame class} #publishedAspectsOfInstances)
	#(#{Kernel.StAssignmentNode} #displayOn:)
	#(#{Kernel.StBlockNode} #displayOn:)
	#(#{Kernel.StCascadeNode} #displayOn:)
	#(#{Kernel.StLiteralArrayNode} #displayOn:)
	#(#{Kernel.StLiteralToken} #textStyle)
	#(#{Kernel.StLiteralValueNode} #displayOn:)
	#(#{Kernel.StMessageNode} #displayOn:)
	#(#{Kernel.StNumberLiteralToken} #textStyle)
	#(#{Kernel.StOptimizedNode} #displayOn:)
	#(#{Kernel.StParameterNode} #displayOn:)
	#(#{Kernel.StPrimitiveNode} #displayOn:)
	#(#{Kernel.StProgramNode} #debugPrintOn:)
	#(#{Kernel.StProgramNode} #postComments)
	#(#{Kernel.StProgramNode} #preComments)
	#(#{Kernel.StProgramNode} #publishedAspects)
	#(#{Kernel.StReturnNode} #displayOn:)
	#(#{Kernel.StSelfVariable} #valueClass)
	#(#{Kernel.StSelfVariableNode} #valueClassIn:)
	#(#{Kernel.StSequenceNode} #displayOn:)
	#(#{Kernel.StSpecialVariableNode} #displayOn:)
	#(#{Kernel.StSpecialVariableNode} #valueClassIn:)
	#(#{Kernel.StStaticVariable} #valueClass)
	#(#{Kernel.StSuperVariable} #valueClass)
	#(#{Kernel.StSuperVariableNode} #valueClassIn:)
	#(#{Kernel.StTempDeclNode} #displayOn:)
	#(#{Kernel.StThisContextVariable} #valueClass)
	#(#{Kernel.StThisContextVariableNode} #valueClassIn:)
	#(#{Kernel.StToken} #postComments)
	#(#{Kernel.StToken} #preComments)
	#(#{Kernel.StVariable} #valueClass)
	#(#{OS._FPIEEE_RECORD} #printFieldsOn:)
	#(#{OS._FPIEEE_VALUE} #printFieldsOn:)
	#(#{OS.FILETIME} #printOn:)
	#(#{OS.KernelLibrary} #queryThreadCycleTime:cycleTime:)
	#(#{OS.LOGBRUSH} #printFieldsOn:)
	#(#{OS.LOGPEN} #printFieldsOn:)
	#(#{OS.LVITEMW} #printableFields)
	#(#{OS.MSG} #printOn:)
	#(#{OS.RegKeyAbstract} #debugPrintOn:)
	#(#{OS.SYSTEMTIME} #printOn:)
	#(#{OS.VersionInfo class} #publishedAspectsOfInstances)
	#(#{OS.VS_FIXEDFILEINFO class} #publishedAspectsOfInstances)
	#(#{OS.WINDOWPOS} #printOn:)
	#(#{Refactory.Browser.AndEnvironment} #includesResource:)
	#(#{Refactory.Browser.BrowserEnvironment} #allMethods)
	#(#{Refactory.Browser.BrowserEnvironment} #allResourcesDo:)
	#(#{Refactory.Browser.BrowserEnvironment} #browse)
	#(#{Refactory.Browser.BrowserEnvironment} #definitionsOf:)
	#(#{Refactory.Browser.BrowserEnvironment} #dynamicReferencesTo:)
	#(#{Refactory.Browser.BrowserEnvironment} #forClassHierarchyFrom:)
	#(#{Refactory.Browser.BrowserEnvironment} #forMethodCategories:)
	#(#{Refactory.Browser.BrowserEnvironment} #forPackages:)
	#(#{Refactory.Browser.BrowserEnvironment} #includesMethod:)
	#(#{Refactory.Browser.BrowserEnvironment} #includesMethodUncached:)
	#(#{Refactory.Browser.BrowserEnvironment} #openEditor)
	#(#{Refactory.Browser.BrowserEnvironment} #search)
	#(#{Refactory.Browser.BrowserEnvironment} #search:)
	#(#{Refactory.Browser.BrowserEnvironmentWrapper} #includesResource:)
	#(#{Refactory.Browser.BrowserEnvironmentWrapper} #openEditor)
	#(#{Refactory.Browser.ClassEnvironment} #includesResource:)
	#(#{Refactory.Browser.ClassEnvironment} #openEditor)
	#(#{Refactory.Browser.OrEnvironment} #includesResource:)
	#(#{Refactory.Browser.RBConfigurableFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RBFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RBSourceFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RefactoryChange} #displayOn:)
	#(#{Refactory.Browser.SelectorEnvironment} #addMethods:)
	#(#{Refactory.Browser.VariableEnvironment} #includesMethodUncached:)
	#(#{Refactory.Browser.VariableEnvironment} #updateCachesForMethod:)
	#(#{Smalltalk class} #publishedEvents)
	#(#{Smalltalk class} #renameVariable:to:)
	#(#{Smalltalk.StyledGradientBrush class} #publishedAspectsOfInstances)
	#(#{Smalltalk.StyledPen class} #publishedAspectsOfInstances)
	#(#{UI.AbstractCardContainer class} #publishedAspectsOfInstances)
	#(#{UI.AbstractCardContainer class} #publishedEventsOfInstances)
	#(#{UI.AbstractDocumentShell} #saveStateOn:)
	#(#{UI.AbstractToTextConverter class} #publishedAspectsOfInstances)
	#(#{UI.AXControlSite class} #publishedAspectsOfInstances)
	#(#{UI.AXValueConvertingControlSite class} #publishedAspectsOfInstances)
	#(#{UI.BasicListAbstract class} #publishedAspectsOfInstances)
	#(#{UI.BooleanToText class} #publishedAspectsOfInstances)
	#(#{UI.BorderLayout} #arrangementAspect)
	#(#{UI.BorderLayout class} #publishedAspectsOfInstances)
	#(#{UI.CardContainer class} #publishedAspectsOfInstances)
	#(#{UI.CardContainer class} #publishedEventsOfInstances)
	#(#{UI.CardLabel class} #publishedAspectsOfInstances)
	#(#{UI.CardLayout class} #publishedEventsOfInstances)
	#(#{UI.CheckBox class} #publishedAspectsOfInstances)
	#(#{UI.CheckButton class} #publishedAspectsOfInstances)
	#(#{UI.ColorView class} #publishedAspectsOfInstances)
	#(#{UI.ComboBox} #visualObjectAtPoint:)
	#(#{UI.ComboBox class} #publishedAspectsOfInstances)
	#(#{UI.CommandDescription} #commandString:)
	#(#{UI.CommandDescription class} #publishedAspectsOfInstances)
	#(#{UI.CommandMenuItem} #commandString:)
	#(#{UI.CommandMenuItem} #edit)
	#(#{UI.CommandMenuItem class} #publishedAspectsOfInstances)
	#(#{UI.ContainerView class} #applicableLayoutManagerCategories)
	#(#{UI.ContainerView class} #publishedAspectsOfInstances)
	#(#{UI.ControlBarAbstract class} #applicableLayoutManagerCategories)
	#(#{UI.ControlBarAbstract class} #publishedAspectsOfInstances)
	#(#{UI.ControlView class} #publishedAspectsOfInstances)
	#(#{UI.DateTimeCommonControl} #publishedAspects)
	#(#{UI.DateTimePicker class} #publishedAspectsOfInstances)
	#(#{UI.DateToText class} #publishedAspectsOfInstances)
	#(#{UI.FlowLayout class} #publishedAspectsOfInstances)
	#(#{UI.FontView class} #publishedAspectsOfInstances)
	#(#{UI.FramingCalculation class} #allCalculations)
	#(#{UI.FramingConstraints class} #publishedAspectsOfInstances)
	#(#{UI.FramingLayout} #arrangementAspect)
	#(#{UI.FramingLayout class} #example1)
	#(#{UI.GridLayout class} #publishedAspectsOfInstances)
	#(#{UI.GroupBox class} #publishedAspectsOfInstances)
	#(#{UI.HotKey class} #publishedAspectsOfInstances)
	#(#{UI.IconicListAbstract class} #publishedAspectsOfInstances)
	#(#{UI.IconicListAbstract class} #publishedEventsOfInstances)
	#(#{UI.ImagePresenter class} #resource_ImageList_view)
	#(#{UI.ImageViewAbstract class} #publishedAspectsOfInstances)
	#(#{UI.LayoutManager} #arrangementAspect)
	#(#{UI.ListBox class} #publishedAspectsOfInstances)
	#(#{UI.ListControlView} #visualObjectAtPoint:)
	#(#{UI.ListControlView class} #publishedAspectsOfInstances)
	#(#{UI.ListControlView class} #publishedEventsOfInstances)
	#(#{UI.ListModel class} #publishedEventsOfInstances)
	#(#{UI.ListTreeView class} #publishedAspectsOfInstances)
	#(#{UI.ListTreeView class} #publishedEventsOfInstances)
	#(#{UI.ListView class} #publishedAspectsOfInstances)
	#(#{UI.ListView class} #publishedEventsOfInstances)
	#(#{UI.ListViewColumn class} #publishedAspectsOfInstances)
	#(#{UI.Menu} #edit)
	#(#{UI.Menu} #painterClass)
	#(#{UI.Menu class} #publishedAspectsOfInstances)
	#(#{UI.MenuBar} #painterClass)
	#(#{UI.MenuBar class} #newInstanceAspect:class:)
	#(#{UI.MenuBar class} #publishedAspectsOfInstances)
	#(#{UI.MenuItem class} #icon)
	#(#{UI.MoenTreeView} #visualObjectAtPoint:)
	#(#{UI.MoenTreeView class} #publishedAspectsOfInstances)
	#(#{UI.MoenTreeView class} #publishedEventsOfInstances)
	#(#{UI.MonthCalendarView class} #publishedAspectsOfInstances)
	#(#{UI.MultilineTextEdit class} #publishedAspectsOfInstances)
	#(#{UI.PluggableTypeConverter class} #publishedAspectsOfInstances)
	#(#{UI.Presenter class} #addView:asResource:)
	#(#{UI.Presenter class} #editNewDefaultView)
	#(#{UI.ProgressBar class} #publishedAspectsOfInstances)
	#(#{UI.ProportionalLayout class} #publishedAspectsOfInstances)
	#(#{UI.PushButton class} #publishedAspectsOfInstances)
	#(#{UI.ReferenceView} #visualObjectAtPoint:)
	#(#{UI.ReferenceView class} #publishedAspectsOfInstances)
	#(#{UI.ResourceIdentifier} #assign:)
	#(#{UI.ResourceIdentifier} #assignLiteralResourceData:)
	#(#{UI.ResourceIdentifier} #browse)
	#(#{UI.ResourceIdentifier} #edit)
	#(#{UI.ResourceIdentifier} #editViewUsing:)
	#(#{UI.ResourceIdentifier} #emit:asStringOn:)
	#(#{UI.ResourceIdentifier} #prompt)
	#(#{UI.ResourceIdentifier} #publishedAspects)
	#(#{UI.ResourceIdentifier} #reassign)
	#(#{UI.ResourceIdentifier class} #prompt)
	#(#{UI.ResourceIdentifier class} #publishedAspectsOfInstances)
	#(#{UI.RichTextEdit class} #publishedAspectsOfInstances)
	#(#{UI.RichTextPresenter class} #publishedEventsOfInstances)
	#(#{UI.Scintilla.Attribute class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.IndicatorStyle class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.KeyBinding class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.Margin class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.MarkerDefinition class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.ScintillaView} #publishedAspects)
	#(#{UI.Scintilla.ScintillaView class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.ScintillaView class} #publishedEventsOfInstances)
	#(#{UI.Scintilla.TextStyle class} #newInstanceAspect:class:)
	#(#{UI.Scintilla.TextStyle class} #publishedAspectsOfInstances)
	#(#{UI.ScrollBar class} #publishedAspectsOfInstances)
	#(#{UI.ScrollingDecorator class} #publishedAspectsOfInstances)
	#(#{UI.ScrollingDecoratorLayout class} #publishedAspectsOfInstances)
	#(#{UI.Shell class} #registerAsToolWith:)
	#(#{UI.Shell class} #unregisterAsToolWith:)
	#(#{UI.ShellView class} #publishedAspectsOfInstances)
	#(#{UI.ShellView class} #publishedEventsOfInstances)
	#(#{UI.Slider} #publishedAspects)
	#(#{UI.Slider class} #publishedAspectsOfInstances)
	#(#{UI.SpinButton} #publishedAspects)
	#(#{UI.SpinButton class} #publishedAspectsOfInstances)
	#(#{UI.SpinButton class} #publishedEventsOfInstances)
	#(#{UI.Splitter class} #publishedAspectsOfInstances)
	#(#{UI.StaticBitmap class} #publishedAspectsOfInstances)
	#(#{UI.StaticIcon class} #publishedAspectsOfInstances)
	#(#{UI.StaticRectangle class} #publishedAspectsOfInstances)
	#(#{UI.StaticText class} #applicableTypeConverterCategories)
	#(#{UI.StaticText class} #publishedAspectsOfInstances)
	#(#{UI.StaticView class} #publishedAspectsOfInstances)
	#(#{UI.StatusBar class} #publishedAspectsOfInstances)
	#(#{UI.StatusBarItem class} #publishedAspectsOfInstances)
	#(#{UI.StatusBarItemAbstract class} #publishedAspectsOfInstances)
	#(#{UI.TabView class} #publishedAspectsOfInstances)
	#(#{UI.TextEdit class} #applicableTypeConverterCategories)
	#(#{UI.TextEdit class} #publishedAspectsOfInstances)
	#(#{UI.TextEdit class} #publishedEventsOfInstances)
	#(#{UI.TimeToText class} #publishedAspectsOfInstances)
	#(#{UI.Toolbar class} #publishedAspectsOfInstances)
	#(#{UI.Toolbar class} #publishedEventsOfInstances)
	#(#{UI.Toolbar class} #resource_Class_browser_tools)
	#(#{UI.Toolbar class} #resource_Debugger_tools)
	#(#{UI.Toolbar class} #resource_Image_tools)
	#(#{UI.Toolbar class} #resource_Resource_tools)
	#(#{UI.Toolbar class} #resource_Search_tools)
	#(#{UI.Toolbar class} #resource_Smalltalk_tools)
	#(#{UI.Toolbar class} #resource_View_composer_alignment_tools)
	#(#{UI.Toolbar class} #resource_View_composer_match_size_tools)
	#(#{UI.Toolbar class} #resource_View_composer_nudge_tools)
	#(#{UI.Toolbar class} #resource_View_composer_spacing_tools)
	#(#{UI.Toolbar class} #resource_View_composer_tools)
	#(#{UI.Toolbar class} #resource_Workspace_tools)
	#(#{UI.ToolbarBitmapButton} #publishedAspects)
	#(#{UI.ToolbarBitmapButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarSeparator class} #icon)
	#(#{UI.ToolbarSeparator class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarSystemButton} #publishedAspects)
	#(#{UI.ToolbarSystemButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolButton class} #publishedAspectsOfInstances)
	#(#{UI.Tooltip class} #publishedAspectsOfInstances)
	#(#{UI.TranscriptShell} #help)
	#(#{UI.TranscriptShell class} #publishedAspects)
	#(#{UI.TranscriptShell class} #resource_Scintilla_view)
	#(#{UI.TreeModelAbstract class} #publishedEventsOfInstances)
	#(#{UI.TreeView class} #publishedAspectsOfInstances)
	#(#{UI.TypeConverter class} #publishedAspectsOfInstances)
	#(#{UI.ValueConverter class} #publishedEventsOfInstances)
	#(#{UI.ValueConvertingControlView class} #applicableTypeConverterCategories)
	#(#{UI.ValueConvertingControlView class} #publishedAspectsOfInstances)
	#(#{UI.ValueDialog class} #publishedEventsOfInstances)
	#(#{UI.ValueModel} #debugPrintOn:)
	#(#{UI.ValueModel class} #publishedAspectsOfInstances)
	#(#{UI.ValueModel class} #publishedEventsOfInstances)
	#(#{UI.ValuePresenter class} #publishedEventsOfInstances)
	#(#{UI.View} #aspectDisplayOn:)
	#(#{UI.View} #publishedAspects)
	#(#{UI.View} #visualObjectAtPoint:)
	#(#{UI.View class} #editNewDefaultView)
	#(#{UI.View class} #makeDefaultResource)
	#(#{UI.View class} #makeResource:inClass:)
	#(#{UI.View class} #publishedAspectsOfInstances)
	#(#{UI.View class} #publishedEventsOfInstances)
).

package setPrerequisites: #(
	'..\..\ActiveX\OCX\ActiveX Control Hosting'
	'..\..\System\Trace\Debug Trace Stream'
	'..\..\Base\Dolphin'
	'..\..\MVP\Presenters\Accelerator\Dolphin Accelerator Presenter'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Views\Cards\Dolphin Card Containers'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Presenters\Color\Dolphin Color Presenter'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Views\Date Time\Dolphin Date Time Controls'
	'..\..\MVP\Presenters\Date Time\Dolphin Date Time Presenters'
	'..\..\MVP\Presenters\Shell\Dolphin Document Presenter'
	'..\..\MVP\Dialogs\Find\Dolphin Find Dialog'
	'..\..\MVP\Presenters\Folder\Dolphin Folder Presenter'
	'..\..\MVP\Presenters\Font\Dolphin Font Presenter'
	'..\..\MVP\Presenters\Image\Dolphin Image Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Integer Prompter'
	'..\..\Base\Dolphin Legacy Date & Time'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\Base\Dolphin Message Box'
	'..\..\MVP\Views\MoenTree\Dolphin MoenTree View'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Presenters\Radio\Dolphin Radio Buttons'
	'..\..\Registry\Dolphin Registry Access'
	'..\..\MVP\Presenters\Text\Dolphin Rich Text Presenter'
	'..\..\MVP\Views\Scintilla\Dolphin Scintilla View'
	'..\..\MVP\Views\Scrollbars\Dolphin Scrollbars'
	'..\..\MVP\Views\Slider\Dolphin Slider Control'
	'..\..\MVP\Views\Sliding Tray\Dolphin Slidey-Inney-Outey Thing'
	'..\..\Base\Dolphin Source Fileout'
	'..\..\MVP\Views\SpinButton\Dolphin SpinButton Control'
	'..\..\MVP\Views\Styled Views\Dolphin Styled Views'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Views\Tooltips\Dolphin Tooltips'
	'Dolphin Transcript'
	'..\..\MVP\Presenters\Tree\Dolphin Tree List Presenter'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\MVP\Gdiplus\Gdiplus'
	'..\..\MVP\Gdiplus\Gdiplus ImageView'
	'..\..\MVP\Icons\Internal Bitmaps and Icons'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Formatters\RBFormatters'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\System\Compiler\Smalltalk Compiler'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Components\VBScript\VBScript Regular Expressions'
	'..\..\ActiveX\Shell\Windows Shell'
).

package setManualPrerequisites: #(
	'Debug Trace Stream'
	'Dolphin Source Fileout'
).

package!

"Class Definitions"!

Core.Object subclass: #'Tools.Grabber'
	instanceVariableNames: 'rectangle aspect constrain view composer'
	classVariableNames: 'Cursors'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.MenuPainter'
	instanceVariableNames: 'menu conflictingMnemonics conflictingAccelerators'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants private} #{OS private})
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.MethodCategorizationPolicy'
	instanceVariableNames: ''
	classVariableNames: 'Default'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.MethodSearch'
	instanceVariableNames: 'findDetails regexp literal'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'IgnoreCaseMask' -> 16r1
	}!
Core.Object subclass: #'Tools.SmalltalkSearchCandidate'
	instanceVariableNames: 'matchingName object'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.SmalltalkSystemIcon'
	instanceVariableNames: 'openBlock icon description tool helpId'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.VisualShellFinder'
	instanceVariableNames: 'mouseTracker foundObject foundCursor notFoundCursor shellClassFilter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.AttributeDescriptor subclass: #'Tools.Aspect'
	instanceVariableNames: 'name presenterBlock editBlock immediateActionBlock category'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'EditInPlaceMask' -> 16r80000.
		'MultilineValueMask' -> 16r40000.
		'ReadOnlyPresenterBlockMask' -> 16r10000.
		'ValueWorkspaceEditorMask' -> 16r20000
	}!
Tools.Aspect subclass: #'Tools.KeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.KeyedAspect subclass: #'Tools.AnonymousKeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.KeyedAspect subclass: #'Tools.InstVarAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.KeyedAspect subclass: #'Tools.KeyedAspectBatch'
	instanceVariableNames: 'batchSize keys accessorClass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AnonymousKeyedAspect subclass: #'Tools.BasicKeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.BrowserEnvironmentWrapper subclass: #'Refactory.Browser.MethodCategoryEnvironment'
	instanceVariableNames: 'categories'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.BrowserEnvironmentWrapper subclass: #'Refactory.Browser.MethodProtocolEnvironment'
	instanceVariableNames: 'protocols'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.BrowserEnvironmentWrapper subclass: #'Refactory.Browser.PackageEnvironment'
	instanceVariableNames: 'packages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.BrowserEnvironmentWrapper subclass: #'Refactory.Browser.PluggableEnvironment'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Category subclass: #'Tools.IntermediateCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.MethodCategory subclass: #'Tools.DebuggerMethodCategory'
	instanceVariableNames: 'mask'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.MethodCategory subclass: #'Tools.VirtualMethodCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.AllMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: 'Current'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.ChangedMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.MethodPrivacyCategory'
	instanceVariableNames: 'privacy'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.PluggableVirtualMethodCategory'
	instanceVariableNames: 'filter isSlowToEnumerate'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.ReferencesCategory'
	instanceVariableNames: 'literal'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.VirtualMethodCategory subclass: #'Tools.UnclassifiedMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ReferencesCategory subclass: #'Tools.PackedReferencesCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ReferencesCategory subclass: #'Tools.SingleUnarySendMethodCategory'
	instanceVariableNames: 'selector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ReferencesCategory subclass: #'Tools.SpecialReferencesCategory'
	instanceVariableNames: 'index'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.ChunkReader subclass: #'Tools.SingleChunkReader'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Error subclass: #'Tools.InvalidInstallationError'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.RelativeFileLocator subclass: #'Tools.PackageRelativeFileLocator'
	instanceVariableNames: 'packageName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Folder subclass: #'Tools.PackageFolder'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MenuPainter subclass: #'Tools.MenuBarPainter'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MenuPainter subclass: #'Tools.PopupMenuPainter'
	instanceVariableNames: 'itemWidth textOffset submenuOffset acceleratorOffset'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MethodSearch subclass: #'Tools.MethodSourceSearch'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Model subclass: #'Tools.SmalltalkSystem'
	instanceVariableNames: 'systemFolderClass workspaceClass defaultInspectorClass defaultBrowserClass systemFolder packageBrowserClass debuggerClass viewComposerClass protocolBrowserClass workspaceShellClass resourceBrowserClass changedIcon hierarchyBrowserClass preferAlternateInspectors formatterClass classChooserClass resourceIdentifierDialogClass findDetails methodWorkspaceClass allSelectors argumentClasses methodExplorerClass aboutBoxClass testBrowserClass toolbarBitmapSize displayItLocale'
	classVariableNames: 'Current FileDrops RegisteredTools'
	imports: #(#{Kernel.CompilerFlags} #{Refactory.Browser} #{Kernel.ParseErrorCodes})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.TreeModel subclass: #'Tools.CategoryTreeModel'
	instanceVariableNames: 'title'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.FolderHierarchyModel subclass: #'Tools.PackageHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.VirtualTreeModel subclass: #'Tools.ClassHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueAdaptor subclass: #'Tools.AspectAccessor'
	instanceVariableNames: 'aspectDescriptor'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AspectAccessor subclass: #'Tools.BatchAspectAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BatchAspectAccessor subclass: #'Tools.IndexedInstVarBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BatchAspectAccessor subclass: #'Tools.KeyedAspectBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.IndexedInstVarBatchAccessor subclass: #'Tools.SetBatchAspectAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.KeyedAspectBatchAccessor subclass: #'Tools.AnonymousKeyedAspectBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.ParseNodeVisitor subclass: #'Tools.MessageNodeCollector'
	instanceVariableNames: 'messages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.StSemanticAnalyser subclass: #'Tools.BrowserSemanticAnalyser'
	instanceVariableNames: 'isStub'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Presenter subclass: #'Tools.ClassBrowserPlugin'
	instanceVariableNames: ''
	classVariableNames: 'DefaultPlugins'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Presenter subclass: #'Tools.PackageDependencyPresenter'
	instanceVariableNames: 'treePresenter tracesPresenter traces packages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Presenter subclass: #'Tools.SmalltalkSearchPresenter'
	instanceVariableNames: 'environment'
	classVariableNames: 'AutoCompleteDwell'
	imports: #(#{UI.Scintilla.ScintillaConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Presenter subclass: #'Tools.SmalltalkWorkspace'
	instanceVariableNames: 'evaluationContext errorModel findDetails workspacePool evaluationPools compilationErrors textStyles searchEnvironment modifiedModel flags indicatorStyles'
	classVariableNames: 'Abbreviations AnnotationMode AutoCompleteDwell DefaultCaretColor DefaultFont DefaultTabWidth FontQuality IndicatorStyles IsAutoCompletionCaseInsensitive IsAutoCompletionEnabled IsAutoCompletionSpaceAdded IsAutoCompletionTruncating KeyBindings KeywordCompletions MaxAutoCompletionListSize StandardUnaryReturnTypes TextStyles UseDirectWrite WordWrap WrapIndentMode'
	imports: #(#{Kernel.CompilerFlags} #{UI.Scintilla.ScintillaConstants})
	classInstanceVariableNames: 'additionalKeyBindings commandQueryHandlers'
	classConstants: {
		'AutoCompleteMask' -> 16r1.
		'VariableTipsMask' -> 16r2
	}!
UI.Presenter subclass: #'Tools.TwinLevelInspector'
	instanceVariableNames: 'contentsPresenter inspectorPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassBrowserPlugin subclass: #'Tools.AstPlugin'
	instanceVariableNames: 'astPresenter sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassBrowserPlugin subclass: #'Tools.ClassAspectPlugin'
	instanceVariableNames: 'textPresenter originalText currentClass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassAspectPlugin subclass: #'Tools.ClassCommentPlugin'
	instanceVariableNames: ''
	classVariableNames: 'TextStyles WordWrap'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.PackageDependencyPresenter subclass: #'Tools.PackageDependents'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.PackageDependencyPresenter subclass: #'Tools.PackagePrerequisites'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.SelectableItemsPresenter subclass: #'Tools.ClassSelector'
	instanceVariableNames: 'flags classesPresenter searchEnvironment'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: 'commandQueryHandlers'
	classConstants: {
		'ClassModeMask' -> 16r1.
		'ShowFullNamesMask' -> 16r2
	}!
UI.SelectableItemsPresenter subclass: #'Tools.PackageSelector'
	instanceVariableNames: 'filterPresenter packagesPresenter autoSelect'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: 'commandQueryHandlers'
	classConstants: {}!
Tools.ClassSelector subclass: #'Tools.ClassHierarchySelector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.ClassSelector subclass: #'Tools.ClassListSelector'
	instanceVariableNames: 'classesListPresenter environment'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ListPresenter subclass: #'Tools.MethodBrowser'
	instanceVariableNames: 'methodsPresenter sourcePresenter filter searchEnvironment refactoringTool versionModel'
	classVariableNames: 'AdditionalAccelerators AutoFormat InfoTips WordWrap'
	imports: #(#{Kernel.CompilerFlags})
	classInstanceVariableNames: 'commandQueryHandlers'
	classConstants: {}!
UI.ListPresenter subclass: #'Tools.ResourceListPresenter'
	instanceVariableNames: 'filterBlock resourcesPresenter previewPresenter resourceIdModel'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ListPresenter subclass: #'Tools.ResourceToolboxPresenter'
	instanceVariableNames: 'categoriesPresenter resourcesPresenter iconMap'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Shell subclass: #'Tools.SmalltalkToolShell'
	instanceVariableNames: 'searchPresenter fontSizePresenter'
	classVariableNames: 'HistoryDwellTime SearchFieldFlashes'
	imports: #()
	classInstanceVariableNames: 'optionFlags defaultView defaultExtent defaultSlideyPinsMap additionalKeyBindings commandQueryHandlers'
	classConstants: {
		'CanUseIdeaSpaceMask' -> 16r2.
		'ReuseIfOpenMask' -> 16r1
	}!
UI.AbstractDocumentShell subclass: #'Tools.SmalltalkWorkspaceDocument'
	instanceVariableNames: 'workspacePresenter searchPresenter'
	classVariableNames: 'CanUseIdeaSpace DefaultExtent DefaultView LanguageExtensions ReuseIfOpen VariableTips'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.AspectEditorDialog'
	instanceVariableNames: 'aspectPresenterInDialog hookPresenter subjectModel aspect aspectRectangle'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.CreateSubclassDialog'
	instanceVariableNames: 'packagesPresenter subclassesPresenter namePresenter usePackagePresenter package superclassPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.MenuItemDialog'
	instanceVariableNames: 'titlePresenter commandPresenter iconPresenter imageModel iconIdPresenter inspector cardsPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Dialog subclass: #'Tools.ResourceIdentifierDialog'
	instanceVariableNames: 'classesPresenter resourceNamePresenter classValue'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MenuItemDialog subclass: #'Tools.CommandMenuItemDialog'
	instanceVariableNames: 'acceleratorPresenter isRadioButtonStylePresenter isDefaultPresenter isModalPresenter'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MenuItemDialog subclass: #'Tools.MenuDialog'
	instanceVariableNames: 'autoDismissPresenter checkColumnModePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.CategoryPrompter'
	instanceVariableNames: 'treePresenter flags categoryClass'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {
		'AllowIntermediatesMask' -> 16r1.
		'AllowReadOnlyMask' -> 16r2
	}!
UI.ValueDialog subclass: #'Tools.ChooseClassDialog'
	instanceVariableNames: 'classesPresenter allowNil'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.MenuComposer'
	instanceVariableNames: 'arena menuViews conflictingAccelerators'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants private})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.PackagePrompter'
	instanceVariableNames: 'packagesPresenter notPackagedPresenter defaultPackage validationBlock'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.MenuComposer subclass: #'Tools.MenuBarComposer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.ClassBrowserAbstract'
	instanceVariableNames: 'classesPresenter categoriesPresenter methodBrowserPresenter definitionPresenter modePresenter flags history variablesPresenter protocolsPresenter filterPresenter packageModel statusModel versionModel cardsPresenter loadedPlugins methodCategories'
	classVariableNames: 'GrayedMethodFadeFactor HistoryListSize LooseMethodColor WordWrapDefinition'
	imports: #()
	classInstanceVariableNames: 'defaultShowInheritedMethods defaultFilterObjectMethods plugins'
	classConstants: {
		'FilterObjectMethodsMask' -> 16r2.
		'ShowInheritedMethodsMask' -> 16r1
	}!
Tools.SmalltalkToolShell subclass: #'Tools.Debugger'
	instanceVariableNames: 'process topFrame temp tempCount depth flags breakWhen stackPresenter sourcePresenter tempsPresenter inspectorPresenter breakAction suspendingList _method refactoringTool'
	classVariableNames: 'AnimatePause DefaultStackDepth EnableDynamicMenus RestartOnMethodSave RunToCursorBehavior ShowWalkbacks SkipTable'
	imports: #(#{Kernel.CompilerFlags} #{Kernel.OpcodePool})
	classInstanceVariableNames: ''
	classConstants: {
		'AnimateMask' -> 16r10.
		'DisassemblyMask' -> 16r4.
		'MainMask' -> 16r1.
		'ResumableMask' -> 16r8.
		'RunMask' -> 16r2.
		'StackDepthIncrement' -> 16r64
	}!
Tools.SmalltalkToolShell subclass: #'Tools.FlipperInspector'
	instanceVariableNames: 'cards'
	classVariableNames: 'Renderers'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.InspectorShell'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.MethodBrowserShell'
	instanceVariableNames: 'browserPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.PackageBrowserShell'
	instanceVariableNames: 'packagesPresenter classesPresenter methodsPresenter methodRefactoringTool variablesPresenter resourcesPresenter currentCard commentPresenter cardsPresenter updateFlags scriptTextPresenter scriptNamesPresenter prerequisitesPresenter dependentsPresenter statusModel versionModel'
	classVariableNames: 'WordWrapComment'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.ResourceBrowser'
	instanceVariableNames: 'resourceToolboxPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.SmalltalkSystemShell'
	instanceVariableNames: 'systemFolderPresenter'
	classVariableNames: 'Backcolor BackImage BackImageAlphaPercent BackImageIsTiled Default HotKey PlaySystemSounds ResetWhenInvisible Textcolor ViewMode'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.ViewComposer'
	instanceVariableNames: 'toolboxPresenter status arenaPresenter inspector composingView ownsComposingView resourceIdentifier addPositionOffset grabbers selections grid viewHierarchyPresenter adornmentRegion primarySelection vcFlags modificationStatus image clipboard undoList'
	classVariableNames: 'Clipboard DefaultGridResolution ExtentImage PositionImage'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {
		'AdornmentModifiedFlag' -> 16r4.
		'ModifiedFlag' -> 16r1.
		'MouseClickFlag' -> 16r2.
		'RefreshFlag' -> 16r8.
		'UndoRedoFlag' -> 16r10
	}!
Tools.ClassBrowserAbstract subclass: #'Tools.ClassBrowserShell'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'LocalHierarchyMask' -> 16r10
	}!
Tools.MethodBrowserShell subclass: #'Tools.MethodExplorerShell'
	instanceVariableNames: 'historyTree historyList'
	classVariableNames: 'HistoryListSize'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkWorkspace subclass: #'Tools.MethodWorkspace'
	instanceVariableNames: 'parseTree refactoringTool'
	classVariableNames: 'AutoParseDwell IsAutoParseEnabled'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'AutoParseMask' -> 16r100000
	}!
Tools.SmalltalkWorkspace subclass: #'Tools.ValueWorkspace'
	instanceVariableNames: 'textModel'
	classVariableNames: 'ValueIsSelfCookie'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValuePresenter subclass: #'Tools.BasicInspector'
	instanceVariableNames: 'variableNamesPresenter sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValuePresenter subclass: #'Tools.InspectorAbstract'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BasicInspector subclass: #'Tools.CompiledMethodInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'MethodTypes' -> #('Normal' 'Return nil' 'Return true' 'Return false' 'Return literal constant 0' 'Return self' 'Return instance variable' 'Set instance variable')
	}!
Tools.BasicInspector subclass: #'Tools.DictionaryInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BasicInspector subclass: #'Tools.SequenceableCollectionInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BasicInspector subclass: #'Tools.StructureInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.InspectorAbstract subclass: #'Tools.AspectInspector'
	instanceVariableNames: 'aspectTreePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: 'treeUpdateMode treeHasGridLines'
	classConstants: {}!
Tools.InspectorAbstract subclass: #'Tools.VisualObjectFinder'
	instanceVariableNames: 'mouseTracker finderIcon heading workspace foundView'
	classVariableNames: 'FindNonDolphinWindows'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AspectInspector subclass: #'Tools.AbstractPublishedAspectInspector'
	instanceVariableNames: 'aspectValueHolder aspectPresenter isRootAspectVisible isSingleLevelOnly'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AspectInspector subclass: #'Tools.InstVarInspector'
	instanceVariableNames: 'sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AbstractPublishedAspectInspector subclass: #'Tools.PropertyInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AbstractPublishedAspectInspector subclass: #'Tools.PublishedAspectInspector'
	instanceVariableNames: 'displayPresenter workspacePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Refactory.Browser.RefactoryClassChange subclass: #'Refactory.Browser.DolphinMoveClassChange'
	instanceVariableNames: 'superclassName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.Scanner subclass: #'Tools.SmalltalkStylingScanner'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.SingletonSearchPolicy subclass: #'Tools.CompiledMethodSearchPolicy'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.GUISessionManager subclass: #'Tools.DevelopmentSessionManager'
	instanceVariableNames: 'imageStamp installationDirectory backupOnImageSave productDetails showSplashAtStartup'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkSystemIcon subclass: #'Tools.SmalltalkSystemFolder'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Kernel.STBInFiler subclass: #'Tools.STBDebugger'
	instanceVariableNames: 'indentLevel traceStream printOffsets'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.Scintilla.Styler subclass: #'Tools.SmalltalkStyler'
	instanceVariableNames: 'arrayDepth view last inTag stack'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkStyler subclass: #'Tools.SmalltalkExpressionStyler'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkStyler subclass: #'Tools.SmalltalkMethodStyler'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.View subclass: #'Tools.MenuComposerView'
	instanceVariableNames: 'selectionIndex painter'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ContainerView subclass: #'Tools.MenuComposerArena'
	instanceVariableNames: 'dragImageList dragPoint dragMenuIndex dragSource _unused'
	classVariableNames: ''
	imports: #(#{OS.CommCtrlConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ShellView subclass: #'Tools.DebuggerShellView'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.DialogView subclass: #'Tools.WalkbackDialog'
	instanceVariableNames: 'callStack resumable caption debuggable'
	classVariableNames: 'Commands'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
		'CallStackId' -> 16r3E9.
		'IconId' -> 16r3F1
	}!
UI.ImageViewAbstract subclass: #'Tools.ImageListView'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ImageView subclass: #'Tools.ViewComposerArena'
	instanceVariableNames: 'composer'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Array methodsFor!

assignToResourceIdentifier: aResourceIdentifier
	"Private - Assign the receiver, as a literal resource array, to aResourceIdentifier"

	aResourceIdentifier assignLiteralResourceData: self!

debugPrintOn: aStream
	self printOn: aStream do: [:each | each debugPrintOn: aStream]! !
!Core.Array categoriesFor: #assignToResourceIdentifier:!private! !
!Core.Array categoriesFor: #debugPrintOn:!printing!public! !

!Core.ArrayedCollection methodsFor!

newBatchAccessor
	^Tools.KeyedAspectBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !
!Core.ArrayedCollection categoriesFor: #newBatchAccessor!public! !

!Core.Association methodsFor!

debugPrintOn: aStream
	aStream visit: self
		do: 
			[aStream
				debugPrint: key;
				nextPutAll: ' -> ';
				debugPrint: value]! !
!Core.Association categoriesFor: #debugPrintOn:!public! !

!Core.Bag class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect collection: #elements);
		yourself! !
!Core.Bag class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Core.Behavior methodsFor!

changedMethods
	"Private - Answer a <collection> of all the changed methods in the receiver."

	^self methodDictionary select: [:method | method hasChanged]!

hasAbstractMethods
	"Answer whether the receiver has any methods that are by convention considered to be
	abstract (i.e. they consist solely of a send of #subclassResponsibility to self)."

	^self methodDictionary anySatisfy: [:each | each isAbstract]!

isAbstract
	^self isNonInstantiable or: [self hasAbstractMethods]!

methodFor: aSymbol
	^self compiledMethodAt: aSymbol ifAbsent: []!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForClass: self!

whichClassDefinesInstVar: aString 
	^self whichClassSatisfies: [:aClass | aClass instVarNames includes: aString]!

whichMethodsContainSource: aString
	"Answer a <Set> of methods from the receiver's local method dictionary whose methods contain
	the specified source string."

	^self selectMethods: [:method | method containsSource: aString]!

whichMethodsOnlySelfSend: aSymbol
	"Answer a Set of methods which consist purely of a send-to-self of the specified zero-arg selector."

	^self selectMethods: ((VMLibrary default indexOfSpecialSelector: aSymbol ifAbsent: [])
				ifNil: [[:method | method isSimpleSelfSend: aSymbol]]
				ifNotNil: 
					[:index |
					| specialSend send sendRet |
					specialSend := index + OpcodePool.ShortSpecialSend - 1.
					sendRet := CompiledCode
								packByteCodes: {OpcodePool.PushSelf. specialSend. OpcodePool.ReturnFromMessage} asByteArray.
					send := CompiledCode
								packByteCodes: {OpcodePool.PushSelf. specialSend. OpcodePool.ReturnSelf} asByteArray.
					
					[:method |
					| packed |
					packed := method basicByteCodes.
					packed == send or: [packed == sendRet]]])!

whichMethodsReferTo: anObject
	"Answer a <Set> of methods in the receiver whose literal frames include the argument, anObject."

	^self selectMethods: (self referenceFilterFor: anObject)!

whichMethodsReferToAnyOf: aCollection
	^self selectMethods: (self referenceFilterForAnyOf: aCollection)!

whichSelectorsReferTo: anObject
	"Answer a Set of selectors whose methods access the argument, anObject.
	This is really only included for Blue Book compatibility."

	^(self whichMethodsReferTo: anObject) collect: [:each | each selector]!

whichSelectorsReferToAnyOf: aCollection
	^(self whichMethodsReferToAnyOf: aCollection) collect: [:each | each selector]! !
!Core.Behavior categoriesFor: #changedMethods!methods-accessing!private! !
!Core.Behavior categoriesFor: #hasAbstractMethods!public!testing! !
!Core.Behavior categoriesFor: #isAbstract!public!testing! !
!Core.Behavior categoriesFor: #methodFor:!accessing!public! !
!Core.Behavior categoriesFor: #searchForInTool:!public! !
!Core.Behavior categoriesFor: #whichClassDefinesInstVar:!public!RefactoringBrowser! !
!Core.Behavior categoriesFor: #whichMethodsContainSource:!methods-testing!public! !
!Core.Behavior categoriesFor: #whichMethodsOnlySelfSend:!methods-testing!public! !
!Core.Behavior categoriesFor: #whichMethodsReferTo:!methods-testing!public! !
!Core.Behavior categoriesFor: #whichMethodsReferToAnyOf:!methods-testing!public! !
!Core.Behavior categoriesFor: #whichSelectorsReferTo:!methods-testing!public! !
!Core.Behavior categoriesFor: #whichSelectorsReferToAnyOf:!private! !

!Core.Boolean methodsFor!

literalTextStyle
	^#literalPseudo! !
!Core.Boolean categoriesFor: #literalTextStyle!constants!private! !

!Core.Boolean class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass boolean: aSymbol! !
!Core.Boolean class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Category class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!Core.Category class categoriesFor: #icon!constants!public! !

!Core.Character methodsFor!

literalTextStyle
	^#literalCharacter! !
!Core.Character categoriesFor: #literalTextStyle!constants!private! !

!Core.Class methodsFor!

changeIndex
	^self propertyAt: #changeIndex ifAbsent: []!

changeIndexValue: aBlock 
	self propertyManager 
		propertyOf: self
		at: #changeIndex
		ifAbsentPut: aBlock!

isAbstract
	^super isAbstract or: [self class isAbstract]!

isChanged: aBoolean 
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self propertyManager isNil ifTrue: [^self].
	"Note that we don't test the existing value of the change flag here, because
	 we want to inform the package regardless (in case it isn't currently changed
	 for some reason)"
	aBoolean 
		ifTrue: 
			[self changeIndexValue: [self sourceManager changesFileSize].
			self notifyPackageOfChange]
		ifFalse: [self removePropertyAt: #changeIndex ifAbsent: []]!

isDeprecated
	^(ClassCategory name: 'Deprecated') includesClass: self!

isNonInstantiable: aBoolean
	"Private - Set whether the receiver should not be instantiated, e.g. it is abstract."

	self isNonInstantiable == aBoolean ifTrue: [^self].
	super isNonInstantiable: aBoolean.
	self isChanged: true!

methodChanged: aCompiledMethod 
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self propertyManager isNil ifTrue: [^self].
	self changeIndexValue: [aCompiledMethod changePosition].
	self notifyPackageOfChange!

notifyPackageOfChange
	PackageManager current onClassDirtied: self!

renameClassVar: oldString to: newString
	"Private - Rename the class variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own class 
	variables , not of one of its superclass'.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access class variables via the binding (Association) they will remain valid until recompiled. It is the 
	caller's responsibility to rewrite and recompile methods that reference the variable."

	self classPool changeKey: oldString to: newString.
	self classUpdated! !
!Core.Class categoriesFor: #changeIndex!accessing!private! !
!Core.Class categoriesFor: #changeIndexValue:!accessing!private! !
!Core.Class categoriesFor: #isAbstract!public!testing! !
!Core.Class categoriesFor: #isChanged:!accessing!public! !
!Core.Class categoriesFor: #isDeprecated!public!source filing! !
!Core.Class categoriesFor: #isNonInstantiable:!instance specification-accessing!private! !
!Core.Class categoriesFor: #methodChanged:!helpers!private! !
!Core.Class categoriesFor: #notifyPackageOfChange!helpers!private! !
!Core.Class categoriesFor: #renameClassVar:to:!class hierarchy-mutating!class variables!private! !

!Core.ClassDescription methodsFor!

browse
	"Open a suitable browser onto the receiver."

	Smalltalk developmentSystem browseClass: self!

categoriesFor: selector are: categories
	"Compatibility ith IBM Smalltalk fileIn format (which is of the form
	<class> categoriesFor: <selector> are: #([<categoryString>]*).
	Sets the additional categories of a selector if it exists."

	(self includesSelector: selector)
		ifTrue: 
			[categories
				do: [:categoryString | self includeSelector: selector inCategory: categoryString asMethodCategory]]!

commentStamp: stamp prior: prior
	"Answer a chunk reader which will add a comment to the receiver. Supplied for 
	compatibility with the Squeak fileout format"

	^Tools.SingleChunkReader do: [:chunk | self comment: chunk]!

copy: selector from: class
	"Copy the method with the selector <Symbol>, selector, in <ClassDescription>, 
	class, to the receiver's method dictionary, maintaining any existing categories.
	If a compile error occurs then a CompilerNotification is signalled. 
	Answers the new method or nil."

	^self copy: selector from: class categories: (class compiledMethodAt: selector) categories

!

copy: aSymbol from: aClass categories: aCollection 
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, classifying it in each of the the <Collection> of
	<methodCategory>s specified by the last argument. If a compile error occurs then a
	CompilerNotification is signalled. Answers the new method or nil."

	| method |
	method := aClass compiledMethodAt: aSymbol.
	^self 
		compile: method getSource
		categories: aCollection
		package: method owningPackageIfLoose!

copy: aSymbol from: aClass classified: aString
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, adding it to the category identified by the final <String>
	argument."

	"This method is primarily present for Smalltalk-80 compatibility, but differs in that as
	Dolphin supports multiple categories, the existing method classifications are retained and
	'cat' is treated as a new classification. The method is recompiled in its new class. If a
	compile error occurs then a CompilerNotification is signalled. Answers the new method or
	nil."

	| categories |
	categories := (aClass compiledMethodAt: aSymbol) categories.
	categories add: aString asMethodCategory.
	^self
		copy: aSymbol
		from: aClass
		categories: categories!

copyAll: selectors from: class
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	maintaining the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyAll: selectors from: class classified: cat
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	adding the new methods to the category with <readableString> name, cat,
	as well as the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | 
		(self copy: selector from: class classified: cat) notNil]!

copyAllCategoriesFrom: class
	"Copy all categories of method from the <Behavior>, class, to the receiver.
	Answers whether all of the methods copied successfully."
	
	^class selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyCategory: category from: aClass
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully."

	| cat |
	cat := category asMethodCategory.
	^(cat methodsInBehavior: self)
		allSatisfy: [:m | (self
				copy: m selector
				from: aClass
				classified: cat) notNil]!

copyCategory: category from: aClass classified: newCategory
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully. The methods are additionally classified
	under the <MethodCategory> named by the <readableString>, newCategory."

	| cat |
	cat := category asMethodCategory.
	^(cat methodsInBehavior: self)
		allSatisfy: [:m | (self
				copy: m selector
				from: aClass
				classified: newCategory) notNil]!

isDeprecated
	^self subclassResponsibility!

isVisiblyAbstract
	^self instanceClass isNonInstantiable!

methodsFor: categoryName
	"Answer a chunk reader to read and compile method chunks for the receiver
	to be classified into the method category with the specified <readableString> name.
	This method is present for loading ST files in Green Book format. Ensure
	first that the category name doesn''t, falsely, appear hierarchical."

	| useName |
	useName := categoryName copyReplacing: #{Category} value separator withObject: $/.
	^ChunkReader
		do: [:chunkString | self compile: chunkString classified: useName]
		inContext: self
		atEnd: []!

methodsFor: name stamp: aString
	"Answer a chunk reader to read and compile method chunks for the receiver
	to be classified into the method category with the specified <readableString> name.
	The stamp is ignored. This method is for compatibility with the Pharo fileout format."

	| useName |
	useName := name copyReplacing: #{Category} value separator withObject: $/.
	^ChunkReader
		do: [:chunkString | self compile: chunkString classified: useName]
		inContext: self
		atEnd: []!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol!

privateMethods
	"For compatibility with IBM Smalltalk file out format"

	^self methodsFor: 'private'

!

publicMethods
	"For compatibility with IBM Smalltalk file out format"

	^self methodsFor: 'public'

!

renameInstVar: oldString to: newString
	"Private - Rename the instance variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own instance 
	variables , not of one of its superclasses.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access instance variables by index they will remain valid until recompiled. It is the caller's responsibility
	to rewrite and recompile methods that reference the instance variable."

	self setInstanceVariables: (self instVarNames copyReplacing: oldString withObject: newString).
	self logDefinition.
	Smalltalk classUpdated: self! !
!Core.ClassDescription categoriesFor: #browse!development!public! !
!Core.ClassDescription categoriesFor: #categoriesFor:are:!public!source filing-methods! !
!Core.ClassDescription categoriesFor: #commentStamp:prior:!public!source filing-methods!squeak! !
!Core.ClassDescription categoriesFor: #copy:from:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copy:from:categories:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copy:from:classified:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copyAll:from:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copyAll:from:classified:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copyAllCategoriesFrom:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copyCategory:from:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #copyCategory:from:classified:!methods-copying!public! !
!Core.ClassDescription categoriesFor: #isDeprecated!public!source filing! !
!Core.ClassDescription categoriesFor: #isVisiblyAbstract!private!testing! !
!Core.ClassDescription categoriesFor: #methodsFor:!public!source filing-methods! !
!Core.ClassDescription categoriesFor: #methodsFor:stamp:!public!source filing-methods!squeak! !
!Core.ClassDescription categoriesFor: #newInstanceAspect:class:!adapters!private! !
!Core.ClassDescription categoriesFor: #privateMethods!public!source filing-methods! !
!Core.ClassDescription categoriesFor: #publicMethods!public!source filing-methods! !
!Core.ClassDescription categoriesFor: #renameInstVar:to:!instance variables!private! !

!Core.Collection methodsFor!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
	argument in a form that a user viewing the receiver as the value of a published aspect would 
	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
	formats.In this case we don't want to include the contents.
	N.B. This is a development time only method that supports the PublishedAspectInspector."
	
	self basicPrintOn: aStream!

debugPrintOn: aStream
	"Copy of printOn: logic, except using #debugPrintOn: to print the elements"

	aStream visit: self
		do: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self do: [:each | each debugPrintOn: aStream] separatedBy: [aStream space].
			aStream nextPut: $)]!

newBatchAccessor
	^Tools.IndexedInstVarBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	^LookupTable new
		addAll: (self newBatchAccessor getBatchAccessors collect: [:each | each aspectDescriptor]);
		yourself!

publishedKeyedAspectsBatchSize
    	"Private - Answers the number of keyed aspects to display in the PAI return at a time"
    
    	^200
    ! !
!Core.Collection categoriesFor: #aspectDisplayOn:!private! !
!Core.Collection categoriesFor: #debugPrintOn:!printing!public! !
!Core.Collection categoriesFor: #newBatchAccessor!public! !
!Core.Collection categoriesFor: #publishedAspects!constants!public! !
!Core.Collection categoriesFor: #publishedKeyedAspects!public! !
!Core.Collection categoriesFor: #publishedKeyedAspectsBatchSize!constants!private! !

!Core.Collection class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass collection: aSymbol! !
!Core.Collection class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Date class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass date: aSymbol! !
!Core.Date class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Dictionary methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^Tools.DictionaryInspector!

debugPrintOn: aStream
	"Copy of the printOn: logic, except using #debugPrintString to print the elements"

	aStream visit: self
		do: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self associationsDo: [:each | each debugPrintOn: aStream] separatedBy: [aStream space].
			aStream nextPut: $)]!

newBatchAccessor
	| keys |
	keys := self keys.
	^Tools.KeyedAspectBatchAccessor
		subject: self
		keys: ([keys asSortedCollection] on: Error do: [:ex | keys asOrderedCollection])
		startingAt: 1
		batchSize: self publishedKeyedAspectsBatchSize!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	"This override is necessary to avoid implementation details being included by the 
    	default implementation in Object>>publishedAspects for an empty Dictionary."

	^(self publishedKeyedAspects)
		addAll: self class publishedAspectsOfInstances;
		yourself! !
!Core.Dictionary categoriesFor: #alternateInspectorClass!constants!public! !
!Core.Dictionary categoriesFor: #debugPrintOn:!printing!public! !
!Core.Dictionary categoriesFor: #newBatchAccessor!public! !
!Core.Dictionary categoriesFor: #publishedAspects!constants!public! !

!Core.Dictionary class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass dictionary: aSymbol! !
!Core.Dictionary class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Float class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !
!Core.Float class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Interval methodsFor!

debugPrintOn: aStream
	self printOn: aStream!

newBatchAccessor
	^Tools.IndexedInstVarBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !
!Core.Interval categoriesFor: #debugPrintOn:!printing!public! !
!Core.Interval categoriesFor: #newBatchAccessor!public! !

!Core.LargeInteger methodsFor!

debugPrintOn: aStream
	| size |
	size := self basicSize.
	size > 1024
		ifTrue: 
			[aStream
				nextPutAll: 'a ';
				print: size * 8;
				nextPutAll: '-bit ';
				print: self class]
		ifFalse: [self printOn: aStream]! !
!Core.LargeInteger categoriesFor: #debugPrintOn:!printing!public! !

!Core.Metaclass methodsFor!

changeIndex
	^self instanceClass changeIndex!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument.
	Implementation Note: The change flags are held on the instance side."

	self instanceClass isChanged: aBoolean!

isDeprecated
	^self instanceClass isDeprecated!

methodChanged: aCompiledMethod
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self instanceClass methodChanged: aCompiledMethod! !
!Core.Metaclass categoriesFor: #changeIndex!accessing!private! !
!Core.Metaclass categoriesFor: #isChanged:!public!source filing! !
!Core.Metaclass categoriesFor: #isDeprecated!public!source filing! !
!Core.Metaclass categoriesFor: #methodChanged:!helpers!private! !

!Core.MethodCategory class methodsFor!

all
	"Answer the category for all methods."

	^Tools.AllMethodsCategory current! !
!Core.MethodCategory class categoriesFor: #all!instance creation!public! !

!Core.Number methodsFor!

literalTextStyle
	^#literalNumber! !
!Core.Number categoriesFor: #literalTextStyle!constants!private! !

!Core.Object methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^Tools.BasicInspector!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representatin of the receiver to the <puttableStream> argument in a form that a user viewing the receiver as the value of a published aspect would like to see it.
	Typically we use #displayOn:locale: with the Smalltalk locale, but some classes of object can use alternate display formats.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."

	self displayOn: aStream!

basicInspect
	"Open and answer an inspector window on the receiver.
    	Do not override this method."

	^Tools.BasicInspector shellOn: self!

browse
	"Open a suitable browser onto the receiver."

	Smalltalk developmentSystem browseClass: self class!

currentPublishedAspectsAsLiteralsMap
	"Answer a <LookupTable> mapping  publised aspect symbols to their current literal array representations. We can use this
	to represent the current published aspects values for an object without having to hold on to the actual value objects themselves."

	^self publishedAspects collect: [:each | (each accessorFor: self) value literalStoreArray]!

debugPrintOn: aStream
	"Append, to the <puttableStream>, argument a string whose characters are a description of the receiver appropriate for display in the debugger."

	self printOn: aStream!

debugPrintString
	"Answer a <readableString> whose characters are a description of the receiver as the debugger would want to see it."

	| stream |
	stream := LimitedWriteStream
				on: (String new: 32)
				limit: 500
				limitBlock: [:s | ^s contents , ' ... etc ...'].
	self debugPrintOn: stream.
	^stream contents!

halt
	"Bring up the Smalltalk debugger (suspending the active process) ..."

	| process |
	process := Processor activeProcess.
	process halt: process topFrame sender cause: 'Hard coded breakpoint'!

inspect
	"Open and answer an inspector window on the receiver."

	^Smalltalk developmentSystem inspect: self!

inspectorClass
	"Answer the class of inspector to be used when inspecting the receiver."

	^Smalltalk developmentSystem defaultInspectorClass!

newAspect: keyObject class: aspectClass 
	"Answer an instance of the <Aspect> class, aspectClass, appropriately configured to represent
	the aspect of the receiver named by the <Object>, keyObject (usually a <Symbol>)."

	^self class newInstanceAspect: keyObject class: aspectClass!

publicAccessorAspects
	"Answer a <LookupTable> of the <Aspect> for public accessor methods of the
    	the receiver."

	| aspects hidden |
	aspects := LookupTable new
				add: (self newAspect: #yourself class: Tools.Aspect);
				yourself.
	hidden := #'non browsable' asMethodCategory.
	self class allGetters do: 
			[:each |
			(each isPublic and: [(hidden includesMethod: each) not])
				ifTrue: 
					[| aspect |
					aspect := (self perform: each selector) newAspect: each selector class: Tools.Aspect.
					(aspect canWriteInto: self) ifFalse: [aspect beReadOnly].
					aspects add: aspect]].
	^aspects!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| aspects |
	aspects := self class publishedAspectsOfInstances.
	^(aspects isEmpty or: 
			[aspects size = 1 and: 
					[| aspect |
					aspect := aspects lookup: #yourself.
					aspect notNil and: [aspect editBlock isNil]]])
		ifTrue: [self publicAccessorAspects]
		ifFalse: [aspects]!

publishedEvents
    	"Answer a Set of Symbols that describe the published events triggered
    	by the receiver."
    
    	^self class publishedEventsOfInstances
    !

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForObject: self! !
!Core.Object categoriesFor: #alternateInspectorClass!constants!public! !
!Core.Object categoriesFor: #aspectDisplayOn:!private! !
!Core.Object categoriesFor: #basicInspect!public! !
!Core.Object categoriesFor: #browse!public! !
!Core.Object categoriesFor: #currentPublishedAspectsAsLiteralsMap!constants!public! !
!Core.Object categoriesFor: #debugPrintOn:!printing!public! !
!Core.Object categoriesFor: #debugPrintString!printing!public! !
!Core.Object categoriesFor: #halt!public! !
!Core.Object categoriesFor: #inspect!public! !
!Core.Object categoriesFor: #inspectorClass!constants!public! !
!Core.Object categoriesFor: #newAspect:class:!constants!public! !
!Core.Object categoriesFor: #publicAccessorAspects!constants!public! !
!Core.Object categoriesFor: #publishedAspects!constants!public! !
!Core.Object categoriesFor: #publishedEvents!events!public! !
!Core.Object categoriesFor: #searchForInTool:!public! !

!Core.Object class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Overridden by subclasses to add the aspects 	published locally"

	^LookupTable new
		add: ((self newAspect: #yourself class: Tools.Aspect) isNullable: false);
		yourself!

publishedAspectsOfInstances
	"Answer a LookupTable of AspectDescriptors that describe the aspects published
    	by an instance of the receiver. Overridden by subclasses to add the aspects
    	published locally.
    	N.B. All #publishedAspectsOfInstances methods must be placed in either the 'must strip'
    	or 'development' categories so that they are removed before package pre-requisites are 
    	calculated by the ImageStripper, otherwise the Development System may be a pre-requisite."

	^LookupTable new
		add: (self newInstanceAspect: #yourself class: Tools.Aspect);
		yourself!

publishedEvents
	"Answer a Set of Symbols that describe the published events triggered
    	by the receiver. Overridden by subclasses to add the events published 
    	locally"

	^Set new!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver. Overridden by subclasses to add the events published 
    	locally"

	^Set new! !
!Core.Object class categoriesFor: #publishedAspects!constants!public! !
!Core.Object class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!Core.Object class categoriesFor: #publishedEvents!events!public! !
!Core.Object class categoriesFor: #publishedEventsOfInstances!events!public! !

!Core.Process methodsFor!

attachDebugger: titleString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a debugger on the receiver with the specified
	frame as that shown at the top of the stack trace."

	self debuggerClass 
		show: titleString
		process: self 
		topFrame: aStackFrame
		resumable: aBoolean!

debug
    	"Private - Bring up a debugger on the receiver."
    
    	self debug: self printString topFrame: self topFrame resumable: self isTerminated not!

debug: titleString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a debugger on the receiver with the specified
	frame as that shown at the top of the stack trace. Suspend the active process."

	self attachDebugger: titleString topFrame: aStackFrame resumable: aBoolean.
	debugger suspendProcess.
	"N.B. There MUST be no further code after this point"
!

debuggerClass
	"Answer the class of <Debugger> to use for debugging this process."

	^Smalltalk developmentSystem debuggerClass!

halt: aStackFrame cause: aString
	"Private - Bring up a Smalltalk debugger on the receiver in the specified frame."

	debugger isNil
		ifTrue: 
			[self
				walkback: aString
				topFrame: aStackFrame
				resumable: true]
		ifFalse: [debugger onHalt: aStackFrame]!

primStep: steps
	"Private - Resume the receiver for a single step (method/block activation), at which point the receiver will receive a debug step interrupt. If the receiver hits a breakpoint instruction before the next method/block activation, then a different interrupt will be received. Other interrupts are disabled while the receiver is stepping."

	"Primitive failure reasons:
    		IllegalStateChange 	- the receiver is waiting on a scheduler or semaphore list (only suspended processes can be 'stepped'
    		AssertionFailure		- the receiver has been terminated.

	Note, however, that primitive failure is ignored."

	<primitive: 105>
	!

showWalkback: titleString callStack: stackTraceString debuggable: debuggableBoolean resumable: resumableBoolean
	"Private - Display a walkback dialog with the specified title and stack trace. Enable/disable
	the debug/resume buttons depending on the boolean arguments. If the Dolphin development 
	system walkback dialog is not available, then use a MessageBox."

	| box response |
	#{Tools.WalkbackDialog} ifDefined: 
			[:dialogClass |
			response := dialogClass new
						caption: titleString;
						callStack: stackTraceString;
						debuggable: debuggableBoolean;
						resumable: resumableBoolean;
						showModal.
			response isNil ifFalse: [^response]].
	box := UI.MessageBox new.
	box caption: titleString.
	box beTaskModal.
	resumableBoolean
		ifTrue: 
			[box buttonStyle: #abortRetryIgnore.
			box defaultButton: 2]
		ifFalse: 
			[box buttonStyle: #retryCancel.
			box defaultButton: 1].
	response := box errorMsg: stackTraceString.
	^response == #retry
		ifTrue: [#debug]
		ifFalse: [response == #ignore ifTrue: [#resume] ifFalse: [#terminate]]!

step
    	"Private - Resume the receiver for a single step (method/block activation), at 
    	which point the receiver will receive a debug step interrupt. If the receiver
    	hits a breakpoint instruction before the next method/block activation, then
    	a different interrupt will be received. Other interrupts are disabled while
    	the receiver is stepping.
    
    	For safety (in case sent within a callback from the UI process) we defer the 
    	single step until the current callback has returned to avoid deadlocking the 
    	current UI process."
    
    	self step: 1!

step: steps
	"Private - Resume the receiver for the specified number of steps (method/block 
    	activation), at which point the receiver will receive a debug step interrupt. If 
    	the receiver hits a breakpoint instruction before the next method/block activation, 
    	then a different interrupt will be received. Other interrupts are disabled while
    	the receiver is stepping.
    
    	For safety (in case sent within a callback from the UI process) we defer the 
    	single step until the current callback has returned to avoid deadlocking the 
    	current UI process."

	SessionManager inputState queueDeferredAction: (MessageSend
				receiver: self
				selector: #primStep:
				argument: steps)!

walkback: aString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a walkback window on the receiver with the specified title
	and with aStackFrame as the top frame of the stack trace"

	| answer traceStream debuggable titleString |
	Processor enableAsyncEvents: true.
	titleString := aString
				collect: [:each | (each == $\r or: [each == $\n]) ifTrue: [$\] ifFalse: [each]].
	debugger isNil
		ifFalse: 
			[^debugger
				onWalkback: titleString
				topFrame: aStackFrame
				resumable: aBoolean].
	traceStream := String smalltalkWriteStream: 512.
	
	[aStackFrame callstackDo: 
			[:frame |
			frame method selector == #wmPaint:wParam:lParam:
				ifTrue: [frame receiver validate	"prevent recusive paint walkback"].
			traceStream
				display: frame;
				cr]
		depth: 50]
			on: Error
			do: [:e | e notify].

	"Only show a walkback if the Debugger's global option, #showWalkbacks, is on"
	debuggable := self canDebug.
	answer := (debuggable not or: [self debuggerClass showWalkbacks])
				ifTrue: 
					[self
						showWalkback: titleString
						callStack: traceStream contents
						debuggable: debuggable
						resumable: aBoolean]
				ifFalse: 
					[aBoolean ifTrue: [Sound warningBeep] ifFalse: [Sound errorBeep].
					#debug].
	answer == #debug
		ifTrue: 
			[
			[self
				debug: titleString
				topFrame: aStackFrame
				resumable: aBoolean]
					postToMessageQueue.
			self suspendUnconditionally]
		ifFalse: [answer == #terminate ifTrue: [self terminate]]
	"Drop through to resume..."! !
!Core.Process categoriesFor: #attachDebugger:topFrame:resumable:!private! !
!Core.Process categoriesFor: #debug!private! !
!Core.Process categoriesFor: #debug:topFrame:resumable:!private! !
!Core.Process categoriesFor: #debuggerClass!constants!public! !
!Core.Process categoriesFor: #halt:cause:!private! !
!Core.Process categoriesFor: #primStep:!private!states-changing! !
!Core.Process categoriesFor: #showWalkback:callStack:debuggable:resumable:!private! !
!Core.Process categoriesFor: #step!private!states-changing! !
!Core.Process categoriesFor: #step:!private!states-changing! !
!Core.Process categoriesFor: #walkback:topFrame:resumable:!private! !

!Core.SearchPolicy class methodsFor!

method
	"Answer the singleton sub-instance of the receiver which supports a search policy based appropriate for CompiledMethods."

	^Tools.CompiledMethodSearchPolicy current! !
!Core.SearchPolicy class categoriesFor: #method!instance creation!public! !

!Core.Semaphore methodsFor!

debugPrintOn: aStream
	self printOn: aStream! !
!Core.Semaphore categoriesFor: #debugPrintOn:!printing!public! !

!Core.SequenceableCollection methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^Tools.SequenceableCollectionInspector!

newBatchAccessor
	^Tools.KeyedAspectBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !
!Core.SequenceableCollection categoriesFor: #alternateInspectorClass!constants!public! !
!Core.SequenceableCollection categoriesFor: #newBatchAccessor!public! !

!Core.SequenceableCollection class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass sequenceableCollection: aSymbol! !
!Core.SequenceableCollection class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.SessionManager class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #sessionStopped;
    		add: #imageSaveCompleted;
    		add: #'sessionStarted';
    		add: #imageSaveStarting;
		add: #queryEndSession:;
    		yourself.
    ! !
!Core.SessionManager class categoriesFor: #publishedEventsOfInstances!events!public! !

!Core.Set methodsFor!

newBatchAccessor
	^Tools.SetBatchAspectAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !
!Core.Set categoriesFor: #newBatchAccessor!private! !

!Core.Set class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass set: aSymbol! !
!Core.Set class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Stream methodsFor!

debugPrint: anObject
	"Ask anObject to append its textual description to the receiver"

	anObject debugPrintOn: self! !
!Core.Stream categoriesFor: #debugPrint:!printing!public! !

!Core.String methodsFor!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representation of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to keep to a reasonable length and stop at the first line delimiter.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."

	| count max charStream |
	aStream nextPut: $'.
	max := self size min: Tools.Aspect maxDisplayCharacters - 2.
	charStream := self readStream.
	count := 0.
	[charStream atEnd or: [count >= max]] whileFalse: 
			[| ch |
			ch := charStream next.
			(ch == $\r or: [ch == $\n])
				ifTrue: 
					["Stop at line delimiter"
					count := max]
				ifFalse: [aStream nextPut: ch].
			count := count + 1].
	charStream atEnd ifFalse: [aStream nextPutAll: ' ...'].
	aStream nextPut: $'!

debugPrintOn: aStream
	self printOn: aStream!

literalTextStyle
	^#literalString!

newAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(self size > 80 or: [self identityIncludes: Character cr])
		ifTrue: [aspectClass multilineString: aSymbol]
		ifFalse: [aspectClass string: aSymbol]!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	"Implementation Note: Override because we want the receiver to be treated
	purely as a string, rather than as a collection of characters."

	^LookupTable with: (self newAspect: #yourself class: Tools.Aspect)! !
!Core.String categoriesFor: #aspectDisplayOn:!private! !
!Core.String categoriesFor: #debugPrintOn:!printing!public! !
!Core.String categoriesFor: #literalTextStyle!constants!private! !
!Core.String categoriesFor: #newAspect:class:!adapters!private! !
!Core.String categoriesFor: #publishedAspects!constants!public! !

!Core.Symbol methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to keep to use the printString format."
  
  	self printOn: aStream!

literalTextStyle
	^#literalSymbol!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForSymbol: self! !
!Core.Symbol categoriesFor: #aspectDisplayOn:!private! !
!Core.Symbol categoriesFor: #literalTextStyle!constants!private! !
!Core.Symbol categoriesFor: #searchForInTool:!public! !

!Core.Symbol class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol) beImmutable! !
!Core.Symbol class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.Time class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass time: aSymbol! !
!Core.Time class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Core.UndefinedObject methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to use #printOn: because nil displays as nothing.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."
  
  	self printOn: aStream!

literalTextStyle
	^#literalPseudo! !
!Core.UndefinedObject categoriesFor: #aspectDisplayOn:!private! !
!Core.UndefinedObject categoriesFor: #literalTextStyle!constants!private! !

!Core.WeakSet class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #elementsExpired:;
    		yourself.
    ! !
!Core.WeakSet class categoriesFor: #publishedEventsOfInstances!events!public! !

!External.AbstractCHARField methodsFor!

characterCreationMessage
	^self subclassResponsibility!

printAccessorExpression: aSymbol on: aWriteStream
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	aWriteStream
		nextPut: $(;
		print: Character;
		space;
		display: self characterCreationMessage;
		space;
		nextPutAll: '(bytes ';
		display: self accessorMessage keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream nextPutAll: '))'! !
!External.AbstractCHARField categoriesFor: #characterCreationMessage!automatic generation!private! !
!External.AbstractCHARField categoriesFor: #printAccessorExpression:on:!automatic generation!private! !

!External.ArrayField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length of the array"

	aWriteStream
		space;
		display: #length:;
		space.
	arrayLength printElementCountExpressionFor: self on: aWriteStream!

printMutatorBody: aSymbol on: aWriteStream
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords valueParam |
	valueParam := self valueParameterName.
	aWriteStream
		nextPutAll: '| size |';
		crtab;
		nextPutAll: 'size := (';
		nextPutAll: valueParam;
		space;
		display: #byteSize.
	"Null terminator is included in the reported byteSize, but not the size/basicSize"
	self arrayClass isNullTerminated
		ifTrue: 
			[aWriteStream nextPutAll: ' - '.
			self printStaticElementSizeExpressionOn: aWriteStream].
	self isFixedSize
		ifTrue: 
			[aWriteStream
				nextPutAll: ') ';
				display: #min:;
				nextPutAll: ' ('.
			self printFieldSizeExpressionOn: aWriteStream].
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	aWriteStream
		nextPutAll: ').';
		crtab;
		nextPutAll: valueParam;
		space;
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: 1.
	aWriteStream
		space;
		display: keywords third;
		space.
	self offset = 0
		ifFalse: 
			[self printOffsetExpression: aSymbol on: aWriteStream.
			aWriteStream nextPutAll: ' + '].
	aWriteStream
		nextPutAll: 'size ';
		display: keywords fourth;
		nextPutAll: ' 1.';
		crtab.
	arrayLength printSetSizeFor: self on: aWriteStream! !
!External.ArrayField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !
!External.ArrayField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.ArrayPointerField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length of the array"

	aWriteStream
		space;
		display: #length:;
		space.
	arrayLength printElementCountExpressionFor: self on: aWriteStream!

printMutatorBody: aSymbol on: aWriteStream
	super printMutatorBody: aSymbol on: aWriteStream.
	aWriteStream
		nextPut: $.;
		crtab.
	arrayLength printSetSizeFor: self on: aWriteStream! !
!External.ArrayPointerField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !
!External.ArrayPointerField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.BOOLField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass boolean: aSymbol!

printAccessorExpressionSuffixOn: aWriteStream
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	aWriteStream
		space;
		display: #asBoolean! !
!External.BOOLField categoriesFor: #newAspect:class:!adapters!private! !
!External.BOOLField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !

!External.BOOLField class methodsFor!

icon
	^Boolean icon! !
!External.BOOLField class categoriesFor: #icon!public! !

!External.CHARField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#byteAtOffset:put:!

characterCreationMessage
	^#ansiValue:! !
!External.CHARField categoriesFor: #accessorMessage!constants!private! !
!External.CHARField categoriesFor: #characterCreationMessage!automatic generation!private! !

!External.DOUBLE class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !
!External.DOUBLE class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!External.DOUBLEField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol! !
!External.DOUBLEField categoriesFor: #newAspect:class:!adapters!private! !

!External.EmbeddedField methodsFor!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	"Note that if returning an ExternalStructure subclass, then the resulting object will be a
	reference (an alias) to the original structure embedded in the contents of the receiving
	ExternalStructure, and therefore modifications to it will also modify the complete
	ExternalStructure. If, however, the structureClass is some other object which responds to
	#fromAddress:, the answer may be a copy of the embedded structure (e.g. subclasses of
	External) - so care is needed when updating the result."

	aWriteStream
		nextPutAll: self fieldClassName;
		nextPutAll: ' fromAddress: (';
		nextPutAll: 'bytes';
		nextPutAll: ' yourAddress'.
	self offset = 0 
		ifFalse: 
			[aWriteStream
				space;
				display: #+;
				space.
			self printOffsetExpression: aSymbol on: aWriteStream].
	aWriteStream nextPut: $)! !
!External.EmbeddedField categoriesFor: #printAccessorExpression:on:!automatic generation!private! !

!External.ExternalArray methodsFor!

printOn: aStream
	"Print a string representation of self on aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: [self do: [:each | each printOn: aStream] separatedBy: [aStream space]].
	aStream nextPut: $)!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	| batchAccessor keyedAspects |
	batchAccessor := Tools.KeyedAspectBatchAccessor subject: self
				batchSize: self publishedKeyedAspectsBatchSize.
	keyedAspects := batchAccessor getBatchAccessors collect: [:each | each aspectDescriptor].
	^LookupTable new
		addAll: keyedAspects;
		yourself!

publishedKeyedAspectsBatchSize
    	"Private - Answers the number of keyed aspects to display in the PAI return at a time"
    
    	^100
    ! !
!External.ExternalArray categoriesFor: #printOn:!printing!public! !
!External.ExternalArray categoriesFor: #publishedAspects!constants!public! !
!External.ExternalArray categoriesFor: #publishedKeyedAspects!constants!public! !
!External.ExternalArray categoriesFor: #publishedKeyedAspectsBatchSize!constants!private! !

!External.ExternalArray class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass sequenceableCollection: aSymbol!

shouldOverrideGetFieldNames
	^false! !
!External.ExternalArray class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!External.ExternalArray class categoriesFor: #shouldOverrideGetFieldNames!compiling!private! !

!External.ExternalMethod class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #descriptor) beReadOnly;
		yourself! !
!External.ExternalMethod class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!External.Field methodsFor!

autoGenCategories
	^{Structure autoGenCategory. self isNonBrowsable ifTrue: ['private'] ifFalse: ['public']}!

autoGenComment
	"Private - Answer a suitable piece of comment to warn the user that a
	method is automatically generated and should not be modified.
	Implementation Note: As of v2.2 this is empty by default as otherwise
	it tends to lead to rather bloated source files."

	^''!

makeInstanceName: className
	^(className first isVowel ifTrue: ['an'] ifFalse: ['a']) , className!

printAccessor: aSymbol on: aPuttableStream
	| remark |
	aPuttableStream
		nextPutAll: aSymbol;
		crtab;
		nextPut: $".
	self isNonBrowsable ifTrue: [aPuttableStream nextPutAll: 'Private - '].
	aPuttableStream
		nextPutAll: 'Answer the <';
		nextPutAll: self fieldClassName;
		nextPutAll: '> value of the receiver''s ''';
		display: aSymbol;
		nextPutAll: ''' field.'.
	remark := self autoGenComment.
	remark notEmpty
		ifTrue: 
			[aPuttableStream
				crtab;
				nextPutAll: remark].
	aPuttableStream
		nextPut: $";
		cr;
		crtab.
	self printAccessorBody: aSymbol on: aPuttableStream!

printAccessorBody: aSymbol on: aWriteStream 
	"Private - Answer suitable method text for compiling a read-accessor method
	to substitute for the receiver (does not include the selector)"

	aWriteStream nextPut: $^.
	self printAccessorExpression: aSymbol on: aWriteStream.
	self printAccessorExpressionSuffixOn: aWriteStream!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self subclassResponsibility!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"By default, nothing is needed."

	!

printMutator: aSymbol on: aPuttableStream
	| fieldName remark paramName |
	fieldName := aSymbol allButLast asSymbol.
	paramName := self valueParameterName.
	aPuttableStream
		nextPutAll: aSymbol;
		space;
		nextPutAll: paramName;
		crtab;
		nextPutAll: '"Set the receiver''s ''';
		display: fieldName;
		nextPutAll: ''' field to the value of the argument, ';
		nextPutAll: paramName.
	remark := self autoGenComment.
	remark notEmpty
		ifTrue: 
			[aPuttableStream
				crtab;
				nextPutAll: remark].
	aPuttableStream
		nextPut: $";
		cr;
		crtab.
	self printMutatorBody: fieldName on: aPuttableStream!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self subclassResponsibility!

printOffsetExpression: aSymbol on: aWriteStream 
	self 
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: nil!

printOffsetExpression: aSymbol on: aWriteStream extra: aMonadicValuable
	aMonadicValuable isNil
		ifTrue: 
			[aWriteStream
				nextPutAll: Structure fieldOffsetConstantPrefix;
				display: aSymbol]
		ifFalse: 
			[self emitStaticExpression: 
					[:stream |
					stream
						nextPutAll: Structure fieldOffsetConstantPrefix;
						display: aSymbol;
						nextPutAll: ' + ';
						display: anObject]
				on: aWriteStream]!

valueParameterName
	"Private - Answer the name to use for the value parameter of a setter method generated for
	the field described by the receiver."

	^self makeInstanceName: self fieldClassName! !
!External.Field categoriesFor: #autoGenCategories!private! !
!External.Field categoriesFor: #autoGenComment!constants!private! !
!External.Field categoriesFor: #makeInstanceName:!automatic generation!private! !
!External.Field categoriesFor: #printAccessor:on:!automatic generation!private! !
!External.Field categoriesFor: #printAccessorBody:on:!automatic generation!private! !
!External.Field categoriesFor: #printAccessorExpression:on:!automatic generation!private! !
!External.Field categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !
!External.Field categoriesFor: #printMutator:on:!automatic generation!private! !
!External.Field categoriesFor: #printMutatorBody:on:!automatic generation!private! !
!External.Field categoriesFor: #printOffsetExpression:on:!automatic generation!private! !
!External.Field categoriesFor: #printOffsetExpression:on:extra:!automatic generation!private! !
!External.Field categoriesFor: #valueParameterName!automatic generation!constants!private! !

!External.FillerField methodsFor!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self shouldNotImplement!

printMutatorBody: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	^self shouldNotImplement! !
!External.FillerField categoriesFor: #printAccessorExpression:on:!automatic generation!private! !
!External.FillerField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.FLOAT class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !
!External.FLOAT class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!External.FLOATField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol! !
!External.FLOATField categoriesFor: #newAspect:class:!adapters!private! !

!External.HANDLEField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	aWriteStream
		space;
		display: #asExternalHandle! !
!External.HANDLEField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !

!External.INTEGER methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull
		ifTrue: [aStream nextPut: $0]
		ifFalse: 
			[self isSigned
				ifTrue: [aStream print: self value]
				ifFalse: 
					[self value
						printOn: aStream
						base: 16
						showRadix: true]].
	aStream nextPut: $)! !
!External.INTEGER categoriesFor: #printOn:!printing!public! !

!External.INTEGER class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol! !
!External.INTEGER class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!External.IntegerBytes methodsFor!

debugPrintOn: aStream
	self printOn: aStream!

publishedKeyedAspects
	"Answers a LookupTable of the published aspects of the receiver's keyed contents"

	^LookupTable new! !
!External.IntegerBytes categoriesFor: #debugPrintOn:!printing!public! !
!External.IntegerBytes categoriesFor: #publishedKeyedAspects!constants!public! !

!External.IntegerBytes class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol! !
!External.IntegerBytes class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!External.LPVOIDField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol!

printAccessorExpressionSuffixOn: aWriteStream
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	aWriteStream
		space;
		display: #asExternalAddress! !
!External.LPVOIDField categoriesFor: #newAspect:class:!adapters!private! !
!External.LPVOIDField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !

!External.PointerField methodsFor!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	aWriteStream
		display: self pointerClass;
		space;
		display: #fromAddress:;
		nextPutAll: ' (bytes ';
		display: #intPtrAtOffset:;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream nextPut: $)!

printMutatorBody: aSymbol on: aWriteStream
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords |
	keywords := #uintPtrAtOffset:put: keywords.
	aWriteStream
		nextPutAll: 'bytes ';
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		space;
		display: keywords second;
		space;
		nextPutAll: self valueParameterName;
		space;
		display: #yourAddress! !
!External.PointerField categoriesFor: #printAccessorExpression:on:!automatic generation!private! !
!External.PointerField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.QWORD methodsFor!

printOn: aStream
	"Append a debug text representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; display: self; nextPut: $)
! !
!External.QWORD categoriesFor: #printOn:!printing!public! !

!External.RECT methodsFor!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	self isNull ifTrue: [^super printOn: aStream].
	aStream
		basicPrint: self;
		nextPut: $(;
		print: self topLeft;
		nextPutAll: ', ';
		print: self bottomRight;
		nextPut: $)! !
!External.RECT categoriesFor: #printOn:!printing!public! !

!External.SCALAR class methodsFor!

shouldOverrideGetFieldNames
	^false! !
!External.SCALAR class categoriesFor: #shouldOverrideGetFieldNames!compiling!private! !

!External.ScalarField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol!

printAccessorExpression: aSymbol on: aWriteStream 
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will read the value of this field from an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	aWriteStream
		nextPutAll: '(bytes ';
		display: self accessorMessage keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream nextPut: $)!

printMutatorBody: aSymbol on: aWriteStream
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an instance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	| keywords |
	keywords := self accessorMessage keywords.
	aWriteStream
		nextPutAll: 'bytes';
		space;
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		space;
		display: keywords second;
		space.
	self printMutatorValueOn: aWriteStream parameter: self valueParameterName! !
!External.ScalarField categoriesFor: #newAspect:class:!adapters!private! !
!External.ScalarField categoriesFor: #printAccessorExpression:on:!automatic generation!private! !
!External.ScalarField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.ScalarField class methodsFor!

icon
	^Integer icon! !
!External.ScalarField class categoriesFor: #icon!public! !

!External.StringField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"If the length of the field is fixed, then assume we are reading a null-terminated string."
	self isFixedSize ifFalse: [super printAccessorExpressionSuffixOn: aWriteStream]
	!

printMutatorBody: aSymbol on: aWriteStream
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which
	will write the value of this field into an isntance of the structure. The field in question
	is after the fields in the <sequencedReadableCollection> that is the 2nd argument."

	"Implementation Note: In this case we overwrite the embedded String, not forgetting to Null
	Terminate it"

	| keywords |
	super printMutatorBody: aSymbol on: aWriteStream.
	aWriteStream nextPutAll: 'bytes '.
	keywords := (self elementSize == 2 ifTrue: [#wordAtOffset:put:] ifFalse: [#byteAtOffset:put:])
				keywords.
	aWriteStream
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aWriteStream.
	aWriteStream
		nextPutAll: ' + size ';
		display: keywords second;
		space;
		nextPut: $0! !
!External.StringField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !
!External.StringField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.StringField class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass string: aSymbol! !
!External.StringField class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!External.Structure methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^Tools.StructureInspector!

printableFields
	^self getValidFields!

printFields: aCollection on: aStream
	| sep |
	sep := [sep := [aStream space]].
	aCollection do: 
			[:each |
			(self isFieldBrowsable: each)
				ifTrue: 
					[sep value.
					aStream
						display: each;
						nextPut: $=;
						print: (self getField: each)]]!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	self printFields: self printableFields on: aStream!

printOn: aStream
	"Append a textual representation of the receiver to aStream.
	We use the template definition to do this in a generic way for all correctly 
	defined subclasses. Fields are printed in the order of their offset"

	aStream visit: self
		do: 
			[self basicPrintOn: aStream.
			aStream nextPut: $(.
			self printFieldsOn: aStream.
			aStream nextPut: $)]!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	self isNull
		ifFalse: 
			[self getValidFields do: 
					[:each |
					| field |
					field := self template at: each.
					field isBrowsable ifTrue: [aspects add: (field newAspect: each class: Tools.Aspect)]]].
	^aspects! !
!External.Structure categoriesFor: #alternateInspectorClass!constants!public! !
!External.Structure categoriesFor: #printableFields!printing!private! !
!External.Structure categoriesFor: #printFields:on:!printing!private! !
!External.Structure categoriesFor: #printFieldsOn:!printing!private! !
!External.Structure categoriesFor: #printOn:!printing!public! !
!External.Structure categoriesFor: #publishedAspects!accessing!public! !

!External.Structure class methodsFor!

autoGenCategory
	"Private - Answer the name of the <MethodCategory> into which the auto-generated 
	structure accessors for the receiver should be compiled."

	^'**compiled accessors**'!

compileAllDefinitions
	"Compile the definitions of the receiver and all its subclasses"

	self withAllSubclassesDo: [:each | each compileDefinition].
!

compileDefinition
	"Builds a new template and generates compiled methods for accessing the fields 
	described by it. Depending on the description held in each field, some accessor
	methods may be left as uncompiled to be addressed via the template and 
	#doesNotUnderstand:"

	self
		newTemplate;
		defineTemplate;
		recompileDefinition!

compileGetFieldNames
	"Private - Define a #getFieldList method for the structure class so that the field names are available even if the template is removed."

	| methodText |
	self shouldOverrideGetFieldNames ifFalse: [^self].
	methodText := String smalltalkWriteStream: 256.
	methodText
		nextPutAll: #getFieldNames;
		crtab;
		nextPutAll: '^#('.
	self fieldNamesFromTemplate do: [:each | methodText print: each] separatedBy: [methodText space].
	methodText nextPut: $).
	self class compile: methodText contents categories: {'constants'. 'private'. self autoGenCategory}!

compileGetMethod: aSymbol forField: anExternalField
	"Private - Generate a compiled 'get' accessor method for the selector aSymbol 
	and field definition anExternalField."

	| methodText |
	anExternalField canGenerateAccessor ifFalse: [^self].
	methodText := String smalltalkWriteStream: 256.
	anExternalField printAccessor: aSymbol on: methodText.
	self formatAndCompile: methodText contents categories: anExternalField autoGenCategories!

compileNewFields
	self definesNewFields ifFalse: [^self].
	self template keysAndValuesDo: 
			[:getSelector :field |
			field isReadable
				ifTrue: 
					[(self shouldCompile: getSelector forField: field)
						ifTrue: [self compileGetMethod: getSelector forField: field]].
			field isWriteable
				ifTrue: 
					[| setSelector |
					setSelector := (getSelector copyWith: ':') asSymbol.
					(self shouldCompile: setSelector forField: field)
						ifTrue: [self compileSetMethod: setSelector forField: field]]]!

compileSetMethod: aSelector forField: anExternalField
	"Private - Generate a compiled 'set' accessor method for the selector aSymbol 
	and field definition, anExternalField"

	| methodText |
	anExternalField canGenerateMutator ifFalse: [^self].
	methodText := String smalltalkWriteStream: 256.
	anExternalField printMutator: aSelector on: methodText.
	self formatAndCompile: methodText contents categories: anExternalField autoGenCategories!

decompileDefinition
	"Remove generated accessor methods from the receiver. The template will be lazily rebuilt."

	{self. self class}
		do: [:each | [each removeCategory: self autoGenCategory] on: NotFoundError do: [:e | e notify]]!

formatAndCompile: aString categories: categories
	| source |
	source := Smalltalk developmentSystem reformatSource: aString in: self.
	^self compile: source categories: categories!

hasHandCodedMethodFor: selector
	"Private - Answer whether the receiver appears to have a hand coded implementation
	for the specified selector <Symbol>."

	| method |
	method := self compiledMethodAt: selector ifAbsent: [^false].
	^(self autoGenCategory asMethodCategory includesMethod: method) not!

inheritsFieldNamed: aSymbol
	| base |
	base := self superclass.
	^base ~~ Object and: [(base template includesKey: aSymbol) or: [base inheritsFieldNamed: aSymbol]]!

recompileDefinition
	"Private - Recompiles the existing template for the receiver"

	self decompileDefinition.
	self compileNewFields.
	self compileGetFieldNames!

shouldCompile: selector forField: anExternalField
	"Private - Answer whether to compile an accessor method
	with the specified selector for the specified field in the
	receiver."

	^anExternalField canGenerateAccessors and: 
			[(self hasHandCodedMethodFor: selector) not and: 
					["Don't generate inherited fields unless specifically marked for override"
					anExternalField isOverride or: [(self inheritsFieldNamed: (selector upTo: $:) asSymbol) not]]	"Don't overwrite manually written methods"]!

shouldOverrideGetFieldNames
	^self isNonInstantiable not and: 
			[self definesNewFields and: 
					[| categories |
					categories := self class whichNonVirtualCategoriesIncludeSelector: #getFieldNames.
					(categories isEmpty or: [categories includes: self autoGenCategory asMethodCategory]) and: 
							[| inherited |
							inherited := self superclass class lookupMethod: #getFieldNames.
							inherited methodClass == Structure class
								or: [self fieldNamesFromTemplate asSet ~= (inherited literalAt: 1) asSet]]]]! !
!External.Structure class categoriesFor: #autoGenCategory!compiling!constants!private! !
!External.Structure class categoriesFor: #compileAllDefinitions!compiling!public! !
!External.Structure class categoriesFor: #compileDefinition!compiling!public! !
!External.Structure class categoriesFor: #compileGetFieldNames!compiling!private! !
!External.Structure class categoriesFor: #compileGetMethod:forField:!compiling!private! !
!External.Structure class categoriesFor: #compileNewFields!compiling!private! !
!External.Structure class categoriesFor: #compileSetMethod:forField:!compiling!private! !
!External.Structure class categoriesFor: #decompileDefinition!compiling!public! !
!External.Structure class categoriesFor: #formatAndCompile:categories:!compiling!private! !
!External.Structure class categoriesFor: #hasHandCodedMethodFor:!compiling!private! !
!External.Structure class categoriesFor: #inheritsFieldNamed:!compiling!private! !
!External.Structure class categoriesFor: #recompileDefinition!compiling!private! !
!External.Structure class categoriesFor: #shouldCompile:forField:!compiling!private! !
!External.Structure class categoriesFor: #shouldOverrideGetFieldNames!compiling!private! !

!External.StructureArrayField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aWriteStream.
	aWriteStream
		space;
		display: #elementClass:;
		space;
		display: self fieldClass! !
!External.StructureArrayField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !

!External.StructureArrayPointerField methodsFor!

printAccessorExpressionSuffixOn: aWriteStream 
	"Private - Print any extra messages/statements onto the <puttableStream> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aWriteStream.
	aWriteStream
		space;
		display: #elementClass:;
		space;
		display: self elementClass! !
!External.StructureArrayPointerField categoriesFor: #printAccessorExpressionSuffixOn:!automatic generation!private! !

!External.StructureField methodsFor!

printMutatorBody: aSymbol on: aWriteStream
	"Private - Answer suitable method text for compiling a write-accessor method
	to substitute for the receiver (does not include the selector).
	N.B. In this case we overwrite the entire embedded structure with
	a new one"

	| keywords |
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	aWriteStream
		nextPutAll: self valueParameterName;
		space;
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: 1.
	aWriteStream
		space;
		display: keywords third;
		space.
	self
		printOffsetExpression: aSymbol
		on: aWriteStream
		extra: (String writeStream
				display: self fieldClassName;
				space;
				display: #basicByteSize;
				contents).
	aWriteStream
		space;
		display: keywords fourth;
		space;
		display: 1! !
!External.StructureField categoriesFor: #printMutatorBody:on:!automatic generation!private! !

!External.StructurePointer methodsFor!

printOn: aStream
	"Print a string representation of self on aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: [aStream print: self value].
	aStream nextPut: $).! !
!External.StructurePointer categoriesFor: #printOn:!printing!public! !

!External.WCHARField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#wordAtOffset:put:!

characterCreationMessage
	^#utf16Value:! !
!External.WCHARField categoriesFor: #accessorMessage!automatic generation!private! !
!External.WCHARField categoriesFor: #characterCreationMessage!automatic generation!private! !

!Graphics.Bitmap class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass bitmap: aSymbol! !
!Graphics.Bitmap class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.Color class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass color: aSymbol! !
!Graphics.Color class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.Font class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass font: aSymbol! !
!Graphics.Font class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.Gdiplus.Image class methodsFor!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol
		presenterBlock: 
			[:p :m |
			| imagePresenter |
			imagePresenter := UI.ImagePresenter
						create: 'Gdiplus view'
						in: p
						on: m.
			imagePresenter view isWholeBackgroundErased: true.
			imagePresenter])
		bePresenterBlockReadOnly;
		yourself! !
!Graphics.Gdiplus.Image class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.Gdiplus.ImageView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #interpolationMode from: self interpolationStyles);
		add: (Tools.Aspect name: #imageAttributes);
		yourself! !
!Graphics.Gdiplus.ImageView class categoriesFor: #publishedAspectsOfInstances!must strip!public! !

!Graphics.Icon class methodsFor!

choose
	| filename |
	filename := UI.FileOpenDialog new
				fileTypes: {self filesType. UI.FileDialog allFilesType};
				showModal.
	^filename notNil ifTrue: [self fromFile: filename]!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass icon: aSymbol! !
!Graphics.Icon class categoriesFor: #choose!public! !
!Graphics.Icon class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.ImageList class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass imageList: aSymbol! !
!Graphics.ImageList class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Graphics.InternalIcon class methodsFor!

choose
	| filename |
	filename := UI.FileOpenDialog new
				fileTypes: {self filesType. Icon filesType. UI.FileDialog allFilesType};
				showModal.
	^filename notNil
		ifTrue: 
			[(File splitExtensionFrom: filename) asLowercase = 'png'
				ifTrue: [self fromFile: filename]
				ifFalse: [Icon fromFile: filename]]! !
!Graphics.InternalIcon class categoriesFor: #choose!public! !

!Graphics.Pen class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #color);
		add: (Tools.Aspect integer: #width);
		add: (Tools.Aspect choice: #styleName from: self styleNames);
		yourself! !
!Graphics.Pen class categoriesFor: #publishedAspectsOfInstances!public! !

!Graphics.Point class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #x);
		add: (Tools.Aspect integer: #y);
		yourself! !
!Graphics.Point class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Graphics.Point3D class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #x);
		add: (Tools.Aspect integer: #y);
		add: (Tools.Aspect integer: #z);
		yourself! !
!Graphics.Point3D class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Graphics.Rectangle class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #top);
		add: (Tools.Aspect integer: #left);
		add: (Tools.Aspect integer: #bottom);
		add: (Tools.Aspect integer: #right);
		yourself! !
!Graphics.Rectangle class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Graphics.TextTileIcon class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass icon: aSymbol! !
!Graphics.TextTileIcon class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!Kernel.BlockClosure methodsFor!

cpuCyclesToRun
	| sem start stop lib hThread |
	lib := KernelLibrary default.
	hThread := lib getCurrentThread.
	start := External.QWORD new.
	stop := External.QWORD new.
	sem := Semaphore new.
	
	[
	[lib queryThreadCycleTime: hThread cycleTime: start.
	self value.
	lib queryThreadCycleTime: hThread cycleTime: stop]
			ensure: [sem signal]]
			forkAt: Processor userInterruptPriority.
	sem wait.
	^stop value - start value! !
!Kernel.BlockClosure categoriesFor: #cpuCyclesToRun!operations!public! !

!Kernel.BlockClosure class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects add: (Tools.Aspect name: #receiver).
	#(#argumentCount #envTempCount #stackTempCount #initialIP)
		do: [:each | aspects add: ((Tools.Aspect integer: each)
						beReadOnly;
						yourself)].
	aspects add: (Tools.Aspect name: #method).
	^aspects! !
!Kernel.BlockClosure class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Kernel.BlockFrame methodsFor!

debugIpFor: debugMethod 
	^self ip = self block initialIP 
		ifTrue: [self mapInitialIpFrom: self method to: debugMethod]
		ifFalse: [super debugIpFor: debugMethod]!

isRestartable
    	"Private - Answer whether this frame is restartable."
    
    	^self sender notNil!

makeDebug
	"Private - Convert the receiver to a debug frame. "

	| method debugMethod block |
	method := self method.
	method isDebugMethod 
		ifTrue: 
			["Already a debug frame"
			^self].
	super makeDebug.
	debugMethod := self method.
	block := self block.
	"Debug version of method will have different initialIP for the block, so we must remap"
	block initialIP: (self mapInitialIpFrom: method to: debugMethod).
	"If the block has an outer ref, then assume it may contain a ^-return and
	mutate the home frame and its sender into debug frames so that any ^-return
	would break if stepped into."
	self homeFrame 
		ifNotNil: 
			[:home | 
			home makeDebug.
			home sender ifNotNil: [:sender | sender makeDebug]]!

mapInitialIpFrom: aCompiledMethod to: debugCompiledMethod 
	| map debugMap i ip |
	map := aCompiledMethod debugInfo textMap.
	debugMap := debugCompiledMethod debugInfo textMap.
	self assert: [map size == debugMap size].
	ip := self block initialIP.
	i := self class findIP: ip inTextMap: map.
	self assert: [(map at: i) key = ip].
	^(debugMap at: i) key! !
!Kernel.BlockFrame categoriesFor: #debugIpFor:!private! !
!Kernel.BlockFrame categoriesFor: #isRestartable!private!testing! !
!Kernel.BlockFrame categoriesFor: #makeDebug!private! !
!Kernel.BlockFrame categoriesFor: #mapInitialIpFrom:to:!private! !

!Kernel.ClassBuilder class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #classAdded:;
    		add: #classUpdated:;
    		yourself.
    ! !
!Kernel.ClassBuilder class categoriesFor: #publishedEventsOfInstances!events!public! !

!Kernel.CompiledCode methodsFor!

alternateInspectorClass
	^Tools.CompiledMethodInspector!

asDebugMethod
    	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."
    
    	^self subclassResponsibility!

decodeHeaderOn: aStream 
	"Private - Answer a String describing the method header."

	aStream 
		nextPutAll: (#('Normal' 'Return self' 'Return true' 'Return false' 'Return nil' 'Return literal constant 0' 'Return instance variable' 'Set instance variable' 'Return literal static 0') 
				at: self extraIndex + 1
				ifAbsent: ['Primitive: ']).
	self isPrimitive ifTrue: [aStream print: self primitiveIndex].
	aStream
		nextPutAll: ', ';
		print: self argumentCount;
		nextPutAll: ' args, '.
	self stackTempCount > 0 
		ifTrue: 
			[aStream
				print: self stackTempCount;
				nextPutAll: ' stack temps, '].
	self envInfo > 0 
		ifTrue: 
			[aStream
				print: self envTempCount;
				nextPutAll: ' env temps, '].
	aStream
		print: self literalCount;
		nextPutAll: ' literals'.
	self needsContext ifTrue: [aStream nextPutAll: ', needs context'].
	self isDebugMethod ifTrue: [aStream nextPutAll: ', debug']!

disassembly
	"Private - Answer a <readableString> disassembly listing for the receiver."

	^Smalltalk developmentSystem disassembleMethod: self!

hasCompilationIssues
	^
	[self parseTree analyze.
	false] on: Compiler notificationClass
			do: [:ex | ex severityClass == Notification ifTrue: [ex resume] ifFalse: [ex return: true]]!

indexOfIP: ip 
	^self byteCodeDispatcherClass indexOfIP: ip in: self!

isAbstract
	"Answer whether this is an abstract method."

	^self isSimpleSelfSend: #subclassResponsibility!

isDeprecated
	^self methodClass isDeprecated or: [MethodCategory deprecatedMethods includesMethod: self]!

isSimpleSelfSend: aSymbol
	"Private - Answer whether the receiver is a method that just sends the specified selector (which must be zero-argument) to self. Note that this does not work for special selectors such as #class, #new, etc, that have specific bytecode encodings."
	
	^(byteCodes == ##(self packByteCodes: {ShortSendSelfZeroArgs. ReturnFromMessage} asByteArray)
		or: [byteCodes == ##(self packByteCodes: {ShortSendSelfZeroArgs. PopReturnSelf} asByteArray)])
			and: [(self basicAt: 1) == aSymbol and: [self extraIndex == 0]]!

stylerClass
	^self subclassResponsibility! !
!Kernel.CompiledCode categoriesFor: #alternateInspectorClass!constants!private! !
!Kernel.CompiledCode categoriesFor: #asDebugMethod!private! !
!Kernel.CompiledCode categoriesFor: #decodeHeaderOn:!printing!private! !
!Kernel.CompiledCode categoriesFor: #disassembly!private! !
!Kernel.CompiledCode categoriesFor: #hasCompilationIssues!public!searching! !
!Kernel.CompiledCode categoriesFor: #indexOfIP:!enquiries!private! !
!Kernel.CompiledCode categoriesFor: #isAbstract!public!testing! !
!Kernel.CompiledCode categoriesFor: #isDeprecated!enquiries!private! !
!Kernel.CompiledCode categoriesFor: #isSimpleSelfSend:!private!testing! !
!Kernel.CompiledCode categoriesFor: #stylerClass!constants!public! !

!Kernel.CompiledCode class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #methodClass) beReadOnly;
		add: (Tools.Aspect name: #header) beReadOnly;
		add: (Tools.Aspect integer: #argumentCount) beReadOnly;
		add: (Tools.Aspect multilineString: #getSource) beReadOnly;
		add: (Tools.Aspect name: #byteCodes) beReadOnly;
		add: (Tools.Aspect multilineString: #disassembly) beReadOnly;
		add: (Tools.Aspect name: #literals);
		add: (Tools.Aspect collection: #tempsMap) beReadOnly;
		add: (Tools.Aspect collection: #textMap) beReadOnly;
		yourself! !
!Kernel.CompiledCode class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Kernel.CompiledExpression methodsFor!

asDebugMethod
	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."

	| debugMethod exprClass |
	exprClass := self expressionClass.
	debugMethod := self compilerClass
				compileDebugExpression: self getSource
				in: exprClass
				evaluationPools: self evaluationPools.
	"Copy across some bits we need as we are an unbound expression"
	debugMethod sourceDescriptor: self sourceDescriptor.
	^debugMethod!

stylerClass
	^Smalltalk developmentSystem expressionStylerClass! !
!Kernel.CompiledExpression categoriesFor: #asDebugMethod!private! !
!Kernel.CompiledExpression categoriesFor: #stylerClass!constants!public! !

!Kernel.CompiledMethod methodsFor!

asDebugMethod
    	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."
    
    	| debugMethod |
    	self isDebugMethod ifTrue: [^self].
    	debugMethod := self compilerClass compileDebugMethod: self getSource in: self methodClass.
    	"Copy across some bits we need as we are an unbound method"
    	debugMethod 
    		sourceDescriptor: self sourceDescriptor;
    		selector: self selector;
    		isPrivate: self isPrivate.
    	^debugMethod!

browse
	"Open a suitable browser onto the receiver."

	^Smalltalk developmentSystem browseMethod: self!

icon
	"Answers an Icon that can be used to represent this object."

	^Smalltalk developmentSystem iconForMethod: self!

infoTip
	"Private - Answer a suitable 'info tip' for the receiver."

	| stream |
	stream := String smalltalkWriteStream.
	stream
		display: self;
		nextPutAll: ' ('.
	self realCategories asSortedCollection asArray
		, (self protocols asSortedCollection: [:a :b | a asSymbol < b asSymbol])
			do: [:each | stream display: each]
			separatedBy: [stream nextPutAll: ', '].
	stream nextPut: $).
	^stream contents!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForMethod: self!

stylerClass
	^Smalltalk developmentSystem methodStylerClass! !
!Kernel.CompiledMethod categoriesFor: #asDebugMethod!private! !
!Kernel.CompiledMethod categoriesFor: #browse!public! !
!Kernel.CompiledMethod categoriesFor: #icon!constants!public! !
!Kernel.CompiledMethod categoriesFor: #infoTip!accessing!development!private! !
!Kernel.CompiledMethod categoriesFor: #searchForInTool:!public! !
!Kernel.CompiledMethod categoriesFor: #stylerClass!constants!public! !

!Kernel.CompiledMethod class methodsFor!

overriddenIcon
	"Private - Answers an Icon that can be used to represent an overridden instance of this class"

	^##((Graphics.TextTileIcon text: $\x25B4 fontName: 'Segoe UI')
		textcolor: Graphics.Color dodgerBlue;
		yourself)!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #selector) beReadOnly;
		yourself! !
!Kernel.CompiledMethod class categoriesFor: #overriddenIcon!constants!private! !
!Kernel.CompiledMethod class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Kernel.CompileFailedMethod methodsFor!

asDebugMethod
    	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."
    
	^self! !
!Kernel.CompileFailedMethod categoriesFor: #asDebugMethod!private! !

!Kernel.CompilerNotification methodsFor!

okToContinue
	"Throw up an OK/Cancel message box with the receiver's compilation error/warning
	message, answering true if the user pressed OK to contine the compilation."

	| mb severity |
	severity := self severityClass.
	mb := UI.MessageBox new
				caption: 'Compilation ' , self severityName;
				text: ('line <1p>: <2s>' expandMacrosWith: self line with: self errorMessage);
				iconStyleFlag: severity mbIconId;
				yourself.
	^severity == Error
		ifTrue: 
			[mb
				ok;
				open.
			false]
		ifFalse: 
			[mb buttonStyle: #okCancel.
			mb open == #ok]! !
!Kernel.CompilerNotification categoriesFor: #okToContinue!public!testing! !

!Kernel.InputState class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #aboutToIdle;
    		yourself.
    ! !
!Kernel.InputState class categoriesFor: #publishedEventsOfInstances!events!public! !

!Kernel.MethodProtocol methodsFor!

icon
	"Answers an Icon that can be used to represent this object."

	^self isANSI
		ifTrue: [self class ansiIcon]
		ifFalse: [
			self isReadOnly
				ifTrue: [self class readOnlyIcon]
				ifFalse: [self class icon]]! !
!Kernel.MethodProtocol categoriesFor: #icon!constants!public! !

!Kernel.MethodProtocol class methodsFor!

ansiIcon
	"Private - Answers an Icon that can be used to represent an ANSI standard protocol."

	^Graphics.Icon fromId: 'METHODPROTOCOL_ANSI.ICO'!

publishedEventsOfInstances
    	"Answer a <Set> of <Symbol>s that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #protocolUpdated:;
    		yourself.
    !

readOnlyIcon
	"Private - Answers an Icon that can be used to represent a read-only protocol."

	^Graphics.Icon fromId: 'METHODPROTOCOL_READONLY.ICO'! !
!Kernel.MethodProtocol class categoriesFor: #ansiIcon!constants!private! !
!Kernel.MethodProtocol class categoriesFor: #publishedEventsOfInstances!events!public! !
!Kernel.MethodProtocol class categoriesFor: #readOnlyIcon!constants!private! !

!Kernel.Namespace class methodsFor!

isAbstract
	^self hasAbstractMethods!

isVisiblyAbstract
	"Private - All Namespaces are non-instantiable (they exist only as classes), but that doesn't mean they are abstract as such."

	^self == ##(self)!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass dictionary: aSymbol!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the receiver's keyed contents."

	^classPool publishedAspects! !
!Kernel.Namespace class categoriesFor: #isAbstract!public!testing! !
!Kernel.Namespace class categoriesFor: #isVisiblyAbstract!private!testing! !
!Kernel.Namespace class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!Kernel.Namespace class categoriesFor: #publishedAspects!constants!public! !
!Kernel.Namespace class categoriesFor: #publishedKeyedAspects!constants!public! !

!Kernel.Package methodsFor!

browse
	"Open a suitable browser onto the receiver."

	Smalltalk developmentSystem browsePackages: {self}!

defaultAbout
	"Shows a default About splash screen for the receiver. This looks for a bitmap of the same
	name as the package in the package installation directory. This is displayed in a standard
	modal Splash view with no overlaid version text.

	If you wish to use such a splash screen for your about box then set #aboutBlock to:
	[:package | package defaultAbout]"

	(UI.Splash bitmap: self defaultAboutBitmap) show!

defaultAboutBitmap
	"Answer a default Bitmap to use for the receiver. We assume that a JPG of the same name as
	the package is available in the Resources directory below the package's folder."

	"If the GdiplusImage class is not available, or the package does not provide an about bitmap
	resource, we just display an empty bitmap"

	#{Graphics.Gdiplus.Image} ifDefined: 
			[:gdiplusImage |
			| dir imageFile |
			dir := File composePath: self path subPath: 'Resources'.
			#('jpg' 'png') do: 
					[:each |
					imageFile := File
								composePath: dir
								stem: self name
								extension: each.
					(File exists: imageFile) ifTrue: [^gdiplusImage fromFile: imageFile]]].
	^Graphics.DIBSection width: 480 height: 360!

fileLocator
	^Tools.PackageRelativeFileLocator package: self!

icon
	self isBasePackage ifTrue: [^self class dolphinPackageIcon].
	^super icon!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	aspects add: ((Tools.Aspect
				collection: #untracedVariables
				presenterClass: UI.HashedCollectionPresenter
				addFrom: self variableNames asSortedCollection)
				beImmutable;
				yourself).
	^aspects!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForPackage: self! !
!Kernel.Package categoriesFor: #browse!commands!public! !
!Kernel.Package categoriesFor: #defaultAbout!constants!public! !
!Kernel.Package categoriesFor: #defaultAboutBitmap!accessing!public! !
!Kernel.Package categoriesFor: #fileLocator!accessing!public! !
!Kernel.Package categoriesFor: #icon!accessing!public! !
!Kernel.Package categoriesFor: #publishedAspects!initializing!public! !
!Kernel.Package categoriesFor: #searchForInTool:!public! !

!Kernel.Package class methodsFor!

changedIcon
	"Private - Answer the icon to mark packages that have been changed"

	^Smalltalk developmentSystem changedIcon!

dolphinPackageIcon
	^Graphics.Icon fromId: 'DolphinPackage.ico'!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances
				add: (Tools.Aspect multilineString: #comment);
				add: (Tools.Aspect string: #packageVersion);
				add: (Tools.Aspect block: #aboutBlock);
				add: (Tools.Aspect fileSave: #packageFileName);
				add: (Tools.Aspect sequenceableCollection: #manualPrerequisites
							addFrom: self manager packageNames asSortedCollection);
				add: (Tools.Aspect boolean: #preDeclareClassesOnLoad);
				yourself.
	"If the image has the ADK loaded, then include the image stripper"
	#{ImageStripper} ifDefined: [:is | answer add: (Tools.Aspect name: #imageStripper) beImmutable].
	^answer!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s, being the names all the events published
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #changed;
		add: #ownedChanged;
		add: #prerequisitesReset;
		yourself! !
!Kernel.Package class categoriesFor: #changedIcon!constants!private! !
!Kernel.Package class categoriesFor: #dolphinPackageIcon!public! !
!Kernel.Package class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!Kernel.Package class categoriesFor: #publishedEventsOfInstances!events!public! !

!Kernel.PackageManager methodsFor!

getVersionInfoFor: aCompiledMethod 
	"Part of the StsManager protocol implemented here for systems which do not have STS
	installed. Answer nil to indicate that we cannot supply version information for
	aCompiledMethod"

	^nil!

isConnected
	"Part of the StsManager protocol implemented here for systems which do not have STS
	installed. Answer nil to indicate that we are not connected to a repository"

	^false!

sourceControl
	^self! !
!Kernel.PackageManager categoriesFor: #getVersionInfoFor:!public!source tracking system! !
!Kernel.PackageManager categoriesFor: #isConnected!public!source tracking system! !
!Kernel.PackageManager categoriesFor: #sourceControl!accessing!public! !

!Kernel.PackageManager class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s being the names of the events published by
    	instances of the receiver."

	^super publishedEventsOfInstances
		add: #loadedChanged;
		add: #prerequisitesReset;
		add: #prerequisitesReset:;
		add: #packageChanged:;
		add: #ownedChanged:;
		add: #classRepackaged:from:to:;
		add: #methodRepackaged:from:to:;
		add: #resourceRepackaged:from:to:;
		add: #variableRepackaged:from:to:;
		add: #aboutToSave:;
		add: #packageInstalled:;
		yourself! !
!Kernel.PackageManager class categoriesFor: #publishedEventsOfInstances!events!public! !

!Kernel.ProcessorScheduler methodsFor!

singleStep: interruptArg
	"Private - A single step has occurred.
	Note that interrupts are NOT re-enabled here if the event if forwarded to the debugger."

	| debugger |
	debugger := activeProcess debugger.
	debugger isNil 
		ifTrue: [self enableInterrupts]
		ifFalse: [debugger onStep: interruptArg]
! !
!Kernel.ProcessorScheduler categoriesFor: #singleStep:!interrupts-handling!private! !

!Kernel.ProtoObject methodsFor!

basicInspect
	"Open and answer an inspector window on the receiver"

	^Tools.BasicInspector shellOn: self!

debugPrintString
	"Answer a <readableString> whose characters are a description of the receiver 
	as the debugger would want to see it."

	^self basicPrintString
!

halt
	"Bring up the Smalltalk debugger (suspending the active process) ..."

	| process |
	process := Processor activeProcess.
	process halt: process topFrame sender cause: 'Hard coded breakpoint'!

inspect
	"Open and answer an inspector window on the receiver"

	^self basicInspect! !
!Kernel.ProtoObject categoriesFor: #basicInspect!public! !
!Kernel.ProtoObject categoriesFor: #debugPrintString!printing!public! !
!Kernel.ProtoObject categoriesFor: #halt!public! !
!Kernel.ProtoObject categoriesFor: #inspect!public! !

!Kernel.ProtoObject class methodsFor!

icon
	^##(self) defaultIcon!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Overridden by subclasses to add the aspects 	published locally"

	^LookupTable new
		add: ((Tools.Aspect name: #yourself) isNullable: false);
		yourself!

publishedAspectsOfInstances
	"Answer a LookupTable of AspectDescriptors that describe the aspects published
    	by an instance of the receiver. Overridden by subclasses to add the aspects
    	published locally."

	^LookupTable new
		add: (Tools.Aspect name: #yourself);
		yourself! !
!Kernel.ProtoObject class categoriesFor: #icon!public! !
!Kernel.ProtoObject class categoriesFor: #publishedAspects!constants!public! !
!Kernel.ProtoObject class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Kernel.SharedPool class methodsFor!

canModifyBinding: aVariableBinding newValue: anObject
	^UI.ConfirmationRequiredWarning
		signal: ('Would you like to recompile references to <1p>.<2s> to reflect the new value <3p> (currently <4p>)?'
				expandMacrosWith: self
				with: aVariableBinding key
				with: anObject
				with: aVariableBinding value)!

referencesTo: keyString
	"Answer the collection of any methods which references the named key, assumed to
	be a variable name from the receiver."

	| env var classes |
	var := self associationAt: keyString.
	classes := self classesReferencing.
	env := Refactory.Browser.BrowserEnvironment new
				forClasses: classes , (classes collect: [:each | each class]).
	^(env referencesTo: var)
		label: ('Methods referencing <1p>.<2s>' expandMacrosWith: self with: keyString);
		yourself! !
!Kernel.SharedPool class categoriesFor: #canModifyBinding:newValue:!private! !
!Kernel.SharedPool class categoriesFor: #referencesTo:!enquiries!public! !

!Kernel.StAbstractVariableNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Var ';
		print: self name! !
!Kernel.StAbstractVariableNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StackFrame methodsFor!

debugIpFor: debugMethod 
	| interp debugPrev method prev i offset map debugMap ip |
	ip := self ip.
	ip = 1 ifTrue: [^1].
	method := self method.
	map := method debugInfo textMap.
	debugMap := debugMethod debugInfo textMap.
	self assert: [map size == debugMap size].
	i := self class findIP: ip inTextMap: map.
	(map at: i) key = ip 
		ifTrue: 
			["Directly corresponding entry"
			^(debugMap at: i) key].
	"More often mapping from bytecode immediately after a send, so we need to remap that
	previous instructions IP and then step to the next instruction in the debug method"
	interp := method byteCodeDispatcher.
	prev := interp prevIP: ip.
	i := self class findIP: prev inTextMap: map.
	offset := prev - (map at: i) key.
	debugPrev := offset = 0 
				ifTrue: [(debugMap at: i) key]
				ifFalse: 
					[| debugDispatcher steps |
					self assert: [offset < 0].
					debugDispatcher := debugMethod byteCodeDispatcher.
					i > 1 
						ifTrue: 
							[interp ip: (map at: i - 1) key.
							debugDispatcher ip: (debugMap at: i - 1) key].
					steps := 0.
					[interp ip = prev] whileFalse: 
							[steps := steps + 1.
							interp next.
							debugDispatcher next].
					self assert: [steps = 1].
					debugDispatcher ip].
	interp
		method: debugMethod;
		ip: debugPrev.
	interp next.
	^interp ip!

debugPrintOn: aStream
	self basicPrintOn: aStream!

makeDebug
	"Private - Convert the receiver to a debug frame. This is for the use of the debugger."

	| method debugMethod ip |
	method := self method.
	(method isDebugMethod or: [method sourceDescriptor isNil]) ifTrue: [^self].	"nothing to do"
	debugMethod := method asDebugMethod.
	ip := self debugIpFor: debugMethod.

	"We must reset ip, even if not changed, because method bytecodes may change from 
    	packed to unpacked. Also the method must be set first for #ip: to work correctly."
	self
		method: debugMethod;
		ip: ip!

stackWorkspace
	"Private - Answer the number of additional stack temps currently in use
    	(i.e. the depth of stack above the last named temporary currently being
    	used for working space)."

	^self sender isNil ifTrue: [0] ifFalse: [self sp - index - self frameSize + 1]! !
!Kernel.StackFrame categoriesFor: #debugIpFor:!private! !
!Kernel.StackFrame categoriesFor: #debugPrintOn:!public! !
!Kernel.StackFrame categoriesFor: #makeDebug!private! !
!Kernel.StackFrame categoriesFor: #stackWorkspace!accessing!private! !

!Kernel.StackFrame class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	^aspects
		add: (Tools.Aspect collection: #arguments) beReadOnly;
		add: (Tools.Aspect name: #method);
		add: (Tools.Aspect integer: #ip);
		add: (Tools.Aspect integer: #sp);
		add: (Tools.Aspect integer: #bp) beReadOnly;
		add: (Tools.Aspect name: #sender);
		add: (Tools.Aspect collection: #tempNames) beReadOnly;
		add: (Tools.Aspect name: #environment);
		yourself! !
!Kernel.StackFrame class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!Kernel.StAssignmentNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: ':='! !
!Kernel.StAssignmentNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StBlockNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '[]'! !
!Kernel.StBlockNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StCascadeNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Cascade'! !
!Kernel.StCascadeNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StLiteralArrayNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '#()'! !
!Kernel.StLiteralArrayNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StLiteralToken methodsFor!

textStyle
	^self value literalTextStyle! !
!Kernel.StLiteralToken categoriesFor: #textStyle!constants!public! !

!Kernel.StLiteralValueNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	self value printOn: aPuttableStream! !
!Kernel.StLiteralValueNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StMessageNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Msg ';
		print: self selector! !
!Kernel.StMessageNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StNumberLiteralToken methodsFor!

textStyle
	^#literalNumber! !
!Kernel.StNumberLiteralToken categoriesFor: #textStyle!constants!public! !

!Kernel.StOptimizedNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '##()'! !
!Kernel.StOptimizedNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StParameterNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPut: $:;
		display: self name! !
!Kernel.StParameterNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StPrimitiveNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: '<Primitive: ';
		display: self primitiveIndex.
	errorTemp
		ifNotNil: 
			[aPuttableStream
				nextPutAll: ' error: ';
				nextPutAll: errorTemp name].
	aPuttableStream nextPut: $>! !
!Kernel.StPrimitiveNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StProgramNode methodsFor!

debugPrintOn: aStream
	"Implementation Note: Debugging the parser can be difficult if we use #printOn:
	because it attempts to output formatted text for the method, which can fail when it
	is only partially constructed."

	self basicPrintOn: aStream!

postComments
	"Answer the set of comments associated with the receiver that are after the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| stop |
			stop := self stop.
			all select: [:each | each start > stop]]!

preComments
	"Answer the set of comments associated with the receiver that are before the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| start |
			start := self start.
			all select: [:each | each stop < start]]!

publishedAspects
	| aspects |
	aspects := super publishedAspects.
	aspects at: #yourself
		put: (Tools.Aspect name: #yourself
				presenterBlock: 
					[:p :m |
					| tree |
					tree := UI.TreePresenter
								create: 'Default view'
								in: p
								on: (UI.VirtualTreeModel withRoots: (OrderedCollection with: m value)).
					tree view expandAll.
					tree]).
	^aspects! !
!Kernel.StProgramNode categoriesFor: #debugPrintOn:!printing!public! !
!Kernel.StProgramNode categoriesFor: #postComments!accessing!public! !
!Kernel.StProgramNode categoriesFor: #preComments!accessing!public! !
!Kernel.StProgramNode categoriesFor: #publishedAspects!constants!public! !

!Kernel.StReturnNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPut: $^! !
!Kernel.StReturnNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StSelfVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	"The scope will be an StClassScope which knows the method class."

	^scope methodClass! !
!Kernel.StSelfVariable categoriesFor: #valueClass!accessing!public! !

!Kernel.StSelfVariableNode methodsFor!

valueClassIn: aClass
	^aClass! !
!Kernel.StSelfVariableNode categoriesFor: #valueClassIn:!public! !

!Kernel.StSequenceNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '...'! !
!Kernel.StSequenceNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StSpecialVariableNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: self name!

valueClassIn: aClass
	^self subclassResponsibility! !
!Kernel.StSpecialVariableNode categoriesFor: #displayOn:!printing!public! !
!Kernel.StSpecialVariableNode categoriesFor: #valueClassIn:!public! !

!Kernel.StStaticVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	"In the case of static variables, we can only offer a variable type with confidence (without
	resort to type inference) if the variable binding is constant. If it isn't then the variable
	could assume different types through the course of the method or even across different
	invocations (if a global, or class variable). This might cause false reports of
	unimplemented messages in the debugger. Therefore we have to be conservative here in
	suggesting the variable type."

	^binding isImmutable ifTrue: [binding value basicClass]! !
!Kernel.StStaticVariable categoriesFor: #valueClass!accessing!public! !

!Kernel.StSuperVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	^scope methodClass superclass! !
!Kernel.StSuperVariable categoriesFor: #valueClass!accessing!public! !

!Kernel.StSuperVariableNode methodsFor!

valueClassIn: aClass
	^aClass superclass! !
!Kernel.StSuperVariableNode categoriesFor: #valueClassIn:!public! !

!Kernel.StTempDeclNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPut: $|;
		nextPutAll: name;
		nextPut: $|! !
!Kernel.StTempDeclNode categoriesFor: #displayOn:!printing!public! !

!Kernel.StThisContextVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	^Integer! !
!Kernel.StThisContextVariable categoriesFor: #valueClass!accessing!public! !

!Kernel.StThisContextVariableNode methodsFor!

valueClassIn: aClass
	^Integer! !
!Kernel.StThisContextVariableNode categoriesFor: #valueClassIn:!public! !

!Kernel.StToken methodsFor!

postComments
	"Answer the set of comments associated with the receiver that are after the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| stop |
			stop := self stop.
			all select: [:each | each start > stop]]!

preComments
	"Answer the set of comments associated with the receiver that are before the token"

	^self comments ifNil: [#()] ifNotNil: [:all | all select: [:each | each stop < start]]! !
!Kernel.StToken categoriesFor: #postComments!accessing!public! !
!Kernel.StToken categoriesFor: #preComments!accessing!public! !

!Kernel.StVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown. In Smalltalk
	we only know the type that a variable can assume in the case of constants as variables are
	untyped."

	^nil! !
!Kernel.StVariable categoriesFor: #valueClass!accessing!public! !

!OS._FPIEEE_RECORD methodsFor!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	aStream
		display: #roundingMode;
		nextPut: $=;
		print: self roundingModeName;
		space;
		display: #precision;
		nextPut: $=;
		print: self precisionName;
		space;
		display: #operation;
		nextPut: $=;
		print: self operationName;
		space.
	#(#cause #enable #status) do: 
			[:each |
			aStream
				space;
				display: each;
				nextPut: $=.
			self class printFlags: (self getField: each) on: aStream].
	#(#operand1 #operand2) do: 
			[:each |
			| value |
			value := self getField: each.
			value isValid
				ifTrue: 
					[aStream
						space;
						display: each;
						nextPut: $=;
						print: value]]! !
!OS._FPIEEE_RECORD categoriesFor: #printFieldsOn:!printing!private! !

!OS._FPIEEE_VALUE methodsFor!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	self isValid
		ifTrue: 
			[aStream
				display: #format;
				nextPut: $=;
				print: self formatName
			"Don't attempt to display the value as often this may result in overflow/underflow exceptions"]
		ifFalse: [aStream nextPutAll: '<invalid>']! !
!OS._FPIEEE_VALUE categoriesFor: #printFieldsOn:!printing!private! !

!OS.FILETIME methodsFor!

printOn: aStream 
	"Append a debug representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: self;
		nextPut: $)! !
!OS.FILETIME categoriesFor: #printOn:!printing!public! !

!OS.KernelLibrary methodsFor!

queryThreadCycleTime: anExternalHandle cycleTime: aULARGE_INTEGER
	<stdcall: bool QueryThreadCycleTime handle qword*>
	^self invalidCall: _failureCode! !
!OS.KernelLibrary categoriesFor: #queryThreadCycleTime:cycleTime:!public!win32 functions-performance monitoring! !

!OS.LOGBRUSH methodsFor!

printFieldsOn: aStream
	aStream
		display: 'style=';
		print: self style;
		space;
		display: 'color=';
		print: self color.
	self hatchStyleName
		ifNotNil: 
			[:symbol |
			aStream
				space;
				display: 'hatch=';
				print: symbol]! !
!OS.LOGBRUSH categoriesFor: #printFieldsOn:!printing!private! !

!OS.LOGPEN methodsFor!

printFieldsOn: aStream
	aStream
		display: 'style=';
		print: self style;
		space;
		display: 'width=';
		print: self width;
		space;
		display: 'color=';
		print: self color! !
!OS.LOGPEN categoriesFor: #printFieldsOn:!printing!private! !

!OS.LVITEMW methodsFor!

printableFields
	| mask fields |
	false ifTrue: [^super printableFields].
	mask := self mask.
	fields := OrderedCollection with: #iItem.
	self iSubItem == 0 ifFalse: [fields addLast: #iSubItem].
	#(##(LVIF_TEXT) #text ##(LVIF_IMAGE) #iImage ##(LVIF_INDENT) #iIndent ##(LVIF_PARAM) #lParam)
		pairsDo: [:flag :symbol | (mask allMask: flag) ifTrue: [fields addLast: symbol]].
	(mask allMask: LVIF_STATE)
		ifTrue: [
			(self stateMask allMask: LVIS_STATEIMAGEMASK) 
				ifTrue: [fields add: #iStateImage]].
	^fields! !
!OS.LVITEMW categoriesFor: #printableFields!printing!private! !

!OS.MSG methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	| msg |
	self basicPrintOn: aStream.
	msg := UI.View selectorForMessage: self message.
	aStream nextPut: $(.
	self hwnd
		printOn: aStream
		base: 16
		showRadix: true.
	aStream space.
	msg isNil
		ifTrue: 
			[self message
				printOn: aStream
				base: 16
				showRadix: true]
		ifFalse: [aStream nextPutAll: msg].
	aStream
		space;
		print: self wParam;
		space;
		print: self lParam;
		nextPut: $)! !
!OS.MSG categoriesFor: #printOn:!printing!public! !

!OS.RegKeyAbstract methodsFor!

debugPrintOn: aStream
	self printOn: aStream! !
!OS.RegKeyAbstract categoriesFor: #debugPrintOn:!printing!public! !

!OS.SYSTEMTIME methodsFor!

printOn: aStream
	"Append a debugging representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		nextPut: $(; 
		display: self; 
		nextPut: $)
! !
!OS.SYSTEMTIME categoriesFor: #printOn:!printing!public! !

!OS.VersionInfo class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #fileDescription) beReadOnly;
		add: (Tools.Aspect string: #productName) beReadOnly;
		add: (Tools.Aspect string: #comments) beReadOnly;
		add: (Tools.Aspect string: #legalCopyright) beReadOnly;
		add: (Tools.Aspect string: #specialBuild) beReadOnly;
		add: (Tools.Aspect name: #fixedInfo);
		yourself! !
!OS.VersionInfo class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.VS_FIXEDFILEINFO class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #fileVersionString) beReadOnly;
		add: (Tools.Aspect string: #productVersionString) beReadOnly;
		yourself! !
!OS.VS_FIXEDFILEINFO class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.WINDOWPOS methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	| flags first |
	self isNull ifTrue: [^super printOn: aStream].
	aStream
		basicPrint: self;
		nextPutAll: '(after ';
		print: (UI.View fromHandle: self hwndInsertAfter);
		nextPutAll: ', '.
	self isRectangleChanged
		ifTrue: 
			[aStream
				print: self rectangle;
				nextPutAll: ', '].
	flags := self flags.
	first := true.
	##((Win32Constants keys select: [:each | each beginsWith: 'SWP_']) asSortedCollection asArray) do: 
			[:each |
			(flags allMask: (Win32Constants at: each))
				ifTrue: 
					[first ifTrue: [first := false] ifFalse: [aStream nextPut: $|].
					aStream nextPutAll: each]]! !
!OS.WINDOWPOS categoriesFor: #printOn:!printing!public! !

!Refactory.Browser.AndEnvironment methodsFor!

includesResource: aResourceIdentifier 
	^(environment includesResource: aResourceIdentifier) 
		and: [andedEnvironment includesResource: aResourceIdentifier]! !
!Refactory.Browser.AndEnvironment categoriesFor: #includesResource:!public!testing! !

!Refactory.Browser.BrowserEnvironment methodsFor!

allMethods
	"Answer a <Collection> of all methods defined in the environment."

	| methods |
	methods := OrderedCollection new: 256.
	self methodsDo: [:each | methods addLast: each].
	^methods!

allResourcesDo: aBlock
	UI.ResourceIdentifier allResourceIdentifiersDo: aBlock!

browse
	^self openEditor!

definitionsOf: aString 
	"Answer a <BrowserEnvironment> that includes all methods with selectors matching
	the <readableString> selector pattern argument in this environment. The selector 
	pattern may be wildcarded."

	^(aString includesAnyOf: '*?#') 
		ifTrue: [self implementorsMatching: (aString copyReplacing: $? withObject: $#)]
		ifFalse: [self implementorsOf: aString asSymbol]!

dynamicReferencesTo: aLiteral
	^MethodCategoryEnvironment referencesTo: aLiteral in: self!

forClassHierarchyFrom: aClass
 	"Answers a <BrowserEnvironment> that includes only aClass and its subclasses, and the corresponding
 	metaclasses. See also #forClassHierarchyOf:."
 
 	| classes |
 	classes := aClass withAllSubclasses asSet.
	classes addAll: aClass class withAllSubclasses.
 	^self forClasses: classes!

forMethodCategories: categoryList
	^MethodCategoryEnvironment onEnvironment: self categories: categoryList!

forPackages: aCollection
	^PackageEnvironment onEnvironment: self packages: aCollection!

includesMethod: aCompiledMethod
	"Answer whether this environment includes aCompiledMethod"

	^self includesSelector: aCompiledMethod selector in: aCompiledMethod methodClass!

includesMethodUncached: aCompiledMethod 
	"Answer whether this environment includes aCompiledMethod. If the environment uses any sort
	of cache to improve performance, then assume that the cache is stale with respect to the
	specified method."

	^self includesMethod: aCompiledMethod!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	Smalltalk developmentSystem browseClass!

search
	^search ifNil: [Tools.MethodSearch newPattern: (self searchStrings at: 1 ifAbsent: [''])]!

search: aMethodSearch 
	search := aMethodSearch.
	self addSearchString: search pattern! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #allMethods!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #allResourcesDo:!enumerating!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #browse!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #definitionsOf:!enquiries!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #dynamicReferencesTo:!environments!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #forClassHierarchyFrom:!environments!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #forMethodCategories:!environments!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #forPackages:!environments!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #includesMethod:!public!testing! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #includesMethodUncached:!public!testing! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #openEditor!browsing!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #search!accessing!public! !
!Refactory.Browser.BrowserEnvironment categoriesFor: #search:!accessing!public! !

!Refactory.Browser.BrowserEnvironmentWrapper methodsFor!

includesResource: aResourceIdentifier 
	^false!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	Smalltalk developmentSystem browseEnvironment: self! !
!Refactory.Browser.BrowserEnvironmentWrapper categoriesFor: #includesResource:!public!testing! !
!Refactory.Browser.BrowserEnvironmentWrapper categoriesFor: #openEditor!browsing!public! !

!Refactory.Browser.ClassEnvironment methodsFor!

includesResource: aResourceIdentifier 
	^self definesClass: aResourceIdentifier owningClass!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	^Smalltalk developmentSystem browseEnvironment: self! !
!Refactory.Browser.ClassEnvironment categoriesFor: #includesResource:!public!testing! !
!Refactory.Browser.ClassEnvironment categoriesFor: #openEditor!browsing!public! !

!Refactory.Browser.OrEnvironment methodsFor!

includesResource: aResourceIdentifier 
	^(environment includesResource: aResourceIdentifier) 
		and: [oredEnvironment includesResource: aResourceIdentifier]! !
!Refactory.Browser.OrEnvironment categoriesFor: #includesResource:!public!testing! !

!Refactory.Browser.RBConfigurableFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: (Tools.Aspect boolean: #formatCommentWithStatements);
		add: ((Tools.Aspect integer: #indentsForKeywords)
					isNullable: false;
					yourself);
		add: (Tools.Aspect string: #indentString);
		add: (Tools.Aspect boolean: #lineUpBlockBrackets);
		add: ((Tools.Aspect integer: #maxLineLength)
					isNullable: false;
					yourself);
		add: (Tools.Aspect boolean: #methodSignatureOnMultipleLines);
		add: ((Tools.Aspect integer: #minimumNewLinesBetweenStatements)
					isNullable: false;
					yourself);
		add: (Tools.Aspect boolean: #newLineAfterCascade);
		add: (Tools.Aspect boolean: #newLineBeforeFirstCascade);
		add: (Tools.Aspect boolean: #newLineBeforeFirstKeyword);
		add: ((Tools.Aspect integer: #newLinesAfterMethodComment)
					isNullable: false;
					yourself);
		add: ((Tools.Aspect integer: #newLinesAfterMethodPattern)
					isNullable: false;
					yourself);
		add: ((Tools.Aspect integer: #newLinesAfterTemporaries)
					isNullable: false;
					yourself);
		add: ((Tools.Aspect integer: #numberOfArgumentsForMultiLine)
					isNullable: false;
					yourself);
		add: (Tools.Aspect boolean: #periodsAsTerminators);
		add: (Tools.Aspect boolean: #retainBlankLinesBetweenStatements);
		add: (Tools.Aspect string: #stringFollowingReturn);
		add: (Tools.Aspect string: #stringInsideBlocks);
		add: (Tools.Aspect string: #stringInsideParentheses);
		add: ((Tools.Aspect sequenceableCollection: #traditionalBinaryPrecedence)
					isNullable: false;
					yourself);
		add: (Tools.Aspect boolean: #useTraditionalBinaryPrecedenceForParentheses);
		yourself! !
!Refactory.Browser.RBConfigurableFormatter class categoriesFor: #publishedAspects!constants!public! !

!Refactory.Browser.RBFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: ((Tools.Aspect integer: #maximumArgumentsPerLine)
					isNullable: false;
					yourself);
		add: ((Tools.Aspect sequenceableCollection: #selectorsToLeaveOnLine)
					isNullable: false;
					yourself);
		add: ((Tools.Aspect sequenceableCollection: #selectorsToStartOnNewLine)
					isNullable: false;
					yourself);
		yourself! !
!Refactory.Browser.RBFormatter class categoriesFor: #publishedAspects!constants!public! !

!Refactory.Browser.RBSourceFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: ((Tools.Aspect integer: #maxLineLength)
					isNullable: false;
					yourself);
		add: (Tools.Aspect boolean: #periodsAtEndOfMethod);
		yourself! !
!Refactory.Browser.RBSourceFormatter class categoriesFor: #publishedAspects!constants!public! !

!Refactory.Browser.RefactoryChange methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: self displayString! !
!Refactory.Browser.RefactoryChange categoriesFor: #displayOn:!printing!public! !

!Refactory.Browser.SelectorEnvironment methodsFor!

addMethods: methodCollection 
	methodCollection do: [:each | self addClass: each methodClass selector: each selector]! !
!Refactory.Browser.SelectorEnvironment categoriesFor: #addMethods:!adding!public! !

!Refactory.Browser.VariableEnvironment methodsFor!

includesMethodUncached: aCompiledMethod 
	"Answer whether this environment includes aCompiledMethod. If the environment uses any sort
	of cache to improve performance, then assume that the cache is stale with respect to the
	specified method."

	self updateCachesForMethod: aCompiledMethod.
	^self includesMethod: aCompiledMethod!

updateCachesForMethod: aCompiledMethod 
	#todo.	"Not necessary to flush the whole cache for the class here"
	self flushCachesFor: aCompiledMethod methodClass! !
!Refactory.Browser.VariableEnvironment categoriesFor: #includesMethodUncached:!public!testing! !
!Refactory.Browser.VariableEnvironment categoriesFor: #updateCachesForMethod:!helpers!private! !

!Smalltalk class methodsFor!

publishedEvents
	"Answer a <Set> of <Symbol>s, being the names all the events published
    	by instances of the receiver."

	"Note that there are currently no #globalAdded: and #protocolAdded: events"

	^super publishedEvents
		add: #methodAdded:;
		add: #methodUpdated:;
		add: #methodRemoved:;
		add: #methodCategorized:;
		add: #classAdded:;
		add: #classUpdated:;
		add: #classRemoved:;
		add: #classCategorized:;
		add: #classCommented:;
		add: #variableRenamed:from:;
		add: #variableRemoved:;
		add: #protocolUpdated:;
		add: #protocolRemoved:;
		yourself!

renameVariable: oldName to: newName
	"Rename the global, informing the system of the change."

	| binding oldSymbol |
	binding := oldName asQualifiedReference binding.
	oldSymbol := binding key.
	binding environment
		changeKey: oldSymbol to: newName asSymbol;
		variableRenamed: binding from: oldSymbol! !
!Smalltalk class categoriesFor: #publishedEvents!events!public! !
!Smalltalk class categoriesFor: #renameVariable:to:!operations!public! !

!StyledGradientBrush class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #startColor);
		add: (Tools.Aspect color: #endColor);
		add: (Tools.Aspect name: #startPoint);
		add: (Tools.Aspect name: #endPoint);
		yourself! !
!StyledGradientBrush class categoriesFor: #publishedAspectsOfInstances!public! !

!StyledPen class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #color);
		add: (Tools.Aspect name: #dashPattern);
		add: (Tools.Aspect number: #width);
		yourself	"For now we don't allow the width to be adjusted in the VC because there are problems"! !
!StyledPen class categoriesFor: #publishedAspectsOfInstances!public! !

!UI.AbstractCardContainer class methodsFor!

publishedAspectsOfInstances
    	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."
    
    	^(super publishedAspectsOfInstances)
    		removeKey: #layoutManager;
    		yourself!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #currentCardChanged;
		yourself! !
!UI.AbstractCardContainer class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.AbstractCardContainer class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.AbstractDocumentShell methodsFor!

saveStateOn: aWriteStream
	"Private - Write the source of a monadic block that will configure an instance of the receiver's class
	to match the state current receiver, to aWriteStream. The block expects a fresh instance of
	the receiver's class as it's parameter"

	aWriteStream nextPutAll: '[:aDocumentShell | 
	aDocumentShell setDocumentData: '.
	self getDocumentData literalStoreEvaluationOn: aWriteStream.
	';
		filename: <1p>]' expandMacrosWithArguments: {self filename} on: aWriteStream! !
!UI.AbstractDocumentShell categoriesFor: #saveStateOn:!private!saved state! !

!UI.AbstractToTextConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #locale);
		yourself! !
!UI.AbstractToTextConverter class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.AXControlSite class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect
					name: #progId
					presenterBlock: [:p :m | TextPresenter createIn: p on: m]
					editBlock: [:p | p model value: (self chooseControl: p model value)]);
		add: (Tools.Aspect name: #controlDispatch) beReadOnly;
		add: (Tools.Aspect name: #yourself editBlock: [:p | p model value editControlProperties]);
		add: (Tools.Aspect boolean: #firesPropertyNotifications);
		add: (Tools.Aspect boolean: #firesControlEvents);
		add: (Tools.Aspect boolean: #allowContextMenu);
		add: (Tools.Aspect boolean: #isDesignMode);
		add: (Tools.Aspect boolean: #isDefault);
		add: (Tools.Aspect string: #licenseKey);
		yourself! !
!UI.AXControlSite class categoriesFor: #publishedAspectsOfInstances!constants!must strip!public! !

!UI.AXValueConvertingControlSite class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| applicableTypeConverters |
	applicableTypeConverters := Set new.
	self applicableTypeConverterCategories do: [:each | applicableTypeConverters addAll: each classes].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #typeconverter
					evaluationFrom: (applicableTypeConverters asSortedCollection asArray
							collect: [:each | each name , ' new']))
						beImmutable;
		add: (Tools.Aspect name: #value);
		yourself! !
!UI.AXValueConvertingControlSite class categoriesFor: #publishedAspectsOfInstances!constants!must strip!public! !

!UI.BasicListAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #canHScroll);
		yourself! !
!UI.BasicListAbstract class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.BooleanToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #format
					chooseFrom: #('nil' '#(''false'' ''true'')' '#(''no'' ''yes'')' '#(''off'' ''on'')')) beImmutable;
		yourself! !
!UI.BooleanToText class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.BorderLayout methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that are managed
	by the receiver."

	^Tools.Aspect
		choice: #arrangement
		from: #(#north #south #east #west #center)
		andNil: #none! !
!UI.BorderLayout categoriesFor: #arrangementAspect!accessing!private! !

!UI.BorderLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #horizontalGap);
		add: (Tools.Aspect integer: #verticalGap);
		yourself! !
!UI.BorderLayout class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.CardContainer class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect font: #font);
		add: (Tools.Aspect boolean: #hasButtons);
		add: (Tools.Aspect boolean: #hasHotTracking);
		add: (Tools.Aspect boolean: #isMultiline);
		add: (Tools.Aspect choice: #tabOrientation from: TabView tabOrientations values);
		add: (Tools.Aspect choice: #viewMode from: TabView viewModes keys asSortedCollection);
		add: (Tools.Aspect block: #getImageBlock);
		add: (Tools.Aspect block: #getTextBlock);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #currentCardChanging:;
    		yourself.
    ! !
!UI.CardContainer class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.CardContainer class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.CardLabel class methodsFor!

publishedAspectsOfInstances
	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #text);
		add: (Tools.Aspect block: #iconBlock);
		add: (Tools.Aspect integer: #helpId);
		yourself! !
!UI.CardLabel class categoriesFor: #publishedAspectsOfInstances!public! !

!UI.CardLayout class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #currentCardChanged;
    		yourself.
    ! !
!UI.CardLayout class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.CheckBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #is3State);
		yourself! !
!UI.CheckBox class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.CheckButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #value);
		add: (Tools.Aspect boolean: #hasLeftText);
		add: (Tools.Aspect boolean: #isPushLike);
		add: (Tools.Aspect name: #image);
		add: (Tools.Aspect choice: #alignment from: AlignmentMap keys asSortedCollection);
		yourself! !
!UI.CheckButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ColorView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		removeKey: #backcolor;
		add: (Tools.Aspect color: #value);
		yourself! !
!UI.ColorView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ComboBox methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self presenter! !
!UI.ComboBox categoriesFor: #visualObjectAtPoint:!enquiries!private! !

!UI.ComboBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #droppedHeight);
		add: (Tools.Aspect choice: #mode from: Modes);
		add: (Tools.Aspect boolean: #canHScroll);
		yourself! !
!UI.ComboBox class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.CommandDescription methodsFor!

commandString: commandText
	"Sets the receiver's command from the <readableString> representation, commandText."

	| c |
	c := Compiler evaluate: commandText.
	c notNil ifTrue: [self command: c]! !
!UI.CommandDescription categoriesFor: #commandString:!accessing!initializing!public! !

!UI.CommandDescription class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #command);
		add: (Tools.Aspect string: #description);
		add: (Tools.Aspect hotkey: #acceleratorKey);
		add: (Tools.Aspect boolean: #isModalCommand);
		add: (Tools.Aspect icon: #image);
		yourself! !
!UI.CommandDescription class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.CommandMenuItem methodsFor!

commandString: commandText
	"Sets the receiver's command from the <readableString> representation, commandText."

	self commandDescription commandString: commandText!

edit
	"Private - Edit the receiver in a dialog box."

	(Tools.CommandMenuItemDialog createOn: self) showModal! !
!UI.CommandMenuItem categoriesFor: #commandString:!accessing!public! !
!UI.CommandMenuItem categoriesFor: #edit!operations!private! !

!UI.CommandMenuItem class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #commandDescription);
		add: (Tools.Aspect boolean: #isRadioButtonStyle);
		add: (Tools.Aspect boolean: #isDefault);
		add: (Tools.Aspect icon: #image);
		yourself! !
!UI.CommandMenuItem class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ContainerView class methodsFor!

applicableLayoutManagerCategories
	"Answers a Set of class category containing LayoutManagers that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Layout Managers-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| applicableLayoutManagers choices categories |
	categories := self applicableLayoutManagerCategories.
	applicableLayoutManagers := LayoutManager allSubclasses
				select: [:each | categories anySatisfy: [:cat | cat includesClass: each]].
	choices := OrderedCollection with: 'nil'.
	applicableLayoutManagers asSortedCollection do: [:each | choices addLast: each name , ' new'].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect rectangle: #insets) beImmutable;
		add: (Tools.Aspect choice: #layoutManager evaluationFrom: choices) beImmutable;
		add: (Tools.Aspect boolean: #clipChildren);
		yourself! !
!UI.ContainerView class categoriesFor: #applicableLayoutManagerCategories!constants!public! !
!UI.ContainerView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ControlBarAbstract class methodsFor!

applicableLayoutManagerCategories
	"Answers a Set of class category containing LayoutManagers that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Layout Managers-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| applicableLayoutManagers categories choices |
	applicableLayoutManagers := Set new.
	categories := self applicableLayoutManagerCategories.
	categories do: [:each | applicableLayoutManagers addAll: each classes].
	choices := OrderedCollection with: 'nil'.
	applicableLayoutManagers asSortedCollection do: [:each | choices addLast: each name , ' new'].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #hasDivider);
		add: (Tools.Aspect choice: #layoutManager evaluationFrom: choices) beImmutable;
		removeKey: #text;
		yourself
	"add: (Aspect boolean: #isVertical);"! !
!UI.ControlBarAbstract class categoriesFor: #applicableLayoutManagerCategories!constants!public! !
!UI.ControlBarAbstract class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ControlView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #forecolor);
		yourself
	"We really need these notifications, so probably not wise to allow them to be turned off"
	"add: (Aspect boolean: #wantParentNotifications);"! !
!UI.ControlView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.DateTimeCommonControl methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^super publishedAspects
		add: (self modelClass newInstanceAspect: #minimum class: Tools.Aspect);
		add: (self modelClass newInstanceAspect: #maximum class: Tools.Aspect);
		add: (self modelClass newInstanceAspect: #value class: Tools.Aspect);
		yourself! !
!UI.DateTimeCommonControl categoriesFor: #publishedAspects!public! !

!UI.DateTimePicker class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #isTimeMode);
		add: (Tools.Aspect boolean: #hasUpDown);
		add: (Tools.Aspect boolean: #canShowNone);
		add: (Tools.Aspect boolean: #hasLongDateFormat);
		add: (Tools.Aspect boolean: #isRightAligned);
		add: (Tools.Aspect name: #displayFormat);
		yourself! !
!UI.DateTimePicker class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.DateToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #format);
		yourself! !
!UI.DateToText class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.FlowLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #horizontalGap);
		add: (Tools.Aspect integer: #verticalGap);
		add: (Tools.Aspect choice: #alignment from: AlignmentMap keys asSortedCollection);
		yourself! !
!UI.FlowLayout class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.FontView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect font: #value);
		add: (Tools.Aspect string: #previewText);
		yourself! !
!UI.FontView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.FramingCalculation class methodsFor!

allCalculations
	"This is a design-time method for accessing the complete set of available framing
	calculations so that the user may choose between them. A refelective means of determing the
	set of calculations is used in order to allow the set of available calculations to be lazily
	created at runtime (i.e. after image stripping) , and also to allow for user-extensibility
	without the need to modify a system (class #initialize) method. To add new framing
	calculations follow the pattern of the existing calcs and ensure that the lazy accessor
	method is placed in the 'instance creation' category in order for the calculation to be
	offered as a choice in the view composer."

	^(('instance creation' asMethodCategory methodsInBehavior: self class)
		select: [:each | each argumentCount = 0]) collect: [:each | each value: self withArguments: #()]! !
!UI.FramingCalculation class categoriesFor: #allCalculations!accessing!public! !

!UI.FramingConstraints class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| topBottomChoices leftRightChoices |
	topBottomChoices := OrderedCollection new.
	leftRightChoices := OrderedCollection new.
	self calculationClass allCalculations do: 
			[:each |
			each isVertical
				ifTrue: [topBottomChoices addLast: each name]
				ifFalse: [leftRightChoices addLast: each name]].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #topOffset);
		add: (Tools.Aspect choice: #topFraming from: (topBottomChoices copyWithout: #fixedViewTop));
		add: (Tools.Aspect integer: #bottomOffset);
		add: (Tools.Aspect choice: #bottomFraming from: (topBottomChoices copyWithout: #fixedViewBottom));
		add: (Tools.Aspect integer: #leftOffset);
		add: (Tools.Aspect choice: #leftFraming from: (leftRightChoices copyWithout: #fixedViewLeft));
		add: (Tools.Aspect integer: #rightOffset);
		add: (Tools.Aspect choice: #rightFraming from: (leftRightChoices copyWithout: #fixedViewRight));
		yourself! !
!UI.FramingConstraints class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.FramingLayout methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that
    	are managed by the recever. Since the aspect contains a <FramingConstraints> instance
    	this must be marked as immutable to ensure that the changes are flushed back correctly"

	^(Tools.Aspect name: #arrangement) beImmutable! !
!UI.FramingLayout categoriesFor: #arrangementAspect!accessing!private! !

!UI.FramingLayout class methodsFor!

example1
	"A simple example of building a view with a framing layout.
	
		FramingLayout example1
	"

	| shell layout label button text1 text2 |
	(shell := View desktop addSubView: ShellView new)
		caption: 'FramingLayout example 1';
		backcolor: Color face3d;
		layoutManager: (layout := FramingLayout new);
		extent: 300 @ 200.
	shell insets: (10 @ 10 corner: 10 @ 10).
	label := shell addSubView: StaticText new.
	button := shell addSubView: PushButton new.
	text1 := shell addSubView: MultilineTextEdit new.
	text2 := shell addSubView: MultilineTextEdit new.
	label text: 'Fixed @ Top Left'.
	label rectangle: (10 @ 10 extent: 100 @ 20).
	button
		text: 'Hugs topright';
		command: #yourself.
	button arrangement
		leftFraming: #fixedViewRight;
		rightFraming: #fixedParentRight;
		leftOffset: -100;
		rightOffset: 0.
	text1
		text: 'Consumes half the width and all the bottom space';
		wordWrap: true.
	text1 arrangement
		rightFraming: #relativeParentWidth;
		bottomFraming: #fixedParentBottom.
	layout resize: text1 to: (10 @ 40 corner: 130 @ 190).
	text2
		text: 'Floats in the same relative postion, keeps same extent';
		wordWrap: true.
	text2 arrangement
		leftFraming: #relativeParentWidth;
		rightFraming: #fixedViewLeft;
		topFraming: #relativeParentHeight;
		bottomFraming: #fixedViewTop.
	layout resize: text2 to: (140 @ 40 corner: 290 @ 80).
	shell show! !
!UI.FramingLayout class categoriesFor: #example1!examples!public! !

!UI.GridLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #horizontalGap);
		add: (Tools.Aspect integer: #verticalGap);
		add: (Tools.Aspect integer: #rows);
		add: (Tools.Aspect integer: #columns);
		yourself! !
!UI.GridLayout class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.GroupBox class methodsFor!

publishedAspectsOfInstances
    	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."
    
    	^(super publishedAspectsOfInstances)
		removeKey: #forecolor;		"#1191: Windows BUTTON control doesn't support changing the foreground colour"
    		yourself! !
!UI.GroupBox class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.HotKey class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect autostring: #value);
		add: (Tools.Aspect name: #invalidCombinationsMask);
		add: (Tools.Aspect name: #defaultKeyMask);
		removeKey: #typeconverter;
		yourself! !
!UI.HotKey class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.IconicListAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#getImageBlock #getInfoTipBlock #customDrawBlock)
		do: [:each | aspects add: (Tools.Aspect block: each)].
	#(#hasHotTracking) do: [:each | aspects add: (Tools.Aspect boolean: each)].
	aspects
		add: (Tools.Aspect choice: #viewMode from: self viewModes keys asSortedCollection);
		yourself.
	^aspects!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
	^(super publishedEventsOfInstances)
    		add: #labelOf:changedTo:;
    		add: #aboutToEditLabel:accept:;
    		add: #labelOf:editedTo:accept:;
		yourself! !
!UI.IconicListAbstract class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.IconicListAbstract class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ImagePresenter class methodsFor!

resource_ImageList_view
	"Answer the literal data from which the 'ImageList view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_ImageList_view)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(Tools.ImageListView) 34 21 nil nil 34 2 8 1140850944 1 416 918598 2 ##(UI.ValueHolder) nil false 1769478 ##(Kernel.EqualitySearchPolicy) nil 917510 ##(Graphics.Color) #default nil 7 nil nil nil 416 nil nil 1049094 ##(UI.NullConverter) nil nil nil nil #normal 1 nil #none 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 722 225 201 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 111 12 0 0 110 0 0 0] 8 #() 722 193 193 nil 27 )! !
!UI.ImagePresenter class categoriesFor: #resource_ImageList_view!public!resources-views! !

!UI.ImageViewAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect bitmap: #value);
		add: (Tools.Aspect choice: #viewMode from: self viewModes);
		add: (Tools.Aspect boolean: #isWholeBackgroundErased);
		add: (Tools.Aspect boolean: #isDoubleBuffered);
		add: (Tools.Aspect rectangle: #insets);
		add: (Tools.Aspect choice: #imageBorder from: self edgeStyles);
		yourself! !
!UI.ImageViewAbstract class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.LayoutManager methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that
    	are managed by the recever. The default is to allow for a workspace to edit the
    	arrangement"

	^Tools.Aspect name: #arrangement! !
!UI.LayoutManager categoriesFor: #arrangementAspect!accessing!private! !

!UI.ListBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #canHScroll);
		add: (Tools.Aspect boolean: #hasPermanentScrollbars);
		add: (Tools.Aspect extent: #horizontalExtent);
		add: (Tools.Aspect choice: #selectionMode from: self selectionModes keys asSortedCollection);
		yourself! !
!UI.ListBox class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ListControlView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	| object |
	object := super visualObjectAtPoint: aPoint.
	^(self itemFromPoint: aPoint) 
		ifNil: [object]
		ifNotNil: [:item | self objectFromHandle: item ifAbsent: [object]]! !
!UI.ListControlView categoriesFor: #visualObjectAtPoint:!enquiries!private! !

!UI.ListControlView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect block: #getTextBlock);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #selectionChanged;
    		add: #selectionChanging:;
    		yourself.
    ! !
!UI.ListControlView class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.ListControlView class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ListModel class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s that describe the published events triggered by instances of
	the receiver."

	^(super publishedEventsOfInstances)
		add: #item:updatedAtIndex:;
		add: #item:addedAtIndex:;
		add: #item:removedAtIndex:;
		add: #listChanged;
		yourself! !
!UI.ListModel class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ListTreeView class methodsFor!

publishedAspectsOfInstances
	"answer the <Aspect>s published by instances of the receiver"

	^super publishedAspectsOfInstances
		removeKey: #hasCheckBoxes ifAbsent: [];
		add: (Tools.Aspect boolean: #hasButtons);
		add: (Tools.Aspect boolean: #hasLinesAtRoot);
		add: (Tools.Aspect boolean: #hasHotTracking);
		add: (Tools.Aspect integer: #indentSeparation);
		add: (Tools.Aspect boolean: #disableExpandAll);
		add: (Tools.Aspect boolean: #retainExpanded);
		add: (Tools.Aspect boolean: #useSmartRefresh);
		add: (Tools.Aspect block: #hasChildrenBlock);
		add: (Tools.Aspect block: #getChildrenBlock);
		add: (Tools.Aspect block: #getParentBlock);
		add: (Tools.Aspect block: #sortBlock);
		add: (Tools.Aspect boolean: #doSortRoots);
		add: (Tools.Aspect block: #doSortChildrenBlock);
		yourself	"	-- uses the same 'state' stuff as we need for 'buttons'"
	"		add: (Aspect boolean: #hasLines);					-- dummied out, we don't have any lines :-( "	"	-- really means #hasButtonsAtRoot"
	"		add: (Aspect boolean: #isMonoExpandable);		-- dummied out, too much effort for no value"
	"		add: (Aspect choice: #updateMode from: TreeView updateModes);
											-- dummied out, not meaningful for lists"!

publishedEventsOfInstances
	"answer a Set of Symbols that describe the published events triggered
	by instances of the receiver.
	ListTreeViews generate a few extra events that would be useful coming
	off TreeViews too (as with most views, the events are actually triggered
	off our presenter)"

	^ super publishedEventsOfInstances
		add: #nodeAdded:;
		add: #nodeRemoved:;
		add: #nodeExpanded:;
		add: #nodeCollapsed:;
		yourself.! !
!UI.ListTreeView class categoriesFor: #publishedAspectsOfInstances!constants!do copy!must strip!public! !
!UI.ListTreeView class categoriesFor: #publishedEventsOfInstances!constants!do copy!events!public! !

!UI.ListView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	#(#isVirtual #hasColumnHeaders #hasFullRowSelect #hasGridLines #hasHeaderDragDrop #hasColumnImages #hasSortHeaders #hasFlatScrollbars #hasInfoTips #canEditLabels #showsSelAlways #hasCheckBoxes #isMultiSelect #isAutoArranged #isDoubleBuffered)
		do: [:each | answer add: (Tools.Aspect boolean: each)].
	answer
		add: (Tools.Aspect autostring: #text);
		add: (Tools.Aspect bitmap: #backImage) beImmutable;
		add: (Tools.Aspect boolean: #backImageIsTiled);
		add: (Tools.Aspect position: #backImageOffset);
		add: (Tools.Aspect integer: #backImageAlphaPercent) beImmutable;
		add: (Tools.Aspect name: #iconSpacing chooseFrom: #('32@32'));
		add: (Tools.Aspect name: #thumbnailExtent chooseFrom: #('64@64' '96@96' '128@128'));
		add: (Tools.Aspect sequenceableCollection: #columnOrder) beImmutable;
		add: (Tools.Aspect sequenceableCollection: #columnsList
					addEvaluationFrom: {self columnClass name , ' new'}) beImmutable;
		removeKey: #text.
	^answer!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #rightButtonPressed:;
    		add: #keyPressed:;
    		add: #keyTyped:;
    		add: #leftButtonPressed:;
    		add: #aboutToEditLabel:accept:;
    		yourself.
    ! !
!UI.ListView class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.ListView class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ListViewColumn class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect autostring: #text);
		add: (Tools.Aspect integer: #width);
		add: (Tools.Aspect block: #getContentsBlock);
		add: (Tools.Aspect block: #getImageBlock);
		add: (Tools.Aspect block: #getTextBlock);
		add: (Tools.Aspect block: #sortBlock);
		add: (Tools.Aspect choice: #alignment from: #(#left #center #right));
		add: (Tools.Aspect boolean: #isAutoResize);
		add: (Tools.Aspect block: #getInfoTipBlock);
		add: (Tools.Aspect block: #customDrawBlock);
		yourself! !
!UI.ListViewColumn class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Menu methodsFor!

edit
	"Private - Edit the receiver in a dialog box."

	(Tools.MenuDialog createOn: self) showModal!

painterClass
	"Private - Answer the class of painter used for rendering the receiver in a
	MenuComposerView."

	^Tools.PopupMenuPainter! !
!UI.Menu categoriesFor: #edit!constants!private! !
!UI.Menu categoriesFor: #painterClass!constants!private! !

!UI.Menu class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	"Note that the #items aspect must be immutable because the #items method answers an
	OrderedCollection which is a copy of the actual items Array."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #text);
		add: (Tools.Aspect sequenceableCollection: #items
					addEvaluationFrom: #('Menu new' 'CommandMenuItem new' 'DividerMenuItem separator' 'DividerMenuItem barBreak' 'DividerMenuItem break'))
						beImmutable;
		add: (Tools.Aspect string: #name);
		add: (Tools.Aspect boolean: #isAutoDismiss);
		add: (Tools.Aspect boolean: #hasSharedImageColumn);
		add: (Tools.Aspect icon: #image);
		yourself! !
!UI.Menu class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.MenuBar methodsFor!

painterClass
	"Private - Answer the class of painter used for rendering the receiver in a
	MenuComposerView."

	^Tools.MenuBarPainter! !
!UI.MenuBar categoriesFor: #painterClass!constants!private! !

!UI.MenuBar class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass menuBar: aSymbol!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^(super publishedAspectsOfInstances)
		removeKey: #text;
		yourself! !
!UI.MenuBar class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!UI.MenuBar class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.MenuItem class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Menu icon! !
!UI.MenuItem class categoriesFor: #icon!constants!public! !

!UI.MoenTreeView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	| object |
	object := super visualObjectAtPoint: aPoint.
	^(self itemFromPoint: aPoint) ifNil: [object] ifNotNil: [:node | node object]! !
!UI.MoenTreeView categoriesFor: #visualObjectAtPoint:!enquiries!private! !

!UI.MoenTreeView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect block: #getTextBlock);
		add: (Tools.Aspect block: #getImageBlock);
		add: (Tools.Aspect integer: #parentSpacing);
		add: (Tools.Aspect name: #linePen);
		add: (Tools.Aspect name: #maxTextExtent);
		add: (Tools.Aspect boolean: #hasWordWrap);
		add: (Tools.Aspect name: #margin);
		add: (Tools.Aspect boolean: #hasButtons);
		add: (Tools.Aspect boolean: #isAutoExpanding);
		add: (Tools.Aspect choice: #viewMode from: self viewModes keys asSortedCollection);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #selectionChanged;
    		add: #selectionChanging:;
    		yourself.
    ! !
!UI.MoenTreeView class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.MoenTreeView class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.MonthCalendarView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| dayMap days |
	dayMap := LookupTable new.
	days := (1 to: 7) collect: 
					[:each |
					| day |
					day := Locale default dayOfWeekName: (each + 1) \\ 7.
					dayMap at: day put: each.
					day].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #hasToday);
		add: (Tools.Aspect boolean: #hasTodayCircle);
		add: (Tools.Aspect boolean: #hasWeekNumbers);
		add: (Tools.Aspect name: #firstDayOfWeek
					presenterBlock: 
						[:parent :model |
						(ChoicePresenter createIn: parent
							on: (ValueConverter subject: model
									typeConverter: ((MappingConverter rightToLeft: dayMap)
											leftNullValue: 0;
											yourself)))
							choices: days;
							yourself]);
		yourself! !
!UI.MonthCalendarView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.MultilineTextEdit class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #canVScroll);
		add: (Tools.Aspect boolean: #wantTab);
		add: (Tools.Aspect multilineString: #text);
		add: (Tools.Aspect boolean: #wantReturn);
		add: (Tools.Aspect boolean: #wordWrap);
		yourself! !
!UI.MultilineTextEdit class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.PluggableTypeConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #leftToRightBlock);
		add: (Tools.Aspect name: #rightToLeftBlock);
		yourself! !
!UI.PluggableTypeConverter class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Presenter class methodsFor!

addView: aViewClass asResource: aStringName
	"Adds a default instance of aViewClass as a resource of the receiver called aStringName"

	aViewClass makeResource: aStringName inClass: self !

editNewDefaultView
	"Open the View Composer to create a new view for the receiver."

	| resourceIdentifier vc resName |
	resName := Prompter
				on: self defaultView
				prompt: 'Resource name:'
				caption: 'Create a view for class ' , self name.
	resName isNil ifTrue: [^self].
	resourceIdentifier := ResourceIdentifier class: self name: resName.
	(resourceIdentifier exists not or: 
			[MessageBox
				confirm: ('<1p> already exists. Do you wish to overwrite it?' expandMacrosWith: resourceIdentifier)])
		ifFalse: [^self].
	vc := Smalltalk developmentSystem openViewComposerEmpty.
	vc
		openOnCopyOf: self defaultResourceIdentifier;
		resourceIdentifier: resourceIdentifier! !
!UI.Presenter class categoriesFor: #addView:asResource:!operations!public! !
!UI.Presenter class categoriesFor: #editNewDefaultView!operations!public! !

!UI.ProgressBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #range);
		add: (Tools.Aspect boolean: #isSmooth);
		yourself! !
!UI.ProgressBar class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ProportionalLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #isVertical);
		yourself! !
!UI.ProportionalLayout class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.PushButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer
		add: (Tools.Aspect name: #commandDescription) beReadOnly;
		add: (Tools.Aspect boolean: #isDefault);
		add: (Tools.Aspect boolean: #hasFlatAppearance);
		add: (Tools.Aspect icon: #image);
		add: (Tools.Aspect choice: #style from: ButtonStyleMap keys asSortedCollection);
		yourself.
	"add: (Aspect boolean: #isMultiline);"

	"#1191: Windows BUTTON control doesn't support changing the foreground colour"
	answer
		removeKey: #forecolor;
		yourself.
	^answer! !
!UI.PushButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ReferenceView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self referee visualObjectAtPoint: aPoint! !
!UI.ReferenceView categoriesFor: #visualObjectAtPoint:!enquiries!private! !

!UI.ReferenceView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #resourceIdentifier);
		removeKey: #hasBorder;
		removeKey: #hasClientEdge;
		removeKey: #hasStaticEdge;
		removeKey: #usePreferredExtent;
		removeKey: #preferredExtent;
		removeKey: #font;
		removeKey: #isTransparent;
		removeKey: #isEnabled;
		removeKey: #text;
		yourself! !
!UI.ReferenceView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ResourceIdentifier methodsFor!

assign: resourceData 
	"Assign aResource as the resource data represented by the receiver."

	resourceData assignToResourceIdentifier: self!

assignLiteralResourceData: aLiteralArray
	"Private - Assign aResource as the resource data represented by the receiver."

	| stream source sel methodClass categories |
	stream := String smalltalkWriteStream.
	sel := self selector.
	self emitMethodHeaderFor: sel on: stream.
	stream
		tab;
		nextPut: $^.
	self emit: aLiteralArray asStringOn: stream.
	source := stream contents.
	methodClass := self owningClass class.
	categories := Set with: self class viewResourceCategoryName.
	(methodClass whichCategoriesIncludeSelector: sel) do: [:each | categories add: each name].
	methodClass compile: source categories: categories!

browse
	^self edit!

edit
	"Invoke a suitable editor on the resource identified by the receiver."

	Tools.ViewComposer openOn: self!

editViewUsing: aMonadicBlock 
	| view | 
	view := self loadWithContext: UI.View desktop.
	aMonadicBlock value: view.
	self assign: view literalStoreArray.
	view destroy!

emit: aResourceArray asStringOn: aWriteStream 
	aWriteStream nextPutAll: '#('.
	aResourceArray do: [:each |  each literalPrintOn: aWriteStream. aWriteStream space].
	aWriteStream nextPut: $)!

prompt
	"Prompt for and answer a new ResourceIdentifier using the receiver to give the default settings."

	^(((self owningClass == UI.Presenter or: [self owningClass owningPackage isNil])
		ifTrue: [Smalltalk developmentSystem resourceIdentifierDialogClass]
		ifFalse: [Smalltalk developmentSystem packagedResourceIdentifierDialogClass]) createOn: self)
		showModal!

publishedAspects
	| answer |
	answer := super publishedAspects.
	self owningClass isBehavior
		ifTrue: 
			[answer add: (Tools.Aspect choice: #name
						from: (owningClass resourceIdentifiers collect: [:each | each name]) asSortedCollection)].
	^answer!

reassign
	| view |
	view := Smalltalk developmentSystem loadViewResource: self resource inContext: UI.View desktop.
	self assign: view literalStoreArray.
	view destroy! !
!UI.ResourceIdentifier categoriesFor: #assign:!accessing!public! !
!UI.ResourceIdentifier categoriesFor: #assignLiteralResourceData:!accessing!private! !
!UI.ResourceIdentifier categoriesFor: #browse!public! !
!UI.ResourceIdentifier categoriesFor: #edit!operations!public! !
!UI.ResourceIdentifier categoriesFor: #editViewUsing:!operations!public! !
!UI.ResourceIdentifier categoriesFor: #emit:asStringOn:!helpers!private! !
!UI.ResourceIdentifier categoriesFor: #prompt!operations!public! !
!UI.ResourceIdentifier categoriesFor: #publishedAspects!constants!public! !
!UI.ResourceIdentifier categoriesFor: #reassign!public! !

!UI.ResourceIdentifier class methodsFor!

prompt
	"Prompt for and answer a new ResourceIdentifier."

	^self new prompt!

publishedAspectsOfInstances
	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #owningClass);
		add: (Tools.Aspect string: #name);
		yourself! !
!UI.ResourceIdentifier class categoriesFor: #prompt!instance creation!public! !
!UI.ResourceIdentifier class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.RichTextEdit class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver.
    	Implementation Note: We remove some superclass aspects because ES_NUMBER 
    	style has no effect on RichEdit and neither do ES_CENTER or ES_RIGHT."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect richText: #text);
		removeKey: #format;
		removeKey: #alignment;
		yourself! !
!UI.RichTextEdit class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.RichTextPresenter class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #linkClicked:;
		yourself! !
!UI.RichTextPresenter class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.Scintilla.Attribute class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #id) beReadOnly;
		yourself! !
!UI.Scintilla.Attribute class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Scintilla.IndicatorStyle class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #forecolor);
		add: (Tools.Aspect color: #hoverForecolor);
		add: (Tools.Aspect choice: #style from: IndicatorStyles);
		add: (Tools.Aspect choice: #hoverStyle from: IndicatorStyles);
		add: (Tools.Aspect name: #name);
		add: (Tools.Aspect integer: #alpha);
		add: (Tools.Aspect integer: #foreAlpha);
		yourself! !
!UI.Scintilla.IndicatorStyle class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Scintilla.KeyBinding class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #commandSymbol from: Commands values asSortedCollection);
		add: (Tools.Aspect hotkey: #acceleratorKey);
		yourself! !
!UI.Scintilla.KeyBinding class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Scintilla.Margin class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #isSensitive);
		add: (Tools.Aspect choice: #type from: MarginTypes);
		add: (Tools.Aspect integer: #width);
		add: (Tools.Aspect integer: #mask);
		add: (Tools.Aspect choice: #cursorType from: CursorTypes values);
		add: (Tools.Aspect color: #backcolor);
		yourself! !
!UI.Scintilla.Margin class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Scintilla.MarkerDefinition class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #name);
		add: (Tools.Aspect choice: #glyphName from: self glyphNames , self visibleCharacterGlyphs);
		add: (Tools.Aspect color: #forecolor);
		add: (Tools.Aspect color: #backcolor);
		add: (Tools.Aspect integer: #alpha);
		add: (Tools.Aspect color: #selectionBackcolor);
		yourself! !
!UI.Scintilla.MarkerDefinition class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Scintilla.ScintillaView methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| createPresenter |
	createPresenter := 
			[:p :m |
			(StylesCollectionPresenter
				create: 'Developer view'
				in: p
				on: m)
				defaultStyle: (TextStyle new
							backcolor: self backcolor;
							font: self actualFont;
							yourself);
				normalStyle: (self styleNamed: #normal);
				yourself].
	^super publishedAspects
		add: (Tools.Aspect name: #textStyles presenterBlock: createPresenter) beImmutable;
		add: (Tools.Aspect name: #annotationStyles presenterBlock: createPresenter) beImmutable;
		yourself! !
!UI.Scintilla.ScintillaView categoriesFor: #publishedAspects!constants!public! !

!UI.Scintilla.ScintillaView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer choices |
	answer := super publishedAspectsOfInstances.
	answer
		removeKey: #format;
		removeKey: #alignment;
		add: (Tools.Aspect sequenceableCollection: #keyBindings addEvaluationFrom: {KeyBinding name , ' new'})
					beImmutable;
		add: (Tools.Aspect sequenceableCollection: #margins);
		add: (Tools.Aspect sequenceableCollection: #indicatorStyles
					addEvaluationFrom: {IndicatorStyle name , ' new'}) beImmutable;
		add: (Tools.Aspect sequenceableCollection: #markerDefinitions
					addEvaluationFrom: {MarkerDefinition name , ' new'}) beImmutable;
		add: (Tools.Aspect choice: #whitespaceVisibility from: self whitespaceVisibilityLevels);
		add: (Tools.Aspect dictionary: #braceChars) beImmutable;
		add: (Tools.Aspect choice: #lexer from: (self lexerLanguages copyWithout: nil) asSortedCollection);
		add: (Tools.Aspect choice: #foldMarkerStyle from: {nil} , self foldMarkerStyles asSortedCollection);
		add: (Tools.Aspect choice: #caretStyle from: self caretStyles asSortedCollection);
		add: (Tools.Aspect choice: #indentationGuides
					from: {nil} , self indentationGuideStyles asSortedCollection);
		add: (Tools.Aspect choice: #annotationMode from: self annotationModes);
		add: (Tools.Aspect choice: #wrapIndentMode from: self wrapIndentModes);
		add: (Tools.Aspect choice: #fontQuality from: self fontQualities);
		add: (Tools.Aspect choice: #multiPasteMode from: self multiPasteModes);
		add: (Tools.Aspect integer: #whitespaceMarkerSize);
		add: (Tools.Aspect choice: #tabDrawMode from: self tabDrawModes);
		add: (Tools.Aspect choice: #endOfLineMode from: self lineEndings);
		add: (Tools.Aspect choice: #tabDrawMode from: self tabDrawModes);
		add: (Tools.Aspect choice: #endOfLineAnnotationMode from: self annotationModes);
		yourself.
	choices := OrderedCollection with: 'nil'.
	(Styler allSubclasses reject: [:each | each isAbstract])
		do: [:each | choices add: each name , ' new'].
	answer add: (Tools.Aspect choice: #styler evaluationFrom: choices).
	#(#autoCompletionAcceptChars #autoCompletionCancelChars)
		do: [:each | answer add: (Tools.Aspect string: each)].
	#(#tabWidth #hoverTime #selectionAlpha #secondarySelectionAlpha #marginCount #currentLineFrameWidth)
		do: [:each | answer add: (Tools.Aspect integer: each)].
	#(#caretForecolor #callTipHighlightColor #whitespaceBackcolor #whitespaceForecolor #foldMarginColor #foldMarginHiColor #currentLineBackcolor)
		do: [:each | answer add: (Tools.Aspect color: each)].
	#(#canScrollPastEnd #isAutoCompletionCancelledAtStart #isAutoCompletionCaseInsensitive #isAutoCompletionCancelledWhenNoMatch #isAutoCompletionSingleMatchChosen #isAutoCompletionTruncating #isBraceHighlightingEnabled #isFoldingEnabled #hasVisibleLineEndings #isCurrentLineHighlighted #isAccessibilityEnabled)
		do: [:each | answer add: (Tools.Aspect boolean: each)].
	^answer!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		remove: #textOverflow;
		add: #charAdded:;
		add: #callTipClicked:;
		add: #hoverStart:;
		add: #hoverEnd:;
		add: #hotSpotClicked:;
		add: #hotSpotDoubleClicked:;
		add: #savePointLeft;
		add: #marginClicked:;
		add: #userList:selection:;
		add: #painted;
		add: #macroRecord:;
		add: #updateUI:;
		add: #zoomed;
		yourself! !
!UI.Scintilla.ScintillaView class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.Scintilla.ScintillaView class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.Scintilla.TextStyle class methodsFor!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol
		presenterBlock: 
			[:p :m |
			TextStylePresenter
				create: 'Developer view'
				in: p
				on: m])
			yourself!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	"Don't bother exposing the changeable style flag, since it doesn't work at present"
	#(#isItalic #isBold #isUnderlined #isBackcolorExtendedToEndOfLine #isHotspot #isInvisible)
		do: [:each | answer add: ((Tools.Aspect boolean: each)
						isNullable: true;
						yourself)].
	^answer
		add: (Tools.Aspect color: #forecolor);
		add: (Tools.Aspect color: #backcolor);
		add: (Tools.Aspect
					choice: #fontName
					from: Canvas forDesktop fontNames asSortedCollection
					andNil: nil);
		add: (Tools.Aspect number: #pointSize);
		add: (Tools.Aspect integer: #characterSet);
		add: (Tools.Aspect
					choice: #caseName
					from: self caseNames
					andNil: nil);
		add: (Tools.Aspect name: #name);
		add: (Tools.Aspect number: #weight);
		yourself! !
!UI.Scintilla.TextStyle class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!UI.Scintilla.TextStyle class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ScrollBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #pageSize);
		add: (Tools.Aspect name: #range);
		add: (Tools.Aspect boolean: #isTrackingContinuous);
		add: (Tools.Aspect boolean: #isVertical);
		yourself! !
!UI.ScrollBar class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ScrollingDecorator class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #isTrackingContinuous);
		add: (Tools.Aspect name: #lineExtent);
		removeKey: #layoutManager;
		yourself! !
!UI.ScrollingDecorator class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ScrollingDecoratorLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #shouldStretchToFit);
		yourself! !
!UI.ScrollingDecoratorLayout class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Shell class methodsFor!

registerAsToolWith: aSmalltalkSystem
    	"The receiver is being registered as a tool with aSmalltalkSystem. Perform any
    	additional registration operations here. Part of the <installableSystemTool>
    	protocol, and implemented at this level so that 3.0 tools can be installed
    	without amendment."
    
    	!

unregisterAsToolWith: aSmalltalkSystem
    	"The receiver is being unregistered as a tool with aSmalltalkSystem. Perform any
    	additional unregistration operations here. Part of the <installableSystemTool>
    	protocol, and implemented at this level so that 3.0 tools can be installed
    	without amendment."
    
    	! !
!UI.Shell class categoriesFor: #registerAsToolWith:!operations!public! !
!UI.Shell class categoriesFor: #unregisterAsToolWith:!operations!public! !

!UI.ShellView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	"This block is used for editing (with a double click inside the PAI) the maximum and
    	minimum extents. The values will toggle between nil and the current extent of the 
    	selected ShellView."

	| maxMinExtentEditBlock |
	maxMinExtentEditBlock := 
			[:p |
			p model value: (p model value isNil ifTrue: [p parentPresenter model value extent])].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect autostring: #caption);
		add: (Tools.Aspect boolean: #isResizable);
		add: (Tools.Aspect boolean: #hasSysMenu);
		add: (Tools.Aspect boolean: #hasCaption);
		add: (Tools.Aspect boolean: #isInitiallyCentered);
		add: (Tools.Aspect boolean: #hasMinimize);
		add: (Tools.Aspect boolean: #hasMaximize);
		add: (Tools.Aspect boolean: #isToolWindow);
		add: (Tools.Aspect boolean: #hasTaskbarIcon);
		add: (Tools.Aspect menuBar: #menuBar) beImmutable;
		add: (Tools.Aspect icon: #largeIcon);
		add: (Tools.Aspect icon: #smallIcon);
		add: ((Tools.Aspect name: #maxExtent editBlock: maxMinExtentEditBlock)
					beImmutable;
					beEditedInPlace;
					yourself);
		add: ((Tools.Aspect name: #minExtent editBlock: maxMinExtentEditBlock)
					beImmutable;
					beEditedInPlace;
					yourself);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #viewMinimized;
    		add: #viewActivated;
    		add: #captionChanged;
    		add: #aboutToDisplaySystemMenu:;
    		add: #positionChanged:;
    		add: #viewRestored;
    		add: #positionChanging:;
    		add: #viewDeactivated;
    		add: #closeRequested:;
    		yourself.
    ! !
!UI.ShellView class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.ShellView class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.Slider methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^super publishedAspects
		add: (Tools.Aspect choice: #tickStyle from: self applicableTickStyles keys asSortedCollection);
		yourself! !
!UI.Slider categoriesFor: #publishedAspects!constants!public! !

!UI.Slider class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects
		removeKey: #forecolor;
		add: (Tools.Aspect name: #range) beImmutable;
		add: (Tools.Aspect integer: #thumbLength).
	#(#pageSize #lineSize #selectionRange) do: [:each | aspects add: (Tools.Aspect name: each)].
	#(#hasAutoTicks #isVertical #hasTicks #hasToolTips)
		do: [:each | aspects add: (Tools.Aspect boolean: each)].
	^aspects! !
!UI.Slider class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.SpinButton methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	self isAutoSync
		ifTrue: 
			[aspects
				add: (Tools.Aspect boolean: #hasThousandsSeparators);
				add: (Tools.Aspect choice: #radix from: #(10 16))].
	^aspects! !
!UI.SpinButton categoriesFor: #publishedAspects!accessing!must strip!public! !

!UI.SpinButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #alignment from: AlignmentMap keys asSortedCollection);
		add: (Tools.Aspect boolean: #wantArrowKeys);
		add: (Tools.Aspect boolean: #isAutoSync);
		add: (Tools.Aspect boolean: #isVertical);
		add: (Tools.Aspect boolean: #hasHotTracking);
		add: (Tools.Aspect boolean: #isWraparound);
		add: (Tools.Aspect name: #range);
		add: (Tools.Aspect name: #buddy) beReadOnly;
		yourself!

publishedEventsOfInstances
    	"Answer a <Set> of <Symbol>s that names all the events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #nudge:;
    		yourself.
    ! !
!UI.SpinButton class categoriesFor: #publishedAspectsOfInstances!accessing!must strip!public! !
!UI.SpinButton class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.Splitter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#isTabStop #isGroupStop #isDragSource #isDropTarget #font #text)
		do: [:each | aspects removeKey: each].
	aspects add: (Tools.Aspect boolean: #hasFlatAppearance).
	^aspects! !
!UI.Splitter class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StaticBitmap class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect bitmap: #image);
		yourself! !
!UI.StaticBitmap class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StaticIcon class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect icon: #image);
		yourself! !
!UI.StaticIcon class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StaticRectangle class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #style from: StyleMap keys asSortedCollection);
		yourself! !
!UI.StaticRectangle class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StaticText class methodsFor!

applicableTypeConverterCategories
	"Answers a class category containing <typeConverter>s that can 
    	be used with the receiver"

	^super applicableTypeConverterCategories
		add: (ClassCategory name: 'MVP-Type Converters-Text');
		yourself!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect multilineString: #text);
		add: (Tools.Aspect choice: #alignment from: AlignmentMap keys asSortedCollection);
		removeKey: #value;
		yourself! !
!UI.StaticText class categoriesFor: #applicableTypeConverterCategories!constants!public! !
!UI.StaticText class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StaticView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #isSunken);
		yourself! !
!UI.StaticView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StatusBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #hasSizeGrip);
		add: (Tools.Aspect boolean: #hasToolTips);
		add: (Tools.Aspect sequenceableCollection: #items
					addEvaluationFrom: {'<1p> <2s>' expandMacrosWith: StatusBarItem with: #new}) beImmutable;
		yourself! !
!UI.StatusBar class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StatusBarItem class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect block: #getImageBlock);
		add: (Tools.Aspect block: #getTextBlock);
		yourself! !
!UI.StatusBarItem class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.StatusBarItemAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #borderStyle from: BorderStyles keys asSortedCollection);
		add: (Tools.Aspect integer: #width);
		add: (Tools.Aspect string: #name);
		yourself! !
!UI.StatusBarItemAbstract class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.TabView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer add: (Tools.Aspect choice: #tabOrientation from: TabOrientations values).
	#(#hasFlatSeparators #hasButtons #isMultiline)
		do: [:each | answer add: (Tools.Aspect boolean: each)].
	^answer! !
!UI.TabView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.TextEdit class methodsFor!

applicableTypeConverterCategories
	"Answers a class category containing <typeConverter>s that can 
    	be used with the receiver"

	^super applicableTypeConverterCategories
		add: (ClassCategory name: 'MVP-Type Converters-Text');
		yourself!

publishedAspectsOfInstances
	"Answer a Set of the aspects published by  instances of the receiver"

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects removeKey: #value.
	#(#canHScroll #isReadOnly #isStatic #isSelectionKept #updatePerChar #isFindEnabled)
		do: [:each | aspects add: (Tools.Aspect boolean: each)].
	^aspects
		add: (Tools.Aspect choice: #alignment from: AlignmentMap keys asSortedCollection);
		add: (Tools.Aspect choice: #format from: FormatMap keys asSortedCollection);
		add: (Tools.Aspect string: #cueBanner);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #textOverflow;
    		yourself.
    ! !
!UI.TextEdit class categoriesFor: #applicableTypeConverterCategories!constants!public! !
!UI.TextEdit class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.TextEdit class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.TimeToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect string: #format);
		yourself! !
!UI.TimeToText class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Toolbar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect rectangle: #insets);
		add: (Tools.Aspect extent: #buttonSize);
		add: (Tools.Aspect
					choice: #bitmapSize
					from: ##({16 @ 16. 20 @ 20. 24 @ 24. 32 @ 32. 40 @ 40. 48 @ 48. 64 @ 64})
					andNil: nil);
		add: (Tools.Aspect boolean: #hasFlatAppearance);
		add: (Tools.Aspect boolean: #hasListAppearance);
		add: (Tools.Aspect boolean: #hasLabels);
		add: (Tools.Aspect integer: #indent);
		add: (Tools.Aspect boolean: #canCustomize);
		add: (Tools.Aspect sequenceableCollection: #items
					addEvaluationFrom: ##({ToolbarIconButton.
							ToolbarBitmapButton.
							ToolbarSystemButton.
							ToolbarSeparator} collect: [:each | each name , ' new']))
						beImmutable;
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #dropDown:;
    		yourself.
    !

resource_Class_browser_tools
	"Answer the literal data from which the 'Class browser tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Class_browser_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 12 48399 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #newMethod 8 'New Method' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'NewMethod.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48399 48395 594 416 17 626 #historyForward 8 'Forward' 1 1 674 nil true 720 8 'HistoryForward.ico' 768 48395 48401 594 416 1 626 #newClass 8 'New Class' 1 1 674 nil true 720 8 'NewClass.ico' 768 48401 48397 594 416 5 626 #toggleShowFullNames 8 'Show Full Class Names' 1 1 674 nil true 720 8 'Namespace.ico' 768 48397 48393 594 416 17 626 #historyBack 8 'Back' 1 1 674 nil true 720 8 'HistoryBack.ico' 768 48393 48403 594 416 1 626 #toggleShowInheritedMethods 8 'Show Inherited Methods' 1 1 674 nil true 720 8 'ToggleLocalHierarchy.ico' 768 48403 34 7 1040 800 1245766 1 ##(UI.ToolbarSeparator) 416 1 960 608 880 1120 nil nil 1 nil nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 1362 361 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 179 12 0 0 35 0 0 0] 8 #() 1362 193 193 nil 27 )!

resource_Debugger_tools
	"Answer the literal data from which the 'Debugger tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Debugger_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 18 33891 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #restartFrame 8 'R&estart' 13545 1 1378630 2 ##(Graphics.TextTileIcon) $\x2B6E 8 'Cambria' nil nil nil nil 1 nil nil 33891 33887 594 416 1 626 #runToCursor 8 'Run to Cursor' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'RunToCursor.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 33887 33883 594 416 1 626 #stepOut 8 'Step Out' 1 1 770 nil true 816 8 'StepOut.ico' 864 33883 33879 594 416 1 626 #stepInto 8 'Step Into' 1 1 770 nil true 816 8 'StepInto.ico' 864 33879 33893 594 416 1 626 #returnFromMessage 8 'Retur&n ...' 1 1 674 $\x23CE 8 'Georgia' nil nil nil nil 1 nil nil 33893 33889 594 416 1 626 #resumeProcess 8 'Go' 1 1 770 nil true 816 8 'Run.ico' 864 33889 33885 594 416 1 626 #stepIntoBlock 8 'Step Into Block' 1 1 770 nil true 816 8 'StepIntoBlock.ico' 864 33885 33881 594 416 1 626 #stepOver 8 'Step Over' 1 1 770 nil true 816 8 'StepOver.ico' 864 33881 33877 594 416 1 626 #showNextStatement 8 'Show Next Statement' 1 1 770 nil true 816 8 'ShowNextStatement.ico' 864 33877 34 10 1376 976 1296 896 1216 720 1136 608 1056 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 1618 421 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 209 12 0 0 35 0 0 0] 8 #() 1618 193 193 nil 27 )!

resource_Image_tools
	"Answer the literal data from which the 'Image tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Image_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 2 48493 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #saveImage 8 'Save Image' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'Snapshot.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48493 34 2 608 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 962 63 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 30 12 0 0 35 0 0 0] 8 #() 962 193 193 nil 27 )!

resource_Resource_tools
	"Answer the literal data from which the 'Resource tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Resource_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 4 48453 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #clearSelection 8 'Delete Resource' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'EditClear.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48453 48451 594 416 1 626 #newView 8 'New View Resource' 1 1 674 nil true 720 8 'NewThing.ico' 768 48451 34 3 800 608 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 1042 111 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 54 12 0 0 35 0 0 0] 8 #() 1042 193 193 nil 27 )!

resource_Search_tools
	"Answer the literal data from which the 'Search tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Search_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil 852998 ##(Graphics.Font) nil true 721158 ##(OS.LOGFONTW) 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 0 0 0 0 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 918022 ##(Graphics.Point) 193 193 nil 416 nil 8 1801306032 170 192 34 2 410 ##(UI.ReferenceView) 34 14 nil 416 34 2 8 1140916224 131073 640 nil 917510 ##(Graphics.Color) #default nil 5 nil nil nil 640 1376838 1 ##(UI.ResourceIdentifier) ##(Tools.SmalltalkSearchPresenter) #resource_Default_view nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 562 1 5 562 371 37 640 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 2 0 0 0 185 0 0 0 20 0 0 0] 8 #() 562 193 193 nil 27 8 'search' 170 192 34 2 48517 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #goSearch 8 'Go Search' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'GoSearch.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48517 34 2 1056 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 375 nil nil nil nil 770 138 144 34 1 834 #createAt:extent: 34 2 562 6143 21 562 437 51 416 914 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 217 12 0 0 35 0 0 0] 34 1 640 976 nil 27 )!

resource_Smalltalk_tools
	"Answer the literal data from which the 'Smalltalk tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Smalltalk_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 22 48501 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #browseHierarchy 8 'Open Class Hierarchy Browser' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'ClassBrowserShell.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48501 48497 594 416 1 626 #openWorkspace 8 'Open Workspace' 1 1 674 nil true 720 8 'OpenWorkspace.ico' 768 48497 48515 594 416 17 626 #newIdeaSpace 8 'New Idea Space' 1 1 674 nil true 720 8 'IdeaSpaceShell.ico' 768 48515 48511 594 416 1 626 #showTranscript 8 'Show Transcript' 1 1 674 nil true 720 8 'TranscriptShell.ico' 768 48511 48507 594 416 1 626 #browseResources 8 'Open View Browser' 1 1 674 nil true 720 8 'ResourceBrowser.ico' 768 48507 48503 594 416 1 626 #browsePackages 8 'Open Package Browser' 1 1 674 nil true 720 8 'PackageBrowserShell.ico' 768 48503 48499 594 416 1 626 #browseSystem 8 'Open System Browser' 1 1 674 nil true 720 8 'SystemBrowserShell.ico' 768 48499 48495 594 416 1 626 #newWorkspace 8 'New Workspace' 1 1 674 nil true 720 8 'NewWorkspace.ico' 768 48495 48513 594 416 1 626 #inspectVisualObject 8 'Visual Object Finder' 1 1 674 nil true 720 8 'VisualObjectFinder.ico' 768 48513 48509 594 416 1 626 #openViewComposer 8 'Open View Composer' 1 1 674 nil true 720 8 'ViewComposer.ico' 768 48509 48505 594 416 1 626 #browseTests 8 'Open Test Browser' 1 1 674 nil true 720 8 'UnitTestPlugin.ico' 768 48505 34 12 1280 800 1200 608 1120 1520 1040 1440 960 1360 880 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil nil nil nil 852806 1 ##(UI.FlowLayout) 1 1 1 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 1794 553 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 19 13 0 0 35 0 0 0] 8 #() 1794 193 193 nil 27 )!

resource_View_composer_alignment_tools
	"Answer the literal data from which the 'View composer alignment tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_alignment_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 14 48467 1443398 1 ##(UI.ToolbarBitmapButton) 416 1 1377606 4 ##(UI.CommandDescription) #alignCenters nil 1 1 nil 48467 985158 3 ##(Graphics.Bitmap) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'VCBar.BMP' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil nil 7 918022 ##(Graphics.Point) 929 33 5 48463 594 416 1 626 #alignToGrid nil 1 1 nil 48463 672 1 48473 594 416 1 626 #alignMiddles nil 1 1 nil 48473 672 11 48469 594 416 1 626 #alignRights nil 1 1 nil 48469 672 7 48465 594 416 1 626 #alignLefts nil 1 1 nil 48465 672 3 48475 594 416 1 626 #alignBottoms nil 1 1 nil 48475 672 13 48471 594 416 1 626 #alignTops nil 1 1 nil 48471 672 9 34 8 816 912 608 880 976 848 944 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil 786 33 33 786 45 45 nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 786 6143 21 786 339 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 168 12 0 0 35 0 0 0] 8 #() 786 193 193 nil 27 )!

resource_View_composer_match_size_tools
	"Answer the literal data from which the 'View composer match size tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_match_size_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 8 48449 1443398 1 ##(UI.ToolbarBitmapButton) 416 1 1377606 4 ##(UI.CommandDescription) #matchSizes nil 1 1 nil 48449 985158 3 ##(Graphics.Bitmap) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'VCBar.BMP' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil nil 7 918022 ##(Graphics.Point) 929 33 21 48447 594 416 1 626 #matchHeights nil 1 1 nil 48447 672 19 48445 594 416 1 626 #sizeToGrid nil 1 1 nil 48445 672 17 48443 594 416 1 626 #matchWidths nil 1 1 nil 48443 672 15 34 5 880 848 816 608 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil 786 33 33 786 45 45 nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 786 6143 21 786 201 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 99 12 0 0 35 0 0 0] 8 #() 786 193 193 nil 27 )!

resource_View_composer_nudge_tools
	"Answer the literal data from which the 'View composer nudge tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_nudge_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 16 48489 1443398 1 ##(UI.ToolbarBitmapButton) 416 1 1377606 4 ##(UI.CommandDescription) #increaseWidth nil 1 1 nil 48489 985158 3 ##(Graphics.Bitmap) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'VCBar.BMP' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil nil 7 918022 ##(Graphics.Point) 929 33 55 48485 594 416 1 626 #increaseHeight nil 1 1 nil 48485 672 51 48481 594 416 1 626 #nudgeUp nil 1 1 nil 48481 672 45 48477 594 416 1 626 #nudgeLeft nil 1 1 nil 48477 672 49 48491 594 416 1 626 #decreaseWidth nil 1 1 nil 48491 672 57 48487 594 416 1 626 #decreaseHeight nil 1 1 nil 48487 672 53 48483 594 416 1 626 #nudgeDown nil 1 1 nil 48483 672 43 48479 594 416 1 626 #nudgeRight nil 1 1 nil 48479 672 47 34 10 880 1008 848 976 1245766 1 ##(UI.ToolbarSeparator) 416 1 816 944 608 912 1058 416 1 nil nil 1 nil 786 33 33 786 45 45 nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 786 6143 21 786 401 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 199 12 0 0 35 0 0 0] 8 #() 786 193 193 nil 27 )!

resource_View_composer_spacing_tools
	"Answer the literal data from which the 'View composer spacing tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_spacing_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 20 48421 1443398 1 ##(UI.ToolbarBitmapButton) 416 1 1377606 4 ##(UI.CommandDescription) #centerHorizontally nil 1 1 nil 48421 985158 3 ##(Graphics.Bitmap) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'VCBar.BMP' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil nil 7 918022 ##(Graphics.Point) 929 33 39 48417 594 416 1 626 #decreaseVerticalGaps nil 1 1 nil 48417 672 35 48413 594 416 1 626 #distributeVertically nil 1 1 nil 48413 672 31 48409 594 416 1 626 #decreaseHorizontalGaps nil 1 1 nil 48409 672 27 48405 594 416 1 626 #distributeHorizontally nil 1 1 nil 48405 672 23 48423 594 416 1 626 #centerVertically nil 1 1 nil 48423 672 41 48419 594 416 1 626 #removeVerticalGaps nil 1 1 nil 48419 672 37 48415 594 416 1 626 #increaseVerticalGaps nil 1 1 nil 48415 672 33 48411 594 416 1 626 #removeHorizontalGaps nil 1 1 nil 48411 672 29 48407 594 416 1 626 #increaseHorizontalGaps nil 1 1 nil 48407 672 25 34 12 912 1072 880 1040 1245766 1 ##(UI.ToolbarSeparator) 416 1 848 1008 816 976 608 944 1122 416 1 nil nil 1 nil 786 33 33 786 45 45 nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 786 6143 21 786 493 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 245 12 0 0 35 0 0 0] 8 #() 786 193 193 nil 27 )!

resource_View_composer_tools
	"Answer the literal data from which the 'View composer tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289036 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 8 48461 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #zBack 8 'Send to Back' 1 1 1378630 1 ##(Graphics.TextTileIcon) $\x23ED 8 'Georgia' nil 482 #menuHilight nil nil 3 nil nil 48461 48459 594 416 1 626 #zBackward 8 'Send Backward' 1 1 674 $\x25BC nil nil 720 nil nil 1 nil nil 48459 48457 594 416 1 626 #zForward 8 'Bring Forward' 1 1 674 $\x25B2 8 'Segoe UI' nil 720 nil nil 1 nil nil 48457 48455 594 416 1 626 #zFront 8 'Bring to Front' 1 1 674 $\x23EE 8 'Georgia' nil 720 nil nil 3 nil nil 48455 34 5 880 800 736 608 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil 918022 ##(Graphics.Point) 33 33 1010 45 45 nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 1010 6143 21 1010 1415 51 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 194 14 0 0 35 0 0 0] 8 #() 1010 193 193 nil 27 )!

resource_Workspace_tools
	"Answer the literal data from which the 'Workspace tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Workspace_tools)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.Toolbar) 34 25 nil nil 34 2 8 1409289164 131137 416 nil nil nil 517 nil nil nil 416 917510 ##(Graphics.Color) #default 8 1801306032 170 192 8 #() 170 192 34 10 48391 1311814 1 ##(UI.ToolbarIconButton) 416 1 1377606 4 ##(UI.CommandDescription) #debugIt 8 'Deb&ug It' 1 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'Debugger.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil 48391 48387 594 416 1 626 #evaluateIt 8 'Evaluate It' 1 1 674 nil true 720 8 'EvaluateIt.ico' 768 48387 48383 594 416 1 626 #displayIt 8 'Display It' 1 1 674 nil true 720 8 'DisplayIt.ico' 768 48383 48389 594 416 1 626 #inspectIt 8 'Inspect It' 1 1 674 nil true 720 8 'InspectIt.ico' 768 48389 48385 594 416 1 626 #printIt 8 'Print It' 1 1 674 nil true 720 8 'PrintIt.ico' 768 48385 34 6 880 1040 800 960 608 1245766 1 ##(UI.ToolbarSeparator) 416 1 nil nil 1 nil nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 1 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 918022 ##(Graphics.Point) 6143 21 1282 51 231 416 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 24 12 0 0 125 0 0 0] 8 #() 1282 193 193 nil 27 )! !
!UI.Toolbar class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.Toolbar class categoriesFor: #publishedEventsOfInstances!events!public! !
!UI.Toolbar class categoriesFor: #resource_Class_browser_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Debugger_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Image_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Resource_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Search_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Smalltalk_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_View_composer_alignment_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_View_composer_match_size_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_View_composer_nudge_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_View_composer_spacing_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_View_composer_tools!public!resources-views! !
!UI.Toolbar class categoriesFor: #resource_Workspace_tools!public!resources-views! !

!UI.ToolbarBitmapButton methodsFor!

publishedAspects
	| aspects |
	aspects := super publishedAspects.
	self bitmap
		ifNotNil: 
			[:bmp |
			aspects add: (Tools.Aspect choice: #bitmapIndex
						from: (0 to: bmp extent x // (self toolbar ifNil: [16] ifNotNil: [:tb | tb actualBitmapSize x])))].
	^aspects! !
!UI.ToolbarBitmapButton categoriesFor: #publishedAspects!constants!public! !

!UI.ToolbarBitmapButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect bitmap: #bitmap) beImmutable;
		yourself! !
!UI.ToolbarBitmapButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ToolbarButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #commandDescription);
		add: (Tools.Aspect boolean: #isCheckStyle);
		add: (Tools.Aspect boolean: #isGroupStyle);
		add: (Tools.Aspect boolean: #isDropdownStyle);
		add: (Tools.Aspect boolean: #isDropDownOnly);
		yourself! !
!UI.ToolbarButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ToolbarSeparator class methodsFor!

icon
	"Answers an Icon that can be used to represent this class."

	^##(TextTileIcon text: '|' color: Color face3d)!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect integer: #width);
		yourself! !
!UI.ToolbarSeparator class categoriesFor: #icon!constants!public! !
!UI.ToolbarSeparator class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ToolbarSystemButton methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| buttons |
	buttons := BitmapButtons at: self bitmapId ifAbsent: [StandardButtons].
	^super publishedAspects
		add: (Tools.Aspect
					choice: #bitmapIndex
					fromMap: buttons
					nullValue: nil);
		yourself! !
!UI.ToolbarSystemButton categoriesFor: #publishedAspects!public! !

!UI.ToolbarSystemButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect
					choice: #bitmapId
					fromMap: Bitmaps
					nullValue: nil);
		yourself! !
!UI.ToolbarSystemButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ToolButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect extent: #buttonSize);
		add: (Tools.Aspect extent: #bitmapSize);
		add: (Tools.Aspect boolean: #hasListAppearance);
		add: (Tools.Aspect boolean: #hasLabels);
		add: (Tools.Aspect name: #commandDescription) beImmutable;
		add: (Tools.Aspect boolean: #isCheckStyle);
		add: (Tools.Aspect boolean: #isGroupStyle);
		add: (Tools.Aspect boolean: #isDropdownStyle);
		add: (Tools.Aspect boolean: #isDropDownOnly);
		yourself
	"removeKey: #forecolor;"! !
!UI.ToolButton class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.Tooltip class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect color: #forecolor);
		add: (Tools.Aspect color: #backcolor);
		add: (Tools.Aspect font: #font);
		add: (Tools.Aspect integer: #maxWidth);
		add: (Tools.Aspect boolean: #isBalloon);
		add: (Tools.Aspect boolean: #alwaysTip);
		add: (Tools.Aspect integer: #showDuration);
		add: (Tools.Aspect integer: #showDelay);
		add: (Tools.Aspect integer: #reshowDelay);
		add: (Tools.Aspect name: #margins) beImmutable;
		yourself! !
!UI.Tooltip class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.TranscriptShell methodsFor!

help
	"Brings up a help page for the receiver"

	Tools.SmalltalkSystem current openHelpTopicForTool: self! !
!UI.TranscriptShell categoriesFor: #help!commands!public! !

!UI.TranscriptShell class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the aspects published by this class."

	^super publishedAspects
		add: (Tools.Aspect name: #defaultExtent);
		add: (Tools.Aspect boolean: #flashOnOutput);
		yourself!

resource_Scintilla_view
	"Answer the literal data from which the 'Scintilla view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Scintilla_view)
	"

	^#(#'!!STL' 4 985166 10 ##(UI.STBViewProxy) ##(UI.ShellView) 34 27 nil nil 8 #(13565952 65536) 416 nil 917510 ##(Graphics.Color) #default 918022 ##(Graphics.Point) 1079 655 517 nil nil nil 416 984838 ##(UI.BorderLayout) 1 1 nil nil nil nil 410 ##(UI.Scintilla.ScintillaView) 34 50 nil 416 34 2 8 1174470916 262145 560 918598 2 ##(UI.ValueHolder) nil false 1769478 ##(Kernel.EqualitySearchPolicy) nil nil nil 23 461638 4 ##(UI.Menu) nil true 34 8 1180742 2 ##(UI.CommandMenuItem) 1 1377606 4 ##(UI.CommandDescription) #copySelection 8 '&Copy' 9351 1 853318 3 ##(Graphics.Icon) nil true 2031622 ##(Kernel.ImageRelativeFileLocator) 8 'EditCopy.ico' 2490894 ##(Kernel.STBExternalResourceLibraryProxy) 8 'dolphindr7.dll' nil nil nil 738 1 770 #selectAll 8 'Select &All' 8323 1 nil nil nil 738 1 770 #clearAll 8 'Clea&r' 1 1 818 nil true 864 8 'ClearDocument.ico' 912 nil nil 1179974 1 ##(UI.DividerMenuItem) 4097 738 1 770 #find 8 '&Find...' 9357 1 818 nil true 864 8 'Find.ico' 912 nil nil 738 1 770 #findNext 8 'Find &Next' 1253 1 818 nil true 864 8 'FindNext.ico' 912 nil nil 1074 4097 690 nil true 34 5 738 1 770 #toggleIndentationGuides 8 'Indentation &Guides' 1 1 nil nil nil 738 1 770 #toggleLineEndings 8 'Line &Endings' 1 1 1378630 1 ##(Graphics.TextTileIcon) $¶ 8 'Arial' nil nil nil nil 1 nil nil nil nil 738 1 770 #toggleLineNumbers 8 'Line N&umbers' 1 1 nil nil nil 738 1 770 #toggleWhitespace 8 'W&hitespace' 1 1 nil nil nil 738 1 770 #toggleWordWrap 8 '&Word Wrap' 1 1 nil nil nil 8 '&Options' nil 134217729 818 nil true 864 8 'Preferences.ico' 912 nil nil nil nil 8 '&Edit' nil 134217729 nil nil nil nil nil nil nil 560 nil 8 2031697384 1049094 ##(UI.NullConverter) nil 8 '' 3 1848849585 170 192 34 10 #indentGuide 1444934 1 ##(UI.Scintilla.TextStyle) 75 466 #gray nil 1 nil nil nil nil #indentGuide 8 'Indentation guides, when visible' nil nil #whitespace 1762 53 466 #silver nil 1 nil nil nil nil #whitespace 8 'Whitespace, when visible' nil nil #lineNumber 1762 67 nil nil 1 nil 1601 nil nil #lineNumber nil nil nil #normal 1762 1 nil nil 1 nil nil nil nil #normal nil nil nil #callTip 1762 77 1792 466 #white 1 nil nil nil nil #callTip nil nil nil nil 1507654 1 ##(UI.Scintilla.NullStyler) #normal 170 192 34 2 #default 1903686 2 ##(UI.Scintilla.MarkerDefinition) nil nil nil nil 560 #circle nil nil nil nil nil nil 138 ##(Core.IdentitySet) 8 #() nil 170 176 2048 nil nil nil nil 466 #mediumSlateBlue 1840 nil nil nil nil nil nil nil 1 170 192 34 4 #text 170 192 34 10 #indentGuide 1776 #whitespace 1824 #lineNumber 1872 #normal 1888 #callTip 1904 #null 1728 nil nil nil nil 208 nil nil nil nil 170 192 34 6 #Notification 1762 7 nil 466 #gainsboro 1 nil nil nil nil #Notification nil nil nil #Warning 1762 5 466 #darkGoldenrod 466 #ivory 1 nil nil nil nil #Warning nil nil nil #Error 1762 3 466 #firebrick 466 #floralWhite 1 nil nil nil nil #Error nil nil nil nil 1310982 ##(Core.MessageSequence) 138 144 34 14 1049350 ##(Core.MessageSend) #createAt:extent: 34 2 498 1 1 498 1047 537 560 2386 #contextMenu: 34 1 704 560 2386 #caretForecolor: 34 1 466 #gray 560 2386 #caretPeriod: 8 #(0) 560 2386 #wordWrap: 8 #(true) 560 2386 #margins: 34 1 34 5 1247302 3 ##(UI.Scintilla.Margin) 1 560 1 3 nil nil nil nil 2658 3 560 1 nil nil 67108863 nil nil 2658 5 560 1 nil nil nil nil nil 2658 7 560 1 nil nil nil nil nil 2658 9 560 1 nil nil nil nil nil 560 2386 #canHScroll: 8 #(false) 560 2386 #tabWidth: 8 #(4) 560 2386 #targetRange: 34 1 852742 ##(Core.Interval) 1 -1 3 560 2386 #maxCompletionListHeight: 8 #(9) 560 2386 #edgeColumn: 8 #(1) 560 2386 #setLexerLanguage: 8 #(#null) 560 2386 #sciSetFontQuality: 8 #(3) 560 2386 #whitespaceMarkerSize: 8 #(2) 560 1179910 ##(OS.WINDOWPLACEMENT) 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 11 2 0 0 12 1 0 0] 8 #() 498 193 193 nil 31 170 192 34 2 560 8 'workspace' nil 658246 4 ##(UI.MenuBar) nil true 34 5 690 nil true 34 9 738 1 770 #fileNew 8 '&New Workspace' 9373 1 818 nil true 864 8 'NewWorkspace.ico' 912 nil nil 738 1 770 #fileOpen 8 '&Open Workspace...' 9375 1 818 nil true 864 8 'OpenWorkspace.ico' 912 nil nil 738 1 770 #fileFileIn 8 '&File In...' 1 1 nil nil nil 1074 4097 738 1 770 #saveImage 8 'Sa&ve Image' 1 1 818 nil true 864 8 'Snapshot.ico' 912 nil nil 738 1 770 #saveImageAs 8 'Save Image As...' 1 1 nil nil nil 738 1 770 #compressChanges 8 '&Compress Changes' 1 1 nil nil nil 1074 4097 738 1 770 #smalltalkExit 8 'E&xit Dolphin' 1 1 818 nil true 864 8 'PowerSwitch.ico' 912 nil nil 8 '&File' nil 134217729 nil nil 48353 nil nil 690 nil true 34 8 738 1 770 #cr 8 'New&line' 1 1 nil nil nil 1074 4097 738 1 770 #copySelection 8 '&Copy' 9351 1 818 nil true 864 8 'EditCopy.ico' 912 nil nil 738 1 770 #selectAll 8 'Select &All' 9347 1 nil nil nil 738 1 770 #clearAll 8 'Clea&r' 9393 1 818 nil true 864 8 'ClearDocument.ico' 912 nil nil 1074 4097 738 1 770 #editFind 8 '&Find...' 9357 1 818 nil true 864 8 'Find.ico' 912 nil nil 738 1 770 #findNext 8 'Find &Next' 1253 1 818 nil true 864 8 'FindNext.ico' 912 nil nil 8 '&Edit' nil 134217729 nil nil 48367 nil nil 690 nil true 8 #() 8 '&Tools' #toolsMenu 134217729 nil nil 48369 nil nil 690 nil true 8 #() 8 'Wi&ndow' #windowMenu 134217729 nil nil 48371 nil nil 690 nil true 34 6 738 1 770 #help 8 '&Help on this tool' 1249 1 818 nil true 864 8 'Help.ico' 912 nil nil 1074 4097 738 1 770 #guidedTour 8 '&Guided tour' 1 1 nil nil nil 738 1 770 #educationCenter 8 '&Education centre' 1 1 nil nil nil 1074 4097 738 1 770 #aboutDolphin 8 '&About Dolphin Smalltalk' 1 1 nil nil nil 8 '&Help' nil 134217729 nil nil 48381 nil nil 8 '' nil 134217729 nil nil nil nil nil nil nil nil 1 nil nil nil nil 1 nil nil 2322 138 144 34 2 2386 #createAt:extent: 34 2 498 6143 21 498 1079 655 416 2386 #text: 34 1 8 'System Transcript' 416 3042 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 26 14 0 0 81 1 0 0] 34 1 560 3104 nil 27 )! !
!UI.TranscriptShell class categoriesFor: #publishedAspects!public! !
!UI.TranscriptShell class categoriesFor: #resource_Scintilla_view!public!resources-views! !

!UI.TreeModelAbstract class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #itemUpdated:;
		add: #treeChanged:;
		add: #removingItem:;
		add: #item:movedToParent:;
		add: #item:removedFromParent:;
		add: #item:addedInParent:;
		yourself! !
!UI.TreeModelAbstract class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.TreeView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#hasLinesAtRoot #hasLines #hasButtons #canEditLabels #showsSelAlways #isMonoExpandable #hasInfoTips #hasCheckBoxes #isExpandAllEnabled #hasFullRowSelect)
		do: [:each | aspects add: (Tools.Aspect boolean: each)].
	aspects
		add: (Tools.Aspect integer: #indentSeparation);
		add: (Tools.Aspect choice: #updateMode from: UpdateModes);
		yourself.
	^aspects! !
!UI.TreeView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.TypeConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #leftNullValue);
		add: (Tools.Aspect name: #rightNullValue);
		yourself! !
!UI.TypeConverter class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ValueConverter class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		yourself.
    ! !
!UI.ValueConverter class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ValueConvertingControlView class methodsFor!

applicableTypeConverterCategories
	"Answers a Set of class categories that contain <typeConverter>s that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Type Converters-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| applicableTypeConverters |
	applicableTypeConverters := Set new.
	self applicableTypeConverterCategories do: [:each | applicableTypeConverters addAll: each classes].
	applicableTypeConverters := applicableTypeConverters asSortedCollection asArray
				collect: [:each | each name , ' new'].
	^super publishedAspectsOfInstances
		add: (Tools.Aspect choice: #typeconverter evaluationFrom: applicableTypeConverters) beImmutable;
		add: (Tools.Aspect name: #value);
		yourself! !
!UI.ValueConvertingControlView class categoriesFor: #applicableTypeConverterCategories!constants!public! !
!UI.ValueConvertingControlView class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!UI.ValueDialog class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !
!UI.ValueDialog class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ValueModel methodsFor!

debugPrintOn: aStream
	"Implementation Note: Since #value is used by #printOn:, we implement this to 
	allow us to debug #value, otherwise setting a breakpoint in #value results in a
	meltdown."

	self basicPrintOn: aStream! !
!UI.ValueModel categoriesFor: #debugPrintOn:!printing!public! !

!UI.ValueModel class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect name: #value);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !
!UI.ValueModel class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.ValueModel class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.ValuePresenter class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !
!UI.ValuePresenter class categoriesFor: #publishedEventsOfInstances!events!public! !

!UI.View methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #printOn: but some classes of object can use alternate display 
  	formats.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."
  
  	self printOn: aStream!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| aspects |
	aspects := super publishedAspects.
	self parentView
		ifNotNil: 
			[:parent |
			parent layoutManager ifNotNil: [:layoutManager | aspects add: layoutManager arrangementAspect].
			parent == View desktop ifFalse: [aspects add: (Tools.Aspect string: #name)]].
	^aspects!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self presenter! !
!UI.View categoriesFor: #aspectDisplayOn:!private! !
!UI.View categoriesFor: #publishedAspects!constants!public! !
!UI.View categoriesFor: #visualObjectAtPoint:!enquiries!private! !

!UI.View class methodsFor!

editNewDefaultView
	"Open the View Composer to create a new view for the receiver."

	| resourceIdentifier view resName |
	view := self desktop addSubView: self new.
	resName := Prompter
				on: self defaultView
				prompt: 'Resource name:'
				caption: 'Create a view for class ' , self name.
	resName isNil ifTrue: [^self].
	resourceIdentifier := ResourceIdentifier class: self name: resName.
	(resourceIdentifier resourceOrNil isNil or: 
			[MessageBox
				confirm: ('<1p> already exists. Do you wish to overwrite it?' expandMacrosWith: resourceIdentifier)])
		ifFalse: [^self].
	resourceIdentifier assign: view literalStoreArray.
	view destroy.
	Smalltalk developmentSystem openViewComposerOn: resourceIdentifier!

makeDefaultResource
	self makeResource: 'Default view' inClass: self!

makeResource: aStringName inClass: aClass
	"Private - Save and instance of the receiver as a default writable ViewResource 
	called aString owned by aClass."

	| resID view shell |
	shell := ShellView new create.
	view := shell addSubView: self new.
	(resID := ResourceIdentifier class: aClass name: aStringName) assign: view literalStoreArray.
	shell destroy.
	^resID!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#hasBorder #hasClientEdge #hasStaticEdge #usePreferredExtent #isTabStop #isGroupStop #isDragSource #isDropTarget #isTransparent #isEnabled #inheritContextMenu)
		do: [:each | aspects add: (Tools.Aspect boolean: each)].
	aspects
		add: (Tools.Aspect color: #backcolor);
		add: (Tools.Aspect menu: #contextMenu) beImmutable;
		add: (Tools.Aspect position: #position);
		add: (Tools.Aspect extent: #extent);
		add: (Tools.Aspect extent: #preferredExtent);
		add: (Tools.Aspect font: #font);
		add: ((Tools.Aspect autostring: #text)
					isNullable: false;
					yourself).
	^aspects!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
	^(super publishedEventsOfInstances)
    		add: #actionPerformed;
    		add: #drop:;
    		add: #dragOver:;
    		add: #viewDeactivated;
    		add: #dragEnter:;
    		add: #dragCut:;
    		add: #dragLeave:;
    		add: #focusLost;
    		add: #leftButtonDoubleClicked:;
    		add: #aboutToDisplayMenu:;
    		add: #focusGained;
    		add: #leftButtonPressed:;
    		add: #leftButtonReleased:;
    		add: #viewOpened;
    		add: #rightButtonDoubleClicked:;
    		add: #requestDragImages:;
    		add: #viewClosed;
    		add: #requestDropOperations:;
    		add: #rightButtonPressed:;
    		add: #positionChanged:;
    		add: #rightButtonReleased:;
    		add: #keyPressed:;
    		add: #drag:;
    		add: #keyReleased:;
    		add: #keyTyped:;
		add: #sysKeyPressed:;
		add: #sysKeyRelease:;
		add: #sysKeyTyped:;
		yourself! !
!UI.View class categoriesFor: #editNewDefaultView!operations!public! !
!UI.View class categoriesFor: #makeDefaultResource!operations!private! !
!UI.View class categoriesFor: #makeResource:inClass:!operations!private! !
!UI.View class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!UI.View class categoriesFor: #publishedEventsOfInstances!events!public! !

"End of package definition"!

