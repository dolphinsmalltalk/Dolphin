| package |
package := Package name: 'Development System'.
package paxVersion: 2.1;
	environmentName: #{Tools};
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk Development System.
    Copyright (c) Object Arts Ltd, 1997-2007. Portions Copyright (c) CGI Group (Europe) Ltd, 1997.
    
This package contains the basic/essential Dolphin Smalltalk development system tools and support, for example the Class, Method and Package browsers. 
'.

package basicPackageVersion: '2016.7.0.4'.


package setClassNames: #(
	#{Tools.AbstractClassHierarchyModel}
	#{Tools.AbstractPublishedAspectInspector}
	#{Tools.AllMethodsCategory}
	#{Tools.AnnotatedMethodSearch}
	#{Tools.AnonymousKeyedAspect}
	#{Tools.AnonymousKeyedAspectBatchAccessor}
	#{Tools.Aspect}
	#{Tools.AspectAccessor}
	#{Tools.AspectEditorDialog}
	#{Tools.AspectInspector}
	#{Tools.AstPlugin}
	#{Tools.BasicInspector}
	#{Tools.BasicKeyedAspect}
	#{Tools.BatchAspectAccessor}
	#{Tools.BrowserSemanticAnalyser}
	#{Tools.CategoryPrompter}
	#{Tools.CategoryTreeModel}
	#{Tools.ChangedMethodsCategory}
	#{Tools.ChooseClassDialog}
	#{Tools.ChooseNamespaceDialog}
	#{Tools.ClassAspectPlugin}
	#{Tools.ClassBrowserAbstract}
	#{Tools.ClassBrowserPlugin}
	#{Tools.ClassBrowserShell}
	#{Tools.ClassCommentPlugin}
	#{Tools.ClassHierarchyModel}
	#{Tools.ClassHierarchySelector}
	#{Tools.ClassListSelector}
	#{Tools.ClassParseContext}
	#{Tools.ClassSelector}
	#{Tools.CodeGenerationContext}
	#{Tools.CommandMenuItemDialog}
	#{Tools.CompiledMethodInspector}
	#{Tools.CompiledMethodSearchPolicy}
	#{Tools.CreateSubclassDialog}
	#{Tools.Debugger}
	#{Tools.DebuggerMethodCategory}
	#{Tools.DesignDesktopView}
	#{Tools.DevelopmentSessionManager}
	#{Tools.DictionaryInspector}
	#{Tools.Examples}
	#{Tools.FlipperInspector}
	#{Tools.Grabber}
	#{Tools.ImageListView}
	#{Tools.IndexedInstVarBatchAccessor}
	#{Tools.InspectorAbstract}
	#{Tools.InspectorShell}
	#{Tools.InstVarAspect}
	#{Tools.InstVarInspector}
	#{Tools.IntermediateCategory}
	#{Tools.InvalidInstallationError}
	#{Tools.KeyedAspect}
	#{Tools.KeyedAspectBatch}
	#{Tools.KeyedAspectBatchAccessor}
	#{Tools.MenuBarComposer}
	#{Tools.MenuBarPainter}
	#{Tools.MenuComposer}
	#{Tools.MenuComposerArena}
	#{Tools.MenuComposerView}
	#{Tools.MenuDialog}
	#{Tools.MenuItemDialog}
	#{Tools.MenuPainter}
	#{Tools.MessageNodeCollector}
	#{Tools.MethodBrowser}
	#{Tools.MethodBrowserShell}
	#{Tools.MethodCategorizationPolicy}
	#{Tools.MethodCategoryEnvironment}
	#{Tools.MethodExplorerShell}
	#{Tools.MethodParseContext}
	#{Tools.MethodPrivacyCategory}
	#{Tools.MethodSearch}
	#{Tools.MethodSourceSearch}
	#{Tools.MethodWorkspace}
	#{Tools.NamespaceHierarchyModel}
	#{Tools.PackageBrowserShell}
	#{Tools.PackageDependencyPresenter}
	#{Tools.PackageDependents}
	#{Tools.PackageFolder}
	#{Tools.PackageHierarchyModel}
	#{Tools.PackagePrerequisites}
	#{Tools.PackagePrompter}
	#{Tools.PackageSelector}
	#{Tools.PackedReferencesCategory}
	#{Tools.ParseContext}
	#{Tools.PluggableVirtualMethodCategory}
	#{Tools.PopupMenuPainter}
	#{Tools.PropertyInspector}
	#{Tools.PublishedAspectInspector}
	#{Tools.ReferencesCategory}
	#{Tools.ResourceBrowser}
	#{Tools.ResourceIdentifierDialog}
	#{Tools.ResourceListPresenter}
	#{Tools.ResourceToolboxPresenter}
	#{Tools.Scintilla}
	#{Tools.Scintilla.CharacterClassificationAspect}
	#{Tools.Scintilla.CharacterClassificationBatchAccessor}
	#{Tools.SequenceableCollectionInspector}
	#{Tools.SetBatchAspectAccessor}
	#{Tools.SingleChunkReader}
	#{Tools.SingleUnarySendMethodCategory}
	#{Tools.SmalltalkExpressionStyler}
	#{Tools.SmalltalkMethodStyler}
	#{Tools.SmalltalkSearchPresenter}
	#{Tools.SmalltalkStyler}
	#{Tools.SmalltalkStylingScanner}
	#{Tools.SmalltalkSystem}
	#{Tools.SmalltalkSystemFolder}
	#{Tools.SmalltalkSystemIcon}
	#{Tools.SmalltalkSystemShell}
	#{Tools.SmalltalkToolShell}
	#{Tools.SmalltalkWorkspace}
	#{Tools.SmalltalkWorkspaceDocument}
	#{Tools.SpecialReferencesCategory}
	#{Tools.StackFrameSlot}
	#{Tools.STBDebugger}
	#{Tools.STLDebugger}
	#{Tools.StructureInspector}
	#{Tools.STxDebugger}
	#{Tools.ThisContextSearch}
	#{Tools.TwinLevelInspector}
	#{Tools.UnclassifiedMethodsCategory}
	#{Tools.ValueWorkspace}
	#{Tools.ViewComposer}
	#{Tools.ViewComposerArena}
	#{Tools.VirtualMethodCategory}
	#{Tools.VisualObjectFinder}
	#{Tools.VisualShellFinder}
	#{Tools.WalkbackDialog}
).

package setMethodNames: #(
	#(#{Core.Array} #assignToResourceIdentifier:)
	#(#{Core.Array} #debugPrintOn:)
	#(#{Core.Association} #debugPrintOn:)
	#(#{Core.Bag class} #publishedAspectsOfInstances)
	#(#{Core.Behavior} #changedMethods)
	#(#{Core.Behavior} #hasAbstractMethods)
	#(#{Core.Behavior} #isAbstract)
	#(#{Core.Behavior} #methodFor:)
	#(#{Core.Behavior} #searchForInTool:)
	#(#{Core.Behavior} #whichClassDefinesInstVar:)
	#(#{Core.Behavior} #whichMethodsContainSource:)
	#(#{Core.Behavior} #whichMethodsOnlySelfSend:)
	#(#{Core.Behavior} #whichMethodsReferTo:)
	#(#{Core.Behavior} #whichSelectorsReferTo:)
	#(#{Core.Boolean} #literalTextStyle)
	#(#{Core.Boolean class} #newInstanceAspect:class:)
	#(#{Core.Category class} #icon)
	#(#{Core.Character} #literalTextStyle)
	#(#{Core.Class} #changeIndex)
	#(#{Core.Class} #changeIndexValue:)
	#(#{Core.Class} #isAbstract)
	#(#{Core.Class} #isChanged:)
	#(#{Core.Class} #isDeprecated)
	#(#{Core.Class} #isNonInstantiable:)
	#(#{Core.Class} #methodChanged:)
	#(#{Core.Class} #notifyPackageOfChange)
	#(#{Core.Class} #renameClassVar:to:)
	#(#{Core.ClassDescription} #browse)
	#(#{Core.ClassDescription} #categoriesFor:are:)
	#(#{Core.ClassDescription} #commentStamp:prior:)
	#(#{Core.ClassDescription} #copy:from:)
	#(#{Core.ClassDescription} #copy:from:categories:)
	#(#{Core.ClassDescription} #copy:from:classified:)
	#(#{Core.ClassDescription} #copyAll:from:)
	#(#{Core.ClassDescription} #copyAll:from:classified:)
	#(#{Core.ClassDescription} #copyAllCategoriesFrom:)
	#(#{Core.ClassDescription} #copyCategory:from:)
	#(#{Core.ClassDescription} #copyCategory:from:classified:)
	#(#{Core.ClassDescription} #isDeprecated)
	#(#{Core.ClassDescription} #isVisiblyAbstract)
	#(#{Core.ClassDescription} #methodsFor:)
	#(#{Core.ClassDescription} #methodsFor:stamp:)
	#(#{Core.ClassDescription} #model)
	#(#{Core.ClassDescription} #newInstanceAspect:class:)
	#(#{Core.ClassDescription} #parseContext)
	#(#{Core.ClassDescription} #privateMethods)
	#(#{Core.ClassDescription} #publicMethods)
	#(#{Core.ClassDescription} #renameInstVar:to:)
	#(#{Core.Collection} #aspectDisplayOn:)
	#(#{Core.Collection} #debugPrintOn:)
	#(#{Core.Collection} #newBatchAccessor)
	#(#{Core.Collection} #publishedAspects)
	#(#{Core.Collection} #publishedKeyedAspects)
	#(#{Core.Collection} #publishedKeyedAspectsBatchSize)
	#(#{Core.Collection class} #newInstanceAspect:class:)
	#(#{Core.Date class} #newInstanceAspect:class:)
	#(#{Core.Dictionary} #alternateInspectorClass)
	#(#{Core.Dictionary} #bestSlotFor:boundedBy:)
	#(#{Core.Dictionary} #debugPrintOn:)
	#(#{Core.Dictionary} #newBatchAccessor)
	#(#{Core.Dictionary} #printSelfEvaluatingOn:)
	#(#{Core.Dictionary} #publishedAspects)
	#(#{Core.Dictionary class} #newInstanceAspect:class:)
	#(#{Core.Duration} #debugPrintOn:)
	#(#{Core.Float class} #newInstanceAspect:class:)
	#(#{Core.Interval} #debugPrintOn:)
	#(#{Core.Interval} #newBatchAccessor)
	#(#{Core.LargeInteger} #debugPrintOn:)
	#(#{Core.LookupTable} #bestSlotFor:boundedBy:)
	#(#{Core.Metaclass} #changeIndex)
	#(#{Core.Metaclass} #isChanged:)
	#(#{Core.Metaclass} #isDeprecated)
	#(#{Core.Metaclass} #methodChanged:)
	#(#{Core.MethodCategory class} #all)
	#(#{Core.Number} #literalTextStyle)
	#(#{Core.Object} #alternateInspectorClass)
	#(#{Core.Object} #aspectDisplayOn:)
	#(#{Core.Object} #basicInspect)
	#(#{Core.Object} #browse)
	#(#{Core.Object} #currentPublishedAspectsAsLiteralsMap)
	#(#{Core.Object} #debugPrintOn:)
	#(#{Core.Object} #debugPrintString)
	#(#{Core.Object} #halt)
	#(#{Core.Object} #inspect)
	#(#{Core.Object} #inspectorClass)
	#(#{Core.Object} #newAspect:class:)
	#(#{Core.Object} #publicAccessorAspects)
	#(#{Core.Object} #publishedAspects)
	#(#{Core.Object} #publishedEvents)
	#(#{Core.Object} #searchForInTool:)
	#(#{Core.Object class} #publishedAspects)
	#(#{Core.Object class} #publishedAspectsOfInstances)
	#(#{Core.Object class} #publishedEvents)
	#(#{Core.Object class} #publishedEventsOfInstances)
	#(#{Core.Process} #attachDebugger:topFrame:resumable:)
	#(#{Core.Process} #debug)
	#(#{Core.Process} #debug:topFrame:resumable:)
	#(#{Core.Process} #debuggerClass)
	#(#{Core.Process} #halt:cause:)
	#(#{Core.Process} #primStep:)
	#(#{Core.Process} #showWalkback:callStack:debuggable:resumable:)
	#(#{Core.Process} #step)
	#(#{Core.Process} #step:)
	#(#{Core.Process} #walkback:topFrame:resumable:)
	#(#{Core.SearchPolicy class} #method)
	#(#{Core.Semaphore} #debugPrintOn:)
	#(#{Core.SequenceableCollection} #alternateInspectorClass)
	#(#{Core.SequenceableCollection} #newBatchAccessor)
	#(#{Core.SequenceableCollection class} #newInstanceAspect:class:)
	#(#{Core.SessionManager class} #publishedEventsOfInstances)
	#(#{Core.Set} #averageProbesPerElement)
	#(#{Core.Set} #bestSlotFor:boundedBy:)
	#(#{Core.Set} #collisions)
	#(#{Core.Set} #newBatchAccessor)
	#(#{Core.Set} #printOn:)
	#(#{Core.Set} #printSelfEvaluatingOn:)
	#(#{Core.Set} #sortSelfEvaluatingElements:locale:)
	#(#{Core.Set} #stats)
	#(#{Core.Set class} #newInstanceAspect:class:)
	#(#{Core.Stream} #debugPrint:)
	#(#{Core.String} #aspectDisplayOn:)
	#(#{Core.String} #debugPrintOn:)
	#(#{Core.String} #literalTextStyle)
	#(#{Core.String} #newAspect:class:)
	#(#{Core.String} #publishedAspects)
	#(#{Core.Symbol} #aspectDisplayOn:)
	#(#{Core.Symbol} #literalTextStyle)
	#(#{Core.Symbol} #searchForInTool:)
	#(#{Core.Symbol class} #newInstanceAspect:class:)
	#(#{Core.Time class} #newInstanceAspect:class:)
	#(#{Core.UndefinedObject} #aspectDisplayOn:)
	#(#{Core.UndefinedObject} #literalTextStyle)
	#(#{Core.WeakSet class} #publishedEventsOfInstances)
	#(#{External.AbstractCHARField} #characterCreationMessage)
	#(#{External.AbstractCHARField} #printAccessorExpression:on:)
	#(#{External.AbstractCHARField} #printMutatorValueOn:parameter:)
	#(#{External.ArrayField} #printAccessorExpressionSuffixOn:)
	#(#{External.ArrayField} #printElementSizeExpressionBodyOn:)
	#(#{External.ArrayField} #printFieldSizeExpressionBodyOn:)
	#(#{External.ArrayField} #printFieldSizeExpressionOn:)
	#(#{External.ArrayField} #printMutatorBody:on:)
	#(#{External.ArrayField} #printStaticElementSizeExpressionOn:)
	#(#{External.ArrayPointerField} #printAccessorExpressionSuffixOn:)
	#(#{External.ArrayPointerField} #printMutatorBody:on:)
	#(#{External.BOOLField} #newAspect:class:)
	#(#{External.BOOLField} #printAccessorExpressionSuffixOn:)
	#(#{External.BOOLField} #printMutatorValueOn:parameter:)
	#(#{External.BOOLField class} #icon)
	#(#{External.CHARField} #accessorMessage)
	#(#{External.CHARField} #characterCreationMessage)
	#(#{External.DOUBLE class} #newInstanceAspect:class:)
	#(#{External.DOUBLEField} #newAspect:class:)
	#(#{External.EmbeddedField} #printAccessorExpression:on:)
	#(#{External.EmbeddedField} #printStructClassSize:on:)
	#(#{External.ExternalArray} #printElement:on:)
	#(#{External.ExternalArray} #printElementsOn:)
	#(#{External.ExternalArray} #printEvaluationOn:)
	#(#{External.ExternalArray} #printOn:)
	#(#{External.ExternalArray} #publishedAspects)
	#(#{External.ExternalArray} #publishedKeyedAspects)
	#(#{External.ExternalArray} #publishedKeyedAspectsBatchSize)
	#(#{External.ExternalArray class} #newInstanceAspect:class:)
	#(#{External.ExternalArray class} #shouldOverrideGetFieldNames)
	#(#{External.ExternalMethod} #isSimpleSelfSend:)
	#(#{External.ExternalMethod class} #publishedAspectsOfInstances)
	#(#{External.Field} #autoGenCategories)
	#(#{External.Field} #autoGenComment)
	#(#{External.Field} #emitStaticExpression:on:)
	#(#{External.Field} #makeInstanceName:)
	#(#{External.Field} #printAccessor:on:)
	#(#{External.Field} #printAccessorBody:on:)
	#(#{External.Field} #printAccessorExpression:on:)
	#(#{External.Field} #printAccessorExpressionSuffixOn:)
	#(#{External.Field} #printMutator:on:)
	#(#{External.Field} #printMutatorBody:on:)
	#(#{External.Field} #printOffsetExpression:on:)
	#(#{External.Field} #printOffsetExpression:on:extra:)
	#(#{External.Field} #valueParameterName)
	#(#{External.FillerField} #printAccessorExpression:on:)
	#(#{External.FillerField} #printMutatorBody:on:)
	#(#{External.FLOAT class} #newInstanceAspect:class:)
	#(#{External.FLOATArray} #printElement:on:)
	#(#{External.FLOATField} #newAspect:class:)
	#(#{External.HANDLEField} #printAccessorExpressionSuffixOn:)
	#(#{External.INTEGER} #printOn:)
	#(#{External.INTEGER class} #newInstanceAspect:class:)
	#(#{External.IntegerBytes} #debugPrintOn:)
	#(#{External.IntegerBytes} #publishedKeyedAspects)
	#(#{External.IntegerBytes class} #newInstanceAspect:class:)
	#(#{External.LPVOIDField} #newAspect:class:)
	#(#{External.LPVOIDField} #printAccessorExpressionSuffixOn:)
	#(#{External.POINTArray} #printEvaluationOn:)
	#(#{External.PointerField} #printAccessorExpression:on:)
	#(#{External.PointerField} #printMutatorBody:on:)
	#(#{External.RECT} #printOn:)
	#(#{External.SCALAR class} #shouldOverrideGetFieldNames)
	#(#{External.ScalarField} #newAspect:class:)
	#(#{External.ScalarField} #printAccessorExpression:on:)
	#(#{External.ScalarField} #printMutatorBody:on:)
	#(#{External.ScalarField} #printMutatorValueOn:parameter:)
	#(#{External.ScalarField class} #icon)
	#(#{External.StringField} #printAccessorExpressionSuffixOn:)
	#(#{External.StringField} #printElementSizeExpressionBodyOn:)
	#(#{External.StringField} #printFieldSizeExpressionOn:)
	#(#{External.StringField} #printMutatorBody:on:)
	#(#{External.StringField} #printStaticElementSizeExpressionOn:)
	#(#{External.StringField class} #newInstanceAspect:class:)
	#(#{External.Structure} #alternateInspectorClass)
	#(#{External.Structure} #printableFields)
	#(#{External.Structure} #printFields:on:)
	#(#{External.Structure} #printFieldsOn:)
	#(#{External.Structure} #printOn:)
	#(#{External.Structure} #publishedAspects)
	#(#{External.Structure class} #autoGenCategory)
	#(#{External.Structure class} #compileAllDefinitions)
	#(#{External.Structure class} #compileByteSize)
	#(#{External.Structure class} #compileDefinition)
	#(#{External.Structure class} #compileGetFieldNames)
	#(#{External.Structure class} #compileGetMethod:forField:)
	#(#{External.Structure class} #compileNewFields)
	#(#{External.Structure class} #compileSetMethod:forField:)
	#(#{External.Structure class} #decompileDefinition)
	#(#{External.Structure class} #formatAndCompile:categories:)
	#(#{External.Structure class} #hasHandCodedMethodFor:)
	#(#{External.Structure class} #inheritsFieldNamed:)
	#(#{External.Structure class} #newCodeGenerationContext)
	#(#{External.Structure class} #recompileDefinition)
	#(#{External.Structure class} #shouldCompile:forField:named:)
	#(#{External.Structure class} #shouldOverrideGetFieldNames)
	#(#{External.StructureArrayField} #printAccessorExpressionSuffixOn:)
	#(#{External.StructureArrayField} #printElementSizeExpressionBodyOn:)
	#(#{External.StructureArrayPointerField} #printAccessorExpressionSuffixOn:)
	#(#{External.StructureField} #printMutatorBody:on:)
	#(#{External.StructurePointer} #printOn:)
	#(#{External.UInt64} #printOn:)
	#(#{External.WCHARField} #accessorMessage)
	#(#{External.WCHARField} #characterCreationMessage)
	#(#{Graphics.AbstractFont class} #newInstanceAspect:class:)
	#(#{Graphics.Bitmap class} #newInstanceAspect:class:)
	#(#{Graphics.Color class} #newInstanceAspect:class:)
	#(#{Graphics.Gdiplus.Image class} #newInstanceAspect:class:)
	#(#{Graphics.Gdiplus.ImageView class} #publishedAspectsOfInstances)
	#(#{Graphics.Icon class} #newInstanceAspect:class:)
	#(#{Graphics.Image class} #choose)
	#(#{Graphics.Image class} #fileTypes)
	#(#{Graphics.Image class} #newInstanceAspect:class:)
	#(#{Graphics.ImageList class} #newInstanceAspect:class:)
	#(#{Graphics.InternalIcon class} #choose)
	#(#{Graphics.Metafile class} #fileTypes)
	#(#{Graphics.Pen class} #publishedAspectsOfInstances)
	#(#{Graphics.Point class} #publishedAspectsOfInstances)
	#(#{Graphics.Point3D class} #publishedAspectsOfInstances)
	#(#{Graphics.Rectangle class} #publishedAspectsOfInstances)
	#(#{Graphics.TextTileIcon class} #newInstanceAspect:class:)
	#(#{Kernel.AbstractChunkSourceFiler class} #stlFilerClass)
	#(#{Kernel.BindingReference} #browse)
	#(#{Kernel.BlockClosure} #cpuCyclesToRun)
	#(#{Kernel.BlockClosure class} #publishedAspectsOfInstances)
	#(#{Kernel.BlockFrame} #debugIpFor:)
	#(#{Kernel.BlockFrame} #isRestartable)
	#(#{Kernel.BlockFrame} #makeDebug)
	#(#{Kernel.BlockFrame} #mapInitialIpFrom:to:)
	#(#{Kernel.ChunkSourceFiler} #printBasicDefinitionOfClass:)
	#(#{Kernel.ClassBuilder class} #publishedEventsOfInstances)
	#(#{Kernel.CompiledCode} #alternateInspectorClass)
	#(#{Kernel.CompiledCode} #asDebugMethod)
	#(#{Kernel.CompiledCode} #decodeHeaderOn:)
	#(#{Kernel.CompiledCode} #disassembly)
	#(#{Kernel.CompiledCode} #hasCompilationIssues)
	#(#{Kernel.CompiledCode} #indexOfIP:)
	#(#{Kernel.CompiledCode} #isAbstract)
	#(#{Kernel.CompiledCode} #isDeprecated)
	#(#{Kernel.CompiledCode} #isSimpleSelfSend:)
	#(#{Kernel.CompiledCode} #mapIp:toDebug:)
	#(#{Kernel.CompiledCode} #mapIP:toDebug:)
	#(#{Kernel.CompiledCode} #parseContext)
	#(#{Kernel.CompiledCode} #stylerClass)
	#(#{Kernel.CompiledCode class} #publishedAspectsOfInstances)
	#(#{Kernel.CompiledExpression} #asDebugMethod)
	#(#{Kernel.CompiledExpression} #stylerClass)
	#(#{Kernel.CompiledMethod} #asDebugMethod)
	#(#{Kernel.CompiledMethod} #browse)
	#(#{Kernel.CompiledMethod} #icon)
	#(#{Kernel.CompiledMethod} #infoTip)
	#(#{Kernel.CompiledMethod} #searchForInTool:)
	#(#{Kernel.CompiledMethod} #stylerClass)
	#(#{Kernel.CompiledMethod class} #overriddenIcon)
	#(#{Kernel.CompiledMethod class} #publishedAspectsOfInstances)
	#(#{Kernel.CompileFailedMethod} #asDebugMethod)
	#(#{Kernel.CompilerNotification} #okToContinue)
	#(#{Kernel.InputState class} #publishedEventsOfInstances)
	#(#{Kernel.MethodAnnotations} #aspectDisplayOn:)
	#(#{Kernel.MethodProtocol} #icon)
	#(#{Kernel.MethodProtocol class} #ansiIcon)
	#(#{Kernel.MethodProtocol class} #isValidProtocolName:)
	#(#{Kernel.MethodProtocol class} #publishedEventsOfInstances)
	#(#{Kernel.MethodProtocol class} #readOnlyIcon)
	#(#{Kernel.Namespace class} #isAbstract)
	#(#{Kernel.Namespace class} #isVisiblyAbstract)
	#(#{Kernel.Namespace class} #newInstanceAspect:class:)
	#(#{Kernel.Namespace class} #publishedAspects)
	#(#{Kernel.Namespace class} #publishedKeyedAspects)
	#(#{Kernel.Package} #aboutBlock:)
	#(#{Kernel.Package} #browse)
	#(#{Kernel.Package} #defaultAbout)
	#(#{Kernel.Package} #defaultAboutBitmap)
	#(#{Kernel.Package} #fileLocator)
	#(#{Kernel.Package} #icon)
	#(#{Kernel.Package} #publishedAspects)
	#(#{Kernel.Package} #searchForInTool:)
	#(#{Kernel.Package} #toggleLegacySourceFormat)
	#(#{Kernel.Package} #toggleUsingPAX)
	#(#{Kernel.Package class} #changedIcon)
	#(#{Kernel.Package class} #dolphinPackageIcon)
	#(#{Kernel.Package class} #publishedAspectsOfInstances)
	#(#{Kernel.Package class} #publishedEventsOfInstances)
	#(#{Kernel.PackageManager} #sourceControl)
	#(#{Kernel.PackageManager class} #publishedEventsOfInstances)
	#(#{Kernel.ProcessorScheduler} #singleStep:)
	#(#{Kernel.ProtoObject} #basicInspect)
	#(#{Kernel.ProtoObject} #debugPrintString)
	#(#{Kernel.ProtoObject} #halt)
	#(#{Kernel.ProtoObject} #inspect)
	#(#{Kernel.ProtoObject class} #icon)
	#(#{Kernel.ProtoObject class} #publishedAspects)
	#(#{Kernel.ProtoObject class} #publishedAspectsOfInstances)
	#(#{Kernel.SharedPool class} #canModifyBinding:newValue:)
	#(#{Kernel.SharedPool class} #isVisiblyAbstract)
	#(#{Kernel.SharedPool class} #referencesTo:)
	#(#{Kernel.SourceFiler} #emitResourceMethod:literals:)
	#(#{Kernel.SourceFiler} #emitResourceMethodHeader:)
	#(#{Kernel.StackFrame} #canReturn)
	#(#{Kernel.StackFrame} #debugIpFor:)
	#(#{Kernel.StackFrame} #debugPrintOn:)
	#(#{Kernel.StackFrame} #isRestartable)
	#(#{Kernel.StackFrame} #makeDebug)
	#(#{Kernel.StackFrame} #stackWorkspace)
	#(#{Kernel.StackFrame class} #publishedAspectsOfInstances)
	#(#{Kernel.StArgumentVariable} #category)
	#(#{Kernel.StArgumentVariable class} #icon)
	#(#{Kernel.StAssignmentNode} #displayOn:)
	#(#{Kernel.StBasicVariableNode} #shortName)
	#(#{Kernel.StBlockNode} #displayOn:)
	#(#{Kernel.StBlockScope} #category)
	#(#{Kernel.StCascadeNode} #displayOn:)
	#(#{Kernel.StClassScope} #category)
	#(#{Kernel.StClassScope} #isVisibleSelector:)
	#(#{Kernel.StEvalScope} #category)
	#(#{Kernel.StGeneratedTempVariable} #category)
	#(#{Kernel.StGeneratedTempVariable class} #icon)
	#(#{Kernel.StInstanceVariable} #classification)
	#(#{Kernel.StInstanceVariable} #icon)
	#(#{Kernel.StInstanceVariable} #iconInFrame:)
	#(#{Kernel.StInstanceVariable} #printDescriptionOn:)
	#(#{Kernel.StInstanceVariable} #printInfoTipOn:frame:)
	#(#{Kernel.StInstanceVariable} #valueClass:)
	#(#{Kernel.StInstanceVariable} #valueInFrame:)
	#(#{Kernel.StInstanceVariable class} #icon)
	#(#{Kernel.StLiteralArrayNode} #displayOn:)
	#(#{Kernel.StLiteralByteArrayNode} #displayOn:)
	#(#{Kernel.StLiteralSymbolToken} #textStyle)
	#(#{Kernel.StLiteralToken} #textStyle)
	#(#{Kernel.StLiteralValueNode} #displayOn:)
	#(#{Kernel.StLocalVariable} #category)
	#(#{Kernel.StLocalVariable} #classification)
	#(#{Kernel.StLocalVariable} #debugInfoInFrame:)
	#(#{Kernel.StLocalVariable} #printDescriptionOn:)
	#(#{Kernel.StLocalVariable} #printInfoTipOn:frame:)
	#(#{Kernel.StLocalVariable} #valueClass:)
	#(#{Kernel.StMessageNode} #displayOn:)
	#(#{Kernel.StMethodScope} #category)
	#(#{Kernel.StNumberLiteralToken} #textStyle)
	#(#{Kernel.StOptimizedBlockScope} #category)
	#(#{Kernel.StOptimizedNode} #displayOn:)
	#(#{Kernel.StParameterNode} #displayOn:)
	#(#{Kernel.StParameterNode class} #icon)
	#(#{Kernel.StPrimitiveNode} #displayOn:)
	#(#{Kernel.StProgramNode} #debugPrintOn:)
	#(#{Kernel.StProgramNode} #postComments)
	#(#{Kernel.StProgramNode} #preComments)
	#(#{Kernel.StProgramNode} #publishedAspects)
	#(#{Kernel.StReturnNode} #displayOn:)
	#(#{Kernel.StSelfVariable} #printDescriptionOn:)
	#(#{Kernel.StSelfVariable} #printInfoTipOn:frame:)
	#(#{Kernel.StSelfVariable} #valueClass)
	#(#{Kernel.StSelfVariable} #valueClass:)
	#(#{Kernel.StSelfVariable class} #icon)
	#(#{Kernel.StSelfVariableNode} #valueClassIn:)
	#(#{Kernel.StSelfVariableNode class} #icon)
	#(#{Kernel.StSemanticScope} #category)
	#(#{Kernel.StSequenceNode} #displayOn:)
	#(#{Kernel.StSpecialVariable} #classification)
	#(#{Kernel.StSpecialVariableNode} #displayOn:)
	#(#{Kernel.StSpecialVariableNode} #valueClassIn:)
	#(#{Kernel.StStaticVariable} #classification)
	#(#{Kernel.StStaticVariable} #displayOn:)
	#(#{Kernel.StStaticVariable} #printDescriptionOn:)
	#(#{Kernel.StStaticVariable} #printInfoTipOn:)
	#(#{Kernel.StStaticVariable} #staticValueClass)
	#(#{Kernel.StStaticVariable} #valueClass)
	#(#{Kernel.StStaticVariable class} #icon)
	#(#{Kernel.StSuperVariable} #printDescriptionOn:)
	#(#{Kernel.StSuperVariable} #valueClass)
	#(#{Kernel.StSuperVariable} #valueClass:)
	#(#{Kernel.StSuperVariable class} #icon)
	#(#{Kernel.StSuperVariableNode} #valueClassIn:)
	#(#{Kernel.StSuperVariableNode class} #icon)
	#(#{Kernel.StTempDeclNode} #displayOn:)
	#(#{Kernel.StTempDeclNode class} #icon)
	#(#{Kernel.StTempVariable} #category)
	#(#{Kernel.StTempVariable class} #icon)
	#(#{Kernel.StThisContextVariable} #valueClass)
	#(#{Kernel.StThisContextVariable class} #icon)
	#(#{Kernel.StThisContextVariableNode} #valueClassIn:)
	#(#{Kernel.StThisContextVariableNode class} #icon)
	#(#{Kernel.StToken} #postComments)
	#(#{Kernel.StToken} #preComments)
	#(#{Kernel.StVariable} #classification)
	#(#{Kernel.StVariable} #description)
	#(#{Kernel.StVariable} #displayOn:)
	#(#{Kernel.StVariable} #iconInFrame:)
	#(#{Kernel.StVariable} #infoTip)
	#(#{Kernel.StVariable} #infoTip:)
	#(#{Kernel.StVariable} #printDescriptionOn:)
	#(#{Kernel.StVariable} #printInfoTipOn:)
	#(#{Kernel.StVariable} #printInfoTipOn:frame:)
	#(#{Kernel.StVariable} #staticValueClass)
	#(#{Kernel.StVariable} #valueClass)
	#(#{Kernel.StVariable} #valueClass:)
	#(#{Kernel.StVariable class} #icon)
	#(#{Kernel.StVariableNode} #displayOn:)
	#(#{Kernel.StVariableNode} #shortName)
	#(#{Kernel.StVariableNode class} #icon)
	#(#{Kernel.StWorkspaceVariable} #classification)
	#(#{Kernel.StWorkspaceVariable} #printDescriptionOn:)
	#(#{Kernel.StWorkspaceVariable} #staticValueClass)
	#(#{Kernel.StWorkspaceVariable class} #icon)
	#(#{OS._FPIEEE_RECORD} #printFieldsOn:)
	#(#{OS._FPIEEE_VALUE} #printFieldsOn:)
	#(#{OS.FILETIME} #printOn:)
	#(#{OS.KernelLibrary} #queryThreadCycleTime:cycleTime:)
	#(#{OS.LOGBRUSH} #printFieldsOn:)
	#(#{OS.LOGPEN} #printFieldsOn:)
	#(#{OS.LVITEMW} #printableFields)
	#(#{OS.MSG} #printOn:)
	#(#{OS.PALETTEENTRY} #printFields:on:)
	#(#{OS.PrintDialogStructure} #printableFields)
	#(#{OS.PRINTDLGEXW} #printableFields)
	#(#{OS.RegKeyAbstract} #debugPrintOn:)
	#(#{OS.RGBQUAD} #printFields:on:)
	#(#{OS.SYSTEMTIME} #printOn:)
	#(#{OS.TVITEMW} #printableFields)
	#(#{OS.VersionInfo class} #publishedAspectsOfInstances)
	#(#{OS.VS_FIXEDFILEINFO class} #publishedAspectsOfInstances)
	#(#{OS.WINDOWPOS} #printOn:)
	#(#{Refactory.Browser.BrowserEnvironment} #allMethods)
	#(#{Refactory.Browser.BrowserEnvironment} #allResourcesDo:)
	#(#{Refactory.Browser.BrowserEnvironment} #allSelectorsImplemented)
	#(#{Refactory.Browser.BrowserEnvironment} #allSelectorsSent)
	#(#{Refactory.Browser.BrowserEnvironment} #browse)
	#(#{Refactory.Browser.BrowserEnvironment} #definitionsOf:)
	#(#{Refactory.Browser.BrowserEnvironment} #forClassHierarchyFrom:)
	#(#{Refactory.Browser.BrowserEnvironment} #forClassHierarchyTo:)
	#(#{Refactory.Browser.BrowserEnvironment} #forMethodCategories:)
	#(#{Refactory.Browser.BrowserEnvironment} #forPackagesClosure:)
	#(#{Refactory.Browser.BrowserEnvironment} #includesMethod:)
	#(#{Refactory.Browser.BrowserEnvironment} #includesMethodUncached:)
	#(#{Refactory.Browser.BrowserEnvironment} #liveReferencesTo:)
	#(#{Refactory.Browser.BrowserEnvironment} #openEditor)
	#(#{Refactory.Browser.BrowserEnvironment} #referencesToBinding:)
	#(#{Refactory.Browser.BrowserEnvironment} #referencesToLiteral:)
	#(#{Refactory.Browser.BrowserEnvironment} #search)
	#(#{Refactory.Browser.BrowserEnvironment} #search:)
	#(#{Refactory.Browser.BrowserEnvironment} #subEnvironmentLabel:for:)
	#(#{Refactory.Browser.BrowserEnvironment} #unimplementedSelectors)
	#(#{Refactory.Browser.BrowserEnvironmentWrapper} #includesResource:)
	#(#{Refactory.Browser.BrowserEnvironmentWrapper} #openEditor)
	#(#{Refactory.Browser.ClassDetails class} #icon)
	#(#{Refactory.Browser.ClassEnvironment} #includesResource:)
	#(#{Refactory.Browser.RBAbstractClass} #parseContext)
	#(#{Refactory.Browser.RBConfigurableFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RBFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RBMethod} #parseContext)
	#(#{Refactory.Browser.RBMethod class} #publishedAspectsOfInstances)
	#(#{Refactory.Browser.RBModel} #defaultParseContext)
	#(#{Refactory.Browser.RBSourceFormatter class} #publishedAspects)
	#(#{Refactory.Browser.RefactoryChange} #displayOn:)
	#(#{Refactory.Browser.SelectorEnvironment} #addMethods:)
	#(#{Refactory.Browser.SelectorEnvironment} #openEditor)
	#(#{Refactory.Browser.VariableEnvironment} #includesMethodUncached:)
	#(#{Refactory.Browser.VariableEnvironment} #updateCachesForMethod:)
	#(#{Smalltalk class} #publishedEvents)
	#(#{Smalltalk class} #renameVariable:to:)
	#(#{Smalltalk.StyledGradientBrush class} #publishedAspectsOfInstances)
	#(#{Smalltalk.StyledPen class} #publishedAspectsOfInstances)
	#(#{UI.AbstractCardContainer class} #publishedAspectsOfInstances)
	#(#{UI.AbstractCardContainer class} #publishedEventsOfInstances)
	#(#{UI.AbstractDocumentShell} #saveStateOn:)
	#(#{UI.AbstractToTextConverter class} #publishedAspectsOfInstances)
	#(#{UI.AXControlSite class} #publishedAspectsOfInstances)
	#(#{UI.AXValueConvertingControlSite class} #publishedAspectsOfInstances)
	#(#{UI.BasicListAbstract class} #publishedAspectsOfInstances)
	#(#{UI.BooleanToText class} #publishedAspectsOfInstances)
	#(#{UI.BorderLayout} #arrangementAspect)
	#(#{UI.BorderLayout class} #publishedAspectsOfInstances)
	#(#{UI.CardContainer class} #publishedAspectsOfInstances)
	#(#{UI.CardContainer class} #publishedEventsOfInstances)
	#(#{UI.CardLabel class} #publishedAspectsOfInstances)
	#(#{UI.CardLayout class} #publishedEventsOfInstances)
	#(#{UI.CheckBox class} #publishedAspectsOfInstances)
	#(#{UI.CheckButton class} #publishedAspectsOfInstances)
	#(#{UI.ColorView class} #publishedAspectsOfInstances)
	#(#{UI.ComboBox} #visualObjectAtPoint:)
	#(#{UI.ComboBox class} #publishedAspectsOfInstances)
	#(#{UI.CommandDescription} #commandString:)
	#(#{UI.CommandDescription class} #publishedAspectsOfInstances)
	#(#{UI.CommandMenuItem} #commandString:)
	#(#{UI.CommandMenuItem} #edit)
	#(#{UI.CommandMenuItem class} #publishedAspectsOfInstances)
	#(#{UI.ContainerView class} #applicableLayoutManagerCategories)
	#(#{UI.ContainerView class} #publishedAspectsOfInstances)
	#(#{UI.ControlBarAbstract class} #applicableLayoutManagerCategories)
	#(#{UI.ControlBarAbstract class} #publishedAspectsOfInstances)
	#(#{UI.ControlView class} #publishedAspectsOfInstances)
	#(#{UI.DateTimeCommonControl} #publishedAspects)
	#(#{UI.DateTimePicker class} #publishedAspectsOfInstances)
	#(#{UI.DateToText class} #publishedAspectsOfInstances)
	#(#{UI.FlowLayout class} #publishedAspectsOfInstances)
	#(#{UI.FontView class} #publishedAspectsOfInstances)
	#(#{UI.FramingCalculation class} #allCalculations)
	#(#{UI.FramingConstraints class} #calculationNames:except:)
	#(#{UI.FramingConstraints class} #publishedAspectsOfInstances)
	#(#{UI.FramingLayout} #arrangementAspect)
	#(#{UI.FramingLayout class} #example1)
	#(#{UI.GridLayout class} #publishedAspectsOfInstances)
	#(#{UI.GroupBox class} #publishedAspectsOfInstances)
	#(#{UI.HotKey class} #publishedAspectsOfInstances)
	#(#{UI.IconicListAbstract class} #publishedAspectsOfInstances)
	#(#{UI.IconicListAbstract class} #publishedEventsOfInstances)
	#(#{UI.ImagePresenter class} #resource_ImageList_view)
	#(#{UI.ImageViewAbstract class} #publishedAspectsOfInstances)
	#(#{UI.LayoutManager} #arrangementAspect)
	#(#{UI.ListBox class} #publishedAspectsOfInstances)
	#(#{UI.ListControlView} #visualObjectAtPoint:)
	#(#{UI.ListControlView class} #publishedAspectsOfInstances)
	#(#{UI.ListControlView class} #publishedEventsOfInstances)
	#(#{UI.ListModel class} #publishedEventsOfInstances)
	#(#{UI.ListTreeView class} #publishedAspectsOfInstances)
	#(#{UI.ListTreeView class} #publishedEventsOfInstances)
	#(#{UI.ListView class} #publishedAspectsOfInstances)
	#(#{UI.ListView class} #publishedEventsOfInstances)
	#(#{UI.ListViewColumn class} #publishedAspectsOfInstances)
	#(#{UI.Menu} #edit)
	#(#{UI.Menu} #painterClass)
	#(#{UI.Menu class} #publishedAspectsOfInstances)
	#(#{UI.MenuBar} #painterClass)
	#(#{UI.MenuBar class} #newInstanceAspect:class:)
	#(#{UI.MenuBar class} #publishedAspectsOfInstances)
	#(#{UI.MenuItem class} #icon)
	#(#{UI.MoenTreeView} #visualObjectAtPoint:)
	#(#{UI.MoenTreeView class} #publishedAspectsOfInstances)
	#(#{UI.MoenTreeView class} #publishedEventsOfInstances)
	#(#{UI.MonthCalendarView class} #publishedAspectsOfInstances)
	#(#{UI.MultilineTextEdit class} #publishedAspectsOfInstances)
	#(#{UI.PluggableTypeConverter class} #publishedAspectsOfInstances)
	#(#{UI.Presenter} #systemModel)
	#(#{UI.Presenter class} #addView:asResource:)
	#(#{UI.Presenter class} #defaultAcceleratorKeyBindings)
	#(#{UI.Presenter class} #editNewDefaultView)
	#(#{UI.ProgressBar class} #publishedAspectsOfInstances)
	#(#{UI.ProportionalLayout} #arrangementAspect)
	#(#{UI.ProportionalLayout class} #publishedAspectsOfInstances)
	#(#{UI.PushButton class} #publishedAspectsOfInstances)
	#(#{UI.ReferenceView} #visualObjectAtPoint:)
	#(#{UI.ReferenceView class} #publishedAspectsOfInstances)
	#(#{UI.ResourceIdentifier} #assign:)
	#(#{UI.ResourceIdentifier} #assignLiteralResourceData:)
	#(#{UI.ResourceIdentifier} #assignView:)
	#(#{UI.ResourceIdentifier} #browse)
	#(#{UI.ResourceIdentifier} #edit)
	#(#{UI.ResourceIdentifier} #editViewUsing:)
	#(#{UI.ResourceIdentifier} #hiddenObjects)
	#(#{UI.ResourceIdentifier} #prompt)
	#(#{UI.ResourceIdentifier} #publishedAspects)
	#(#{UI.ResourceIdentifier} #reassign)
	#(#{UI.ResourceIdentifier} #sourceFilerClass)
	#(#{UI.ResourceIdentifier class} #prompt)
	#(#{UI.ResourceIdentifier class} #publishedAspectsOfInstances)
	#(#{UI.RichTextEdit class} #publishedAspectsOfInstances)
	#(#{UI.RichTextPresenter class} #publishedEventsOfInstances)
	#(#{UI.Scintilla.Attribute class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.BoolPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.CharacterClassifications} #publishedAspects)
	#(#{UI.Scintilla.CharacterClassifications} #publishedKeyedAspects)
	#(#{UI.Scintilla.CharacterRepresentation class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.ColourAlphaPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.ColourPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.EnumPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.HundredthsPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.IndicatorDefinition class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.IntPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.KeyBinding class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.MarkerDefinition class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.PropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.ScintillaView} #publishedAspects)
	#(#{UI.Scintilla.ScintillaView class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.ScintillaView class} #publishedEventsOfInstances)
	#(#{UI.Scintilla.StringPropertyDescriptor} #aspectDescriptor)
	#(#{UI.Scintilla.StylesCollectionPresenter class} #resource_Developer_view)
	#(#{UI.Scintilla.TextStyle class} #newInstanceAspect:class:)
	#(#{UI.Scintilla.TextStyle class} #publishedAspectsOfInstances)
	#(#{UI.Scintilla.TextStylePresenter class} #resource_Developer_view)
	#(#{UI.Scintilla.ThreeStateBooleanPropertyDescriptor} #aspectDescriptor)
	#(#{UI.ScrollBar class} #publishedAspectsOfInstances)
	#(#{UI.ScrollingDecorator class} #publishedAspectsOfInstances)
	#(#{UI.ScrollingDecoratorLayout class} #publishedAspectsOfInstances)
	#(#{UI.SelectableItemsPresenter} #browseIt)
	#(#{UI.SelectableItemsPresenter} #browseItCommand)
	#(#{UI.SelectableItemsPresenter} #queryBrowseIt:)
	#(#{UI.Shell class} #registerAsToolWith:)
	#(#{UI.Shell class} #unregisterAsToolWith:)
	#(#{UI.ShellView class} #publishedAspectsOfInstances)
	#(#{UI.ShellView class} #publishedEventsOfInstances)
	#(#{UI.Slider} #publishedAspects)
	#(#{UI.Slider class} #publishedAspectsOfInstances)
	#(#{UI.SpinButton} #publishedAspects)
	#(#{UI.SpinButton class} #publishedAspectsOfInstances)
	#(#{UI.SpinButton class} #publishedEventsOfInstances)
	#(#{UI.Splitter class} #publishedAspectsOfInstances)
	#(#{UI.StaticBitmap class} #publishedAspectsOfInstances)
	#(#{UI.StaticControlView class} #publishedAspectsOfInstances)
	#(#{UI.StaticIcon class} #publishedAspectsOfInstances)
	#(#{UI.StaticRectangle class} #publishedAspectsOfInstances)
	#(#{UI.StaticText class} #applicableTypeConverterCategories)
	#(#{UI.StaticText class} #publishedAspectsOfInstances)
	#(#{UI.StatusBar class} #publishedAspectsOfInstances)
	#(#{UI.StatusBarItem class} #publishedAspectsOfInstances)
	#(#{UI.StatusBarItemAbstract class} #publishedAspectsOfInstances)
	#(#{UI.TabView class} #publishedAspectsOfInstances)
	#(#{UI.TextEdit class} #applicableTypeConverterCategories)
	#(#{UI.TextEdit class} #publishedAspectsOfInstances)
	#(#{UI.TextEdit class} #publishedEventsOfInstances)
	#(#{UI.TimeToText class} #publishedAspectsOfInstances)
	#(#{UI.Toolbar class} #publishedAspectsOfInstances)
	#(#{UI.Toolbar class} #publishedEventsOfInstances)
	#(#{UI.Toolbar class} #resource_Class_browser_tools)
	#(#{UI.Toolbar class} #resource_Debugger_tools)
	#(#{UI.Toolbar class} #resource_Image_tools)
	#(#{UI.Toolbar class} #resource_Resource_tools)
	#(#{UI.Toolbar class} #resource_Search_tools)
	#(#{UI.Toolbar class} #resource_Smalltalk_tools)
	#(#{UI.Toolbar class} #resource_View_composer_alignment_tools)
	#(#{UI.Toolbar class} #resource_View_composer_match_size_tools)
	#(#{UI.Toolbar class} #resource_View_composer_nudge_tools)
	#(#{UI.Toolbar class} #resource_View_composer_spacing_tools)
	#(#{UI.Toolbar class} #resource_View_composer_tools)
	#(#{UI.Toolbar class} #resource_Workspace_tools)
	#(#{UI.ToolbarBitmapButton} #publishedAspects)
	#(#{UI.ToolbarBitmapButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarSeparator class} #icon)
	#(#{UI.ToolbarSeparator class} #publishedAspectsOfInstances)
	#(#{UI.ToolbarSystemButton} #publishedAspects)
	#(#{UI.ToolbarSystemButton class} #publishedAspectsOfInstances)
	#(#{UI.ToolButton class} #publishedAspectsOfInstances)
	#(#{UI.Tooltip class} #publishedAspectsOfInstances)
	#(#{UI.TranscriptShell} #help)
	#(#{UI.TranscriptShell class} #publishedAspects)
	#(#{UI.TranscriptShell class} #resource_Scintilla_view)
	#(#{UI.TreeModelAbstract class} #publishedEventsOfInstances)
	#(#{UI.TreeView class} #publishedAspectsOfInstances)
	#(#{UI.TypeConverter class} #publishedAspectsOfInstances)
	#(#{UI.ValueConvertingControlView class} #applicableTypeConverterCategories)
	#(#{UI.ValueConvertingControlView class} #publishedAspectsOfInstances)
	#(#{UI.ValueDialog class} #publishedEventsOfInstances)
	#(#{UI.ValueModel} #debugPrintOn:)
	#(#{UI.ValueModel class} #publishedAspectsOfInstances)
	#(#{UI.ValueModel class} #publishedEventsOfInstances)
	#(#{UI.ValuePresenter class} #publishedEventsOfInstances)
	#(#{UI.View} #aspectDisplayOn:)
	#(#{UI.View} #loadViewResource:forEdit:)
	#(#{UI.View} #publishedAspects)
	#(#{UI.View} #visualObjectAtPoint:)
	#(#{UI.View class} #editNewDefaultView)
	#(#{UI.View class} #makeDefaultResource)
	#(#{UI.View class} #makeResource:inClass:)
	#(#{UI.View class} #publishedAspectsOfInstances)
	#(#{UI.View class} #publishedEventsOfInstances)
	#(#{UI.WebView2View class} #publishedAspectsOfInstances)
	#(#{UI.WebView2View class} #publishedEventsOfInstances)
	#(#{WebView2.ICoreWebView2Sequence} #newBatchAccessor)
	#(#{WebView2.ICoreWebView2Sequence} #publishedAspects)
	#(#{WebView2.ICoreWebView2Sequence} #publishedKeyedAspects)
	#(#{WebView2.ICoreWebView2Sequence} #publishedKeyedAspectsBatchSize)
	#(#{WebView2.ICoreWebView2Sequence class} #newInstanceAspect:class:)
).

package setPrerequisites: #(
	'..\..\ActiveX\OCX\ActiveX Control Hosting'
	'..\..\System\Trace\Debug Trace Stream'
	'..\..\Base\Dolphin'
	'..\..\MVP\Presenters\Accelerator\Dolphin Accelerator Presenter'
	'..\..\MVP\Dialogs\Dolphin Base Dialogs'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\System\Filer\Dolphin Binary Filer'
	'..\..\MVP\Base\Dolphin Binary Object Clipboard Format'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'Dolphin Browser Environments'
	'..\..\MVP\Views\Cards\Dolphin Card Containers'
	'..\..\MVP\Views\Buttons\Dolphin Check Buttons'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Choice Prompter'
	'..\..\MVP\Presenters\Collection\Dolphin Collection Presenters'
	'..\..\MVP\Presenters\Color\Dolphin Color Presenter'
	'..\..\MVP\Base\Dolphin Command History'
	'..\..\MVP\Dialogs\Common\Dolphin Common Color Dialog'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\MVP\Dialogs\Common\Dolphin Common Font Dialog'
	'..\..\MVP\Dialogs\Common\Dolphin Common Print Dialog'
	'..\..\MVP\Views\Control Bars\Dolphin Control Bars'
	'..\..\MVP\Base\Dolphin ControlViews Base'
	'..\..\MVP\Views\Date Time\Dolphin Date Time Controls'
	'..\..\MVP\Presenters\Date Time\Dolphin Date Time Presenters'
	'..\..\MVP\Presenters\Shell\Dolphin Document Presenter'
	'..\..\MVP\Type Converters\Dolphin Evaluating Type Converter'
	'..\..\MVP\Dialogs\Find\Dolphin Find Dialog'
	'..\..\MVP\Presenters\Folder\Dolphin Folder Presenter'
	'..\..\MVP\Models\Tree\Dolphin Folder Tree Model'
	'..\..\MVP\Presenters\Font\Dolphin Font Presenter'
	'..\..\MVP\Graphics\Dolphin GDI Graphics'
	'..\..\MVP\Views\Static\GroupBox\Dolphin GroupBox'
	'..\..\MVP\Presenters\Image\Dolphin Image Presenter'
	'..\..\MVP\Presenters\Prompters\Dolphin Integer Prompter'
	'..\..\MVP\Presenters\Prompters\Dolphin Key-Value Prompter'
	'..\..\Base\Dolphin Legacy Date & Time'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\MVP\Presenters\ListTree\Dolphin List Tree Presenter'
	'..\..\System\Filer\Dolphin Literal Filer'
	'..\..\System\Filer\Dolphin Literal Out Filer'
	'..\..\System\Win32\MessageBox\Dolphin Message Box'
	'..\..\MVP\Metafiles\Dolphin Metafiles'
	'..\..\MVP\Views\MoenTree\Dolphin MoenTree View'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Presenters\Number\Dolphin Number Presenter'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\MVP\Views\Buttons\Dolphin Push Buttons'
	'..\..\MVP\Presenters\Radio\Dolphin Radio Buttons'
	'..\..\Registry\Dolphin Registry Access'
	'..\..\Registry\Dolphin Registry Serialisation'
	'..\..\MVP\Presenters\Text\Dolphin Rich Text Presenter'
	'..\..\MVP\Views\Scintilla\Dolphin Scintilla View'
	'..\..\MVP\Views\Scrollbars\Dolphin Scrollbars'
	'..\..\System\SemVer\Dolphin SemVer'
	'..\..\MVP\Views\Slider\Dolphin Slider Control'
	'..\..\MVP\Views\Sliding Tray\Dolphin Slidey-Inney-Outey Thing'
	'..\..\Base\Dolphin Source Fileout'
	'..\..\MVP\Views\SpinButton\Dolphin SpinButton Control'
	'..\..\MVP\Views\Splitter\Dolphin Splitter Control'
	'..\..\MVP\Views\Static\Rectangle\Dolphin StaticRectangle Control'
	'..\..\MVP\Views\Static\Text\Dolphin StaticText Control'
	'..\..\System\Filer\Dolphin STx Filer Core'
	'..\..\MVP\Views\Styled Views\Dolphin Styled Views'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Icons\Dolphin Text Tile Icons'
	'..\..\MVP\Views\Tooltips\Dolphin Tooltips'
	'Dolphin Transcript'
	'..\..\MVP\Presenters\Tree\Dolphin Tree List Presenter'
	'..\..\MVP\Models\Tree\Dolphin Tree Models'
	'..\..\MVP\Presenters\Tree\Dolphin Tree Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Presenters\Validation\Dolphin Validation Hint Presenter'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\MVP\Gdiplus\Gdiplus'
	'..\..\MVP\Gdiplus\Gdiplus ImageView'
	'..\..\Utilities\HTML Help\HTML Help'
	'..\..\MVP\Icons\Internal Bitmaps and Icons'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Formatters\RBFormatters'
	'..\..\..\..\Contributions\Refactory\RBNamespaces'
	'..\..\..\..\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\..\System\Compiler\Smalltalk Compiler'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\..\..\Contributions\Camp Smalltalk\SUnit\SUnitPreload'
	'..\..\ActiveX\Components\WebView2\WebView2'
	'..\..\ActiveX\Shell\Windows Shell'
).

package setManualPrerequisites: #(
	'Debug Trace Stream'
	'Dolphin Source Fileout'
).

package!

"Class Definitions"!

Tools
	subclass: #'Tools.Examples'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools
	subclass: #'Tools.Scintilla'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.CodeGenerationContext'
	instanceVariableNames: 'writeStream targetClass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.Grabber'
	instanceVariableNames: 'rectangle aspect constrain view composer'
	classVariableNames: 'Cursors'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.MenuPainter'
	instanceVariableNames: 'menu conflictingMnemonics conflictingAccelerators'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants private} #{OS private})
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.MethodCategorizationPolicy'
	instanceVariableNames: ''
	classVariableNames: 'Default'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.MethodSearch'
	instanceVariableNames: 'findDetails regexp literal referenceFilter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: { 'IgnoreCaseMask' -> 16r1 }!

Core.Object
	subclass: #'Tools.ParseContext'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.SmalltalkSystemIcon'
	instanceVariableNames: 'openBlock icon description tool helpId'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Object
	subclass: #'Tools.VisualShellFinder'
	instanceVariableNames: 'mouseTracker foundObject foundCursor notFoundCursor shellClassFilter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.AttributeDescriptor
	subclass: #'Tools.Aspect'
	instanceVariableNames: 'name presenterBlock editBlock immediateActionBlock category getBlock putBlock type icon defaultValue'
	classVariableNames: 'DefaultPresenterBlock'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'EditInPlaceMask' -> 16r80000.
			'MultilineValueMask' -> 16r40000.
			'ReadOnlyPresenterBlockMask' -> 16r10000.
			'ValueWorkspaceEditorMask' -> 16r20000
		}!

Tools.Aspect
	subclass: #'Tools.KeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspect
	subclass: #'Tools.AnonymousKeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspect
	subclass: #'Tools.Scintilla.CharacterClassificationAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'ControlCodeNames'
				-> (IdentityDictionary withAll: {
								$\0 -> 'NUL'.
								$\x1 -> 'SOH'.
								$\x2 -> 'SOT'.
								$\x3 -> 'EOT'.
								$\x4 -> 'EOT'.
								$\x5 -> 'ENQ'.
								$\x6 -> 'ACK'.
								$\a -> 'BEL'.
								$\b -> 'BS'.
								$\t -> 'TAB'.
								$\n -> 'LF'.
								$\v -> 'VT'.
								$\f -> 'FF'.
								$\r -> 'CR'.
								$\xE -> 'SO'.
								$\xF -> 'SI'.
								$\x10 -> 'DLE'.
								$\x11 -> 'DC1'.
								$\x12 -> 'DC2'.
								$\x13 -> 'DC3'.
								$\x14 -> 'DC4'.
								$\x15 -> 'NAK'.
								$\x16 -> 'SYN'.
								$\x17 -> 'EOB'.
								$\x18 -> 'CAN'.
								$\x19 -> 'EM'.
								$\x1A -> 'SUB'.
								$\x1B -> 'ESC'.
								$\x1C -> 'FS'.
								$\x1D -> 'GS'.
								$\x1E -> 'RS'.
								$\x1F -> 'US'.
								$\x20 -> 'SP'.
								$\x7F -> 'DEL'
							})
		}!

Tools.KeyedAspect
	subclass: #'Tools.InstVarAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspect
	subclass: #'Tools.KeyedAspectBatch'
	instanceVariableNames: 'batchSize keys accessorClass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspect
	subclass: #'Tools.StackFrameSlot'
	instanceVariableNames: 'index'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AnonymousKeyedAspect
	subclass: #'Tools.BasicKeyedAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Refactory.Browser.BrowserEnvironmentWrapper
	subclass: #'Tools.MethodCategoryEnvironment'
	instanceVariableNames: 'categories'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Category
	subclass: #'Tools.IntermediateCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.MethodCategory
	subclass: #'Tools.DebuggerMethodCategory'
	instanceVariableNames: 'mask'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.MethodCategory
	subclass: #'Tools.VirtualMethodCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.AllMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: 'Current'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.ChangedMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.MethodPrivacyCategory'
	instanceVariableNames: 'privacy'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.PluggableVirtualMethodCategory'
	instanceVariableNames: 'filter isSlowToEnumerate'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.ReferencesCategory'
	instanceVariableNames: 'literal'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.VirtualMethodCategory
	subclass: #'Tools.UnclassifiedMethodsCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ReferencesCategory
	subclass: #'Tools.PackedReferencesCategory'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ReferencesCategory
	subclass: #'Tools.SingleUnarySendMethodCategory'
	instanceVariableNames: 'selector'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ReferencesCategory
	subclass: #'Tools.SpecialReferencesCategory'
	instanceVariableNames: 'index'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.ChunkReader
	subclass: #'Tools.SingleChunkReader'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Error
	subclass: #'Tools.InvalidInstallationError'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Folder
	subclass: #'Tools.PackageFolder'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MenuPainter
	subclass: #'Tools.MenuBarPainter'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MenuPainter
	subclass: #'Tools.PopupMenuPainter'
	instanceVariableNames: 'itemWidth textOffset submenuOffset acceleratorOffset'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MethodSearch
	subclass: #'Tools.AnnotatedMethodSearch'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MethodSearch
	subclass: #'Tools.MethodSourceSearch'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MethodSearch
	subclass: #'Tools.ThisContextSearch'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Model
	subclass: #'Tools.SmalltalkSystem'
	instanceVariableNames: 'systemFolderClass workspaceClass defaultInspectorClass defaultBrowserClass systemFolder packageBrowserClass debuggerClass viewComposerClass protocolBrowserClass workspaceShellClass resourceBrowserClass changedIcon hierarchyBrowserClass preferAlternateInspectors formatterClass classChooserClass resourceIdentifierDialogClass findDetails methodWorkspaceClass allSelectors argumentClasses methodExplorerClass aboutBoxClass testBrowserClass toolbarBitmapSize displayItLocale'
	classVariableNames: 'ChangedIcon Current RegisteredTools'
	imports: #(#{Kernel.CompilerFlags} #{Refactory.Browser} #{Kernel.ParseErrorCodes} #{XProgramming.SUnit private})
	classInstanceVariableNames: ''
	classConstants: {
			'FileDrops'
				-> (LookupTable withAll: {
								'chg' -> #dropScriptFile:.
								'cls' -> #dropClassFile:.
								'pac' -> #dropPackageFile:.
								'pax' -> #dropPackageFile:.
								'sml' -> #dropScriptFile:.
								'st' -> #dropScriptFile:.
								'txt' -> #dropTextFile:.
								'xml' -> #dropXmlFile:
							})
		}!

UI.TreeModel
	subclass: #'Tools.CategoryTreeModel'
	instanceVariableNames: 'title'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.FolderHierarchyModel
	subclass: #'Tools.PackageHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.VirtualTreeModel
	subclass: #'Tools.AbstractClassHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AbstractClassHierarchyModel
	subclass: #'Tools.ClassHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AbstractClassHierarchyModel
	subclass: #'Tools.NamespaceHierarchyModel'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValueAdaptor
	subclass: #'Tools.AspectAccessor'
	instanceVariableNames: 'aspectDescriptor'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AspectAccessor
	subclass: #'Tools.BatchAspectAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.BatchAspectAccessor
	subclass: #'Tools.IndexedInstVarBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.BatchAspectAccessor
	subclass: #'Tools.KeyedAspectBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.IndexedInstVarBatchAccessor
	subclass: #'Tools.SetBatchAspectAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspectBatchAccessor
	subclass: #'Tools.AnonymousKeyedAspectBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.KeyedAspectBatchAccessor
	subclass: #'Tools.Scintilla.CharacterClassificationBatchAccessor'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ParseContext
	subclass: #'Tools.ClassParseContext'
	instanceVariableNames: 'classScope'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ParseContext
	subclass: #'Tools.MethodParseContext'
	instanceVariableNames: 'method'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.ParseNodeVisitor
	subclass: #'Tools.MessageNodeCollector'
	instanceVariableNames: 'messages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.StSemanticAnalyser
	subclass: #'Tools.BrowserSemanticAnalyser'
	instanceVariableNames: 'isStub'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Presenter
	subclass: #'Tools.ClassBrowserPlugin'
	instanceVariableNames: ''
	classVariableNames: 'DefaultPlugins'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Presenter
	subclass: #'Tools.PackageDependencyPresenter'
	instanceVariableNames: 'treePresenter tracesPresenter traces packages'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Presenter
	subclass: #'Tools.SmalltalkSearchPresenter'
	instanceVariableNames: 'searchEnvironment'
	classVariableNames: 'AutoCompleteDwell MaxCompletionListHeight MaxCompletionListWidth OptionFlags'
	imports: #(#{UI.Scintilla private})
	classInstanceVariableNames: ''
	classConstants: { 'LoadingOptionsMask' -> 16r1 }!

UI.Presenter
	subclass: #'Tools.SmalltalkWorkspace'
	instanceVariableNames: 'evaluationContext errorModel findDetails workspacePool namespaces compilationErrors textStyles searchEnvironment modifiedModel flags indicatorDefinitions variableMetadataProvider'
	classVariableNames: 'Abbreviations AnnotationMode AutoCompleteDwell DefaultCaretColor DefaultFont DefaultTabWidth FontQuality IndicatorDefinitions KeyBindings KeywordCompletions MaxAutoCompletionListHeight MaxAutoCompletionListSize MaxAutoCompletionListWidth OptionFlags StandardUnaryReturnTypes TextStyles WrapIndentMode'
	imports: #(#{Kernel.CompilerFlags} #{UI.Scintilla private} #{Refactory.Browser private})
	classInstanceVariableNames: 'additionalKeyBindings'
	classConstants: {
			'AutoCompleteMask' -> 16r8.
			'AutoCompletionCaseInsensitiveMask' -> 16r80.
			'AutoCompletionEnabledMask' -> 16r10.
			'AutoCompletionSpaceAddedMask' -> 16r40.
			'AutoCompletionTruncatingMask' -> 16r20.
			'LiteralStyleNames'
				-> (Set withAll: #(#literalNumber #literalPseudo #literalString #literalSymbol)).
			'LoadingOptionsMask' -> 16r1.
			'UseDirectWriteMask' -> 16r100.
			'VariableTipsMask' -> 16r2.
			'WordWrapMask' -> 16r4
		}!

UI.Presenter
	subclass: #'Tools.TwinLevelInspector'
	instanceVariableNames: 'contentsPresenter inspectorPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassBrowserPlugin
	subclass: #'Tools.AstPlugin'
	instanceVariableNames: 'astPresenter sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassBrowserPlugin
	subclass: #'Tools.ClassAspectPlugin'
	instanceVariableNames: 'textPresenter originalText currentClass'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassAspectPlugin
	subclass: #'Tools.ClassCommentPlugin'
	instanceVariableNames: ''
	classVariableNames: 'TextStyles WordWrap'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.PackageDependencyPresenter
	subclass: #'Tools.PackageDependents'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.PackageDependencyPresenter
	subclass: #'Tools.PackagePrerequisites'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.SelectableItemsPresenter
	subclass: #'Tools.ClassSelector'
	instanceVariableNames: 'classesPresenter searchEnvironment'
	classVariableNames: ''
	imports: #(#{Refactory.Browser private} #{XProgramming.SUnit private})
	classInstanceVariableNames: ''
	classConstants: { 'ClassModeMask' -> 16r1. 'ShowFullNamesMask' -> 16r2 }!

UI.SelectableItemsPresenter
	subclass: #'Tools.PackageSelector'
	instanceVariableNames: 'filterPresenter packagesPresenter autoSelect'
	classVariableNames: ''
	imports: #(#{XProgramming.SUnit private} #{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassSelector
	subclass: #'Tools.ClassHierarchySelector'
	instanceVariableNames: 'flags'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ClassSelector
	subclass: #'Tools.ClassListSelector'
	instanceVariableNames: 'flags classesListPresenter browserEnvironment namespacesPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ListPresenter
	subclass: #'Tools.MethodBrowser'
	instanceVariableNames: 'methodsPresenter sourcePresenter filter searchEnvironment refactoringTool namespaceModel'
	classVariableNames: 'AdditionalAccelerators AutoFormat InfoTips WordWrap'
	imports: #(#{Kernel.CompilerFlags} #{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ListPresenter
	subclass: #'Tools.ResourceListPresenter'
	instanceVariableNames: 'filterBlock resourcesPresenter previewPresenter resourceIdModel'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ListPresenter
	subclass: #'Tools.ResourceToolboxPresenter'
	instanceVariableNames: 'categoriesPresenter resourcesPresenter iconMap'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Shell
	subclass: #'Tools.SmalltalkToolShell'
	instanceVariableNames: 'searchPresenter fontSizePresenter'
	classVariableNames: 'HistoryDwellTime SearchFieldFlashes'
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: 'optionFlags defaultView defaultExtent defaultSlideyPinsMap additionalKeyBindings'
	classConstants: {
			'CanUseIdeaSpaceMask' -> 16r2.
			'LoadingMask' -> 16r1.
			'ReuseIfOpenMask' -> 16r4.
			'ShowOptionLoadingTimes' -> false
		}!

UI.AbstractDocumentShell
	subclass: #'Tools.SmalltalkWorkspaceDocument'
	instanceVariableNames: 'workspacePresenter searchPresenter'
	classVariableNames: 'DefaultExtent DefaultView OptionFlags'
	imports: #(#{Refactory.Browser private})
	classInstanceVariableNames: ''
	classConstants: {
			'CanUseIdeaSpaceMask' -> 16r8.
			'LanguageExtensions'
				-> (LookupTable withAll: {
								'chg' -> #container.
								'cls' -> #container.
								'ist' -> #container.
								'json' -> #json.
								'pac' -> #container.
								'pax' -> #container.
								'sml' -> #container.
								'st' -> #container.
								'ston' -> #smalltalk.
								'xml' -> #xml
							}).
			'LoadingMask' -> 16r1.
			'ReUseIfOpenMask' -> 16r2.
			'VariableTipsMask' -> 16r4
		}!

UI.Dialog
	subclass: #'Tools.AspectEditorDialog'
	instanceVariableNames: 'aspectPresenterInDialog hookPresenter subjectModel aspect aspectRectangle'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Dialog
	subclass: #'Tools.CreateSubclassDialog'
	instanceVariableNames: 'packagesPresenter subclassesPresenter namePresenter namespacePresenter usePackagePresenter package superclassPresenter isNonInstantiablePresenter isVariablePresenter isBytesPresenter attributesPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Dialog
	subclass: #'Tools.MenuItemDialog'
	instanceVariableNames: 'titlePresenter commandPresenter iconPresenter imageModel iconIdPresenter inspector cardsPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Dialog
	subclass: #'Tools.ResourceIdentifierDialog'
	instanceVariableNames: 'classesPresenter resourceNamePresenter classValue'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MenuItemDialog
	subclass: #'Tools.CommandMenuItemDialog'
	instanceVariableNames: 'acceleratorPresenter isRadioButtonStylePresenter isDefaultPresenter isModalPresenter hasSubstitutionsPresenter'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MenuItemDialog
	subclass: #'Tools.MenuDialog'
	instanceVariableNames: 'autoDismissPresenter checkColumnModePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValueDialog
	subclass: #'Tools.CategoryPrompter'
	instanceVariableNames: 'treePresenter flags categoryClass'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: { 'AllowIntermediatesMask' -> 16r1. 'AllowReadOnlyMask' -> 16r2 }!

UI.ValueDialog
	subclass: #'Tools.ChooseClassDialog'
	instanceVariableNames: 'classesPresenter allowNil nilButtonCaption'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValueDialog
	subclass: #'Tools.MenuComposer'
	instanceVariableNames: 'arena menuViews conflictingAccelerators'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants private})
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValueDialog
	subclass: #'Tools.PackagePrompter'
	instanceVariableNames: 'packagesPresenter notPackagedPresenter defaultPackage'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.ChooseClassDialog
	subclass: #'Tools.ChooseNamespaceDialog'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.MenuComposer
	subclass: #'Tools.MenuBarComposer'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.ClassBrowserAbstract'
	instanceVariableNames: 'classesPresenter categoriesPresenter methodBrowserPresenter definitionPresenter modePresenter flags history variablesPresenter protocolsPresenter filterPresenter packageModel statusModel cardsPresenter loadedPlugins methodCategories'
	classVariableNames: 'GrayedMethodFadeFactor HistoryListSize LooseMethodColor WordWrapDefinition'
	imports: #()
	classInstanceVariableNames: 'plugins'
	classConstants: { 'FilterObjectMethodsMask' -> 16r200. 'ShowInheritedMethodsMask' -> 16r100 }!

Tools.SmalltalkToolShell
	subclass: #'Tools.Debugger'
	instanceVariableNames: 'process topFrame localAccessor depth flags breakWhen stackPresenter sourcePresenter variablesPresenter inspectorPresenter breakAction suspendingList _method refactoringTool sourceInterval'
	classVariableNames: 'AnimatePause DefaultStackDepth EnableDynamicMenus RestartOnMethodSave RunToCursorBehavior ShowWalkbacks SkipTable'
	imports: #(#{Kernel.CompilerFlags} #{Kernel.OpcodePool})
	classInstanceVariableNames: ''
	classConstants: {
			'AnimateMask' -> 16r10.
			'DisassemblyMask' -> 16r4.
			'MainMask' -> 16r1.
			'ResumableMask' -> 16r8.
			'RunMask' -> 16r2.
			'StackDepthIncrement' -> 16r64
		}!

Tools.SmalltalkToolShell
	subclass: #'Tools.FlipperInspector'
	instanceVariableNames: 'cards'
	classVariableNames: 'Renderers'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.InspectorShell'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.MethodBrowserShell'
	instanceVariableNames: 'browserPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.PackageBrowserShell'
	instanceVariableNames: 'packagesPresenter classesPresenter methodsPresenter methodRefactoringTool variablesPresenter resourcesPresenter currentCard commentPresenter cardsPresenter updateFlags scriptTextPresenter scriptNamesPresenter prerequisitesPresenter dependentsPresenter statusModel'
	classVariableNames: 'WordWrapComment'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.ResourceBrowser'
	instanceVariableNames: 'resourceToolboxPresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.SmalltalkSystemShell'
	instanceVariableNames: 'systemFolderPresenter'
	classVariableNames: 'Backcolor BackImage BackImageAlphaPercent BackImageIsTiled Default HotKey PlaySystemSounds ResetWhenInvisible Textcolor ViewMode'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkToolShell
	subclass: #'Tools.ViewComposer'
	instanceVariableNames: 'toolboxPresenter status arenaPresenter inspector composingView ownsComposingView resourceIdentifier addPositionOffset grabbers selections grid viewHierarchyPresenter adornmentRegion primarySelection vcFlags modificationStatus image undoList'
	classVariableNames: 'Clipboard DefaultGridResolution ExtentImage PositionImage'
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {
			'AdornmentModifiedFlag' -> 16r4.
			'ModifiedFlag' -> 16r1.
			'MouseClickFlag' -> 16r2.
			'RefreshFlag' -> 16r8.
			'UndoRedoFlag' -> 16r10
		}!

Tools.ClassBrowserAbstract
	subclass: #'Tools.ClassBrowserShell'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: { 'LocalHierarchyMask' -> 16r10 }!

Tools.MethodBrowserShell
	subclass: #'Tools.MethodExplorerShell'
	instanceVariableNames: 'historyTree historyList'
	classVariableNames: 'HistoryListSize'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkWorkspace
	subclass: #'Tools.MethodWorkspace'
	instanceVariableNames: 'parseTree'
	classVariableNames: 'AutoParseDwell'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: { 'NoAutoParseMask' -> 16r100000. 'NoSelectionMatching' -> 16r200000 }!

Tools.SmalltalkWorkspace
	subclass: #'Tools.ValueWorkspace'
	instanceVariableNames: 'textModel'
	classVariableNames: 'ValueIsSelfCookie'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValuePresenter
	subclass: #'Tools.BasicInspector'
	instanceVariableNames: 'variableNamesPresenter sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ValuePresenter
	subclass: #'Tools.InspectorAbstract'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.BasicInspector
	subclass: #'Tools.CompiledMethodInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'MethodTypes'
				-> #('Normal' 'Return nil' 'Return true' 'Return false' 'Return literal constant 0' 'Return self' 'Return instance variable' 'Set instance variable')
		}!

Tools.BasicInspector
	subclass: #'Tools.DictionaryInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.BasicInspector
	subclass: #'Tools.SequenceableCollectionInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.BasicInspector
	subclass: #'Tools.StructureInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.InspectorAbstract
	subclass: #'Tools.AspectInspector'
	instanceVariableNames: 'aspectTreePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: 'treeUpdateMode treeHasGridLines'
	classConstants: {}!

Tools.InspectorAbstract
	subclass: #'Tools.VisualObjectFinder'
	instanceVariableNames: 'mouseTracker finderIcon heading workspace foundView'
	classVariableNames: 'FindNonDolphinWindows'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AspectInspector
	subclass: #'Tools.AbstractPublishedAspectInspector'
	instanceVariableNames: 'aspectValueHolder aspectPresenter isRootAspectVisible isSingleLevelOnly'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AspectInspector
	subclass: #'Tools.InstVarInspector'
	instanceVariableNames: 'sourcePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AbstractPublishedAspectInspector
	subclass: #'Tools.PropertyInspector'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.AbstractPublishedAspectInspector
	subclass: #'Tools.PublishedAspectInspector'
	instanceVariableNames: 'displayPresenter workspacePresenter'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.Scanner
	subclass: #'Tools.SmalltalkStylingScanner'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.SingletonSearchPolicy
	subclass: #'Tools.CompiledMethodSearchPolicy'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.GUISessionManager
	subclass: #'Tools.DevelopmentSessionManager'
	instanceVariableNames: 'imageStamp installationDirectory backupOnImageSave productDetails showSplashAtStartup'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkSystemIcon
	subclass: #'Tools.SmalltalkSystemFolder'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Kernel.STxInFilerWrapper
	subclass: #'Tools.STxDebugger'
	instanceVariableNames: 'indentLevel count traceStream printOffsets'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.STxDebugger
	subclass: #'Tools.STBDebugger'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.STxDebugger
	subclass: #'Tools.STLDebugger'
	instanceVariableNames: 'slotName'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.Scintilla.Styler
	subclass: #'Tools.SmalltalkStyler'
	instanceVariableNames: 'arrayDepth view last inTag stack'
	classVariableNames: ''
	imports: #(#{UI.Scintilla private})
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkStyler
	subclass: #'Tools.SmalltalkExpressionStyler'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

Tools.SmalltalkStyler
	subclass: #'Tools.SmalltalkMethodStyler'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.View
	subclass: #'Tools.MenuComposerView'
	instanceVariableNames: 'selectionIndex painter'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants})
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ContainerView
	subclass: #'Tools.MenuComposerArena'
	instanceVariableNames: 'dragImageList dragPoint dragMenuIndex dragSource _unused'
	classVariableNames: ''
	imports: #(#{OS.CommCtrlConstants})
	classInstanceVariableNames: ''
	classConstants: {}!

UI.DesktopView
	subclass: #'Tools.DesignDesktopView'
	instanceVariableNames: 'dpi'
	classVariableNames: 'Default System Unaware'
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
	
UI.DialogView
	subclass: #'Tools.WalkbackDialog'
	instanceVariableNames: 'callStack resumable caption debuggable'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {
			'CallStackId' -> 16r3E9.
			'Commands'
				-> (LookupTable withAll: { 16r1 -> #debug. 16r2 -> #terminate. 16r3 -> #resume. 16r4 -> #copy }).
			'IconId' -> 16r3F1
		}!

UI.ImageViewAbstract
	subclass: #'Tools.ImageListView'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

UI.ImageView
	subclass: #'Tools.ViewComposerArena'
	instanceVariableNames: 'composer'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.Array methodsFor!

assignToResourceIdentifier: aResourceIdentifier
	"Private - Assign the receiver, as a literal resource array, to aResourceIdentifier"

	aResourceIdentifier assignLiteralResourceData: self!

debugPrintOn: aStream
	self printOn: aStream do: [:each | each debugPrintOn: aStream]! !

!Core.Array categoriesForMethods!
assignToResourceIdentifier:!private! !
debugPrintOn:!printing!public! !
!

!Core.Association methodsFor!

debugPrintOn: aStream
	aStream visit: self
		do: 
			[aStream
				debugPrint: key;
				nextPutAll: ' -> ';
				debugPrint: value]! !

!Core.Association categoriesForMethods!
debugPrintOn:!public! !
!

!Core.Bag class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect collection: #elements);
		yourself! !

!Core.Bag class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Core.Behavior methodsFor!

changedMethods
	"Private - Answer a <collection> of all the changed methods in the receiver."

	^self methodDictionary select: [:method | method hasChanged]!

hasAbstractMethods
	"Answer whether the receiver has any methods that are by convention considered to be
	abstract (i.e. they consist solely of a send of #subclassResponsibility to self)."

	^self methodDictionary anySatisfy: [:each | each isAbstract]!

isAbstract
	^self isNonInstantiable or: [self hasAbstractMethods]!

methodFor: aSymbol
	^self compiledMethodAt: aSymbol ifAbsent: nil!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForClass: self!

whichClassDefinesInstVar: aString 
	^self whichClassSatisfies: [:aClass | aClass instanceVariableNames includes: aString]!

whichMethodsContainSource: aString
	"Answer a <Set> of methods from the receiver's local method dictionary whose methods contain
	the specified source string."

	^self selectMethods: [:method | method containsSource: aString]!

whichMethodsOnlySelfSend: aSymbol
	"Answer a Set of methods which consist purely of a send-to-self of the specified zero-arg selector."

	^self selectMethods: ((VM indexOfSpecialSelector: aSymbol ifAbsent: nil)
				ifNil: [[:method | method isSimpleSelfSend: aSymbol]]
				ifNotNil: 
					[:index |
					| specialSend send sendRet |
					specialSend := index + OpcodePool.ShortSpecialSend - 1.
					sendRet := CompiledCode packByteCodes: (ByteArray
										with: OpcodePool.PushSelf
										with: specialSend
										with: OpcodePool.ReturnFromMessage).
					send := CompiledCode packByteCodes: (ByteArray
										with: OpcodePool.PushSelf
										with: specialSend
										with: OpcodePool.ReturnSelf).
					
					[:method |
					| packed |
					packed := method basicByteCodes.
					packed == send or: [packed == sendRet]]])!

whichMethodsReferTo: anObject
	"Answer a <Set> of methods in the receiver whose literal frames include the argument, anObject."

	^self selectMethods: (self referenceFilterFor: anObject)!

whichSelectorsReferTo: anObject
	"Answer a Set of selectors whose methods access the argument, anObject.
	This is really only included for Blue Book compatibility."

	^(self whichMethodsReferTo: anObject) collect: [:each | each selector]! !

!Core.Behavior categoriesForMethods!
changedMethods!methods-accessing!private! !
hasAbstractMethods!public!testing! !
isAbstract!public!testing! !
methodFor:!accessing!public! !
searchForInTool:!public! !
whichClassDefinesInstVar:!public!RefactoringBrowser! !
whichMethodsContainSource:!methods-testing!public! !
whichMethodsOnlySelfSend:!methods-testing!public! !
whichMethodsReferTo:!methods-testing!public! !
whichSelectorsReferTo:!methods-testing!public! !
!

!Core.Boolean methodsFor!

literalTextStyle
	^#literalPseudo! !

!Core.Boolean categoriesForMethods!
literalTextStyle!constants!private! !
!

!Core.Boolean class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass boolean: aSymbol! !

!Core.Boolean class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Category class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !

!Core.Category class categoriesForMethods!
icon!constants!public! !
!

!Core.Character methodsFor!

literalTextStyle
	^#literalCharacter! !

!Core.Character categoriesForMethods!
literalTextStyle!constants!private! !
!

!Core.Class methodsFor!

changeIndex
	^self propertyAt: #changeIndex ifAbsent: nil!

changeIndexValue: aBlock 
	self propertyManager 
		propertyOf: self
		at: #changeIndex
		ifAbsentPut: aBlock!

isAbstract
	^super isAbstract or: [self class isAbstract]!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	(self isAnonymous or: [self propertyManager isNil]) ifTrue: [^self].
	"Note that we don't test the existing value of the change flag here, because
	 we want to inform the package regardless (in case it isn't currently changed
	 for some reason)"
	aBoolean
		ifTrue: 
			[self changeIndexValue: [self sourceManager changesFileSize].
			self notifyPackageOfChange]
		ifFalse: [self removePropertyAt: #changeIndex ifAbsent: nil]!

isDeprecated
	^ClassCategory.Deprecated includesClass: self!

isNonInstantiable: aBoolean
	"Private - Set whether the receiver should not be instantiated, e.g. it is abstract."

	self isNonInstantiable == aBoolean ifTrue: [^self].
	super isNonInstantiable: aBoolean.
	self isChanged: true!

methodChanged: aCompiledMethod 
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	self propertyManager isNil ifTrue: [^self].
	self changeIndexValue: [aCompiledMethod changePosition].
	self notifyPackageOfChange!

notifyPackageOfChange
	PackageManager current onClassDirtied: self!

renameClassVar: oldString to: newString
	"Private - Rename the class variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own class 
	variables , not of one of its superclass'.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access class variables via the binding (Association) they will remain valid until recompiled. It is the 
	caller's responsibility to rewrite and recompile methods that reference the variable."

	self classPool changeKey: oldString to: newString.
	self classUpdated! !

!Core.Class categoriesForMethods!
changeIndex!accessing!private! !
changeIndexValue:!accessing!private! !
isAbstract!public!testing! !
isChanged:!accessing!public! !
isDeprecated!public!source filing! !
isNonInstantiable:!instance specification-accessing!private! !
methodChanged:!helpers!private! !
notifyPackageOfChange!private!refactoring! !
renameClassVar:to:!class hierarchy-mutating!class variables!private! !
!

!Core.ClassDescription methodsFor!

browse
	"Open a suitable browser onto the receiver."

	SmalltalkSystem current browseClass: self!

categoriesFor: selector are: categories
	"Compatibility ith IBM Smalltalk fileIn format (which is of the form
	<class> categoriesFor: <selector> are: #([<categoryString>]*).
	Sets the additional categories of a selector if it exists."

	(self includesSelector: selector)
		ifTrue: 
			[categories
				do: [:categoryString | self includeSelector: selector inCategory: categoryString asMethodCategory]]!

commentStamp: stamp prior: prior
	"Answer a chunk reader which will add a comment to the receiver. Supplied for 
	compatibility with the Squeak fileout format"

	^SingleChunkReader do: [:chunk | self comment: chunk]!

copy: selector from: class
	"Copy the method with the selector <Symbol>, selector, in <ClassDescription>, 
	class, to the receiver's method dictionary, maintaining any existing categories.
	If a compile error occurs then a CompilerNotification is signalled. 
	Answers the new method or nil."

	^self copy: selector from: class categories: (class compiledMethodAt: selector) categories

!

copy: aSymbol from: aClass categories: aCollection 
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, classifying it in each of the <Collection> of
	<methodCategory>s specified by the last argument. If a compile error occurs then a
	CompilerNotification is signalled. Answers the new method or nil."

	| method |
	method := aClass compiledMethodAt: aSymbol.
	^self 
		compile: method getSource
		environment: method environment
		categories: aCollection
		package: method owningPackageIfLoose!

copy: aSymbol from: aClass classified: aString
	"Copy the method with the specified selector <Symbol>, in the <Behavior>, aClass, to the
	receiver's method dictionary, adding it to the category identified by the final <String>
	argument."

	"This method is primarily present for Smalltalk-80 compatibility, but differs in that as
	Dolphin supports multiple categories, the existing method classifications are retained and
	'cat' is treated as a new classification. The method is recompiled in its new class. If a
	compile error occurs then a CompilerNotification is signalled. Answers the new method or
	nil."

	| categories |
	categories := (aClass compiledMethodAt: aSymbol) categories.
	categories add: aString asMethodCategory.
	^self
		copy: aSymbol
		from: aClass
		categories: categories!

copyAll: selectors from: class
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	maintaining the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyAll: selectors from: class classified: cat
	"Copy each of the methods with selectors in the <Collection> of <Symbol>s,
	selectors, from the <Behavior>, class, to the receiver's method dictionary, 
	adding the new methods to the category with <readableString> name, cat,
	as well as the methods current categories.
	Answers whether all of the methods copied successfully."

	^selectors allSatisfy: [:selector | 
		(self copy: selector from: class classified: cat) notNil]!

copyAllCategoriesFrom: class
	"Copy all categories of method from the <Behavior>, class, to the receiver.
	Answers whether all of the methods copied successfully."
	
	^class selectors allSatisfy: [:selector | (self copy: selector from: class) notNil]!

copyCategory: category from: aClass
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully."

	| cat |
	cat := category asMethodCategory.
	^(cat methodsInBehavior: self)
		allSatisfy: [:m | (self
				copy: m selector
				from: aClass
				classified: cat) notNil]!

copyCategory: category from: aClass classified: newCategory
	"Copy all methods of the <ClassDescription> class, in the <MethodCategory>
	named by the <readableString>, category, to the receiver. Answers whether all 
	of the methods copied successfully. The methods are additionally classified
	under the <MethodCategory> named by the <readableString>, newCategory."

	| cat |
	cat := category asMethodCategory.
	^(cat methodsInBehavior: self)
		allSatisfy: [:m | (self
				copy: m selector
				from: aClass
				classified: newCategory) notNil]!

isDeprecated
	^self subclassResponsibility!

isVisiblyAbstract
	^self instanceClass isNonInstantiable!

methodsFor: categoryName
	"Answer a chunk reader to read and compile method chunks for the receiver
	to be classified into the method category with the specified <readableString> name.
	This method is present for loading ST files in Green Book format. Ensure
	first that the category name doesn''t, falsely, appear hierarchical."

	| useName |
	useName := categoryName copyReplacing: #{Category.Separator} value withObject: $/.
	^ChunkReader
		do: [:chunkString :filer | self compile: chunkString classified: useName]
		inContext: self
		atEnd: []!

methodsFor: name stamp: aString
	"Answer a chunk reader to read and compile method chunks for the receiver
	to be classified into the method category with the specified <readableString> name.
	The stamp is ignored. This method is for compatibility with the Pharo fileout format."

	| useName |
	useName := name copyReplacing: #{Category.Separator} value withObject: $/.
	^ChunkReader
		do: [:chunkString :filer | self compile: chunkString classified: useName]
		inContext: self
		atEnd: []!

model
	^SmalltalkSystem current!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol!

parseContext
	^ParseContext methodClass: self environment: self environment!

privateMethods
	"For compatibility with IBM Smalltalk file out format"

	^self methodsFor: 'private'

!

publicMethods
	"For compatibility with IBM Smalltalk file out format"

	^self methodsFor: 'public'

!

renameInstVar: oldString to: newString
	"Private - Rename the instance variable of the receiver named by the <readableString>, oldString, to be
	named by the <readableString>, newString. The variable must be one of the receiver's own instance 
	variables , not of one of its superclasses.
	Note: This is a low-level operation that does not recompile any methods, however since the methods
	access instance variables by index they will remain valid until recompiled. It is the caller's responsibility
	to rewrite and recompile methods that reference the instance variable."

	self setInstanceVariables: (self instanceVariableNames copyReplacing: oldString withObject: newString).
	self logDefinition.
	Smalltalk classUpdated: self! !

!Core.ClassDescription categoriesForMethods!
browse!commands!development!public! !
categoriesFor:are:!public!source filing-methods! !
commentStamp:prior:!public!source filing-methods!squeak! !
copy:from:!methods-copying!public! !
copy:from:categories:!methods-copying!public! !
copy:from:classified:!methods-copying!public! !
copyAll:from:!methods-copying!public! !
copyAll:from:classified:!methods-copying!public! !
copyAllCategoriesFrom:!methods-copying!public! !
copyCategory:from:!methods-copying!public! !
copyCategory:from:classified:!methods-copying!public! !
isDeprecated!public!source filing! !
isVisiblyAbstract!private!testing! !
methodsFor:!public!source filing-methods! !
methodsFor:stamp:!public!source filing-methods!squeak! !
model!public!source filing-methods! !
newInstanceAspect:class:!adapters!private! !
parseContext!public!source filing-methods! !
privateMethods!public!source filing-methods! !
publicMethods!public!source filing-methods! !
renameInstVar:to:!instance variables!private! !
!

!Core.Collection methodsFor!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
	argument in a form that a user viewing the receiver as the value of a published aspect would 
	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
	formats.In this case we don't want to include the contents.
	N.B. This is a development time only method that supports the PublishedAspectInspector."
	
	self basicPrintOn: aStream!

debugPrintOn: aStream
	"Copy of printOn: logic, except using #debugPrintOn: to print the elements"

	aStream visit: self
		do: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self do: [:each | each debugPrintOn: aStream] separatedBy: [aStream space].
			aStream nextPut: $)]!

newBatchAccessor
	^IndexedInstVarBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	^LookupTable new
		addAll: (self newBatchAccessor getBatchAccessors collect: [:each | each aspectDescriptor]);
		yourself!

publishedKeyedAspectsBatchSize
    	"Private - Answers the number of keyed aspects to display in the PAI return at a time"
    
    	^200
    ! !

!Core.Collection categoriesForMethods!
aspectDisplayOn:!private! !
debugPrintOn:!printing!public! !
newBatchAccessor!public! !
publishedAspects!constants!public! !
publishedKeyedAspects!public! !
publishedKeyedAspectsBatchSize!constants!private! !
!

!Core.Collection class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass collection: aSymbol! !

!Core.Collection class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Date class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass date: aSymbol! !

!Core.Date class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Dictionary methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^DictionaryInspector!

bestSlotFor: element boundedBy: capacity
	^self hash: element key max: capacity!

debugPrintOn: aStream
	"Copy of the printOn: logic, except using #debugPrintString to print the elements"

	aStream visit: self
		do: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self associationsDo: [:each | each debugPrintOn: aStream] separatedBy: [aStream space].
			aStream nextPut: $)]!

newBatchAccessor
	| keys |
	keys := self keys.
	^KeyedAspectBatchAccessor
		subject: self
		keys: ([keys asSortedCollection] on: Error do: [:ex | keys asOrderedCollection])
		startingAt: 1
		batchSize: self publishedKeyedAspectsBatchSize!

printSelfEvaluatingOn: aStream
	tally == 0
		ifTrue: 
			[aStream
				print: self class;
				space;
				nextPutAll: #new.
			^self].
	aStream
		nextPut: $(;
		print: self class;
		space.
	tally == 1
		ifTrue: 
			[aStream
				nextPutAll: #with:;
				space;
				print: self associations single;
				nextPut: $)]
		ifFalse: 
			[aStream
				nextPutAll: #withAll:;
				space;
				print: (self sortSelfEvaluatingElements: self associations locale: aStream locale);
				nextPut: $)]!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	"This override is necessary to avoid implementation details being included by the 
    	default implementation in Object>>publishedAspects for an empty Dictionary."

	^(self publishedKeyedAspects)
		addAll: self class publishedAspectsOfInstances;
		yourself! !

!Core.Dictionary categoriesForMethods!
alternateInspectorClass!constants!public! !
bestSlotFor:boundedBy:!development!private!statistics! !
debugPrintOn:!printing!public! !
newBatchAccessor!public! !
printSelfEvaluatingOn:!printing!private! !
publishedAspects!constants!public! !
!

!Core.Dictionary class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass dictionary: aSymbol! !

!Core.Dictionary class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Duration methodsFor!

debugPrintOn: aWriteStream
	"The human-readable displayString is more easy to interpret than the ANSI-compliant printString."

	self displayOn: aWriteStream! !

!Core.Duration categoriesForMethods!
debugPrintOn:!printing!public! !
!

!Core.Float class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !

!Core.Float class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Interval methodsFor!

debugPrintOn: aStream
	self printOn: aStream!

newBatchAccessor
	^IndexedInstVarBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !

!Core.Interval categoriesForMethods!
debugPrintOn:!printing!public! !
newBatchAccessor!public! !
!

!Core.LargeInteger methodsFor!

debugPrintOn: aStream
	| size |
	size := self basicSize.
	size > 1024
		ifTrue: 
			[aStream
				nextPutAll: 'a ';
				print: size * 8;
				nextPutAll: '-bit ';
				print: self class]
		ifFalse: [self printOn: aStream]! !

!Core.LargeInteger categoriesForMethods!
debugPrintOn:!printing!public! !
!

!Core.LookupTable methodsFor!

bestSlotFor: element boundedBy: capacity
	^self hash: element max: capacity! !

!Core.LookupTable categoriesForMethods!
bestSlotFor:boundedBy:!development!private!statistics! !
!

!Core.Metaclass methodsFor!

changeIndex
	^instanceClass changeIndex!

isChanged: aBoolean
	"Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument.
	Implementation Note: The change flags are held on the instance side."

	instanceClass isChanged: aBoolean!

isDeprecated
	^instanceClass isDeprecated!

methodChanged: aCompiledMethod
	"Private - Flag the receiver as changed or not changed, according to the value 
	of the <Boolean> argument. If the receiver is marked as changed, then
	its owning package (if any) is also so marked."

	instanceClass methodChanged: aCompiledMethod! !

!Core.Metaclass categoriesForMethods!
changeIndex!accessing!private! !
isChanged:!public!source filing! !
isDeprecated!public!source filing! !
methodChanged:!helpers!private! !
!

!Core.MethodCategory class methodsFor!

all
	"Answer the category for all methods."

	^AllMethodsCategory current! !

!Core.MethodCategory class categoriesForMethods!
all!instance creation!public! !
!

!Core.Number methodsFor!

literalTextStyle
	^#literalNumber! !

!Core.Number categoriesForMethods!
literalTextStyle!constants!private! !
!

!Core.Object methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^BasicInspector!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representatin of the receiver to the <puttableStream> argument in a form that a user viewing the receiver as the value of a published aspect would like to see it.
	Typically we use #displayOn:locale: with the Smalltalk locale, but some classes of object can use alternate display formats.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."

	self displayOn: aStream!

basicInspect
	"Open and answer an inspector window on the receiver.
    	Do not override this method."

	^BasicInspector shellOn: self!

browse
	"Open a suitable browser onto the receiver."

	SmalltalkSystem current browseClass: self class!

currentPublishedAspectsAsLiteralsMap
	"Answer a <LookupTable> mapping  publised aspect symbols to their current literal array representations. We can use this
	to represent the current published aspects values for an object without having to hold on to the actual value objects themselves."

	^self publishedAspects collect: [:each | (each accessorFor: self) value literalStoreArray]!

debugPrintOn: aStream
	"Append, to the <puttableStream>, argument a string whose characters are a description of the receiver appropriate for display in the debugger."

	self printOn: aStream!

debugPrintString
	"Answer a <readableString> whose characters are a description of the receiver as the debugger would want to see it."

	| stream |
	stream := LimitedWriteStream
				over: (String smalltalkWriteStream: 32)
				limit: 500
				limitBlock: [:s | ^s contents , ' ... etc ...'].
	self debugPrintOn: stream.
	^stream contents!

halt
	"Bring up the Smalltalk debugger (suspending the active process) ..."

	| process |
	process := Processor activeProcess.
	process halt: process topFrame sender cause: 'Hard coded breakpoint'!

inspect
	"Open and answer an inspector window on the receiver."

	^SmalltalkSystem current inspect: self!

inspectorClass
	"Answer the class of inspector to be used when inspecting the receiver."

	^SmalltalkSystem current defaultInspectorClass!

newAspect: keyObject class: aspectClass 
	"Answer an instance of the <Aspect> class, aspectClass, appropriately configured to represent
	the aspect of the receiver named by the <Object>, keyObject (usually a <Symbol>)."

	^self class newInstanceAspect: keyObject class: aspectClass!

publicAccessorAspects
	"Answer a <LookupTable> of the <Aspect> for public accessor methods of the
    	the receiver."

	| aspects |
	aspects := LookupTable new: (self class instSize + 1) * 2.
	aspects add: ((self newAspect: #yourself class: Aspect)
				type: self class;
				yourself).
	self class allGettersDo: 
			[:each |
			(each isPublic and: [(each hasAnnotation: #nonBrowsable) not])
				ifTrue: 
					[| aspect |
					aspect := (each value: self withArguments: #()) newAspect: each selector class: Aspect.
					(aspect canWriteInto: self) ifFalse: [aspect beReadOnly].
					aspects add: aspect]].
	^aspects!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| aspects |
	aspects := self class publishedAspectsOfInstances.
	^(aspects isEmpty or: 
			[aspects size = 1 and: 
					[| aspect |
					aspect := aspects lookup: #yourself.
					aspect notNil and: [aspect editBlock isNil]]])
		ifTrue: [self publicAccessorAspects]
		ifFalse: [aspects]!

publishedEvents
    	"Answer a Set of Symbols that describe the published events triggered
    	by the receiver."
    
    	^self class publishedEventsOfInstances
    !

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForObject: self! !

!Core.Object categoriesForMethods!
alternateInspectorClass!constants!public! !
aspectDisplayOn:!private! !
basicInspect!public! !
browse!commands!public! !
currentPublishedAspectsAsLiteralsMap!constants!public! !
debugPrintOn:!printing!public! !
debugPrintString!printing!public! !
halt!public! !
inspect!public! !
inspectorClass!constants!public! !
newAspect:class:!constants!public! !
publicAccessorAspects!constants!public! !
publishedAspects!constants!public! !
publishedEvents!events!public! !
searchForInTool:!public! !
!

!Core.Object class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Overridden by subclasses to add the aspects 	published locally"

	^IdentityDictionary new
		add: ((self newAspect: #yourself class: Aspect)
					beNonNullable;
					type: Class;
					yourself);
		yourself!

publishedAspectsOfInstances
	"Answer a LookupTable of AspectDescriptors that describe the aspects published
    	by an instance of the receiver. Overridden by subclasses to add the aspects
    	published locally.
    	N.B. All #publishedAspectsOfInstances methods must be placed in either the 'must strip'
    	or 'development' categories so that they are removed before package pre-requisites are 
    	calculated by the ImageStripper, otherwise the Development System may be a pre-requisite."

	^(IdentityDictionary new: (self instSize + 1) * 2)
		add: ((self newInstanceAspect: #yourself class: Aspect)
					type: self;
					yourself);
		yourself!

publishedEvents
	"Answer a Set of Symbols that describe the published events triggered
    	by the receiver. Overridden by subclasses to add the events published 
    	locally"

	^Set new!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver. Overridden by subclasses to add the events published 
    	locally"

	^Set new! !

!Core.Object class categoriesForMethods!
publishedAspects!constants!public! !
publishedAspectsOfInstances!constants!public! !
publishedEvents!events!public! !
publishedEventsOfInstances!events!public! !
!

!Core.Process methodsFor!

attachDebugger: titleString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a debugger on the receiver with the specified
	frame as that shown at the top of the stack trace."

	self debuggerClass 
		show: titleString
		process: self 
		topFrame: aStackFrame
		resumable: aBoolean!

debug
	"Private - Bring up a debugger on the receiver."

	self
		debug: self printString
		topFrame: self topFrame sender
		resumable: self isTerminated not!

debug: titleString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a debugger on the receiver with the specified
	frame as that shown at the top of the stack trace. Suspend the active process."

	self attachDebugger: titleString topFrame: aStackFrame resumable: aBoolean.
	debugger suspendProcess.
	"N.B. There MUST be no further code after this point"
!

debuggerClass
	"Answer the class of <Debugger> to use for debugging this process."

	^SmalltalkSystem current debuggerClass!

halt: aStackFrame cause: aString
	"Private - Bring up a Smalltalk debugger on the receiver in the specified frame."

	debugger isNil
		ifTrue: 
			[self
				walkback: aString
				topFrame: aStackFrame
				resumable: true]
		ifFalse: [debugger onHalt: aStackFrame]!

primStep: steps
	"Private - Resume the receiver for a single step (method/block activation), at which point the receiver will receive a debug step interrupt. If the receiver hits a breakpoint instruction before the next method/block activation, then a different interrupt will be received. Other interrupts are disabled while the receiver is stepping."

	"Primitive failure reasons:
    		IllegalStateChange 	- the receiver is waiting on a scheduler or semaphore list (only suspended processes can be 'stepped'
    		AssertionFailure		- the receiver has been terminated.

	Note, however, that primitive failure is ignored."

	<primitive: 105>
	!

showWalkback: titleString callStack: stackTraceString debuggable: debuggableBoolean resumable: resumableBoolean
	"Private - Display a walkback dialog with the specified title and stack trace. Enable/disable
	the debug/resume buttons depending on the boolean arguments. If the Dolphin development 
	system walkback dialog is not available, then use a MessageBox."

	| box response |
	#{WalkbackDialog} ifDefined: 
			[:dialogClass |
			response := dialogClass new
						caption: titleString;
						callStack: stackTraceString;
						debuggable: debuggableBoolean;
						resumable: resumableBoolean;
						showModal.
			response isNil ifFalse: [^response]].
	box := MessageBox new.
	box caption: titleString.
	box beTaskModal.
	resumableBoolean
		ifTrue: 
			[box buttonStyle: #abortRetryIgnore.
			box defaultButton: 2]
		ifFalse: 
			[box buttonStyle: #retryCancel.
			box defaultButton: 1].
	response := box errorMsg: stackTraceString.
	^response == #retry
		ifTrue: [#debug]
		ifFalse: [response == #ignore ifTrue: [#resume] ifFalse: [#terminate]]!

step
    	"Private - Resume the receiver for a single step (method/block activation), at 
    	which point the receiver will receive a debug step interrupt. If the receiver
    	hits a breakpoint instruction before the next method/block activation, then
    	a different interrupt will be received. Other interrupts are disabled while
    	the receiver is stepping.
    
    	For safety (in case sent within a callback from the UI process) we defer the 
    	single step until the current callback has returned to avoid deadlocking the 
    	current UI process."
    
    	self step: 1!

step: steps
	"Private - Resume the receiver for the specified number of steps (method/block 
    	activation), at which point the receiver will receive a debug step interrupt. If 
    	the receiver hits a breakpoint instruction before the next method/block activation, 
    	then a different interrupt will be received. Other interrupts are disabled while
    	the receiver is stepping.
    
    	For safety (in case sent within a callback from the UI process) we defer the 
    	single step until the current callback has returned to avoid deadlocking the 
    	current UI process."

	SessionManager.Current inputState queueDeferredAction: (MessageSend
				receiver: self
				selector: #primStep:
				argument: steps)!

walkback: aString topFrame: aStackFrame resumable: aBoolean
	"Private - Bring up a walkback window on the receiver with the specified title
	and with aStackFrame as the top frame of the stack trace"

	| answer traceStream debuggable titleString |
	Processor enableAsyncEvents: true.
	titleString := aString
				collect: [:each | (each == $\r or: [each == $\n]) ifTrue: [$\] ifFalse: [each]].
	debugger isNil
		ifFalse: 
			[^debugger
				onWalkback: titleString
				topFrame: aStackFrame
				resumable: aBoolean].
	traceStream := String smalltalkWriteStream: 512.
	
	[aStackFrame callstackDo: 
			[:frame |
			frame method selector == #wmPaint:wParam:lParam:
				ifTrue: [frame receiver validate	"prevent recusive paint walkback"].
			traceStream
				display: frame;
				cr]
		depth: 50]
			on: Error
			do: [:e | e notify].

	"Only show a walkback if the Debugger's global option, #showWalkbacks, is on"
	debuggable := self canDebug.
	answer := (debuggable not or: [self debuggerClass showWalkbacks])
				ifTrue: 
					[self
						showWalkback: titleString
						callStack: traceStream contents
						debuggable: debuggable
						resumable: aBoolean]
				ifFalse: 
					[aBoolean ifTrue: [Sound warningBeep] ifFalse: [Sound errorBeep].
					#debug].
	answer == #debug
		ifTrue: 
			[
			[self
				debug: titleString
				topFrame: aStackFrame
				resumable: aBoolean]
					postToMessageQueue.
			self suspendUnconditionally]
		ifFalse: [answer == #terminate ifTrue: [self terminate]]
	"Drop through to resume..."! !

!Core.Process categoriesForMethods!
attachDebugger:topFrame:resumable:!private! !
debug!private! !
debug:topFrame:resumable:!private! !
debuggerClass!constants!public! !
halt:cause:!private! !
primStep:!private!states-changing! !
showWalkback:callStack:debuggable:resumable:!private! !
step!private!states-changing! !
step:!private!states-changing! !
walkback:topFrame:resumable:!private! !
!

!Core.SearchPolicy class methodsFor!

method
	"Answer the singleton sub-instance of the receiver which supports a search policy based appropriate for CompiledMethods."

	^CompiledMethodSearchPolicy current! !

!Core.SearchPolicy class categoriesForMethods!
method!instance creation!public! !
!

!Core.Semaphore methodsFor!

debugPrintOn: aStream
	self printOn: aStream! !

!Core.Semaphore categoriesForMethods!
debugPrintOn:!printing!public! !
!

!Core.SequenceableCollection methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^SequenceableCollectionInspector!

newBatchAccessor
	^KeyedAspectBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize! !

!Core.SequenceableCollection categoriesForMethods!
alternateInspectorClass!constants!public! !
newBatchAccessor!public! !
!

!Core.SequenceableCollection class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass sequenceableCollection: aSymbol! !

!Core.SequenceableCollection class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.SessionManager class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #sessionStopped;
    		add: #imageSaveCompleted;
    		add: #'sessionStarted';
    		add: #imageSaveStarting;
		add: #queryEndSession:;
    		yourself.
    ! !

!Core.SessionManager class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!Core.Set methodsFor!

averageProbesPerElement
	"Answer the average number of probes necessary to  find an element 
	in the receiver. Ideally this should be close to 1."

	| probes capacity |
	self isEmpty ifTrue: [^1].
	probes := 0.
	capacity := self basicSize.
	1 to: capacity
		do: 
			[:i | 
			| element |
			element := self basicAt: i.
			element notNil 
				ifTrue: 
					[| pos distance |
					pos := self bestSlotFor: element boundedBy: capacity.
					distance := i - pos.
					distance < 0 ifTrue: [distance := distance + capacity].
					probes := probes + distance + 1]].
	^probes asFloat / self size!

bestSlotFor: element boundedBy: capacity
	^self hash: element max: capacity!

collisions
	"Answer the <Integer> number of the elements which are not found
	on first probe."

	| answer capacity |
	answer := 0.
	capacity := self basicSize.
	1 to: capacity
		do: 
			[:i | 
			| element |
			element := self basicAt: i.
			element notNil 
				ifTrue: 
					[(self hash: element max: capacity) ~= i ifTrue: [answer := answer + 1]]].
	^answer!

newBatchAccessor
	^SetBatchAspectAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize!

printOn: aPuttableStream
	"Print a string representation of self on aStream. This method suffices for most collections, and is able to handle cyclic references."

	self isSelfEvaluating
		ifTrue: [self printSelfEvaluatingOn: aPuttableStream]
		ifFalse: [super printOn: aPuttableStream]!

printSelfEvaluatingOn: aStream
	tally == 0
		ifTrue: 
			[aStream
				print: self class;
				space;
				nextPutAll: #new.
			^self].
	aStream
		nextPut: $(;
		print: self class;
		space.
	tally == 1
		ifTrue: 
			[aStream
				nextPutAll: #with:;
				space;
				print: self anyOne;
				nextPut: $)]
		ifFalse: 
			[aStream
				nextPutAll: #withAll:;
				space;
				print: (self sortSelfEvaluatingElements: self asArray locale: aStream locale);
				nextPut: $)]!

sortSelfEvaluatingElements: anArray locale: aLocale
	"Private - We want the elements printed in a stable order, e.g. so that if in source code we don't get gratuitous diffs occurring. We use the natural sort order of the elements if possible (generally this is true for self-evaluating forms in source), but if not we sort by the printed order of the source representation. As we want the order to be stable, we use case-sensitive comparison."

	^[anArray sort: [:a :b | a <==> b <= 0]] on: Error
		do: 
			[:ex |
			| stream |
			"Very unlikely we'll get here, but if the elements are heterogenous or don't respond to #<==>, sort them according to their printString representation"
			stream := String writeStream
						locale: aLocale;
						yourself.
			anArray sort: 
					[:a :b |
					| ap bp |
					stream reset.
					a printOn: stream.
					ap := stream contents.
					stream reset.
					b printOn: stream.
					bp := stream contents.
					ap <==> bp <= 0]]!

stats
	^{self size. self basicSize. self averageProbesPerElement. self collisions}! !

!Core.Set categoriesForMethods!
averageProbesPerElement!development!public!statistics! !
bestSlotFor:boundedBy:!development!private!statistics! !
collisions!development!public!statistics! !
newBatchAccessor!private! !
printOn:!printing!public! !
printSelfEvaluatingOn:!printing!private! !
sortSelfEvaluatingElements:locale:!printing!private! !
stats!development!public!statistics! !
!

!Core.Set class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass set: aSymbol! !

!Core.Set class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Stream methodsFor!

debugPrint: anObject
	"Ask anObject to append its textual description to the receiver"

	anObject debugPrintOn: self! !

!Core.Stream categoriesForMethods!
debugPrint:!printing!public! !
!

!Core.String methodsFor!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representation of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to keep to a reasonable length and stop at the first line delimiter.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."

	| count max charStream |
	aStream nextPut: $'.
	max := self size min: Aspect maxDisplayCharacters - 2.
	charStream := self readStream.
	count := 0.
	[charStream atEnd or: [count >= max]] whileFalse: 
			[| ch |
			ch := charStream next.
			(ch == $\r or: [ch == $\n])
				ifTrue: 
					["Stop at line delimiter"
					count := max]
				ifFalse: [aStream nextPut: ch].
			count := count + 1].
	charStream atEnd ifFalse: [aStream nextPutAll: ' …'].
	aStream nextPut: $'!

debugPrintOn: aStream
	self printOn: aStream!

literalTextStyle
	^#literalString!

newAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(self size > 80 or: [self identityIncludes: Character cr])
		ifTrue: [aspectClass multilineString: aSymbol]
		ifFalse: [aspectClass string: aSymbol]!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	"Implementation Note: Override because we want the receiver to be treated
	purely as a string, rather than as a collection of characters."

	^LookupTable with: (self newAspect: #yourself class: Aspect)! !

!Core.String categoriesForMethods!
aspectDisplayOn:!private! !
debugPrintOn:!printing!public! !
literalTextStyle!constants!private! !
newAspect:class:!adapters!private! !
publishedAspects!constants!public! !
!

!Core.Symbol methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to keep to use the printString format."
  
  	self printOn: aStream!

literalTextStyle
	^#literalSymbol!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForSymbol: self! !

!Core.Symbol categoriesForMethods!
aspectDisplayOn:!private! !
literalTextStyle!constants!private! !
searchForInTool:!public! !
!

!Core.Symbol class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol) beImmutable! !

!Core.Symbol class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.Time class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass time: aSymbol! !

!Core.Time class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Core.UndefinedObject methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats. In this case we want to use #printOn: because nil displays as nothing.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."
  
  	self printOn: aStream!

literalTextStyle
	^#literalPseudo! !

!Core.UndefinedObject categoriesForMethods!
aspectDisplayOn:!private! !
literalTextStyle!constants!private! !
!

!Core.WeakSet class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #elementsExpired:;
    		yourself.
    ! !

!Core.WeakSet class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!External.AbstractCHARField methodsFor!

characterCreationMessage
	^self subclassResponsibility!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <CodeGenerationContext> which will read the value of this field from an instance of the structure."

	| stream |
	stream := aCodeGenerationContext writeStream.
	stream nextPut: $(.
	aCodeGenerationContext printClass: Character.
	stream
		space;
		display: self characterCreationMessage;
		space;
		nextPutAll: '(bytes ';
		display: self accessorMessage keywords first;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	stream nextPutAll: '))'!

printMutatorValueOn: aCodeGenerationContext parameter: aString
	"Private - Print a suitable expression onto the specified <CodeGenerationContext> which will evaluate to the value to be stored into this field in an instance of the structure when compiled into a mutator method where the value parameter is named by the <String> argument."

	aCodeGenerationContext writeStream
		nextPutAll: aString;
		space;
		display: #codePoint! !

!External.AbstractCHARField categoriesForMethods!
characterCreationMessage!automatic generation!private! !
printAccessorExpression:on:!automatic generation!private! !
printMutatorValueOn:parameter:!automatic generation!development!private! !
!

!External.ArrayField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	"We need to set the length of the array"

	aCodeGenerationContext writeStream
		space;
		display: #length:;
		space.
	arrayLength printElementCountExpressionFor: self on: aCodeGenerationContext!

printElementSizeExpressionBodyOn: aCodeGenerationContext
	aCodeGenerationContext printClass: self arrayClass.
	aCodeGenerationContext writeStream
		space;
		display: #elementSize!

printFieldSizeExpressionBodyOn: aCodeGenerationContext
	arrayLength printElementCountExpressionFor: self on: aCodeGenerationContext.
	aCodeGenerationContext writeStream nextPutAll: ' * '.
	self isFixedSize
		ifTrue: [self printElementSizeExpressionBodyOn: aCodeGenerationContext]
		ifFalse: [self printStaticElementSizeExpressionOn: aCodeGenerationContext]!

printFieldSizeExpressionOn: aCodeGenerationContext
	self isFixedSize
		ifTrue: 
			[self emitStaticExpression: [:context | self printFieldSizeExpressionBodyOn: context]
				on: aCodeGenerationContext]
		ifFalse: [self printFieldSizeExpressionBodyOn: aCodeGenerationContext]!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContext> which will write the value of this field into an instance of the structure."

	| stream keywords valueParam |
	stream := aCodeGenerationContext writeStream.
	valueParam := self valueParameterName.
	stream
		nextPutAll: '| size |';
		crtab;
		nextPutAll: 'size := (';
		nextPutAll: valueParam;
		space;
		display: #byteSize.
	"Null terminator is included in the reported byteSize, but not the size/basicSize"
	self arrayClass isNullTerminated
		ifTrue: 
			[stream nextPutAll: ' - '.
			self printStaticElementSizeExpressionOn: aCodeGenerationContext].
	self isFixedSize
		ifTrue: 
			[stream
				nextPutAll: ') ';
				display: #min:;
				nextPutAll: ' ('.
			self printFieldSizeExpressionOn: aCodeGenerationContext].
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	stream
		nextPutAll: ').';
		crtab;
		nextPutAll: valueParam;
		space;
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self
		printOffsetExpression: aSymbol
		on: aCodeGenerationContext
		extra: [:context | context writeStream print: 1].
	stream
		space;
		display: keywords third;
		space.
	self offset = 0
		ifFalse: 
			[self printOffsetExpression: aSymbol on: aCodeGenerationContext.
			stream nextPutAll: ' + '].
	stream
		nextPutAll: 'size ';
		display: keywords fourth;
		nextPutAll: ' 1.';
		crtab.
	arrayLength printSetSizeFor: self on: aCodeGenerationContext!

printStaticElementSizeExpressionOn: aCodeGenerationContext
	self emitStaticExpression: [:context | self printElementSizeExpressionBodyOn: context]
		on: aCodeGenerationContext! !

!External.ArrayField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
printElementSizeExpressionBodyOn:!automatic generation!private! !
printFieldSizeExpressionBodyOn:!automatic generation!private! !
printFieldSizeExpressionOn:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
printStaticElementSizeExpressionOn:!automatic generation!private! !
!

!External.ArrayPointerField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to
	configure the object being read from the structure instance."

	"We need to set the length of the array"

	aCodeGenerationContext writeStream
		space;
		display: #length:;
		space.
	arrayLength printElementCountExpressionFor: self on: aCodeGenerationContext!

printMutatorBody: aSymbol on: aCodeGenerationContext
	super printMutatorBody: aSymbol on: aCodeGenerationContext.
	aCodeGenerationContext writeStream
		nextPut: $.;
		crtab.
	arrayLength printSetSizeFor: self on: aCodeGenerationContext! !

!External.ArrayPointerField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
!

!External.BOOLField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass boolean: aSymbol!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	aCodeGenerationContext writeStream
		space;
		display: #asBoolean!

printMutatorValueOn: aCodeGenerationContext parameter: aString
	"Private - Print a suitable expression onto the specified <CodeGenerationContext> which will evaluate to the value to be stored into this field in an instance of the structure when compiled into a mutator method where the value parameter is named by the <String> argument."

	aCodeGenerationContext writeStream
		nextPutAll: aString;
		space;
		display: #asParameter! !

!External.BOOLField categoriesForMethods!
newAspect:class:!adapters!private! !
printAccessorExpressionSuffixOn:!automatic generation!private! !
printMutatorValueOn:parameter:!automatic generation!development!private! !
!

!External.BOOLField class methodsFor!

icon
	^Boolean icon! !

!External.BOOLField class categoriesForMethods!
icon!public! !
!

!External.CHARField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#uint8AtOffset:put:!

characterCreationMessage
	^#ansiValue:! !

!External.CHARField categoriesForMethods!
accessorMessage!constants!private! !
characterCreationMessage!automatic generation!private! !
!

!External.DOUBLE class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !

!External.DOUBLE class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!External.DOUBLEField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol! !

!External.DOUBLEField categoriesForMethods!
newAspect:class:!adapters!private! !
!

!External.EmbeddedField methodsFor!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which will read the value of this field from an instance of the structure."

	"Note that if returning an External.Structure subclass, then the resulting object will be a reference (an alias) to the original structure embedded in the contents of the receiving External.Structure, and therefore modifications to it will also modify the complete External.Structure. If, however, the structureClass is some other object which responds to #fromAddress:, the answer may be a copy of the embedded structure (e.g. subclasses of External) - so care is needed when updating the result."

	| stream |
	stream := aCodeGenerationContext writeStream.
	aCodeGenerationContext printClass: self valueType.
	stream
		nextPutAll: ' fromAddress: (';
		nextPutAll: 'bytes';
		nextPutAll: ' yourAddress'.
	self offset = 0
		ifFalse: 
			[stream
				space;
				display: #+;
				space.
			self printOffsetExpression: aSymbol on: aCodeGenerationContext].
	stream nextPut: $)!

printStructClassSize: aStructureClass on: aCodeGenerationContext
	aCodeGenerationContext printClass: aStructureClass.
	aCodeGenerationContext writeStream
		nextPutAll: '._';
		nextPutAll: aStructureClass unqualifiedName;
		nextPutAll: '_Size'! !

!External.EmbeddedField categoriesForMethods!
printAccessorExpression:on:!automatic generation!private! !
printStructClassSize:on:!automatic generation!private! !
!

!External.ExternalArray methodsFor!

printElement: anObject on: aStream
	anObject printOn: aStream!

printElementsOn: aStream
	self do: [:each | self printElement: each on: aStream] separatedBy: [aStream space]!

printEvaluationOn: aStream
	aStream
		nextPut: $(;
		print: self class;
		nextPutAll: ' withAll: #('.
	self printElementsOn: aStream.
	aStream nextPutAll: '))'!

printOn: aStream
	"Print a string representation of self on aStream."

	self isSelfEvaluating
		ifTrue: [self printEvaluationOn: aStream]
		ifFalse: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self isNull ifTrue: [aStream nextPutAll: 'NULL'] ifFalse: [self printElementsOn: aStream].
			aStream nextPut: $)]!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	| batchAccessor keyedAspects |
	batchAccessor := KeyedAspectBatchAccessor subject: self
				batchSize: self publishedKeyedAspectsBatchSize.
	keyedAspects := batchAccessor getBatchAccessors collect: [:each | each aspectDescriptor].
	^LookupTable new
		addAll: keyedAspects;
		yourself!

publishedKeyedAspectsBatchSize
    	"Private - Answers the number of keyed aspects to display in the PAI return at a time"
    
    	^100
    ! !

!External.ExternalArray categoriesForMethods!
printElement:on:!printing!private! !
printElementsOn:!printing!private! !
printEvaluationOn:!printing!private! !
printOn:!printing!public! !
publishedAspects!constants!public! !
publishedKeyedAspects!constants!public! !
publishedKeyedAspectsBatchSize!constants!private! !
!

!External.ExternalArray class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass sequenceableCollection: aSymbol!

shouldOverrideGetFieldNames
	^false! !

!External.ExternalArray class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
shouldOverrideGetFieldNames!compiling!private! !
!

!External.ExternalMethod methodsFor!

isSimpleSelfSend: aSymbol
	"Private - Answer whether the receiver is a method that just sends the specified selector (which must be zero-argument) to self. Note that this does not work for special selectors such as #class, #new, etc, that have specific bytecode encodings."

	^false! !

!External.ExternalMethod categoriesForMethods!
isSimpleSelfSend:!private!testing! !
!

!External.ExternalMethod class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #descriptor) beReadOnly;
		yourself! !

!External.ExternalMethod class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!External.Field methodsFor!

autoGenCategories
	^{External.Structure autoGenCategory. self isNonBrowsable ifTrue: ['private'] ifFalse: ['public']}!

autoGenComment
	"Private - Answer a suitable piece of comment to warn the user that a
	method is automatically generated and should not be modified.
	Implementation Note: As of v2.2 this is empty by default as otherwise
	it tends to lead to rather bloated source files."

	^''!

emitStaticExpression: operation on: aCodeGenerationContext
	aCodeGenerationContext writeStream nextPutAll: '##('.
	operation value: aCodeGenerationContext.
	aCodeGenerationContext writeStream nextPut: $)!

makeInstanceName: className
	^(className first isVowel ifTrue: ['an'] ifFalse: ['a']) , className!

printAccessor: aSymbol on: aCodeGenerationContext
	| remark stream |
	stream := aCodeGenerationContext writeStream.
	stream
		nextPutAll: aSymbol;
		crtab;
		nextPut: $".
	self isNonBrowsable ifTrue: [stream nextPutAll: 'Private - '].
	stream nextPutAll: 'Answer the <'.
	aCodeGenerationContext printClass: self valueType.
	stream
		nextPutAll: '> value of the receiver''s ''';
		display: aSymbol;
		nextPutAll: ''' field.'.
	remark := self autoGenComment.
	remark notEmpty
		ifTrue: 
			[stream
				crtab;
				nextPutAll: remark].
	stream
		nextPut: $";
		cr;
		crtab.
	self printAccessorBody: aSymbol on: aCodeGenerationContext!

printAccessorBody: aSymbol on: aCodeGenerationContext
	"Private - Print suitable method text for compiling a read-accessor method to substitute for the receiver (does not include the selector) on the <CodeGenerationContext> argument."

	aCodeGenerationContext writeStream nextPut: $^.
	self printAccessorExpression: aSymbol on: aCodeGenerationContext.
	self printAccessorExpressionSuffixOn: aCodeGenerationContext!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <CodeGenerationContext> which will read the value of this field from an instance of the structure."

	^self subclassResponsibility!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	"By default, nothing is needed."

	!

printMutator: aSymbol on: aCodeGenerationContext
	| stream fieldName remark paramName |
	stream := aCodeGenerationContext writeStream.
	fieldName := aSymbol allButLast asSymbol.
	paramName := self valueParameterName.
	stream
		nextPutAll: aSymbol;
		space;
		nextPutAll: paramName;
		crtab;
		nextPutAll: '"Set the receiver''s ''';
		display: fieldName;
		nextPutAll: ''' field to the value of the argument, ';
		nextPutAll: paramName.
	remark := self autoGenComment.
	remark notEmpty
		ifTrue: 
			[stream
				crtab;
				nextPutAll: remark].
	stream
		nextPut: $";
		cr;
		crtab.
	self printMutatorBody: fieldName on: aCodeGenerationContext!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContest> which will write the value of this field into an instance of the structure."

	^self subclassResponsibility!

printOffsetExpression: aSymbol on: aCodeGenerationContext
	self
		printOffsetExpression: aSymbol
		on: aCodeGenerationContext
		extra: nil!

printOffsetExpression: aSymbol on: aCodeGenerationContext extra: aMonadicValuable
	aMonadicValuable isNil
		ifTrue: 
			[aCodeGenerationContext writeStream
				nextPutAll: External.Structure fieldOffsetConstantPrefix;
				display: aSymbol]
		ifFalse: 
			[self emitStaticExpression: 
					[:context |
					context writeStream
						nextPutAll: External.Structure fieldOffsetConstantPrefix;
						display: aSymbol;
						nextPutAll: ' + '.
					aMonadicValuable value: context]
				on: aCodeGenerationContext]!

valueParameterName
	"Private - Answer the name to use for the value parameter of a setter method generated for
	the field described by the receiver."

	^self makeInstanceName: self valueType name! !

!External.Field categoriesForMethods!
autoGenCategories!private! !
autoGenComment!constants!private! !
emitStaticExpression:on:!automatic generation!private! !
makeInstanceName:!automatic generation!private! !
printAccessor:on:!automatic generation!private! !
printAccessorBody:on:!automatic generation!private! !
printAccessorExpression:on:!automatic generation!private! !
printAccessorExpressionSuffixOn:!automatic generation!private! !
printMutator:on:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
printOffsetExpression:on:!automatic generation!private! !
printOffsetExpression:on:extra:!automatic generation!private! !
valueParameterName!automatic generation!constants!private! !
!

!External.FillerField methodsFor!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <CodeGenerationContext> which will read the value of this field from an instance of the structure."

	^self shouldNotImplement!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContext> which will write the value of this field into an instance of the structure."

	^self shouldNotImplement! !

!External.FillerField categoriesForMethods!
printAccessorExpression:on:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
!

!External.FLOAT class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass float: aSymbol! !

!External.FLOAT class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!External.FLOATArray methodsFor!

printElement: each on: aStream
	"Private - Print the <Float> argument as if an element of the receiver (i.e. a single-precision float), in a format appropriate for a developer. In this case we want to print the number as it is represented, not necessarily as originally expressed. There is very limited definite decimal precision in a 32-bit float (6 digits only), but some numbers (e.g. binary fractions) can be represented precisely up to nine significant figures.
	If an IEEE 754 single-precision number is converted to a decimal string with at least 9 significant digits, and then converted back to single-precision representation, the final result will match the original number."

	^each printOn: aStream significantFigures: 9! !

!External.FLOATArray categoriesForMethods!
printElement:on:!printing!private! !
!

!External.FLOATField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol! !

!External.FLOATField categoriesForMethods!
newAspect:class:!adapters!private! !
!

!External.HANDLEField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to
	configure the object being read from the structure instance."

	aCodeGenerationContext writeStream
		space;
		display: #asExternalHandle! !

!External.HANDLEField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
!

!External.INTEGER methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull
		ifTrue: [aStream nextPut: $0]
		ifFalse: 
			[self isSigned
				ifTrue: [aStream print: self value]
				ifFalse: 
					[self value
						printOn: aStream
						base: 16
						showRadix: true]].
	aStream nextPut: $)! !

!External.INTEGER categoriesForMethods!
printOn:!printing!public! !
!

!External.INTEGER class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol! !

!External.INTEGER class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!External.IntegerBytes methodsFor!

debugPrintOn: aStream
	self printOn: aStream!

publishedKeyedAspects
	"Answers a LookupTable of the published aspects of the receiver's keyed contents"

	^LookupTable new! !

!External.IntegerBytes categoriesForMethods!
debugPrintOn:!printing!public! !
publishedKeyedAspects!constants!public! !
!

!External.IntegerBytes class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol! !

!External.IntegerBytes class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!External.LPVOIDField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass name: aSymbol!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	aCodeGenerationContext writeStream
		space;
		display: #asExternalAddress! !

!External.LPVOIDField categoriesForMethods!
newAspect:class:!adapters!private! !
printAccessorExpressionSuffixOn:!automatic generation!private! !
!

!External.POINTArray methodsFor!

printEvaluationOn: aStream
	aStream
		nextPut: $(;
		print: self class;
		nextPutAll: ' withAll: {'.
	self do: [:each | self printElement: each on: aStream] separatedBy: [aStream nextPutAll: '. '].
	aStream nextPutAll: '})'! !

!External.POINTArray categoriesForMethods!
printEvaluationOn:!printing!private! !
!

!External.PointerField methodsFor!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <puttableStream> which will read the value of this field from an instance of the structure."

	| stream |
	aCodeGenerationContext printClass: self pointerClass.
	stream := aCodeGenerationContext writeStream.
	stream
		space;
		display: #fromAddress:;
		nextPutAll: ' (bytes ';
		display: #intPtrAtOffset:;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	stream nextPut: $)!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContest> which will write the value of this field into an instance of the structure."

	| stream keywords |
	keywords := #uintPtrAtOffset:put: keywords.
	stream := aCodeGenerationContext writeStream.
	stream
		nextPutAll: 'bytes ';
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	stream
		space;
		display: keywords second;
		space;
		nextPutAll: self valueParameterName;
		space;
		display: #yourAddress! !

!External.PointerField categoriesForMethods!
printAccessorExpression:on:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
!

!External.RECT methodsFor!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	self isNull ifTrue: [^super printOn: aStream].
	aStream
		basicPrint: self;
		nextPut: $(;
		print: self topLeft;
		nextPutAll: ', ';
		print: self bottomRight;
		nextPut: $)! !

!External.RECT categoriesForMethods!
printOn:!printing!public! !
!

!External.SCALAR class methodsFor!

shouldOverrideGetFieldNames
	^false! !

!External.SCALAR class categoriesForMethods!
shouldOverrideGetFieldNames!compiling!private! !
!

!External.ScalarField methodsFor!

newAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass integer: aSymbol!

printAccessorExpression: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statement onto the specified <CodeGenerationContext> which will read the value of this field from an instance of the structure."

	aCodeGenerationContext writeStream
		nextPutAll: '(bytes ';
		display: self accessorMessage keywords first;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	aCodeGenerationContext writeStream nextPut: $)!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContext> which will write the value of this field into an instance of the structure."

	| stream keywords |
	stream := aCodeGenerationContext writeStream.
	keywords := self accessorMessage keywords.
	stream
		nextPutAll: 'bytes';
		space;
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	stream
		space;
		display: keywords second;
		space.
	self printMutatorValueOn: aCodeGenerationContext parameter: self valueParameterName!

printMutatorValueOn: aCodeGenerationContext parameter: aString
	"Private - Print a suitable expression onto the specified <CodeGenerationContext> which will
	evaluate to the value to be stored into this field in an instance of the structure when
	compiled into a mutator method where the value parameter is named by the <String> argument."

	aCodeGenerationContext writeStream nextPutAll: aString! !

!External.ScalarField categoriesForMethods!
newAspect:class:!adapters!private! !
printAccessorExpression:on:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
printMutatorValueOn:parameter:!automatic generation!development!private! !
!

!External.ScalarField class methodsFor!

icon
	^Integer icon! !

!External.ScalarField class categoriesForMethods!
icon!public! !
!

!External.StringField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	"If the length of the field is fixed, then assume we are reading a null-terminated string."

	self isFixedSize ifFalse: [super printAccessorExpressionSuffixOn: aCodeGenerationContext]!

printElementSizeExpressionBodyOn: aCodeGenerationContext
	aCodeGenerationContext writeStream display: self arrayClass elementSize!

printFieldSizeExpressionOn: aCodeGenerationContext
	| charSize |
	charSize := self arrayClass elementSize.
	charSize > 1
		ifTrue: 
			[self emitStaticExpression: 
					[:context |
					context writeStream
						display: self allocationLength;
						nextPutAll: ' * ';
						display: charSize]
				on: aCodeGenerationContext]
		ifFalse: [aCodeGenerationContext writeStream display: self allocationLength]!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Print a suitable statement or statements onto the specified <CodeGenerationContext> which will write the value of this field into an instance of the structure."

	"Implementation Note: In this case we overwrite the embedded String, not forgetting to Null Terminate it"

	| keywords stream |
	super printMutatorBody: aSymbol on: aCodeGenerationContext.
	stream := aCodeGenerationContext writeStream.
	stream nextPutAll: 'bytes '.
	keywords := (self elementSize == 2 ifTrue: [#uint16AtOffset:put:] ifFalse: [#uint8AtOffset:put:])
				keywords.
	stream
		display: keywords first;
		space.
	self printOffsetExpression: aSymbol on: aCodeGenerationContext.
	stream
		nextPutAll: ' + size ';
		display: keywords second;
		space;
		nextPut: $0!

printStaticElementSizeExpressionOn: aCodeGenerationContext
	self printElementSizeExpressionBodyOn: aCodeGenerationContext! !

!External.StringField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
printElementSizeExpressionBodyOn:!automatic generation!private! !
printFieldSizeExpressionOn:!automatic generation!private! !
printMutatorBody:on:!automatic generation!private! !
printStaticElementSizeExpressionOn:!automatic generation!private! !
!

!External.StringField class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass string: aSymbol! !

!External.StringField class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!External.Structure methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^StructureInspector!

printableFields
	^self getValidFields!

printFields: aCollection on: aStream
	| sep |
	sep := [sep := [aStream space]].
	aCollection do: 
			[:each |
			(self isFieldBrowsable: each)
				ifTrue: 
					[sep value.
					aStream
						display: each;
						nextPut: $=;
						print: (self getField: each)]]!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	self printFields: self printableFields on: aStream!

printOn: aStream
	"Append a textual representation of the receiver to aStream.
	We use the template definition to do this in a generic way for all correctly 
	defined subclasses. Fields are printed in the order of their offset"

	aStream visit: self
		do: 
			[self basicPrintOn: aStream.
			aStream nextPut: $(.
			self printFieldsOn: aStream.
			aStream nextPut: $)]!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	self isNull
		ifFalse: 
			[self getValidFields do: 
					[:each |
					| field |
					field := self template at: each.
					field isBrowsable ifTrue: [aspects add: (field newAspect: each class: Aspect)]]].
	^aspects! !

!External.Structure categoriesForMethods!
alternateInspectorClass!constants!public! !
printableFields!printing!private! !
printFields:on:!printing!private! !
printFieldsOn:!printing!private! !
printOn:!printing!public! !
publishedAspects!accessing!public! !
!

!External.Structure class methodsFor!

autoGenCategory
	"Private - Answer the name of the <MethodCategory> into which the auto-generated 
	structure accessors for the receiver should be compiled."

	^'**compiled accessors**'!

compileAllDefinitions
	"Compile the definitions of the receiver and all its subclasses"

	self withAllSubclassesDo: [:each | each compileDefinition].
!

compileByteSize
	"Private - Define a #byteSize method for the structure class that returns a constant."

	| methodText constName |
	constName := self sizeConstantName.
	(self definesClassVariable: constName) ifFalse: [^self].
	methodText := String smalltalkWriteStream: 256.
	methodText
		nextPutAll: #byteSize;
		crtab;
		nextPut: $^;
		nextPutAll: constName.
	self class compile: methodText contents categories: { 'constants'. 'public'. self autoGenCategory }!

compileDefinition
	"Builds a new template and generates compiled methods for accessing the fields 
	described by it. Depending on the description held in each field, some accessor
	methods may be left as uncompiled to be addressed via the template and 
	#doesNotUnderstand:"

	self
		newTemplate;
		defineTemplate;
		recompileDefinition!

compileGetFieldNames
	"Private - Define a #getFieldList method for the structure class so that the field names are available even if the template is removed."

	| methodText |
	self shouldOverrideGetFieldNames ifFalse: [^self].
	methodText := String smalltalkWriteStream: 256.
	methodText
		nextPutAll: #getFieldNames;
		crtab;
		nextPutAll: '^#('.
	self fieldNamesFromTemplate do: [:each | methodText print: each] separatedBy: [methodText space].
	methodText nextPut: $).
	self class compile: methodText contents categories: {'constants'. 'private'. self autoGenCategory}!

compileGetMethod: aSymbol forField: anExternalField
	"Private - Generate a compiled 'get' accessor method for the selector aSymbol 
	and field definition anExternalField."

	| context |
	anExternalField canGenerateAccessor ifFalse: [^self].
	context := self newCodeGenerationContext.
	anExternalField printAccessor: aSymbol on: context.
	self formatAndCompile: context contents categories: anExternalField autoGenCategories!

compileNewFields
	self definesNewFields ifFalse: [^self].
	self template keysAndValuesDo: 
			[:getSelector :field |
			field isReadable
				ifTrue: 
					[(self
						shouldCompile: getSelector
						forField: field
						named: getSelector) ifTrue: [self compileGetMethod: getSelector forField: field]].
			field isWriteable
				ifTrue: 
					[| setSelector |
					setSelector := (getSelector , ':') asSymbol.
					(self
						shouldCompile: setSelector
						forField: field
						named: getSelector) ifTrue: [self compileSetMethod: setSelector forField: field]]]!

compileSetMethod: aSelector forField: anExternalField
	"Private - Generate a compiled 'set' accessor method for the selector aSymbol 
	and field definition, anExternalField"

	| context |
	anExternalField canGenerateMutator ifFalse: [^self].
	context := self newCodeGenerationContext.
	anExternalField printMutator: aSelector on: context.
	self formatAndCompile: context contents categories: anExternalField autoGenCategories!

decompileDefinition
	"Remove generated accessor methods from the receiver. The template will be lazily rebuilt."

	{self. self class}
		do: [:each | [each removeCategory: self autoGenCategory] on: NotFoundError do: [:e | e notify]].
	self hasUncompiledFields: true!

formatAndCompile: aString categories: categories
	| source |
	source := SmalltalkSystem current reformatSource: aString in: self.
	^self compile: source categories: categories!

hasHandCodedMethodFor: selector
	"Private - Answer whether the receiver appears to have a hand coded implementation
	for the specified selector <Symbol>."

	^(self compiledMethodAt: selector ifAbsent: nil)
		ifNil: [false]
		ifNotNil: [:method | (self autoGenCategory asMethodCategory includesMethod: method) not]!

inheritsFieldNamed: aSymbol
	| base |
	base := self superclass.
	^base ~~ Object and: [(base template includesKey: aSymbol) or: [base inheritsFieldNamed: aSymbol]]!

newCodeGenerationContext
	^CodeGenerationContext targetClass: self!

recompileDefinition
	"Private - Recompiles the existing template for the receiver"

	self decompileDefinition.
	self compileNewFields.
	self compileGetFieldNames.
	self compileByteSize!

shouldCompile: selectorSymbol forField: anExternalField named: fieldNameSymbol
	"Private - Answer whether to compile an accessor method
	with the specified selector for the specified field in the
	receiver."

	^anExternalField canGenerateAccessors and: 
			[(self hasHandCodedMethodFor: selectorSymbol) not and: 
					["Don't generate inherited fields unless specifically marked for override"
					anExternalField isOverride or: [(self inheritsFieldNamed: fieldNameSymbol) not]]	"Don't overwrite manually written methods"]!

shouldOverrideGetFieldNames
	^self isNonInstantiable not and: 
			[self definesNewFields and: 
					[| categories |
					categories := self class whichNonVirtualCategoriesIncludeSelector: #getFieldNames.
					(categories isEmpty or: [categories includes: self autoGenCategory asMethodCategory]) and: 
							[| inherited |
							inherited := self superclass class lookupMethod: #getFieldNames.
							inherited methodClass == ##(self) class
								or: [self fieldNamesFromTemplate asSet ~= (inherited literalAt: 1) asSet]]]]! !

!External.Structure class categoriesForMethods!
autoGenCategory!compiling!constants!private! !
compileAllDefinitions!compiling!public! !
compileByteSize!compiling!private! !
compileDefinition!compiling!public! !
compileGetFieldNames!compiling!private! !
compileGetMethod:forField:!compiling!private! !
compileNewFields!compiling!private! !
compileSetMethod:forField:!compiling!private! !
decompileDefinition!compiling!public! !
formatAndCompile:categories:!compiling!private! !
hasHandCodedMethodFor:!compiling!private! !
inheritsFieldNamed:!compiling!private! !
newCodeGenerationContext!compiling!private! !
recompileDefinition!compiling!private! !
shouldCompile:forField:named:!compiling!private! !
shouldOverrideGetFieldNames!compiling!private! !
!

!External.StructureArrayField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aCodeGenerationContext.
	aCodeGenerationContext writeStream
		space;
		display: #elementClass:;
		space.
	aCodeGenerationContext printClass: self fieldClass!

printElementSizeExpressionBodyOn: aCodeGenerationContext
	self printStructClassSize: self elementClass on: aCodeGenerationContext! !

!External.StructureArrayField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
printElementSizeExpressionBodyOn:!automatic generation!private! !
!

!External.StructureArrayPointerField methodsFor!

printAccessorExpressionSuffixOn: aCodeGenerationContext
	"Private - Print any extra messages/statements onto the <CodeGenerationContext> argument that are required to configure the object being read from the structure instance."

	"We need to set the length and element class of the structure array"

	super printAccessorExpressionSuffixOn: aCodeGenerationContext.
	aCodeGenerationContext writeStream
		space;
		display: #elementClass:;
		space.
	aCodeGenerationContext printClass: self elementClass! !

!External.StructureArrayPointerField categoriesForMethods!
printAccessorExpressionSuffixOn:!automatic generation!private! !
!

!External.StructureField methodsFor!

printMutatorBody: aSymbol on: aCodeGenerationContext
	"Private - Answer suitable method text for compiling a write-accessor method to substitute for the receiver (does not include the selector).
	N.B. In this case we overwrite the entire embedded structure with a new one"

	| stream keywords |
	stream := aCodeGenerationContext writeStream.
	keywords := #replaceBytesOf:from:to:startingAt: keywords.
	stream
		nextPutAll: self valueParameterName;
		space;
		display: keywords first;
		nextPutAll: ' bytes ';
		display: keywords second;
		space.
	self
		printOffsetExpression: aSymbol
		on: aCodeGenerationContext
		extra: [:context | context writeStream print: 1].
	stream
		space;
		display: keywords third;
		space.
	self
		printOffsetExpression: aSymbol
		on: aCodeGenerationContext
		extra: [:context | self printStructClassSize: self valueType on: context].
	stream
		space;
		display: keywords fourth;
		space;
		display: 1! !

!External.StructureField categoriesForMethods!
printMutatorBody:on:!automatic generation!private! !
!

!External.StructurePointer methodsFor!

printOn: aStream
	"Print a string representation of self on aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream nextPutAll: 'NULL']
		ifFalse: [aStream print: self value].
	aStream nextPut: $).! !

!External.StructurePointer categoriesForMethods!
printOn:!printing!public! !
!

!External.UInt64 methodsFor!

printOn: aStream
	"Append a debug text representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; display: self; nextPut: $)
! !

!External.UInt64 categoriesForMethods!
printOn:!printing!public! !
!

!External.WCHARField methodsFor!

accessorMessage
	"Private - Answer the receiver's 'accessorStem'."

	^#uint16AtOffset:put:!

characterCreationMessage
	^#utf16Value:! !

!External.WCHARField categoriesForMethods!
accessorMessage!automatic generation!private! !
characterCreationMessage!automatic generation!private! !
!

!Graphics.AbstractFont class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass font: aSymbol! !

!Graphics.AbstractFont class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.Bitmap class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass bitmap: aSymbol! !

!Graphics.Bitmap class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.Color class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass color: aSymbol! !

!Graphics.Color class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.Gdiplus.Image class methodsFor!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol
		presenterBlock: 
			[:p :m |
			| imagePresenter |
			imagePresenter := ImagePresenter
						create: 'Gdiplus view'
						in: p
						on: m.
			imagePresenter view isWholeBackgroundErased: true.
			imagePresenter])
		bePresenterBlockReadOnly;
		yourself! !

!Graphics.Gdiplus.Image class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.Gdiplus.ImageView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect symbol: #interpolationMode from: [self interpolationStyles]);
		add: (Aspect name: #imageAttributes);
		yourself! !

!Graphics.Gdiplus.ImageView class categoriesForMethods!
publishedAspectsOfInstances!must strip!public! !
!

!Graphics.Icon class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass icon: aSymbol! !

!Graphics.Icon class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.Image class methodsFor!

choose
	^(FileOpenDialog new
		fileTypes: self fileTypes;
		showModal)
			ifNotNil: [self fromFile: (FileOpenDialog new
							fileTypes: self fileTypes;
							showModal)]!

fileTypes
	^self filesType
		ifNil: [{UI.FileDialog allFilesType}]
		ifNotNil: [:specific | {specific. UI.FileDialog allFilesType}]!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass image: aSymbol type: self! !

!Graphics.Image class categoriesForMethods!
choose!public! !
fileTypes!constants!public! !
newInstanceAspect:class:!adapters!private! !
!

!Graphics.ImageList class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass imageList: aSymbol! !

!Graphics.ImageList class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Graphics.InternalIcon class methodsFor!

choose
	| filename |
	filename := FileOpenDialog new
				fileTypes: {
							#('PNG Files (*.png)' '*.png').
							#('Icon Files (*.ico)' '*.ico').
							FileDialog allFilesType
						};
				showModal.
	^filename notNil
		ifTrue: 
			[((File splitExtensionFrom: filename) compareOrdinals: 'png' ignoringCase: true) == 0
				ifTrue: [self fromFile: filename]
				ifFalse: [Icon fromFile: filename]]! !

!Graphics.InternalIcon class categoriesForMethods!
choose!public! !
!

!Graphics.Metafile class methodsFor!

fileTypes
	^#(#('EMF (*.emf)' '*.emf') #('WMF (*.wmf)' '*.wmf') #('All Metafiles' '*.emf;*.wmf'))
		, {FileDialog allFilesType}! !

!Graphics.Metafile class categoriesForMethods!
fileTypes!constants!private! !
!

!Graphics.Pen class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect color: #color);
		add: (Aspect integer: #width);
		add: (Aspect
					choice: #styleName
					from: self styleNames
					type: String);
		yourself! !

!Graphics.Pen class categoriesForMethods!
publishedAspectsOfInstances!public! !
!

!Graphics.Point class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #x);
		add: (Aspect integer: #y);
		yourself! !

!Graphics.Point class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Graphics.Point3D class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #x);
		add: (Aspect integer: #y);
		add: (Aspect integer: #z);
		yourself! !

!Graphics.Point3D class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Graphics.Rectangle class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: ((Aspect integer: #top)
					defaultValue: 0;
					yourself);
		add: ((Aspect integer: #left)
					defaultValue: 0;
					yourself);
		add: ((Aspect integer: #bottom)
					defaultValue: 0;
					yourself);
		add: ((Aspect integer: #right)
					defaultValue: 0;
					yourself);
		yourself! !

!Graphics.Rectangle class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Graphics.TextTileIcon class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass icon: aSymbol! !

!Graphics.TextTileIcon class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
!

!Kernel.AbstractChunkSourceFiler class methodsFor!

stlFilerClass
	^STLOutFiler! !

!Kernel.AbstractChunkSourceFiler class categoriesForMethods!
stlFilerClass!constants!public! !
!

!Kernel.BindingReference methodsFor!

browse
	"Open a suitable browser onto the receiver."

	SmalltalkSystem current browseClass: (self bindingOrNil
				ifNil: [self class]
				ifNotNil: [:var | var isClassBinding ifTrue: [var value] ifFalse: [var environment]])! !

!Kernel.BindingReference categoriesForMethods!
browse!commands!public! !
!

!Kernel.BlockClosure methodsFor!

cpuCyclesToRun
	| sem start stop hThread |
	hThread := OS.Kernel32 getCurrentThread.
	start := External.UInt64 new.
	stop := External.UInt64 new.
	sem := Semaphore new.
	
	[
	[OS.Kernel32 queryThreadCycleTime: hThread cycleTime: start.
	self value.
	OS.Kernel32 queryThreadCycleTime: hThread cycleTime: stop]
			ensure: [sem signal]]
			forkAt: Processor userInterruptPriority.
	sem wait.
	^stop value - start value! !

!Kernel.BlockClosure categoriesForMethods!
cpuCyclesToRun!operations!public! !
!

!Kernel.BlockClosure class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects add: (Aspect name: #receiver).
	#(#argumentCount #envTempCount #stackTempCount #initialIP)
		do: [:each | aspects add: ((Aspect integer: each)
						beReadOnly;
						yourself)].
	aspects add: (Aspect name: #method type: CompiledCode).
	^aspects! !

!Kernel.BlockClosure class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Kernel.BlockFrame methodsFor!

debugIpFor: debugMethod 
	^self ip = self block initialIP 
		ifTrue: [
			"We've just stepping into a block"
			self mapInitialIpFrom: self basicMethod to: debugMethod]
		ifFalse: [super debugIpFor: debugMethod]!

isRestartable
    	"Private - Answer whether this frame is restartable."
    
    	^self sender notNil!

makeDebug
	"Private - Convert the receiver to a debug frame. "

	| method debugMethod block |
	method := super makeDebug.
	method
		ifNil: 
			["Already a debug frame"
			^nil].
	debugMethod := self basicMethod.
	block := self block.
	"Debug version of method will have different initialIP for the block, so we must remap"
	block initialIP: (self mapInitialIpFrom: method to: debugMethod).
	"If the block has an outer ref, then assume it may contain a ^-return and
	mutate the home frame and its sender into debug frames so that any ^-return
	would break if stepped into."
	self homeFrame
		ifNotNil: 
			[:home |
			home makeDebug.
			home sender ifNotNil: [:sender | sender makeDebug]].
	^method!

mapInitialIpFrom: aCompiledMethod to: debugCompiledMethod
	| map debugMap |
	map := aCompiledMethod debugInfo textMap.
	debugMap := debugCompiledMethod debugInfo textMap.
	^(debugMap at: (self class findInitialIP: self block initialIP inTextMap: map)) key! !

!Kernel.BlockFrame categoriesForMethods!
debugIpFor:!private! !
isRestartable!private!testing! !
makeDebug!private! !
mapInitialIpFrom:to:!private! !
!

!Kernel.ChunkSourceFiler methodsFor!

printBasicDefinitionOfClass: aClass
	| definitionStream |
	definitionStream := (String writeStream: 384)
				locale: stream locale;
				yourself.
	self printBasicDefinitionOfClass: aClass on: definitionStream.
	definitionStream := definitionStream contents.
	self emitString: (Parser parseExpression: definitionStream) formattedCode! !

!Kernel.ChunkSourceFiler categoriesForMethods!
printBasicDefinitionOfClass:!public!source filing-file out! !
!

!Kernel.ClassBuilder class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #classAdded:;
    		add: #classUpdated:;
    		yourself.
    ! !

!Kernel.ClassBuilder class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!Kernel.CompiledCode methodsFor!

alternateInspectorClass
	^CompiledMethodInspector!

asDebugMethod
    	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."
    
    	^self subclassResponsibility!

decodeHeaderOn: aStream
	"Private - Answer a String describing the method header."

	aStream
		nextPutAll: (#('Normal' 'Return self' 'Return true' 'Return false' 'Return nil' 'Return literal constant 0' 'Return instance variable' 'Set instance variable' 'Return literal static 0')
				at: self extraIndex + 1
				ifAbsent: 'Primitive: ').
	self isPrimitive ifTrue: [aStream print: self primitiveIndex].
	aStream
		nextPutAll: ', ';
		print: self argumentCount;
		nextPutAll: ' args, '.
	self stackTempCount > 0
		ifTrue: 
			[aStream
				print: self stackTempCount;
				nextPutAll: ' stack temps, '].
	self envInfo > 0
		ifTrue: 
			[aStream
				print: self envTempCount;
				nextPutAll: ' env temps, '].
	aStream
		print: self size;
		nextPutAll: ' literals'.
	self needsContext ifTrue: [aStream nextPutAll: ', needs context'].
	self isDebugMethod ifTrue: [aStream nextPutAll: ', debug']!

disassembly
	"Private - Answer a <readableString> disassembly listing for the receiver."

	^SmalltalkSystem current disassembleMethod: self!

hasCompilationIssues
	^
	[self parseTree analyze.
	false] on: Compiler notificationClass
			do: [:ex | ex severityClass == Notification ifTrue: [ex resume] ifFalse: [ex return: true]]!

indexOfIP: ip 
	^self byteCodeDispatcherClass indexOfIP: ip in: self!

isAbstract
	"Answer whether this is an abstract method."

	^self isSimpleSelfSend: #subclassResponsibility!

isDeprecated
	^self methodClass isDeprecated or: [MethodCategory deprecatedMethods includesMethod: self]!

isSimpleSelfSend: aSymbol
	"Private - Answer whether the receiver is a method that just sends the specified selector (which must be zero-argument) to self. Note that this does not work for special selectors such as #class, #new, etc, that have specific bytecode encodings."

	^(byteCodes == ##(self packByteCodes: { ShortSendSelfZeroArgs. ReturnFromMessage } asByteArray)
		or: [byteCodes == ##(self packByteCodes: { ShortSendSelfZeroArgs. PopReturnSelf } asByteArray)])
			and: [(self basicAt: 1) == aSymbol and: [(header bitShift: PrimitiveIndexShift) == 0]]!

mapIp: anInteger toDebug: debugCompiledMethod
	| i interp first map debugMap debugDispatcher debugFirst |
	map := self debugInfo textMap.
	debugMap := debugCompiledMethod debugInfo textMap.
	i := self class findIp: anInteger inTextMap: map.
	i == 0
		ifTrue: [first := debugFirst := 1]
		ifFalse: 
			[first := (map at: i) key.
			debugFirst := (debugMap at: i) key].
	first == anInteger
		ifTrue: 
			["Directly corresponding entry"
			^debugFirst].
	self assert: [first < anInteger].
	"We should have the map entry for the previous sync point (send instruction), and need to step forward from there"
	interp := self byteCodeDispatcher.
	debugDispatcher := debugCompiledMethod byteCodeDispatcher.
	interp ip: first.
	debugDispatcher ip: debugFirst.
	"Note: If there is more than one step here, the results are unreliable. In use from the debugger, this should not happen though, because any release frame should have been suspended just after a send."
	
	[debugDispatcher next.
	(interp
		next;
		ip) == anInteger] whileFalse.
	^debugDispatcher ip!

mapIP: anInteger toDebug: debugCompiledMethod
	| i interp offset prev map debugMap debugDispatcher |
	map := self debugInfo textMap.
	debugMap := debugCompiledMethod debugInfo textMap.
	i := self class findIP: anInteger inTextMap: map.
	(map at: i) key == anInteger
		ifTrue: 
			["Directly corresponding entry"
			^(debugMap at: i) key].
	"We expect to be mapping from a bytecode immediately after a send (or a jump replacing an optimised send), so we need to remap that previous send instructions IP and then step to the next instruction in the debug method"
	interp := self byteCodeDispatcher.
	prev := interp prevIP: anInteger.
	i := self class findIP: prev inTextMap: map.
	offset := prev - (map at: i) key.
	offset == 0
		ifTrue: 
			["Text map entry exists for previous instruction, so step forward once from there in the debug method"
			^interp
				method: debugCompiledMethod;
				ip: (debugMap at: i) key;
				next;
				ip].
	"Intermediate bytecode, so find the prior map entry and step forward from there."
	debugDispatcher := debugCompiledMethod byteCodeDispatcher.
	[i > 1 and: 
			["We must skip over any voided entries"
			(map at: (i := i - 1)) key == 0]]
		whileTrue.
	interp ip: (map at: i) key.
	debugDispatcher ip: (debugMap at: i) key.
	"Note: If there is more than one step here, the results are unreliable. In use from the debugger, this should not happen though, because any release frame should have been suspended just after a send."
	[interp ip == prev] whileFalse: 
			[interp next.
			debugDispatcher next].
	^debugDispatcher
		next;
		ip!

parseContext
	^ParseContext method: self!

stylerClass
	^self subclassResponsibility! !

!Kernel.CompiledCode categoriesForMethods!
alternateInspectorClass!constants!private! !
asDebugMethod!private! !
decodeHeaderOn:!printing!private! !
disassembly!private! !
hasCompilationIssues!public!searching! !
indexOfIP:!enquiries!private! !
isAbstract!public!testing! !
isDeprecated!enquiries!private! !
isSimpleSelfSend:!private!testing! !
mapIp:toDebug:!private! !
mapIP:toDebug:!private! !
parseContext!accessing!public! !
stylerClass!constants!public! !
!

!Kernel.CompiledCode class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #methodClass) beReadOnly;
		add: (Aspect name: #header) beReadOnly;
		add: (Aspect integer: #argumentCount) beReadOnly;
		add: (Aspect multilineString: #getSource) beReadOnly;
		add: (Aspect name: #byteCodes) beReadOnly;
		add: (Aspect multilineString: #disassembly) beReadOnly;
		add: (Aspect name: #literals);
		add: (Aspect collection: #tempsMap) beReadOnly;
		add: (Aspect collection: #textMap) beReadOnly;
		add: (Aspect name: #parseTreeNoError) beReadOnly;
		yourself! !

!Kernel.CompiledCode class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Kernel.CompiledExpression methodsFor!

asDebugMethod
	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."

	| debugMethod exprClass |
	exprClass := self expressionClass.
	debugMethod := self compilerClass
				compileDebugExpression: self getSource
				in: exprClass
				environment: self customEnvironment
				evaluationPools: self evaluationPools.
	"Copy across some bits we need as we are an unbound expression"
	debugMethod sourceDescriptor: self sourceDescriptor.
	^debugMethod!

stylerClass
	^SmalltalkSystem current expressionStylerClass! !

!Kernel.CompiledExpression categoriesForMethods!
asDebugMethod!private! !
stylerClass!constants!public! !
!

!Kernel.CompiledMethod methodsFor!

asDebugMethod
	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."

	| debugMethod |
	self isDebugMethod ifTrue: [^self].
	debugMethod := self compilerClass
				compileDebugMethod: self getSource
				in: self methodClass
				environment: self environment.
	"Copy across some bits we need as we are an unbound method"
	debugMethod
		sourceDescriptor: self sourceDescriptor;
		selector: self selector;
		isPrivate: self isPrivate.
	^debugMethod!

browse
	"Open a suitable browser onto the receiver."

	^SmalltalkSystem current browseMethod: self!

icon
	"Answers an Icon that can be used to represent this object."

	^SmalltalkSystem current iconForMethod: self!

infoTip
	"Private - Answer a suitable 'info tip' for the receiver."

	| stream |
	stream := String smalltalkWriteStream.
	stream
		display: self;
		nextPutAll: ' ('.
	self realCategories asSortedArray
		, (self protocols asSortedArray: [:a :b | a asSymbol < b asSymbol])
			do: [:each | stream display: each]
			separatedBy: [stream nextPutAll: ', '].
	stream nextPut: $).
	^stream contents!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForMethod: self!

stylerClass
	^SmalltalkSystem current methodStylerClass! !

!Kernel.CompiledMethod categoriesForMethods!
asDebugMethod!private! !
browse!commands!public! !
icon!constants!public! !
infoTip!accessing!development!private! !
searchForInTool:!public! !
stylerClass!constants!public! !
!

!Kernel.CompiledMethod class methodsFor!

overriddenIcon
	"Private - Answers an Icon that can be used to represent an overridden instance of this class: ▴"

	^##((TextTileIcon text: $\x25B4 fontName: 'Segoe UI')
		textcolor: Color dodgerBlue;
		yourself)!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #selector) beReadOnly;
		yourself! !

!Kernel.CompiledMethod class categoriesForMethods!
overriddenIcon!constants!private! !
publishedAspectsOfInstances!constants!public! !
!

!Kernel.CompileFailedMethod methodsFor!

asDebugMethod
    	"Private - Answer a debug version of the receiver with breakpoints after each 
    	expression/statement."
    
	^self! !

!Kernel.CompileFailedMethod categoriesForMethods!
asDebugMethod!private! !
!

!Kernel.CompilerNotification methodsFor!

okToContinue
	"Throw up an OK/Cancel message box with the receiver's compilation error/warning
	message, answering true if the user pressed OK to contine the compilation."

	| mb severity |
	severity := self severityClass.
	mb := MessageBox new
				headline: 'Compilation <1s>' << self severityName;
				text: ('line <1p>: <2s>' expandMacrosWith: self line with: self errorMessage);
				iconStyleFlag: severity mbIconId;
				yourself.
	^severity == Error
		ifTrue: 
			[mb
				buttonStyle: #ok;
				open.
			false]
		ifFalse: 
			[mb buttonStyle: #okCancel.
			mb open == #ok]! !

!Kernel.CompilerNotification categoriesForMethods!
okToContinue!public!testing! !
!

!Kernel.InputState class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #aboutToIdle;
    		yourself.
    ! !

!Kernel.InputState class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!Kernel.MethodAnnotations methodsFor!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representation of the receiver to the <puttableStream>
	argument in a form that a user viewing the receiver as the value of a published aspect would 
	like to see it."

	self displayOn: aStream! !

!Kernel.MethodAnnotations categoriesForMethods!
aspectDisplayOn:!private! !
!

!Kernel.MethodProtocol methodsFor!

icon
	"Answers an Icon that can be used to represent this object."

	^self isANSI
		ifTrue: [self class ansiIcon]
		ifFalse: [
			self isReadOnly
				ifTrue: [self class readOnlyIcon]
				ifFalse: [self class icon]]! !

!Kernel.MethodProtocol categoriesForMethods!
icon!constants!public! !
!

!Kernel.MethodProtocol class methodsFor!

ansiIcon
	"Private - Answers an Icon that can be used to represent an ANSI standard protocol."

	^Icon fromId: 'METHODPROTOCOL_ANSI.ICO'!

isValidProtocolName: aString
	^aString notEmpty and: 
			[aString first ~~ $\x20 and: 
					[aString last ~~ $\x20 and: 
							[aString
								allSatisfy: [:each | each == $\x20 or: [each == $_ or: [each isEnglishLetter or: [each isDigit]]]]]]]!

publishedEventsOfInstances
    	"Answer a <Set> of <Symbol>s that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #protocolUpdated:;
    		yourself.
    !

readOnlyIcon
	"Private - Answers an Icon that can be used to represent a read-only protocol."

	^Icon fromId: 'METHODPROTOCOL_READONLY.ICO'! !

!Kernel.MethodProtocol class categoriesForMethods!
ansiIcon!constants!private! !
isValidProtocolName:!public! !
publishedEventsOfInstances!events!public! !
readOnlyIcon!constants!private! !
!

!Kernel.Namespace class methodsFor!

isAbstract
	^self hasAbstractMethods!

isVisiblyAbstract
	"Private - All Namespaces are non-instantiable (they exist only as classes), but that doesn't mean they are abstract as such."

	^self == ##(self)!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass dictionary: aSymbol)
		type: Class;
		icon: Kernel.Namespace icon;
		yourself!

publishedAspects
    	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."
    
    	^(self publishedKeyedAspects)
    		addAll: super publishedAspects;
    		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the receiver's keyed contents."

	^classPool publishedAspects! !

!Kernel.Namespace class categoriesForMethods!
isAbstract!public!testing! !
isVisiblyAbstract!private!testing! !
newInstanceAspect:class:!adapters!private! !
publishedAspects!constants!public! !
publishedKeyedAspects!constants!public! !
!

!Kernel.Package methodsFor!

aboutBlock: aMonadicValuableOrNil
	"Set the <monadicValuable> that will display an About screen.  The receiver
	will be passed as the parameter to the valuable. 
	When a package is created it does not have an about operation set. 
	To set a default splash screen see #defaultAbout."

	| newArray |
	newArray := aMonadicValuableOrNil ifNotNil: [aMonadicValuableOrNil literalStoreArray].
	newArray = aboutBlock ifTrue: [^self].
	aboutBlock := newArray.
	self isChanged: true!

browse
	"Open a suitable browser onto the receiver."

	SmalltalkSystem current browsePackages: {self}!

defaultAbout
	"Shows a default About splash screen for the receiver. This looks for a bitmap of the same
	name as the package in the package installation directory. This is displayed in a standard
	modal Splash view with no overlaid version text.

	If you wish to use such a splash screen for your about box then set #aboutBlock to:
	[:package | package defaultAbout]"

	(Splash bitmap: self defaultAboutBitmap) show!

defaultAboutBitmap
	"Answer a default Bitmap to use for the receiver. We assume that a JPG of the same name as
	the package is available in the Resources directory below the package's folder."

	"If the GdiplusImage class is not available, or the package does not provide an about bitmap
	resource, we just display an empty bitmap"

	#{Graphics.Gdiplus.Image} ifDefined: 
			[:gdiplusImage |
			| dir imageFile |
			dir := File composePath: self path subPath: 'Resources'.
			#('jpg' 'png') do: 
					[:each |
					imageFile := File
								composePath: dir
								stem: self name
								extension: each.
					(File exists: imageFile) ifTrue: [^gdiplusImage fromFile: imageFile]]].
	^DIBSection width: 480 height: 360!

fileLocator
	^PackageRelativeFileLocator package: self!

icon
	self isBasePackage ifTrue: [^self class dolphinPackageIcon].
	^super icon!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	aspects
		add: ((Aspect
					collection: #untracedVariables
					presenterClass: HashedCollectionPresenter
					addFrom: [self variableNames asSortedCollection])
					beImmutable;
					yourself);
		add: (Aspect
					choice: #environment
					from: 
						[(Namespace allSubclasses
							reject: [:each | each isVisiblyAbstract or: [(each inheritsFrom: SharedPool) or: [each owningPackage == self]]])
								asSortedCollection: [:a :b | a fullName <= b fullName]]
					andNil: nil).
	^aspects!

searchForInTool: aSmalltalkToolShell 
	aSmalltalkToolShell searchForPackage: self!

toggleLegacySourceFormat
	"Toggles the use of legacy (pre-namespace) source format."

	SmalltalkSystem current changeManager
		performChange: (Refactory.Browser.PackageVersionChange package: self
				version: (self isLegacySourceFormat ifTrue: [self class paxVersion] ifFalse: [1]))!

toggleUsingPAX
	"Toggles the use of PAX mode."

	^self isUsingPAX: self isUsingPAX not! !

!Kernel.Package categoriesForMethods!
aboutBlock:!accessing!public! !
browse!commands!public! !
defaultAbout!constants!public! !
defaultAboutBitmap!accessing!public! !
fileLocator!accessing!public! !
icon!accessing!public! !
publishedAspects!initializing!public! !
searchForInTool:!public! !
toggleLegacySourceFormat!public! !
toggleUsingPAX!commands!public! !
!

!Kernel.Package class methodsFor!

changedIcon
	"Private - Answer the icon to mark packages that have been changed"

	^SmalltalkSystem.ChangedIcon!

dolphinPackageIcon
	^##(Icon fromId: 'DolphinPackage.ico')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances
				add: (Aspect multilineString: #comment);
				add: (Aspect string: #packageVersion);
				add: (Aspect block: #aboutBlock);
				add: (Aspect fileSave: #packageFileName);
				add: (Aspect sequenceableCollection: #manualPrerequisites
							addFrom: [self manager packageNames asSortedArray]);
				add: (Aspect boolean: #preDeclareClassesOnLoad);
				add: (Aspect
							choice: #paxVersion
							from: #(1 2.1)
							type: Number);
				yourself.
	"If the image has the ADK loaded, then include the image stripper"
	#{Smalltalk.ImageStripper} isDefined
		ifTrue: [answer add: (Aspect name: #imageStripper) beImmutable].
	^answer!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s, being the names all the events published
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #changed;
		add: #ownedChanged;
		add: #prerequisitesReset;
		yourself! !

!Kernel.Package class categoriesForMethods!
changedIcon!constants!private! !
dolphinPackageIcon!public! !
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!Kernel.PackageManager methodsFor!

sourceControl
	^self! !

!Kernel.PackageManager categoriesForMethods!
sourceControl!accessing!public! !
!

!Kernel.PackageManager class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s being the names of the events published by
    	instances of the receiver."

	^super publishedEventsOfInstances
		add: #loadedChanged;
		add: #prerequisitesReset;
		add: #prerequisitesReset:;
		add: #packageChanged:;
		add: #ownedChanged:;
		add: #classRepackaged:from:to:;
		add: #methodRepackaged:from:to:;
		add: #resourceRepackaged:from:to:;
		add: #variableRepackaged:from:to:;
		add: #aboutToSave:;
		add: #packageInstalled:;
		yourself! !

!Kernel.PackageManager class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!Kernel.ProcessorScheduler methodsFor!

singleStep: interruptArg
	"Private - A single step has occurred.
	Note that interrupts are NOT re-enabled here if the event if forwarded to the debugger."

	| debugger |
	debugger := activeProcess debugger.
	debugger isNil 
		ifTrue: [self enableInterrupts]
		ifFalse: [debugger onStep: interruptArg]
! !

!Kernel.ProcessorScheduler categoriesForMethods!
singleStep:!interrupts-handling!private! !
!

!Kernel.ProtoObject methodsFor!

basicInspect
	"Open and answer an inspector window on the receiver"

	^BasicInspector shellOn: self!

debugPrintString
	"Answer a <readableString> whose characters are a description of the receiver 
	as the debugger would want to see it."

	^self basicPrintString
!

halt
	"Bring up the Smalltalk debugger (suspending the active process) ..."

	| process |
	process := Processor activeProcess.
	process halt: process topFrame sender cause: 'Hard coded breakpoint'!

inspect
	"Open and answer an inspector window on the receiver"

	^self basicInspect! !

!Kernel.ProtoObject categoriesForMethods!
basicInspect!public! !
debugPrintString!printing!public! !
halt!public! !
inspect!public! !
!

!Kernel.ProtoObject class methodsFor!

icon
	^##(self) defaultIcon!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Overridden by subclasses to add the aspects 	published locally"

	^LookupTable new
		add: (Aspect name: #yourself) beNonNullable;
		yourself!

publishedAspectsOfInstances
	"Answer a LookupTable of AspectDescriptors that describe the aspects published
    	by an instance of the receiver. Overridden by subclasses to add the aspects
    	published locally."

	^LookupTable new
		add: (Aspect name: #yourself);
		yourself! !

!Kernel.ProtoObject class categoriesForMethods!
icon!public! !
publishedAspects!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!Kernel.SharedPool class methodsFor!

canModifyBinding: aVariableBinding newValue: anObject
	^ConfirmationRequiredWarning
		signal: ('Would you like to recompile references to <1p>.<2s> to reflect the new value <3p> (currently <4p>)?'
				expandMacrosWith: self
				with: aVariableBinding key
				with: anObject
				with: aVariableBinding value)!

isVisiblyAbstract
	"Private - All Namespaces are non-instantiable (they exist only as classes), but that doesn't mean they are abstract as such."

	^self == ##(self)!

referencesTo: keyString
	"Answer the collection of any methods which references the named key, assumed to
	be a variable name from the receiver."

	| env var classes |
	var := self associationAt: keyString.
	classes := self classesReferencing.
	env := Refactory.Browser.BrowserEnvironment new
				forClasses: classes , (classes collect: [:each | each class]).
	^(env referencesTo: var)
		label: ('Methods referencing <1p>.<2s>' expandMacrosWith: self with: keyString);
		yourself! !

!Kernel.SharedPool class categoriesForMethods!
canModifyBinding:newValue:!private! !
isVisiblyAbstract!private!testing! !
referencesTo:!enquiries!public! !
!

!Kernel.SourceFiler methodsFor!

emitResourceMethod: aResourceIdentifier literals: aLiteralArray
	self emitResourceMethodHeader: aResourceIdentifier.
	stream
		tab;
		nextPut: $^.
	STLPrinter printLiteralStoreArray: aLiteralArray on: stream!

emitResourceMethodHeader: aResourceIdentifier
	stream
		nextPutAll: aResourceIdentifier selector;
		crtab;
		nextPutAll: '"Answer the literal data from which the ';
		print: aResourceIdentifier name;
		nextPutAll: ' resource can be reconstituted.';
		crtab;
		nextPutAll: 'DO NOT EDIT OR RECATEGORIZE THIS METHOD.';
		cr;
		crtab;
		nextPutAll: 'If you wish to modify this resource evaluate:';
		crtab.
	self emitClassName: Tools.ViewComposer on: stream.
	stream nextPutAll: ' openOn: ('.
	self emitClassName: ResourceIdentifier on: stream.
	stream
		nextPutAll: ' class: self selector: ';
		print: aResourceIdentifier selector;
		nextPut: $);
		crtab;
		nextPut: $";
		cr;
		cr! !

!Kernel.SourceFiler categoriesForMethods!
emitResourceMethod:literals:!private!source filing! !
emitResourceMethodHeader:!private!source filing! !
!

!Kernel.StackFrame methodsFor!

canReturn
	"Answer whether this frame can be returned from."

	^(self isDead or: [self sender isNil]) not!

debugIpFor: debugCompiledMethod
	| ip |
	ip := self ip.
	ip == 1 ifTrue: [^1].
	^self basicMethod mapIP: ip toDebug: debugCompiledMethod!

debugPrintOn: aStream
	self basicPrintOn: aStream!

isRestartable
	"Answer whether this frame is restartable. Some methods, such as
	callback entry points, cannot be restarted at all, others not reliably."

	^self isDead not and: 
			[self sender notNil and: 
					[| method |
					method := self basicMethod.
					method isExpression or: [('not restartable' asMethodCategory includesMethod: method) not]]]!

makeDebug
	"Private - Convert the receiver to a debug frame. Returns the non-debug method that was replaced, or nil if already a debug frame. This is for the use of the debugger."

	| method debugMethod ip |
	method := self basicMethod.
	(method isDebugMethod or: [method sourceDescriptor isNil]) ifTrue: [^nil].	"nothing to do"
	debugMethod := method asDebugMethod.
	ip := self debugIpFor: debugMethod.

	"We must reset ip, even if not changed, because method bytecodes may change from 
    	packed to unpacked. Also the method must be set first for #ip: to work correctly."
	self
		method: debugMethod;
		ip: ip.
	^method!

stackWorkspace
	"Private - Answer the number of additional stack temps currently in use
    	(i.e. the depth of stack above the last named temporary currently being
    	used for working space)."

	^self sender isNil ifTrue: [0] ifFalse: [self sp - index - self frameSize + 1]! !

!Kernel.StackFrame categoriesForMethods!
canReturn!public!testing! !
debugIpFor:!private! !
debugPrintOn:!public! !
isRestartable!public!testing! !
makeDebug!private! !
stackWorkspace!accessing!private! !
!

!Kernel.StackFrame class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	^aspects
		add: (Aspect collection: #arguments) beReadOnly;
		add: (Aspect name: #method);
		add: (Aspect integer: #ip);
		add: (Aspect integer: #sp);
		add: (Aspect integer: #bp) beReadOnly;
		add: (Aspect name: #sender);
		add: (Aspect collection: #tempNames) beReadOnly;
		add: (Aspect name: #environment);
		yourself! !

!Kernel.StackFrame class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Kernel.StArgumentVariable methodsFor!

category
	"Answer a descriptive category name for this local variable."

	^'argument'! !

!Kernel.StArgumentVariable categoriesForMethods!
category!accessing!public! !
!

!Kernel.StArgumentVariable class methodsFor!

icon
	^StParameterNode icon! !

!Kernel.StArgumentVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StAssignmentNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: ':='! !

!Kernel.StAssignmentNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StBasicVariableNode methodsFor!

shortName
	^self isStaticVariable ifTrue: [self binding shortName] ifFalse: [super shortName]! !

!Kernel.StBasicVariableNode categoriesForMethods!
shortName!constants!public! !
!

!Kernel.StBlockNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '[]'! !

!Kernel.StBlockNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StBlockScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^'block'! !

!Kernel.StBlockScope categoriesForMethods!
category!constants!public! !
!

!Kernel.StCascadeNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: 'Cascade'! !

!Kernel.StCascadeNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StClassScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^'class'!

isVisibleSelector: aSymbol
	^SmalltalkSystem current allSelectors includes: aSymbol! !

!Kernel.StClassScope categoriesForMethods!
category!constants!public! !
isVisibleSelector:!helpers!private! !
!

!Kernel.StEvalScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^'workspace'! !

!Kernel.StEvalScope categoriesForMethods!
category!constants!public! !
!

!Kernel.StGeneratedTempVariable methodsFor!

category
	"Answer a descriptive category name for this local variable."

	^'generated temp'! !

!Kernel.StGeneratedTempVariable categoriesForMethods!
category!accessing!public! !
!

!Kernel.StGeneratedTempVariable class methodsFor!

icon
	^##((TextTileIcon text: '_t' fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StGeneratedTempVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StInstanceVariable methodsFor!

classification
	^#instance!

icon
	^(scope methodClass whichClassDefinesInstVar: self name) icon!

iconInFrame: aStackFrame
	^aStackFrame receiver ifNotNil: [:receiver | (receiver instVarAt: index) icon] ifNil: [self icon]!

printDescriptionOn: aStream
	aStream
		nextPutAll: 'Instance variable ''';
		print: (scope methodClass whichClassDefinesInstVar: name);
		nextPut: $.;
		nextPutAll: self name;
		nextPutAll: ''''!

printInfoTipOn: aStream frame: aStackFrame
	"Answer an informative tip for this variable that might be displayed, for example, when the user is hovering over it in a Debugger workspace showing the specified <StackFrame>."

	self printInfoTipOn: aStream.
	aStream nextPutAll: ': '.
	aStackFrame receiver
		ifNil: [aStream nextPutAll: '<unavailable>']
		ifNotNil: [(self valueInFrame: aStackFrame) debugPrintOn: aStream]!

valueClass: aStackFrame 
	^(self valueInFrame: aStackFrame) class!

valueInFrame: aStackFrame
	^aStackFrame receiver ifNotNil: [:receiver | receiver instVarAt: index]! !

!Kernel.StInstanceVariable categoriesForMethods!
classification!accessing!public! !
icon!constants!public! !
iconInFrame:!public! !
printDescriptionOn:!accessing!public! !
printInfoTipOn:frame:!accessing!public! !
valueClass:!public! !
valueInFrame:!accessing!public! !
!

!Kernel.StInstanceVariable class methodsFor!

icon
	^##((TextTileIcon text: $\x24D8 fontName: 'Segoe UI')
		textcolor: Color navy;
		yourself)! !

!Kernel.StInstanceVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StLiteralArrayNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '#(‥)'! !

!Kernel.StLiteralArrayNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StLiteralByteArrayNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '#[‥]'! !

!Kernel.StLiteralByteArrayNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StLiteralSymbolToken methodsFor!

textStyle
	^#literalSymbol! !

!Kernel.StLiteralSymbolToken categoriesForMethods!
textStyle!public! !
!

!Kernel.StLiteralToken methodsFor!

textStyle
	^self value literalTextStyle! !

!Kernel.StLiteralToken categoriesForMethods!
textStyle!constants!public! !
!

!Kernel.StLiteralValueNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	self value printOn: aPuttableStream! !

!Kernel.StLiteralValueNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StLocalVariable methodsFor!

category
	"Answer a descriptive category name for this local variable."

	^self subclassResponsibility!

classification
	^#temporary!

debugInfoInFrame: aStackFrame
	^aStackFrame temps detect: [:each | each first = self name] ifNone: nil!

printDescriptionOn: aStream
	scope
		ifNotNil: 
			[#todo.	"Copy down copied variables and set storage class to #copy, then it will be useful to show the storage class"
			(storage == #stack or: [true])
				ifTrue: 
					[aStream
						nextPutAll: scope category capitalized;
						space]
				ifFalse: 
					[aStream
						nextPutAll: (storage ifNil: ['Unused'] ifNotNil: [storage capitalized]);
						space;
						nextPutAll: scope category;
						space]].
	aStream
		nextPutAll: self category;
		nextPutAll: ' ''';
		nextPutAll: self name;
		nextPutAll: ''''!

printInfoTipOn: aStream frame: aStackFrame
	"Answer an informative tip for this variable that might be displayed, for example, when the user is hovering over it in a Debugger workspace showing the specified <StackFrame>."

	self printInfoTipOn: aStream.
	(self debugInfoInFrame: aStackFrame)
		ifNotNil: 
			[:entry |
			aStream
				nextPutAll: ': ';
				debugPrint: (aStackFrame temp: (entry at: 2) at: (entry at: 3))]!

valueClass: aStackFrame
	^(self debugInfoInFrame: aStackFrame)
		ifNil: [super valueClass: aStackFrame]
		ifNotNil: [:entry | (aStackFrame temp: (entry at: 2) at: (entry at: 3)) basicClass]! !

!Kernel.StLocalVariable categoriesForMethods!
category!accessing!public! !
classification!accessing!public! !
debugInfoInFrame:!accessing!public! !
printDescriptionOn:!accessing!public! !
printInfoTipOn:frame:!accessing!public! !
valueClass:!enquiries!public! !
!

!Kernel.StMessageNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Msg ';
		print: self selector! !

!Kernel.StMessageNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StMethodScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^'method'! !

!Kernel.StMethodScope categoriesForMethods!
category!constants!public! !
!

!Kernel.StNumberLiteralToken methodsFor!

textStyle
	^#literalNumber! !

!Kernel.StNumberLiteralToken categoriesForMethods!
textStyle!constants!public! !
!

!Kernel.StOptimizedBlockScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^'optimized block'! !

!Kernel.StOptimizedBlockScope categoriesForMethods!
category!constants!public! !
!

!Kernel.StOptimizedNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: '##()'! !

!Kernel.StOptimizedNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StParameterNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPut: $:;
		display: self name! !

!Kernel.StParameterNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StParameterNode class methodsFor!

icon
	^##((TextTileIcon text: 'arg' fontName: 'Consolas')
		fontStyle: #italic;
		textcolor: Color navy;
		yourself)! !

!Kernel.StParameterNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StPrimitiveNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: '<Primitive: ';
		display: self primitiveIndex.
	self hasDefaultErrorTemp
		ifFalse: 
			[aPuttableStream
				nextPutAll: ' error: ';
				nextPutAll: self errorTemp name].
	aPuttableStream nextPut: $>! !

!Kernel.StPrimitiveNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StProgramNode methodsFor!

debugPrintOn: aStream
	"Implementation Note: Debugging the parser can be difficult if we use #printOn:
	because it attempts to output formatted text for the method, which can fail when it
	is only partially constructed."

	self basicPrintOn: aStream!

postComments
	"Answer the set of comments associated with the receiver that are after the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| stop |
			stop := self stop.
			all select: [:each | each start > stop]]!

preComments
	"Answer the set of comments associated with the receiver that are before the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| start |
			start := self start.
			all select: [:each | each stop < start]]!

publishedAspects
	| aspects |
	aspects := super publishedAspects.
	aspects at: #yourself
		put: (Aspect name: #yourself
				presenterBlock: 
					[:p :m |
					| tree |
					tree := TreePresenter
								create: 'Default view'
								in: p
								on: (VirtualTreeModel withRoots: (OrderedCollection with: m value)).
					tree view expandAll.
					tree]).
	^aspects! !

!Kernel.StProgramNode categoriesForMethods!
debugPrintOn:!printing!public! !
postComments!accessing!public! !
preComments!accessing!public! !
publishedAspects!constants!public! !
!

!Kernel.StReturnNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPut: $^! !

!Kernel.StReturnNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StSelfVariable methodsFor!

printDescriptionOn: aStream
	aStream
		nextPutAll: 'Receiver: A subinstance of ';
		print: scope methodClass!

printInfoTipOn: aStream frame: aStackFrame
	"Answer an informative tip for this variable that might be displayed, for example, when the user is hovering over it in a Debugger workspace showing the specified <StackFrame>."

	aStream
		nextPutAll: 'Receiver: ';
		debugPrint: aStackFrame receiver!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	"The scope will be an StClassScope which knows the method class."

	^scope methodClass!

valueClass: aStackFrame
	^aStackFrame receiver basicClass! !

!Kernel.StSelfVariable categoriesForMethods!
printDescriptionOn:!accessing!public! !
printInfoTipOn:frame:!accessing!public! !
valueClass!accessing!public! !
valueClass:!enquiries!public! !
!

!Kernel.StSelfVariable class methodsFor!

icon
	^StSelfVariableNode icon! !

!Kernel.StSelfVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StSelfVariableNode methodsFor!

valueClassIn: aClass
	^aClass! !

!Kernel.StSelfVariableNode categoriesForMethods!
valueClassIn:!public! !
!

!Kernel.StSelfVariableNode class methodsFor!

icon
	^##((TextTileIcon text: $\x2B6A fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StSelfVariableNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StSemanticScope methodsFor!

category
	"Answer a descriptive category name for this scope."

	^self subclassResponsibility! !

!Kernel.StSemanticScope categoriesForMethods!
category!constants!public! !
!

!Kernel.StSequenceNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPut: $…! !

!Kernel.StSequenceNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StSpecialVariable methodsFor!

classification
	^#special! !

!Kernel.StSpecialVariable categoriesForMethods!
classification!accessing!public! !
!

!Kernel.StSpecialVariableNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: self name!

valueClassIn: aClass
	^self subclassResponsibility! !

!Kernel.StSpecialVariableNode categoriesForMethods!
displayOn:!printing!public! !
valueClassIn:!public! !
!

!Kernel.StStaticVariable methodsFor!

classification
	binding ifNotNil: [
		binding isClassVariable ifTrue: [^#class].
		binding isClassBinding ifTrue: [^#classGlobal]].
	^#global!

displayOn: aStream
	"Write a informative tip for this variable to the <puttableStream> argument, that might be displayed, for example, when the user is hovering over it in a browser workspace."

	binding ifNil: [super displayOn: aStream] ifNotNil: [binding displayOn: aStream]!

printDescriptionOn: aStream
	"Print an informative description of this variable on the <puttableStream> argument."

	binding isNil
		ifTrue: 
			[aStream nextPutAll: 'Undeclared'.
			^false].
	binding isClassVariable
		ifTrue: 
			[aStream
				nextPutAll: 'Class ';
				nextPutAll: (binding isImmutable ifTrue: ['constant '] ifFalse: ['variable ']);
				nextPutAll: binding fullName]
		ifFalse: 
			[binding isClassBinding
				ifTrue: 
					[aStream
						nextPutAll: 'Class ';
						nextPutAll: binding fullName.
					^false]
				ifFalse: 
					[aStream
						nextPutAll: 'Shared variable ';
						nextPutAll: binding fullName]].
	^true!

printInfoTipOn: aStream
	"Print an informative tip on the <puttableStream> argument for this variable that might be displayed, for example, when the user is hovering over it in a browser workspace."

	"Here we try to provide some useful information, such as the fully qualified name of a class referenced only by a short name, whether the variable is a class or shared variable, or a class constant."

	| value |
	(self printDescriptionOn: aStream) ifFalse: [^self].
	aStream nextPutAll: ': '.
	value := binding value.
	value debugPrintOn: aStream.
	value isInteger ifFalse: [^self].
	aStream
		nextPutAll: ' (';
		nextPutAll: value printString;
		nextPut: $)!

staticValueClass
	"Answer the class that the variable should be assumed to hold for the purposes of deducing what messages it may understand, or nil if not known with any certainty."

	"In the case of static variables, we can only offer a variable type with confidence (without resort to type inference) if the variable binding is constant (which includes class bindings). If it isn't then the variable could assume different types through the course of the method or even across different invocations (if a global, or class variable). This might cause false reports of unimplemented messages in the debugger. Therefore we have to be conservative here in suggesting the variable type."

	^binding isImmutable ifTrue: [self valueClass]!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	^binding ifNotNil: [binding realBinding value basicClass]! !

!Kernel.StStaticVariable categoriesForMethods!
classification!accessing!public! !
displayOn:!accessing!public! !
printDescriptionOn:!accessing!public! !
printInfoTipOn:!accessing!public! !
staticValueClass!accessing!public! !
valueClass!accessing!public! !
!

!Kernel.StStaticVariable class methodsFor!

icon
	^##((TextTileIcon text: $\x24B6 fontName: 'Segoe UI')
		textcolor: Color navy;
		yourself)! !

!Kernel.StStaticVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StSuperVariable methodsFor!

printDescriptionOn: aStream
	aStream
		nextPutAll: 'Supersend to ';
		print: scope methodClass superclass!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	^scope methodClass superclass!

valueClass: aStackFrame
	^aStackFrame method methodClass superclass! !

!Kernel.StSuperVariable categoriesForMethods!
printDescriptionOn:!accessing!public! !
valueClass!accessing!public! !
valueClass:!enquiries!public! !
!

!Kernel.StSuperVariable class methodsFor!

icon
	^StSuperVariableNode icon! !

!Kernel.StSuperVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StSuperVariableNode methodsFor!

valueClassIn: aClass
	^aClass superclass! !

!Kernel.StSuperVariableNode categoriesForMethods!
valueClassIn:!public! !
!

!Kernel.StSuperVariableNode class methodsFor!

icon
	^##((TextTileIcon text: $\x2B6B fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StSuperVariableNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StTempDeclNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPut: $|;
		nextPutAll: name;
		nextPut: $|! !

!Kernel.StTempDeclNode categoriesForMethods!
displayOn:!printing!public! !
!

!Kernel.StTempDeclNode class methodsFor!

icon
	^##((TextTileIcon text: '|t|' fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StTempDeclNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StTempVariable methodsFor!

category
	"Answer a descriptive category name for this local variable."

	^'temp'! !

!Kernel.StTempVariable categoriesForMethods!
category!accessing!public! !
!

!Kernel.StTempVariable class methodsFor!

icon
	^StTempDeclNode icon! !

!Kernel.StTempVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StThisContextVariable methodsFor!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown."

	^Integer! !

!Kernel.StThisContextVariable categoriesForMethods!
valueClass!accessing!public! !
!

!Kernel.StThisContextVariable class methodsFor!

icon
	^StThisContextVariableNode icon! !

!Kernel.StThisContextVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StThisContextVariableNode methodsFor!

valueClassIn: aClass
	^Integer! !

!Kernel.StThisContextVariableNode categoriesForMethods!
valueClassIn:!public! !
!

!Kernel.StThisContextVariableNode class methodsFor!

icon
	^Context icon! !

!Kernel.StThisContextVariableNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StToken methodsFor!

postComments
	"Answer the set of comments associated with the receiver that are after the token"

	^self comments 
		ifNil: [#()]
		ifNotNil: 
			[:all | 
			| stop |
			stop := self stop.
			all select: [:each | each start > stop]]!

preComments
	"Answer the set of comments associated with the receiver that are before the token"

	^self comments ifNil: [#()] ifNotNil: [:all | all select: [:each | each stop < start]]! !

!Kernel.StToken categoriesForMethods!
postComments!accessing!public! !
preComments!accessing!public! !
!

!Kernel.StVariable methodsFor!

classification
	^self subclassResponsibility!

description
	"Answer an informative description for this variable that might be displayed, for example, in a context menu."

	| stream |
	stream := LimitedWriteStream
				over: ((WriteStream on: (String new: 32))
						locale: SmalltalkLocale.Hex;
						yourself)
				limit: 120
				limitBlock: [:s | ^s contents , ' … etc …'].
	self printDescriptionOn: stream.
	^stream contents!

displayOn: aStream
	"Write a informative tip for this variable to the <puttableStream> argument, that might be displayed, for example, when the user is hovering over it in a browser workspace."

	aStream nextPutAll: self name!

iconInFrame: aStackFrame 
	^(self valueClass: aStackFrame) icon!

infoTip
	"Answer an informative tip for this variable that might be displayed, for example, when the user is hovering over it in a browser workspace."

	| stream |
	stream := LimitedWriteStream
				over: ((WriteStream on: (String new: 32))
						locale: SmalltalkLocale.Hex;
						yourself)
				limit: 120
				limitBlock: [:s | ^s contents , ' … etc …'].
	self printInfoTipOn: stream.
	^stream contents!

infoTip: aStackFrame
	"Answer an informative tip for this variable that might be displayed, for example, when the user is hovering over it in a Debugger workspace showing the specified <StackFrame>."

	| stream |
	stream := LimitedWriteStream
				over: ((WriteStream on: (String new: 32))
						locale: SmalltalkLocale.Hex;
						yourself)
				limit: 120
				limitBlock: [:s | ^s contents , ' … etc …'].
	self printInfoTipOn: stream frame: aStackFrame.
	^stream contents!

printDescriptionOn: aStream
	self displayOn: aStream!

printInfoTipOn: aStream
	"Write a informative tip for this variable to the <puttableStream> argument, that might be displayed, for example, when the user is hovering over it in a browser workspace."

	self printDescriptionOn: aStream!

printInfoTipOn: aStream frame: aStackFrame
	"Write a informative tip for this variable to the <puttableStream> argument, that might be displayed, for example, when the user is hovering over it in a debugger workspace."

	"By default, use the static tip."

	self printInfoTipOn: aStream!

staticValueClass
	"Answer the class that the variable should be assumed to hold for the purposes of deducing what messages it may understand, or nil if not known with any certainty."

	^self valueClass!

valueClass
	"Answer the class of the variables value, if this is known, or nil if unknown. In Smalltalk we only know the type that a variable can assume in the case of constants and shared variables where the value is availabe, as variables are untyped."

	^nil!

valueClass: aStackFrame 
	^self valueClass! !

!Kernel.StVariable categoriesForMethods!
classification!accessing!public! !
description!accessing!public! !
displayOn:!accessing!public! !
iconInFrame:!public! !
infoTip!accessing!public! !
infoTip:!accessing!public! !
printDescriptionOn:!accessing!public! !
printInfoTipOn:!accessing!public! !
printInfoTipOn:frame:!accessing!public! !
staticValueClass!accessing!public! !
valueClass!accessing!public! !
valueClass:!public! !
!

!Kernel.StVariable class methodsFor!

icon
	^StVariableNode icon! !

!Kernel.StVariable class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StVariableNode methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream
		nextPutAll: 'Var ';
		print: self name!

shortName
	^self name! !

!Kernel.StVariableNode categoriesForMethods!
displayOn:!printing!public! !
shortName!constants!public! !
!

!Kernel.StVariableNode class methodsFor!

icon
	^##((TextTileIcon text: $\x24B3 fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StVariableNode class categoriesForMethods!
icon!constants!public! !
!

!Kernel.StWorkspaceVariable methodsFor!

classification
	^#workspace!

printDescriptionOn: aStream
	aStream
		nextPutAll: 'Workspace variable ';
		nextPutAll: binding fullName.
	^true!

staticValueClass
	"Answer the class that the variable should be assumed to hold for the purposes of deducing what messages it may understand, or nil if not known with any certainty."

	^binding value basicClass! !

!Kernel.StWorkspaceVariable categoriesForMethods!
classification!accessing!public! !
printDescriptionOn:!accessing!public! !
staticValueClass!accessing!public! !
!

!Kernel.StWorkspaceVariable class methodsFor!

icon
	^##((TextTileIcon text: $\x24B2 fontName: 'Consolas')
		textcolor: Color navy;
		yourself)! !

!Kernel.StWorkspaceVariable class categoriesForMethods!
icon!constants!public! !
!

!OS._FPIEEE_RECORD methodsFor!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	aStream
		display: #roundingMode;
		nextPut: $=;
		display: self roundingModeName;
		space;
		display: #precision;
		nextPut: $=;
		display: self precisionName;
		space;
		display: #operation;
		nextPut: $=;
		display: self operationName;
		space.
	#(#cause #enabled #status) do: 
			[:each |
			aStream
				space;
				display: each;
				nextPut: $=.
			self printFlags: (self getField: each) on: aStream].
	#(#operand1 #operand2) do: 
			[:each |
			| value |
			value := self getField: each.
			value isValid
				ifTrue: 
					[aStream
						space;
						display: each;
						nextPut: $=;
						print: value]]! !

!OS._FPIEEE_RECORD categoriesForMethods!
printFieldsOn:!printing!private! !
!

!OS._FPIEEE_VALUE methodsFor!

printFieldsOn: aStream
	self isNull
		ifTrue: 
			[aStream nextPutAll: 'NULL'.
			^self].
	self isValid
		ifTrue: 
			[aStream
				display: #format;
				nextPut: $=;
				display: self formatName
			"Don't attempt to display the value as often this may result in overflow/underflow exceptions"]
		ifFalse: [aStream nextPutAll: '<invalid>']! !

!OS._FPIEEE_VALUE categoriesForMethods!
printFieldsOn:!printing!private! !
!

!OS.FILETIME methodsFor!

printOn: aStream
	"Append a debug representation of the receiver to aStream, which will be a UTC date/time."

	aStream
		basicPrint: self;
		nextPut: $(;
		print: self asDateAndTime;
		nextPut: $)! !

!OS.FILETIME categoriesForMethods!
printOn:!printing!public! !
!

!OS.KernelLibrary methodsFor!

queryThreadCycleTime: anExternalHandle cycleTime: aULARGE_INTEGER
	<stdcall: bool QueryThreadCycleTime handle qword*>
	^self invalidCall: _failureCode! !

!OS.KernelLibrary categoriesForMethods!
queryThreadCycleTime:cycleTime:!public!win32 functions-performance monitoring! !
!

!OS.LOGBRUSH methodsFor!

printFieldsOn: aStream
	aStream
		display: 'style=';
		print: self lbStyle;
		space;
		display: 'color=';
		print: self color.
	self hatchStyleName
		ifNotNil: 
			[:symbol |
			aStream
				space;
				display: 'hatch=';
				print: symbol]! !

!OS.LOGBRUSH categoriesForMethods!
printFieldsOn:!printing!private! !
!

!OS.LOGPEN methodsFor!

printFieldsOn: aStream
	aStream
		display: 'style=';
		print: self lopnStyle;
		space;
		display: 'width=';
		print: self width;
		space;
		display: 'color=';
		print: self color! !

!OS.LOGPEN categoriesForMethods!
printFieldsOn:!printing!private! !
!

!OS.LVITEMW methodsFor!

printableFields
	| fields i |
	fields := self getValidFields.
	i := fields identityIndexOf: #text.
	i == 0
		ifFalse: 
			[(bytes intPtrAtOffset: _OffsetOf_pszText) == OS.Win32Constants.LPSTR_TEXTCALLBACK
				ifTrue: [^fields copyWithoutIndex: i]].
	^fields! !

!OS.LVITEMW categoriesForMethods!
printableFields!printing!private! !
!

!OS.MSG methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	| msg |
	self basicPrintOn: aStream.
	msg := View selectorForMessage: self message.
	aStream nextPut: $(.
	self hwnd
		printOn: aStream
		base: 16
		showRadix: true.
	aStream space.
	msg isNil
		ifTrue: 
			[self message
				printOn: aStream
				base: 16
				showRadix: true]
		ifFalse: [aStream nextPutAll: msg].
	aStream
		space;
		print: self wParam;
		space;
		print: self lParam;
		nextPut: $)! !

!OS.MSG categoriesForMethods!
printOn:!printing!public! !
!

!OS.PALETTEENTRY methodsFor!

printFields: aCollection on: aStream
	aStream print: self color! !

!OS.PALETTEENTRY categoriesForMethods!
printFields:on:!printing!private! !
!

!OS.PrintDialogStructure methodsFor!

printableFields
	^#(#ownerView #devMode #devNames) , (super printableFields copyFrom: 5)! !

!OS.PrintDialogStructure categoriesForMethods!
printableFields!printing!private! !
!

!OS.PRINTDLGEXW methodsFor!

printableFields
	^#(#ownerView #devMode #flags #Flags2 #ExclusionFlags #pageRanges #printableRange #nCopies #nStartPage #dwResultAction)! !

!OS.PRINTDLGEXW categoriesForMethods!
printableFields!printing!private! !
!

!OS.RegKeyAbstract methodsFor!

debugPrintOn: aStream
	self printOn: aStream! !

!OS.RegKeyAbstract categoriesForMethods!
debugPrintOn:!printing!public! !
!

!OS.RGBQUAD methodsFor!

printFields: aCollection on: aStream
	aStream print: self color! !

!OS.RGBQUAD categoriesForMethods!
printFields:on:!printing!private! !
!

!OS.SYSTEMTIME methodsFor!

printOn: aStream
	"Append a debugging representation of the receiver to aStream."

	aStream 
		basicPrint: self;
		nextPut: $(; 
		display: self; 
		nextPut: $)
! !

!OS.SYSTEMTIME categoriesForMethods!
printOn:!printing!public! !
!

!OS.TVITEMW methodsFor!

printableFields
	| fields i |
	fields := self getValidFields.
	i := fields identityIndexOf: #pszText.
	i == 0
		ifFalse: 
			[(bytes intPtrAtOffset: _OffsetOf_pszText) == OS.Win32Constants.LPSTR_TEXTCALLBACK
				ifTrue: [^fields copyWithoutIndex: i]].
	^fields! !

!OS.TVITEMW categoriesForMethods!
printableFields!printing!private! !
!

!OS.VersionInfo class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect string: #fileDescription) beReadOnly;
		add: (Aspect string: #productName) beReadOnly;
		add: (Aspect string: #comments) beReadOnly;
		add: (Aspect string: #legalCopyright) beReadOnly;
		add: (Aspect string: #specialBuild) beReadOnly;
		add: (Aspect name: #fixedInfo);
		yourself! !

!OS.VersionInfo class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!OS.VS_FIXEDFILEINFO class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect string: #fileVersionString) beReadOnly;
		add: (Aspect string: #productVersionString) beReadOnly;
		yourself! !

!OS.VS_FIXEDFILEINFO class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!OS.WINDOWPOS methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	| flags separator |
	self isNull ifTrue: [^super printOn: aStream].
	aStream
		basicPrint: self;
		nextPutAll: '(after ';
		print: (View fromHandle: self hwndInsertAfter);
		nextPutAll: ', '.
	self isRectangleChanged
		ifTrue: 
			[aStream
				print: self rectangle;
				nextPutAll: ', '].
	flags := self flags.
	separator := 
			[separator := '|'.
			''].
	##((OS.Win32Constants keys select: [:each | each beginsWith: 'SWP_']) asSortedCollection asArray)
		do: 
			[:each |
			(flags allMask: (OS.Win32Constants at: each))
				ifTrue: 
					[aStream
						nextPutAll: separator value;
						nextPutAll: each]]! !

!OS.WINDOWPOS categoriesForMethods!
printOn:!printing!public! !
!

!Refactory.Browser.BrowserEnvironment methodsFor!

allMethods
	"Answer a <Collection> of all methods defined in the environment."

	| methods |
	methods := OrderedCollection new: 256.
	self methodsDo: [:each | methods addLast: each].
	^methods!

allResourcesDo: aBlock
	ResourceIdentifier allResourceIdentifiersDo: aBlock!

allSelectorsImplemented
	"Answer an <IdentitySet> of all the <Symbol>s which currently have at least one implementation in the scope of the receiver. This can include so-called 'dynamic selectors', which are messages that classes may respond to but which are not within the static set for which they implement methods."

	| selectors classes |
	selectors := IdentitySet new: 1000.
	classes := IdentitySet new: 50.
	self classesAndSelectorsDo: 
			[:class :selector |
			selectors add: selector.
			((classes addNewElement: class) and: [self definesClass: class])
				ifTrue: [class dynamicSelectorsDo: [:each | selectors add: each]]].
	^selectors!

allSelectorsSent
	"Answer a <Set> of all the <Symbol>s which are directly sent by methods in the scope of the receiver.
	N.B. This may take some time (depending on the BrowserEnvironment used), and will not contain any selectors 
	which are only sent dynamically with #perform(etc).
		(PackageEnvironment onEnvironment: BrowserEnvironment new packageNames: #('ActiveX Automation')) allSelectorsSent
	"

	| selectors excluded |
	selectors := (IdentitySet new: 512)
				addAll: VM specialSelectors;
				yourself.
	excluded := 'examples' asMethodCategory methods.
	self methodsDo: 
			[:each |
			(excluded includes: each) ifFalse: [each messagesDo: [:selector | selectors add: selector]]].
	^selectors!

browse
	^self openEditor!

definitionsOf: aString 
	"Answer a <BrowserEnvironment> that includes all methods with selectors matching
	the <readableString> selector pattern argument in this environment. The selector 
	pattern may be wildcarded."

	^(aString includesAnyOf: '*?#') 
		ifTrue: [self implementorsMatching: (aString copyReplacing: $? withObject: $#)]
		ifFalse: [self implementorsOf: aString asSymbol]!

forClassHierarchyFrom: aClass
	"Answers a <BrowserEnvironment> that includes only aClass and its subclasses, and the corresponding metaclasses. See also #forClassHierarchyOf:."

	^(self forClasses: (aClass withAllSubclasses asSet
				addAll: aClass class withAllSubclasses;
				yourself))
		label: (self subEnvironmentLabel: #subclassHierarchy for: aClass);
		yourself!

forClassHierarchyTo: aClass
	"Answers a <BrowserEnvironment> that includes aClass, its superclasses and subclasses, and the corresponding
	metaclasses. See also #forClassHierarchyFrom: and #forClassHierarchyOf:"

	^(self forClasses: (aClass withAllSuperclasses asSet
				addAll: aClass class withAllSuperclasses;
				yourself))
		label: (self subEnvironmentLabel: #superclassHierarchy for: aClass);
		yourself!

forMethodCategories: categoryList
	^MethodCategoryEnvironment onEnvironment: self categories: categoryList!

forPackagesClosure: aCollectionOfPackages
	| closure |
	closure := IdentitySet new.
	aCollectionOfPackages do: 
			[:each |
			closure add: each.
			each addAllPrerequisitesTo: closure].
	^self forPackages: closure!

includesMethod: aCompiledMethod
	"Answer whether this environment includes aCompiledMethod"

	^self includesSelector: aCompiledMethod selector in: aCompiledMethod methodClass!

includesMethodUncached: aCompiledMethod 
	"Answer whether this environment includes aCompiledMethod. If the environment uses any sort
	of cache to improve performance, then assume that the cache is stale with respect to the
	specified method."

	^self includesMethod: aCompiledMethod!

liveReferencesTo: anObject
	| aMethodSearch |
	aMethodSearch := MethodSearch newLiteral: anObject.
	^(self filterMethods: aMethodSearch simpleReferenceFilter)
		label: (self subEnvironmentLabel: #references for: anObject);
		addSearchString: aMethodSearch pattern;
		yourself!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	SmalltalkSystem current browseClass!

referencesToBinding: aBindingReference
	^(self filterMethods: [:method | method refersToLiteral: aBindingReference])
		label: (self subEnvironmentLabel: #bindingReferences for: aBindingReference);
		addSearchString: aBindingReference printString;
		yourself!

referencesToLiteral: anObject
	| methodSearch |
	methodSearch := MethodSearch newLiteral: anObject.
	^(self filterMethods: methodSearch simpleReferenceFilter)
		label: (self subEnvironmentLabel: #literalReferences for: anObject);
		search: methodSearch;
		yourself!

search
	^search ifNil: [MethodSearch newPattern: (self searchStrings at: 1 ifAbsent: '')]!

search: aMethodSearch 
	search := aMethodSearch.
	self addSearchString: search pattern!

subEnvironmentLabel: aSymbol for: anObject
	^(self labelFormats at: aSymbol) << {anObject. self}!

unimplementedSelectors
	"Answer a <Set> of all the <Symbol>s which are selectors actually sent by methods in the receiver but which have no corresponding implementation in the receiver. N.B. This may not include any messages sent dynamically with #perform:	and friends, and so should not be considered a guarantee that no send will ever result in a DNU (which, of course, cannot be guaranteed anyway because there is no way of knowing that the object to which the message is sent actually implements that message)."

	^self allSelectorsSent difference: self allSelectorsImplemented! !

!Refactory.Browser.BrowserEnvironment categoriesForMethods!
allMethods!public! !
allResourcesDo:!enumerating!public! !
allSelectorsImplemented!enquiries!public! !
allSelectorsSent!enquiries!public! !
browse!commands!public! !
definitionsOf:!enquiries!public! !
forClassHierarchyFrom:!environments!public! !
forClassHierarchyTo:!environments!public! !
forMethodCategories:!environments!public! !
forPackagesClosure:!helpers!public! !
includesMethod:!public!testing! !
includesMethodUncached:!public!testing! !
liveReferencesTo:!enquiries!public! !
openEditor!browsing!public! !
referencesToBinding:!enquiries!public! !
referencesToLiteral:!browsing!public! !
search!accessing!public! !
search:!accessing!public! !
subEnvironmentLabel:for:!environments!public! !
unimplementedSelectors!enquiries!public! !
!

!Refactory.Browser.BrowserEnvironmentWrapper methodsFor!

includesResource: aResourceIdentifier
	^self includesSelector: aResourceIdentifier selector in: aResourceIdentifier owningClass class!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	^SmalltalkSystem current browseEnvironment: self! !

!Refactory.Browser.BrowserEnvironmentWrapper categoriesForMethods!
includesResource:!public!testing! !
openEditor!browsing!public! !
!

!Refactory.Browser.ClassDetails class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Icon fromId: 'ClassDefinition.ico'! !

!Refactory.Browser.ClassDetails class categoriesForMethods!
icon!constants!public! !
!

!Refactory.Browser.ClassEnvironment methodsFor!

includesResource: aResourceIdentifier 
	^self definesClass: aResourceIdentifier owningClass! !

!Refactory.Browser.ClassEnvironment categoriesForMethods!
includesResource:!public!testing! !
!

!Refactory.Browser.RBAbstractClass methodsFor!

parseContext
	^ParseContext methodClass: self environment: self environment! !

!Refactory.Browser.RBAbstractClass categoriesForMethods!
parseContext!public!source filing-methods! !
!

!Refactory.Browser.RBConfigurableFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: (Aspect boolean: #formatCommentWithStatements);
		add: ((Aspect integer: #indentsForKeywords)
					beNonNullable;
					yourself);
		add: (Aspect string: #indentString);
		add: (Aspect boolean: #lineUpBlockBrackets);
		add: ((Aspect integer: #maxLineLength)
					beNonNullable;
					yourself);
		add: (Aspect boolean: #methodSignatureOnMultipleLines);
		add: ((Aspect integer: #minimumNewLinesBetweenStatements)
					beNonNullable;
					yourself);
		add: (Aspect boolean: #newLineAfterCascade);
		add: (Aspect boolean: #newLineBeforeFirstCascade);
		add: (Aspect boolean: #newLineBeforeFirstKeyword);
		add: ((Aspect integer: #newLinesAfterMethodComment)
					beNonNullable;
					yourself);
		add: ((Aspect integer: #newLinesAfterMethodPattern)
					beNonNullable;
					yourself);
		add: ((Aspect integer: #newLinesAfterTemporaries)
					beNonNullable;
					yourself);
		add: ((Aspect integer: #numberOfArgumentsForMultiLine)
					beNonNullable;
					yourself);
		add: (Aspect boolean: #periodsAsTerminators);
		add: (Aspect boolean: #retainBlankLinesBetweenStatements);
		add: (Aspect string: #stringFollowingReturn);
		add: (Aspect string: #stringInsideBlocks);
		add: (Aspect string: #stringInsideParentheses);
		add: ((Aspect sequenceableCollection: #traditionalBinaryPrecedence)
					beNonNullable;
					yourself);
		add: (Aspect boolean: #useTraditionalBinaryPrecedenceForParentheses);
		yourself! !

!Refactory.Browser.RBConfigurableFormatter class categoriesForMethods!
publishedAspects!constants!public! !
!

!Refactory.Browser.RBFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: ((Aspect integer: #maximumArgumentsPerLine)
					beNonNullable;
					yourself);
		add: ((Aspect sequenceableCollection: #selectorsToLeaveOnLine)
					beNonNullable;
					yourself);
		add: ((Aspect sequenceableCollection: #selectorsToStartOnNewLine)
					beNonNullable;
					yourself);
		yourself! !

!Refactory.Browser.RBFormatter class categoriesForMethods!
publishedAspects!constants!public! !
!

!Refactory.Browser.RBMethod methodsFor!

parseContext
	^ParseContext method: self! !

!Refactory.Browser.RBMethod categoriesForMethods!
parseContext!public! !
!

!Refactory.Browser.RBMethod class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #selector) beReadOnly;
		add: (Aspect name: #modelClass) beReadOnly;
		add: (Aspect multilineString: #source) beReadOnly;
		add: (Aspect name: #method) beReadOnly;
		yourself! !

!Refactory.Browser.RBMethod class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!Refactory.Browser.RBModel methodsFor!

defaultParseContext
	^ParseContext methodClass: (self classFor: UndefinedObject) environment: self smalltalkNamespace! !

!Refactory.Browser.RBModel categoriesForMethods!
defaultParseContext!public! !
!

!Refactory.Browser.RBSourceFormatter class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspects
		add: ((Aspect integer: #maxLineLength)
					beNonNullable;
					yourself);
		add: (Aspect boolean: #periodsAtEndOfMethod);
		yourself! !

!Refactory.Browser.RBSourceFormatter class categoriesForMethods!
publishedAspects!constants!public! !
!

!Refactory.Browser.RefactoryChange methodsFor!

displayOn: aPuttableStream
	"Append to the <puttableStream> argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttableStream nextPutAll: self displayString! !

!Refactory.Browser.RefactoryChange categoriesForMethods!
displayOn:!printing!public! !
!

!Refactory.Browser.SelectorEnvironment methodsFor!

addMethods: methodCollection 
	methodCollection do: [:each | self addClass: each methodClass selector: each selector]!

openEditor
	"Open an appropriate Dolphin browser on this environment."

	^SmalltalkSystem current browseMethodsIn: self! !

!Refactory.Browser.SelectorEnvironment categoriesForMethods!
addMethods:!adding!public! !
openEditor!browsing!public! !
!

!Refactory.Browser.VariableEnvironment methodsFor!

includesMethodUncached: aCompiledMethod 
	"Answer whether this environment includes aCompiledMethod. If the environment uses any sort
	of cache to improve performance, then assume that the cache is stale with respect to the
	specified method."

	self updateCachesForMethod: aCompiledMethod.
	^self includesMethod: aCompiledMethod!

updateCachesForMethod: aCompiledMethod 
	#todo.	"Not necessary to flush the whole cache for the class here"
	self flushCachesFor: aCompiledMethod methodClass! !

!Refactory.Browser.VariableEnvironment categoriesForMethods!
includesMethodUncached:!public!testing! !
updateCachesForMethod:!helpers!private! !
!

!Smalltalk class methodsFor!

publishedEvents
	"Answer a <Set> of <Symbol>s, being the names all the events published
    	by instances of the receiver."

	"Note that there are currently no #globalAdded: and #protocolAdded: events"

	^super publishedEvents
		add: #methodAdded:;
		add: #methodUpdated:;
		add: #methodRemoved:;
		add: #methodCategorized:;
		add: #classAdded:;
		add: #classUpdated:;
		add: #classRemoved:;
		add: #classCategorized:;
		add: #classCommented:;
		add: #variableRenamed:from:;
		add: #variableRemoved:;
		add: #protocolUpdated:;
		add: #protocolRemoved:;
		yourself!

renameVariable: oldName to: newName
	"Rename the global, informing the system of the change."

	| binding oldSymbol |
	binding := oldName asQualifiedReference binding.
	oldSymbol := binding key.
	binding environment
		changeKey: oldSymbol to: newName asSymbol;
		variableRenamed: binding from: oldSymbol! !

!Smalltalk class categoriesForMethods!
publishedEvents!events!public! !
renameVariable:to:!operations!public! !
!

!StyledGradientBrush class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect color: #startColor);
		add: (Aspect color: #endColor);
		add: (Aspect name: #startPoint);
		add: (Aspect name: #endPoint);
		yourself! !

!StyledGradientBrush class categoriesForMethods!
publishedAspectsOfInstances!public! !
!

!StyledPen class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect color: #color);
		add: (Aspect name: #dashPattern);
		add: (Aspect number: #width);
		yourself	"For now we don't allow the width to be adjusted in the VC because there are problems"! !

!StyledPen class categoriesForMethods!
publishedAspectsOfInstances!public! !
!

!UI.AbstractCardContainer class methodsFor!

publishedAspectsOfInstances
    	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."
    
    	^(super publishedAspectsOfInstances)
    		removeKey: #layoutManager;
    		yourself!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #currentCardChangedFrom:to:;
		yourself! !

!UI.AbstractCardContainer class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.AbstractDocumentShell methodsFor!

saveStateOn: aWriteStream
	"Private - Write the source of a monadic block that will configure an instance of the receiver's class
	to match the state current receiver, to aWriteStream. The block expects a fresh instance of
	the receiver's class as it's parameter"

	aWriteStream nextPutAll: '[:aDocumentShell | 
	aDocumentShell setDocumentData: '.
	self getDocumentData literalStoreEvaluationOn: aWriteStream.
	';
		filename: <1p>]' expandMacrosWithArguments: {self filename} on: aWriteStream! !

!UI.AbstractDocumentShell categoriesForMethods!
saveStateOn:!private!saved state! !
!

!UI.AbstractToTextConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #locale);
		yourself! !

!UI.AbstractToTextConverter class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.AXControlSite class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect
					name: #progId
					presenterBlock: [:p :m | TextPresenter createIn: p on: m]
					editBlock: [:p | p model value: (self chooseControl: p model value)]);
		add: (Aspect name: #controlDispatch) beReadOnly;
		add: (Aspect name: #yourself editBlock: [:p | p model value editControlProperties]);
		add: (Aspect boolean: #firesPropertyNotifications);
		add: (Aspect boolean: #firesControlEvents);
		add: (Aspect boolean: #allowContextMenu);
		add: (Aspect boolean: #isDesignMode);
		add: (Aspect boolean: #isDefault);
		add: (Aspect string: #licenseKey);
		yourself! !

!UI.AXControlSite class categoriesForMethods!
publishedAspectsOfInstances!constants!must strip!public! !
!

!UI.AXValueConvertingControlSite class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect choice: #typeconverter
					evaluationFrom: 
						[| applicableTypeConverters |
						applicableTypeConverters := Set new.
						self applicableTypeConverterCategories do: [:each | applicableTypeConverters addAll: each classes].
						applicableTypeConverters asSortedArray collect: [:each | each shortName , ' new']])
						beImmutable;
		add: (Aspect name: #value);
		yourself! !

!UI.AXValueConvertingControlSite class categoriesForMethods!
publishedAspectsOfInstances!constants!must strip!public! !
!

!UI.BasicListAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #canHScroll);
		yourself! !

!UI.BasicListAbstract class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.BooleanToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	#todo.	"Change this to use Aspect class>>choice:from:andNil:. Currently PublishedAspectInspectorTest>>testImmutableAspect2 relies on this old form that only opens the choices in a dialog."
	^super publishedAspectsOfInstances
		add: (Aspect name: #format
					chooseFrom: #('nil' '#(''false'' ''true'')' '#(''no'' ''yes'')' '#(''off'' ''on'')')) beImmutable;
		yourself! !

!UI.BooleanToText class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.BorderLayout methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that are managed
	by the receiver."

	^(Aspect
		choice: #arrangement
		from: #(#north #south #east #west #center)
		andNil: #none)
		type: Symbol;
		yourself! !

!UI.BorderLayout categoriesForMethods!
arrangementAspect!accessing!private! !
!

!UI.BorderLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #horizontalGap);
		add: (Aspect integer: #verticalGap);
		yourself! !

!UI.BorderLayout class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.CardContainer class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect font: #font);
		add: (Aspect boolean: #hasButtons);
		add: (Aspect boolean: #hasHotTracking);
		add: (Aspect boolean: #isMultiline);
		add: (Aspect symbol: #tabOrientation from: [TabView tabOrientations values]);
		add: (Aspect symbol: #viewMode from: [TabView viewModes keys asSortedArray]);
		add: (Aspect block: #getImageBlock);
		add: (Aspect block: #getTextBlock);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #currentCardChanging:;
    		yourself.
    ! !

!UI.CardContainer class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.CardLabel class methodsFor!

publishedAspectsOfInstances
	^super publishedAspectsOfInstances
		add: (Aspect string: #text);
		add: (Aspect block: #iconBlock);
		add: (Aspect integer: #helpId);
		yourself! !

!UI.CardLabel class categoriesForMethods!
publishedAspectsOfInstances!public! !
!

!UI.CardLayout class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^super publishedEventsOfInstances
		add: #currentCardChangedFrom:to:;
		yourself! !

!UI.CardLayout class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.CheckBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #is3State);
		yourself! !

!UI.CheckBox class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.CheckButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #value);
		add: (Aspect boolean: #hasLeftText);
		add: (Aspect boolean: #isPushLike);
		add: (Aspect name: #image);
		add: (Aspect symbol: #alignment from: ##(AlignmentMap keys asSortedArray));
		yourself! !

!UI.CheckButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ColorView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		removeKey: #backcolor;
		add: (Aspect color: #value);
		yourself! !

!UI.ColorView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ComboBox methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self presenter! !

!UI.ComboBox categoriesForMethods!
visualObjectAtPoint:!enquiries!private! !
!

!UI.ComboBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #droppedHeight);
		add: (Aspect symbol: #mode from: Modes);
		add: (Aspect boolean: #canHScroll);
		yourself! !

!UI.ComboBox class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.CommandDescription methodsFor!

commandString: commandText
	"Sets the receiver's command from the <readableString> representation, commandText."

	| c |
	c := Compiler evaluate: commandText.
	c notNil ifTrue: [self command: c]! !

!UI.CommandDescription categoriesForMethods!
commandString:!accessing!initializing!public! !
!

!UI.CommandDescription class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: ((Aspect name: #command)
					icon: Message icon;
					yourself);
		add: (Aspect string: #description);
		add: (Aspect hotkey: #acceleratorKey);
		add: (Aspect boolean: #isModalCommand);
		add: (Aspect boolean: #hasTextSubstitutions);
		add: (Aspect icon: #image);
		yourself! !

!UI.CommandDescription class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.CommandMenuItem methodsFor!

commandString: commandText
	"Sets the receiver's command from the <readableString> representation, commandText."

	self commandDescription commandString: commandText!

edit
	"Private - Edit the receiver in a dialog box."

	(CommandMenuItemDialog createOn: self) showModal! !

!UI.CommandMenuItem categoriesForMethods!
commandString:!accessing!public! !
edit!operations!private! !
!

!UI.CommandMenuItem class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: ((Aspect name: #commandDescription)
					icon: Message icon;
					yourself);
		add: (Aspect boolean: #isRadioButtonStyle);
		add: (Aspect boolean: #isDefault);
		add: (Aspect icon: #image);
		yourself! !

!UI.CommandMenuItem class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ContainerView class methodsFor!

applicableLayoutManagerCategories
	"Answers a Set of class category containing LayoutManagers that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Layout Managers-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect rectangle: #insets) beImmutable;
		add: ((Aspect choice: #layoutManager
					evaluationFrom: 
						[| categories |
						categories := self applicableLayoutManagerCategories.
						#('nil')
							, ((LayoutManager allSubclasses
									select: [:each | categories anySatisfy: [:cat | cat includesClass: each]]) asSortedArray
									collect: [:each | each shortName , ' new'])])
					type: LayoutManager;
					beImmutable;
					yourself);
		add: (Aspect boolean: #clipChildren);
		yourself! !

!UI.ContainerView class categoriesForMethods!
applicableLayoutManagerCategories!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.ControlBarAbstract class methodsFor!

applicableLayoutManagerCategories
	"Answers a Set of class category containing LayoutManagers that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Layout Managers-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		removeKey: #text;
		add: (Aspect boolean: #hasDivider);
		add: (Aspect choice: #layoutManager
					evaluationFrom: 
						[| categories |
						categories := self applicableLayoutManagerCategories.
						#('nil')
							, ((LayoutManager allSubclasses
									select: [:each | categories anySatisfy: [:cat | cat includesClass: each]]) asSortedArray
									collect: [:each | each shortName , ' new'])])
						beImmutable;
		yourself! !

!UI.ControlBarAbstract class categoriesForMethods!
applicableLayoutManagerCategories!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.ControlView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect color: #forecolor);
		yourself
	"We really need these notifications, so probably not wise to allow them to be turned off"
	"add: (Aspect boolean: #wantParentNotifications);"! !

!UI.ControlView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.DateTimeCommonControl methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^super publishedAspects
		add: (self modelClass newInstanceAspect: #minimum class: Aspect);
		add: (self modelClass newInstanceAspect: #maximum class: Aspect);
		add: (self modelClass newInstanceAspect: #value class: Aspect);
		yourself! !

!UI.DateTimeCommonControl categoriesForMethods!
publishedAspects!public! !
!

!UI.DateTimePicker class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #isTimeMode);
		add: (Aspect boolean: #hasUpDown);
		add: (Aspect boolean: #canShowNone);
		add: (Aspect boolean: #hasLongDateFormat);
		add: (Aspect boolean: #isRightAligned);
		add: (Aspect name: #displayFormat);
		yourself! !

!UI.DateTimePicker class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.DateToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect string: #format);
		yourself! !

!UI.DateToText class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.FlowLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #horizontalGap);
		add: (Aspect integer: #verticalGap);
		add: (Aspect symbol: #alignment from: ##(AlignmentMap keys asSortedArray));
		yourself! !

!UI.FlowLayout class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.FontView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect font: #value);
		add: (Aspect string: #previewText);
		yourself! !

!UI.FontView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.FramingCalculation class methodsFor!

allCalculations
	"This is a design-time method for accessing the complete set of available framing
	calculations so that the user may choose between them. A refelective means of determing the
	set of calculations is used in order to allow the set of available calculations to be lazily
	created at runtime (i.e. after image stripping) , and also to allow for user-extensibility
	without the need to modify a system (class #initialize) method. To add new framing
	calculations follow the pattern of the existing calcs and ensure that the lazy accessor
	method is placed in the 'instance creation' category in order for the calculation to be
	offered as a choice in the view composer."

	^(('instance creation' asMethodCategory methodsInBehavior: self class)
		select: [:each | each argumentCount = 0]) collect: [:each | each value: self withArguments: #()]! !

!UI.FramingCalculation class categoriesForMethods!
allCalculations!accessing!public! !
!

!UI.FramingConstraints class methodsFor!

calculationNames: aBoolean except: aSymbol
	^(self calculationClass allCalculations
		select: [:each | each isVertical == aBoolean and: [each name ~~ aSymbol]])
			collect: [:each | each name]!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #topOffset);
		add: (Aspect symbol: #topFraming
					from: [FramingConstraints calculationNames: true except: #fixedViewTop]);
		add: (Aspect integer: #bottomOffset);
		add: (Aspect symbol: #bottomFraming
					from: [FramingConstraints calculationNames: true except: #fixedViewBottom]);
		add: (Aspect integer: #leftOffset);
		add: (Aspect symbol: #leftFraming
					from: [FramingConstraints calculationNames: false except: #fixedViewLeft]);
		add: (Aspect integer: #rightOffset);
		add: (Aspect symbol: #rightFraming
					from: [FramingConstraints calculationNames: false except: #fixedViewRight]);
		yourself! !

!UI.FramingConstraints class categoriesForMethods!
calculationNames:except:!constants!private! !
publishedAspectsOfInstances!constants!public! !
!

!UI.FramingLayout methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that
    	are managed by the recever. Since the aspect contains a <FramingConstraints> instance
    	this must be marked as immutable to ensure that the changes are flushed back correctly"

	^(Aspect name: #arrangement) beImmutable! !

!UI.FramingLayout categoriesForMethods!
arrangementAspect!accessing!private! !
!

!UI.FramingLayout class methodsFor!

example1
	"A simple example of building a view with a framing layout.
	
		FramingLayout example1
	"

	| shell layout label button text1 text2 |
	(shell := View desktop addSubView: ShellView new)
		caption: 'FramingLayout example 1';
		backcolor: Color face3d;
		layoutManager: (layout := FramingLayout new);
		extent: 300 @ 200.
	shell insets: (10 @ 10 corner: 10 @ 10).
	label := shell addSubView: StaticText new.
	button := shell addSubView: PushButton new.
	text1 := shell addSubView: MultilineTextEdit new.
	text2 := shell addSubView: MultilineTextEdit new.
	label text: 'Fixed @ Top Left'.
	label rectangle: (10 @ 10 extent: 100 @ 20).
	button
		text: 'Hugs topright';
		command: #yourself.
	button arrangement
		leftFraming: #fixedViewRight;
		rightFraming: #fixedParentRight;
		leftOffset: -100;
		rightOffset: 0.
	text1
		text: 'Consumes half the width and all the bottom space';
		wordWrap: true.
	text1 arrangement
		rightFraming: #relativeParentWidth;
		bottomFraming: #fixedParentBottom.
	layout resize: text1 to: (10 @ 40 corner: 130 @ 190).
	text2
		text: 'Floats in the same relative postion, keeps same extent';
		wordWrap: true.
	text2 arrangement
		leftFraming: #relativeParentWidth;
		rightFraming: #fixedViewLeft;
		topFraming: #relativeParentHeight;
		bottomFraming: #fixedViewTop.
	layout resize: text2 to: (140 @ 40 corner: 290 @ 80).
	shell show! !

!UI.FramingLayout class categoriesForMethods!
example1!examples!public! !
!

!UI.GridLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #horizontalGap);
		add: (Aspect integer: #verticalGap);
		add: (Aspect integer: #rows);
		add: (Aspect integer: #columns);
		yourself! !

!UI.GridLayout class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.GroupBox class methodsFor!

publishedAspectsOfInstances
    	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."
    
    	^(super publishedAspectsOfInstances)
		removeKey: #forecolor;		"#1191: Windows BUTTON control doesn't support changing the foreground colour"
    		yourself! !

!UI.GroupBox class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.HotKey class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect autostring: #value);
		add: (Aspect name: #invalidCombinationsMask);
		add: (Aspect name: #defaultKeyMask);
		removeKey: #typeconverter;
		yourself! !

!UI.HotKey class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.IconicListAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#getImageBlock #getInfoTipBlock #customDrawBlock) do: [:each | aspects add: (Aspect block: each)].
	#(#hasHotTracking) do: [:each | aspects add: (Aspect boolean: each)].
	aspects
		add: (Aspect symbol: #viewMode from: [self viewModes keys asSortedArray]);
		yourself.
	^aspects!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
	^(super publishedEventsOfInstances)
    		add: #labelOf:changedTo:;
    		add: #aboutToEditLabel:accept:;
    		add: #labelOf:editedTo:accept:;
		yourself! !

!UI.IconicListAbstract class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.ImagePresenter class methodsFor!

resource_ImageList_view
	"Answer the literal data from which the 'ImageList view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_ImageList_view)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{Tools.ImageListView} 38 #{Core.Array} 21 nil nil 50 2 8 1140850944 1 32 1094 2 #{UI.ValueHolder} nil false 6 #{Kernel.EqualitySearchPolicy} nil 6 #{Graphics.Color} #default nil 5 nil nil nil 32 nil nil 518 #{UI.NullConverter} nil nil nil nil #normal 1 nil #none 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 338 225 201 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 111 12 0 0 110 0 0 0] 8 #() 338 193 193 nil 27)! !

!UI.ImagePresenter class categoriesForMethods!
resource_ImageList_view!public!resources-views! !
!

!UI.ImageViewAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect bitmap: #value);
		add: (Aspect symbol: #viewMode from: self viewModes);
		add: (Aspect boolean: #isWholeBackgroundErased);
		add: (Aspect boolean: #isDoubleBuffered);
		add: (Aspect rectangle: #insets);
		add: (Aspect symbol: #imageBorder from: self edgeStyles);
		yourself! !

!UI.ImageViewAbstract class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.LayoutManager methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that
    	are managed by the recever. The default is to allow for a workspace to edit the
    	arrangement"

	^Aspect name: #arrangement! !

!UI.LayoutManager categoriesForMethods!
arrangementAspect!accessing!private! !
!

!UI.ListBox class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#canHScroll #hasPermanentScrollbars #isReadOnly) do: [:each | aspects add: (Aspect boolean: each)].
	aspects add: (Aspect extent: #horizontalExtent).
	aspects add: (Aspect symbol: #selectionMode from: ##(SelectionModes keys asSortedArray)).
	^aspects! !

!UI.ListBox class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ListControlView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	| object |
	object := super visualObjectAtPoint: aPoint.
	^(self itemFromPoint: aPoint) 
		ifNil: [object]
		ifNotNil: [:item | self objectFromHandle: item ifAbsent: [object]]! !

!UI.ListControlView categoriesForMethods!
visualObjectAtPoint:!enquiries!private! !
!

!UI.ListControlView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect block: #getTextBlock);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #selectionChanged;
    		add: #selectionChanging:;
    		yourself.
    ! !

!UI.ListControlView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.ListModel class methodsFor!

publishedEventsOfInstances
	"Answer a <Set> of <Symbol>s that describe the published events triggered by instances of
	the receiver."

	^(super publishedEventsOfInstances)
		add: #item:updatedAtIndex:;
		add: #item:addedAtIndex:;
		add: #items:addedAtIndex:;
		add: #item:removedAtIndex:;
		add: #listChanged;
		yourself! !

!UI.ListModel class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.ListTreeView class methodsFor!

publishedAspectsOfInstances
	"answer the <Aspect>s published by instances of the receiver"

	^super publishedAspectsOfInstances
		removeKey: #hasCheckBoxes ifAbsent: nil;
		add: (Aspect boolean: #hasButtons);
		add: (Aspect boolean: #hasLinesAtRoot);
		add: (Aspect boolean: #hasHotTracking);
		add: (Aspect integer: #indentSeparation);
		add: (Aspect boolean: #disableExpandAll);
		add: (Aspect boolean: #retainExpanded);
		add: (Aspect boolean: #useSmartRefresh);
		add: (Aspect block: #hasChildrenBlock);
		add: (Aspect block: #getChildrenBlock);
		add: (Aspect block: #getParentBlock);
		add: (Aspect block: #sortBlock);
		add: (Aspect boolean: #doSortRoots);
		add: (Aspect block: #doSortChildrenBlock);
		yourself	"	-- uses the same 'state' stuff as we need for 'buttons'"
	"		add: (Aspect boolean: #hasLines);					-- dummied out, we don't have any lines :-( "	"	-- really means #hasButtonsAtRoot"
	"		add: (Aspect boolean: #isMonoExpandable);		-- dummied out, too much effort for no value"
	"		add: (Aspect choice: #updateMode from: TreeView updateModes);
											-- dummied out, not meaningful for lists"!

publishedEventsOfInstances
	"answer a Set of Symbols that describe the published events triggered
	by instances of the receiver.
	ListTreeViews generate a few extra events that would be useful coming
	off TreeViews too (as with most views, the events are actually triggered
	off our presenter)"

	^ super publishedEventsOfInstances
		add: #nodeAdded:;
		add: #nodeRemoved:;
		add: #nodeExpanded:;
		add: #nodeCollapsed:;
		yourself.! !

!UI.ListTreeView class categoriesForMethods!
publishedAspectsOfInstances!constants!do copy!must strip!public! !
publishedEventsOfInstances!constants!do copy!events!public! !
!

!UI.ListView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	#(#isVirtual #hasColumnHeaders #hasFullRowSelect #hasGridLines #hasHeaderDragDrop #hasColumnImages #hasSortHeaders #hasFlatScrollbars #hasInfoTips #canEditLabels #showsSelAlways #hasCheckBoxes #isMultiSelect #isAutoArranged #isDoubleBuffered)
		do: [:each | answer add: (Aspect boolean: each)].
	answer
		add: (Aspect autostring: #text);
		add: (Aspect bitmap: #backImage) beImmutable;
		add: (Aspect boolean: #backImageIsTiled);
		add: (Aspect position: #backImageOffset);
		add: (Aspect integer: #backImageAlphaPercent) beImmutable;
		add: (Aspect point: #iconSpacing);
		add: (Aspect choice: #thumbnailExtent from: ##({64 @ 64. 96 @ 96. 128 @ 128}));
		add: (Aspect sequenceableCollection: #columnOrder) beImmutable;
		add: (Aspect sequenceableCollection: #columnsList
					addEvaluationFrom: {self columnClass shortName , ' new'}) beImmutable;
		removeKey: #text.
	^answer!

publishedEventsOfInstances
	^super publishedEventsOfInstances
		add: #viewModeChanged;
		yourself! !

!UI.ListView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.ListViewColumn class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect autostring: #text);
		add: (Aspect integer: #width);
		add: (Aspect block: #getContentsBlock);
		add: (Aspect block: #getImageBlock);
		add: (Aspect block: #getTextBlock);
		add: (Aspect block: #sortBlock);
		add: (Aspect symbol: #alignment from: #(#left #center #right));
		add: (Aspect boolean: #isAutoResize);
		add: (Aspect block: #getInfoTipBlock);
		add: (Aspect block: #customDrawBlock);
		yourself! !

!UI.ListViewColumn class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Menu methodsFor!

edit
	"Private - Edit the receiver in a dialog box."

	(MenuDialog createOn: self) showModal!

painterClass
	"Private - Answer the class of painter used for rendering the receiver in a
	MenuComposerView."

	^PopupMenuPainter! !

!UI.Menu categoriesForMethods!
edit!constants!private! !
painterClass!constants!private! !
!

!UI.Menu class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	"Note that the #items aspect must be immutable because the #items method answers an
	OrderedCollection which is a copy of the actual items Array."

	^super publishedAspectsOfInstances
		add: (Aspect string: #text);
		add: ((Aspect sequenceableCollection: #items
					addEvaluationFrom: #('Menu new' 'CommandMenuItem new' 'DividerMenuItem separator' 'DividerMenuItem barBreak' 'DividerMenuItem break'))
					beImmutable;
					icon: CommandMenuItem icon;
					yourself);
		add: (Aspect string: #name);
		add: (Aspect boolean: #isAutoDismiss);
		add: (Aspect boolean: #hasSharedImageColumn);
		add: (Aspect icon: #image);
		yourself! !

!UI.Menu class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.MenuBar methodsFor!

painterClass
	"Private - Answer the class of painter used for rendering the receiver in a
	MenuComposerView."

	^MenuBarPainter! !

!UI.MenuBar categoriesForMethods!
painterClass!constants!private! !
!

!UI.MenuBar class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass menuBar: aSymbol!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^(super publishedAspectsOfInstances)
		removeKey: #text;
		yourself! !

!UI.MenuBar class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
publishedAspectsOfInstances!constants!public! !
!

!UI.MenuItem class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Menu icon! !

!UI.MenuItem class categoriesForMethods!
icon!constants!public! !
!

!UI.MoenTreeView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	| object |
	object := super visualObjectAtPoint: aPoint.
	^(self itemFromPoint: aPoint) ifNil: [object] ifNotNil: [:node | node object]! !

!UI.MoenTreeView categoriesForMethods!
visualObjectAtPoint:!enquiries!private! !
!

!UI.MoenTreeView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect block: #getTextBlock);
		add: (Aspect block: #getImageBlock);
		add: (Aspect integer: #parentSpacing);
		add: (Aspect name: #linePen);
		add: (Aspect name: #maxTextExtent);
		add: (Aspect boolean: #hasWordWrap);
		add: (Aspect name: #margin);
		add: (Aspect boolean: #hasButtons);
		add: (Aspect boolean: #isAutoExpanding);
		add: (Aspect symbol: #viewMode from: ##(ViewModes keys asSortedArray));
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #selectionChanged;
    		add: #selectionChanging:;
    		yourself.
    ! !

!UI.MoenTreeView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.MonthCalendarView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #hasToday);
		add: (Aspect boolean: #hasTodayCircle);
		add: (Aspect boolean: #hasWeekNumbers);
		add: (Aspect name: #firstDayOfWeek
					presenterBlock: 
						[:parent :model |
						| dayMap days |
						dayMap := LookupTable new.
						days := (1 to: 7) collect: 
										[:each |
										| day |
										day := Locale default dayOfWeekName: (each + 1) \\ 7.
										dayMap at: day put: each.
										day].
						(ChoicePresenter createIn: parent
							on: (ValueConverter subject: model
									typeConverter: ((MappingConverter rightToLeft: dayMap)
											leftNullValue: 0;
											yourself)))
							choices: days;
							yourself]);
		yourself! !

!UI.MonthCalendarView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.MultilineTextEdit class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #canVScroll);
		add: (Aspect boolean: #wantTab);
		add: (Aspect multilineString: #text);
		add: (Aspect boolean: #wantReturn);
		add: (Aspect boolean: #wordWrap);
		yourself! !

!UI.MultilineTextEdit class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.PluggableTypeConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #leftToRightBlock);
		add: (Aspect name: #rightToLeftBlock);
		yourself! !

!UI.PluggableTypeConverter class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Presenter methodsFor!

systemModel
	^self parentPresenter ifNil: [SmalltalkSystem current] ifNotNil: [:parent | parent systemModel]! !

!UI.Presenter categoriesForMethods!
systemModel!accessing!public! !
!

!UI.Presenter class methodsFor!

addView: aViewClass asResource: aStringName
	"Adds a default instance of aViewClass as a resource of the receiver called aStringName"

	aViewClass makeResource: aStringName inClass: self !

defaultAcceleratorKeyBindings
	^Dictionary withAll: (self additionalAccelerators
				collect: [:each | (AcceleratorTable canonicalizeKeyString: each second) -> each first])!

editNewDefaultView
	"Open the View Composer to create a new view for the receiver."

	| resourceIdentifier vc resName prompter |
	prompter := Prompter
				createOn: self defaultView
				prompt: 'Resource name:'
				caption: 'Create a view for class ' , self name.
	prompter validater: 
			[:proposedName |
			(ResourceIdentifier isValidResourceName: proposedName)
				ifTrue: [ValidationResult new]
				ifFalse: [ValidationResult errorMessage: '<p> is not a valid resource name' << proposedName]].
	resName := prompter showModal.
	resName isNil ifTrue: [^self].
	resourceIdentifier := ResourceIdentifier class: self name: resName.
	(resourceIdentifier exists not or: 
			[MessageBox new
				headline: 'Overwrite <1p>?' << resourceIdentifier;
				confirm: '<1p> already exists. Do you wish to overwrite it?' << resourceIdentifier])
		ifFalse: [^self].
	vc := SmalltalkSystem current openViewComposerEmpty.
	vc
		openOnCopyOf: self defaultResourceIdentifier;
		resourceIdentifier: resourceIdentifier! !

!UI.Presenter class categoriesForMethods!
addView:asResource:!operations!public! !
defaultAcceleratorKeyBindings!options!private! !
editNewDefaultView!operations!public! !
!

!UI.ProgressBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #range);
		add: (Aspect boolean: #isSmooth);
		add: (Aspect boolean: #isMarquee);
		yourself! !

!UI.ProgressBar class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ProportionalLayout methodsFor!

arrangementAspect
	"Private - Answer an Aspect description for the arrangement aspect of Views that are managed by the recever."

	^Aspect number: #arrangement! !

!UI.ProportionalLayout categoriesForMethods!
arrangementAspect!accessing!private! !
!

!UI.ProportionalLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #isVertical);
		yourself! !

!UI.ProportionalLayout class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.PushButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer
		add: ((Aspect name: #commandDescription type: CommandDescription)
					beReadOnly;
					yourself);
		add: (Aspect boolean: #isDefault);
		add: (Aspect boolean: #hasFlatAppearance);
		add: (Aspect icon: #image);
		add: (Aspect symbol: #style from: ##(ButtonStyleMap keys asSortedArray));
		yourself.

	"#1191: Windows BUTTON control doesn't support changing the foreground colour"
	answer
		removeKey: #forecolor;
		yourself.
	^answer! !

!UI.PushButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ReferenceView methodsFor!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self referee visualObjectAtPoint: aPoint! !

!UI.ReferenceView categoriesForMethods!
visualObjectAtPoint:!enquiries!private! !
!

!UI.ReferenceView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #resourceIdentifier);
		removeAllKeys: #(#hasBorder #hasClientEdge #hasStaticEdge #usePreferredExtent #preferredExtent #font #isTransparent #isEnabled #text);
		yourself! !

!UI.ReferenceView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ResourceIdentifier methodsFor!

assign: resourceData 
	"Assign aResource as the resource data represented by the receiver."

	resourceData assignToResourceIdentifier: self!

assignLiteralResourceData: aLiteralArray
	"Private - Assign aResource as the resource data represented by the receiver."

	| stream filer source methodClass categories |
	stream := String writeStream: 512.
	"The 2nd entry in the literal array is the STL version; if < 5, then this is pre-D8 content and we need to use the legacy filer"
	filer := ((aLiteralArray at: 2) < 5
				ifTrue: [#{LegacyChunkSourceFiler} value]
				ifFalse: [ChunkSourceFiler]) on: stream.
	"Historically integers have been written in decimal format in resource method literals"
	stream locale: SmalltalkLocale.Current.
	filer emitResourceMethod: self literals: aLiteralArray.
	source := stream contents.
	methodClass := self owningClass class.
	categories := Set with: self class viewResourceCategoryName.
	(methodClass whichCategoriesIncludeSelector: selector) do: [:each | categories add: each name].
	methodClass compile: source categories: categories!

assignView: aView
	| stream |
	stream := Array writeStream: 128.
	aView binaryStoreUsing: (self stlFilerClass on: stream).
	self assign: stream contents!

browse
	^self edit!

edit
	"Invoke a suitable editor on the resource identified by the receiver."

	ViewComposer openOn: self!
editViewUsing: aMonadicBlock
	| view |
	view := self loadWithContext: DesignDesktopView forSystemDpi.
	aMonadicBlock value: view.
	self assign: view literalStoreArray.
	view destroy!

hiddenObjects
	"Private - Answers a <collection> of the <Object>s that are contained in the receiver's resource
	The View resources will not be realized as actual windows."

	self resource
		ifNil: [self error: 'Resource [' , owningClass fullName , '>>#' , selector , '] does not exist']
		ifNotNil: 
			[:resource |
			^(STLInFiler on: resource readStream)
				basicNext;
				elements]!

prompt
	"Prompt for and answer a new ResourceIdentifier using the receiver to give the default settings."

	^(((self owningClass == Presenter
		or: [self owningClass isNil or: [self owningClass owningPackage isNil]])
			ifTrue: [SmalltalkSystem current resourceIdentifierDialogClass]
			ifFalse: [SmalltalkSystem current packagedResourceIdentifierDialogClass]) createOn: self)
		showModal!

publishedAspects
	| answer class |
	answer := super publishedAspects.
	class := self owningClass.
	class isBehavior
		ifTrue: 
			[answer add: (Aspect
						choice: #name
						from: [(class resourceIdentifiers collect: [:each | each name]) asSortedCollection]
						type: String)].
	^answer!

reassign
	| view |
	view := Smalltalk developmentSystem loadViewResource: self resource
				inContext: DesignDesktopView forDefaultDpi.
	self assignView: view.
	view destroy!

sourceFilerClass
	^(self owningPackage ifNil: [self owningClass]) sourceFilerClass! !

!UI.ResourceIdentifier categoriesForMethods!
assign:!accessing!public! !
assignLiteralResourceData:!development!private! !
assignView:!public! !
browse!commands!public! !
edit!operations!public! !
editViewUsing:!operations!public! !
hiddenObjects!accessing!private! !
prompt!operations!public! !
publishedAspects!constants!public! !
reassign!public! !
sourceFilerClass!development!private! !
!

!UI.ResourceIdentifier class methodsFor!

prompt
	"Prompt for and answer a new ResourceIdentifier."

	^(self class: nil name: 'Default view') prompt!

publishedAspectsOfInstances
	^super publishedAspectsOfInstances
		add: (Aspect name: #owningClass);
		add: (Aspect string: #name);
		yourself! !

!UI.ResourceIdentifier class categoriesForMethods!
prompt!instance creation!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.RichTextEdit class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver.
    	Implementation Note: We remove some superclass aspects because ES_NUMBER 
    	style has no effect on RichEdit and neither do ES_CENTER or ES_RIGHT."

	^super publishedAspectsOfInstances
		add: (Aspect richText: #text);
		removeKey: #format;
		removeKey: #alignment;
		yourself! !

!UI.RichTextEdit class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.RichTextPresenter class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #linkClicked:;
		yourself! !

!UI.RichTextPresenter class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.Scintilla.Attribute class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects add: (Aspect integer: #id) beReadOnly.
	self propertyDescriptors
		do: [:each | each isNonBrowsable ifFalse: [aspects add: each aspectDescriptor]].
	^aspects! !

!UI.Scintilla.Attribute class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.BoolPropertyDescriptor methodsFor!

aspectDescriptor
	^self isNullable ifTrue: [Aspect nullableBoolean: key] ifFalse: [Aspect boolean: key]! !

!UI.Scintilla.BoolPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.CharacterClassifications methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	"This override is necessary to avoid implementation details being included by the 
    	default implementation in Object>>publishedAspects for an empty Dictionary."

	^(self publishedKeyedAspects)
		addAll: self class publishedAspectsOfInstances;
		yourself!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	^LookupTable new
		addAll: ((Scintilla.CharacterClassificationBatchAccessor
					subject: self
					keys: self keys
					startingAt: 1
					batchSize: 128) getBatchAccessors
					collect: [:each | each aspectDescriptor]);
		yourself! !

!UI.Scintilla.CharacterClassifications categoriesForMethods!
publishedAspects!constants!public! !
publishedKeyedAspects!public! !
!

!UI.Scintilla.CharacterRepresentation class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #character);
		add: (Aspect boolean: #isBlob);
		add: (Aspect string: #representation);
		add: (Aspect color: #color);
		yourself! !

!UI.Scintilla.CharacterRepresentation class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.ColourAlphaPropertyDescriptor methodsFor!

aspectDescriptor
	^(Aspect color: key)
		isNullable: self isNullable;
		defaultValue: defaultValue;
		yourself! !

!UI.Scintilla.ColourAlphaPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.ColourPropertyDescriptor methodsFor!

aspectDescriptor
	^(Aspect color: key)
		isNullable: self isNullable;
		yourself! !

!UI.Scintilla.ColourPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.EnumPropertyDescriptor methodsFor!

aspectDescriptor
	| nullable |
	nullable := self isNullable.
	^(Aspect choice: key from: (nullable ifTrue: [[#(nil) , self values value]] ifFalse: [self values]))
		isNullable: nullable;
		type: Symbol;
		yourself! !

!UI.Scintilla.EnumPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.HundredthsPropertyDescriptor methodsFor!

aspectDescriptor
	^(Aspect float: key)
		isNullable: self isNullable;
		defaultValue: (defaultValue ifNotNil: [defaultValue // 100]);
		yourself! !

!UI.Scintilla.HundredthsPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.IndicatorDefinition class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects add: (Aspect string: #name).
	^aspects! !

!UI.Scintilla.IndicatorDefinition class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.IntPropertyDescriptor methodsFor!

aspectDescriptor
	^(Aspect integer: key)
		isNullable: self isNullable;
		defaultValue: defaultValue;
		yourself! !

!UI.Scintilla.IntPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.KeyBinding class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect symbol: #commandSymbol from: [Commands values asSortedCollection]);
		add: ((Aspect hotkey: #acceleratorKey)
					beNonNullable;
					yourself);
		yourself! !

!UI.Scintilla.KeyBinding class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.MarkerDefinition class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver.
	Most of the aspects can be built from the property descriptor map."

	^super publishedAspectsOfInstances
		add: (Aspect name: #name);
		yourself! !

!UI.Scintilla.MarkerDefinition class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.PropertyDescriptor methodsFor!

aspectDescriptor
	^Aspect name: key! !

!UI.Scintilla.PropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.ScintillaView methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| createPresenter |
	createPresenter := 
			[:p :m |
			(UI.Scintilla.StylesCollectionPresenter
				create: 'Developer view'
				in: p
				on: m)
				defaultStyle: (UI.Scintilla.TextStyle new
							backcolor: self backcolor;
							font: self actualFont;
							yourself);
				normalStyle: (self styleNamed: #normal);
				yourself].
	^super publishedAspects
		add: ((Aspect name: #textStyles presenterBlock: createPresenter)
					type: SequenceableCollection;
					beImmutable;
					yourself);
		add: ((Aspect name: #annotationStyles presenterBlock: createPresenter)
					type: SequenceableCollection;
					beImmutable;
					yourself);
		yourself! !

!UI.Scintilla.ScintillaView categoriesForMethods!
publishedAspects!constants!public! !
!

!UI.Scintilla.ScintillaView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer
		removeAllKeys: #(#format #alignment #cueBanner);
		add: (Aspect sequenceableCollection: #keyBindings
					addEvaluationFrom: [{UI.Scintilla.KeyBinding shortName , ' new'}]) beImmutable;
		add: (Aspect sequenceableCollection: #characterRepresentations
					addEvaluationFrom: 
						[{UI.Scintilla.CharacterRepresentation shortName , ' new'.
							UI.Scintilla.CharacterRepresentation shortName , ' ' , #forLineEnding}])
						beImmutable;
		add: ((Aspect sequenceableCollection: #margins)
					getBlock: [:view | view margins asOrderedCollection];
					beImmutable);
		add: (Aspect sequenceableCollection: #indicatorDefinitions
					addEvaluationFrom: [{UI.Scintilla.IndicatorDefinition shortName , ' new'}]) beImmutable;
		add: (Aspect sequenceableCollection: #markerDefinitions
					addEvaluationFrom: [{UI.Scintilla.MarkerDefinition shortName , ' new'}]) beImmutable;
		add: (Aspect symbol: #whitespaceVisibility from: self whitespaceVisibilityLevels);
		add: (Aspect dictionary: #braceChars) beImmutable;
		add: (Aspect
					choice: #lexer
					from: [(UI.Scintilla.ScintillaView lexerLanguages copyWithout: nil) sort]
					type: String);
		add: ((Aspect
					choice: #foldMarkerStyle
					from: [UI.Scintilla.ScintillaView foldMarkerStyles asSortedCollection]
					andNil: '<None>')
					type: Symbol;
					yourself);
		add: (Aspect symbol: #caretStyle from: self caretStyles asSortedCollection);
		add: ((Aspect
					choice: #indentationGuides
					from: [UI.Scintilla.ScintillaView indentationGuideStyles asSortedCollection]
					andNil: '<None>')
					type: Symbol;
					yourself);
		add: (Aspect symbol: #annotationMode from: self annotationModes);
		add: (Aspect symbol: #wrapIndentMode from: self wrapIndentModes);
		add: (Aspect symbol: #fontQuality from: self fontQualities);
		add: (Aspect symbol: #multiPasteMode from: self multiPasteModes);
		add: (Aspect symbol: #tabDrawMode from: self tabDrawModes);
		add: (Aspect symbol: #endOfLineMode from: self lineEndings);
		add: (Aspect duration: #mouseDwellTime);
		add: (Aspect symbol: #drawingTechnology from: self drawingTechnologies);
		add: (Aspect name: #characterClassifications) beImmutable;
		yourself.
	answer add: ((Aspect choice: #styler
				evaluationFrom: 
					[(UI.Scintilla.Styler allSubclasses reject: [:each | each isAbstract])
						collect: [:each | each shortName , ' new']])
				type: UI.Scintilla.Styler;
				yourself).
	#(#autoCompletionAcceptChars #autoCompletionCancelChars)
		do: [:each | answer add: (Aspect string: each)].
	#(#tabWidth #currentLineFrameWidth #whitespaceMarkerSize)
		do: [:each | answer add: (Aspect integer: each)].
	#(#caretForecolor #callTipHighlightColor #whitespaceBackcolor #whitespaceForecolor #foldLineColor #foldMarginColor #foldMarginHiColor #hiddenLineColor #currentLineBackcolor #selectionBackcolor #inactiveSelectionBackcolor)
		do: [:each | answer add: (Aspect color: each)].
	#(#canScrollPastEnd #isAutoCompletionCancelledAtStart #isAutoCompletionCaseInsensitive #isAutoCompletionCancelledWhenNoMatch #isAutoCompletionSingleMatchChosen #isAutoCompletionTruncating #isBraceHighlightingEnabled #isFoldingEnabled #hasVisibleLineEndings #isAccessibilityEnabled)
		do: [:each | answer add: (Aspect boolean: each)].
	answer add: (Aspect symbol: #selectionLayer from: self layerNames).
	^answer!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		remove: #textOverflow;
		add: #charAdded:;
		add: #callTipClicked:;
		add: #hoverStart:;
		add: #hoverEnd:;
		add: #hotSpotClicked:;
		add: #hotSpotDoubleClicked:;
		add: #savePointLeft;
		add: #marginClicked:;
		add: #userList:selection:;
		add: #painted;
		add: #macroRecord:;
		add: #updateUI:;
		add: #zoomed;
		yourself! !

!UI.Scintilla.ScintillaView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.Scintilla.StringPropertyDescriptor methodsFor!

aspectDescriptor
	^(Aspect string: key)
		isNullable: self isNullable;
		yourself! !

!UI.Scintilla.StringPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.Scintilla.StylesCollectionPresenter class methodsFor!

resource_Developer_view
	"Answer the literal data from which the 'Developer view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Developer_view)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.ContainerView} 38 #{Core.Array} 15 nil nil 50 2 8 1409286144 131073 32 nil nil nil 5 nil nil nil 32 1798 #{UI.BorderLayout} 17 11 nil nil nil 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 144 nil nil nil 5 nil nil nil 144 114 1 1 18 #{UI.ReferenceView} 50 14 nil 144 50 2 8 1140850688 131073 224 nil nil nil 5 nil nil nil 224 582 1 #{UI.ResourceIdentifier} #{UI.Toolbar} #resource_List_tools nil 262 #{Core.MessageSequence} 50 2 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 1 1 418 321 51 224 370 #text: 50 1 8 'toolbar' 224 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 160 0 0 0 25 0 0 0] 8 #() 418 193 193 nil 27 nil nil nil 18 #{UI.ListView} 50 45 nil 144 50 2 8 1140936781 1 592 838 2 #{UI.ListModel} 550 #{Core.OrderedCollection} 0 nil 6 #{Kernel.IdentitySearchPolicy} 6 #{Graphics.Color} #default nil 5 2886 4 #{UI.Menu} nil true 50 4 1094 2 #{UI.CommandMenuItem} 1 1350 4 #{UI.CommandDescription} #moveFirst 8 'Move to &First' 1 1 nil nil nil 834 1 866 #moveUp 8 'Move to &Previous' 1 1 nil nil nil 834 1 866 #moveDown 8 'Move to &Next' 1 1 nil nil nil 834 1 866 #moveLast 8 'Move to &Last' 1 1 nil nil nil 8 '' nil 1 nil nil nil nil nil nil nil 592 nil nil 518 #{Core.Message} #displayString 8 #() nil 1350 1 #{Graphics.IconImageManager} nil nil nil nil nil nil 690 1 3142 5 #{UI.ListViewColumn} 8 '' 313 #left 1074 #displayString 1104 1074 #<= 8 #() nil nil 592 nil 3 nil 1382 3 #{Kernel.BlockClosure} 0 nil 1318 #{Kernel.CompiledExpression} 3 1 1264 8 'doIt' 8 '[:each | UI.Scintilla.StylesCollectionPresenter customDraw: each] ' 8 #[31 105 45 17 177 106] 1094 2 #{Kernel.VariableBinding} #StylesCollectionPresenter #{UI.Scintilla.StylesCollectionPresenter} #{UI.Scintilla} 1 #customDraw: 1280 7 257 nil #report 8 #() nil 133217 nil 1 nil nil nil nil 1 nil nil nil nil nil nil nil nil nil nil 322 50 1 370 #createAt:extent: 50 2 418 1 51 418 321 783 592 514 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 25 0 0 0 160 0 0 0 160 1 0 0] 8 #() 576 nil 35 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 50 2 592 8 'list' nil 322 50 1 370 #createAt:extent: 50 2 418 1 1 418 321 833 144 514 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 160 0 0 0 160 1 0 0] 50 2 224 592 576 nil 27 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140850688 131073 1776 nil nil nil 5 nil nil nil 1776 290 #{UI.Scintilla.TextStylePresenter} #resource_Developer_view nil 322 50 1 370 #createAt:extent: 50 2 418 337 1 418 501 833 1776 514 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 168 0 0 0 0 0 0 0 162 1 0 0 160 1 0 0] 560 576 nil 27 1570 #{Core.IdentityDictionary} 50 4 1776 8 'detail' 144 8 'styles' 518 #{Graphics.Rectangle} 418 1 1 418 1 1 322 50 2 370 #createAt:extent: 50 2 418 6143 21 418 837 833 32 370 #text: 50 1 8 'Text Styles' 32 514 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 161 13 0 0 170 1 0 0] 50 2 144 1776 576 nil 27)! !

!UI.Scintilla.StylesCollectionPresenter class categoriesForMethods!
resource_Developer_view!public!resources-views! !
!

!UI.Scintilla.TextStyle class methodsFor!

newInstanceAspect: aSymbol class: aspectClass
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass name: aSymbol
		presenterBlock: 
			[:p :m |
			UI.Scintilla.TextStylePresenter
				create: 'Developer view'
				in: p
				on: m])
			yourself!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #name);
		yourself! !

!UI.Scintilla.TextStyle class categoriesForMethods!
newInstanceAspect:class:!adapters!private! !
publishedAspectsOfInstances!constants!public! !
!

!UI.Scintilla.TextStylePresenter class methodsFor!

resource_Developer_view
	"Answer the literal data from which the 'Developer view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Developer_view)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.ContainerView} 38 #{Core.Array} 15 nil nil 50 2 8 1409286144 131073 32 nil nil nil 517 nil 1030 #{Graphics.Font} nil true 262 #{OS.LOGFONTW} 8 #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 518 #{Graphics.Point} 193 193 nil 32 838 1 #{UI.FlowLayout} 11 21 17 550 #{Core.IdentityDictionary} 0 518 #{Graphics.Rectangle} 194 1 21 194 1 21 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 194 6143 21 194 485 791 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 241 12 0 0 149 1 0 0] 50 4 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 544 nil nil nil 5 nil nil nil 544 226 11 1 9 518 #{Kernel.STBIdentityDictionaryProxy} 256 50 4 18 #{UI.TextEdit} 50 20 nil 544 50 2 8 1140916352 1025 672 nil 6 #{Graphics.Color} #default nil 5 nil nil nil 672 nil nil 518 #{UI.NullConverter} nil nil 35 #focusLost nil nil nil 354 50 1 402 #createAt:extent: 50 2 194 391 1 194 69 39 672 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 195 0 0 0 0 0 0 0 229 0 0 0 19 0 0 0] 8 #() 194 193 193 nil 45 8 'id' 18 #{UI.TextEdit} 50 20 nil 544 50 2 8 1140916352 1025 976 nil 752 nil 5 nil nil nil 976 nil nil 770 nil nil 1 #focusLost nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 93 1 194 255 39 976 402 #text: 50 1 8 'Name of style' 976 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 46 0 0 0 0 0 0 0 173 0 0 0 19 0 0 0] 8 #() 944 nil 45 8 'name' 290 194 21 1 194 1 1 354 50 1 402 #createAt:extent: 50 2 194 1 21 194 481 39 544 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 10 0 0 0 240 0 0 0 29 0 0 0] 50 4 18 #{UI.StaticText} 50 16 nil 544 50 2 8 1140850956 1 1456 nil nil nil 5 nil nil nil 1456 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 21 7 194 63 27 1456 402 #text: 50 1 8 '&Name:' 1456 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 3 0 0 0 41 0 0 0 16 0 0 0] 8 #() 944 nil 27 976 18 #{UI.StaticText} 50 16 nil 544 50 2 8 1140850955 1 1728 nil nil nil 5 nil nil nil 1728 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 357 7 194 25 27 1728 402 #text: 50 1 8 'Id:' 1728 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 178 0 0 0 3 0 0 0 190 0 0 0 16 0 0 0] 8 #() 944 nil 27 672 944 nil 27 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 2000 nil nil nil 5 nil nil nil 2000 262 #{UI.FramingLayout} 626 #{Core.LookupTable} 50 24 18 #{UI.GroupBox} 50 14 nil 2000 50 2 8 1140850695 65 2128 nil nil nil 5 nil nil nil 2128 nil nil 354 50 2 402 #createAt:extent: 50 2 194 1 1 194 485 317 2128 402 #text: 50 1 8 'Text' 2128 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 242 0 0 0 158 0 0 0] 8 #() 944 nil 27 2118 2 #{UI.FramingConstraints} 1030 #{UI.FramingCalculation} #fixedParentLeft -19 2418 #fixedParentRight 21 2418 #fixedParentTop 1 2418 #fixedParentBottom 1 18 #{UI.StaticText} 50 16 nil 2000 50 2 8 1140850956 1 2496 nil nil nil 5 nil nil nil 2496 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 21 37 194 61 31 2496 402 #text: 50 1 8 '&Font:' 2496 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 18 0 0 0 40 0 0 0 33 0 0 0] 8 #() 944 nil 27 2386 2432 1 2418 #fixedViewLeft 61 2464 37 2418 #fixedViewTop 31 18 #{UI.StaticText} 50 16 nil 2000 50 2 8 1140916492 1 2816 1094 2 #{UI.ValueHolder} nil false 6 #{Kernel.EqualitySearchPolicy} nil nil nil 5 nil nil nil 2816 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 327 37 194 61 31 2816 402 #text: 50 1 8 '&Size:' 2816 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 163 0 0 0 18 0 0 0 193 0 0 0 33 0 0 0] 8 #() 944 nil 27 2386 2418 #fixedPreviousRight 27 2784 61 2418 #fixedPreviousTop -29 2800 31 18 #{UI.ComboBox} 50 17 nil 2000 50 2 8 1152583170 1 3200 838 2 #{UI.ListModel} 550 #{Core.OrderedCollection} 0 nil 6 #{Kernel.IdentitySearchPolicy} 752 nil 5 nil nil nil 3200 nil nil 518 #{Core.Message} #displayString 8 #() 8 #() 401 354 50 1 402 #createAt:extent: 50 2 194 21 67 194 281 43 3200 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 33 0 0 0 150 0 0 0 54 0 0 0] 8 #() 944 nil 27 2386 2418 #fixedPreviousLeft 1 2784 281 2418 #fixedPreviousBottom 1 2800 43 18 #{UI.TextEdit} 50 20 nil 2000 50 2 8 1140924544 1025 3616 nil 738 #window nil 5 nil nil nil 3616 nil nil 1094 1 #{UI.IntegerToText} nil 8 '' 326 1 #{Core.Locale} #userDefault nil 1 #focusLost nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 327 67 194 1 43 3616 402 #text: 50 1 8 '0' 3616 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 163 0 0 0 33 0 0 0 163 0 0 0 54 0 0 0] 8 #() 944 nil 45 2386 3584 1 2784 61 3600 1 2800 43 18 #{UI.SpinButton} 50 15 nil 2000 50 2 8 1140916276 1 3984 2882 nil nil 518 #{Kernel.PluggableSearchPolicy} 3362 #= 8 #() 3362 #hash 8 #() 1 752 nil 5 nil nil nil 3984 nil nil 770 nil nil 354 50 3 402 #createAt:extent: 50 2 194 387 67 194 31 43 3984 402 #setRange: 50 1 774 #{Core.Interval} 3 201 3 3984 402 #udmSetAccel: 50 1 1350 1 #{External.StructureArray} 8 #[0 0 0 0 1 0 0 0 2 0 0 0 5 0 0 0 5 0 0 0 20 0 0 0] 7 #{OS.UDACCEL} nil 17 3984 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 193 0 0 0 33 0 0 0 208 0 0 0 54 0 0 0] 8 #() 944 nil 27 2386 3168 1 2784 31 3184 1 3600 1 18 #{UI.StaticText} 50 16 nil 2000 50 2 8 1140916492 1 4480 2882 nil false 2928 nil nil nil 5 nil nil nil 4480 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 21 121 194 61 31 4480 402 #text: 50 1 8 '&Color:' 4480 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 60 0 0 0 40 0 0 0 75 0 0 0] 8 #() 944 nil 27 2386 2432 1 2784 61 3600 13 2800 31 18 #{UI.StaticText} 50 16 nil 2000 50 2 8 1140916492 1 4784 2882 nil false 2928 nil nil nil 5 nil nil nil 4784 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 191 121 194 61 31 4784 402 #text: 50 1 8 'C&ase:' 4784 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 95 0 0 0 60 0 0 0 125 0 0 0 75 0 0 0] 8 #() 944 nil 27 2386 3168 29 2784 61 3184 -31 2800 31 18 #{UI.ComboBox} 50 17 nil 2000 50 2 8 1144063491 1025 5088 3266 3298 0 nil 3344 752 nil 5 nil nil nil 5088 nil nil 3362 #displayString 8 #() 3408 401 354 50 1 402 #createAt:extent: 50 2 194 191 151 194 171 43 5088 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 95 0 0 0 75 0 0 0 180 0 0 0 96 0 0 0] 8 #() 944 nil 27 2386 3584 1 2784 171 3600 1 2800 43 18 #{UI.ColorView} 50 16 nil 2000 50 2 8 1140850944 262145 5376 2882 nil false 6 #{Kernel.NeverSearchPolicy} nil nil nil 5 nil nil nil 5376 nil nil 770 nil nil nil 354 50 1 402 #createAt:extent: 50 2 194 23 153 194 91 43 5376 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 0 76 0 0 0 56 0 0 0 97 0 0 0] 8 #() 944 nil 27 2386 3584 3 2784 91 3600 3 2800 43 18 #{UI.PushButton} 50 20 nil 2000 50 2 8 1140924416 1 5664 nil 752 nil 5 nil nil nil 5664 nil nil 1350 4 #{UI.CommandDescription} #chooseForecolor 8 '…' 1 1 nil nil false nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 123 153 194 41 43 5664 402 #text: 50 1 8 '…' 5664 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 61 0 0 0 76 0 0 0 81 0 0 0 97 0 0 0] 8 #() 944 nil 29 2386 3168 11 2784 41 3184 1 3600 1 18 #{UI.ContainerView} 50 15 nil 2000 50 2 8 1140850688 131073 5984 nil nil nil 5 nil nil nil 5984 1030 #{UI.GridLayout} 1 7 5 7 626 256 50 12 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140927750 1 6112 2882 nil nil 5472 false nil nil 5 nil 114 nil true 146 8 #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 188 2 0 0 0 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 194 193 193 nil 6112 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 3 1 194 149 43 6112 402 #text: 50 1 8 '&Bold' 6112 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 1 0 0 0 0 0 0 0 75 0 0 0 21 0 0 0] 8 #() 944 nil 27 8 'isBold' 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140924422 1 6480 2882 nil nil 5472 false nil nil 5 nil nil nil 6480 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 155 49 194 147 41 6480 402 #text: 50 1 8 '&Hotspot' 6480 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 77 0 0 0 24 0 0 0 150 0 0 0 44 0 0 0] 8 #() 944 nil 27 8 'isHotspot' 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140924422 1 6784 2882 nil nil 5472 false nil nil 5 nil nil nil 6784 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 305 49 194 149 41 6784 402 #text: 50 1 8 'In&visible' 6784 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 152 0 0 0 24 0 0 0 226 0 0 0 44 0 0 0] 8 #() 944 nil 27 8 'isInvisible' 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140924422 1 7088 2882 nil nil 5472 false nil nil 5 nil 114 nil true 146 8 #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 255 0 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 6240 nil 7088 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 155 1 194 147 43 7088 402 #text: 50 1 8 '&Italic' 7088 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 77 0 0 0 0 0 0 0 150 0 0 0 21 0 0 0] 8 #() 944 nil 27 8 'isItalic' 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140924422 1 7440 2882 nil nil 5472 false nil nil 5 nil nil nil 7440 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 3 49 194 149 41 7440 402 #text: 50 1 8 '&Read Only' 7440 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 1 0 0 0 24 0 0 0 75 0 0 0 44 0 0 0] 8 #() 944 nil 27 8 'isReadOnly' 18 #{UI.CheckBox} 50 16 nil 5984 50 2 8 1140924422 1 7744 2882 nil nil 5472 false nil nil 5 nil 114 nil true 146 8 #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 1 0 0 3 2 1 34 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 6240 nil 7744 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 305 1 194 149 43 7744 402 #text: 50 1 8 '&Underlined' 7744 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 152 0 0 0 0 0 0 0 226 0 0 0 21 0 0 0] 8 #() 944 nil 27 8 'isUnderlined' 290 194 3 1 194 5 1 354 50 1 402 #createAt:extent: 50 2 194 21 207 194 457 89 5984 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 103 0 0 0 238 0 0 0 147 0 0 0] 50 6 6112 7088 7744 7440 6480 6784 944 nil 27 2386 2432 1 2448 13 3600 15 2480 -21 626 256 50 10 5088 8 'case' 3200 8 'faceName' 5376 8 'forecolor' 3616 8 'pointSize' 3984 8 'pointSizeSpinner' 290 194 21 1 194 21 1 354 50 1 402 #createAt:extent: 50 2 194 1 79 194 485 317 2000 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 39 0 0 0 242 0 0 0 197 0 0 0] 50 12 2128 2496 3200 2816 3616 3984 4480 5376 5664 4784 5088 5984 944 nil 27 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 8608 nil nil nil 5 nil nil nil 8608 2066 626 #{Core.LookupTable} 50 10 18 #{UI.GroupBox} 50 14 nil 8608 50 2 8 1140850695 65 8720 nil nil nil 5 nil nil nil 8720 nil nil 354 50 2 402 #createAt:extent: 50 2 194 1 1 194 485 145 8720 402 #text: 50 1 8 'Background' 8720 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 242 0 0 0 72 0 0 0] 8 #() 944 nil 27 2386 2432 -19 2448 21 2464 1 2480 11 18 #{UI.StaticText} 50 16 nil 8608 50 2 8 1140850956 1 8992 nil nil nil 5 nil nil nil 8992 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 21 41 194 61 31 8992 402 #text: 50 1 8 'C&olor:
' 8992 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 20 0 0 0 40 0 0 0 35 0 0 0] 8 #() 944 nil 27 2386 2432 1 2784 61 2464 41 2800 31 18 #{UI.ColorView} 50 16 nil 8608 50 2 8 1140850944 262145 9280 2882 nil false 5472 nil nil nil 5 nil nil nil 9280 nil nil 770 nil nil nil 354 50 1 402 #createAt:extent: 50 2 194 23 73 194 91 43 9280 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 0 36 0 0 0 56 0 0 0 57 0 0 0] 8 #() 944 nil 27 2386 3584 3 2784 91 3600 3 2800 43 18 #{UI.PushButton} 50 20 nil 8608 50 2 8 1141055488 1 9536 nil 752 nil 5 nil nil nil 9536 nil nil 5730 #chooseBackcolor 8 '…' 1 1 nil nil false nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 123 73 194 41 43 9536 402 #text: 50 1 8 '…' 9536 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 61 0 0 0 36 0 0 0 81 0 0 0 57 0 0 0] 8 #() 944 nil 29 2386 3168 11 2784 41 3184 1 3600 1 18 #{UI.CheckBox} 50 16 nil 8608 50 2 8 1140924422 1 9840 2882 nil nil 5472 false nil nil 5 nil nil nil 9840 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 201 77 194 221 31 9840 402 #text: 50 1 8 'Fill to &end of line' 9840 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 100 0 0 0 38 0 0 0 210 0 0 0 53 0 0 0] 8 #() 944 nil 27 2386 3168 39 2784 221 3184 5 2800 31 626 256 50 4 9280 8 'backcolor' 9840 8 'isBackcolorExtendedToEndOfLine' 290 194 21 1 194 21 11 354 50 1 402 #createAt:extent: 50 2 194 1 415 194 485 145 8608 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 207 0 0 0 242 0 0 0 23 1 0 0] 50 5 8720 8992 9280 9536 9840 944 nil 27 18 #{UI.ContainerView} 50 15 nil 32 50 2 8 1140850688 131073 10400 nil nil nil 5 nil nil nil 10400 1798 #{UI.BorderLayout} 1 11 18 #{UI.StaticText} 50 16 nil 10400 50 2 8 1140850956 1 10496 2882 nil false 2928 nil nil nil 517 nil nil nil 10496 nil nil 770 nil nil nil 354 50 2 402 #createAt:extent: 50 2 194 21 1 194 449 27 10496 402 #text: 50 1 8 '&Description:' 10496 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 0 0 0 0 234 0 0 0 13 0 0 0] 8 #() 944 nil 27 nil nil nil 18 #{UI.Scintilla.ScintillaView} 50 56 nil 10400 50 2 8 1174409476 1025 10784 2882 nil false 2928 nil 752 nil 5 nil nil nil 10784 nil nil 770 nil 8 '' 9 #focusLost nil nil nil nil 258 3 #callTip 3142 1 #{UI.Scintilla.TextStyle} 77 738 #gray 738 #white 1 nil nil nil nil #callTip nil nil nil #indentGuide 10914 75 nil nil 1 nil nil nil nil #indentGuide nil nil nil #normal 10914 1 nil nil 1 nil nil nil nil #normal nil nil nil nil 326 1 #{UI.Scintilla.NullStyler} #preview 258 0 294 #{Core.IdentitySet} 0 nil 550 #{Core.LookupTable} 0 9215 nil nil 11090 1 81 738 #windowText nil nil 262 #{UI.Scintilla.NullScintillaLibrary} nil 65 nil nil nil nil 3 258 1 #container 10896 nil nil nil nil #{Core.Utf8String} nil 258 0 nil nil 258 0 nil nil nil 354 50 8 402 #createAt:extent: 50 2 194 21 37 194 449 163 10784 402 #text: 50 1 8 '-- Abcdefghijklm … 
	…  nopqrstuvwxyz --' 10784 402 #setMarginWidths: 50 1 8 #(5 5) 10784 402 #wordWrap: 8 #(true) 10784 402 #margins: 50 1 50 3 2118 3 #{UI.Scintilla.Margin} 1 10784 nil 3 nil nil nil nil 11506 3 10784 nil nil nil 67108863 nil nil 11506 5 10784 nil nil nil nil nil nil 10784 402 #sciSetIndentationGuides: 8 #(1) 10784 402 #targetRange: 50 1 4306 3 91 3 10784 402 #maxCompletionListHeight: 8 #(9) 10784 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 10 0 0 0 18 0 0 0 234 0 0 0 99 0 0 0] 8 #() 944 nil 45 626 256 50 2 10784 8 'preview' 290 194 21 1 194 17 1 354 50 1 402 #createAt:extent: 50 2 194 1 579 194 485 199 10400 482 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 33 1 0 0 242 0 0 0 132 1 0 0] 50 2 10496 10784 944 nil 27 944 nil 27)! !

!UI.Scintilla.TextStylePresenter class categoriesForMethods!
resource_Developer_view!public!resources-views! !
!

!UI.Scintilla.ThreeStateBooleanPropertyDescriptor methodsFor!

aspectDescriptor
	^Aspect nullableBoolean: key! !

!UI.Scintilla.ThreeStateBooleanPropertyDescriptor categoriesForMethods!
aspectDescriptor!development!public! !
!

!UI.ScrollBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #pageSize);
		add: (Aspect name: #range);
		add: (Aspect boolean: #isTrackingContinuous);
		add: (Aspect boolean: #isVertical);
		yourself! !

!UI.ScrollBar class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ScrollingDecorator class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #isTrackingContinuous);
		add: (Aspect name: #lineExtent);
		removeKey: #layoutManager;
		yourself! !

!UI.ScrollingDecorator class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ScrollingDecoratorLayout class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #shouldStretchToFit);
		yourself! !

!UI.ScrollingDecoratorLayout class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.SelectableItemsPresenter methodsFor!

browseIt
	"Browse the selected item in the pane with focus."

	<commandQuery: #queryBrowseIt:>
	self perform: self browseItCommand!

browseItCommand
	"Private - Answer the command that the context-sensitive 'Browse-It' command would be linked
	to if sent to the receiver at this moment."

	^nil!

queryBrowseIt: aCommandQuery
	self browseItCommand ifNotNil: [:selector | self queryContextCommand: aCommandQuery as: selector]! !

!UI.SelectableItemsPresenter categoriesForMethods!
browseIt!commands-actions!public! !
browseItCommand!helpers!private! !
queryBrowseIt:!commands-queries!private! !
!

!UI.Shell class methodsFor!

registerAsToolWith: aSmalltalkSystem
    	"The receiver is being registered as a tool with aSmalltalkSystem. Perform any
    	additional registration operations here. Part of the <installableSystemTool>
    	protocol, and implemented at this level so that 3.0 tools can be installed
    	without amendment."
    
    	!

unregisterAsToolWith: aSmalltalkSystem
    	"The receiver is being unregistered as a tool with aSmalltalkSystem. Perform any
    	additional unregistration operations here. Part of the <installableSystemTool>
    	protocol, and implemented at this level so that 3.0 tools can be installed
    	without amendment."
    
    	! !

!UI.Shell class categoriesForMethods!
registerAsToolWith:!operations!public! !
unregisterAsToolWith:!operations!public! !
!

!UI.ShellView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	"This block is used for editing (with a double click inside the PAI) the maximum and
    	minimum extents. The values will toggle between nil and the current extent of the 
    	selected ShellView."

	| maxMinExtentEditBlock |
	maxMinExtentEditBlock := 
			[:p |
			p model value: (p model value isNil ifTrue: [p parentPresenter model value extent])].
	^super publishedAspectsOfInstances
		add: (Aspect autostring: #caption);
		add: (Aspect boolean: #isResizable);
		add: (Aspect boolean: #hasSysMenu);
		add: (Aspect boolean: #hasCaption);
		add: (Aspect boolean: #isInitiallyCentered);
		add: (Aspect boolean: #hasMinimize);
		add: (Aspect boolean: #hasMaximize);
		add: (Aspect boolean: #isToolWindow);
		add: (Aspect boolean: #hasTaskbarIcon);
		add: (Aspect menuBar: #menuBar) beImmutable;
		add: (Aspect icon: #largeIcon);
		add: (Aspect icon: #smallIcon);
		add: ((Aspect extent: #maxExtent)
					editBlock: maxMinExtentEditBlock;
					yourself);
		add: ((Aspect name: #minExtent)
					editBlock: maxMinExtentEditBlock;
					yourself);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #viewMinimized;
    		add: #viewActivated;
    		add: #captionChanged;
    		add: #aboutToDisplaySystemMenu:;
    		add: #positionChanged:;
    		add: #viewRestored;
    		add: #positionChanging:;
    		add: #viewDeactivated;
    		add: #closeRequested:;
    		yourself.
    ! !

!UI.ShellView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.Slider methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^super publishedAspects
		add: (Aspect symbol: #tickStyle from: [self applicableTickStyles keys asSortedCollection]);
		yourself! !

!UI.Slider categoriesForMethods!
publishedAspects!constants!public! !
!

!UI.Slider class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects
		removeKey: #forecolor;
		add: (Aspect name: #range) beImmutable;
		add: (Aspect integer: #thumbLength).
	#(#pageSize #lineSize #selectionRange) do: [:each | aspects add: (Aspect name: each)].
	#(#hasAutoTicks #isVertical #hasTicks #hasToolTips)
		do: [:each | aspects add: (Aspect boolean: each)].
	^aspects! !

!UI.Slider class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.SpinButton methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspects.
	self isAutoSync
		ifTrue: 
			[aspects
				add: (Aspect boolean: #hasThousandsSeparators);
				add: (Aspect choice: #radix from: #(10 16) type: Integer)].
	^aspects! !

!UI.SpinButton categoriesForMethods!
publishedAspects!accessing!must strip!public! !
!

!UI.SpinButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect symbol: #alignment from: ##(AlignmentMap keys asSortedArray));
		add: (Aspect boolean: #wantArrowKeys);
		add: (Aspect boolean: #isAutoSync);
		add: (Aspect boolean: #isVertical);
		add: (Aspect boolean: #hasHotTracking);
		add: (Aspect boolean: #isWraparound);
		add: (Aspect name: #range);
		add: (Aspect name: #buddy) beReadOnly;
		yourself!

publishedEventsOfInstances
    	"Answer a <Set> of <Symbol>s that names all the events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #nudge:;
    		yourself.
    ! !

!UI.SpinButton class categoriesForMethods!
publishedAspectsOfInstances!accessing!must strip!public! !
publishedEventsOfInstances!events!public! !
!

!UI.Splitter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects removeAllKeys: #(#isTabStop #isGroupStop #isDragSource #isDropTarget #font #text).
	aspects add: (Aspect boolean: #hasFlatAppearance).
	^aspects! !

!UI.Splitter class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StaticBitmap class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect bitmap: #image);
		yourself! !

!UI.StaticBitmap class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StaticControlView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #isSunken);
		yourself! !

!UI.StaticControlView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StaticIcon class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect icon: #image);
		yourself! !

!UI.StaticIcon class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StaticRectangle class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect symbol: #style from: ##(StyleMap keys asSortedArray));
		yourself! !

!UI.StaticRectangle class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StaticText class methodsFor!

applicableTypeConverterCategories
	"Answers a class category containing <typeConverter>s that can 
    	be used with the receiver"

	^super applicableTypeConverterCategories
		add: (ClassCategory name: 'MVP-Type Converters-Text');
		yourself!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect multilineString: #text);
		add: (Aspect symbol: #alignment from: ##(AlignmentMap keys asSortedArray));
		removeKey: #value;
		yourself! !

!UI.StaticText class categoriesForMethods!
applicableTypeConverterCategories!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.StatusBar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect boolean: #hasSizeGrip);
		add: (Aspect boolean: #hasToolTips);
		add: (Aspect sequenceableCollection: #items addEvaluationFrom: [{StatusBarItem shortName , ' new'}])
					beImmutable;
		yourself! !

!UI.StatusBar class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StatusBarItem class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect block: #getImageBlock);
		add: (Aspect block: #getTextBlock);
		add: (Aspect block: #getTipTextBlock);
		yourself! !

!UI.StatusBarItem class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.StatusBarItemAbstract class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect symbol: #borderStyle from: ##(BorderStyles keys asSortedArray));
		add: (Aspect integer: #width);
		add: (Aspect string: #name);
		add: (Aspect boolean: #isAutoResize);
		yourself! !

!UI.StatusBarItemAbstract class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.TabView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| answer |
	answer := super publishedAspectsOfInstances.
	answer add: (Aspect symbol: #tabOrientation from: ##(TabOrientations values asSortedArray)).
	#(#hasFlatSeparators #hasButtons #isMultiline) do: [:each | answer add: (Aspect boolean: each)].
	^answer! !

!UI.TabView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.TextEdit class methodsFor!

applicableTypeConverterCategories
	"Answers a class category containing <typeConverter>s that can 
    	be used with the receiver"

	^super applicableTypeConverterCategories
		add: (ClassCategory name: 'MVP-Type Converters-Text');
		yourself!

publishedAspectsOfInstances
	"Answer a Set of the aspects published by  instances of the receiver"

	| aspects |
	aspects := super publishedAspectsOfInstances.
	aspects removeKey: #value.
	#(#canHScroll #isReadOnly #isStatic #isSelectionKept #isFindEnabled)
		do: [:each | aspects add: (Aspect boolean: each)].
	^aspects
		add: (Aspect symbol: #updateMode from: #(#focusLost #perChar #explicit));
		add: (Aspect symbol: #alignment from: ##(AlignmentMap keys asSortedArray));
		add: (Aspect symbol: #format from: ##(FormatMap keys asSortedArray));
		add: (Aspect string: #cueBanner);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #textOverflow;
    		yourself.
    ! !

!UI.TextEdit class categoriesForMethods!
applicableTypeConverterCategories!constants!public! !
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.TimeToText class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect string: #format);
		yourself! !

!UI.TimeToText class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Toolbar class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect rectangle: #insets);
		add: (Aspect
					choice: #imageSize
					from: ImageSizes keys asSortedCollection
					andNil: nil);
		add: (Aspect boolean: #hasFlatAppearance);
		add: (Aspect boolean: #hasListAppearance);
		add: (Aspect boolean: #hasLabels);
		add: (Aspect integer: #indent);
		add: (Aspect boolean: #canCustomize);
		add: (Aspect sequenceableCollection: #items
					addEvaluationFrom: 
						[##({ToolbarIconButton. ToolbarBitmapButton. ToolbarSystemButton. ToolbarSeparator}
							collect: [:each | each shortName , ' new'])])
						beImmutable;
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #dropDown:;
    		yourself.
    !

resource_Class_browser_tools
	"Answer the literal data from which the 'Class browser tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Class_browser_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 7 1094 1 #{UI.ToolbarIconButton} 32 17 1350 4 #{UI.CommandDescription} #historyBack 8 'Back to <d:…>' 1 17 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'HistoryBack.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 210 32 17 242 #historyForward 8 'Forward to <d:…>' 1 17 290 nil true 322 8 'HistoryForward.ico' 384 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 210 32 5 242 #toggleShowFullNames 8 '<?Hide:Show> Full Class Names' 1 17 290 nil true 322 8 'Namespace.ico' 384 65541 nil nil 210 32 1 242 #newMethod 8 'New <s:Method>' 1 17 290 nil true 322 8 'NewMethod.ico' 384 65541 nil nil 210 32 1 242 #newClass 8 'New subclass of <p>' 1 17 290 nil true 322 8 'NewClass.ico' 384 65541 nil nil 210 32 1 242 #toggleShowInheritedMethods 8 '<?Hide:Show> Inherited Methods' 1 17 290 nil true 322 8 'ToggleLocalHierarchy.ico' 384 65541 nil nil nil nil 1 nil nil nil nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 1026 361 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 179 12 0 0 35 0 0 0] 8 #() 1026 193 193 nil 29)!

resource_Debugger_tools
	"Answer the literal data from which the 'Debugger tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Debugger_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 10 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #showNextStatement 8 'Show Next Statement' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'ShowNextStatement.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 210 32 1 242 #stepInto 8 'Step Into' 1 1 290 nil true 322 8 'StepInto.ico' 384 65541 nil nil 210 32 1 242 #stepOver 8 'Step Over' 1 1 290 nil true 322 8 'StepOver.ico' 384 65541 nil nil 210 32 1 242 #stepOut 8 'Step Out' 1 1 290 nil true 322 8 'StepOut.ico' 384 65541 nil nil 210 32 1 242 #stepIntoBlock 8 'Step Into Block' 1 1 290 nil true 322 8 'StepIntoBlock.ico' 384 65541 nil nil 210 32 1 242 #runToCursor 8 'Run to Cursor' 1 1 290 nil true 322 8 'RunToCursor.ico' 384 65541 nil nil 210 32 1 242 #resumeProcess 8 'Go' 1 1 290 nil true 322 8 'Run.ico' 384 65541 nil nil 210 32 1 242 #restartFrame 8 'R&estart' 13545 1 2374 2 #{Graphics.TextTileIcon} 8 $⭮ 8 'Cambria' nil nil nil nil 1 nil nil nil 210 32 1 242 #returnFromMessage 8 'Retur&n …' 1 1 1042 8 $⏎ 8 'Georgia' nil nil nil nil 1 nil nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil nil nil nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 1330 421 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 209 12 0 0 35 0 0 0] 8 #() 1330 193 193 nil 29)!

resource_Image_tools
	"Answer the literal data from which the 'Image tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Image_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 2 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #saveImage 8 'Save Image' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'Snapshot.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil nil nil nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 546 63 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 30 12 0 0 35 0 0 0] 8 #() 546 193 193 nil 29)!

resource_Resource_tools
	"Answer the literal data from which the 'Resource tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Resource_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 3 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #newView 8 'New View Resource' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'NewThing.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 210 32 1 242 #clearSelection 8 'Delete Resource' 1 1 290 nil true 322 8 'EditClear.ico' 384 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil nil nil nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 642 111 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 54 12 0 0 35 0 0 0] 8 #() 642 193 193 nil 29)!

resource_Search_tools
	"Answer the literal data from which the 'Search tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Search_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil 1030 #{Graphics.Font} nil true 262 #{OS.LOGFONTW} 8 #[244 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 0 0 0 0 83 0 101 0 103 0 111 0 101 0 32 0 85 0 73 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 518 #{Graphics.Point} 193 193 nil 32 nil nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 50 2 18 #{UI.ReferenceView} 50 14 nil 32 50 2 8 1140916224 131073 272 nil 6 #{Graphics.Color} #default nil 5 nil nil nil 272 582 1 #{UI.ResourceIdentifier} #{Tools.SmalltalkSearchPresenter} #resource_Default_view nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 194 1 5 194 371 37 272 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 2 0 0 0 185 0 0 0 20 0 0 0] 8 #() 194 193 193 nil 27 8 'search' nil nil nil nil 50 2 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #goSearch 8 'Go Search' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'GoSearch.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 375 nil nil nil nil 402 50 1 450 #createAt:extent: 50 2 194 6143 21 194 437 51 32 530 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 217 12 0 0 35 0 0 0] 50 1 272 592 nil 29)!

resource_Smalltalk_tools
	"Answer the literal data from which the 'Smalltalk tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Smalltalk_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 12 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #newWorkspace 8 'New Workspace' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'NewWorkspace.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 210 32 1 242 #openWorkspace 8 'Open Workspace' 1 1 290 nil true 322 8 'OpenWorkspace.ico' 384 65541 nil nil 210 32 1 242 #browseSystem 8 'Open System Browser on <d:Object>' 1 17 290 nil true 322 8 'SystemBrowserShell.ico' 384 65541 nil nil 210 32 1 242 #browseHierarchy 8 'Open Class Hierarchy Browser on <d:Object>' 1 17 290 nil true 322 8 'ClassBrowserShell.ico' 384 65541 nil nil 210 32 1 242 #browsePackages 8 'Open Package Browser' 1 1 290 nil true 322 8 'PackageBrowserShell.ico' 384 65541 nil nil 210 32 1 242 #browseTests 8 'Open Test Browser' 1 1 290 nil true 322 8 'UnitTestPlugin.ico' 384 65541 nil nil 210 32 1 242 #browseResources 8 'Open View Browser' 1 1 290 nil true 322 8 'ResourceBrowser.ico' 384 65541 nil nil 210 32 1 242 #openViewComposer 8 'Open View Composer' 1 1 290 nil true 322 8 'ViewComposer.ico' 384 65541 nil nil 210 32 1 242 #showTranscript 8 'Show Transcript' 1 1 290 nil true 322 8 'TranscriptShell.ico' 384 65541 nil nil 210 32 1 242 #inspectVisualObject 8 'Visual Object Finder' 1 1 290 nil true 322 8 'VisualObjectFinder.ico' 384 65541 nil nil 210 32 17 242 #newIdeaSpace 8 'New Idea Space' 1 1 290 nil true 322 8 'IdeaSpaceShell.ico' 384 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil nil nil nil 838 1 #{UI.FlowLayout} 1 1 1 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 1538 553 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 19 13 0 0 35 0 0 0] 8 #() 1538 193 193 nil 29)!

resource_View_composer_alignment_tools
	"Answer the literal data from which the 'View composer alignment tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_alignment_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 8 1606 1 #{UI.ToolbarBitmapButton} 32 1 1350 4 #{UI.CommandDescription} #alignToGrid nil 1 1 nil nil 1606 4 #{Graphics.Bitmap} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'VCBar.BMP' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 73733 nil nil 5 518 #{Graphics.Point} 929 33 1 210 32 1 242 #alignLefts nil 1 1 nil nil 288 3 210 32 1 242 #alignCenters nil 1 1 nil nil 288 5 210 32 1 242 #alignRights nil 1 1 nil nil 288 7 210 32 1 242 #alignTops nil 1 1 nil nil 288 9 210 32 1 242 #alignMiddles nil 1 1 nil nil 288 11 210 32 1 242 #alignBottoms nil 1 1 nil nil 288 13 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil 402 33 33 402 45 45 nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 402 6143 21 402 339 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 168 12 0 0 35 0 0 0] 8 #() 402 193 193 nil 29)!

resource_View_composer_match_size_tools
	"Answer the literal data from which the 'View composer match size tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_match_size_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 5 1606 1 #{UI.ToolbarBitmapButton} 32 1 1350 4 #{UI.CommandDescription} #matchWidths nil 1 1 nil nil 1606 4 #{Graphics.Bitmap} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'VCBar.BMP' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 73733 nil nil 5 518 #{Graphics.Point} 929 33 15 210 32 1 242 #sizeToGrid nil 1 1 nil nil 288 17 210 32 1 242 #matchHeights nil 1 1 nil nil 288 19 210 32 1 242 #matchSizes nil 1 1 nil nil 288 21 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil 402 33 33 402 45 45 nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 402 6143 21 402 201 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 99 12 0 0 35 0 0 0] 8 #() 402 193 193 nil 29)!

resource_View_composer_nudge_tools
	"Answer the literal data from which the 'View composer nudge tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_nudge_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 10 1606 1 #{UI.ToolbarBitmapButton} 32 1 1350 4 #{UI.CommandDescription} #nudgeLeft nil 1 1 nil nil 1606 4 #{Graphics.Bitmap} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'VCBar.BMP' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 73733 nil nil 5 518 #{Graphics.Point} 929 33 49 210 32 1 242 #nudgeRight nil 1 1 nil nil 288 47 210 32 1 242 #nudgeUp nil 1 1 nil nil 288 45 210 32 1 242 #nudgeDown nil 1 1 nil nil 288 43 582 1 #{UI.ToolbarSeparator} 32 1 210 32 1 242 #increaseHeight nil 1 1 nil nil 288 51 210 32 1 242 #decreaseHeight nil 1 1 nil nil 288 53 210 32 1 242 #increaseWidth nil 1 1 nil nil 288 55 210 32 1 242 #decreaseWidth nil 1 1 nil nil 288 57 530 32 1 nil nil 1 nil 402 33 33 402 45 45 nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 402 6143 21 402 401 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 199 12 0 0 35 0 0 0] 8 #() 402 193 193 nil 29)!

resource_View_composer_spacing_tools
	"Answer the literal data from which the 'View composer spacing tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_spacing_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 12 1606 1 #{UI.ToolbarBitmapButton} 32 1 1350 4 #{UI.CommandDescription} #distributeHorizontally nil 1 1 nil nil 1606 4 #{Graphics.Bitmap} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'VCBar.BMP' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 73733 nil nil 5 518 #{Graphics.Point} 929 33 23 210 32 1 242 #increaseHorizontalGaps nil 1 1 nil nil 288 25 210 32 1 242 #decreaseHorizontalGaps nil 1 1 nil nil 288 27 210 32 1 242 #removeHorizontalGaps nil 1 1 nil nil 288 29 582 1 #{UI.ToolbarSeparator} 32 1 210 32 1 242 #distributeVertically nil 1 1 nil nil 288 31 210 32 1 242 #increaseVerticalGaps nil 1 1 nil nil 288 33 210 32 1 242 #decreaseVerticalGaps nil 1 1 nil nil 288 35 210 32 1 242 #removeVerticalGaps nil 1 1 nil nil 288 37 210 32 1 242 #centerHorizontally nil 1 1 nil nil 288 39 210 32 1 242 #centerVertically nil 1 1 nil nil 288 41 530 32 1 nil nil 1 nil 402 33 33 402 45 45 nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 402 6143 21 402 493 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 245 12 0 0 35 0 0 0] 8 #() 402 193 193 nil 29)!

resource_View_composer_tools
	"Answer the literal data from which the 'View composer tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_View_composer_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289036 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 5 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #zFront 8 'Bring to Front' 1 1 2374 2 #{Graphics.TextTileIcon} 8 $⏮ 8 'Georgia' nil 114 #menuHilight nil nil 3 nil nil nil 210 32 1 242 #zForward 8 'Bring Forward' 1 1 290 8 $▲ 8 'Segoe UI' nil 352 nil nil 1 nil nil nil 210 32 1 242 #zBackward 8 'Send Backward' 1 1 290 8 $▼ nil nil 352 nil nil 1 nil nil nil 210 32 1 242 #zBack 8 'Send to Back' 1 1 290 8 $⏭ 8 'Georgia' nil 352 nil nil 3 nil nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil 518 #{Graphics.Point} 33 33 674 45 45 nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 674 6143 21 674 1415 51 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 194 14 0 0 35 0 0 0] 8 #() 674 193 193 nil 29)!

resource_Workspace_tools
	"Answer the literal data from which the 'Workspace tools' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Workspace_tools)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.Toolbar} 38 #{Core.Array} 28 nil nil 50 2 8 1409289164 131137 32 nil nil nil 517 nil nil nil 32 6 #{Graphics.Color} #default nil 518 #{Kernel.STBIdentityDictionaryProxy} #{Core.IdentityDictionary} 8 #() nil nil nil nil 50 6 1094 1 #{UI.ToolbarIconButton} 32 1 1350 4 #{UI.CommandDescription} #displayIt 8 'Display It' 1 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'DisplayIt.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil 210 32 1 242 #printIt 8 'Print It' 1 1 290 nil true 322 8 'PrintIt.ico' 384 65541 nil nil 210 32 1 242 #evaluateIt 8 'Evaluate It' 1 1 290 nil true 322 8 'EvaluateIt.ico' 384 65541 nil nil 210 32 1 242 #inspectIt 8 'Inspect It' 1 1 290 nil true 322 8 'InspectIt.ico' 384 65541 nil nil 210 32 1 242 #debugIt 8 'Deb&ug It' 1 1 290 nil true 322 8 'Debugger.ico' 384 65541 nil nil 582 1 #{UI.ToolbarSeparator} 32 1 nil nil 1 nil nil nil nil nil 262 #{Core.MessageSequence} 50 1 774 #{Core.MessageSend} #createAt:extent: 50 2 518 #{Graphics.Point} 6143 21 930 51 231 32 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 24 12 0 0 125 0 0 0] 8 #() 930 193 193 nil 29)! !

!UI.Toolbar class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
resource_Class_browser_tools!public!resources-views! !
resource_Debugger_tools!public!resources-views! !
resource_Image_tools!public!resources-views! !
resource_Resource_tools!public!resources-views! !
resource_Search_tools!public!resources-views! !
resource_Smalltalk_tools!public!resources-views! !
resource_View_composer_alignment_tools!public!resources-views! !
resource_View_composer_match_size_tools!public!resources-views! !
resource_View_composer_nudge_tools!public!resources-views! !
resource_View_composer_spacing_tools!public!resources-views! !
resource_View_composer_tools!public!resources-views! !
resource_Workspace_tools!public!resources-views! !
!

!UI.ToolbarBitmapButton methodsFor!

publishedAspects
	| aspects |
	aspects := super publishedAspects.
	self bitmap
		ifNotNil: 
			[:bmp |
			aspects add: (Aspect
						choice: #bitmapIndex
						from: [0 to: bmp extent x // (self toolbar ifNil: [16] ifNotNil: [:tb | tb actualBitmapSize x])]
						type: Integer)].
	^aspects! !

!UI.ToolbarBitmapButton categoriesForMethods!
publishedAspects!constants!public! !
!

!UI.ToolbarBitmapButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect bitmap: #bitmap) beImmutable;
		yourself! !

!UI.ToolbarBitmapButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ToolbarButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #commandDescription);
		add: (Aspect boolean: #isCheckStyle);
		add: (Aspect boolean: #isGroupStyle);
		add: (Aspect boolean: #isDropdownStyle);
		add: (Aspect boolean: #isDropDownOnly);
		yourself! !

!UI.ToolbarButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ToolbarSeparator class methodsFor!

icon
	"Answers an Icon that can be used to represent this class."

	^##(TextTileIcon text: '|' color: Color.Face3d)!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect integer: #width);
		yourself! !

!UI.ToolbarSeparator class categoriesForMethods!
icon!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.ToolbarSystemButton methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	^super publishedAspects
		add: (Aspect
					choice: #bitmapIndex
					fromMap: [BitmapButtons at: self bitmapId ifAbsent: [StandardButtons]]
					nullValue: nil);
		yourself! !

!UI.ToolbarSystemButton categoriesForMethods!
publishedAspects!public! !
!

!UI.ToolbarSystemButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect
					choice: #bitmapId
					fromMap: Bitmaps
					nullValue: nil);
		yourself! !

!UI.ToolbarSystemButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ToolButton class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect extent: #buttonSize);
		add: (Aspect
					choice: #imageSize
					from: Toolbar.ImageSizes keys asSortedCollection
					andNil: nil);
		add: (Aspect boolean: #hasListAppearance);
		add: (Aspect boolean: #hasLabels);
		add: (Aspect name: #commandDescription) beImmutable;
		add: (Aspect boolean: #isCheckStyle);
		add: (Aspect boolean: #isGroupStyle);
		add: (Aspect boolean: #isDropdownStyle);
		add: (Aspect boolean: #isDropDownOnly);
		yourself
	"removeKey: #forecolor;"! !

!UI.ToolButton class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.Tooltip class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect color: #forecolor);
		add: (Aspect color: #backcolor);
		add: (Aspect font: #font);
		add: (Aspect integer: #maxWidth);
		add: (Aspect boolean: #isBalloon);
		add: (Aspect boolean: #alwaysTip);
		add: (Aspect integer: #showDuration);
		add: (Aspect integer: #showDelay);
		add: (Aspect integer: #reshowDelay);
		add: (Aspect name: #margins) beImmutable;
		yourself! !

!UI.Tooltip class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.TranscriptShell methodsFor!

help
	"Brings up a help page for the receiver"

	SmalltalkSystem current openHelpTopicForTool: self! !

!UI.TranscriptShell categoriesForMethods!
help!commands-actions!public! !
!

!UI.TranscriptShell class methodsFor!

publishedAspects
	"Answer a <LookupTable> of the aspects published by this class."

	^super publishedAspects
		add: (Aspect extent: #defaultExtent);
		add: (Aspect boolean: #flashOnOutput);
		yourself!

resource_Scintilla_view
	"Answer the literal data from which the 'Scintilla view' resource can be reconstituted.
	DO NOT EDIT OR RECATEGORIZE THIS METHOD.

	If you wish to modify this resource evaluate:
	Tools.ViewComposer openOn: (UI.ResourceIdentifier class: self selector: #resource_Scintilla_view)
	"

	^#(#'!!STL' 6 2118 10 #{UI.STBViewProxy} #{UI.ShellView} 38 #{Core.Array} 27 nil nil 8 #(13565952 65536) 32 nil 6 #{Graphics.Color} #default 518 #{Graphics.Point} 1079 655 517 nil nil nil 32 1798 #{UI.BorderLayout} 1 1 nil nil nil nil 18 #{UI.Scintilla.ScintillaView} 50 56 nil 32 50 2 8 1174470916 262145 192 1094 2 #{UI.ValueHolder} nil false 6 #{Kernel.EqualitySearchPolicy} nil nil nil 21 2886 4 #{UI.Menu} nil true 50 8 1094 2 #{UI.CommandMenuItem} 1 1350 4 #{UI.CommandDescription} #copySelection 8 '&Copy' 9351 1 838 4 #{Graphics.Icon} nil true 1030 #{Graphics.ImageFromStringResourceInitializer} 8 'EditCopy.ico' 838 1 #{External.ResourceLibrary} 8 'dolphindr8.dll' 65541 nil nil nil 370 1 402 #selectAll 8 'Select &All' 8323 1 nil nil nil 370 1 402 #clearAll 8 'Clea&r' 1 1 450 nil true 482 8 'ClearDocument.ico' 544 65541 nil nil nil 326 1 #{UI.DividerMenuItem} 4097 370 1 402 #find 8 '&Find…' 9357 1 450 nil true 482 8 'Find.ico' 544 65541 nil nil nil 370 1 402 #findNext 8 'Find &Next' 1253 1 450 nil true 482 8 'FindNext.ico' 544 65541 nil nil nil 722 4097 322 nil true 50 5 370 1 402 #toggleIndentationGuides 8 'Indentation &Guides' 1 1 nil nil nil 370 1 402 #toggleLineEndings 8 'Line &Endings' 1 1 2374 2 #{Graphics.TextTileIcon} $¶ 8 'Arial' nil nil nil nil 1 nil nil nil nil 370 1 402 #toggleLineNumbers 8 'Line N&umbers' 1 1 nil nil nil 370 1 402 #toggleWhitespace 8 'W&hitespace' 1 1 nil nil nil 370 1 402 #toggleWordWrap 8 '&Word Wrap' 1 1 nil nil nil 8 '&Options' nil 134217729 450 nil true 482 8 'Preferences.ico' 544 65541 nil nil nil nil nil 8 '&Edit' nil 134217729 nil nil nil nil nil nil nil 192 nil nil 518 #{UI.NullConverter} nil 8 '' 3 #focusLost nil nil nil nil 550 #{Core.IdentityDictionary} 5 #callTip 3142 1 #{UI.Scintilla.TextStyle} 77 98 #gray 98 #white 1 nil nil nil nil #callTip nil nil nil #indentGuide 1442 75 1472 nil 1 nil nil nil nil #indentGuide 8 'Indentation guides, when visible' nil nil #lineNumber 1442 67 nil nil 1 nil 1601 nil nil #lineNumber nil nil nil #normal 1442 1 nil nil 1 nil nil nil nil #normal nil nil nil #whitespace 1442 53 98 #silver nil 1 nil nil nil nil #whitespace 8 'Whitespace, when visible' nil nil nil 326 1 #{UI.Scintilla.NullStyler} #normal 1410 1 #default 3142 2 #{UI.Scintilla.MarkerDefinition} nil nil nil nil 192 #circle nil nil nil nil nil nil 294 #{Core.IdentitySet} 0 nil 550 #{Core.LookupTable} 0 nil nil nil 1730 2 81 1472 121 98 #mediumSlateBlue nil nil 262 #{UI.Scintilla.NullScintillaLibrary} nil nil nil nil nil nil 1 1410 2 #null 1424 #text 1410 5 #callTip 1456 #indentGuide 1504 #lineNumber 1536 #normal 1552 #whitespace 1568 nil nil nil nil #{Core.Utf8String} nil nil nil nil 1410 3 #Error 1442 3 98 #firebrick 98 #floralWhite 1 nil nil nil nil #Error nil nil nil #Notification 1442 7 nil 98 #gainsboro 1 nil nil nil nil #Notification nil nil nil #Warning 1442 5 98 #darkGoldenrod 98 #ivory 1 nil nil nil nil #Warning nil nil nil nil nil nil 262 #{Core.MessageSequence} 50 10 774 #{Core.MessageSend} #createAt:extent: 50 2 130 1 1 130 1047 537 192 2050 #wordWrap: 8 #(true) 192 2050 #margins: 50 1 50 5 2118 3 #{UI.Scintilla.Margin} 1 192 nil 3 nil nil nil nil 2210 3 192 nil nil nil 67108863 nil nil 2210 5 192 nil nil nil nil nil nil 2210 7 192 nil nil nil nil nil nil 2210 9 192 nil nil nil nil nil nil 192 2050 #sciSetHScrollBar: 8 #(false) 192 2050 #tabWidth: 8 #(4) 192 2050 #maxCompletionListHeight: 8 #(9) 192 2050 #setLexerLanguage: 8 #(#null) 192 2050 #sciSetFontQuality: 8 #(3) 192 2050 #whitespaceMarkerSize: 8 #(2) 192 2050 #isUndoEnabled: 8 #(false) 192 262 #{OS.WINDOWPLACEMENT} 8 #[44 0 0 0 0 0 0 0 1 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 0 0 0 0 0 0 0 0 11 2 0 0 12 1 0 0] 8 #() 130 193 193 nil 45 518 #{Kernel.STBIdentityDictionaryProxy} 1408 50 2 192 8 'workspace' nil 2886 4 #{UI.MenuBar} nil true 50 5 322 nil true 50 9 370 1 402 #fileNew 8 '&New Workspace' 9373 1 450 nil true 482 8 'NewWorkspace.ico' 544 65541 nil nil nil 370 1 402 #fileOpen 8 '&Open Workspace…' 9375 1 450 nil true 482 8 'OpenWorkspace.ico' 544 65541 nil nil nil 370 1 402 #fileFileIn 8 '&File In…' 1 1 nil nil nil 722 4097 370 1 402 #saveImage 8 'Sa&ve Image' 1 1 450 nil true 482 8 'Snapshot.ico' 544 65541 nil nil nil 370 1 402 #saveImageAs 8 'Save Image As…' 1 1 nil nil nil 370 1 402 #compressChanges 8 '&Compress Changes' 1 1 nil nil nil 722 4097 370 1 402 #smalltalkExit 8 'E&xit Dolphin' 1 1 450 nil true 482 8 'PowerSwitch.ico' 544 65541 nil nil nil 8 '&File' nil 134217729 nil nil nil nil nil 322 nil true 50 8 370 1 402 #cr 8 'New&line' 1 1 nil nil nil 722 4097 370 1 402 #copySelection 8 '&Copy' 9351 1 450 nil true 482 8 'EditCopy.ico' 544 65541 nil nil nil 370 1 402 #selectAll 8 'Select &All' 9347 1 nil nil nil 370 1 402 #clearAll 8 'Clea&r' 9393 1 450 nil true 482 8 'ClearDocument.ico' 544 65541 nil nil nil 722 4097 370 1 402 #editFind 8 '&Find…' 9357 1 450 nil true 482 8 'Find.ico' 544 65541 nil nil nil 370 1 402 #findNext 8 'Find &Next' 1253 1 450 nil true 482 8 'FindNext.ico' 544 65541 nil nil nil 8 '&Edit' nil 134217729 nil nil nil nil nil 322 nil true 8 #() 8 '&Tools' #toolsMenu 134217729 nil nil nil nil nil 322 nil true 8 #() 8 'Wi&ndow' #windowMenu 134217729 nil nil nil nil nil 322 nil true 50 6 370 1 402 #help 8 '&Help on this tool' 1249 1 450 nil true 482 8 'Help.ico' 544 65541 nil nil nil 722 4097 370 1 402 #guidedTour 8 '&Guided tour' 1 1 nil nil nil 370 1 402 #educationCenter 8 '&Education centre' 1 1 nil nil nil 722 4097 370 1 402 #aboutDolphin 8 '&About Dolphin Smalltalk' 1 1 nil nil nil 8 '&Help' nil 134217729 nil nil nil nil nil 8 '' nil 134217729 nil nil nil nil nil nil nil nil 1 nil nil nil nil 1 nil nil 2002 50 2 2050 #createAt:extent: 50 2 130 6143 21 130 1079 655 32 2050 #text: 50 1 8 'System Transcript' 32 2530 8 #[44 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 11 0 0 10 0 0 0 26 14 0 0 81 1 0 0] 50 1 192 2592 nil 27)! !

!UI.TranscriptShell class categoriesForMethods!
publishedAspects!public! !
resource_Scintilla_view!public!resources-views! !
!

!UI.TreeModelAbstract class methodsFor!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^(super publishedEventsOfInstances)
		add: #itemUpdated:;
		add: #treeChanged:;
		add: #removingItem:;
		add: #item:movedToParent:;
		add: #item:removedFromParent:;
		add: #item:addedInParent:;
		yourself! !

!UI.TreeModelAbstract class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.TreeView class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#hasLinesAtRoot #hasLines #hasButtons #canEditLabels #showsSelAlways #isMonoExpandable #hasInfoTips #hasCheckBoxes #isExpandAllEnabled #hasFullRowSelect #isDoubleBuffered)
		do: [:each | aspects add: (Aspect boolean: each)].
	aspects
		add: (Aspect integer: #indentSeparation);
		add: (Aspect symbol: #updateMode from: self updateModes);
		yourself.
	^aspects! !

!UI.TreeView class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.TypeConverter class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #leftNullValue);
		add: (Aspect name: #rightNullValue);
		yourself! !

!UI.TypeConverter class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
!

!UI.ValueConvertingControlView class methodsFor!

applicableTypeConverterCategories
	"Answers a Set of class categories that contain <typeConverter>s that can 
    	be used with the receiver"

	^Set with: (ClassCategory name: 'MVP-Type Converters-General')!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect choice: #typeconverter
					evaluationFrom: 
						[| applicableTypeConverters |
						applicableTypeConverters := Set new.
						self applicableTypeConverterCategories do: [:each | applicableTypeConverters addAll: each classes].
						applicableTypeConverters asSortedArray collect: [:each | each shortName , ' new']])
						beImmutable;
		add: (Aspect name: #value);
		yourself! !

!UI.ValueConvertingControlView class categoriesForMethods!
applicableTypeConverterCategories!constants!public! !
publishedAspectsOfInstances!constants!public! !
!

!UI.ValueDialog class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !

!UI.ValueDialog class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.ValueModel methodsFor!

debugPrintOn: aStream
	"Implementation Note: Since #value is used by #printOn:, we implement this to 
	allow us to debug #value, otherwise setting a breakpoint in #value results in a
	meltdown."

	self basicPrintOn: aStream! !

!UI.ValueModel categoriesForMethods!
debugPrintOn:!printing!public! !
!

!UI.ValueModel class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Aspect name: #value);
		yourself!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !

!UI.ValueModel class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.ValuePresenter class methodsFor!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
    	^super publishedEventsOfInstances
    		add: #valueChanged;
    		yourself.
    ! !

!UI.ValuePresenter class categoriesForMethods!
publishedEventsOfInstances!events!public! !
!

!UI.View methodsFor!

aspectDisplayOn: aStream
  	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #printOn: but some classes of object can use alternate display 
  	formats.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."
  
  	self printOn: aStream!

loadViewResource: aResourceArray forEdit: isLoadingForEdit
	"Add an instance of the resource held in aResourceArray. Answer the new view."

	^aResourceArray stbInFiler
		isUpgrading: isLoadingForEdit;
		context: self;
		next!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| aspects |
	aspects := super publishedAspects.
	self parentView
		ifNotNil: 
			[:parent |
			parent layoutManager ifNotNil: [:layoutManager | aspects add: layoutManager arrangementAspect].
			parent isDesktop ifFalse: [aspects add: (Aspect string: #name)]].
	^aspects!

visualObjectAtPoint: aPoint
	"Private - Answers the object that will be found by the VisualObjectFinder at aPoint (in local coordinates)
	within the receiver"

	^self presenter! !

!UI.View categoriesForMethods!
aspectDisplayOn:!private! !
loadViewResource:forEdit:!binary filing!public! !
publishedAspects!constants!public! !
visualObjectAtPoint:!enquiries!private! !
!

!UI.View class methodsFor!

editNewDefaultView
	"Open the View Composer to create a new view for the receiver."

	| resourceIdentifier view resName |
	view := (DesignDesktopView forDpi: DisplayMonitor active dpi) addSubView: self new.
	resName := Prompter
				on: self defaultView
				prompt: 'Resource name:'
				caption: 'Create a view for class ' , self name.
	resName isNil ifTrue: [^self].
	resourceIdentifier := ResourceIdentifier class: self name: resName.
	(resourceIdentifier resourceOrNil isNil or: 
			[MessageBox new
				headline: 'Overwrite existing view?';
				confirm: '<1p> already exists. Do you wish to overwrite it?' << resourceIdentifier])
		ifFalse: [^self].
	resourceIdentifier assignView: view.
	view destroy.
	SmalltalkSystem current openViewComposerOn: resourceIdentifier!

makeDefaultResource
	self makeResource: 'Default view' inClass: self!

makeResource: aStringName inClass: aClass
	"Private - Save and instance of the receiver as a default writable ViewResource 
	called aString owned by aClass."

	| resID view shell |
	shell := ShellView new create.
	view := shell addSubView: self new.
	(resID := ResourceIdentifier class: aClass name: aStringName) assignView: view.
	shell destroy.
	^resID!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#hasBorder #hasClientEdge #hasStaticEdge #usePreferredExtent #isTabStop #isGroupStop #isDragSource #isDropTarget #isTransparent #isEnabled #inheritContextMenu)
		do: [:each | aspects add: (Aspect boolean: each)].
	aspects
		add: (Aspect color: #backcolor);
		add: (Aspect menu: #contextMenu) beImmutable;
		add: ((Aspect position: #position)
					beNonNullable;
					yourself);
		add: ((Aspect extent: #extent)
					beNonNullable;
					yourself);
		add: (Aspect extent: #preferredExtent);
		add: (Aspect font: #font);
		add: ((Aspect autostring: #text)
					beNonNullable;
					yourself).
	^aspects!

publishedEventsOfInstances
    	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."
    
	^(super publishedEventsOfInstances)
    		add: #actionPerformed;
    		add: #drop:;
    		add: #dragOver:;
    		add: #viewDeactivated;
    		add: #dragEnter:;
    		add: #dragCut:;
    		add: #dragLeave:;
    		add: #focusLost;
    		add: #leftButtonDoubleClicked:;
    		add: #aboutToDisplayMenu:;
    		add: #focusGained;
    		add: #leftButtonPressed:;
    		add: #leftButtonReleased:;
    		add: #viewOpened;
    		add: #rightButtonDoubleClicked:;
    		add: #requestDragImages:;
    		add: #viewClosed;
    		add: #requestDropOperations:;
    		add: #rightButtonPressed:;
    		add: #positionChanged:;
    		add: #rightButtonReleased:;
    		add: #keyPressed:;
    		add: #drag:;
    		add: #keyReleased:;
    		add: #keyTyped:;
		add: #sysKeyPressed:;
		add: #sysKeyRelease:;
		add: #sysKeyTyped:;
		yourself! !

!UI.View class categoriesForMethods!
editNewDefaultView!operations!public! !
makeDefaultResource!operations!private! !
makeResource:inClass:!operations!private! !
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!UI.WebView2View class methodsFor!

publishedAspectsOfInstances
	"Answer a Set of the aspects published by  instances of the receiver"

	| aspects |
	aspects := super publishedAspectsOfInstances.
	#(#allowSSO #isCustomCrashReportingEnabled #canNavigateToStrings #isStatusBarEnabled #isScriptEnabled #areBrowserAcceleratorKeysEnabled #allowExternalDrop #allowContextMenu #areDefaultScriptDialogsEnabled #areDevToolsEnabled #areHostObjectsAllowed #isBuiltInErrorPageEnabled #isGeneralAutofillEnabled #isPasswordAutosaveEnabled #isPinchZoomEnabled #isSwipeNavigationEnabled #isWebMessageEnabled #isZoomControlEnabled #isInPrivateModeEnabled #areBrowserExtensionsEnabled)
		do: [:each | aspects add: (Aspect boolean: each)].
	aspects add: (Aspect
				choice: #trackingPreventionLevel
				fromMap: 
					[LookupTable withAll: {
								'None' -> COREWEBVIEW2_TRACKING_PREVENTION_LEVEL_NONE.
								'Basic' -> COREWEBVIEW2_TRACKING_PREVENTION_LEVEL_BASIC.
								'Balanced' -> COREWEBVIEW2_TRACKING_PREVENTION_LEVEL_BALANCED.
								'Strict' -> COREWEBVIEW2_TRACKING_PREVENTION_LEVEL_STRICT
							}]
				nullValue: nil).
	^aspects!

publishedEventsOfInstances
	"Answer a Set of Symbols that describe the published events triggered
    	by instances of the receiver."

	^super publishedEventsOfInstances
		addAll: self webview2Events;
		yourself! !

!UI.WebView2View class categoriesForMethods!
publishedAspectsOfInstances!constants!public! !
publishedEventsOfInstances!events!public! !
!

!WebView2.ICoreWebView2Sequence methodsFor!

newBatchAccessor
	^KeyedAspectBatchAccessor subject: self batchSize: self publishedKeyedAspectsBatchSize!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver.
    	Implementation Note: By adding superclass aspects to the keyed aspect
    	table we get much better performance because it reduces the number 
    	of rehashes that are necessary due to resizing."

	^self publishedKeyedAspects!

publishedKeyedAspects
	"Answers a <LookupTable> of the published aspects of the 
    	receiver's keyed contents."

	^LookupTable new
		addAll: (self newBatchAccessor getBatchAccessors collect: [:each | each aspectDescriptor]);
		yourself!

publishedKeyedAspectsBatchSize
    	"Private - Answers the number of keyed aspects to display in the PAI return at a time"
    
    	^50
    ! !

!WebView2.ICoreWebView2Sequence categoriesForMethods!
newBatchAccessor!public! !
publishedAspects!public! !
publishedKeyedAspects!public! !
publishedKeyedAspectsBatchSize!private! !
!

!WebView2.ICoreWebView2Sequence class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
    	which is appropriate for representing aspects of the receiver's type."

	^aspectClass sequenceableCollection: aSymbol! !

!WebView2.ICoreWebView2Sequence class categoriesForMethods!
newInstanceAspect:class:!private! !
!

"End of package definition"!

