| package |
package := Package name: 'ActiveX Automation Development'.
package paxVersion: 2.1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk ActiveX Automation Development Tools.
Copyright (c) Object Arts Ltd, 2000-2006.

This package extends the Active-X Automation package for development purposes. It consists mainly of loose methods that extend the type-library analyzer to add code generation for wrapper classes, and the Active-X Component Wizard which provides a GUI onto those code generation facilities.

The IDE packages include an Active-X Component Wizard that makes it easy to instruct the type library analyzer to generate wrapper classes for almost any COM component.  It can even reverse engineer the IDL used to build the type library in the first place. You can find this wizard in the Additional Tools folder (or the Tools/Additional Tools menu), or open one up as follows:

	AXComponentWizard show

The type-library analyzer can also be driven programmatically, as is demonstrated by the example methods on the class side of <AXTypeLibraryAnalyzer>, in particular see #example1 which generates wrappers for Microsoft Excel 2000, and then automates it to produce a spreadsheet.

One you have generated interfaces for a component, you can create an instance of the component by send the #new message to its default interface, or you can use the #createObject: method, for example:

	IFontDisp createObject: ''''StdFont''''	"Ctrl+D"

It is also possible to use late-binding to access COM objects through IDispatch. See the class side examples of IDispatch.'.

package basicPackageVersion: '6.2'.


package setClassNames: #(
	#{Tools.AXAutomationAspect}
	#{Tools.AXComponentWizard}
	#{Tools.AXInspector}
	#{Tools.AXMethodName}
	#{Tools.AXRecordAspect}
	#{Tools.AXTypeLibraryPrompter}
	#{Tools.AXTypeLibRegistration}
	#{Tools.DispatchAspect}
).

package setMethodNames: #(
	#(#{Core.ByteArray class} #fieldType)
	#(#{Core.ByteArray class} #fieldType:indirections:)
	#(#{Core.ByteArray class} #pointerFieldType)
	#(#{Core.ByteArray class} #printStructField:indirections:on:in:)
	#(#{Core.GUID class} #arrayType:)
	#(#{Core.GUID class} #elementType:)
	#(#{Core.GUID class} #newToClipboard)
	#(#{Core.GUID class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{Core.GUID class} #printStructField:indirections:on:in:)
	#(#{Core.String class} #arrayType)
	#(#{Core.String class} #arrayType:)
	#(#{Core.String class} #elementType:)
	#(#{Core.String class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{Core.String class} #printStructField:indirections:on:in:)
	#(#{Core.Utf16String class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{External.Address class} #fieldType)
	#(#{External.ArrayField class} #printVariable:type:indirections:on:in:)
	#(#{External.ArrayPointerField class} #printVariable:type:indirections:on:in:)
	#(#{External.BOOL class} #fieldType)
	#(#{External.BOOLEAN class} #fieldType)
	#(#{External.BYTE class} #arrayType)
	#(#{External.BYTE class} #fieldType)
	#(#{External.DOUBLE class} #arrayType)
	#(#{External.DOUBLE class} #fieldType)
	#(#{External.DWORD class} #arrayType)
	#(#{External.DWORD class} #fieldType)
	#(#{External.DWORDBytes class} #fieldType)
	#(#{External.DynamicLinkLibrary} #DllRegisterServer)
	#(#{External.ExternalArray class} #arrayType)
	#(#{External.ExternalArray class} #fieldType)
	#(#{External.ExternalArray class} #fieldType:indirections:)
	#(#{External.ExternalArray class} #pointerFieldType)
	#(#{External.ExternalArray class} #printStructField:indirections:on:in:)
	#(#{External.Field class} #printArrayField:length:on:in:)
	#(#{External.Field class} #printArrayField:type:on:in:)
	#(#{External.Field class} #printConformantArrayLength:on:in:)
	#(#{External.Field class} #printFixedArrayLength:on:)
	#(#{External.Field class} #printTypedField:on:in:)
	#(#{External.Field class} #printVariable:type:indirections:on:in:)
	#(#{External.Field class} #warningMultiDimensionArray:)
	#(#{External.FLOAT class} #arrayType)
	#(#{External.FLOAT class} #fieldType)
	#(#{External.FLOAT class} #printDefaultValue:on:)
	#(#{External.Handle class} #arrayType:)
	#(#{External.Handle class} #fieldType)
	#(#{External.Handle class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{External.INT_PTR class} #arrayType)
	#(#{External.INT_PTR class} #fieldType)
	#(#{External.IntegerBytes class} #fieldType)
	#(#{External.IntegerBytes class} #printStructField:indirections:on:in:)
	#(#{External.POINT} #printOn:)
	#(#{External.PointerArray class} #fieldType)
	#(#{External.PointerArray class} #pointerFieldType)
	#(#{External.PointerArrayField class} #printVariable:type:indirections:on:in:)
	#(#{External.PointerField class} #printVariable:type:indirections:on:in:)
	#(#{External.QWORD class} #fieldType)
	#(#{External.SBYTE class} #arrayType)
	#(#{External.SBYTE class} #fieldType)
	#(#{External.SDWORD class} #arrayType)
	#(#{External.SDWORD class} #fieldType)
	#(#{External.Structure class} #arrayType)
	#(#{External.Structure class} #arrayType:)
	#(#{External.Structure class} #elementType:)
	#(#{External.Structure class} #fieldType)
	#(#{External.Structure class} #fieldType:indirections:)
	#(#{External.Structure class} #mustWrapOptionalArgument:)
	#(#{External.Structure class} #printDefaultValue:on:)
	#(#{External.Structure class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{External.Structure class} #printOptionalParameter:on:for:)
	#(#{External.Structure class} #printStructField:indirections:on:in:)
	#(#{External.Structure class} #printWrappedValue:on:for:)
	#(#{External.Structure class} #unspecifiedParameterValue)
	#(#{External.StructureArray class} #fieldType)
	#(#{External.StructureArray class} #pointerFieldType)
	#(#{External.StructureArrayField class} #printVariable:type:indirections:on:in:)
	#(#{External.StructureArrayPointerField class} #printVariable:type:indirections:on:in:)
	#(#{External.StructureField class} #printVariable:type:indirections:on:in:)
	#(#{External.SWORD class} #arrayType)
	#(#{External.SWORD class} #fieldType)
	#(#{External.UINT_PTR class} #arrayType)
	#(#{External.UINT_PTR class} #fieldType)
	#(#{External.UIntPtrBytes class} #fieldType)
	#(#{External.VOID class} #arrayType)
	#(#{External.VOID class} #fieldType)
	#(#{External.VOID class} #pointerFieldType)
	#(#{External.WORD class} #arrayType)
	#(#{External.WORD class} #fieldType)
	#(#{OS.COM class} #icon)
	#(#{OS.COM.AbstractDispatchImplementation class} #icon)
	#(#{OS.COM.AbstractELEMDESC} #printFieldsOn:)
	#(#{OS.COM.APIInfoAnalyzer} #areWrappersRequired)
	#(#{OS.COM.APIInfoAnalyzer} #basicPrintType:on:)
	#(#{OS.COM.APIInfoAnalyzer} #compileMethodWrapper:)
	#(#{OS.COM.APIInfoAnalyzer} #functionHasReturnValue:)
	#(#{OS.COM.APIInfoAnalyzer} #generateMethod:wrapping:)
	#(#{OS.COM.APIInfoAnalyzer} #generateMethodWrappers)
	#(#{OS.COM.APIInfoAnalyzer} #generateMethodWrappers:)
	#(#{OS.COM.APIInfoAnalyzer} #generateRawMethod:categories:)
	#(#{OS.COM.APIInfoAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.APIInfoAnalyzer} #idlAttributesOfFunc:)
	#(#{OS.COM.APIInfoAnalyzer} #instanceMethodCategories:)
	#(#{OS.COM.APIInfoAnalyzer} #isDefaultedWrapperRequiredFor:)
	#(#{OS.COM.APIInfoAnalyzer} #isMethodWrapperRequiredFor:)
	#(#{OS.COM.APIInfoAnalyzer} #methodCommentDescription)
	#(#{OS.COM.APIInfoAnalyzer} #mungeSelectorKeywords:forMember:)
	#(#{OS.COM.APIInfoAnalyzer} #namespaceImports)
	#(#{OS.COM.APIInfoAnalyzer} #printCommentPrefixOn:isPrivate:)
	#(#{OS.COM.APIInfoAnalyzer} #printFunctionPrototype:on:indent:)
	#(#{OS.COM.APIInfoAnalyzer} #printFunctionPrototypeComment:on:)
	#(#{OS.COM.APIInfoAnalyzer} #printIDLForFunction:on:indent:)
	#(#{OS.COM.APIInfoAnalyzer} #printMethod:wrapping:on:)
	#(#{OS.COM.APIInfoAnalyzer} #printMethodCommentPostamble:on:)
	#(#{OS.COM.APIInfoAnalyzer} #printMethodCommentPreamble:on:isPrivate:)
	#(#{OS.COM.APIInfoAnalyzer} #printRawMethodBody:name:on:)
	#(#{OS.COM.APIInfoAnalyzer} #printRawMethodComment:on:isPrivate:)
	#(#{OS.COM.APIInfoAnalyzer} #printRawMethodCommentHelp:on:)
	#(#{OS.COM.APIInfoAnalyzer} #printRawMethodCommentPreamble:on:isPrivate:)
	#(#{OS.COM.APIInfoAnalyzer} #printType:on:)
	#(#{OS.COM.APIInfoAnalyzer} #proputrefWrapperPrefix)
	#(#{OS.COM.APIInfoAnalyzer} #rawMethodNameForFunction:)
	#(#{OS.COM.APIInfoAnalyzer} #reinventBadSelector:member:)
	#(#{OS.COM.APIInfoAnalyzer} #selectorForFunction:)
	#(#{OS.COM.BSTR class} #newInstanceAspect:class:)
	#(#{OS.COM.BSTR class} #printDefaultValue:on:)
	#(#{OS.COM.BSTR class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{OS.COM.BSTR class} #printOptionalParameter:on:for:)
	#(#{OS.COM.BSTR class} #unspecifiedParameterValue)
	#(#{OS.COM.CountedArray class} #fieldType)
	#(#{OS.COM.CountedArray class} #pointerFieldType)
	#(#{OS.COM.CURRENCY} #printOn:)
	#(#{OS.COM.CURRENCY class} #mustWrapOptionalArgument:)
	#(#{OS.COM.CURRENCY class} #newInstanceAspect:class:)
	#(#{OS.COM.CUSTDATAITEM} #printIDLOn:)
	#(#{OS.COM.DATE class} #newInstanceAspect:class:)
	#(#{OS.COM.DATE class} #printDefaultValue:on:)
	#(#{OS.COM.DECIMAL} #printOn:)
	#(#{OS.COM.ELEMDESC} #idlAttributes)
	#(#{OS.COM.FUNCDESC} #buildMethodName)
	#(#{OS.COM.FUNCDESC} #displayOn:)
	#(#{OS.COM.FUNCDESC} #generate)
	#(#{OS.COM.FUNCDESC} #hasAnswer)
	#(#{OS.COM.FUNCDESC} #hasMultipleOutputs)
	#(#{OS.COM.FUNCDESC} #hasOptionalInputs)
	#(#{OS.COM.FUNCDESC} #hasReturnValue)
	#(#{OS.COM.FUNCDESC} #isInspectable)
	#(#{OS.COM.FUNCDESC} #isValueSetter)
	#(#{OS.COM.FUNCDESC} #methodName)
	#(#{OS.COM.FUNCDESC} #printIDLOn:indent:)
	#(#{OS.COM.FUNCDESC} #printOn:)
	#(#{OS.COM.FUNCDESC} #reinventBadVarNames:)
	#(#{OS.COM.IDispatch} #alternateInspectorClass)
	#(#{OS.COM.IDispatch} #aspectDisplayOn:)
	#(#{OS.COM.IDispatch} #debugPrintOn:)
	#(#{OS.COM.IDispatch} #printOn:)
	#(#{OS.COM.IDispatch} #publishedAspects)
	#(#{OS.COM.IDispatch class} #example1)
	#(#{OS.COM.IDispatch class} #example2)
	#(#{OS.COM.IDispatch class} #example3)
	#(#{OS.COM.IDispatch class} #example4)
	#(#{OS.COM.IDispatch class} #icon)
	#(#{OS.COM.Interface class} #icon)
	#(#{OS.COM.Interface class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{OS.COM.Interface class} #printOptionalParameter:on:for:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #areWrappersRequired)
	#(#{OS.COM.InterfaceTypeAnalyzer} #autoGenPropertiesCategories)
	#(#{OS.COM.InterfaceTypeAnalyzer} #buildMethodName:defaultOptionals:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #buildPublishedAspects:forObject:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #classCategories)
	#(#{OS.COM.InterfaceTypeAnalyzer} #compilePropertyAccessor:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #compileRawMethod:categories:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #determineNewBase:forExistingWrapper:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateClassCLSIDForCoclass:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateClassInitialize)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateClassInstanceCreation)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateClassSide:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateCollectionTest)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateDefaultMethod:wrapping:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateInitializeTypeLib)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateInstanceSide:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateMethodWrappers)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateMethodWrappers:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateNewForCoclass:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropertyAccessors)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropGet:wrapping:defaultOptionals:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropGetWrappers:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropPut:wrapping:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropPutRefWrappers:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generatePropPutWrappers:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateRawPropGet:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateRawPropPut:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateRuntimeExtensibilityTest)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateTests)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateValueAccessor:wrapping:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateValueMutator:wrapping:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateValuePropertyWrappers)
	#(#{OS.COM.InterfaceTypeAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #idlAttributes)
	#(#{OS.COM.InterfaceTypeAnalyzer} #inspectableProperties)
	#(#{OS.COM.InterfaceTypeAnalyzer} #instanceMethodCategories:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #interfaceCategoryName)
	#(#{OS.COM.InterfaceTypeAnalyzer} #isAutomationCompatible)
	#(#{OS.COM.InterfaceTypeAnalyzer} #isInspectablePropGet:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #isProtocolRequired)
	#(#{OS.COM.InterfaceTypeAnalyzer} #methodCommentDescription)
	#(#{OS.COM.InterfaceTypeAnalyzer} #newAspectForMember:ppb:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printArgument:named:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printDefaultMethod:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printDefaultMethodBody:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printMethod:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printMethodBody:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printMethodComment:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printMultiOutMethodBody:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropertyCommentDecl:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropertyCommentPostamble:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropGet:wrapping:on:defaultOptionals:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropGetComment:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropGetCommentPreamble:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropPut:wrapping:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printPropPutComment:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printRawPropGetBody:name:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printRawPropPutBody:name:on:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #printValuePropCommentPostambleOn:)
	#(#{OS.COM.InterfaceTypeAnalyzer} #rawPropCategories)
	#(#{OS.COM.InterfaceTypeAnalyzer} #reservedSelectors)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #icon)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #optimizedSelectors)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #overridableIDispatchSelectors)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #overridableIUnknownSelectors)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #reservedDispSelectors)
	#(#{OS.COM.InterfaceTypeAnalyzer class} #reservedUnkSelectors)
	#(#{OS.COM.ITypeInfo} #printOn:)
	#(#{OS.COM.ITypeLib} #printOn:)
	#(#{OS.COM.MemberDesc} #idlAttributes)
	#(#{OS.COM.MemberDesc} #idlAttributesAndId)
	#(#{OS.COM.MemberDesc} #idlCustomAttributes)
	#(#{OS.COM.MemberDesc} #isInspectable)
	#(#{OS.COM.MemberDesc} #printIDL)
	#(#{OS.COM.MemberDesc} #printIDLOn:)
	#(#{OS.COM.MemberDesc} #printIDLOn:indent:)
	#(#{OS.COM.MemberDesc class} #publishedAspectsOfInstances)
	#(#{OS.COM.PARAMDESC} #idlAttributes)
	#(#{OS.COM.Record} #publishedAspects)
	#(#{OS.COM.SAFEARRAY} #printOn:)
	#(#{OS.COM.SAFEARRAY class} #fieldType)
	#(#{OS.COM.SAFEARRAY class} #pointerFieldType)
	#(#{OS.COM.SAFEARRAY class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{OS.COM.StructureTypeAnalyzer} #conformsToRequiredProtocols:)
	#(#{OS.COM.StructureTypeAnalyzer} #determineNewBase:forExistingWrapper:)
	#(#{OS.COM.StructureTypeAnalyzer} #generateClassSide:)
	#(#{OS.COM.StructureTypeAnalyzer} #generateDefineFields)
	#(#{OS.COM.StructureTypeAnalyzer} #generateInstanceSide:)
	#(#{OS.COM.StructureTypeAnalyzer} #generateTypeLibAccessor)
	#(#{OS.COM.StructureTypeAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.StructureTypeAnalyzer} #generateWrapper)
	#(#{OS.COM.StructureTypeAnalyzer} #printAnonymousStruct:offset:prefix:hidden:on:)
	#(#{OS.COM.StructureTypeAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.StructureTypeAnalyzer} #printFieldDefinition:offset:prefix:hidden:on:)
	#(#{OS.COM.StructureTypeAnalyzer} #printFieldDefinitionsOn:offset:prefix:hidden:)
	#(#{OS.COM.StructureTypeAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.StructureTypeAnalyzer} #printIDLForVariablesOn:indent:)
	#(#{OS.COM.StructureTypeAnalyzer} #printIDLOn:indent:)
	#(#{OS.COM.StructureTypeAnalyzer} #printNamedFieldDefinition:offset:prefix:hidden:on:)
	#(#{OS.COM.StructureTypeAnalyzer class} #icon)
	#(#{OS.COM.StructureTypeAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TKindAliasAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.TKindAliasAnalyzer} #generateWrapper)
	#(#{OS.COM.TKindAliasAnalyzer} #idlAttributes)
	#(#{OS.COM.TKindAliasAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindAliasAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.TKindAliasAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindAliasAnalyzer} #printIDLOn:indent:)
	#(#{OS.COM.TKindCoclassAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.TKindCoclassAnalyzer} #generateWrapper)
	#(#{OS.COM.TKindCoclassAnalyzer} #idlAttributes)
	#(#{OS.COM.TKindCoclassAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindCoclassAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindCoclassAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TKindDispatchAnalyzer} #buildPropertyAccessorName:)
	#(#{OS.COM.TKindDispatchAnalyzer} #buildPropertyMutatorName:)
	#(#{OS.COM.TKindDispatchAnalyzer} #generatePropertyAccessor:)
	#(#{OS.COM.TKindDispatchAnalyzer} #generatePropertyAccessors)
	#(#{OS.COM.TKindDispatchAnalyzer} #generatePropertyMutator:)
	#(#{OS.COM.TKindDispatchAnalyzer} #generateRawMethod:categories:)
	#(#{OS.COM.TKindDispatchAnalyzer} #generateValuePropertyWrappers)
	#(#{OS.COM.TKindDispatchAnalyzer} #generateWrapper)
	#(#{OS.COM.TKindDispatchAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindDispatchAnalyzer} #isInspectablePropGet:)
	#(#{OS.COM.TKindDispatchAnalyzer} #isProtocolRequired)
	#(#{OS.COM.TKindDispatchAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printIDLOfPropertiesOn:indent:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printMethodBody:wrapping:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printMultiOutMethodBody:wrapping:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printPropertyCommentDecl:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printPropGet:wrapping:on:defaultOptionals:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printPropPut:wrapping:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printRawMethodBody:name:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printRawPropGetBody:name:on:)
	#(#{OS.COM.TKindDispatchAnalyzer} #printRawPropPutBody:name:on:)
	#(#{OS.COM.TKindDispatchAnalyzer class} #icon)
	#(#{OS.COM.TKindDispatchAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TKindEnumAnalyzer} #constantsPool)
	#(#{OS.COM.TKindEnumAnalyzer} #generateInstanceSide:)
	#(#{OS.COM.TKindEnumAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.TKindEnumAnalyzer} #idlAttributes)
	#(#{OS.COM.TKindEnumAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindEnumAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindEnumAnalyzer} #printIDLOn:indent:)
	#(#{OS.COM.TKindEnumAnalyzer} #removeOldWrappers:)
	#(#{OS.COM.TKindEnumAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TKindInterfaceAnalyzer} #areWrappersRequired)
	#(#{OS.COM.TKindInterfaceAnalyzer} #functionHasReturnValue:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #generateClassInitialize)
	#(#{OS.COM.TKindInterfaceAnalyzer} #generateDefineFunctions)
	#(#{OS.COM.TKindInterfaceAnalyzer} #generatePropertyAccessors)
	#(#{OS.COM.TKindInterfaceAnalyzer} #generateRawPropGet:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #generateRawPropPut:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #idlAttributes)
	#(#{OS.COM.TKindInterfaceAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindInterfaceAnalyzer} #isInspectablePropGet:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #isMethodWrapperRequiredFor:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printMethodBody:wrapping:on:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printMultiOutMethodBody:wrapping:on:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printPropertyCommentDecl:on:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printPropGet:wrapping:on:defaultOptionals:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printPropPut:wrapping:on:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printRawMethodBody:name:on:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printRawPropGetComment:on:isPrivate:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #printRawPropPutComment:name:on:isPrivate:)
	#(#{OS.COM.TKindInterfaceAnalyzer} #rawMethodNameForFunction:)
	#(#{OS.COM.TKindModuleAnalyzer} #areWrappersRequired)
	#(#{OS.COM.TKindModuleAnalyzer} #generateClassFilename)
	#(#{OS.COM.TKindModuleAnalyzer} #generateClassSide:)
	#(#{OS.COM.TKindModuleAnalyzer} #generateInstanceSide:)
	#(#{OS.COM.TKindModuleAnalyzer} #generateMethodWrappers)
	#(#{OS.COM.TKindModuleAnalyzer} #generateWrapper)
	#(#{OS.COM.TKindModuleAnalyzer} #idlAttributes)
	#(#{OS.COM.TKindModuleAnalyzer} #idlAttributesOfFunc:)
	#(#{OS.COM.TKindModuleAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindModuleAnalyzer} #instanceMethodCategories:)
	#(#{OS.COM.TKindModuleAnalyzer} #methodCommentDescription)
	#(#{OS.COM.TKindModuleAnalyzer} #mungeSelectorKeywords:forMember:)
	#(#{OS.COM.TKindModuleAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.TKindModuleAnalyzer} #printIDLBodyOn:indent:)
	#(#{OS.COM.TKindModuleAnalyzer} #printMethod:wrapping:on:)
	#(#{OS.COM.TKindModuleAnalyzer} #printRawMethodBody:name:on:)
	#(#{OS.COM.TKindModuleAnalyzer class} #icon)
	#(#{OS.COM.TKindModuleAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TKindRecordAnalyzer} #idlKeyword)
	#(#{OS.COM.TKindUnionAnalyzer} #idlKeyword)
	#(#{OS.COM.TYPEDESC} #printOn:)
	#(#{OS.COM.TypeInfoAnalyzer} #autoGenCategoryName)
	#(#{OS.COM.TypeInfoAnalyzer} #autoGenClassCommentMarker)
	#(#{OS.COM.TypeInfoAnalyzer} #autoGenMethodComment)
	#(#{OS.COM.TypeInfoAnalyzer} #baseClassCheck:)
	#(#{OS.COM.TypeInfoAnalyzer} #basicGenerate)
	#(#{OS.COM.TypeInfoAnalyzer} #canGenerateClassMessage:)
	#(#{OS.COM.TypeInfoAnalyzer} #canGenerateMessage:)
	#(#{OS.COM.TypeInfoAnalyzer} #canGenerateMessage:into:)
	#(#{OS.COM.TypeInfoAnalyzer} #canGenerateMethodNamed:)
	#(#{OS.COM.TypeInfoAnalyzer} #checkConformanceOfExistingClass:)
	#(#{OS.COM.TypeInfoAnalyzer} #classCategories)
	#(#{OS.COM.TypeInfoAnalyzer} #classConstantsCategories)
	#(#{OS.COM.TypeInfoAnalyzer} #classInitializerCategories)
	#(#{OS.COM.TypeInfoAnalyzer} #compileClassMethod:categories:)
	#(#{OS.COM.TypeInfoAnalyzer} #compileMethod:categories:)
	#(#{OS.COM.TypeInfoAnalyzer} #compileRawMethod:categories:)
	#(#{OS.COM.TypeInfoAnalyzer} #compileTestingMethod:)
	#(#{OS.COM.TypeInfoAnalyzer} #conformsToRequiredProtocols:)
	#(#{OS.COM.TypeInfoAnalyzer} #constantsPool)
	#(#{OS.COM.TypeInfoAnalyzer} #determineNewBase:forExistingWrapper:)
	#(#{OS.COM.TypeInfoAnalyzer} #emitComment:on:)
	#(#{OS.COM.TypeInfoAnalyzer} #generate)
	#(#{OS.COM.TypeInfoAnalyzer} #generateAs:flags:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateClassComment)
	#(#{OS.COM.TypeInfoAnalyzer} #generateClassDefinition:imports:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateClassSide:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateConstants)
	#(#{OS.COM.TypeInfoAnalyzer} #generateConstantsIntoPool:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateInstanceSide:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateVariableDefinition)
	#(#{OS.COM.TypeInfoAnalyzer} #generateVariableDefinition:)
	#(#{OS.COM.TypeInfoAnalyzer} #generateWrapper)
	#(#{OS.COM.TypeInfoAnalyzer} #generationFlags)
	#(#{OS.COM.TypeInfoAnalyzer} #guidCheck:)
	#(#{OS.COM.TypeInfoAnalyzer} #guidClashPrompt:)
	#(#{OS.COM.TypeInfoAnalyzer} #handleClash:response:)
	#(#{OS.COM.TypeInfoAnalyzer} #identifierFrom:)
	#(#{OS.COM.TypeInfoAnalyzer} #idlTypeOfVT:)
	#(#{OS.COM.TypeInfoAnalyzer} #isClassCheck:)
	#(#{OS.COM.TypeInfoAnalyzer} #packageCheck:)
	#(#{OS.COM.TypeInfoAnalyzer} #printAutoGenMethodPostambleOn:)
	#(#{OS.COM.TypeInfoAnalyzer} #printClass:on:)
	#(#{OS.COM.TypeInfoAnalyzer} #printClassCommentPreambleOn:)
	#(#{OS.COM.TypeInfoAnalyzer} #printHelpstringComment:on:)
	#(#{OS.COM.TypeInfoAnalyzer} #printIDLDecl:type:on:)
	#(#{OS.COM.TypeInfoAnalyzer} #printIDLForVariable:on:indent:)
	#(#{OS.COM.TypeInfoAnalyzer} #removeAutoGeneratedMethods:)
	#(#{OS.COM.TypeInfoAnalyzer} #removeOldWrappers:)
	#(#{OS.COM.TypeInfoAnalyzer} #reservedSelectors)
	#(#{OS.COM.TypeInfoAnalyzer} #resolveExistingClass:)
	#(#{OS.COM.TypeInfoAnalyzer} #shouldOverwriteClassComment)
	#(#{OS.COM.TypeInfoAnalyzer} #superclassClashPrompt:)
	#(#{OS.COM.TypeInfoAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TypeInfoObject} #abortGeneration)
	#(#{OS.COM.TypeInfoObject} #basicIdlAttributes)
	#(#{OS.COM.TypeInfoObject} #classComments)
	#(#{OS.COM.TypeInfoObject} #classComments:)
	#(#{OS.COM.TypeInfoObject} #constantsPool)
	#(#{OS.COM.TypeInfoObject} #customAttributes)
	#(#{OS.COM.TypeInfoObject} #defineFunctionTables)
	#(#{OS.COM.TypeInfoObject} #defineFunctionTables:)
	#(#{OS.COM.TypeInfoObject} #defineMethodProtocols)
	#(#{OS.COM.TypeInfoObject} #defineMethodProtocols:)
	#(#{OS.COM.TypeInfoObject} #forceLowercaseIdentifiers)
	#(#{OS.COM.TypeInfoObject} #forceLowercaseIdentifiers:)
	#(#{OS.COM.TypeInfoObject} #fullyQualifiedName)
	#(#{OS.COM.TypeInfoObject} #generateSourceInterfaces)
	#(#{OS.COM.TypeInfoObject} #generationFlags)
	#(#{OS.COM.TypeInfoObject} #generationFlags:)
	#(#{OS.COM.TypeInfoObject} #getCustData)
	#(#{OS.COM.TypeInfoObject} #guidClashSignal)
	#(#{OS.COM.TypeInfoObject} #highLevelWrappers)
	#(#{OS.COM.TypeInfoObject} #highLevelWrappers:)
	#(#{OS.COM.TypeInfoObject} #idlAttributes)
	#(#{OS.COM.TypeInfoObject} #idlKeyword)
	#(#{OS.COM.TypeInfoObject} #isTraceOnly)
	#(#{OS.COM.TypeInfoObject} #isTracing)
	#(#{OS.COM.TypeInfoObject} #isTracingVerbose)
	#(#{OS.COM.TypeInfoObject} #isTracingVerbose:)
	#(#{OS.COM.TypeInfoObject} #namespaceImports)
	#(#{OS.COM.TypeInfoObject} #packageCheck:)
	#(#{OS.COM.TypeInfoObject} #printAttributeList:on:)
	#(#{OS.COM.TypeInfoObject} #printIDL)
	#(#{OS.COM.TypeInfoObject} #printIDLAttributes:on:indent:)
	#(#{OS.COM.TypeInfoObject} #printIDLAttributesOn:indent:)
	#(#{OS.COM.TypeInfoObject} #printIDLBodyOn:indent:)
	#(#{OS.COM.TypeInfoObject} #printIDLOn:)
	#(#{OS.COM.TypeInfoObject} #printIDLOn:indent:)
	#(#{OS.COM.TypeInfoObject} #printOn:)
	#(#{OS.COM.TypeInfoObject} #tracing)
	#(#{OS.COM.TypeInfoObject} #tracing:)
	#(#{OS.COM.TypeInfoObject class} #classCommentStyleMap)
	#(#{OS.COM.TypeInfoObject class} #classCommentStyles)
	#(#{OS.COM.TypeInfoObject class} #guidClashSignal)
	#(#{OS.COM.TypeInfoObject class} #highLevelWrapperStyleMap)
	#(#{OS.COM.TypeInfoObject class} #highLevelWrapperStyles)
	#(#{OS.COM.TypeInfoObject class} #icon)
	#(#{OS.COM.TypeInfoObject class} #stonAllInstVarNames)
	#(#{OS.COM.TypeInfoObject class} #tracingStyleMap)
	#(#{OS.COM.TypeInfoObject class} #tracingStyles)
	#(#{OS.COM.TypeLibDocumentation} #idlAttributes)
	#(#{OS.COM.TypeLibDocumentation class} #icon)
	#(#{OS.COM.TypeLibraryAnalyzer} #addAlias:forType:)
	#(#{OS.COM.TypeLibraryAnalyzer} #addClassToPackage:)
	#(#{OS.COM.TypeLibraryAnalyzer} #addVariableToPackage:)
	#(#{OS.COM.TypeLibraryAnalyzer} #binding)
	#(#{OS.COM.TypeLibraryAnalyzer} #checkConformanceOfExistingPool:)
	#(#{OS.COM.TypeLibraryAnalyzer} #constantsPool)
	#(#{OS.COM.TypeLibraryAnalyzer} #constantsPoolBinding)
	#(#{OS.COM.TypeLibraryAnalyzer} #constantsPoolName)
	#(#{OS.COM.TypeLibraryAnalyzer} #constantsPoolName:)
	#(#{OS.COM.TypeLibraryAnalyzer} #defaultNamespaceImports)
	#(#{OS.COM.TypeLibraryAnalyzer} #defaultPackageFolder)
	#(#{OS.COM.TypeLibraryAnalyzer} #definesSymbolicConstants)
	#(#{OS.COM.TypeLibraryAnalyzer} #environment)
	#(#{OS.COM.TypeLibraryAnalyzer} #fullyQualifiedName)
	#(#{OS.COM.TypeLibraryAnalyzer} #generatableInterfaces)
	#(#{OS.COM.TypeLibraryAnalyzer} #generatableModules)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateClass:for:imports:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateConstantsIntoPool:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateConstantsPool)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateDispatchWrapper:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateDispatchWrapper:name:flags:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateInterfaceWrapper:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateInterfaceWrapper:name:flags:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateInterfaceWrappers)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateTypelibGlobal)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateTypelibGlobal:)
	#(#{OS.COM.TypeLibraryAnalyzer} #generateWrapper:name:flags:)
	#(#{OS.COM.TypeLibraryAnalyzer} #idlAttributes)
	#(#{OS.COM.TypeLibraryAnalyzer} #idlHelpAttributes:)
	#(#{OS.COM.TypeLibraryAnalyzer} #idlKeyword)
	#(#{OS.COM.TypeLibraryAnalyzer} #isPoolCheck:)
	#(#{OS.COM.TypeLibraryAnalyzer} #moveClassToPackage:)
	#(#{OS.COM.TypeLibraryAnalyzer} #namespaceBinding)
	#(#{OS.COM.TypeLibraryAnalyzer} #namespaceImports)
	#(#{OS.COM.TypeLibraryAnalyzer} #package)
	#(#{OS.COM.TypeLibraryAnalyzer} #package:)
	#(#{OS.COM.TypeLibraryAnalyzer} #packageCheck:)
	#(#{OS.COM.TypeLibraryAnalyzer} #packageName)
	#(#{OS.COM.TypeLibraryAnalyzer} #packageName:)
	#(#{OS.COM.TypeLibraryAnalyzer} #prefix:)
	#(#{OS.COM.TypeLibraryAnalyzer} #prefixGlobalNames)
	#(#{OS.COM.TypeLibraryAnalyzer} #printIDLForwardRefsOn:indent:)
	#(#{OS.COM.TypeLibraryAnalyzer} #printIDLOn:indent:)
	#(#{OS.COM.TypeLibraryAnalyzer} #printOn:)
	#(#{OS.COM.TypeLibraryAnalyzer} #resolveExistingPool:)
	#(#{OS.COM.TypeLibraryAnalyzer} #superclassClashSignal)
	#(#{OS.COM.TypeLibraryAnalyzer} #variableName)
	#(#{OS.COM.TypeLibraryAnalyzer class} #example1)
	#(#{OS.COM.TypeLibraryAnalyzer class} #example2)
	#(#{OS.COM.TypeLibraryAnalyzer class} #example3)
	#(#{OS.COM.TypeLibraryAnalyzer class} #fileTypes)
	#(#{OS.COM.TypeLibraryAnalyzer class} #icon)
	#(#{OS.COM.TypeLibraryAnalyzer class} #open)
	#(#{OS.COM.TypeLibraryAnalyzer class} #publishedAspectsOfInstances)
	#(#{OS.COM.TypeLibraryAnalyzer class} #registerTypeLib)
	#(#{OS.COM.TypeLibraryAnalyzer class} #stonAllInstVarNames)
	#(#{OS.COM.TypeLibraryAnalyzer class} #superclassClashSignal)
	#(#{OS.COM.TypeLibraryAnalyzer class} #typeLibRegistrations)
	#(#{OS.COM.VARDESC} #printIDLOn:indent:)
	#(#{OS.COM.VARDESC} #printOn:)
	#(#{OS.COM.VARIANT} #debugPrintOn:)
	#(#{OS.COM.VARIANT} #printIDLOn:)
	#(#{OS.COM.VARIANT} #printOn:)
	#(#{OS.COM.VARIANT class} #example1)
	#(#{OS.COM.VARIANT class} #printMethodArgument:elemdesc:indirections:on:for:)
	#(#{OS.COM.VARIANT class} #printOptionalParameter:on:for:)
	#(#{OS.COM.VARIANT_BOOL} #printOn:)
	#(#{OS.COM.VARIANT_BOOL class} #newInstanceAspect:class:)
	#(#{OS.HRESULT class} #fieldType)
	#(#{OS.LARGE_INTEGER class} #fieldType)
).

package setPrerequisites: #(
	'..\..\ActiveX\Automation\ActiveX Automation'
	'..\Base\Development System'
	'..\..\Base\Dolphin'
	'..\..\MVP\Base\Dolphin Basic Geometry'
	'..\..\MVP\Presenters\Boolean\Dolphin Boolean Presenter'
	'..\..\MVP\Views\Cards\Dolphin Card Containers'
	'..\..\MVP\Presenters\Choice\Dolphin Choice Presenter'
	'..\..\MVP\Views\Common Controls\Dolphin Common Controls'
	'..\..\MVP\Dialogs\Common\Dolphin Common Dialogs'
	'..\..\Base\Dolphin Legacy Date & Time'
	'..\..\MVP\Models\List\Dolphin List Models'
	'..\..\MVP\Presenters\List\Dolphin List Presenter'
	'..\..\Base\Dolphin Message Box'
	'..\..\MVP\Base\Dolphin MVP Base'
	'..\..\MVP\Dialogs\Progress\Dolphin Progress Dialog'
	'..\..\MVP\Presenters\Prompters\Dolphin Prompter'
	'..\..\Registry\Dolphin Registry Access'
	'..\..\Base\Dolphin SizeIs Fields'
	'..\..\MVP\Presenters\Text\Dolphin Text Presenter'
	'..\..\MVP\Type Converters\Dolphin Type Converters'
	'..\..\MVP\Models\Value\Dolphin Value Models'
	'..\..\ActiveX\COM\OLE COM'
	'..\..\System\Compiler\Smalltalk Parser'
	'..\..\ActiveX\Shell\Windows Shell'
).

package!

"Class Definitions"!

Core.Object subclass: #'Tools.AXMethodName'
	instanceVariableNames: 'keywords argumentNames indices'
	classVariableNames: ''
	imports: #(#{OS.COM private})
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Object subclass: #'Tools.AXTypeLibRegistration'
	instanceVariableNames: 'description guidString versionString minor major'
	classVariableNames: ''
	imports: #(#{OS.COM private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.Aspect subclass: #'Tools.AXAutomationAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AXAutomationAspect subclass: #'Tools.AXRecordAspect'
	instanceVariableNames: ''
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.AXAutomationAspect subclass: #'Tools.DispatchAspect'
	instanceVariableNames: 'dispid'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!
UI.ValueDialog subclass: #'Tools.AXTypeLibraryPrompter'
	instanceVariableNames: 'typeLibs path guidPresenter'
	classVariableNames: ''
	imports: #(#{OS.COM private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.SmalltalkToolShell subclass: #'Tools.AXComponentWizard'
	instanceVariableNames: 'typeLibs types description guid globalName namespaceName packageName forcePackage cards libraryName libraryPath buffer typelibGlobal constantsPoolName highLevelWrappers classComments tracing defineProtocols defineFunctionTables lowercaseIdentifiers verboseTracing'
	classVariableNames: ''
	imports: #(#{OS.COM private})
	classInstanceVariableNames: ''
	classConstants: {}!
Tools.BasicInspector subclass: #'Tools.AXInspector'
	instanceVariableNames: 'collection'
	classVariableNames: ''
	imports: #()
	classInstanceVariableNames: ''
	classConstants: {}!

"Loose Methods"!

!Core.ByteArray class methodsFor!

fieldType
	^External.ArrayField!

fieldType: aVARDESC indirections: anInteger
	"Private - Answer the <ExternalField> type to be used to represent a field described by the
	<VARDESC> argument based of the receiver's basic field type in structures with the given
	number of <integer> indirections."

	^anInteger == 0
		ifTrue: [self fieldType]
		ifFalse: 
			[anInteger == 1 ifTrue: [self pointerFieldType] ifFalse: [External.LPVOIDField]	"Represent as anon. indirection"]!

pointerFieldType
	^External.ArrayPointerField!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the for the C-array of bytes variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	(self fieldType: aVARDESC indirections: anInteger)
		printVariable: aVARDESC
		type: self
		indirections: anInteger
		on: aPuttableStream
		in: aNamespace! !
!Core.ByteArray class categoriesFor: #fieldType!constants!private! !
!Core.ByteArray class categoriesFor: #fieldType:indirections:!constants!private! !
!Core.ByteArray class categoriesFor: #pointerFieldType!constants!private! !
!Core.ByteArray class categoriesFor: #printStructField:indirections:on:in:!private! !

!Core.GUID class methodsFor!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [External.StructureArray] ifFalse: [External.PointerArray]!

elementType: indirs
	"Private - Answer the <ExternalStructure> class to represent array elements of this 
	external type with the <integer> indirections, indirs."

	^indirs < 2 ifTrue: [self] ifFalse: [External.LPVOID]!

newToClipboard
	"Useful for pasting GUIDs into IDL"

	| answer |
	answer := self newUnique.
	(answer asString copyFrom: 2 to: 37) copyToClipboard.
	^answer!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	anELEMDESC isOut
		ifTrue: 
			[| isIn |
			"If an output argument, need an pointer buffer to receive the result"
			(isIn := anELEMDESC isIn) ifTrue: [aPuttableStream nextPut: $(].
			anInteger > 1
				ifTrue: 
					[anAPIInfoAnalyzer printClass: External.REFGUID on: aPuttableStream.
					isIn
						ifTrue: 
							[aPuttableStream
								space;
								display: #fromAddress:;
								space;
								nextPutAll: aString]
						ifFalse: 
							[aPuttableStream
								space;
								display: #new]]
				ifFalse: 
					[anAPIInfoAnalyzer printClass: self on: aPuttableStream.
					aPuttableStream
						space;
						display: #new.
					isIn
						ifTrue: 
							[aPuttableStream
								space;
								display: #value:;
								space;
								nextPutAll: aString;
								nextPutAll: '; yourself']].
			isIn ifTrue: [aPuttableStream nextPut: $)]]
		ifFalse: 
			["Input only, just pass the GUID"
			aPuttableStream nextPutAll: aString]!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the Guid variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	"Implementation Note: Copy <External.Structure>'s implementation."

	(External.Structure fieldType: aVARDESC indirections: anInteger)
		printVariable: aVARDESC
		type: self
		indirections: anInteger
		on: aPuttableStream
		in: aNamespace! !
!Core.GUID class categoriesFor: #arrayType:!constants!private! !
!Core.GUID class categoriesFor: #elementType:!constants!private! !
!Core.GUID class categoriesFor: #newToClipboard!public! !
!Core.GUID class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!Core.GUID class categoriesFor: #printStructField:indirections:on:in:!private! !

!Core.String class methodsFor!

arrayType
	^self!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections.
	Note that in the case of a String, one level of indirection is implied, and therefore we
	always use the PointerArray type."

	^External.PointerArray!

elementType: indirs
	"Private - Answer the <ExternalStructure> class to represent array elements of this 
	external type with the <integer> indirections, indirs.
	Note that one level of indirection is implied already."

	^indirs == 0
		ifTrue: [self]
		ifFalse: [self pointerType]!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	"Implementation Note: If the argument is an output (double indirection since one level implied) we assume that the output will be allocated by the callee using CoTaskMemAlloc. This assumption may be false, in which case it may be necessary to manually write a high-level wrapper method (which calls the low-level wrapper which will have been emitted correctly regardless) following the documentation for the interface."

	anELEMDESC isOut
		ifFalse: 
			["Input only, or singly indirected in-out argument - assume argument in correct form already"
			aPuttableStream nextPutAll: aString]
		ifTrue: 
			[| isIn |
			"Out or in,out"
			isIn := anELEMDESC isIn.
			anInteger > 0
				ifTrue: 
					["As we already have one level of indirection, and form of out parameter must be
					 through COM task memory, so we'll need to use a StructurePointer ot ease the
					 task."
					self assert: [anInteger >= 1].
					aPuttableStream nextPut: $(.
					anAPIInfoAnalyzer printClass: External.StructurePointer on: aPuttableStream.
					isIn
						ifTrue: 
							["If an in-out argument, need to call with value in the buffer"
							aPuttableStream
								nextPutAll: ' fromAddress: ';
								nextPutAll: aString;
								nextPutAll: ' as';
								print: self;
								space;
								nextPutAll: #copyToCOMTaskMemory]
						ifFalse: 
							["If an output only argument, need an pointer buffer to receive the result"
							aPuttableStream nextPutAll: ' newNull: '.
							anAPIInfoAnalyzer printClass: OS.COM.TaskMemory on: aPuttableStream].
					aPuttableStream
						nextPutAll: ' elementClass: ';
						print: self;
						nextPut: $)]
				ifFalse: 
					[isIn
						ifTrue: 
							["Drop through and pass input argument as a buffer"
							]
						ifFalse: 
							[#todo.	"Treat these as in-out parameters (at ELEMDESC level) so wrapper includes an argument"
							Notification
								signal: ('Warning: Parameter <1p> of <2s>() is () is [out]char*, which means it is a caller allocated buffer of unspecified size. The function will require a hand coded wrapper method.'
										expandMacrosWith: aString
										with: anELEMDESC owner fullName).
							anAPIInfoAnalyzer printClass: self on: aPuttableStream.
							aPuttableStream
								space;
								display: #new]]]!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	aVARDESC tdesc arrayDesc
		ifNil: 
			["a [string] type in the IDL, e.g. an LPSTR, our could be an array of chars, or pointer to array of chars."
			(aVARDESC isConformant ifTrue: [External.ArrayPointerField] ifFalse: [External.PointerField])
				printVariable: aVARDESC
				type: (anInteger < 2 ifTrue: [self] ifFalse: [self pointerType])
				indirections: anInteger
				on: aPuttableStream
				in: aNamespace]
		ifNotNil: 
			[self assert: [anInteger == 0].
			External.StringField
				printArrayField: aVARDESC
				type: self
				on: aPuttableStream
				in: aNamespace]! !
!Core.String class categoriesFor: #arrayType!constants!private! !
!Core.String class categoriesFor: #arrayType:!constants!private! !
!Core.String class categoriesFor: #elementType:!constants!private! !
!Core.String class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!Core.String class categoriesFor: #printStructField:indirections:on:in:!private! !

!Core.Utf16String class methodsFor!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	anELEMDESC isOut
		ifTrue: 
			[super
				printMethodArgument: aString
				elemdesc: anELEMDESC
				indirections: anInteger
				on: aPuttableStream
				for: anAPIInfoAnalyzer]
		ifFalse: 
			[aPuttableStream
				nextPutAll: aString;
				space;
				nextPutAll: #asUtf16String]! !
!Core.Utf16String class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !

!External.Address class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^LPVOIDField! !
!External.Address class categoriesFor: #fieldType!constants!development!private! !

!External.ArrayField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	self assert: 
			["Instances of the receiver describe fields that are embedded arrays (not pointers to arrays)."
			anInteger == 0].
	self
		printArrayField: aVARDESC
		type: aClass
		on: aPuttableStream
		in: aNamespace! !
!External.ArrayField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.ArrayPointerField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	self assert: 
			["Instances of the receiver describe fields that are embedded fixed arrays (not pointers to array, and not conformant arrays)."
			anInteger <= 1].
	self
		printArrayField: aVARDESC
		type: aClass arrayType
		on: aPuttableStream
		in: aNamespace! !
!External.ArrayPointerField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.BOOL class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^BOOLField! !
!External.BOOL class categoriesFor: #fieldType!constants!private! !

!External.BOOLEAN class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in other
	structures."

	^BOOLEANField! !
!External.BOOLEAN class categoriesFor: #fieldType!constants!private! !

!External.BYTE class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^ExternalArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in other
	structures."

	^BYTEField! !
!External.BYTE class categoriesFor: #arrayType!constants!private! !
!External.BYTE class categoriesFor: #fieldType!constants!private! !

!External.DOUBLE class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^DOUBLEArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DOUBLEField! !
!External.DOUBLE class categoriesFor: #arrayType!constants!private! !
!External.DOUBLE class categoriesFor: #fieldType!constants!private! !

!External.DWORD class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^DWORDArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DWORDField! !
!External.DWORD class categoriesFor: #arrayType!constants!private! !
!External.DWORD class categoriesFor: #fieldType!constants!private! !

!External.DWORDBytes class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^DWORDField! !
!External.DWORDBytes class categoriesFor: #fieldType!constants!development!private! !

!External.DynamicLinkLibrary methodsFor!

DllRegisterServer
	<stdcall: hresult DllRegisterServer>
	^self invalidCall: _failureCode! !
!External.DynamicLinkLibrary categoriesFor: #DllRegisterServer!operations!private! !

!External.ExternalArray class methodsFor!

arrayType
	^self!

fieldType
	^ArrayField!

fieldType: aVARDESC indirections: anInteger
	"Private - Answer the <ExternalField> type to be used to represent a field described by the
	<VARDESC> argument based of the receiver's basic field type in structures with the given
	number of <integer> indirections."

	^anInteger > 1
		ifTrue: 
			["Represent ** (or more) as anon. indirection"
			LPVOIDField]
		ifFalse: [anInteger == 0 ifTrue: [self fieldType] ifFalse: [self pointerFieldType]]!

pointerFieldType
	^ArrayPointerField!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the array variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	(self fieldType: aVARDESC indirections: anInteger)
		printVariable: aVARDESC
		type: self
		indirections: anInteger
		on: aPuttableStream
		in: aNamespace! !
!External.ExternalArray class categoriesFor: #arrayType!constants!private! !
!External.ExternalArray class categoriesFor: #fieldType!constants!private! !
!External.ExternalArray class categoriesFor: #fieldType:indirections:!private! !
!External.ExternalArray class categoriesFor: #pointerFieldType!constants!private! !
!External.ExternalArray class categoriesFor: #printStructField:indirections:on:in:!private! !

!External.Field class methodsFor!

printArrayField: elementOrArrayClass length: sizeisObject on: aPuttableStream in: aNamespace
	aPuttableStream nextPut: $(.
	self
		printClassReference: self
		from: aNamespace
		on: aPuttableStream.
	aPuttableStream nextPutAll: ' type: '.
	self
		printClassReference: elementOrArrayClass
		from: aNamespace
		on: aPuttableStream.
	aPuttableStream
		nextPutAll: ' length: ';
		print: sizeisObject;
		nextPut: $)!

printArrayField: aVARDESC type: extClass on: aPuttableStream in: aNamespace
	aPuttableStream
		nextPut: $(;
		print: self;
		nextPutAll: ' type: '.
	self
		printClassReference: extClass
		from: aNamespace
		on: aPuttableStream.
	aVARDESC isConformant
		ifTrue: 
			[self
				printConformantArrayLength: aVARDESC
				on: aPuttableStream
				in: aNamespace]
		ifFalse: [self printFixedArrayLength: aVARDESC on: aPuttableStream].
	aPuttableStream nextPut: $)!

printConformantArrayLength: aVARDESC on: aPuttableStream in: aNamespace
	| sizeIs |
	sizeIs := Parser parseExpression: (aVARDESC customAttributes at: #size_is) value.
	sizeIs isVariable
		ifTrue: 
			["Simple size_is expression which names another field, e.g. size_is(cbBytes)."
			aPuttableStream
				nextPutAll: ' lengthField: ';
				print: sizeIs name asSymbol]
		ifFalse: 
			[(sizeIs isLiteralNode and: [sizeIs value isInteger])
				ifTrue: 
					["e.g. size_is(5) - redundant and should be a fixed array, but support it."
					aPuttableStream
						nextPutAll: ' length: ';
						print: sizeIs value]
				ifFalse: 
					["Complex size_is expression, e.g. size_is(cbBytes >> 1 - 1)"
					aPuttableStream nextPutAll: ' arrayLength: ('.
					self
						printClassReference: SizeIsArrayFieldLength
						from: aNamespace
						on: aPuttableStream.
					aPuttableStream
						space;
						display: #sizeIs:;
						space;
						print: sizeIs formattedCode;
						nextPut: $)]]!

printFixedArrayLength: aVARDESC on: aPuttableStream
	| arrayDesc |
	arrayDesc := aVARDESC tdesc arrayDesc.
	arrayDesc cDims > 1 ifTrue: [self warningMultiDimensionArray: aVARDESC].
	aPuttableStream
		nextPutAll: ' length: ';
		print: arrayDesc elementCount!

printTypedField: extClass on: aPuttableStream in: aNamespace
	aPuttableStream nextPut: $(.
	self
		printClassReference: self
		from: aNamespace
		on: aPuttableStream.
	aPuttableStream
		space;
		nextPutAll: #type:;
		space.
	self
		printClassReference: extClass
		from: aNamespace
		on: aPuttableStream.
	aPuttableStream nextPut: $)!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	self
		printClassReference: self
		from: aNamespace
		on: aPuttableStream.
	aPuttableStream nextPutAll: ' new'!

warningMultiDimensionArray: aVARDESC
	Warning
		signal: 'Multi-dimensioned byte array treated as single-dimensioned: ' , aVARDESC printString! !
!External.Field class categoriesFor: #printArrayField:length:on:in:!private! !
!External.Field class categoriesFor: #printArrayField:type:on:in:!private! !
!External.Field class categoriesFor: #printConformantArrayLength:on:in:!private! !
!External.Field class categoriesFor: #printFixedArrayLength:on:!private! !
!External.Field class categoriesFor: #printTypedField:on:in:!private! !
!External.Field class categoriesFor: #printVariable:type:indirections:on:in:!private! !
!External.Field class categoriesFor: #warningMultiDimensionArray:!private! !

!External.FLOAT class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^FLOATArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^FLOATField!

printDefaultValue: aVARIANT on: aPuttableStream 
	self assert: [aVARIANT vt == self vt].
	aVARIANT value printOn: aPuttableStream significantFigures: 8! !
!External.FLOAT class categoriesFor: #arrayType!constants!private! !
!External.FLOAT class categoriesFor: #fieldType!constants!private! !
!External.FLOAT class categoriesFor: #printDefaultValue:on:!helpers!private! !

!External.Handle class methodsFor!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [HandleArray] ifFalse: [PointerArray]!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^HANDLEField!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	anELEMDESC isIn
		ifTrue: 
			["If in or in-out then just the argument; no need to convert unless indirected"
			aPuttableStream nextPutAll: aString.
			anInteger > 0
				ifTrue: 
					[aPuttableStream
						space;
						display: #asExternalHandle]]
		ifFalse: 
			["If an output only argument, need a new instance of the receiver to buffer the result"
			anAPIInfoAnalyzer printClass: self on: aPuttableStream.
			aPuttableStream
				space;
				display: #new]! !
!External.Handle class categoriesFor: #arrayType:!constants!private! !
!External.Handle class categoriesFor: #fieldType!constants!development!private! !
!External.Handle class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !

!External.INT_PTR class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^INT_PTRArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^INT_PTRField! !
!External.INT_PTR class categoriesFor: #arrayType!constants!private! !
!External.INT_PTR class categoriesFor: #fieldType!constants!private! !

!External.IntegerBytes class methodsFor!

fieldType
	^self subclassResponsibility!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the array variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	"Implementation Note: Copy <ExternalStructure>'s implementation."

	(self fieldType: aVARDESC indirections: anInteger)
		printVariable: aVARDESC
		type: self
		indirections: anInteger
		on: aPuttableStream
		in: aNamespace! !
!External.IntegerBytes class categoriesFor: #fieldType!constants!development!private! !
!External.IntegerBytes class categoriesFor: #printStructField:indirections:on:in:!private! !

!External.POINT methodsFor!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(; print: self asPoint; nextPut: $)! !
!External.POINT categoriesFor: #printOn:!printing!public! !

!External.PointerArray class methodsFor!

fieldType
	^PointerArrayField!

pointerFieldType
	^PointerArrayPointerField! !
!External.PointerArray class categoriesFor: #fieldType!private! !
!External.PointerArray class categoriesFor: #pointerFieldType!private! !

!External.PointerArrayField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections.
	In this case the field must be a pointer to a fixed-length array, so we need to determine the length and element class by looking these up from the typeinfo."

	| arrayDesc elemIndirs elemclassdesc elemType |
	self assert: 
			["Instances of the receiver describe fields that are embedded fixed arrays
			 of pointers to structs (not pointers to arrays, and not conformant arrays)."
			aClass == PointerArray and: [anInteger == 0 and: [aVARDESC isConformant not]]].
	arrayDesc := aVARDESC tdesc arrayDesc.
	arrayDesc cDims > 1 ifTrue: [self warningMultiDimensionArray: aVARDESC].
	elemclassdesc := arrayDesc tdesc classDesc.
	elemType := elemclassdesc key.
	elemIndirs := elemclassdesc value.
	self assert: 
			["Can only describe arrays of pointers."
			elemIndirs == 1].
	self assert: [aVARDESC isStringField not].
	self
		printArrayField: (aVARDESC isStringField
				ifTrue: [elemType elementClass byteSize == 2 ifTrue: [Utf16String] ifFalse: [String]]
				ifFalse: [elemType])
		length: arrayDesc elementCount
		on: aPuttableStream
		in: aNamespace! !
!External.PointerArrayField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.PointerField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Generate a structure field definition message onto the specified <puttableStream> for the pointer-to-conformant-array field described by the <VARDESC>, aVARDESC, with the specified number of <integer> indirections."

	self
		printTypedField: aClass
		on: aPuttableStream
		in: aNamespace! !
!External.PointerField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.QWORD class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^QWORDField! !
!External.QWORD class categoriesFor: #fieldType!constants!private! !

!External.SBYTE class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^SBYTEArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SBYTEField! !
!External.SBYTE class categoriesFor: #arrayType!constants!private! !
!External.SBYTE class categoriesFor: #fieldType!constants!private! !

!External.SDWORD class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^SDWORDArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SDWORDField! !
!External.SDWORD class categoriesFor: #arrayType!constants!private! !
!External.SDWORD class categoriesFor: #fieldType!constants!private! !

!External.Structure class methodsFor!

arrayType
	"Private - Answer the <ExternalArray> class to be used to represent C arrays of the receiver's type.
	The generic <StructureArray> can actually handle most types, but this may be overridden
	for increased efficiency."

	^StructureArray!

arrayType: indirs
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type with the specified number of indirections."

	^indirs == 0 ifTrue: [self arrayType] ifFalse: [PointerArray]!

elementType: indirs
	"Private - Answer the <ExternalStructure> class to represent array elements of this 
	external type with the <integer> indirections, indirs."

	^indirs < 2 ifTrue: [self] ifFalse: [LPVOID]	"double-indirection"!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^StructureField!

fieldType: aVARDESC indirections: anInteger
	"Private - Answer the <ExternalField> type to be used to represent a field described by the
	<VARDESC> argument based of the receiver's basic field type in structures with the given
	number of <integer> indirections."

	^anInteger > 1
		ifTrue: 
			["Represent ** (or more) as anon. indirection"
			LPVOIDField]
		ifFalse: 
			[anInteger == 0
				ifTrue: 
					[self assert: 
							["Should not have arrived here for conformant embedded arrays"
							aVARDESC isConformant not].
					self fieldType]
				ifFalse: 
					["Its a pointer, but could be to an array"
					aVARDESC isConformant ifTrue: [self arrayType pointerFieldType] ifFalse: [self pointerFieldType]]]!

mustWrapOptionalArgument: anELEMDESC 
	^anELEMDESC indirections > 0 and: [anELEMDESC isOut not]!

printDefaultValue: aVARIANT on: aPuttableStream
	aVARIANT value displayOn: aPuttableStream!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	"Implementation Note: It does not appear to be possible to determine from the type library whether double indirected output arguments are arrays or not (the size_is information, for example, is lost). We therefore assume it is not an array. We do assume that the output will be allocated by the callee using CoTaskMemAlloc. Either of these assumptions may be false, in which case it may be necessary to manually write a high-level wrapper method (which calls the low-level wrapper which will have been emitted correctly regardless) following the documentation for the interface."

	anELEMDESC isOut
		ifTrue: 
			[| isIn |
			"If an output argument, need an instance of the receiver to buffer the result"
			isIn := anELEMDESC isIn.
			aPuttableStream nextPut: $(.
			anInteger > 1
				ifTrue: 
					["Assume Callee allocates block in task memory"
					Notification signal: 'Warning: Parameter ''' , aString , ''' of ' , anELEMDESC owner fullName
								, ' is doubly indirected output, wrapper will use COM Task Memory.'.
					isIn ifTrue: [aPuttableStream nextPut: $(].
					anAPIInfoAnalyzer printClass: self on: aPuttableStream.
					aPuttableStream
						space;
						display: #newBufferClass:;
						space.
					anAPIInfoAnalyzer printClass: COM.TaskMemory on: aPuttableStream.
					isIn ifTrue: [aPuttableStream nextPut: $)]]
				ifFalse: 
					[anAPIInfoAnalyzer printClass: self on: aPuttableStream.
					aPuttableStream
						space;
						display: #new].
			isIn
				ifTrue: 
					["If an in-out argument, need to call with value in the buffer"
					aPuttableStream
						space;
						display: #value:;
						space;
						nextPutAll: aString;
						nextPutAll: '; yourself'].
			aPuttableStream nextPut: $)]
		ifFalse: 
			["Input only argument - Default is to assume argument in correct form already"
			aPuttableStream nextPutAll: aString]!

printOptionalParameter: anELEMDESC on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Print a default parameter value for  the optional method parameter described by the <ELEMDESC> onto the <puttableStream>. If the parameter is passed by reference, then  the value must be wrapped into a structure. 	Note, however, that if it is an output parameter, then the wrapper method will already be wrapping the value, and so we don't want to do so again."

	| defaultValue |
	defaultValue := anELEMDESC defaultValue ifNil: [self unspecifiedParameterValue].
	(self mustWrapOptionalArgument: anELEMDESC)
		ifTrue: 
			[self
				printWrappedValue: defaultValue
				on: aPuttableStream
				for: anAPIInfoAnalyzer]
		ifFalse: [self printDefaultValue: defaultValue on: aPuttableStream]!

printStructField: aVARDESC indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the structure variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	(self fieldType: aVARDESC indirections: anInteger)
		printVariable: aVARDESC
		type: self
		indirections: anInteger
		on: aPuttableStream
		in: aNamespace!

printWrappedValue: aVARIANT on: aPuttableStream for: anAPIInfoAnalyzer
	aPuttableStream nextPut: $(.
	anAPIInfoAnalyzer printClass: self on: aPuttableStream.
	aPuttableStream
		space;
		display: #new;
		space;
		display: #value:;
		space.
	self printDefaultValue: aVARIANT on: aPuttableStream.
	aPuttableStream
		nextPutAll: '; ';
		display: #yourself;
		nextPut: $)!

unspecifiedParameterValue
	^COM.VARIANT new
		vt: self vt;
		yourself! !
!External.Structure class categoriesFor: #arrayType!constants!private! !
!External.Structure class categoriesFor: #arrayType:!constants!private! !
!External.Structure class categoriesFor: #elementType:!constants!private! !
!External.Structure class categoriesFor: #fieldType!constants!private! !
!External.Structure class categoriesFor: #fieldType:indirections:!private! !
!External.Structure class categoriesFor: #mustWrapOptionalArgument:!helpers!private! !
!External.Structure class categoriesFor: #printDefaultValue:on:!helpers!private! !
!External.Structure class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!External.Structure class categoriesFor: #printOptionalParameter:on:for:!helpers!private! !
!External.Structure class categoriesFor: #printStructField:indirections:on:in:!private! !
!External.Structure class categoriesFor: #printWrappedValue:on:for:!helpers!private! !
!External.Structure class categoriesFor: #unspecifiedParameterValue!helpers!private! !

!External.StructureArray class methodsFor!

fieldType
	^StructureArrayField!

pointerFieldType
	^StructureArrayPointerField! !
!External.StructureArray class categoriesFor: #fieldType!private! !
!External.StructureArray class categoriesFor: #pointerFieldType!private! !

!External.StructureArrayField class methodsFor!

printVariable: aVARDESC type: extClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	| arrayDesc elemclassdesc |
	self assert: 
			["Instances of the receiver describe fields that are embedded arrays (not pointers to arrays)."
			anInteger == 0].
	arrayDesc := aVARDESC tdesc arrayDesc.
	arrayDesc cDims > 1 ifTrue: [self warningMultiDimensionArray: aVARDESC].
	elemclassdesc := arrayDesc tdesc classDesc.
	self assert: 
			["Not expecting to be used for arrays of pointers."
			elemclassdesc value == 0].
	self
		printArrayField: aVARDESC
		type: elemclassdesc key
		on: aPuttableStream
		in: aNamespace! !
!External.StructureArrayField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.StructureArrayPointerField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Print a structure field definition message onto the <puttableStream> argument, for the variable described by the <VARDESC> argument, with the specified <integer> number of indirections."

	self assert: 
			["Instances of the receiver describe fields that are embedded fixed arrays (not pointers to array, and not conformant arrays)."
			anInteger == 1].
	self
		printArrayField: aVARDESC
		type: aClass
		on: aPuttableStream
		in: aNamespace! !
!External.StructureArrayPointerField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.StructureField class methodsFor!

printVariable: aVARDESC type: aClass indirections: anInteger on: aPuttableStream in: aNamespace
	"Private - Generate a structure field definition message onto the specified <puttableStream> for the pointer-to-conformant-array field described by the <VARDESC>, aVARDESC, with the specified number of <integer> indirections."

	self
		printTypedField: aClass
		on: aPuttableStream
		in: aNamespace! !
!External.StructureField class categoriesFor: #printVariable:type:indirections:on:in:!private! !

!External.SWORD class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^SWORDArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SWORDField! !
!External.SWORD class categoriesFor: #arrayType!constants!private! !
!External.SWORD class categoriesFor: #fieldType!constants!private! !

!External.UINT_PTR class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^UINT_PTRArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^UINT_PTRField! !
!External.UINT_PTR class categoriesFor: #arrayType!constants!private! !
!External.UINT_PTR class categoriesFor: #fieldType!constants!private! !

!External.UIntPtrBytes class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^UINT_PTRField! !
!External.UIntPtrBytes class categoriesFor: #fieldType!constants!development!private! !

!External.VOID class methodsFor!

arrayType
	"Private - Answer the <ExternalArray> class to be used to represent C arrays of the receiver's type."

	"Implementation Note: Embedded arrays of <VOID> are not valid, since no size is known,
	however where a field is a void* pointer to a conformant array, we assume it is pointing at
	bytes."

	^ExternalArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures. VOID is of course only valid when indirected."

	^self shouldNotImplement!

pointerFieldType
	"Answer the <ExternalField> class to represent pointers to this external type with the
	one indirection."

	^LPVOIDField! !
!External.VOID class categoriesFor: #arrayType!constants!private! !
!External.VOID class categoriesFor: #fieldType!constants!private! !
!External.VOID class categoriesFor: #pointerFieldType!constants!private! !

!External.WORD class methodsFor!

arrayType
	"Private - Answer the class of object (typically an <ExternalArray> subclass) to be used to 
	represent arrays of the receiver's field type in other structures."

	^WORDArray!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^WORDField! !
!External.WORD class categoriesFor: #arrayType!constants!private! !
!External.WORD class categoriesFor: #fieldType!constants!private! !

!OS.COM class methodsFor!

icon
	"Answers an Icon that can be used to represent this class, the emoji 🧪"

	^Interface icon! !
!OS.COM class categoriesFor: #icon!constants!public! !

!OS.COM.AbstractDispatchImplementation class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^IDispatch icon! !
!OS.COM.AbstractDispatchImplementation class categoriesFor: #icon!constants!public! !

!OS.COM.AbstractELEMDESC methodsFor!

printFieldsOn: aStream
	self isNull
		ifFalse: 
			[aStream
				display: #tdescElem;
				nextPutAll: '=';
				print: self tdesc;
				space].
	^super printFieldsOn: aStream! !
!OS.COM.AbstractELEMDESC categoriesFor: #printFieldsOn:!printing!private! !

!OS.COM.APIInfoAnalyzer methodsFor!

areWrappersRequired
	"Private - Answer whether a high-level wrappers are required in general."
	
	^(self generationFlags noMask: RawMethodsOnly)!

basicPrintType: aTYPEDESC on: aPuttableStream
	| type classDesc typeName |
	classDesc := aTYPEDESC classDesc.
	type := classDesc key.
	typeName := type typeName.
	"Built in types start with lowercase letters - there ought to be a better way to determine this"
	typeName first isLowerCase
		ifTrue: [aPuttableStream nextPutAll: typeName]
		ifFalse: [self printClass: type on: aPuttableStream].
	^classDesc!

compileMethodWrapper: aString
	self compileMethod: aString categories: {self autoGenCategoryName. 'methods'. 'public'}!

functionHasReturnValue: aFUNCDESC
	"Private - Answer whether or not the function described by the <FUNCDESC>, method,
	has a significant return value."

	^aFUNCDESC hasReturnValue!

generateMethod: aFUNCDESC wrapping: anAXMethodName
	"Private - Generate a high-level wrapper for the method described 
	by the <FUNCDESC> argument, calling the low-level wrapper
	method named by the <AXMethodName> argument. 
	The high-level wrapper returns the correct type of object as opposed 
	to an HRESULT code."

	| stream wrapperName |
	stream := String smalltalkWriteStream: 128.
	wrapperName := self
				printMethod: aFUNCDESC
				wrapping: anAXMethodName
				on: stream.
	wrapperName isNil ifFalse: [self compileMethodWrapper: stream contents].
	^wrapperName!

generateMethodWrappers
	"Private - Generate a method to wrap each of the functions in the type described by the receiver."

	^self subclassResponsibility!

generateMethodWrappers: aFUNCDESC
	| wrapit methodName |
	wrapit := self isMethodWrapperRequiredFor: aFUNCDESC.
	methodName := self generateRawMethod: aFUNCDESC
				categories: (self instanceMethodCategories: wrapit).
	wrapit ifTrue: [methodName := self generateMethod: aFUNCDESC wrapping: methodName].
	^methodName!

generateRawMethod: aFUNCDESC categories: aCollection
	"Private - Generate a wrapper for the method described by the <FUNCDESC> argument..
	Answer an <AXMethodName> containing selector keyword and argument pair information 
	which can be used to construct a call to the method."

	| methodName |
	methodName := self rawMethodNameForFunction: aFUNCDESC.
	(self canGenerateMethodNamed: methodName)
		ifTrue: 
			[| target |
			target := String smalltalkWriteStream: 512.
			methodName printSignatureOn: target.
			target cr.
			self
				printRawMethodComment: aFUNCDESC
				on: target
				isPrivate: (aCollection includes: 'private').
			self
				printRawMethodBody: aFUNCDESC
				name: methodName
				on: target.
			self compileRawMethod: target contents categories: aCollection].
	^methodName!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	| class |
	class := self generateClassDefinition: aVariableBinding imports: #().
	self guid notNull ifTrue: [class guid: self guid].
	^class!

idlAttributesOfFunc: aFUNCDESC 
	"Private - Answer a <sequencedReadableCollection> of IDL attribute strings for the receiver."

	^aFUNCDESC idlAttributesAndId!

instanceMethodCategories: aBoolean
	"Private - Answer a collection of categories with which instance side methods are to be associated. The <boolean>
	argument indicates whether the categories are for a public or private method."

	^self subclassResponsibility!

isDefaultedWrapperRequiredFor: aFUNCDESC
	"Private - Answer whether a high-level wrapper that defaults all optional parameters
	of the function described by the <FUNCDESC> argument should be generated ."

	^self areWrappersRequired and: [aFUNCDESC hasOptionalInputs]!

isMethodWrapperRequiredFor: aFUNCDESC
	"Private - Answer whether a high-level wrapper for the function described by the 
	<FUNCDESC> argument should be generated."

	^self areWrappersRequired!

methodCommentDescription
	^self subclassResponsibility!

mungeSelectorKeywords: aSequencedReadableCollection forMember: aFUNCDESC 
	^self reinventBadSelector: aSequencedReadableCollection member: aFUNCDESC!

namespaceImports
	"Private - Answer a <collection> of the shared pool names to be used when 
	defining a wrapper class for the receiver."

	^self typeLib sharedPoolNames!

printCommentPrefixOn: aPuttableStream isPrivate: aBoolean
	aPuttableStream
		tab;
		nextPut: $".
	aBoolean ifTrue: [aPuttableStream nextPutAll: 'Private - ']!

printFunctionPrototype: aFUNCDESC on: target indent: tabs
	"Private - Generate an IDL-style prototype for the method described by the <FUNCDESC>, funcDesc,
	on the <puttableStream>, target. This is useful for documentatary purposes in the method comment."

	target tab: tabs.
	self
		printIDLDecl: ''
		type: aFUNCDESC tdescFunc
		on: target.
	target space.
	aFUNCDESC isDispatchable
		ifFalse: 
			[target
				nextPutAll: aFUNCDESC idlCallingConvention;
				space].
	target
		nextPutAll: aFUNCDESC name;
		nextPut: $(.
	aFUNCDESC argumentCount > 0
		ifTrue: 
			[| params types |
			params := aFUNCDESC argumentNames.
			types := aFUNCDESC arguments.
			(1 to: params size) do: 
					[:i |
					| name type |
					type := types at: i.
					target crtab: tabs + 1.
					self
						printIDLAttributes: type idlAttributes
						on: target
						indent: -1.
					name := params at: i.
					name isEmpty ifTrue: [name := 'arg' , i printString].
					self
						printIDLDecl: name
						type: type tdesc
						on: target]
				separatedBy: [target nextPut: $,]].
	target nextPutAll: ');'!

printFunctionPrototypeComment: aFUNCDESC on: aPuttableStream
	| comment |
	comment := String smalltalkWriteStream: 128.
	self
		printFunctionPrototype: aFUNCDESC
		on: comment
		indent: 2.
	self emitComment: comment contents on: aPuttableStream!

printIDLForFunction: aFUNCDESC on: aPuttableStream indent: anInteger 
	"Private - Print an IDL description for <FUNCDESC>, function, assumed to be 
	a member of the receiver, on the <puttableStream>, target."

	self 
		printIDLAttributes: (self idlAttributesOfFunc: aFUNCDESC)
		on: aPuttableStream
		indent: -1.
	aPuttableStream cr.
	self 
		printFunctionPrototype: aFUNCDESC
		on: aPuttableStream
		indent: anInteger!

printMethod: aFUNCDESC wrapping: anAXMethodName on: puttableStream
	"Private -Print a high-level wrapper for the function described 
	by the <FUNCDESC> argument onto the <puttableStream> argument.
	Answer an <AXMethodName> naming the printed method, or nil if 
	none should be generated."

	^self subclassResponsibility!

printMethodCommentPostamble: member on: aPuttableStream
	"Private - Close an auto-geneated method comment."

	self printAutoGenMethodPostambleOn: aPuttableStream!

printMethodCommentPreamble: aFUNCDESC on: aPuttableStream isPrivate: aBoolean
	self printCommentPrefixOn: aPuttableStream isPrivate: aBoolean.
	((self functionHasReturnValue: aFUNCDESC) and: [aFUNCDESC hasMultipleOutputs not])
		ifTrue: 
			[aPuttableStream nextPutAll: 'Answer the <'.
			self basicPrintType: aFUNCDESC tdesc on: aPuttableStream.
			aPuttableStream nextPutAll: '> result of invoking the ']
		ifFalse: [aPuttableStream nextPutAll: 'Invoke the '].
	aPuttableStream
		nextPutAll: aFUNCDESC name;
		nextPutAll: '() ';
		nextPutAll: self methodCommentDescription;
		nextPut: $.!

printRawMethodBody: aFUNCDESC name: anAXMethodName on: aPuttableStream
	"Private - Print an external function call for the member described by the <FUNCDESC> first argument, whose selector and arguments are as described in the <AXMethodName> 2nd argument,  onto the <puttableStream> 3rd argument."

	^self subclassResponsibility!

printRawMethodComment: aFUNCDESC on: aPuttableStream isPrivate: aBoolean
	self 
		printRawMethodCommentPreamble: aFUNCDESC
		on: aPuttableStream
		isPrivate: aBoolean.
	self printRawMethodCommentHelp: aFUNCDESC on: aPuttableStream.
	self printMethodCommentPostamble: aFUNCDESC on: aPuttableStream!

printRawMethodCommentHelp: aFUNCDESC on: aPuttableStream 
	self printHelpstringComment: aFUNCDESC on: aPuttableStream.
	aPuttableStream
		cr;
		cr.
	self printFunctionPrototypeComment: aFUNCDESC on: aPuttableStream!

printRawMethodCommentPreamble: aFUNCDESC on: aPuttableStream isPrivate: aBoolean
	self printCommentPrefixOn: aPuttableStream isPrivate: aBoolean.
	aPuttableStream
		nextPutAll: 'Invoke the ';
		nextPutAll: aFUNCDESC name;
		nextPutAll: '() ';
		nextPutAll: self methodCommentDescription;
		nextPut: $.!

printType: aTYPEDESC on: aPuttableStream
	self basicPrintType: aTYPEDESC on: aPuttableStream.
	aTYPEDESC classDesc value timesRepeat: [aPuttableStream nextPut: $*]!

proputrefWrapperPrefix
	"Answer a <String> to be prepended to high-level wrapper methods generated to
	wrap propputref functions. This is needed to distinguish these methods from normal
	propputs, as in some cases a property may have both a propput and a propputref."

	^'set'!

rawMethodNameForFunction: aFUNCDESC
	"Private - Answer an <AXMethodName> describing the selector keywords
	and argument names to be used for a raw wrapper method for the function
	described by the <FUNCDESC> argument."

	| name |
	name := aFUNCDESC methodName.
	^Tools.AXMethodName
		keywords: (self mungeSelectorKeywords: name keywords forMember: aFUNCDESC)
		argumentNames: name argumentNames
		indices: name indices!

reinventBadSelector: aSequencedReadableCollection member: aMemberDesc
	"Private - If the selector constructed from the keywords in the <sequencedReadableCollection> argument would cause a clash with a reserved selector, then reinvent it. Answer a  <sequencedReadableCollection> of keywords that combing into an unused selector."

	"Implementation Note: The algorithm is basically to append underscore characters as a suffix to the primary keyword until a non-reserved selector is found. As ST methods typically don't tend to have underscores in them, this should be sucessful first time around. Note that this algorithm doesn't work for binary selectors, but that shouldn't be a problem as operators cannot be used as method/property names."

	| selector reserved primary |
	self assert: [aSequencedReadableCollection notEmpty].
	"Because most selectors only have one or two components, it is quicker to string concatenate than use a stream"
	selector := primary := aSequencedReadableCollection first.
	aSequencedReadableCollection from: 2 do: [:each | selector := selector , each].
	selector := selector asSymbol.
	reserved := self reservedSelectors.
	^(reserved includes: selector)
		ifTrue: 
			[| tail unique |
			primary := selector upTo: $:.
			tail := selector copyFrom: primary size + 1.
			
			[primary := primary , '_'.
			unique := (primary , tail) asSymbol.
			reserved includes: unique]
					whileTrue.
			(tail notEmpty and: [tail first = $:]) ifTrue: [primary := primary , ':'].
			Notification signal: ('Warning: Selector <1p> for <2s> is reserved, using <3p> instead'
						expandMacrosWith: selector
						with: aMemberDesc fullName
						with: unique).
			{primary} , aSequencedReadableCollection allButFirst]
		ifFalse: [aSequencedReadableCollection]!

selectorForFunction: aFUNCDESC
	"Private - Answer a suitable Smalltalk selector for the method of the receiver's
	interface described by the <FUNCDESC> argument."

	^(self rawMethodNameForFunction: aFUNCDESC) selector! !
!OS.COM.APIInfoAnalyzer categoriesFor: #areWrappersRequired!private!testing! !
!OS.COM.APIInfoAnalyzer categoriesFor: #basicPrintType:on:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #compileMethodWrapper:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #functionHasReturnValue:!helpers!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #generateMethod:wrapping:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #generateMethodWrappers!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #generateMethodWrappers:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #generateRawMethod:categories:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #idlAttributesOfFunc:!printing-IDL!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #instanceMethodCategories:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #isDefaultedWrapperRequiredFor:!private!testing! !
!OS.COM.APIInfoAnalyzer categoriesFor: #isMethodWrapperRequiredFor:!private!testing! !
!OS.COM.APIInfoAnalyzer categoriesFor: #methodCommentDescription!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #mungeSelectorKeywords:forMember:!helpers!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #namespaceImports!constants!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printCommentPrefixOn:isPrivate:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printFunctionPrototype:on:indent:!printing!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printFunctionPrototypeComment:on:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printIDLForFunction:on:indent:!printing-IDL!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printMethod:wrapping:on:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printMethodCommentPostamble:on:!printing!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printMethodCommentPreamble:on:isPrivate:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printRawMethodBody:name:on:!printing!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printRawMethodComment:on:isPrivate:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printRawMethodCommentHelp:on:!printing!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printRawMethodCommentPreamble:on:isPrivate:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #printType:on:!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #proputrefWrapperPrefix!constants!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #rawMethodNameForFunction:!helpers!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #reinventBadSelector:member:!helpers!private! !
!OS.COM.APIInfoAnalyzer categoriesFor: #selectorForFunction:!helpers!private! !

!OS.COM.BSTR class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^(aspectClass string: aSymbol) beImmutable!

printDefaultValue: aVARIANT on: aPuttableStream 
	self assert: [aVARIANT vartype == self vt].
	aPuttableStream print: aVARIANT bstr!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anApiInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	"Implementation Note: No memory management problems here - BSTR takes care of that."

	anELEMDESC isIn
		ifTrue: 
			["If in or in-out then just the argument "

			"We don't convert it, unless BSTR* , because the VM can do it faster"
			aPuttableStream nextPutAll: aString.
			anInteger > 0
				ifTrue: 
					[aPuttableStream
						space;
						display: #asBSTR]]
		ifFalse: 
			["If an output only argument, need a new instance of the receiver to buffer the result"
			anApiInfoAnalyzer printClass: self on: aPuttableStream.
			aPuttableStream
				space;
				display: #new]!

printOptionalParameter: anELEMDESC on: aPuttableStream for: anAPIInfoAnalyzer
	anELEMDESC hasDefaultValue
		ifTrue: 
			[self printDefaultValue: anELEMDESC defaultValue on: aPuttableStream.
			(anELEMDESC indirections > 0 and: [anELEMDESC isOut not])
				ifTrue: 
					[aPuttableStream
						space;
						display: #asBSTR]]
		ifFalse: [aPuttableStream print: nil]!

unspecifiedParameterValue
	^VARIANT new
		vt: self vt;
		yourself! !
!OS.COM.BSTR class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!OS.COM.BSTR class categoriesFor: #printDefaultValue:on:!helpers!private! !
!OS.COM.BSTR class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!OS.COM.BSTR class categoriesFor: #printOptionalParameter:on:for:!helpers!private! !
!OS.COM.BSTR class categoriesFor: #unspecifiedParameterValue!helpers!private! !

!OS.COM.CountedArray class methodsFor!

fieldType
	^StructureField!

pointerFieldType
	^PointerField! !
!OS.COM.CountedArray class categoriesFor: #fieldType!constants!private! !
!OS.COM.CountedArray class categoriesFor: #pointerFieldType!constants!private! !

!OS.COM.CURRENCY methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: (self isNull ifTrue: ['NULL'] ifFalse: [self value]);
		nextPut: $)! !
!OS.COM.CURRENCY categoriesFor: #printOn:!printing!public! !

!OS.COM.CURRENCY class methodsFor!

mustWrapOptionalArgument: anELEMDESC 
	^anELEMDESC isOut not!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass number: aSymbol! !
!OS.COM.CURRENCY class categoriesFor: #mustWrapOptionalArgument:!private!testing! !
!OS.COM.CURRENCY class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!OS.COM.CUSTDATAITEM methodsFor!

printIDLOn: target
	"Private - Print the IDL representation of the custom data attribute described by the receiver
	onto the <puttableStream>, target."
	
	target
		nextPutAll: 'custom(';
		nextPutAll: self guid idlString;
		nextPutAll: ', '.
	self varValue printIDLOn: target.
	target nextPut: $).
! !
!OS.COM.CUSTDATAITEM categoriesFor: #printIDLOn:!printing-IDL!private! !

!OS.COM.DATE class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass date: aSymbol!

printDefaultValue: aVARIANT on: aPuttableStream
	self assert: [aVARIANT vt == VT_DATE or: [aVARIANT vt == VT_R8]].
	aVARIANT dblVal displayOn: aPuttableStream! !
!OS.COM.DATE class categoriesFor: #newInstanceAspect:class:!adapters!private! !
!OS.COM.DATE class categoriesFor: #printDefaultValue:on:!helpers!private! !

!OS.COM.DECIMAL methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(;
		display: (self isNull ifTrue: ['NULL'] ifFalse: [self value]);
		nextPut: $)! !
!OS.COM.DECIMAL categoriesFor: #printOn:!printing!public! !

!OS.COM.ELEMDESC methodsFor!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of flag names (IDL attributes)
	from the receiver."

	^self paramdesc idlAttributes! !
!OS.COM.ELEMDESC categoriesFor: #idlAttributes!printing-IDL!private! !

!OS.COM.FUNCDESC methodsFor!

buildMethodName
	| monikers keywords argc argumentNames funcName indices forceLower |
	monikers := self names.
	argc := monikers size - 1.
	funcName := monikers first.
	self assert: [funcName notEmpty].
	forceLower := self analyzer forceLowercaseIdentifiers.
	argc > 0
		ifFalse: 
			["Zero arguments"
			indices := argumentNames := #().
			keywords := {funcName}]
		ifTrue: 
			[| firstArg j |
			"First argument must be treated differently"
			keywords := Array new: argc.
			argumentNames := Array new: argc.
			indices := 1 to: argc.
			firstArg := monikers second.
			keywords at: 1 put: funcName , ':'.
			argumentNames at: 1
				put: (firstArg isEmpty ifTrue: ['arg1'] ifFalse: [self argumentNameFor: firstArg]).
			j := 2.
			monikers from: 3
				do: 
					[:each |
					each isEmpty
						ifTrue: 
							[keywords at: j put: '_:'.
							argumentNames at: j put: 'arg' , j printString]
						ifFalse: 
							[| param |
							param := self argumentNameFor: each.
							keywords at: j put: (forceLower ifTrue: [param] ifFalse: [each]) , ':'.
							argumentNames at: j put: param].
					j := j + 1].
			self reinventBadVarNames: argumentNames].
	^Tools.AXMethodName
		keywords: keywords
		argumentNames: argumentNames
		indices: indices!

displayOn: aPuttable
	"Append to the <puttableStream> first argument a String whose characters are a representation of the receiver that an end-user might want to see."

	aPuttable
		nextPutAll: self name;
		nextPut: $(.
	self argumentNames do: [:n | aPuttable nextPutAll: n]
		separatedBy: 
			[aPuttable
				nextPut: $,;
				space].
	aPuttable nextPut: $)!

generate
	self analyzer generateMethodWrappers: self!

hasAnswer
	^self isPropSet not and: [self hasReturnValue]!

hasMultipleOutputs
	"Private - Answer whether the function described by the receiver has multiple output
	arguments (well designed functions usually don't, but unfortunately one can find 
	many that do)."

	^self outputIndices size > 1!

hasOptionalInputs
	"Private - Answer whether the receiver has optional input arguments."

	^self arguments anySatisfy: [:each | each isOptional and: [each isIn]]!

hasReturnValue
	"Answer whether the receiver has a non-void return type."

	^self tdesc vt ~= VT_VOID!

isInspectable
	"Answer whether the receiver is describing a 'browsable' property that is not 'restricted'
	and therefore suitable for display in inspectors, etc."

	^self isMethod not and: [super isInspectable]!

isValueSetter
	^self isValueProperty and: [self isPropSet]!

methodName
	"Private - Answer an <AXMethodName> describing a method with
	suitable symbolic keywords and argument names to wrap the function
	described by the receiver."

	methodName isNil ifTrue: [methodName := self buildMethodName].
	^methodName!

printIDLOn: target indent: tabs
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self analyzer printIDLForFunction: self on: target indent: tabs!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self displayOn: aStream.
	aStream nextPut: $)!

reinventBadVarNames: anOrderedCollection
	"Private - Reinvent any bad variable names in the keyword-and-argument-name
	argument, wordsAndArgs. Answer the squeaky clean result."

	| badNames |
	badNames := (Set withAll: self analyzer programObject allInstVarNames)
				addAll: #('self' 'super' 'nil' 'true' 'false' 'thisContext');
				addAll: #('answer' '_' 'outputs');
				yourself.
	anOrderedCollection keysAndValuesDo: 
			[:i :each |
			| suffix arg |
			suffix := 0.
			arg := each.
			[badNames includes: arg] whileTrue: 
					["Invent a suitable non-clashing name by just adding a digit on the end"
					suffix := suffix + 1.
					arg := each , suffix printString].
			anOrderedCollection at: i put: arg.
			"We obviously can't use a duplicate argument name"
			badNames add: arg].
	^anOrderedCollection! !
!OS.COM.FUNCDESC categoriesFor: #buildMethodName!private! !
!OS.COM.FUNCDESC categoriesFor: #displayOn:!printing!public! !
!OS.COM.FUNCDESC categoriesFor: #generate!private! !
!OS.COM.FUNCDESC categoriesFor: #hasAnswer!private! !
!OS.COM.FUNCDESC categoriesFor: #hasMultipleOutputs!private!testing! !
!OS.COM.FUNCDESC categoriesFor: #hasOptionalInputs!accessing!private! !
!OS.COM.FUNCDESC categoriesFor: #hasReturnValue!public!testing! !
!OS.COM.FUNCDESC categoriesFor: #isInspectable!public!testing! !
!OS.COM.FUNCDESC categoriesFor: #isValueSetter!private! !
!OS.COM.FUNCDESC categoriesFor: #methodName!accessing!private! !
!OS.COM.FUNCDESC categoriesFor: #printIDLOn:indent:!printing-IDL!public! !
!OS.COM.FUNCDESC categoriesFor: #printOn:!printing!public! !
!OS.COM.FUNCDESC categoriesFor: #reinventBadVarNames:!helpers!private! !

!OS.COM.IDispatch methodsFor!

alternateInspectorClass
	"Answer the class of inspector to be used when the user requests to inspect
    	the receiver with the Shift key held down."

	^Tools.AXInspector!

aspectDisplayOn: aStream
	"Private - Append a single-line textual representatin of the receiver to the <puttableStream>
  	argument in a form that a user viewing the receiver as the value of a published aspect would 
  	like to see it. Typically we use #displayOn: but some classes of object can use alternate display 
  	formats.
  	N.B. This is a development time only method that supports the PublishedAspectInspector."

	self isNull 
		ifTrue: 
			[aStream
				nextPutAll: 'a null ';
				display: self class name]
		ifFalse: [self basicPrintOn: aStream]!

debugPrintOn: aStream
	"Implementation Note: Since #value is used by #printOn:, we implement this to 
	allow us to debug #value, otherwise setting a breakpoint in #value results in a
	meltdown."

	self isNull
		ifTrue: 
			[aStream
				nextPutAll: 'a null ';
				print: self class]
		ifFalse: [aStream basicPrint: self]!

printOn: aStream
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self printValueOn: aStream.
	aStream nextPut: $)!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by the receiver."

	| aspects |
	aspects := super publishedAspects.
	self isNull 
		ifFalse: 
			[(self typeInfoIfNone: []) ifNotNil: [:ti | ti buildPublishedAspects: aspects forObject: self]].
	^aspects! !
!OS.COM.IDispatch categoriesFor: #alternateInspectorClass!constants!public! !
!OS.COM.IDispatch categoriesFor: #aspectDisplayOn:!private! !
!OS.COM.IDispatch categoriesFor: #debugPrintOn:!printing!public! !
!OS.COM.IDispatch categoriesFor: #printOn:!printing!public! !
!OS.COM.IDispatch categoriesFor: #publishedAspects!constants!public! !

!OS.COM.IDispatch class methodsFor!

example1
	"
		IDispatch example1
	"

	| pdisp |
	pdisp := IDispatch createObject: 'Internet.HHCtrl.1'.
	"Fire off a method invocation via #doesNotUnderstand"
	pdisp
		TextPopup: 'How about a little popup help'
		_: 'Microsoft Sans Serif,8,,italic'
		_: 2
		_: 2
		_: -1
		_: -1	"Font face,point size,char set,format options"	"Default foreground colour"	"Default background colour"!

example2
	"The Microsoft Direct Text-to-Speech control (if you have it installed).
		IDispatch example2
	"

	| d |
	"d := IDispatch createObject: 'DirectSS.DirectSS.1'."
	d := IDispatch onCLSID: (CLSID fromString: '{EEE78591-FE22-11D0-8BEF-0060081841DE}').
	d Speak: 'Oops, I nearly forgot'.
	d LexiconDlg: UI.View activeHandle asInteger _: 'Dolphin'!

example3
	"Simple automation of Microsoft Word
		IDispatch example3
	This uses the object model first introduced with Word 97, which is recommended in preference to the older
	Word.Basic automation interface - it is at least an object model, and if desired the interfaces can be generated,
	although be warned that the result may be a number of sizeable packages.
	"

	| word docs newDoc |
	word := IDispatch createObject: 'Word.Application'.
	docs := word getProperty: 'Documents'.
	newDoc := docs invoke: 'Add'.
	"Alternatively, can do all the above by creating an instance of 'Word.Document'"
	"newDoc := IDispatch createObject: 'Word.Document'. word := newDoc getProperty: 'Application'"

	"Add some text"
	(word getProperty: 'Selection') invoke: 'TypeText' with: 'This is some text.'.

	"Save the document and close it"
	(word getProperty: 'ActiveDocument') invoke: 'SaveAs' with: '\mydoc.doc'.
	newDoc invoke: 'Close'.

	"Re-open our handywork and make it visible"
	docs invoke: 'Open' with: '\mydoc.doc'.
	word setProperty: 'Visible' value: true.

	"Quit Word"
	word invoke: 'Quit'.

	"Tidy"
	word := docs := newDoc := nil!

example4
	"Another more complex example automation of Microsoft Word based on a sample in the MSDN article Q198508
		IDispatch example4
	Like example3 this uses the object model first introduced with Word 97, which is recommended in preference to the older
	Word.Basic automation interface - it is at least an object model, and if desired the interfaces can be generated,
	although be warned that the result may be a number of sizeable packages.
	"

	| word doc futuredate shapes selection |
	word := IDispatch createObject: 'Word.Application'.
	word setProperty: 'Visible' value: true.
	futuredate := Date today addDays: 14.

	"Create a new document"
	doc := (word getProperty: 'Documents') invoke: 'Add'.

	"Add a picture - the Dolphin night splash"
	shapes := doc getProperty: 'Shapes'.
	shapes invoke: 'AddPicture'
		with: (FileLocator installRelative localFileSpecFor: 'Resources\Dolphin1.jpg').

	"Make the new pic into the active selection"
	(shapes invoke: 'Item' with: 'Picture 2') invoke: 'Select'.
	selection := word getProperty: 'Selection'.
	(selection getProperty: 'ShapeRange')
		setProperty: 'RelativeHorizontalPosition' value: 2;
		setProperty: 'RelativeVerticalPosition' value: 0;
		setProperty: 'Left' value: 4.2 * 72;
		setProperty: 'Top' value: 0;
		setProperty: 'LockAnchor' value: true.	"Move 4.2 inches x 72 points/inch"
	selection
		invoke: 'MoveRight';
		invoke: 'InsertParagraphAfter';
		invoke: 'MoveDown'.
	(selection getProperty: 'Font')
		setProperty: 'Name' value: 'Arial';
		setProperty: 'Bold' value: true;
		setProperty: 'Size' value: 8.
	selection
		invoke: 'InsertDateTime'
		with: 'dddd, MMMM dd, yyyy'
		with: 1.
	(selection getProperty: 'ParagraphFormat') setProperty: 'Alignment' value: 1.	"Center date"
	selection
		invoke: 'InsertParagraphAfter';
		invoke: 'MoveDown'.
	(selection getProperty: 'ParagraphFormat') setProperty: 'Alignment' value: 3.	"Justify"
	selection
		invoke: 'InsertParagraphAfter';
		invoke: 'MoveDown';
		invoke: 'InsertAfter' with: 'Dear ';
		invoke: 'MoveRight'.
	(selection getProperty: 'Fields')
		invoke: 'Add'
		with: (selection getProperty: 'Range')
		with: -1
		with: 'author'.

	"Add a bit of text - in practice one would probably build it up in a stream and insert en-masse
	 rather than like this."
	selection
		invoke: 'MoveRight';
		invoke: 'InsertAfter' with: ':';
		invoke: 'InsertParagraphAfter';
		invoke: 'InsertParagraphAfter';
		invoke: 'MoveDown'.
	selection
		invoke: 'InsertAfter' with: 'This letter is to inform you that ';
		invoke: 'InsertAfter' with: 'you have been selected as the ';
		invoke: 'InsertAfter' with: 'grand prize winner in our contest. ';
		invoke: 'InsertAfter' with: 'To claim your prize, please complete ';
		invoke: 'InsertAfter' with: 'the entry form and return it no later than ';
		invoke: 'InsertAfter' with: futuredate;
		invoke: 'InsertAfter' with: '.'.
	selection
		invoke: 'InsertParagraphAfter';
		invoke: 'InsertParagraphAfter';
		invoke: 'InsertAfter' with: 'If we have not received your entry within ';
		invoke: 'InsertAfter' with: 'fourteen days, that is, on or before ';
		invoke: 'InsertAfter' with: futuredate monthName;
		invoke: 'InsertAfter' with: ' ';
		invoke: 'InsertAfter' with: futuredate dayOfMonth;
		invoke: 'InsertAfter' with: ', ';
		invoke: 'InsertAfter' with: futuredate year;
		invoke: 'InsertAfter' with: ', we will remove your name from the ';
		invoke: 'InsertAfter' with: 'list of eligible winners.'.
	selection
		invoke: 'InsertParagraphAfter';
		invoke: 'InsertParagraphAfter';
		invoke: 'InsertAfter' with: 'Thank you,'.
	selection
		invoke: 'InsertParagraphAfter';
		invoke: 'MoveRight';
		invoke: 'InsertAfter' with: 'The Prize Selection Committee'.
	(selection getProperty: 'Font')
		setProperty: 'Name' value: 'Lucida Handwriting';
		setProperty: 'Bold' value: true.
	selection invoke: 'MoveRight'.
	word invoke: 'Activate'.
	(Delay forSeconds: 3) wait.

	"Quit without prompt"
	word invoke: 'Quit' with: 0!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon! !
!OS.COM.IDispatch class categoriesFor: #example1!examples!public! !
!OS.COM.IDispatch class categoriesFor: #example2!examples!public! !
!OS.COM.IDispatch class categoriesFor: #example3!examples!public! !
!OS.COM.IDispatch class categoriesFor: #example4!examples!public! !
!OS.COM.IDispatch class categoriesFor: #icon!constants!public! !

!OS.COM.Interface class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^##(self) defaultIcon!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	"Implementation Note: We never need to use COM Task Memory for interface pointers, as they are pointers and the memory is managed by ref. counting (i.e. the size is a known 32-bits)."

	anELEMDESC isIn
		ifTrue: 
			["If in or in-out then just pass the object as is (already a reference)"
			aPuttableStream nextPutAll: aString]
		ifFalse: 
			["If an output only argument, need an instance of the receiver to buffer the result"
			self assert: [anInteger == 2	"[out] interface pointers must use double indirection"].
			anAPIInfoAnalyzer printClass: self on: aPuttableStream.
			aPuttableStream
				space;
				display: #newPointer]!

printOptionalParameter: anELEMDESC on: aPuttableStream for: anAPIInfoAnalyzer
	(anELEMDESC hasDefaultValue ifTrue: [anELEMDESC defaultValue value]) displayOn: aPuttableStream! !
!OS.COM.Interface class categoriesFor: #icon!constants!public! !
!OS.COM.Interface class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!OS.COM.Interface class categoriesFor: #printOptionalParameter:on:for:!helpers!private! !

!OS.COM.InterfaceTypeAnalyzer methodsFor!

areWrappersRequired
	"Private - Answer whether a high-level wrappers are required in general.
	We don't want to generate wrappers for source (event sink) interfaces, as we implement these ourselves rather than call them."

	^self isSource not!

autoGenPropertiesCategories
	"Private - Answer the special method categories for auto-generated property accessors in the receivers wrapper class."

	^{self autoGenCategoryName. 'properties'. 'public'}!

buildMethodName: aFUNCDESC defaultOptionals: aBoolean
	"Private - Answer a high-level wrapper method name for the function described by the <FUNCDESC> argument."

	| args methodName argc outOnly keywords argumentNames optional indices |
	methodName := aFUNCDESC methodName.
	args := aFUNCDESC arguments.
	"Output only (and, conditionally, optional) arguments are excluded from the signature"
	outOnly := aFUNCDESC outputIndices reject: [:i | (args at: i) isIn].
	optional := aBoolean ifTrue: [aFUNCDESC optionalInputs] ifFalse: [#()].
	argc := methodName argumentCount - outOnly size - optional size.
	argc == 0
		ifTrue: 
			[self assert: [aFUNCDESC isPropSet not].
			"No args, or output/return value was the only argument, so we can use a unary selector"
			keywords := self reinventBadSelector: {self identifierFrom: aFUNCDESC name} member: aFUNCDESC.
			indices := argumentNames := #()]
		ifFalse: 
			[| keyword j rawKeywords rawArguments |
			"The first keyword must be handled specially - it must be named after the actual function, even
			if the first argument is output only."
			keywords := Array new: argc.
			argumentNames := Array new: argc.
			indices := Array new: argc.
			rawKeywords := methodName keywords.
			rawArguments := methodName argumentNames.
			keyword := self identifierFrom: rawKeywords first.
			aFUNCDESC isPropPutRef ifTrue: [keyword := self proputrefWrapperPrefix , keyword capitalized].
			j := 1.
			1 to: rawKeywords size
				do: 
					[:each |
					((outOnly includes: each) or: [optional includes: each])
						ifFalse: 
							[j == 1 ifFalse: [keyword := self identifierFrom: (rawKeywords at: each)].
							keywords at: j put: keyword.
							argumentNames at: j put: (rawArguments at: each).
							indices at: j put: each.
							j := j + 1]].

			"Now get a unique primary keyword which doesn't clash with one of the reserved selectors"
			keywords := self reinventBadSelector: keywords member: aFUNCDESC].
	^Tools.AXMethodName
		keywords: keywords
		argumentNames: argumentNames
		indices: indices!

buildPublishedAspects: aLookupTable forObject: anIUnknown
	| ppb |
	self isRestricted ifTrue: [^self].
	self superInterface
		ifNotNil: [:supertype | supertype buildPublishedAspects: aLookupTable forObject: anIUnknown].
	ppb := anIUnknown queryInterface: IPerPropertyBrowsing.
	self variables do: 
			[:each |
			each isInspectable
				ifTrue: 
					[| aspect |
					aspect := self newAspectForMember: each ppb: ppb.
					each isReadOnly ifTrue: [aspect beReadOnly].
					aLookupTable add: aspect]].
	self methods do: 
			[:each |
			each isInspectable
				ifTrue: 
					[| aspect |
					aspect := aLookupTable at: each name
								ifAbsentPut: 
									[(self newAspectForMember: each ppb: ppb)
										beInaccessible;
										yourself].
					aspect
						flags: (aspect flags maskSet: (each isPropGet
										ifTrue: [AttributeDescriptor.ReadableMask]
										ifFalse: 
											[self assert: [each isPropSet].
											AttributeDescriptor.WriteableMask]))]].
	ppb ifNotNil: [ppb free]!

classCategories
	"Private - Answer a <Set> of the class categories to which any class generated for the receiver should be added."

	^super classCategories
		add: (self class classCategoryClass name: 'COM-Interfaces');
		yourself!

compilePropertyAccessor: aString
	self compileMethod: aString categories: self autoGenPropertiesCategories!

compileRawMethod: aString categories: anArray 
	"Private - Generate the method or send to trace, depending on the mode."

	| result |
	result := self compileMethod: aString categories: anArray.
	(result notNil and: [self isProtocolRequired]) 
		ifTrue: [self protocol addSelector: result selector]!

determineNewBase: baseClass forExistingWrapper: existingClass 
	"Answer the superclass for the wrapper class generated by the receiver when modifying an existing wrapper class. By default the existing superclass is maintained."

	| currentSuper |
	currentSuper := existingClass superclass.
	^baseClass == currentSuper 
		ifTrue: [currentSuper]
		ifFalse: 
			[(currentSuper includesBehavior: IDispatch) 
				ifTrue: [(baseClass includesBehavior: IDispatch) ifTrue: [currentSuper] ifFalse: [baseClass]]
				ifFalse: 
					[(baseClass includesBehavior: IDispatch) ifTrue: [baseClass] ifFalse: [currentSuper]]]!

generateClassCLSIDForCoclass: aTKindCoclassAnalyzer
	| target |
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: 'clsid';
		crtab;
		nextPutAll: '"Private - Answer the CLSID of the coclass (';
		nextPutAll: aTKindCoclassAnalyzer name;
		nextPutAll: ') for which the receiver is the default interface.'.
	self printAutoGenMethodPostambleOn: target.
	target nextPut: $^.
	self printClass: CLSID on: target.
	target
		space;
		display: #fromString:;
		space;
		print: aTKindCoclassAnalyzer guid asString;
		cr.
	self compileClassMethod: target contents categories: self classConstantsCategories!

generateClassInitialize
	"Private - Generate the class initialization methods for a COM interface wrapper."

	(self generationFlags allMask: NoTypeLib)
		ifFalse: [self generateInitializeTypeLib]!

generateClassInstanceCreation
	"Private - Generate the class #clsid method for an interface wrapper, 
	but only if this interface is a default interface."

	| coclasses iid |
	(self canGenerateClassMessage: #clsid) ifFalse: [^nil].
	iid := self guid.
	coclasses := self typeLib coclasses select: [:c | c defaultInterface guid = iid].
	coclasses isEmpty ifTrue: [^self].
	coclasses size > 1 
		ifTrue: 
			[| instantiable |
			instantiable := coclasses select: [:c | c isInstantiable].
			instantiable size = 1 ifTrue: [coclasses := instantiable]].
	coclasses size > 1 
		ifTrue: [coclasses do: [:each | self generateNewForCoclass: each]]
		ifFalse: [self generateClassCLSIDForCoclass: coclasses first]!

generateClassSide: aClass 
	self generateClassInitialize.
	aClass initialize.
	self generateClassComment.
	self generateClassInstanceCreation!

generateCollectionTest
	"Private - Generate a test method which statically defines whether the interface
	associated with the receiver represents a collection object based on the
	presence/absence of the _NewEnum property in the type information associated
	with the receiver. IDispatch>>isCollection should always work, but is slow,
	so we always generate one of these test methods, unless the interface is run-time
	extensible and the type-info does not include _NewEnum."

	| text expr isCollection dunno |
	self isDispatchable ifFalse: [^self	"Not applicable"].
	isCollection := self isVBCollection.
	dunno := isCollection not and: [self isExtensible].
	expr := dunno
				ifTrue: 
					["Might add _NewEnum at run-time"
					self baseClass == IDispatch ifTrue: [^self	"Inherited method OK"].
					'self has_NewEnum']
				ifFalse: [isCollection printString].
	text := String smalltalkWriteStream: 256.
	text
		nextPutAll: 'isVBCollection';
		crtab;
		nextPutAll: '"Answer whether the receiver is a VB style collection.'.
	dunno
		ifTrue: 
			[text
				crtab;
				nextPutAll: 'The receiver is dynamically extensible, so we cannot determine this from the type library, and must perform a run-time check for the _NewEnum property.'].
	text
		nextPut: $";
		cr;
		crtab;
		nextPut: $^;
		nextPutAll: expr.
	self compileTestingMethod: text contents!

generateDefaultMethod: aFUNCDESC wrapping: anAXMethodName
	"Private - Generate a high-level wrapper for the method described 
	by the <FUNCDESC> argument, calling the lower-level wrapper
	method named by the <AXMethodName> argument, passing it
	default values for all optional arguments."

	| stream wrapperName |
	stream := String smalltalkWriteStream: 128.
	wrapperName := self
				printDefaultMethod: aFUNCDESC
				wrapping: anAXMethodName
				on: stream.
	wrapperName isNil ifFalse: [self compileMethodWrapper: stream contents].
	^wrapperName!

generateInitializeTypeLib
	"Private - Generate the #initializeTypeLib method for a COM interface wrapper."

	| target lib variableName |
	(self canGenerateClassMessage: #initializeTypeLib) ifFalse: [^nil].
	target := String writeStream.
	lib := self typeLib.
	target
		nextPutAll: 'initializeTypeLib';
		crtab;
		nextPutAll: '"Private - Establish a connection to the receiver''s type library.';
		crtab;
		tab;
		nextPutAll: self variableName;
		nextPutAll: ' initializeTypeLib'.
	self printAutoGenMethodPostambleOn: target.
	"Avoid generating typelib global"
	variableName := self isTraceOnly ifTrue: [lib variableName] ifFalse: [lib binding key].
	target
		nextPutAll: 'typeLib := ';
		nextPutAll: variableName.
	self compileClassMethod: target contents categories: self classInitializerCategories!

generateInstanceSide: aClass
	self generateTests.
	self generatePropertyAccessors.
	self generateMethodWrappers.

	"Add protocol last to avoid loads of stubs being needlessly generated"
	self isProtocolRequired ifTrue: [self protocol addClass: aClass]!

generateMethodWrappers
	"Private - Generate a wrapper for each of the methods in the receiver."

	| valueProp |
	self methods do: 
			[:each | 
			(each isMethod)
				ifTrue: [self generateMethodWrappers: each];
				ifFalse: 
						[each isPropGet 
							ifTrue: [self generatePropGetWrappers: each]
							ifFalse: 
								[each isPropPut 
									ifTrue: [self generatePropPutWrappers: each]
									ifFalse: [self generatePropPutRefWrappers: each]]]].
	self areWrappersRequired ifFalse: [^self].
	valueProp := self nameOfID: DISPID_VALUE ifAbsent: [].
	(valueProp notNil and: [(valueProp sameAs: #value) not]) 
		ifTrue: [self generateValuePropertyWrappers]!

generateMethodWrappers: aFUNCDESC
	(super generateMethodWrappers: aFUNCDESC) ifNotNil: 
			[:methodName | 
			(self isDefaultedWrapperRequiredFor: aFUNCDESC) 
				ifTrue: [self generateDefaultMethod: aFUNCDESC wrapping: methodName]]!

generateNewForCoclass: aTKindCoclassAnalyzer
	| target |
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: 'new';
		nextPutAll: aTKindCoclassAnalyzer name;
		crtab;
		nextPutAll: '"Answer a new instance of the receiver on the ';
		nextPutAll: aTKindCoclassAnalyzer name;
		nextPutAll: ' COM object'.
	self printAutoGenMethodPostambleOn: target.
	target
		nextPutAll: '^self ';
		display: #onCLSID:;
		nextPutAll: ' ('.
	self printClass: CLSID on: target.
	target
		space;
		display: #fromString:;
		space;
		print: aTKindCoclassAnalyzer clsid asString;
		nextPut: $);
		cr.
	self compileClassMethod: target contents categories: {self autoGenCategoryName. 'instance creation'}!

generatePropertyAccessors
	"Private - Generate get/set wrappers for the properties accessible via the dispinterface."

	^self subclassResponsibility!

generatePropGet: aFUNCDESC wrapping: anAXMethodName defaultOptionals: aBoolean
	"Private - Generate a high-level wrapper for the propget method described by the <FUNCDESC> argument. If the argument describes the DISPID_VALUE propget, then generate a #value wrapper as well. Both wrappers return the correct type of object as opposed to an HRESULT code. Answer an <AXMethodName> describing the generated method (or the one that would have been generated)."

	| methodName target |
	self assert: [aFUNCDESC isPropGet].
	methodName := self buildMethodName: aFUNCDESC defaultOptionals: aBoolean.
	(self canGenerateMethodNamed: methodName) ifFalse: [^methodName].
	target := String smalltalkWriteStream: 512.
	methodName printSignatureOn: target.
	target cr.
	self printPropGetComment: aFUNCDESC on: target.
	(self
		printPropGet: aFUNCDESC
		wrapping: anAXMethodName
		on: target
		defaultOptionals: aBoolean) notNil
		ifTrue: [self compilePropertyAccessor: target contents].
	^methodName!

generatePropGetWrappers: aFUNCDESC
	"Private - Generate method wrappers for the propget described by the <FUNCDESC>, method."

	"Implementation Note: At present we generate the raw get_XXX property access method, and a higher level wrapper which answers the property value directly. In the case of a dispinterface these are one and the same."

	| rawPropGetName wrapperName |
	rawPropGetName := self generateRawPropGet: aFUNCDESC.
	(rawPropGetName isNil or: [self areWrappersRequired not]) ifTrue: [^self].
	wrapperName := self
				generatePropGet: aFUNCDESC
				wrapping: rawPropGetName
				defaultOptionals: false.
	(wrapperName isNil or: [(self isDefaultedWrapperRequiredFor: aFUNCDESC) not]) ifTrue: [^self].
	self
		generatePropGet: aFUNCDESC
		wrapping: wrapperName
		defaultOptionals: true!

generatePropPut: aFUNCDESC wrapping: anAXMethodName
	"Private - Generate a high-level wrapper for the prop-put function described by the <FUNCDESC> argument, invoking the raw prop-put method described by the <AXMethodName> argument. Answer an <AXMethodName> describing the generated method (or the one that would have been generated)."

	| methodName |
	self assert: [aFUNCDESC isPropSet].
	methodName := self buildMethodName: aFUNCDESC defaultOptionals: false.
	(self canGenerateMethodNamed: methodName)
		ifTrue: 
			[| target |
			target := String smalltalkWriteStream: 512.
			methodName printSignatureOn: target.
			target cr.
			self printPropPutComment: aFUNCDESC on: target.
			(self
				printPropPut: aFUNCDESC
				wrapping: anAXMethodName
				on: target) notNil
				ifTrue: [self compilePropertyAccessor: target contents]].
	^methodName!

generatePropPutRefWrappers: aFUNCDESC
	"Private - Generate a wrapper for the property put method described by the <FUNCDESC> argument."

	self generatePropPutWrappers: aFUNCDESC!

generatePropPutWrappers: aFUNCDESC
	"Private - Generate method wrappers for the propput described by the <FUNCDESC>, method."

	"Implementation Note: At present we generate the raw put_XXX property access method, and a higher level wrapper which converts variant arguments, etc. In the case of a dispinterface these are one and the same."

	(self generateRawPropPut: aFUNCDESC)
		ifNotNil: [:rawMethodName | self areWrappersRequired ifTrue: [self generatePropPut: aFUNCDESC wrapping: rawMethodName]]!

generateRawPropGet: aFUNCDESC
	"Private - Generate a wrapper for the propget function described by the <FUNCDESC> argument. Answer an <AXMethodName> containing selector keyword and argument information which can be used to construct a call to the method."

	^self rawMethodNameForFunction: aFUNCDESC!

generateRawPropPut: aFUNCDESC
	"Private - Generate a low-level wrapper for the property put function described by the <FUNCDESC> argument.. Answer an <AXMethodName> containing selector keyword and argument information which can be used to construct a call to the method."

	^self rawMethodNameForFunction: aFUNCDESC!

generateRuntimeExtensibilityTest
	"Private - Generate a runtime extensibility test if needed."

	"Implementation Note: IDispatch>>isExtensible is a simple '^true' method, so we only generate this test method into the wrapper if the interface is does _not_ add members at run-time, or if it isn't a direct IDispatch descendent (we may need to override a superclass method in the latter case)."

	| isDynamic target |
	isDynamic := self isExtensible.
	(self isDispatchable and: [isDynamic not or: [self baseClass ~~ IDispatch]]) ifFalse: [^self].
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: #isExtensible;
		crtab;
		nextPutAll: '"Answer whether the receiver may add methods at run-time."';
		cr;
		crtab;
		nextPut: $^;
		print: isDynamic.
	self compileTestingMethod: target contents!

generateTests
	"Private - Generate any test methods associated with the receiver."

	self 
		generateRuntimeExtensibilityTest;
		generateCollectionTest!

generateValueAccessor: aMemberDesc wrapping: anAXMethodName
	"Private - Generate a #value accessor for the default property (DISPID_VALUE) described by the <MemberDesc> argument. The accessor for the property is described by the <AXMethodName> argument."

	| target |
	self assert: [aMemberDesc isValueProperty].
	(self canGenerateMessage: #value) ifFalse: [^self].
	target := String smalltalkWriteStream: 256.
	target
		display: #value;
		cr.
	self printPropGetCommentPreamble: aMemberDesc on: target.
	self printValuePropCommentPostambleOn: target.
	target
		crtab;
		nextPutAll: '^self ';
		display: anAXMethodName selector;
		cr.
	self compilePropertyAccessor: target contents!

generateValueMutator: aMemberDesc wrapping: anAXMethodName
	"Private - Generate a #value: mutator for the default property (DISPID_VALUE) described by the <MemberDesc> argument."

	| target argumentName |
	self assert: [aMemberDesc isValueProperty and: [anAXMethodName argumentCount = 1]].
	(self canGenerateMessage: #value:) ifFalse: [^self].
	argumentName := anAXMethodName argumentNames first.
	target := String smalltalkWriteStream: 256.
	target
		display: #value:;
		space;
		nextPutAll: argumentName;
		cr;
		tab;
		nextPutAll: '"Set the ''';
		nextPutAll: aMemberDesc name;
		nextPutAll: ''' property of the receiver to the <'.
	self printType: aMemberDesc arguments last tdesc on: target.
	target nextPutAll: '> value of the argument.'.
	self printValuePropCommentPostambleOn: target.
	target
		crtab;
		nextPutAll: 'self ';
		display: anAXMethodName selector;
		space;
		nextPutAll: argumentName;
		cr.
	self compilePropertyAccessor: target contents!

generateValuePropertyWrappers
	(self functions select: [:each | each isValueProperty]) do: 
			[:each | 
			| methodName |
			methodName := self buildMethodName: each defaultOptionals: false.
			each isPropGet 
				ifTrue: 
					[methodName argumentCount = 0 
						ifTrue: [self generateValueAccessor: each wrapping: methodName]]
				ifFalse: 
					[methodName argumentCount = 1 
						ifTrue: [self generateValueMutator: each wrapping: methodName]]]!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver so it has a referenceable presence."

	| class |
	class := super generateVariableDefinition: aVariableBinding.
	"Presize to avoid recompilation when size calculated by subsequent initialization"
	class byteSize: IUnknown byteSize.
	^class!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes for the receiver."

	| attrs |
	attrs := self basicIdlAttributes.
	self isExtensible ifFalse: [attrs addLast: 'nonextensible'].
	^attrs!

inspectableProperties
	"Answer <sequencedReadableCollection> of VARDESC/FUNCDESCs describing the inspectable properties associated with the receiver. This list includes all properties which can be read and which are not marked as non-browsable. We need to include the inspectableProperties of all inherited interfaces."

	| answer |
	answer := OrderedCollection new.
	self superInterface ifNotNil: [:supertype | answer addAll: supertype inspectableProperties].
	answer addAll: (self variables select: [:each | each isInspectable]).
	answer addAll: (self methods select: [:each | self isInspectablePropGet: each]).
	^answer!

instanceMethodCategories: aBoolean
	"Private - Answer a collection of categories with which instance side methods are to be associated. The <boolean> argument indicates whether the categories are for a public or private method."

	^{self interfaceCategoryName.
		self autoGenCategoryName.
		aBoolean ifTrue: ['private'] ifFalse: ['public']}!

interfaceCategoryName
	"Private - Answer the name of the special method category for the interface described the receiver."

	^'COM Interfaces-', self name!

isAutomationCompatible
	"Answer whether the receiver is describing an interface which is Automation compatible. This doesn't mean that the class must be derived from IDispatch, just that only uses automation compatible types."

	^self attributes isAutomationCompatible!

isInspectablePropGet: aFUNCDESC 
	^aFUNCDESC isPropGet and: [aFUNCDESC isInspectable]!

isProtocolRequired
	"Private - Answer whether a protocol should be generated for the COM interface."

	^(self generationFlags allMask: DefineProtocol) and: [self isTraceOnly not]!

methodCommentDescription
	^'method of the COM object'!

newAspectForMember: aMemberDesc ppb: anIPerPropertyBrowsing
	| map name aspect vartype |
	map := anIPerPropertyBrowsing ifNotNil: [anIPerPropertyBrowsing stringsToValues: aMemberDesc memid].
	name := aMemberDesc name.
	vartype := aMemberDesc tdesc vartype.
	aspect := (map isNil or: [map isEmpty])
				ifTrue: [(VARIANT classForVT: vartype) newInstanceAspect: name class: Tools.DispatchAspect]
				ifFalse: 
					[Tools.DispatchAspect
						choice: name
						fromMap: map
						nullValue: (vartype == VT_BSTR ifTrue: [''])].
	aspect dispid: aMemberDesc memid.
	^aspect!

printArgument: anELEMDESC named: aString on: aPuttableStream
	anELEMDESC isOptional
		ifTrue: 
			[anELEMDESC objectClass
				printOptionalParameter: anELEMDESC
				on: aPuttableStream
				for: self]
		ifFalse: [aPuttableStream nextPutAll: aString]!

printDefaultMethod: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	| name |
	self assert: [anAXMethodName argumentCount > 0].
	name := self buildMethodName: aFUNCDESC defaultOptionals: true.
	(self canGenerateMethodNamed: name) ifFalse: [^nil].
	name printSignatureOn: aPuttableStream.
	aPuttableStream cr.
	self 
		printMethodCommentPreamble: aFUNCDESC
		on: aPuttableStream
		isPrivate: false.
	aPuttableStream
		crtab;
		nextPutAll: 'Default values are passed for all optional parameters.'.
	self printAutoGenMethodPostambleOn: aPuttableStream.
	self 
		printDefaultMethodBody: aFUNCDESC
		wrapping: anAXMethodName
		on: aPuttableStream.
	^name!

printDefaultMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream 
	| argc arguments keywords first indices argumentNames |
	aFUNCDESC hasAnswer ifTrue: [aPuttableStream nextPut: $^].
	aPuttableStream nextPutAll: 'self'.
	keywords := anAXMethodName keywords.
	indices := anAXMethodName indices.
	arguments := aFUNCDESC arguments.
	argumentNames := anAXMethodName argumentNames.
	argc := anAXMethodName argumentCount.
	first := argc <= 1.
	1 to: argc
		do: 
			[:each | 
			first ifTrue: [first := false] ifFalse: [aPuttableStream crtab: 2].
			aPuttableStream
				space;
				display: (keywords at: each);
				space.
			self 
				printArgument: (arguments at: (indices at: each))
				named: (argumentNames at: each)
				on: aPuttableStream]!

printMethod: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Printe a high-level wrapper for the method described by the <FUNCDESC> first argument method onto the <puttableStream> final argument.
	This wrapper actually returns the correct type of object as opposed to an HRESULT code. Answer an <AXMethodName> naming the printed  method, or nil if none should be generated."

	| methodName |
	self assert: [aFUNCDESC isMethod].
	methodName := self buildMethodName: aFUNCDESC defaultOptionals: false.
	(self canGenerateMethodNamed: methodName) ifFalse: [^nil].
	methodName printSignatureOn: aPuttableStream.
	aPuttableStream cr.
	self printMethodComment: aFUNCDESC on: aPuttableStream.
	self
		printMethodBody: aFUNCDESC
		wrapping: anAXMethodName
		on: aPuttableStream.
	^methodName!

printMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level method for the method described by the <FUNCDESC> first argument, calling the low-level method described by the <AXMethodName> second argument, onto the <puttableStream> third argument. Answers nil to suppress generation of method, else self."

	^self subclassResponsibility!

printMethodComment: aFUNCDESC on: aPuttableStream
	self
		printMethodCommentPreamble: aFUNCDESC
		on: aPuttableStream
		isPrivate: false.
	self printHelpstringComment: aFUNCDESC on: aPuttableStream.
	self printAutoGenMethodPostambleOn: aPuttableStream!

printMultiOutMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Generate the main body of a high-level method for the function described by the <FUNCDESC> first argument, invoking the low-level wrapper method named by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. The function has multiple output parameters, which is thankfully an unusual occurrence."

	^self subclassResponsibility!

printPropertyCommentDecl: aMemberDesc on: aPuttableStream
	^self subclassResponsibility!

printPropertyCommentPostamble: aMemberDesc on: aPuttableStream
	"Private - Print any available documentation for the property described by the <MemberDesc> argument, on the <puttableStream> argument. This will include any documentation from the type library, perhaps an IDL representation of the property, and a standard comment associated with auto-generated methods (which may be empty)."

	self printHelpstringComment: aMemberDesc on: aPuttableStream.
	self printPropertyCommentDecl: aMemberDesc on: aPuttableStream.
	self printAutoGenMethodPostambleOn: aPuttableStream!

printPropGet: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream defaultOptionals: aBoolean
	"Private - Generate the main body of a  high-level accessor for the prop-get method described by the <FUNCDESC> first argument. Answer nil if no method is to be emitted."

	^self subclassResponsibility!

printPropGetComment: aMemberDesc on: aPuttableStream
	self
		printPropGetCommentPreamble: aMemberDesc on: aPuttableStream;
		printPropertyCommentPostamble: aMemberDesc on: aPuttableStream!

printPropGetCommentPreamble: aMemberDesc on: aPuttableStream
	aPuttableStream
		tab;
		nextPutAll: '"Answer the <'.
	self basicPrintType: aMemberDesc tdesc on: aPuttableStream.
	aPuttableStream
		nextPutAll: '> value of the ''';
		nextPutAll: aMemberDesc name;
		nextPutAll: ''' property of the receiver.'!

printPropPut: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level accessor for the prop-put method described by the <FUNCDESC> first argument, calling the low-level method described by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. Answers nil to suppress generation of method, else self."

	^self subclassResponsibility!

printPropPutComment: aMemberDesc on: aPuttableStream
	aPuttableStream
		tab;
		nextPutAll: '"Set the ''';
		nextPutAll: aMemberDesc name;
		nextPutAll: ''' property of the receiver to the <'.
	self printType: aMemberDesc arguments last tdesc on: aPuttableStream.
	aPuttableStream nextPutAll: '> value of the argument.'.
	self printPropertyCommentPostamble: aMemberDesc on: aPuttableStream!

printRawPropGetBody: aMemberDesc name: anAXMethodName on: aPuttableStream
	"Private - Print the code for accessing the (optionally subscripted) property described by the <MemberDesc> first argument onto the <puttableStream> last argument."

	^self
		printRawMethodBody: aMemberDesc
		name: anAXMethodName
		on: aPuttableStream!

printRawPropPutBody: aMemberDesc name: anAXMethodName on: aPuttableStream
	"Private - Print the code for accessing the (optionally subscripted) property described by the <MemberDesc> first argument, onto the <puttableStream>last argument, using the most efficient property set method."

	^self
		printRawMethodBody: aMemberDesc
		name: anAXMethodName
		on: aPuttableStream!

printValuePropCommentPostambleOn: aPuttableStream
	aPuttableStream
		crtab;
		nextPutAll: 'This is the default value (DISPID_VALUE) property of the receiver."';
		cr!

rawPropCategories
	"Private - Answer the special method categories for auto-generated property accessors in the receiver's wrapper class."

	| privacy |
	privacy := self areWrappersRequired ifTrue: ['private'] ifFalse: ['public'].
	^{self autoGenCategoryName. self interfaceCategoryName. privacy}!

reservedSelectors
	"Answer a <Set> of all the selectors which are reserved, and should not be overridden by any auto-generated method."

	^self isDispatchable 
		ifTrue: [self class reservedDispSelectors]
		ifFalse: [self class reservedUnkSelectors]! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #areWrappersRequired!private!testing! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #autoGenPropertiesCategories!constants!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #buildMethodName:defaultOptionals:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #buildPublishedAspects:forObject:!helpers!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #classCategories!constants!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #compilePropertyAccessor:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #compileRawMethod:categories:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #determineNewBase:forExistingWrapper:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateClassCLSIDForCoclass:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateClassInitialize!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateClassInstanceCreation!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateClassSide:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateCollectionTest!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateDefaultMethod:wrapping:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateInitializeTypeLib!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateInstanceSide:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateMethodWrappers!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateMethodWrappers:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateNewForCoclass:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropertyAccessors!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropGet:wrapping:defaultOptionals:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropGetWrappers:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropPut:wrapping:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropPutRefWrappers:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generatePropPutWrappers:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateRawPropGet:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateRawPropPut:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateRuntimeExtensibilityTest!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateTests!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateValueAccessor:wrapping:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateValueMutator:wrapping:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateValuePropertyWrappers!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #inspectableProperties!enumerating!public! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #instanceMethodCategories:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #interfaceCategoryName!constants!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #isAutomationCompatible!public!testing! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #isInspectablePropGet:!enumerating!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #isProtocolRequired!private!testing! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #methodCommentDescription!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #newAspectForMember:ppb:!helpers!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printArgument:named:on:!helpers!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printDefaultMethod:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printDefaultMethodBody:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printMethod:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printMethodBody:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printMethodComment:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printMultiOutMethodBody:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropertyCommentDecl:on:!printing!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropertyCommentPostamble:on:!printing!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropGet:wrapping:on:defaultOptionals:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropGetComment:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropGetCommentPreamble:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropPut:wrapping:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printPropPutComment:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printRawPropGetBody:name:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printRawPropPutBody:name:on:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #printValuePropCommentPostambleOn:!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #rawPropCategories!constants!private! !
!OS.COM.InterfaceTypeAnalyzer categoriesFor: #reservedSelectors!accessing!public! !

!OS.COM.InterfaceTypeAnalyzer class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^Interface icon!

optimizedSelectors
	^#(#and: #or: #ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil: #ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil:)!

overridableIDispatchSelectors
	^#(#_newEnum #isVBCollection #isExtensible)!

overridableIUnknownSelectors
	^#(#value #value: #size #copy #hash)!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect sequenceableCollection: #methods) beReadOnly;
		yourself!

reservedDispSelectors
	ReservedDispSelectors isNil 
		ifTrue: 
			[ReservedDispSelectors := (IDispatch allSelectors)
						removeAll: self overridableIUnknownSelectors;
						removeAll: self overridableIDispatchSelectors;
						addAll: self optimizedSelectors;
						yourself].
	^ReservedDispSelectors!

reservedUnkSelectors
	ReservedUnkSelectors isNil
		ifTrue: 
			[ReservedUnkSelectors := IUnknown allSelectors
						removeAll: self overridableIUnknownSelectors;
						addAll: self optimizedSelectors;
						addAll: self optimizedSelectors;
						yourself].
	^ReservedUnkSelectors! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #icon!constants!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #optimizedSelectors!constants!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #overridableIDispatchSelectors!constants!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #overridableIUnknownSelectors!constants!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #reservedDispSelectors!accessing!public! !
!OS.COM.InterfaceTypeAnalyzer class categoriesFor: #reservedUnkSelectors!accessing!public! !

!OS.COM.ITypeInfo methodsFor!

printOn: aStream 
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream display: 'NULL']
		ifFalse: [aStream print: (self nameOfID: MEMBERID_NIL)].
	aStream nextPut: $)! !
!OS.COM.ITypeInfo categoriesFor: #printOn:!printing!public! !

!OS.COM.ITypeLib methodsFor!

printOn: aStream 
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isNull 
		ifTrue: [aStream display: 'NULL']
		ifFalse: [aStream print: (self nameAt: 0 ifAbsent: ['<anon>'])].
	aStream nextPut: $)! !
!OS.COM.ITypeLib categoriesFor: #printOn:!printing!public! !

!OS.COM.MemberDesc methodsFor!

idlAttributes
	^(OrderedCollection new)
		addAllLast: self basicIdlAttributes;
		addAllLast: self documentation idlAttributes;
		addAllLast: self idlCustomAttributes;
		yourself!

idlAttributesAndId
	^{self idlId} , self idlAttributes!

idlCustomAttributes
	| attrs |
	attrs := Array writeStream.
	(self customAttributes associations
		asSortedCollection: [:a :b | a key displayString < b key displayString]) do: 
				[:each |
				| attr |
				attr := String writeStream.
				each key isSymbol
					ifTrue: 
						[attr display: each key.
						(each value isEmpty or: 
								["Doesn't seem to be possible to actually set the value of a custom attribute to VT_EMPTY, to we treat an empty string as no argument"
								each value value = ''])
							ifFalse: 
								[attr nextPut: $(.
								each value printIDLOn: attr.
								attr nextPut: $)]]
					ifFalse: 
						[attr
							nextPutAll: 'custom(';
							nextPutAll: each key idlString.
						each value isEmpty
							ifFalse: 
								[attr nextPutAll: ', '.
								each value printIDLOn: attr.
								attr nextPutAll: $)]].
				attrs nextPut: attr contents].
	^attrs contents!

isInspectable
	"Answer whether the receiver is describing a 'browsable' property that is not 'restricted'
	and therefore suitable for display in inspectors, etc."

	^(self isNonBrowsable or: [self isRestricted]) not!

printIDL
	"Answer a <readableString> containing the Microsoft Interface Definition Language
	description of the receiver."

	| s |
	s := String writeStream.
	self printIDLOn: s.
	^s contents!

printIDLOn: target
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self printIDLOn: target indent: 0!

printIDLOn: target indent: tabs 
	"Print the IDL description of the receiver on the <puttableStream>, target."

	^self subclassResponsibility! !
!OS.COM.MemberDesc categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.MemberDesc categoriesFor: #idlAttributesAndId!accessing!private! !
!OS.COM.MemberDesc categoriesFor: #idlCustomAttributes!accessing!public! !
!OS.COM.MemberDesc categoriesFor: #isInspectable!public!testing! !
!OS.COM.MemberDesc categoriesFor: #printIDL!printing-IDL!public! !
!OS.COM.MemberDesc categoriesFor: #printIDLOn:!printing-IDL!public! !
!OS.COM.MemberDesc categoriesFor: #printIDLOn:indent:!printing-IDL!public! !

!OS.COM.MemberDesc class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect multilineString: #printIDL);
		yourself! !
!OS.COM.MemberDesc class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.PARAMDESC methodsFor!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of flag names (IDL attributes)
	from the receiver."

	| answer flags |
	answer := OrderedCollection new: 3.
	flags := self wParamFlags.
	(flags anyMask: PARAMFLAG_FIN) ifTrue: [answer addLast: 'in'].
	(flags anyMask: PARAMFLAG_FOUT) ifTrue: [answer addLast: 'out'].
	(flags anyMask: PARAMFLAG_FRETVAL) ifTrue: [answer addLast: 'retval'].
	"defaultvalue() implies optional"
	self hasDefaultValue
		ifTrue: 
			[| stm |
			stm := String writeStream.
			stm nextPutAll: 'defaultvalue('.
			self defaultValue printIDLOn: stm.
			stm nextPut: $).
			answer addLast: stm contents]
		ifFalse: [(flags anyMask: PARAMFLAG_FOPT) ifTrue: [answer addLast: 'optional']].
	^answer! !
!OS.COM.PARAMDESC categoriesFor: #idlAttributes!accessing!private! !

!OS.COM.Record methodsFor!

publishedAspects
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	| aspects |
	aspects := self class publishedAspectsOfInstances.
	self isNull
		ifFalse: 
			[self getValidFields
				do: [:each | aspects add: ((self getField: each) newAspect: each class: Tools.AXRecordAspect)]].
	^aspects! !
!OS.COM.Record categoriesFor: #publishedAspects!accessing!public! !

!OS.COM.SAFEARRAY methodsFor!

printOn: aStream
	"Print a string representation of self on aStream."

	"Implementation Note: If multidimensioned then just print the dimensions rather than the contents."

	(self isNull or: [self dimensions == 1])
		ifTrue: [super printOn: aStream]
		ifFalse: 
			[aStream basicPrint: self.
			1 to: self dimensions
				do: 
					[:d |
					aStream
						nextPut: $[;
						print: (self lowerBound: d);
						nextPutAll: '..';
						print: (self upperBound: d);
						nextPut: $]]]! !
!OS.COM.SAFEARRAY categoriesFor: #printOn:!printing!private! !

!OS.COM.SAFEARRAY class methodsFor!

fieldType
	^StructureField!

pointerFieldType
	^PointerField!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	anELEMDESC isIn
		ifTrue: 
			["If in or in-out then just pass a converted object"
			#todo.	"Set the elementClass of the safe array correctly?"
			aPuttableStream
				nextPutAll: aString;
				space;
				display: #asSAFEARRAY]
		ifFalse: 
			["If an output only argument, need an instance of the receiver to buffer the result"
			anAPIInfoAnalyzer printClass: self on: aPuttableStream.
			aPuttableStream
				space;
				display: #newPointer]! !
!OS.COM.SAFEARRAY class categoriesFor: #fieldType!constants!private! !
!OS.COM.SAFEARRAY class categoriesFor: #pointerFieldType!constants!private! !
!OS.COM.SAFEARRAY class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !

!OS.COM.StructureTypeAnalyzer methodsFor!

conformsToRequiredProtocols: aVariableBinding
	"Private - Answer whether the global object with the specified binding conforms to all the necessary
	class and instance <MethodProtocol>s."

	"If it doesn't currently inherit from our usual base class, we'll need to see if it implements the relevant protocols"

	^(super conformsToRequiredProtocols: aVariableBinding)
		or: [aVariableBinding value class conformsToProtocol: #'externalStructure class']!

determineNewBase: baseClass forExistingWrapper: existingClass
	| existingSuper |
	existingSuper := existingClass superclass.
	^existingSuper == External.Structure ifTrue: [baseClass] ifFalse: [existingSuper]!

generateClassSide: aClass
	self generateDefineFields.
	self generateClassComment.
	(self generationFlags allMask: NoTypeLib) 
		ifFalse: [self generateTypeLibAccessor]!

generateDefineFields
	"Private - Generate the #defineFields method for a structure wrapper."

	| target idl |
	(self canGenerateClassMessage: #defineFields) ifFalse: [^nil].
	target := String writeStream.
	target
		nextPutAll: #defineFields;
		crtab;
		nextPut: $";
		nextPutAll: 'Define the fields of the ';
		nextPutAll: self name;
		nextPutAll: ' structure.';
		cr;
		crtab;
		nextPutAll: self variableName;
		nextPutAll: ' compileDefinition';
		cr;
		cr.
	idl := String writeStream.
	self printIDLOn: idl indent: 2.
	self emitComment: idl contents on: target.
	self printAutoGenMethodPostambleOn: target.
	self
		printFieldDefinitionsOn: target
		offset: 0
		prefix: ''
		hidden: false.
	target
		nextPut: $.;
		crtab;
		nextPutAll: 'self byteSize: ';
		print: self byteSize.
	self compileClassMethod: target contents
		categories: {self autoGenCategoryName. 'template definition'}!

generateInstanceSide: aClass
	aClass compileDefinition!

generateTypeLibAccessor
	"Private - Generate the #typeLib class method for an <ExternalStructure> wrapper."

	| target lib glob |
	(self canGenerateClassMessage: #libraryAndIndex) ifFalse: [^nil].
	target := String writeStream.
	lib := self typeLib.
	target
		nextPutAll: 'libraryAndIndex';
		crtab;
		nextPutAll: '"Answer an <Asssociation> between an <AXTypeLibraryAnalyzer> on the receiver''s type library';
		crtab;
		nextPutAll: 'and the index of the receiver''s type information in that library'.
	self printAutoGenMethodPostambleOn: target.
	"Avoid generating typelib global"
	glob := self isTraceOnly ifTrue: [lib variableName] ifFalse: [lib binding key].
	target
		nextPut: $^;
		nextPutAll: glob;
		nextPutAll: ' -> ';
		display: tlbInterface libraryAndIndex value.
	self compileClassMethod: target contents categories: self classInitializerCategories!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	| class |
	class := self generateClassDefinition: aVariableBinding imports: #().
	self guid notNull ifTrue: [class guid: self guid].
	^class!

generateWrapper
	^(BuiltIns lookup: self guid) ifNil: [super generateWrapper]!

printAnonymousStruct: aVARDESC offset: anInteger prefix: aString hidden: aBoolean on: aWriteStream
	| hidden prefix offset structTypeInfo |
	structTypeInfo := aVARDESC tdesc realTypeInfo.
	offset := anInteger + aVARDESC oInst.
	prefix := aString , (aVARDESC isAnonymous ifTrue: [''] ifFalse: [aVARDESC name , '_']).
	hidden := (aBoolean or: [aVARDESC isHidden]) or: [structTypeInfo isHidden].
	structTypeInfo variables do: 
			[:each |
			structTypeInfo
				printFieldDefinition: each
				offset: offset
				prefix: prefix
				hidden: hidden
				on: aWriteStream]
		separatedBy: 
			[aWriteStream
				nextPut: $;;
				crtab: 2]!

printClassCommentPreambleOn: target
	"Private - Print a comment preamble appropriate for the receiver onto the 
	<puttableStream>, target."

	| lib |
	lib := self typeLib.
	target
		nextPut: $`;
		nextPutAll: self variableName;
		nextPutAll: '` is an `ExternalStructure` class to wrap the ';
		nextPutAll: self idlKeyword;
		space;
		print: self fullyQualifiedName;
		nextPutAll: ' from type information in the ''';
		nextPutAll: lib helpstring;
		nextPutAll: ''' library.'!

printFieldDefinition: aVARDESC offset: anInteger prefix: aString hidden: aBoolean on: aPuttableStream
	aVARDESC tdesc isAnonymous
		ifTrue: 
			[self
				printAnonymousStruct: aVARDESC
				offset: anInteger
				prefix: aString
				hidden: aBoolean
				on: aPuttableStream]
		ifFalse: 
			[self
				printNamedFieldDefinition: aVARDESC
				offset: anInteger
				prefix: aString
				hidden: aBoolean
				on: aPuttableStream]!

printFieldDefinitionsOn: aPuttableStream offset: anInteger prefix: aString hidden: aBoolean
	| hidden vars firstField first |
	hidden := aBoolean or: [self isHidden].
	vars := self variables.
	firstField := vars first.
	first := true.
	(firstField isAnonymous and: [firstField tdesc isAnonymous not])
		ifTrue: 
			[aPuttableStream
				nextPutAll: 'super defineFields.';
				crtab]
		ifFalse: 
			[aPuttableStream
				nextPutAll: 'self';
				crtab: 2.
			self
				printFieldDefinition: firstField
				offset: anInteger
				prefix: aString
				hidden: hidden
				on: aPuttableStream.
			first := false].
	2 to: vars size
		do: 
			[:i |
			first
				ifTrue: 
					[aPuttableStream
						nextPutAll: 'self';
						crtab: 2.
					first := false]
				ifFalse: 
					[aPuttableStream
						nextPut: $;;
						crtab: 2].
			self
				printFieldDefinition: (vars at: i)
				offset: anInteger
				prefix: aString
				hidden: hidden
				on: aPuttableStream]!

printIDLBodyOn: aPuttableStream indent: anInteger 
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	aPuttableStream
		crtab: anInteger;
		nextPutAll: self idlKeyword;
		space;
		nextPutAll: 'tag';
		nextPutAll: self name;
		space;
		nextPut: ${.
	self printIDLForVariablesOn: aPuttableStream indent: anInteger + 1.
	aPuttableStream
		crtab: anInteger;
		nextPutAll: '} ';
		nextPutAll: self name;
		nextPut: $;;
		cr!

printIDLForVariablesOn: aPuttableStream indent: anInteger 
	self variables do: 
			[:each | 
			aPuttableStream crtab: anInteger.
			self 
				printIDLForVariable: each
				on: aPuttableStream
				indent: anInteger]!

printIDLOn: target indent: tabs 
	"Print the IDL description of the receiver on the <puttableStream>, target."

	target
		tab: tabs;
		nextPutAll: 'typedef '.
	self printIDLAttributesOn: target indent: -1.
	self printIDLBodyOn: target indent: tabs!

printNamedFieldDefinition: aVARDESC offset: anInteger prefix: aString hidden: aBoolean on: aPuttableStream
	| classdesc |
	aPuttableStream
		nextPutAll: 'defineField: #';
		nextPutAll: aString;
		nextPutAll: aVARDESC name;
		nextPutAll: ' type: '.
	classdesc := aVARDESC classDesc.
	(aVARDESC isStringField
		ifTrue: [classdesc key elementSize == 2 ifTrue: [Utf16String] ifFalse: [String]]
		ifFalse: [classdesc key])
			printStructField: aVARDESC
			indirections: classdesc value
			on: aPuttableStream
			in: self environment.
	#(#(#isReadOnly #beReadOnly) #(#isNonBrowsable #beNonBrowsable) #(#isRestricted #beWriteOnly)) do: 
			[:each |
			(aVARDESC perform: each first)
				ifTrue: 
					[aPuttableStream
						space;
						nextPutAll: each second]].
	(aBoolean or: [aVARDESC isHidden])
		ifTrue: 
			[aPuttableStream
				space;
				nextPutAll: #beFiller].
	"The offset is explicitly set in case typelib using special packing"
	aPuttableStream
		nextPutAll: ' offset: ';
		print: anInteger + aVARDESC oInst! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #conformsToRequiredProtocols:!private!testing! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #determineNewBase:forExistingWrapper:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateClassSide:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateDefineFields!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateInstanceSide:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateTypeLibAccessor!automatic generation!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printAnonymousStruct:offset:prefix:hidden:on:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printClassCommentPreambleOn:!printing!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printFieldDefinition:offset:prefix:hidden:on:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printFieldDefinitionsOn:offset:prefix:hidden:!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printIDLForVariablesOn:indent:!printing-IDL!private! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printIDLOn:indent:!printing-IDL!public! !
!OS.COM.StructureTypeAnalyzer categoriesFor: #printNamedFieldDefinition:offset:prefix:hidden:on:!private! !

!OS.COM.StructureTypeAnalyzer class methodsFor!

icon
	"Answers an <Icon> that can be used to represent this class"

	^External.Structure icon!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect sequenceableCollection: #members) beReadOnly;
		yourself! !
!OS.COM.StructureTypeAnalyzer class categoriesFor: #icon!constants!public! !
!OS.COM.StructureTypeAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TKindAliasAnalyzer methodsFor!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	^self shouldNotImplement!

generateWrapper
	"Private - Generate appropriate Dolphin objects to wrap the type described
	by the receiver. There is no wrapper for alias types in Dolphin, but we can
	wrap the aliased type."

	^self tdesc typeInfo generate!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes
	 for the receiver."

	^(self basicIdlAttributes)
		addLast: 'public';
		yourself!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'typedef'!

printClassCommentPreambleOn: target
	"Private - Print a comment preamble appropriate for the receiver onto the 
	<puttableStream>, target."

	^self shouldNotImplement!

printIDLBodyOn: aPuttableStream indent: anInteger 
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	self 
		printIDLDecl: self name
		type: self tdesc
		on: aPuttableStream.
	aPuttableStream
		nextPut: $;;
		cr!

printIDLOn: target indent: tabs
	"Print the IDL description of the receiver on the <puttableStream>, target."

	target
		tab: tabs;
		nextPutAll: self idlKeyword;
		space.
	(self printIDLAttributesOn: target indent: -1)
		ifTrue: [tabs > 0 ifTrue: [target crtab: tabs] ifFalse: [target space]].
	self printIDLBodyOn: target indent: tabs! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #printClassCommentPreambleOn:!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing!private! !
!OS.COM.TKindAliasAnalyzer categoriesFor: #printIDLOn:indent:!printing-IDL!public! !

!OS.COM.TKindCoclassAnalyzer methodsFor!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	^self shouldNotImplement!

generateWrapper
	"Private - Generate appropriate Dolphin objects to wrap the type described
	by the receiver. There is no wrapper for coclasses in Dolphin (one should
	generate the interfaces instead)."

	"Do nothing"!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes
	 for the receiver."

	| answer |
	answer := self basicIdlAttributes.
	#(#isAppObject #isAggregatable #isControl #isLicensed #notInstantiable) 
		with: #('appobject' 'aggregatable' 'control' 'licensed' 'noncreatable')
		do: [:eachTest :eachAttr | (self perform: eachTest) ifTrue: [answer addLast: eachAttr]].
	^answer!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'coclass'!

printIDLBodyOn: target indent: tabs
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	super printIDLBodyOn: target indent: tabs.
	target
		space;
		nextPut: ${;
		cr.
	self interfaces with: self interfaceFlags
		do: 
			[:i :f |
			| flags |
			flags := OrderedCollection new.
			(f allMask: IMPLTYPEFLAG_FDEFAULT) ifTrue: [flags addLast: 'default'].
			(f allMask: IMPLTYPEFLAG_FSOURCE) ifTrue: [flags addLast: 'source'].
			self
				printIDLAttributes: flags
				on: target
				indent: tabs + 1.
			target
				nextPutAll: i idlKeyword;
				space;
				nextPutAll: i name;
				nextPut: $;;
				cr].
	target
		tab: tabs;
		nextPutAll: '};';
		cr! !
!OS.COM.TKindCoclassAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.TKindCoclassAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.TKindCoclassAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TKindCoclassAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindCoclassAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !

!OS.COM.TKindCoclassAnalyzer class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect sequenceableCollection: #interfaces) beReadOnly;
		yourself! !
!OS.COM.TKindCoclassAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TKindDispatchAnalyzer methodsFor!

buildPropertyAccessorName: aVARDESC
	^Tools.AXMethodName
		keywords: (self reinventBadSelector: {self identifierFrom: aVARDESC name} member: aVARDESC)
		argumentNames: #()
		indices: #()!

buildPropertyMutatorName: aVARDESC
	^Tools.AXMethodName
		keywords: (self reinventBadSelector: {(self identifierFrom: aVARDESC name) , ':'} member: aVARDESC)
		argumentNames: #('newVal')
		indices: #(1)!

generatePropertyAccessor: aVARDESC
	"Private - Generate a property accessor (get) method for property described by the <VARDESC> argument."

	| target methodName |
	methodName := self buildPropertyAccessorName: aVARDESC.
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: methodName keywords first;
		cr.
	self printPropGetComment: aVARDESC on: target.
	self
		printRawPropGetBody: aVARDESC
		name: methodName
		on: target.
	self compilePropertyAccessor: target contents!

generatePropertyAccessors
	"Private - Generate get/set wrappers for the properties accessible via the dispinterface."

	self properties do: 
			[:each |
			self generatePropertyAccessor: each.
			each isReadOnly ifFalse: [self generatePropertyMutator: each]]!

generatePropertyMutator: aVARDESC
	"Private - Generate a property mutator method for property described by the <VARDESC> argument."

	| target methodName |
	methodName := self buildPropertyMutatorName: aVARDESC.
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: methodName keywords first;
		nextPutAll: ' newVal';
		cr.
	self printPropPutComment: aVARDESC on: target.
	self
		printRawPropPutBody: aVARDESC
		name: methodName
		on: target.
	self compilePropertyAccessor: target contents!

generateRawMethod: aFUNCDESC categories: aCollection
	"Private - Generate a wrapper for the method described by the <FUNCDESC> argument. Answer an <AXMethodName> containing selector keyword and argument information  which can be used to construct a call to the method."

	^self rawMethodNameForFunction: aFUNCDESC!

generateValuePropertyWrappers
	(self properties detect: [:each | each isValueProperty] ifNone: [])
		ifNil: [^super generateValuePropertyWrappers]
		ifNotNil: 
			[:valueProp |
			self generateValueAccessor: valueProp wrapping: (self buildPropertyAccessorName: valueProp).
			self generateValueMutator: valueProp wrapping: (self buildPropertyMutatorName: valueProp)]!

generateWrapper
	"Private - Generate a new subclass of IDispatch which wraps the  properties and methods of the dispinterface described the the receiver's ITypeInfo. Answer the object generated (in this case a <COMInterface> subclass)."

	^self isSource
		ifTrue: 
			[(self generationFlags allMask: Verbose)
				ifTrue: 
					[Notification signal: self name , ' is a source dispinterface, no specific wrapper class is needed.'].
			IDispatch]
		ifFalse: [super generateWrapper]!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object described by the receiver, e.g. dispinterface."

	^'dispinterface'!

isInspectablePropGet: aFUNCDESC
	^(super isInspectablePropGet: aFUNCDESC) and: [aFUNCDESC argumentCount == 0]!

isProtocolRequired
	"Private - Answer whether a protocol should be generated for the COM interface."

	^super isProtocolRequired and: [self isSource]!

printClassCommentPreambleOn: aPuttableStream
	"Private - Print a comment preamble appropriate for the receiver onto the <puttableStream> argument."

	| lib |
	lib := self typeLib.
	aPuttableStream
		nextPut: $`;
		nextPutAll: self variableName;
		nextPutAll: '` is a wrapper class generated for the dispatch interface ';
		print: self fullyQualifiedName;
		nextPutAll: ' from type information in the ''';
		nextPutAll: lib helpstring;
		nextPutAll: ''' library. It contains methods to get and set the properties and invoke the methods exposed ';
		nextPutAll: 'by that interface.'!

printIDLBodyOn: aPuttableStream indent: anInteger
	"Private - Print the IDL description for the receiver on the <puttableStream> argument."

	super printIDLBodyOn: aPuttableStream indent: anInteger.
	aPuttableStream
		space;
		nextPut: ${;
		cr.
	aPuttableStream
		tab: anInteger + 1;
		nextPutAll: 'properties:';
		cr.
	self printIDLOfPropertiesOn: aPuttableStream indent: anInteger.
	aPuttableStream
		tab: anInteger + 1;
		nextPutAll: 'methods:';
		cr.
	self methods do: [:m | m printIDLOn: aPuttableStream indent: anInteger + 2]
		separatedBy: [aPuttableStream cr].
	aPuttableStream
		crtab: anInteger;
		nextPutAll: '};';
		cr!

printIDLOfPropertiesOn: aPuttableStream indent: anInteger 
	| props |
	props := self properties.
	props do: 
			[:each | 
			self 
				printIDLAttributes: each idlAttributesAndId
				on: aPuttableStream
				indent: anInteger + 2.
			aPuttableStream cr.
			self 
				printIDLForVariable: each
				on: aPuttableStream
				indent: anInteger + 2.
			aPuttableStream cr].
	props notEmpty ifTrue: [aPuttableStream cr]!

printMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level method for the method described by the <FUNCDESC> first argument, calling the low-level method described by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. Answers nil to suppress generation of method, else self."

	^self
		printRawMethodBody: aFUNCDESC
		name: anAXMethodName
		on: aPuttableStream!

printMultiOutMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Generate the main body of a high-level method for the function described by the <FUNCDESC> first argument, invoking the low-level wrapper method named by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. The function has multiple output parameters, which is thankfully an unusual occurrence."

	| outputs params argumentNames hasRet |
	outputs := aFUNCDESC outputIndices.
	self assert: [outputs size > 1].

	"User might well want to write own wrapper in this case, as can employ knowledge of component perhaps to ignore outputs if they aren't really needed, but are simply the result of a careless VB component developer passing all parameters by reference, or perhaps to wrap up as an object."
	Notification
		signal: 'Warning: ' , self name , '.' , aFUNCDESC name , ' has ' , outputs size displayString
				, ' (possible) outputs that wrapper will return in an array.'.
	params := aFUNCDESC arguments.
	aPuttableStream
		nextPutAll: '| answer |';
		crtab;
		nextPutAll: 'answer := (Array new: ';
		print: outputs size;
		nextPut: $).
	argumentNames := anAXMethodName argumentNames.
	outputs keysAndValuesDo: 
			[:i :each |
			| arg |
			aPuttableStream
				crtab: 4;
				nextPutAll: 'basicAt: ';
				print: i;
				nextPutAll: ' put: '.
			arg := params at: each.
			arg isIn
				ifTrue: 
					[aPuttableStream
						nextPutAll: (argumentNames at: each);
						space;
						nextPutAll: #asVariant]
				ifFalse: 
					[aPuttableStream
						print: VARIANT;
						nextPutAll: ' new'].
			aPuttableStream nextPut: $;].
	aPuttableStream
		crtab: 4;
		nextPutAll: 'yourself.';
		crtab.

	"We only want to return another value if the receiver really has a return value"
	(hasRet := aFUNCDESC tdescFunc vt ~= VT_VOID)
		ifTrue: 
			[| retType |
			aPuttableStream nextPutAll: '^(Array with: ('.
			retType := aFUNCDESC classDesc.

			"If an interface pointer, then answer the correct type"
			((retType key includesBehavior: IUnknown) and: [retType value == 1])
				ifTrue: 
					[self printType: aFUNCDESC tdesc on: aPuttableStream.
					aPuttableStream nextPutAll: ' attachInterface: ']].
	aPuttableStream
		nextPutAll: '(self invokeId: ';
		display: aFUNCDESC memid;
		nextPutAll: ' withArguments:';
		crtab: 3;
		nextPutAll: '((Array new: ';
		display: aFUNCDESC cParams;
		nextPut: $).

	"Build an array of arguments for the less common case"
	anAXMethodName keywords keysAndValuesDo: 
			[:i :each |
			| iOut |
			aPuttableStream
				crtab: 4;
				nextPutAll: 'basicAt: ';
				display: i;
				nextPutAll: ' put: '.
			(iOut := outputs indexOf: i) == 0
				ifTrue: [aPuttableStream nextPutAll: (argumentNames at: i)]
				ifFalse: 
					["Output parameter"
					aPuttableStream
						nextPutAll: '(answer basicAt: ';
						print: iOut;
						nextPut: $)].
			aPuttableStream nextPut: $;].
	aPuttableStream
		crtab: 4;
		nextPutAll: 'yourself))'.
	hasRet
		ifTrue: 
			[aPuttableStream
				nextPutAll: ')), ';
				crtab: 2]
		ifFalse: 
			[aPuttableStream
				nextPut: $.;
				crtab;
				nextPut: $^].
	aPuttableStream
		nextPutAll: '(answer collect: [:each | each asObject])';
		cr!

printPropertyCommentDecl: aMemberDesc on: aPuttableStream
	aPuttableStream crtab: 2.
	self
		printIDLDecl: aMemberDesc name
		type: aMemberDesc tdesc
		on: aPuttableStream!

printPropGet: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream defaultOptionals: aBoolean
	"Private - Generate the main body of a  high-level accessor for the prop-get method described by the <FUNCDESC>, method. Answer nil if no method is to be emitted."

	^aBoolean
		ifTrue: 
			[self
				printDefaultMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream]
		ifFalse: 
			[self
				printRawPropGetBody: aFUNCDESC
				name: anAXMethodName
				on: aPuttableStream]!

printPropPut: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level accessor for the prop-put method described by the <FUNCDESC> first argument, calling the low-level method described by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. Answers nil to suppress generation of method, else self."

	^self
		printRawPropPutBody: aFUNCDESC
		name: anAXMethodName
		on: aPuttableStream!

printRawMethodBody: aFUNCDESC name: anAXMethodName on: aPuttableStream
	"Private - Print  an external function call for the member described by the <FUNCDESC> first argument, whose selector and arguments are as described in the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument."

	| argc id retType |
	id := aFUNCDESC memid.
	argc := aFUNCDESC cParams.

	"Could be one of the reserved member ids, some of which have 
		custom accessors in IDispatch. Sometimes these are not marked as propget when they should be."
	argc == 0
		ifTrue: 
			[SpecialPropGets at: id
				ifPresent: 
					[:p |
					^(p isNil or: [p isEmpty])
						ifFalse: 
							[aPuttableStream nextPutAll: p.
							self]]].
	aFUNCDESC hasMultipleOutputs
		ifTrue: 
			[^self
				printMultiOutMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream].
	aFUNCDESC hasReturnValue ifTrue: [aPuttableStream nextPut: $^].
	"For dispinterfaces we return the retval argument even from the raw method."
	retType := aFUNCDESC classDesc.

	"If an interface pointer, then answer the correct type"
	((retType key includesBehavior: IUnknown) and: [retType value == 1])
		ifTrue: 
			[self printType: aFUNCDESC tdesc on: aPuttableStream.
			aPuttableStream nextPutAll: ' attachInterface: '].
	aPuttableStream
		nextPutAll: '(self invokeId: ';
		display: id.
	argc < 3
		ifTrue: 
			["Use one of the optimized invoke forms for common argument counts"
			argc > 0
				ifTrue: 
					[anAXMethodName argumentNames do: 
							[:each |
							aPuttableStream
								nextPutAll: ' with: ';
								nextPutAll: each]]]
		ifFalse: 
			["Build an array of arguments for the less common case"
			aPuttableStream nextPutAll: ' withArguments: {'.
			anAXMethodName argumentNames do: [:each | aPuttableStream nextPutAll: each]
				separatedBy: [aPuttableStream nextPutAll: '. '].
			aPuttableStream nextPut: $}].
	aPuttableStream
		nextPut: $);
		cr!

printRawPropGetBody: aMemberDesc name: anAXMethodName on: aPuttableStream
	"Private - Print the code for accessing the (optionally subscripted) property described by the <MemberDesc> first argument on the <puttableStream> last argument."

	| id propType argc |
	id := aMemberDesc memid.
	argc := aMemberDesc argumentCount.
	"Could be one of the reserved member ids, some of which have 
		custom accessors in IDispatch"
	argc == 0
		ifTrue: 
			[SpecialPropGets at: id
				ifPresent: 
					[:propget |
					^(propget isNil or: [propget isEmpty])
						ifFalse: 
							[aPuttableStream nextPutAll: propget.
							self]]].
	aPuttableStream nextPut: $^.
	propType := aMemberDesc classDesc.
	"If an interface pointer, then answer the correct type"
	((propType key includesBehavior: IUnknown) and: [propType value == 1])
		ifTrue: 
			[self printType: aMemberDesc tdesc on: aPuttableStream.
			aPuttableStream nextPutAll: ' attachInterface: '].
	aPuttableStream
		nextPutAll: '(self getPropertyId: ';
		display: id.
	argc == 0
		ifFalse: 
			[| argumentNames |
			"Property is indexed"
			argumentNames := anAXMethodName argumentNames.
			argc == 1
				ifTrue: 
					[aPuttableStream
						nextPutAll: ' item: ';
						nextPutAll: argumentNames first]
				ifFalse: 
					["Property has more than one index (quite unusual)"
					aPuttableStream
						crtab: 2;
						nextPutAll: ' withArguments: ((Array new: ';
						display: argc;
						nextPut: $);
						crtab: 4.
					1 to: argc
						do: 
							[:i |
							aPuttableStream
								nextPutAll: 'basicAt: ';
								display: i;
								nextPutAll: ' put: ';
								nextPutAll: (argumentNames at: i);
								nextPut: $;;
								crtab: 4].
					aPuttableStream
						nextPutAll: 'yourself)';
						crtab: 2]].
	aPuttableStream
		nextPut: $);
		cr!

printRawPropPutBody: aMemberDesc name: anAXMethodName on: aPuttableStream
	"Private - Print the code for accessing the (optionally subscripted) property described by the <MemberDesc> argument, onto the <puttableStream> argument, using the most efficient property set method."

	| argc argumentNames |
	aPuttableStream
		nextPutAll: 'self setPropertyId: ';
		display: aMemberDesc memid;
		space.
	argumentNames := anAXMethodName argumentNames.
	argc := argumentNames size.
	argc > 1
		ifTrue: 
			["Property is indexed"
			argc > 2
				ifTrue: 
					["Property has more than one index (very unusual)"
					aPuttableStream
						crtab: 2;
						nextPutAll: 'withArguments: ((Array new: ';
						display: argc - 1;
						nextPut: $);
						crtab: 4.
					1 to: argc - 1
						do: 
							[:i |
							aPuttableStream
								nextPutAll: 'basicAt: ';
								display: i;
								nextPutAll: ' put: ';
								nextPutAll: (argumentNames at: i);
								nextPut: $;;
								crtab: 4].
					aPuttableStream
						nextPutAll: 'yourself)';
						crtab: 2]
				ifFalse: 
					[aPuttableStream
						nextPutAll: 'item: ';
						nextPutAll: argumentNames first;
						space]].
	aPuttableStream
		nextPutAll: 'value: ';
		nextPutAll: argumentNames last;
		cr! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #buildPropertyAccessorName:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #buildPropertyMutatorName:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generatePropertyAccessor:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generatePropertyAccessors!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generatePropertyMutator:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generateRawMethod:categories:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generateValuePropertyWrappers!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #isInspectablePropGet:!helpers!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #isProtocolRequired!private!testing! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printClassCommentPreambleOn:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printIDLOfPropertiesOn:indent:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printMethodBody:wrapping:on:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printMultiOutMethodBody:wrapping:on:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printPropertyCommentDecl:on:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printPropGet:wrapping:on:defaultOptionals:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printPropPut:wrapping:on:!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printRawMethodBody:name:on:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printRawPropGetBody:name:on:!printing!private! !
!OS.COM.TKindDispatchAnalyzer categoriesFor: #printRawPropPutBody:name:on:!printing!private! !

!OS.COM.TKindDispatchAnalyzer class methodsFor!

icon
	"Answers an Icon that can be used to represent this class"

	^IDispatch icon!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect sequenceableCollection: #properties) beReadOnly;
		yourself! !
!OS.COM.TKindDispatchAnalyzer class categoriesFor: #icon!constants!public! !
!OS.COM.TKindDispatchAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TKindEnumAnalyzer methodsFor!

constantsPool
	^self typeLib constantsPoolBinding value!

generateInstanceSide: aPoolConstantsDictionary 
	self generateConstantsIntoPool: aPoolConstantsDictionary!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment. Answer the object generated (in this case a 	<PoolConstantsDictionary>)."

	| var |
	var := self typeLib constantsPoolBinding.
	self assert: [var notNil].
	^var value!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes
	 for the receiver."

	| attrs |
	attrs := self basicIdlAttributes.
	self attributes cbSizeInstance == 4 ifTrue: [attrs addLast: 'v1_enum'].
	^attrs!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'enum'!

printIDLBodyOn: aPuttableStream indent: anInteger
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	| childIndent |
	aPuttableStream
		nextPutAll: self idlKeyword;
		space;
		nextPut: ${;
		cr.
	childIndent := anInteger + 1.
	self constants do: 
			[:each |
			aPuttableStream tab: childIndent.
			(self
				printIDLAttributes: each idlAttributes
				on: aPuttableStream
				indent: -1) ifTrue: [aPuttableStream space].
			aPuttableStream
				nextPutAll: each name;
				nextPutAll: ' = ';
				print: each lpvarValue value]
		separatedBy: 
			[aPuttableStream
				nextPut: $,;
				cr].
	aPuttableStream
		crtab: anInteger;
		nextPutAll: '} ';
		nextPutAll: self name;
		nextPut: $;;
		cr!

printIDLOn: target indent: tabs 
	"Print the IDL description of the receiver on the <puttableStream>, target."

	target
		tab: tabs;
		nextPutAll: 'typedef '.
	(self printIDLAttributesOn: target indent: -1) ifTrue: [target crtab: tabs].
	self printIDLBodyOn: target indent: tabs!

removeOldWrappers: aClass
	"Nothing to remove in this case"! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #constantsPool!public! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #generateInstanceSide:!private! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #printIDLOn:indent:!printing-IDL!public! !
!OS.COM.TKindEnumAnalyzer categoriesFor: #removeOldWrappers:!private! !

!OS.COM.TKindEnumAnalyzer class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect sequenceableCollection: #constants) beReadOnly;
		yourself! !
!OS.COM.TKindEnumAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TKindInterfaceAnalyzer methodsFor!

areWrappersRequired
	"Private - Answer whether a high-level wrappers are required in general."

	^(self generationFlags noMask: RawMethodsOnly) and: [super areWrappersRequired]!

functionHasReturnValue: aFUNCDESC
	"Private - Answer whether or not the function described by the <FUNCDESC>, method,
	has a significant return value."

	^aFUNCDESC tdesc vt ~= VT_HRESULT or: [aFUNCDESC hasRetval]!

generateClassInitialize
	"Private - Generate the class initialization methods for a custom interface wrapper."

	super generateClassInitialize.
	(self generationFlags anyMask: NoFunctionTable) ifFalse: [self generateDefineFunctions]!

generateDefineFunctions
	"Private - Generate the function table definition class method for the receiver."

	| target methods |
	(self canGenerateClassMessage: #defineFunctions) ifFalse: [^nil].
	methods := self methods.
	methods isEmpty ifTrue: [^self].
	target := String smalltalkWriteStream: 512.
	target
		nextPutAll: 'defineFunctions';
		crtab;
		nextPutAll: '"Declare the virtual function table for the COM interface ';
		print: self fullyQualifiedName;
		crtab: 2;
		display: self variableName;
		nextPutAll: ' defineTemplate'.
	self printAutoGenMethodPostambleOn: target.
	target nextPutAll: 'self'.
	methods do: 
			[:each |
			| retType params |
			self assert: [each callconv = CC_STDCALL].
			target
				crtab: 2;
				nextPutAll: 'defineFunction: #'.
			(self rawMethodNameForFunction: each) printSelectorOn: target.
			retType := each tdescFunc.
			retType vt == VT_HRESULT
				ifFalse: 
					[target
						crtab: 3;
						nextPutAll: 'returnType: '''.
					self printType: retType on: target.
					target nextPut: $'].
			params := each argumentTypes.
			params notEmpty
				ifTrue: 
					[target
						crtab: 3;
						nextPutAll: 'argumentTypes: '''.
					params do: [:eachParm | self printType: eachParm on: target] separatedBy: [target space].
					target nextPut: $']]
		separatedBy: [target nextPut: $;].
	target cr.
	self compileClassMethod: target contents categories: self classInitializerCategories!

generatePropertyAccessors
	"Private - Generate get/set wrappers for the properties accessible via the dispinterface.
	There are no properties associated with the receiver, so there is nothing to do."!

generateRawPropGet: aFUNCDESC
	"Private - Generate a wrapper for the propget function described by the <FUNCDESC> argument..
	Answer an <AXMethodName> containing selector keyword and argument information which can 
	be used to construct a call to the method."

	| methodName cats target |
	methodName := self rawMethodNameForFunction: aFUNCDESC.
	(self canGenerateMethodNamed: methodName) ifFalse: [^nil].
	cats := self rawPropCategories.
	target := String smalltalkWriteStream: 512.
	methodName printSignatureOn: target.
	target cr.
	self
		printRawPropGetComment: aFUNCDESC
		on: target
		isPrivate: (cats includes: 'private').
	self
		printRawPropGetBody: aFUNCDESC
		name: methodName
		on: target.
	self compileRawMethod: target contents categories: cats.
	^methodName!

generateRawPropPut: aFUNCDESC
	"Private - Generate a basic wrapper for the property put method
	described by the <FUNCDESC>, method. Answer selector keyword 
	and argument pair information which can be used to construct
	a call to the method."

	| methodName |
	methodName := self rawMethodNameForFunction: aFUNCDESC.
	(self canGenerateMethodNamed: methodName)
		ifTrue: 
			[| cats target |
			"Now emit the method body"
			cats := self rawPropCategories.
			target := String smalltalkWriteStream: 512.
			methodName printSignatureOn: target.
			target cr.
			self
				printRawPropPutComment: aFUNCDESC
				name: methodName
				on: target
				isPrivate: (cats includes: 'private').
			self
				printRawPropPutBody: aFUNCDESC
				name: methodName
				on: target.
			self compileRawMethod: target contents categories: cats].
	^methodName!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes
	 for the receiver."

	| attrs |
	attrs := super idlAttributes.
	self isDual 
		ifTrue: [attrs addLast: 'dual']
		ifFalse: [self isAutomationCompatible ifTrue: [attrs addLast: 'oleautomation']].
	^attrs
		addFirst: 'object';
		yourself!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'interface'!

isInspectablePropGet: aFUNCDESC 
	^(super isInspectablePropGet: aFUNCDESC) and: [aFUNCDESC argumentCount = 1]!

isMethodWrapperRequiredFor: aFUNCDESC
	"Private - Answer whether a high-level wrapper for the function described by the 
	<FUNCDESC> argument should be generated."

	^self areWrappersRequired and: 
			[(self generationFlags noMask: MinimizeWrappers) 
				or: [aFUNCDESC arguments anySatisfy: [:each | each isVariant or: [each isOut]]]]!

printClassCommentPreambleOn: target
	"Private - Print a comment preamble appropriate for the receiver onto the 
	<puttableStream>, target."

	| lib |
	lib := self typeLib.
	target
		nextPut: $`;
		nextPutAll: self variableName;
		nextPutAll: '` is a wrapper class for the COM interface ';
		print: self fullyQualifiedName;
		nextPutAll: ' generated from type information in the ''';
		nextPutAll: lib helpstring;
		nextPutAll: ''' library. It contains methods to invoke the member functions exposed by that interface.'!

printIDLBodyOn: target indent: tabs 
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	| base |
	super printIDLBodyOn: target indent: tabs.
	base := self superInterface.
	base isNil 
		ifFalse: 
			[target
				nextPutAll: ' : ';
				nextPutAll: base name].
	target
		crtab: tabs;
		nextPutAll: ' {'.
	self methods do: 
			[:m | 
			target crtab: tabs + 1.
			self 
				printIDLForFunction: m
				on: target
				indent: tabs + 1].
	target
		crtab: tabs;
		nextPutAll: '};';
		cr!

printMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level method for the method described by the <FUNCDESC> first argument, calling the low-level method described by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument.
	Answers nil to suppress generation of method, else self."

	| params nRet |
	aFUNCDESC hasMultipleOutputs
		ifTrue: 
			[^self
				printMultiOutMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream].
	params := aFUNCDESC arguments.
	(nRet := aFUNCDESC retvalIndex) ~= 0
		ifTrue: 
			[| answerDesc |
			aPuttableStream
				nextPutAll: '| answer |';
				crtab;
				nextPutAll: 'answer := '.
			answerDesc := aFUNCDESC classDesc.
			answerDesc key
				printMethodArgument: (anAXMethodName argumentNames at: nRet)
				elemdesc: (params at: nRet)
				indirections: answerDesc value
				on: aPuttableStream
				for: self.
			aPuttableStream
				nextPut: $.;
				crtab].

	"If there is no output argument, then answer any return value from the raw method, even if it is just an HRESULT because sometimes HRESULT success codes contain useful information.
	 However for compatibility with Smalltalk inst. var. setter methods we still want to return the receiver for property setters."
	(nRet == 0 and: [aFUNCDESC hasAnswer]) ifTrue: [aPuttableStream nextPut: $^].

	"Print call to raw method"
	aPuttableStream nextPutAll: 'self'.
	params isEmpty
		ifTrue: 
			[aPuttableStream
				space;
				nextPutAll: anAXMethodName primary]
		ifFalse: 
			[| argumentNames keywords argc |
			"Print keyword arg pairs"
			argumentNames := anAXMethodName argumentNames.
			keywords := anAXMethodName keywords.
			argc := keywords size.
			1 to: argc
				do: 
					[:each |
					| keyword |
					keyword := keywords at: each.
					aPuttableStream
						space;
						nextPutAll: keyword;
						space.
					each == nRet
						ifTrue: [aPuttableStream nextPutAll: 'answer']
						ifFalse: 
							[| arg desc |
							arg := params at: each.
							desc := arg classDesc.
							desc key
								printMethodArgument: (argumentNames at: each)
								elemdesc: arg
								indirections: desc value
								on: aPuttableStream
								for: self]]].
	nRet ~= 0
		ifTrue: 
			[aPuttableStream
				nextPut: $.;
				crtab;
				nextPutAll: '^answer asObject']!

printMultiOutMethodBody: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Generate the main body of a high-level method for the function described by the <FUNCDESC> first argument, invoking the low-level wrapper method named by the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument. 
	The function has multiple output parameters, which is thankfully an unusual occurrence."

	| outputs params argumentNames |
	outputs := aFUNCDESC outputIndices.
	self assert: [outputs size > 1].

	"User might well want to write own wrapper in this case, as can employ knowledge of component perhaps to ignore outputs if they aren't really needed, but are simply the result of a careless VB component developer passing all parameters by reference, or perhaps to wrap up as an object."
	Notification
		signal: 'Warning: ' , self name , '.' , aFUNCDESC name , ' has ' , outputs size displayString
				, ' (possible) outputs that wrapper will return in an array.'.
	params := aFUNCDESC arguments.
	aPuttableStream
		nextPutAll: '| outputs |';
		crtab;
		nextPutAll: 'outputs := {'.
	argumentNames := anAXMethodName argumentNames.
	outputs do: 
			[:each |
			| arg desc |
			arg := params at: each.
			desc := arg classDesc.
			desc key
				printMethodArgument: (argumentNames at: each)
				elemdesc: arg
				indirections: desc value
				on: aPuttableStream
				for: self]
		separatedBy: [aPuttableStream nextPutAll: '. '].
	aPuttableStream
		nextPutAll: '}.';
		crtab.
	"Now call the API function"
	aPuttableStream nextPutAll: 'self'.
	anAXMethodName keywords keysAndValuesDo: 
			[:i :each |
			| iOut |
			aPuttableStream
				space;
				nextPutAll: each;
				space.
			(iOut := outputs indexOf: i) == 0
				ifTrue: 
					[| arg desc |
					"Input only parameter"
					arg := params at: i.
					desc := arg classDesc.
					desc key
						printMethodArgument: (argumentNames at: i)
						elemdesc: arg
						indirections: desc value
						on: aPuttableStream
						for: self]
				ifFalse: 
					["Output parameter"
					aPuttableStream
						nextPutAll: '(outputs basicAt: ';
						print: iOut;
						nextPut: $)]].

	"Return the array of outputs converted to objects"
	aPuttableStream
		nextPut: $.;
		crtab;
		nextPutAll: '^outputs collect: [:each | each asObject]'!

printPropertyCommentDecl: aFUNCDESC on: aPuttableStream
	"Implementtion Note: The IDL decl for the property can be seen in the raw wrapper."!

printPropGet: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream defaultOptionals: aBoolean 
	"Private - Generate the main body of a  high-level accessor for the prop-get method described 
	by the <FUNCDESC>, method. Answer nil if no method is to be emitted."

	^aBoolean 
		ifTrue: 
			[self 
				printDefaultMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream]
		ifFalse: 
			[self 
				printMethodBody: aFUNCDESC
				wrapping: anAXMethodName
				on: aPuttableStream]!

printPropPut: aFUNCDESC wrapping: anAXMethodName on: aPuttableStream
	"Private - Print the main body of a  high-level accessor for the prop-put method described 
	by the <FUNCDESC> argument, calling the low-level method described by the <AXMethodName>
	argument, onto the <puttableStream> argument. Answers nil to suppress generation of method, else self."

	^self 
		printMethodBody: aFUNCDESC
		wrapping: anAXMethodName
		on: aPuttableStream!

printRawMethodBody: aFUNCDESC name: anAXMethodName on: aPuttableStream
	"Private - Print  an external function call for the member described by the <FUNCDESC> 
	argument, whose selector and arguments are as described in the <AXMethodName> argument, 
	onto the <puttableStream> argument."

	aPuttableStream
		nextPutAll: '<virtual ';
		nextPutAll: aFUNCDESC callingConvention;
		space.
	"Here we want to print the actual return type of the function, as opposed to any retval argument."
	self printType: aFUNCDESC tdescFunc on: aPuttableStream.
	aPuttableStream
		space;
		display: aFUNCDESC vfnIndex.
	aFUNCDESC argumentTypes do: 
			[:each |
			aPuttableStream space.
			self printType: each on: aPuttableStream].
	aPuttableStream
		nextPut: $>;
		crtab;
		nextPutAll: '^self invalidCall: _failureCode'!

printRawPropGetComment: aFUNCDESC on: aPuttableStream isPrivate: aBoolean 
	self printCommentPrefixOn: aPuttableStream isPrivate: aBoolean.
	aPuttableStream
		nextPutAll: 'Get the value of the ''';
		nextPutAll: aFUNCDESC name;
		nextPutAll: ''' property of the receiver.'.
	aPuttableStream
		cr;
		cr.
	self printFunctionPrototypeComment: aFUNCDESC on: aPuttableStream.
	self printMethodCommentPostamble: aFUNCDESC on: aPuttableStream!

printRawPropPutComment: aFUNCDESC name: anAXMethodName on: aPuttableStream isPrivate: aBoolean
	self printCommentPrefixOn: aPuttableStream isPrivate: aBoolean.
	aPuttableStream
		nextPutAll: 'Set the value of the ''';
		nextPutAll: aFUNCDESC name;
		nextPutAll: ''' property of the object wrapped by the ';
		crtab;
		nextPutAll: ' receiver to the <'.
	self printType: aFUNCDESC arguments last tdesc on: aPuttableStream.
	aPuttableStream
		nextPutAll: '> argument, ';
		nextPutAll: anAXMethodName argumentNames last;
		nextPut: $.;
		cr;
		cr.
	self printFunctionPrototypeComment: aFUNCDESC on: aPuttableStream.
	self printMethodCommentPostamble: aFUNCDESC on: aPuttableStream!

rawMethodNameForFunction: aFUNCDESC
	"Private - Answer an <AXMethodName> describing the selector keywords
	and argument names to be used for a raw wrapper method for the function
	described by the <FUNCDESC> argument."

	| name keywords primary size |
	name := aFUNCDESC methodName.
	keywords := name keywords.
	primary := aFUNCDESC isMethod
				ifTrue: [keywords first capitalized]
				ifFalse: 
					[(aFUNCDESC isPropGet
						ifTrue: ['get_']
						ifFalse: 
							[aFUNCDESC isPropPutRef
								ifTrue: ['putref_']
								ifFalse: 
									[self assert: [aFUNCDESC isPropPut].
									'put_']])
							, keywords first].
	size := keywords size.
	keywords := (Array new: size)
				at: 1 put: primary;
				replaceFrom: 2
					to: size
					with: keywords
					startingAt: 2;
				yourself.
	^Tools.AXMethodName
		keywords: (self reinventBadSelector: keywords member: aFUNCDESC)
		argumentNames: name argumentNames
		indices: name indices! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #areWrappersRequired!private!testing! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #functionHasReturnValue:!helpers!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #generateClassInitialize!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #generateDefineFunctions!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #generatePropertyAccessors!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #generateRawPropGet:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #generateRawPropPut:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #isInspectablePropGet:!enumerating!helpers!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #isMethodWrapperRequiredFor:!private!testing! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printClassCommentPreambleOn:!printing!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printMethodBody:wrapping:on:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printMultiOutMethodBody:wrapping:on:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printPropertyCommentDecl:on:!printing!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printPropGet:wrapping:on:defaultOptionals:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printPropPut:wrapping:on:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printRawMethodBody:name:on:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printRawPropGetComment:on:isPrivate:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #printRawPropPutComment:name:on:isPrivate:!private! !
!OS.COM.TKindInterfaceAnalyzer categoriesFor: #rawMethodNameForFunction:!helpers!private! !

!OS.COM.TKindModuleAnalyzer methodsFor!

areWrappersRequired
	"Private - Answer whether a high-level wrappers are required in general."
	
	^false!

generateClassFilename
	"Private - Generate the class side #fileName method which answers the file name stem of the DLL
	which the receiver describes."

	| name target |
	(self canGenerateClassMessage: #fileName) ifFalse: [^nil].
	name := File splitStemFrom: (self dllNameIfNone: [^nil]).
	target := String smalltalkWriteStream: 256.
	target
		nextPutAll: 'fileName';
		crtab;
		nextPutAll: '"Answer the host system file name for the library.'.
	self printAutoGenMethodPostambleOn: target.
	target
		nextPut: $^;
		print: name;
		cr.
	self compileClassMethod: target contents categories: self classConstantsCategories!

generateClassSide: aClass
	self generateClassFilename.
	self generateClassComment!

generateInstanceSide: aClass
	self generateMethodWrappers!

generateMethodWrappers
	"Private - Generate a method to wrap each of the functions in the module described by the
	receiver."

	self functions do: [:each | self generateMethodWrappers: each]!

generateWrapper
	"Private - Generate a new subclass of IDispatch which wraps the  properties and methods 
	of the dispinterface described the the receiver's ITypeInfo.
	Answer the object generated (in this case a <COMInterface> subclass)."

	| class |
	class := self functions notEmpty ifTrue: [super generateWrapper].
	self generateConstants.
	^class!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes
	 for the receiver."

	^super idlAttributes addFirst: 'dllname("', (self dllNameIfNone: ['<Unknown>']), '")'; yourself!

idlAttributesOfFunc: aFUNCDESC
	"Private - Answer a <sequencedReadableCollection> of IDL attribute strings for the receiver."

	^{'entry("%s")' sprintfWith: aFUNCDESC name} , aFUNCDESC idlAttributes!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'module'!

instanceMethodCategories: aBoolean
	"Private - Answer a collection of categories with which instance side methods are to be associated. The <boolean>
	argument indicates whether the categories are for a public or private method."

	^{self autoGenCategoryName. aBoolean ifTrue: ['private'] ifFalse: ['public']}!

methodCommentDescription
	^'function of the module wrapped by the receiver'!

mungeSelectorKeywords: aSequencedReadableCollection forMember: aFUNCDESC 
	"#1332: Override in order to generate Dolphin Smalltalk format external library call selectors (as
	documented in the 'External Method Selector' pattern, see
	http://www.object-arts.com/Lib/EducationCentre4/htm/externalmethodselector.htm"

	| keywords |
	keywords := aSequencedReadableCollection collect: [:each | self identifierFrom: each].
	^self reinventBadSelector: keywords member: aFUNCDESC!

printClassCommentPreambleOn: target
	"Private - Print a comment preamble appropriate for the receiver onto the 
	<puttableStream>, target."

	| lib |
	lib := self typeLib.
	target
		nextPutAll: self variableName;
		nextPutAll: ' is the `ExternalLibrary` class to represent the dynamic link library, ';
		print: (self dllNameIfNone: ['(anon)']);
		nextPut: $.;
		nextPutAll: 'It was generated generated from type information in the ';
		print: lib helpstring;
		nextPutAll: ' library. It contains methods for each of the functions defined by the corresponding module in that type library.'!

printIDLBodyOn: target indent: tabs 
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	| childIndent vars |
	childIndent := tabs + 1.
	super printIDLBodyOn: target indent: tabs.
	target
		crtab: tabs;
		nextPut: ${.
	vars := self variables.
	vars do: 
			[:each | 
			target crtab: childIndent.
			self 
				printIDLForVariable: each
				on: target
				indent: tabs + 1].
	vars isEmpty ifFalse: [target cr].
	self functions do: 
			[:each | 
			target crtab: tabs + 1.
			self 
				printIDLForFunction: each
				on: target
				indent: tabs + 1].
	target
		crtab: tabs;
		nextPutAll: '};';
		cr!

printMethod: aFUNCDESC wrapping: anAXMethodName on: puttableStream
	"Private -Print a high-level wrapper for the function described 
	by the <FUNCDESC> argument onto the <puttableStream> argument.
	Answer an <AXMethodName> naming the printed method, or nil if 
	none should be generated."

	^nil!

printRawMethodBody: aFUNCDESC name: anAXMethodName on: aPuttableStream
	"Private - Print  an external function call for the member described by the <FUNCDESC> first argument, whose selector and arguments are as described in the <AXMethodName> 2nd argument, onto the <puttableStream> 3rd argument."

	| entry procName |
	aPuttableStream
		nextPut: $<;
		nextPutAll: aFUNCDESC callingConvention;
		space.
	"Here we want to print the actual return type of the function, as opposed to any retval argument."
	self printType: aFUNCDESC tdescFunc on: aPuttableStream.
	aPuttableStream space.
	entry := self getDllEntry: aFUNCDESC.
	procName := (entry at: 2) trimBlanks.
	procName isEmpty
		ifTrue: 
			[procName := entry at: 3.
			procName = 0 ifTrue: [procName := aFUNCDESC name]].
	aPuttableStream display: procName.
	aFUNCDESC argumentTypes do: 
			[:each |
			aPuttableStream space.
			self printType: each on: aPuttableStream].
	aPuttableStream
		nextPut: $>;
		crtab;
		nextPutAll: '^self invalidCall: _failureCode'! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #areWrappersRequired!private!testing! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #generateClassFilename!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #generateClassSide:!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #generateInstanceSide:!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #generateMethodWrappers!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #idlAttributesOfFunc:!printing-IDL!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #instanceMethodCategories:!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #methodCommentDescription!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #mungeSelectorKeywords:forMember:!helpers!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #printClassCommentPreambleOn:!printing!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #printMethod:wrapping:on:!private! !
!OS.COM.TKindModuleAnalyzer categoriesFor: #printRawMethodBody:name:on:!private! !

!OS.COM.TKindModuleAnalyzer class methodsFor!

icon
	"Answers an <Icon> that can be used to represent this class"

	^External.DynamicLinkLibrary icon!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect dictionary: #functionsByName) beReadOnly;
		yourself! !
!OS.COM.TKindModuleAnalyzer class categoriesFor: #icon!constants!public! !
!OS.COM.TKindModuleAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TKindRecordAnalyzer methodsFor!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'struct'! !
!OS.COM.TKindRecordAnalyzer categoriesFor: #idlKeyword!constants!private! !

!OS.COM.TKindUnionAnalyzer methodsFor!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^'union'! !
!OS.COM.TKindUnionAnalyzer categoriesFor: #idlKeyword!constants!private! !

!OS.COM.TYPEDESC methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self isAnonymous
		ifTrue: 
			[aStream
				nextPutAll: 'Anon: ';
				print: self typeInfo name]
		ifFalse: [aStream print: self typeName].
	aStream nextPut: $)! !
!OS.COM.TYPEDESC categoriesFor: #printOn:!development!printing!public! !

!OS.COM.TypeInfoAnalyzer methodsFor!

autoGenCategoryName
	"Private - Answer the name of the special method category for auto-generated
	methods."

	^'**auto generated**'!

autoGenClassCommentMarker
	^'** This comment was automatically generated from a type library. Delete this line to prevent any manual edits from being overwritten if the wrapper class is regenerated.'!

autoGenMethodComment
	"Private - Answer a suitable piece of comment to warn the user that a
	method is automatically generated and should not be modified.
	By default we don't add any such comment, in order to avoid making the
	source files very large."

	^''!

baseClassCheck: aVariableBinding
	"Private - The receiver's global is already present, check to make sure it has the same superclass
	and if not ask the user for confirmation that it is OK to overwrite it. Answer whether to plough
	ahead or prompt for a new name."

	^(self conformsToRequiredProtocols: aVariableBinding)
		or: [self typeLib superclassClashSignal signal: self with: aVariableBinding]!

basicGenerate
	"Generate appropriate Dolphin objects to wrap the type described
	by the receiver. What happens exactly will differ vastly depending on the
	subclass."

	generationFlags := nil.		"Pick up generation flags from the typeLib"
	^self generateWrapper
!

canGenerateClassMessage: selector
	"Private - Answer whether an auto-generated method implementing the message with
	the specified symbolic selector can be safely generated into the class side of the receiver's 
	wrapper class."

	^self isTraceOnly or: [self canGenerateMessage: selector into: self programObject class]!

canGenerateMessage: aSymbol
	"Private - Answer whether an auto-generated method implementing the message with
	the specified symbolic selector can be safely generated into the receiver's associated
	wrapper class."

	^self isTraceOnly or: [self canGenerateMessage: aSymbol into: self programObject]!

canGenerateMessage: aSymbol into: aClass
	"Private - Answer whether an auto-generated method implementing the message with
	the specified symbolic selector can be safely generated into the <ClassDescription>, class.
	The purpose of this test is to avoid overwriting hand written methods of the same
	name, or perhaps to avoid overriding certain critical selectors."

	^(aClass includesSelector: aSymbol asSymbol)
		ifTrue: 
			[Notification signal: ('Warning: Wrapper method <1p>>><2s> not generated due to selector clash.'
						expandMacrosWith: aClass
						with: aSymbol).
			false]
		ifFalse: [true]!

canGenerateMethodNamed: anAXMethodName
	"Private - Answer whether an auto-generated method implementing the message with
	the name (keyword and arguments) can be safely generated into the receiver's associated
	wrapper class."

	^self isTraceOnly or: [self canGenerateMessage: anAXMethodName selector into: self programObject]!

checkConformanceOfExistingClass: aVariableBinding
	"Private - Check that the existing global with the specified binding is compatible
	with the receiver, and warn the user if not. Answers whether the global should
	be used, or an attempt should be made to find another one."

	^aVariableBinding isUnbound or: 
			[(self isClassCheck: aVariableBinding) and: 
					[(self guidCheck: aVariableBinding)
						and: [(self baseClassCheck: aVariableBinding) and: [self packageCheck: aVariableBinding]]]]!

classCategories
	"Private - Answer a <Set> of the class categories to which any class generated for
	the receiver should be added."

	| catName |
	catName := self idlKeyword.
	catName := String smalltalkWriteStream
				nextPutAll: self typeLib name;
				nextPut: $-;
				nextPutAll: catName capitalized;
				nextPutAll: (catName last asLowercase = $s ifTrue: ['es'] ifFalse: ['s']);
				contents.
	^Set with: (self class classCategoryClass name: catName)!

classConstantsCategories
	"Private - Answer the <collection> of method categories for class side constant accessor
	methods generated into the wrapper class.
	We don't specify a privacy category, but let the class decide as appropriate when compiling."

	^{self autoGenCategoryName. 'constants'}!

classInitializerCategories
	"Private - Answer the <collection> of method categories for non-specific auto-generated methods.
	We don't specify a privacy category, but let the class decide as appropriate when compiling."

	^{self autoGenCategoryName. 'initializing'}!

compileClassMethod: aString categories: categories
	"Private - Generate the method or send to trace, depending on the mode."

	(self generationFlags anyMask: Trace) ifTrue: [Notification signal: aString].
	^self isTraceOnly ifFalse: [self programObject class compile: aString categories: categories]!

compileMethod: aString categories: aCollection
	"Private - Generate the method or send to trace, depending on the mode."

	aString isEmpty ifTrue: [^nil].
	(self generationFlags anyMask: Trace) ifTrue: [Notification signal: aString].
	^self isTraceOnly
		ifFalse: 
			[| class source |
			class := self programObject.
			source := Smalltalk developmentSystem reformatSource: aString in: class.
			class compile: source categories: aCollection]!

compileRawMethod: aString categories: categories
	"Private - Generate the method or send to trace, depending on the mode."

	^self compileMethod: aString categories: categories!

compileTestingMethod: aString
	"Private - Generate a 'testing' method or send to trace, depending on the mode."

	self compileMethod: aString categories: {self autoGenCategoryName. 'testing'. 'public'}!

conformsToRequiredProtocols: aVariableBinding
	"Private - Answer whether the global object with the specified binding conforms to all the necessary
	class and instance <MethodProtocol>s."

	"If it doesn't currently inherit from our usual base class, we'll need to see if it implements the relevant protocols"

	^aVariableBinding value inheritsFrom: self baseClass!

constantsPool
	^self typeLib constantsPool!

determineNewBase: baseClass forExistingWrapper: existingClass 
	"Answer the superclass for the wrapper class generated by the receiver when 
	modifying an existing wrapper class. By default the existing superclass is
	maintained."

	^existingClass superclass!

emitComment: aString on: aPuttableStream 
	(aString identityIncludes: $") 
		ifTrue: 
			[aString do: 
					[:each | 
					"Replace double quotes with single quotes"

					each == $" ifTrue: [aPuttableStream nextPut: $'] ifFalse: [aPuttableStream nextPut: each]]]
		ifFalse: [aPuttableStream nextPutAll: aString].
	^aString!

generate
	"Generate appropriate Dolphin objects to wrap the type described
	by the receiver. Handle any name or guid clashes by popping appropriate
	"

	^[self basicGenerate] 
		on: self guidClashSignal
		do: [:e | self handleClash: e response: (self guidClashPrompt: e tag)]
		on: self typeLib superclassClashSignal
		do: [:e | self handleClash: e response: (self superclassClashPrompt: e tag)]!

generateAs: aString flags: anInteger
	"Generate a new global object with the <readableString> name, global,
	including any possible wrapping of the type information such as an
	IDispatch subclass with wrapper methods for the properties and member
	functions of the dispinterface described by the ITypeInfo. "

	self variableName: aString.
	generationFlags := anInteger.
	^self generateWrapper!

generateClassComment
	"Private - Extract any help string associated with the interface described by the
	receiver and use it to construct a class comment. This will probably be pretty
	limited, but there might be something useful there."

	| stm helpstring flags idlkey class |
	(self generationFlags allMask: NoClassComment) ifTrue: [^self].
	stm := String writeStream: 512.
	self printClassCommentPreambleOn: stm.
	stm
		cr;
		cr.
	helpstring := self helpstring.
	idlkey := self idlKeyword.
	helpstring isEmpty
		ifTrue: 
			[stm
				nextPutAll: 'The type library contains no documentation for this ';
				nextPutAll: idlkey]
		ifFalse: 
			[stm
				nextPutAll: 'The type library contains the following helpstring for this ';
				nextPutAll: idlkey;
				crtab;
				nextPut: $";
				nextPutAll: helpstring;
				nextPut: $"].
	stm
		cr;
		cr;
		nextPutAll: self autoGenClassCommentMarker;
		cr.
	self includeIDLInClassComment
		ifTrue: 
			[stm
				cr;
				nextPutAll: 'IDL definition follows:';
				cr;
				nextPutAll: '```';
				cr.
			self printIDLOn: stm.
			stm
				nextPutAll: '```';
				cr].
	flags := self generationFlags.
	(flags anyMask: Trace) ifTrue: [Notification signal: stm contents].
	self isTraceOnly ifTrue: [^self].
	class := self programObject.
	self shouldOverwriteClassComment
		ifTrue: [class comment: stm contents]
		ifFalse: 
			[(flags allMask: Verbose)
				ifTrue: [Notification signal: 'Existing class comment for ' , self name , ' not overwritten']]!

generateClassDefinition: aVariableBinding imports: anArray
	"Private - Generate and answer a new class to wrap the type described by the receiver."

	^self typeLib
		generateClass: aVariableBinding
		for: self
		imports: anArray!

generateClassSide: aClass
	"By default, do nothing."!

generateConstants
	| pool |
	pool := self constantsPool.
	self generateConstantsIntoPool: pool!

generateConstantsIntoPool: aSharedPool
	(self generationFlags anyMask: Verbose)
		ifTrue: 
			[Notification signal: ('Generating constants for <1s> <2s> into pool <3s>'
						expandMacrosWith: self idlKeyword
						with: self name
						with: aSharedPool name)].
	self constants do: [:each | aSharedPool at: each name put: each lpvarValue value]!

generateInstanceSide: aClass
	"By default, do nothing. To be overridden by subclasses where necessary."!

generateVariableDefinition
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	^self generateVariableDefinition: self binding!

generateVariableDefinition: aVariableBinding
	"Private - Generate a minimal definition of the receiver which will enable it to be seen,
	if not heard, in the development environment."

	^self subclassResponsibility!

generateWrapper
	"Private - Generate a new subclass of IDispatch which wraps the  properties and methods 
	of the dispinterface described the the receiver's ITypeInfo.
	Answer the object generated (in this case a <COMInterface> subclass)."

	| class |
	class := self generateVariableDefinition.
	self removeOldWrappers: class.
	self generateClassSide: class.
	self generateInstanceSide: class.
	^class!

generationFlags
	"Answer the value of the receiver's 'generationFlags' instance variable."

	generationFlags isNil ifTrue: [generationFlags := self typeLib generationFlags].
	^generationFlags!

guidCheck: aVariableBinding
	"Private - The receiver's global is already present, check to make sure it has the same GUID
	and if not ask the user for confirmation that it is OK to overwrite it. Answer whether to plough
	ahead."

	| myId hisId value |
	value := aVariableBinding value.
	myId := self guid.
	hisId := value guid.
	(myId notNull and: [myId ~= hisId])
		ifTrue: 
			[(self guidClashSignal signal: self with: aVariableBinding) ifFalse: [^false].
			"Handler ignored, so assert our guid!!"
			value guid: myId].
	^true!

guidClashPrompt: aVariableBinding
	"Private - Prompt the user as to how they wish to resolve a guid clash."

	| type mb |
	type := self idlKeyword.
	mb := UI.MessageBox new.
	mb iconStyle: #warning.
	mb
		text: ('The proposed class name <1p> clashes with an existing class in the <2p> package which has a different GUID.
This may be due to a name clash, or because, for example, an interface has been updated

Are you sure that you would like to overwrite it?

Press Retry to suggest an alternative name for the <3s>, Ignore to overwrite, or Abort to quit.'
				expandMacrosWith: aVariableBinding key
				with: aVariableBinding value owningPackage name
				with: type).
	mb
		buttonStyle: #abortRetryIgnore;
		defaultButton: 2.
	mb caption: ('Dolphin Type Library Analyzer: Generating <1s> <2s>.<3d>'
				expandMacrosWith: type
				with: self typeLib name
				with: self).
	^mb open!

handleClash: exception response: userResponseSymbol 
	"Private- The user has responded to a clash prompt with a resolution.
	This must be called inside the handler for the <Exception> argument, exception.
	The result will be to abort the generation process, or to resume from the point
	where the clash was signalled with true to ignore, or false to 'retry'."

	userResponseSymbol == #abort ifTrue: [self abortGeneration].
	exception resume: userResponseSymbol == #ignore!

identifierFrom: name
	"Private - Answer a Smalltalk compliant identifier from the 
	<readableString>, name, which is a raw identifier from a type library.
	Uses the following rules.
		func -> func
		Func -> func
		XFunc -> xFunc
		FUNC -> func
	Any leading underscores are preserved, but ignored.
	"
	| firstAlpha firstLower size leadingUppers |
	firstAlpha := 1.
	size := name size.
	[firstAlpha <= size and: [(name at: firstAlpha) == $_]] whileTrue: [firstAlpha := firstAlpha + 1].
	firstLower := firstAlpha.
	[firstLower <= size and: [(name at: firstLower) isLowercase not]] whileTrue: [firstLower := firstLower + 1].

	firstLower > size ifTrue: [ "eg. FUNC -> func"
		^name asLowercase].

	^(leadingUppers := firstLower - firstAlpha) == 0
		ifTrue: [name "eg. func -> func"]
		ifFalse: [
			"eg. XFunc -> xFunc, Func -> func, of FUNCTwo -> funcTwo"
			| mid |
			mid := leadingUppers min: 2.
			(name copyFrom: 1 to: (firstLower-mid)) asLowercase, 
				(name copyFrom: firstLower-mid+1 to: size)]!

idlTypeOfVT: vt
	"Private - Answer a <readableString> 'C' type name for the <VARENUM> argument, vt."

	^VTtoIDLTypeMap at: vt!

isClassCheck: aVariableBinding
	"Private - The receiver's global is already present, check to make sure it is actually a class."

	| value resp mb |
	value := aVariableBinding value.
	value class isMeta ifTrue: [^true].
	mb := UI.MessageBox new.
	mb iconStyle: #warning.
	mb
		text: ('Class name <1p> clashes with an existing global which is not a class (a <2p>).

Press OK to suggest an alternative name for the <3s>, or Cancel to abort.'
				expandMacrosWith: aVariableBinding key
				with: aVariableBinding value class
				with: self idlKeyword).
	mb caption: ('Dolphin Type Library Analyzer: Generating <1s> <2s>.<3s>'
				expandMacrosWith: self idlKeyword
				with: self typeLib name
				with: self name).
	mb buttonStyle: #okCancel.
	resp := mb open.
	resp == #cancel ifTrue: [self abortGeneration].
	^false	"Binding not acceptable - please try a new one"!

packageCheck: anAssociation
	"Private - The receiver's variable is already present, check to make sure it it in the same package,
	and if not ask the user whether or not to relocate it. Note that this method never answers false,
	so the user never gets a chance to try a different name."

	| value myPackageName hisPackage |
	value := anAssociation value.
	myPackageName := self typeLib packageName.
	hisPackage := value owningPackage ?? Package uncommitted.
	(myPackageName = hisPackage name or: [hisPackage isSystemPackage])
		ifFalse: 
			[| resp type mb |
			type := self idlKeyword.
			mb := UI.MessageBox new.
			mb iconStyle: #warning.
			mb
				text: ('The <1s> <2s> already exists in the <3p> package.<n>
Would you like to move it to the <4p> package?<n>
Press Yes to move the class, No to leave it where it is, or Cancel to abort'
						expandMacrosWith: type
						with: anAssociation key
						with: hisPackage name
						with: myPackageName).
			mb caption: ('Dolphin Type Library Analyzer: Generating <1s> <2s>.<3d>'
						expandMacrosWith: type
						with: self typeLib name
						with: self).
			mb
				buttonStyle: #yesNoCancel;
				defaultButton: 2.
			resp := mb open.	"Default to No, to leave as is"
			resp == #cancel ifTrue: [self abortGeneration].
			resp == #yes ifTrue: [self typeLib moveClassToPackage: value]].
	^true!

printAutoGenMethodPostambleOn: target 
	"Private - Print a comment to the effect that this is an autogenerated method on the
	<puttableStream>, target."

	| cmt |
	cmt := self autoGenMethodComment.
	cmt notEmpty 
		ifTrue: 
			[target
				crtab;
				nextPutAll: cmt].
	target
		nextPut: $";
		cr;
		crtab!

printClass: aClass on: aPuttableStream
	| myNamespace |
	myNamespace := self environment.
	(aClass environment == myNamespace or: 
			[| var |
			var := myNamespace fullBindingFor: aClass name.
			var notNil and: [var value == aClass]])
		ifTrue: [aPuttableStream nextPutAll: aClass name]
		ifFalse: [aPuttableStream nextPutAll: aClass fullName]!

printClassCommentPreambleOn: target
	"Private - Print a comment preamble appropriate for the receiver onto the 
	<puttableStream>, target."

	^self subclassResponsibility!

printHelpstringComment: aMemberDesc on: aPuttableStream
	"Private - Print the helpstring, if any, for the <MemberDesc> first argument, onto the <puttableStream> last argument. Answer whether any helpstring was printed."

	| help |
	help := aMemberDesc helpstring.
	^help isEmpty
		ifTrue: [false]
		ifFalse: 
			[aPuttableStream
				crtab;
				nextPutAll: 'Helpstring: '.
			self emitComment: help on: aPuttableStream.
			true]!

printIDLDecl: aString type: aTYPEDESC on: aPuttableStream
	"Private - Print a <readableString> IDL-style description of the <TYPEDESC> argument onto
	the <puttableStream> argument. This may involve chasing down through aliases, etc, if the
	type is user defined, or looking up a pointer type through a further level of indirection."

	| vt |
	vt := aTYPEDESC vt.
	self assert: [vt <= 16rFFF	"modifier flags not valid in a TYPEDESC"].
	vt == VT_CARRAY
		ifTrue: 
			[| array |
			array := aTYPEDESC tdescArray.
			self
				printIDLDecl: aString
				type: aTYPEDESC tdesc
				on: aPuttableStream.
			array rgbounds do: 
					[:sab |
					aPuttableStream
						nextPut: $[;
						print: sab cElements;
						nextPut: $]].
			^self].
	vt == VT_PTR
		ifTrue: 
			[self
				printIDLDecl: ''
				type: aTYPEDESC tdesc
				on: aPuttableStream.
			aPuttableStream nextPut: $*]
		ifFalse: 
			[vt == VT_SAFEARRAY
				ifTrue: 
					[aPuttableStream nextPutAll: 'SAFEARRAY('.
					self
						printIDLDecl: ''
						type: aTYPEDESC tdesc
						on: aPuttableStream.
					aPuttableStream nextPut: $)]
				ifFalse: 
					[vt == VT_USERDEFINED
						ifTrue: 
							["Chase down the actual type via the referenced Type Info."
							aPuttableStream nextPutAll: aTYPEDESC typeInfo name]
						ifFalse: [aPuttableStream nextPutAll: (self idlTypeOfVT: vt)]]].
	aString notEmpty
		ifTrue: 
			[aPuttableStream
				space;
				nextPutAll: aString]!

printIDLForVariable: aVARDESC on: aPuttableStream indent: anInteger
	"Private - Generate an IDL-style description of the property described by the 
	<VARDESC>, on the <puttableStream>. This is useful for documentary purposes,
	e.g. in method comments."

	| isConst typedesc |
	(self
		printIDLAttributes: aVARDESC idlAttributes
		on: aPuttableStream
		indent: -1) ifTrue: [aPuttableStream space].
	typedesc := aVARDESC tdesc.
	typedesc isAnonymous
		ifTrue: 
			[| structure |
			structure := typedesc realTypeInfo.
			aPuttableStream
				nextPutAll: structure idlKeyword;
				space;
				nextPut: ${.
			structure printIDLForVariablesOn: aPuttableStream indent: anInteger + 1.
			aPuttableStream
				crtab: anInteger;
				nextPut: $}.
			aVARDESC isAnonymous
				ifFalse: 
					[aPuttableStream
						space;
						nextPutAll: aVARDESC name].
			aPuttableStream nextPut: $;.
			^self].
	isConst := aVARDESC isSymbolicConstant.
	isConst ifTrue: [aPuttableStream nextPutAll: 'const '].
	self
		printIDLDecl: (aVARDESC isAnonymous ifTrue: [''] ifFalse: [aVARDESC name])
		type: typedesc
		on: aPuttableStream.
	isConst
		ifTrue: 
			[aPuttableStream
				nextPutAll: ' = ';
				print: aVARDESC lpvarValue value].
	aPuttableStream nextPut: $;!

removeAutoGeneratedMethods: aClassDescription
	"Private - Remove any auto-generated methods from the instance side (only) of
	the class generated by the receiver.
	N.B. It is important not to define any of your own methods in the auto-generated
	category, or they will be lost."

	aClassDescription removeCategory: self autoGenCategoryName!

removeOldWrappers: aClass
	self removeAutoGeneratedMethods: aClass class.
	self removeAutoGeneratedMethods: aClass!

reservedSelectors
	"Answer a <Set> of all the selectors which are reserved, and should not be overridden by any
	auto-generated method."

	^IdentitySet new!

resolveExistingClass: aVariableBinding
	"Private - Attempt to locate an existing class which matches the receiver's type, starting with value associated with the <VariableBinding> argument, but prompting the user for further global names if necessary. Answer a <VariableBinding> which is either an existing static variable binding, or a suggested new variable."

	| prompt caption var |
	var := aVariableBinding.
	[self checkConformanceOfExistingClass: var] whileFalse: 
			[| newName |
			prompt isNil
				ifTrue: 
					[| typeName |
					typeName := self idlKeyword.
					prompt := 'Please enter a unique global name for the <1s> <2p>' expandMacrosWith: typeName
								with: self name.
					caption := 'Generating <1s> <2s>.<3s>'
								expandMacrosWith: typeName
								with: self typeLib name
								with: self name].
			newName := UI.Prompter
						on: var key , '_'
						prompt: prompt
						caption: caption.
			newName isNil ifTrue: [self abortGeneration].
			var := (VariableBinding key: newName value: nil)
						environment: self environment;
						yourself].
	"Found a conformant class"
	^var!

shouldOverwriteClassComment
	| existingComment |
	existingComment := self programObject comment.
	^existingComment isEmpty or: 
			[(existingComment contains: self autoGenClassCommentMarker)
				or: [self generationFlags allMask: OverwriteClassComments]]!

superclassClashPrompt: aVariableBinding
	"Private - Prompt the user as to how they wish to resolve an inheritance mismatch."

	| mb |
	mb := UI.MessageBox new.
	mb iconStyle: #warning.
	mb
		text: ('<1s> already exists (in package <2p>) and inherits from <5p>, rather than <3p>, but <5p> does not 
appear to implement the required protocols.

Please press Retry to suggest an alternative name for the <4s>, or Abort to abort.

You can Ignore this warning, but it is suggested that you check the location of <1s> in the hierarchy to be sure that it is correct.'
				expandMacrosWith: {aVariableBinding key.
						aVariableBinding value owningPackage name.
						self baseClass.
						self idlKeyword.
						aVariableBinding value superclass}).
	mb
		caption: ('Dolphin Type Library Analyzer: Generating <1s>.<2s>' expandMacrosWith: self typeLib name
				with: self name).
	mb buttonStyle: #abortRetryIgnore.
	mb defaultButton: 2.
	^mb open! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #autoGenCategoryName!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #autoGenClassCommentMarker!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #autoGenMethodComment!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #baseClassCheck:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #basicGenerate!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #canGenerateClassMessage:!private!testing! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #canGenerateMessage:!private!testing! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #canGenerateMessage:into:!private!testing! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #canGenerateMethodNamed:!private!testing! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #checkConformanceOfExistingClass:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #classCategories!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #classConstantsCategories!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #classInitializerCategories!constants!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #compileClassMethod:categories:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #compileMethod:categories:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #compileRawMethod:categories:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #compileTestingMethod:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #conformsToRequiredProtocols:!private!testing! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #constantsPool!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #determineNewBase:forExistingWrapper:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #emitComment:on:!helpers!printing!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generate!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateAs:flags:!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateClassComment!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateClassDefinition:imports:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateClassSide:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateConstants!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateConstantsIntoPool:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateInstanceSide:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateVariableDefinition!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateVariableDefinition:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generateWrapper!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #generationFlags!accessing!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #guidCheck:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #guidClashPrompt:!helpers!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #handleClash:response:!helpers!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #identifierFrom:!helpers!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #idlTypeOfVT:!helpers!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #isClassCheck:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #packageCheck:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printAutoGenMethodPostambleOn:!printing!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printClass:on:!accessing!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printClassCommentPreambleOn:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printHelpstringComment:on:!printing!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printIDLDecl:type:on:!printing-IDL!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #printIDLForVariable:on:indent:!printing-IDL!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #removeAutoGeneratedMethods:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #removeOldWrappers:!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #reservedSelectors!accessing!public! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #resolveExistingClass:!helpers!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #shouldOverwriteClassComment!private! !
!OS.COM.TypeInfoAnalyzer categoriesFor: #superclassClashPrompt:!helpers!private! !

!OS.COM.TypeInfoAnalyzer class methodsFor!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect multilineString: #printIDL) beReadOnly;
		yourself! !
!OS.COM.TypeInfoAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !

!OS.COM.TypeInfoObject methodsFor!

abortGeneration
	OperationAborted signal: 'Type library wrapper generation aborted'!

basicIdlAttributes
	| attrs uuid |
	attrs := OrderedCollection new: 5.
	uuid := self guid.
	uuid = GUID null ifFalse: [attrs addLast: 'uuid(' , uuid idlString , ')'].
	attrs addAll: self documentation idlAttributes.
	self isHidden ifTrue: [attrs addLast: 'hidden'].
	self isRestricted ifTrue: [attrs addLast: 'restricted'].
	self getCustData do: 
			[:each |
			| attr |
			attr := String writeStream.
			each printIDLOn: attr.
			attrs addLast: attr contents].
	^attrs!

classComments
	"Answer the symbolic name of the comment generation option currently in force for the receiver
	(one of #none, #once, and #overwrite)."

	| flags |
	flags := self generationFlags bitAnd: CommentStyleMask.
	^self class classCommentStyleMap keyAtValue: flags!

classComments: aSymbol 
	"Set the style of comment generation currently in force for the receiver
	(one of #none, #once, and #overwrite)."

	| flags |
	flags := self generationFlags maskClear: CommentStyleMask.
	self generationFlags: (flags 
				maskSet: (self class classCommentStyleMap at: aSymbol ifAbsent: [0]))!

constantsPool
	^self subclassResponsibility!

customAttributes
	"Private - Answer an <abstractDictionary> of the custom attributes defined against this type.
	The keys of the dictionary are the GUIDs which uniquely identify the attribute type, and the
	values are the value of that attribute in this case."

	^self getCustData contents!

defineFunctionTables
	"Answer whether #defineFunction methods will be defined in the classes of 
	all COM interfaces generated from the receiver. These are required if the interface
	is to be implemented by Dolphin on Smalltalk objects (i.e. Dolphin is acting as a COM
	server). They are not required if the interface is only ever used for calling out to 
	external COM objects."

	^self generationFlags noMask: NoFunctionTable!

defineFunctionTables: aBoolean
	"Set whether #defineFunction methods will be defined in the classes of 
	all COM interfaces generated from the receiver. These are required if the interface
	is to be implemented by Dolphin on Smalltalk objects (i.e. Dolphin is acting as a COM
	server). They are not required if the interface is only ever used for calling out to 
	external COM objects."

	self generationFlags: (self generationFlags mask: NoFunctionTable set: aBoolean not)!

defineMethodProtocols
	"Answer whether <MethodProtocol>s will be defined for all COM interfaces
	generated from the receiver."

	^self generationFlags allMask: DefineProtocol!

defineMethodProtocols: aBoolean
	"Set whether <MethodProtocol>s will be defined for all COM interfaces
	generated from the receiver."

	self generationFlags: (self generationFlags mask: DefineProtocol set: aBoolean)!

forceLowercaseIdentifiers
	"Private - Answer whether the keywords generated for raw wrapper methods, with the exception
	of the first keyword, should be forced to start with a lower-case letter. This option is
	provided because of the MIDL case-insensitivity bug described in the Microsoft Knowledge
	base article Q220137. Essentially the bug causes MIDL to ignore case differences between
	names seen in the IDL when building the type-library, and to wrongly fold names that are
	equal excluding case differences. The upshot is that if, say, a parameter name has been
	previously used but with different case (e.g. as a field name in a structure) then the
	parameter name will assume the same case as previously used, and will no longer precisely
	reflect the IDL. Simply re-ordering the IDL may cause the case of the shared name in the
	file to change. Since Smalltalk is case-sensitive, the selectors generated from the
	reordered IDL may change, breaking code that refers to the previous selector name."

	^self generationFlags allMask: LowercaseIdentifiers!

forceLowercaseIdentifiers: aBoolean 
	self generationFlags: (self generationFlags mask: LowercaseIdentifiers set: aBoolean)!

fullyQualifiedName
	^self subclassResponsibility!

generateSourceInterfaces
	"Answer whether wrapper classes should be generated for 'source' (event callback) interfaces."

	^self generationFlags noMask: NoSourceInterfaces!

generationFlags
	"Answer the value of the receiver's 'generationFlags' instance variable."

	^generationFlags!

generationFlags: anObject
	"Set the value of the receiver's 'generationFlags' instance variable to the argument, anObject."

	generationFlags := anObject!

getCustData
	^self tlbInterface
		ifNil: [#()]
		ifNotNil: 
			[:iti2 |
			| custData answer array |
			custData := iti2 getAllCustData.
			array := custData prgCustData.
			answer := array isNull ifTrue: [#()] ifFalse: [array copy].
			custData free.
			answer]!

guidClashSignal
	"Answer the <exceptionSelector>/<exceptionSignaler> which can be signalled to
	when a clashing GUID is detected."

	^self class guidClashSignal
!

highLevelWrappers
	"Answer the symbolic name of the wrapper generation option currently in force for the receiver
	(one of #none, #minimal, and #full)."

	| flags |
	flags := self generationFlags bitAnd: WrapperStyleMask.
	^self class highLevelWrapperStyleMap keyAtValue: flags!

highLevelWrappers: aSymbol 
	"Set the generation of high-level symbols to the named type (one of #none, #minimal, #full)."

	| flags |
	flags := self generationFlags maskClear: WrapperStyleMask.
	self generationFlags: (flags 
				maskSet: (self class highLevelWrapperStyleMap at: aSymbol ifAbsent: [0]))!

idlAttributes
	"Private - Answer a <sequencedReadableCollection> of IDL-style attributes for the receiver."

	^self basicIdlAttributes!

idlKeyword
	"Private - Answer a <readableString> IDL keyword for the type of object
	described by the receiver, e.g. dispinterface."

	^self subclassResponsibility!

isTraceOnly
	"Private - Answer whether compilation is disabled."

	^self generationFlags allMask: NoCompile!

isTracing
	"Private - Answer whether the receiver is writing a trace of generated wrapper classes, 
	methods, etc, to the transcript."

	^self generationFlags allMask: Trace!

isTracingVerbose
	^self generationFlags allMask: Verbose!

isTracingVerbose: aBoolean 
	generationFlags := generationFlags mask: Verbose set: aBoolean!

namespaceImports
	"Private - Answer a <collection> of the shared pool names to be used when 
	defining a wrapper class for the receiver."

	^#()!

packageCheck: anAssociation 
	"Private - The receiver's global is already present, check to make sure it it in the same package,
	and if not ask the user whether or not to relocate it. Note that this method never answers false,
	so the user never gets a chance to try a different name."

	^self subclassResponsibility!

printAttributeList: aCollection on: aPuttableStream 
	aCollection do: [:each | aPuttableStream nextPutAll: each]
		separatedBy: [aPuttableStream nextPutAll: ', ']!

printIDL
	"Answer a <readableString> containing the Microsoft Interface Definition Language
	description of the receiver."

	| s |
	s := String writeStream.
	self printIDLOn: s.
	^s contents!

printIDLAttributes: aCollection on: aPuttableStream indent: anInteger 
	aCollection isEmpty ifTrue: [^false].
	aPuttableStream
		tab: anInteger;
		nextPut: $[.
	aCollection do: 
			[:h | 
			anInteger < 0 ifFalse: [aPuttableStream crtab: anInteger + 1].
			aPuttableStream nextPutAll: h]
		separatedBy: [aPuttableStream nextPutAll: ', '].
	anInteger < 0 ifFalse: [aPuttableStream crtab: anInteger].
	aPuttableStream nextPut: $].
	^true!

printIDLAttributesOn: aPuttableStream indent: anInteger 
	"Private - Print the IDL attribute description for the receiver on the <puttableStream>, target.
	Answer whether any attributes were actually printed"

	^self 
		printIDLAttributes: self idlAttributes
		on: aPuttableStream
		indent: anInteger!

printIDLBodyOn: target indent: tabs
	"Private - Print the IDL description for the receiver on the <puttableStream>, target."

	target
		tab: tabs;
		nextPutAll: self idlKeyword;
		space;
		nextPutAll: self name!

printIDLOn: target
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self printIDLOn: target indent: 0!

printIDLOn: aPuttableStream indent: anInteger 
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self printIDLAttributesOn: aPuttableStream indent: anInteger.
	aPuttableStream cr.
	self printIDLBodyOn: aPuttableStream indent: anInteger!

printOn: aStream 
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self tlbInterface isNull 
		ifTrue: [aStream display: 'NULL']
		ifFalse: [aStream print: self basicName].
	aStream nextPut: $)!

tracing
	"Answer the symbolic name of the tracing option currently in force for the receiver
	(one of #off, #on, and #only)."

	| flags |
	flags := self generationFlags bitAnd: TraceOnly.
	^self class tracingStyleMap keyAtValue: flags!

tracing: aSymbol 
	"Set the symbolic name of the tracing option currently in force for the receiver
	(one of #off, #on, and #only)."

	| flags |
	flags := self generationFlags maskClear: TraceOnly.
	self generationFlags: (flags 
				maskSet: (self class tracingStyleMap at: aSymbol ifAbsent: [0]))! !
!OS.COM.TypeInfoObject categoriesFor: #abortGeneration!private! !
!OS.COM.TypeInfoObject categoriesFor: #basicIdlAttributes!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #classComments!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #classComments:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #constantsPool!public! !
!OS.COM.TypeInfoObject categoriesFor: #customAttributes!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #defineFunctionTables!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #defineFunctionTables:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #defineMethodProtocols!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #defineMethodProtocols:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #forceLowercaseIdentifiers!private!testing! !
!OS.COM.TypeInfoObject categoriesFor: #forceLowercaseIdentifiers:!private!testing! !
!OS.COM.TypeInfoObject categoriesFor: #fullyQualifiedName!public! !
!OS.COM.TypeInfoObject categoriesFor: #generateSourceInterfaces!public!testing! !
!OS.COM.TypeInfoObject categoriesFor: #generationFlags!accessing!converting!public! !
!OS.COM.TypeInfoObject categoriesFor: #generationFlags:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #getCustData!accessing!private! !
!OS.COM.TypeInfoObject categoriesFor: #guidClashSignal!constants!public! !
!OS.COM.TypeInfoObject categoriesFor: #highLevelWrappers!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #highLevelWrappers:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TypeInfoObject categoriesFor: #isTraceOnly!private!testing! !
!OS.COM.TypeInfoObject categoriesFor: #isTracing!private!testing! !
!OS.COM.TypeInfoObject categoriesFor: #isTracingVerbose!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #isTracingVerbose:!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #namespaceImports!constants!private! !
!OS.COM.TypeInfoObject categoriesFor: #packageCheck:!helpers!private! !
!OS.COM.TypeInfoObject categoriesFor: #printAttributeList:on:!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #printIDL!printing!public! !
!OS.COM.TypeInfoObject categoriesFor: #printIDLAttributes:on:indent:!printing!private! !
!OS.COM.TypeInfoObject categoriesFor: #printIDLAttributesOn:indent:!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #printIDLBodyOn:indent:!printing-IDL!private! !
!OS.COM.TypeInfoObject categoriesFor: #printIDLOn:!printing-IDL!public! !
!OS.COM.TypeInfoObject categoriesFor: #printIDLOn:indent:!printing-IDL!public! !
!OS.COM.TypeInfoObject categoriesFor: #printOn:!printing!public! !
!OS.COM.TypeInfoObject categoriesFor: #tracing!accessing!public! !
!OS.COM.TypeInfoObject categoriesFor: #tracing:!accessing!public! !

!OS.COM.TypeInfoObject class methodsFor!

classCommentStyleMap
	ClassCommentStyleMap isNil
		ifTrue: 
			[ClassCommentStyleMap := IdentityDictionary new
						at: #none put: NoClassComment;
						at: #once put: 0;
						at: #overwrite put: OverwriteClassComments;
						shrink].
	^ClassCommentStyleMap!

classCommentStyles
	"Answer the names of the different configurations of a instances of the
	receiver which affect how they will (or will not) generate class comments
	for the structures and interfaces in a type library."

	^self classCommentStyleMap keys asSortedCollection!

guidClashSignal
	"Answer the <exceptionSelector>/<exceptionSignaler> which can be signalled to
	when a clashing GUID is detected."

	GuidClash isNil ifTrue: [GuidClash := WarningSignal description: 'GUID clash generating %1'].
	^GuidClash!

highLevelWrapperStyleMap
	HighLevelWrapperStyleMap isNil
		ifTrue: 
			[HighLevelWrapperStyleMap := IdentityDictionary new
						at: #none put: RawMethodsOnly;
						at: #minimal put: MinimizeWrappers;
						at: #full put: 0;
						shrink].
	^HighLevelWrapperStyleMap!

highLevelWrapperStyles
	"Answer the names of the different configurations of a instances of the
	receiver which affect how they will (or will not) generate high-level
	wrapper methods for COM properties and methods."

	^self highLevelWrapperStyleMap keys!

icon
	"Answers an <Icon> that can be used to represent this class"

	^TypeLibraryAnalyzer icon!

stonAllInstVarNames
	"Override to exclude the number of instance variables we never want to serialize."

	^super stonAllInstVarNames copyWithout: 'tlbInterface'!

tracingStyleMap
	TracingStyleMap isNil
		ifTrue: 
			[TracingStyleMap := IdentityDictionary new
						at: #off put: 0;
						at: #on put: Trace;
						at: #only put: TraceOnly;
						shrink].
	^TracingStyleMap!

tracingStyles
	"Answer the names of the different configurations of a instances of the
	receiver which affect the debug output they will produce (one of #off, #on, #only
	for no tracing, trace source of all generated methods, and do not actually
	compile methods, etc, just write them to trace). Tracing can be useful for
	debugging problems with generation."

	^self tracingStyleMap keys asSortedCollection! !
!OS.COM.TypeInfoObject class categoriesFor: #classCommentStyleMap!constants!private! !
!OS.COM.TypeInfoObject class categoriesFor: #classCommentStyles!initializing!private! !
!OS.COM.TypeInfoObject class categoriesFor: #guidClashSignal!constants!examples!public! !
!OS.COM.TypeInfoObject class categoriesFor: #highLevelWrapperStyleMap!accessing!private! !
!OS.COM.TypeInfoObject class categoriesFor: #highLevelWrapperStyles!initializing!private! !
!OS.COM.TypeInfoObject class categoriesFor: #icon!constants!public! !
!OS.COM.TypeInfoObject class categoriesFor: #stonAllInstVarNames!public! !
!OS.COM.TypeInfoObject class categoriesFor: #tracingStyleMap!accessing!private! !
!OS.COM.TypeInfoObject class categoriesFor: #tracingStyles!initializing!private! !

!OS.COM.TypeLibDocumentation methodsFor!

idlAttributes
	| attrs |
	attrs := OrderedCollection new.
	helpstring notEmpty ifTrue: [attrs addLast: 'helpstring("' , helpstring , '")'].
	helpfile notEmpty ifTrue: [attrs addLast: 'helpfile("' , helpfile , '")'].
	helpcontext isZero ifFalse: [attrs addLast: ('helpcontext(%#010x)' sprintfWith: helpcontext)].
	^attrs! !
!OS.COM.TypeLibDocumentation categoriesFor: #idlAttributes!printing-IDL!private! !

!OS.COM.TypeLibDocumentation class methodsFor!

icon
	"Answers an <Icon> that can be used to represent this class"

	^TypeLibraryAnalyzer icon! !
!OS.COM.TypeLibDocumentation class categoriesFor: #icon!constants!public! !

!OS.COM.TypeLibraryAnalyzer methodsFor!

addAlias: aBindingReference forType: anAXTypeInfoAnalyzer
	self aliasMap at: anAXTypeInfoAnalyzer name asString put: aBindingReference!

addClassToPackage: class
	"Private - Add the specified class to the package associated with the receiver."

	Package manager addClass: class to: self package!

addVariableToPackage: aVariableBinding
	"Private - Add the specified global to the package associated with the receiver."

	Package manager addVariableNamed: aVariableBinding fullyQualifiedReference to: self package!

binding
	"Private - Answer the VariableBinding for the variable being generated for the receiver."

	| name |
	name := self variableName.
	self assert: [self isTraceOnly not].
	^(Root localBindingFor: name)
		ifNil: 
			[| var |
			var := Root addClassVariable: name value: self.
			self package addVariableNamed: name.
			var]
		ifNotNil: 
			[:var |
			"Ensure the binding is actually referring to the receiver"
			var value: self]!

checkConformanceOfExistingPool: binding
	"Private - Check that the existing global with the specified binding is suitable
	for use as the receiver's constants pool. Answers whether the global should
	be used, or an attempt should be made to find another one."

	^(self isPoolCheck: binding)
		and: [self packageCheck: binding]!

constantsPool
	"Private - Answer the <SharedPool> subclass containing all constants (enumerations) defined in the receiver, or nil if none. The pool is generated if it doesn't already exist."

	^self constantsPoolBinding
		ifNotNil: 
			[:var |
			| pool |
			pool := var value.
			pool isEmpty ifTrue: [self generateConstantsIntoPool: var].
			pool]!

constantsPoolBinding
	"Private - Answer a <VariableBinding> which is the actual binding for the receiver's constants pool that contains all constants (enumerations) defined in the receiver. Answer nil if there is no pool because there are no constants."

	| var |
	self assert: [self isTraceOnly not].
	constantsPoolName := (constantsPoolName isNil and: [self enums isEmpty])
				ifTrue: ['']
				ifFalse: [self constantsPoolName].
	constantsPoolName isEmpty ifTrue: [^nil].
	var := self resolveExistingPool: constantsPoolName.
	var value isNil
		ifTrue: 
			[var value: (SharedPool subclass: var key).
			self addVariableToPackage: var	"key"].
	constantsPoolName := var key.
	^var!

constantsPoolName
	"Answer the name of the <SharedPool> class into which all all of the constants and enumerated type values defined in this type library are to be placed. If not cast in stone already, answer the name that would likely be used if the pool were generated."

	^constantsPoolName isNil
		ifFalse: [constantsPoolName]
		ifTrue: [self fullNameFor: (self variableNameFrom: self name , 'Constants')]!

constantsPoolName: identifier
	"Set the <Symbol> name of the <PoolConstantsDictionary> into which all all 
	of the constants and enumerated type values defined in this type library are to be
	placed. This accessor is provided so that the default name generation scheme
	(#<LibName>Constants) can be replaced on an instance specific basis."

	constantsPoolName := identifier.
!

defaultNamespaceImports
	"Private - Answer a <sequencedReadableCollection> of the namespaces to be imported into the generated namespace by default."

	^#('OS.COM' 'OS') collect: [:each | each asQualifiedReference private]!

defaultPackageFolder
	^Tools.PackageFolder dolphinRootPathname , 'Object Arts\Dolphin\ActiveX\Components'!

definesSymbolicConstants
	^self enums notEmpty 
		or: [self modules anySatisfy: [:eachModule | eachModule constants notEmpty]]!

environment
	self namespaceBinding
		ifNil: 
			[binding := (self
						generateClass: self namespaceName
						for: self
						imports: self namespaceImports) binding].
	^binding value!

fullyQualifiedName
	^Root fullNameFor: self namespaceName!

generatableInterfaces
	"Answer a <sequencedReadableCollection> of all the interfaces that should be generated in
	the receiver based on the current generation parameters. Note that late-bound event (source)
	interfaces are never included."

	^self generateSourceInterfaces 
		ifTrue: [self vtblInterfaces , (self dispinterfaces difference: self sourceInterfaces)]
		ifFalse: [self interfaces difference: self sourceInterfaces]!

generatableModules
	"Answer a <sequencedReadableCollection> of all the generatable
	modules in the receiver."

	^self modules 
		reject: [:each | (each dllNameIfNone: []) isNil and: [each constants isEmpty]]!

generateClass: aVariableBinding for: aTypeInfoObject imports: anArray
	| baseClass imports var classVars instVars class existingClass classGuid classInstVars classConstants |
	imports := anArray.
	classVars := instVars := classInstVars := ''.
	classConstants := #().
	baseClass := aTypeInfoObject baseClass.
	var := aTypeInfoObject resolveExistingClass: aVariableBinding.
	"Record any name that differs from suggestion in the alias map so that we can regenerate later to the same name
	 without prompting the user again, and without having to keep the cached analyzers hanging around."
	var ~~ aVariableBinding ifTrue: [self addAlias: var fullyQualifiedReference forType: aTypeInfoObject].
	existingClass := var value.
	existingClass isNil
		ifTrue: 
			[(aTypeInfoObject generationFlags allMask: Verbose)
				ifTrue: 
					[Notification
						signal: 'Generating new class ' , var fullName , ' to wrap ' , aTypeInfoObject fullyQualifiedName]]
		ifFalse: 
			["It may we be that this is already perfect"
			((imports difference: existingClass imports) isEmpty and: [existingClass superclass == baseClass])
				ifTrue: 
					[aTypeInfoObject binding: var.
					^existingClass].
			(aTypeInfoObject generationFlags allMask: Verbose)
				ifTrue: 
					[Notification signal: 'Modifying existing class ' , existingClass name , ' to wrap '
								, aTypeInfoObject fullyQualifiedName].

			"Need to re-generate, but try and preserved existing details"
			imports := existingClass imports union: imports.
			classVars := existingClass classVariableString.
			instVars := existingClass instanceVariableString.
			baseClass := aTypeInfoObject determineNewBase: baseClass forExistingWrapper: existingClass.
			classInstVars := existingClass class instanceVariableString.
			classConstants := existingClass classConstants].
	class := baseClass
				subclass: var fullName
				instanceVariableNames: instVars
				classVariableNames: classVars
				imports: imports
				classInstanceVariableNames: classInstVars
				classConstants: classConstants.

	"Immediately update the class GUID to that in the typelib (if any)"
	classGuid := aTypeInfoObject guid.
	classGuid notNull ifTrue: [class guid: classGuid].
	class classCategories: aTypeInfoObject classCategories.
	aTypeInfoObject isTracing ifTrue: [Notification signal: class definitionChunk].

	"We can now store down the binding info."
	aTypeInfoObject binding: class binding.
	existingClass isNil ifTrue: [self addClassToPackage: class].
	^class!

generateConstantsIntoPool: aVariableBinding
	"Private - Generate the receiver's constants into the <PoolConstantsDictionary>, pool."

	| poolName pool |
	poolName := aVariableBinding key.
	pool := aVariableBinding value.
	self enums do: [:each | each generateAs: poolName flags: 0].
	^pool!

generateConstantsPool
	"Generate and answer a <SharedPool> containing all of the enumerated type values defined in this type library. If the dictionary already exists, then its contents are rewritten (any existing key-value pairs may remain if the keys do not clash)."

	| var pool |
	var := self constantsPoolBinding.
	[pool := var isNil ifFalse: [self generateConstantsIntoPool: var]] on: OperationAborted
		do: [:e | e toTrace].
	self reset.
	^pool!

generateDispatchWrapper: dispName
	"Generate a new subclass of IDispatch which wraps the properties and methods
	of the dispinterface named by the <readableString>, dispInterfaceName."

	^self
		generateDispatchWrapper: dispName
		name: (self fullNameFor: dispName)
		flags: self generationFlags!

generateDispatchWrapper: dispName name: className flags: flags
	"Generate a new subclass of IDispatch identified by the <readableString>, className,
	 which wraps the properties and methods of the dispinterface named by the <readableString>,
 	dispInterfaceName in the receiver's type library."

	| typeInfoAnalyzer |
	typeInfoAnalyzer := self dispinterfaces detect: [:d | d name = dispName].
	^typeInfoAnalyzer generateAs: className flags: flags!

generateInterfaceWrapper: name
	"Generate a new subclass of IUnknown which wraps the methods
	of the custom interface named by the <readableString>, name."

	^self
		generateInterfaceWrapper: name
		name: (self fullNameFor: name)
		flags: self generationFlags!

generateInterfaceWrapper: ifName name: className flags: flags
	"Generate a new subclass of IUnknown identified by the <readableString>, className,
	 which wraps the properties and methods of the dispinterface named by the <readableString>,
 	ifName in the receiver's type library."

	| typeInfoAnalyzer |
	typeInfoAnalyzer := self interfaces detect: [:d | d name = ifName].
	^typeInfoAnalyzer generateAs: className flags: flags!

generateInterfaceWrappers
	"Generate a set of <COMInterface> wrapper classes for custom and
	dual interfaces defined in the receiver."

	[self generatableInterfaces do: [:i | i generate]] on: OperationAborted do: [:e | e toTrace].
	"Reset to clear away analyzers, some global binding may be lost, but alias collection maintains most"
	self reset!

generateTypelibGlobal
	"Answer whether the receiver will generate a global to associate with itself and reference that
	global from generated wrapper classes. This is handy for maintaining analyzer settings in a
	package wrapping a component and is recommended in most cases."

	^(self generationFlags allMask: NoTypeLib) not!

generateTypelibGlobal: aBoolean
	"Set whether the receiver will generate a global to associate with itself and reference that
	global from generated wrapper classes. This is handy for maintaining analyzer settings in a
	package wrapping a component and is recommended in most cases."

	self generationFlags: (self generationFlags mask: NoTypeLib set: aBoolean not)!

generateWrapper: name name: globName flags: flags 
	"Generate a new wrapper object by the <readableString>, globalName,
	 which wraps the object described by the type information named by the 
	readableString>, name, in the receiver's type library, if any."

	| types |
	types := self find: name count: 1.
	^types do: [:each | each generateAs: globName flags: flags]!

idlAttributes
	^(self basicIdlAttributes)
		add: 'version(' , self versionString , ')' afterIndex: 1;
		yourself!

idlHelpAttributes: docs 
	^docs idlAttributes!

idlKeyword
	^'library'!

isPoolCheck: binding
	"Private - Check that the global binding represented by the <Association>, binding, refers to a 
	pool dictionary, and if not prompt for user action."

	| global resp mb |
	global := binding value.
	(global isBehavior and: [global inheritsFrom: SharedPool]) ifTrue: [^true].
	mb := UI.MessageBox new.
	mb iconStyle: #warning.
	mb
		text: ('Pool name <1p> clashes with an existing global which is not a SharedPool.<n><n>Press OK to suggest an alternative name for the constants pool, or Cancel to abort.'
				expandMacrosWith: binding key).
	mb
		caption: ('Dolphin Type Library Analyzer: Generating <1s> constants pool' expandMacrosWith: self name).
	mb buttonStyle: #okCancel.
	resp := mb open.
	resp == #cancel ifTrue: [self abortGeneration].
	^false	"Binding not acceptable - please try a new one"!

moveClassToPackage: class
	"Private - Move the specified class to the package associated with the receiver."

	Package manager addClass: class to: self package!

namespaceBinding
	^binding ifNil: [binding := self namespaceName asQualifiedReference bindingOrNil]!

namespaceImports
	"Private - Answer a <collection> of the shared variable names to be used for wrapper classes generated out
	of the receiver, e.g. COMInterface subclasses. The shared pool will be generated if it doesn't currently 
	exist."

	| imports poolName |
	imports := self defaultNamespaceImports.
	poolName := self constantsPoolName.
	poolName isEmpty ifFalse: [imports := imports copyWith: {poolName asQualifiedReference private}].
	^imports!

package
	"Answer the package into which wrapper classes for the receiver should be generated.
	The default behaviour is to answer a package with the same name as the type library, 
	creating a new package if necessary.
	Note: Must be stripped, as refers to the development system Package classes."

	| pm |
	packageName isNil ifTrue: [packageName := self name].
	pm := Package manager.
	^pm packageNamed: self packageName
		ifNone: [pm newPackage: (File composePath: self defaultPackageFolder subPath: self packageName)]!

package: parcel
	"Set the package into which wrapper classes for the receiver should be generated to
	the <Package>, parcel. This method can be used to override the default package,
	named after the type library, which would otherwise be used."
	
	self packageName: parcel name!

packageCheck: anAssociation
	"Private - The receiver's global is already present, check to make sure it it in the same package,
	and if not ask the user whether or not to relocate it. Note that this method never answers false,
	so the user never gets a chance to try a different name."

	| global myPackage hisPackage |
	global := anAssociation value.
	myPackage := self packageName.
	hisPackage := global owningPackage name.
	myPackage = hisPackage
		ifFalse: 
			[| resp mb |
			mb := UI.MessageBox new.
			mb
				iconStyle: #warning;
				buttonStyle: #yesNoCancel.
			mb
				text: ('The shared pool <1s> already exists in the <2p> package.

Would you like to move it to the <3p> package?

Press Yes to move the class, No to leave it where it is, or Cancel to abort'
						expandMacrosWith: anAssociation key
						with: hisPackage
						with: myPackage).
			mb
				caption: ('Dolphin Type Library Analyzer: Generating <1s> constants pool' expandMacrosWith: self name).
			resp := mb open.
			resp == #cancel ifTrue: [self abortGeneration].
			resp == #yes ifTrue: [self addVariableToPackage: anAssociation]].
	^true!

packageName
	"Answer the name of the package into which wrapper classes for the receiver
	should be generated. The default behaviour is to answer a package with the same name
	as the type library. Unlike #package, this method does not force the creation of
	a package if it does not already exist."

	packageName isNil ifTrue: [self packageName: self name].
	^packageName!

packageName: aString
	"Sets the name of the package into which wrapper classes for the receiver
	should be generated to <readableString> aString."

	packageName := aString!

prefix: aString
	"Set the name of the namespace into which the classes will be generated."

	namespaceName := self variableNameFrom: aString!

prefixGlobalNames
	"Answer whether generated globals (e.g. classes) will be prefixed."

	^self prefix notEmpty!

printIDLForwardRefsOn: aPuttableStream indent: anInteger 
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self customInterfaces , self dualInterfaces do: 
			[:i | 
			aPuttableStream
				nextPutAll: i idlKeyword;
				space;
				nextPutAll: i name;
				nextPut: $;;
				crtab: anInteger].
	self dispinterfaces do: 
			[:i | 
			aPuttableStream
				nextPutAll: i idlKeyword;
				space;
				nextPutAll: i name;
				nextPut: $;;
				crtab: anInteger]!

printIDLOn: aPuttableStream indent: anInteger
	"Print the IDL description of the receiver on the <puttableStream>, target."

	| childIndent |
	aPuttableStream
		nextPutAll: '// IDL generated by Dolphin Smalltalk from:';
		crtab: anInteger;
		nextPutAll: '//	'''.
	[aPuttableStream nextPutAll: self path] on: HRESULTError
		do: 
			[:e |
			aPuttableStream
				nextPut: $(;
				nextPutAll: e messageText;
				nextPut: $)].
	aPuttableStream
		nextPut: $';
		cr;
		crtab: anInteger.
	self printIDLForwardRefsOn: aPuttableStream indent: anInteger.
	aPuttableStream cr.
	self printIDLAttributesOn: aPuttableStream indent: anInteger.
	aPuttableStream
		crtab: anInteger;
		nextPutAll: self idlKeyword;
		space;
		nextPutAll: self name;
		crtab: anInteger;
		nextPut: ${;
		crtab;
		nextPutAll: 'importlib("stdole2.tlb");';
		crtab: anInteger;
		crtab: anInteger.
	childIndent := anInteger + 1.
	self enums do: 
			[:e |
			e printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self namedStructs do: 
			[:s |
			s printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self namedUnions do: 
			[:s |
			s printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self typedefs do: 
			[:a |
			a printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self customInterfaces , self dualInterfaces do: 
			[:i |
			i printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self dispinterfaces do: 
			[:d |
			d printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self coclasses do: 
			[:c |
			c printIDLOn: aPuttableStream indent: childIndent.
			aPuttableStream crtab: anInteger].
	self modules do: [:m | m printIDLOn: aPuttableStream indent: childIndent]
		separatedBy: [aPuttableStream crtab: anInteger].
	aPuttableStream
		nextPutAll: '};';
		cr!

printOn: aStream
	"Append a developer friendly textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	tlbInterface isNull ifTrue: [aStream print: libVariableName] ifFalse: [aStream print: self name].
	aStream nextPut: $)!

resolveExistingPool: poolName
	"Private - Attempt to locate an existing constants pool which belongs to the receiver
	starting with the <readableString> name, poolName, but prompting the user for further
	global names if necessary. Answer an <Association> which is either an existing global
	variable binding, or a suggested new name and nil value."

	| env newName var |
	env := self environment.
	newName := poolName.
	
	[newName := newName asQualifiedReference.
	var := env bindingOrNil ifNil: [^newName -> nil].
	self checkConformanceOfExistingPool: var]
			whileFalse: 
				[newName := UI.Prompter
							on: newName , '_'
							prompt: 'Please enter a new global name for the pool'
							caption: ('Generating <1s> constants pool' expandMacrosWith: self name)].
	^var!

superclassClashSignal
	"Answer the <exceptionSelector>/<exceptionSignaler> which can be signalled to
	when an inheritance mismatch is detected."

	^self class superclassClashSignal!

variableName
	"Private - Answer a (non-clashing) variable name for the receiver."

	libVariableName isNil
		ifTrue: 
			[| stem libid |
			stem := self variableNameFrom: self name.
			(stem endsWith: 'Lib') ifFalse: [stem := stem , 'Lib'].
			libVariableName := stem asSymbol.
			libid := self guid.
			self isTraceOnly
				ifFalse: 
					[| suffix |
					suffix := 0.
					
					[| glob |
					glob := Root at: libVariableName ifAbsent: [^libVariableName].
					(glob respondsTo: #guid) not or: [glob guid ~= libid]]
							whileTrue: 
								[suffix := suffix + 1.
								libVariableName := (stem , suffix printString) asSymbol]]].
	^libVariableName! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #addAlias:forType:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #addClassToPackage:!helpers!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #addVariableToPackage:!must strip!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #binding!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #checkConformanceOfExistingPool:!helpers!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #constantsPool!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #constantsPoolBinding!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #constantsPoolName!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #constantsPoolName:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #defaultNamespaceImports!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #defaultPackageFolder!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #definesSymbolicConstants!private!updating! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #environment!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #fullyQualifiedName!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generatableInterfaces!enumerating!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generatableModules!enumerating!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateClass:for:imports:!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateConstantsIntoPool:!operations!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateConstantsPool!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateDispatchWrapper:!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateDispatchWrapper:name:flags:!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateInterfaceWrapper:!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateInterfaceWrapper:name:flags:!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateInterfaceWrappers!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateTypelibGlobal!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateTypelibGlobal:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #generateWrapper:name:flags:!operations!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #idlAttributes!printing-IDL!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #idlHelpAttributes:!printing-IDL!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #idlKeyword!constants!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #isPoolCheck:!private!testing! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #moveClassToPackage:!helpers!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #namespaceBinding!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #namespaceImports!accessing!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #package!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #package:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #packageCheck:!helpers!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #packageName!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #packageName:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #prefix:!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #prefixGlobalNames!accessing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #printIDLForwardRefsOn:indent:!printing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #printIDLOn:indent:!printing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #printOn:!printing!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #resolveExistingPool:!helpers!private! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #superclassClashSignal!constants!public! !
!OS.COM.TypeLibraryAnalyzer categoriesFor: #variableName!accessing!private! !

!OS.COM.TypeLibraryAnalyzer class methodsFor!

example1
	"Exercise ITypeLib a bit."

	| tlb docs analyzers |
	tlb := TypeLibraryAnalyzer open: 'stdole2.tlb'.

	"Display the names of the members of the library"
	tlb names.

	"Ask whether particular members are present in the library."
	tlb isName: IUnknown name.
	tlb isName: ITypeLib name.

	"Answer all the documentation for a particular member (e.g. IUnknown)"
	tlb documentationAt: 4.
	docs := (1 to: tlb typeInfoCount) collect: [:i | tlb documentationAt: i].

	"Answer an ITypeInfo for a particular member."
	tlb typeAnalyzerAt: 4.
	analyzers := (1 to: tlb typeInfoCount) collect: [:i | tlb typeAnalyzerAt: i].

	"Get the library attributes."
	tlb attributes.

	"Now try some higher level enumerations"
	tlb coclasses.
	tlb typedefs.
	tlb structs.
	tlb enums.
	tlb interfaces.
	tlb dispinterfaces!

example2
	"Example using the Microsoft Scripting Runtime.
	One of the main purposes of the Scripting Runtime is to provide an object-oriented file
	system model, and we exercise a very small part of its capabilities here.
		AXTypeLibraryAnalyzer example2
	"

	"First lets get the FileSystem object, we might need to generate some wrappers to do so"

	| fs cdrive croot windir systemdir |
	fs := (#{IFileSystem} isDefined
				ifFalse: 
					[| tlb |
					tlb := TypeLibraryAnalyzer open: 'scrrun.dll'.
					"We'll generate without a namespace (i.e. into Smalltalk)"
					tlb namespaceName: ''.
					"Generate the wrappers for the type library interfaces"
					tlb generateInterfaceWrappers.
					#{IFileSystem} value])
					createObject: 'Scripting.FileSystemObject'.

	"Now we can test it out a bit by finding the root of C"
	cdrive := fs drives item: 'C'.
	croot := cdrive rootFolder.

	"And then from there by locating the system folder"
	windir := croot subFolders item: 'windows'.
	systemdir := windir subFolders item: 'system32'.

	"A better way to get the system folder is:"
	systemdir := fs getSpecialFolder: #{ScriptingConstants.SystemFolder} value.

	"Display the contents of the system folder (files only) in a list box (might take a while)"
	UI.ListPresenter show list: systemdir files contents!

example3
	"Example using the Microsoft Excel 2000 (can be adapted for older versions).
	This code should ideally be run line-by-line from a workspace.
		AXTypeLibraryAnalyzer example3
	"

	| excel books book range font arry caption |
	#{ExcelLib} isDefined
		ifFalse: 
			[| xl |
			xl := TypeLibraryAnalyzer open: 'c:\Program Files\Microsoft Office\Office\excel9.olb'.
			xl namespaceName: 'Xl'.
			xl generateConstantsPool.
			#(#_Application #Workbooks #_Workbook #Range #Font) do: [:i | (xl at: i) generate].
			xl reset].
	excel := #{Xl.Application} value new.
	books := excel workbooks.
	book := books add: VARIANT unspecified lcid: 0.

	"Make the sheet visible - you'll lose focus"
	excel visible: 0 rhs: true.

	"Set the workbook caption"
	caption := 'Dolphin-VisualWorks Performance Comparison'.
	excel caption: caption.

	"Add a title in the sheet itself"
	range := (excel range: 'A1' cell2: VARIANT unspecified)
				value: caption;
				yourself.
	(excel range: 'A2' cell2: VARIANT unspecified) value: '(266Mz P1, 96M, Win98)'.

	"And set its font"
	font := range font.
	font
		bold: true;
		italic: true;
		size: 22.

	"Now insert some values"
	range := excel range: 'A4' cell2: 'F4'.
	range value: #('STIC Benchmark' 'Dolphin 2.1' 'Dolphin 3.01' 'VWNC 3.0' 'D2.1/VW' 'D3.0/VW').

	"Bit tricky to handle 2-D array, need some higher level help really"
	range := excel range: 'A5' cell2: 'A14'.
	arry := range value.
	#('Towers Of Hanoi' 'Alloc.' 'Array Write' 'Dictionary Write' 'Floating Math' 'Integer Math' 'OrderedCollection Iterate' 'OrderedCollection Write' 'String Compare' 'String Compare 2')
		keysAndValuesDo: [:i :s | arry elementAt: {i. 1} put: s asVariant].
	range value: arry.
	range := excel range: 'B5' cell2: 'D14'.
	arry := range value.
	#(#(4715 10990 72791 7980 75870 14639 12617 21946 3981 7738) #(4615 11973 70180 8074 84630 14501 8709 20262 10964 18355) #(678 8936 20520 3153 90170 14720 5090 8694 18659 18653))
		keysAndValuesDo: [:j :a | a keysAndValuesDo: [:i :n | arry elementAt: {i. j} put: n asVariant]].	"Dolphin 2.1"	"Dolphin 3.0"	"VWNC 3.0"
	range value: arry.

	"Add formulas for ratios; and format"
	(excel range: 'E5' cell2: 'E14')
		formula: '=B5/D5';
		numberFormat: '0.00'.
	(excel range: 'F5' cell2: 'F14')
		formula: '=C5/D5';
		numberFormat: '0.00'.

	"Add fancy formatting to our report."
	(excel range: 'A1:F14' cell2: VARIANT unspecified)
		autoFormat: #{XlConstants.xlSimple} value
		number: VARIANT unspecified
		font: VARIANT unspecified
		alignment: VARIANT unspecified
		border: VARIANT unspecified
		pattern: VARIANT unspecified
		width: VARIANT unspecified.

	"Print Preview"
	"(excel range: 'A1' cell2: 'F14') printPreview: true."

	"Save the active workbook."
	book := excel activeWorkbook.
	book invokeId: (book idOfName: 'SaveAs')
		with: (File
				composePath: ''
				stem: caption
				extension: 'xls').
	(UI.MessageBox confirm: 'Close Excel?') ifTrue: [excel quit]!

fileTypes
	"Answer an Array of file types that can be associated with this
	class of document."

	^#( ('Components (*.dll,*.ocx,*.exe)' '*.dll;*.ocx;*.exe')
		('Type Libraries (*.tlb,*.olb)' '*.tlb;*.olb')
		('All Files (*.*)' '*.*'))!

icon
	"Answers an <Icon> that can be used to represent this class"

	^ITypeLib icon!

open
	"Answer a new instance of the receiver on a type library located
	by the user through the file open dialog."

	| openFilename |
	openFilename := UI.FileOpenDialog new
				fileTypes: self fileTypes;
				defaultExtension: 'dll';
				showModal.
	openFilename isNil ifTrue: [^nil].
	^self open: openFilename!

publishedAspectsOfInstances
	"Answer a <LookupTable> of the <Aspect>s published by instances of the receiver."

	^super publishedAspectsOfInstances
		add: (Tools.Aspect boolean: #defineFunctionTables);
		add: (Tools.Aspect boolean: #defineMethodProtocols);
		add: (Tools.Aspect string: #namespaceName);
		add: (Tools.Aspect string: #constantsPoolName);
		add: (Tools.Aspect choice: #highLevelWrappers from: self highLevelWrapperStyles);
		add: (Tools.Aspect choice: #classComments from: self classCommentStyles);
		add: (Tools.Aspect choice: #tracing from: self tracingStyles);
		add: (Tools.Aspect name: #aliasMap);
		add: (Tools.Aspect sequenceableCollection: #interfaces) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #coclasses) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #enums) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #modules) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #namedStructs) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #namedUnions) beReadOnly;
		add: (Tools.Aspect sequenceableCollection: #typedefs) beReadOnly;
		yourself!

registerTypeLib
	
	[self open
		ifNotNil: 
			[:lib |
			UI.MessageBox new
				notify: ('The type library ''<1s> - <2s>'' was successfully loaded and registered from:<n><n><t><3s>'
						expandMacrosWith: lib name
						with: lib helpstring
						with: lib path)]]
			on: Error
			do: 
				[:each |
				UI.MessageBox new
					caption: 'Unable to register type library...';
					errorMsg: each description]!

stonAllInstVarNames
	"Override to exclude the number of instance variables we never want to serialize."

	^super stonAllInstVarNames copyWithout: 'typeAnalyzers'!

superclassClashSignal
	"Answer the <exceptionSelector>/<exceptionSignaler> which can be signalled to
	when an inheritance mismatch is detected."

	SuperclassClash isNil
		ifTrue: [SuperclassClash := WarningSignal description: 'Superclass clash generating %1'].
	^SuperclassClash!

typeLibRegistrations
	"Private - Answer a <sequencedReadableCollection> containing the an
	assocation between a type library description, and a two element array
	containing its GUID and version strings. The collection is sorted in 
	ascending order of type library description. Note that the GUID is in string
	form, but can be converted to a GUID using GUID>>fromString:.
	Full registration details for a particular type library can be accessed
	by opening the key:
		((RegKey classesRoot: #read) at: guidString) at: versionString
	Under which there are keys for the DLL path, etc. Alternatively
	the type library can be loaded using #load:major:minor:locale:,
	and then the path queried from the resulting ITypeLib."

	| list |
	list := OrderedCollection new: 256.
	((RegKey classesRoot: #read) at: 'TypeLib') keysAndValuesDo: 
			[:g :gk |
			gk keysAndValuesDo: 
					[:v :vk |
					| description |
					description := vk value.
					(description notNil and: [description notEmpty])
						ifTrue: 
							[list add: (Tools.AXTypeLibRegistration
										description: description
										guidString: g
										versionString: v)]]].
	^list asSortedCollection! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #example1!examples!must strip!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #example2!examples!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #example3!examples!must strip!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #fileTypes!constants!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #icon!constants!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #open!instance creation!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #publishedAspectsOfInstances!constants!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #registerTypeLib!helpers!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #stonAllInstVarNames!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #superclassClashSignal!constants!examples!public! !
!OS.COM.TypeLibraryAnalyzer class categoriesFor: #typeLibRegistrations!enquiries!private! !

!OS.COM.VARDESC methodsFor!

printIDLOn: target indent: tabs
	"Print the IDL description of the receiver on the <puttableStream>, target."

	self analyzer printIDLForVariable: self on: target indent: tabs!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self printIDLOn: aStream indent: -1.
	aStream nextPut: $)! !
!OS.COM.VARDESC categoriesFor: #printIDLOn:indent:!printing-IDL!public! !
!OS.COM.VARDESC categoriesFor: #printOn:!printing!public! !

!OS.COM.VARIANT methodsFor!

debugPrintOn: aStream
	"For VARIANTs we want to be careful not to have any side effects when displayed in the debugger."

	self isArray
		ifTrue: 
			[aStream
				basicPrint: self;
				nextPut: $(.
			self isNull
				ifTrue: [aStream nextPutAll: 'NULL']
				ifFalse: 
					[aStream nextPutAll: self typeName; nextPutAll: '[]'.
					self isByRef ifTrue: [aStream nextPut: $*]].
			aStream nextPut: $)]
		ifFalse: [super debugPrintOn: aStream]!

printIDLOn: aPuttableStream
	"Append, to the <puttableStream>, target, a string whose characters are a 
	the same as those which would be needed to represent the receiver as a literal
	in an IDL file."

	| vt |
	vt := self vartype.
	vt == VT_BSTR
		ifTrue: 
			[aPuttableStream
				nextPut: $";
				display: self bstr;
				nextPut: $"]
		ifFalse: 
			[vt == VT_DATE
				ifTrue: [self date asFloat printOn: aPuttableStream]
				ifFalse: 
					[vt == VT_R4
						ifTrue: [FLOAT printDefaultValue: self on: aPuttableStream]
						ifFalse: [self value displayOn: aPuttableStream]]]!

printOn: aPuttableStream
	"Append, to the <puttableStream> argument a string whose characters are a the same as those which would result from sending a #printString message to the receiver.
	N.B. This is really intended for development use. #displayOn: and #displayString are complementary methods for generating strings for presentation to an end-user."

	aPuttableStream
		basicPrint: self;
		nextPut: $(.
	self isNull
		ifTrue: [aPuttableStream nextPutAll: 'NULL']
		ifFalse: 
			[aPuttableStream nextPutAll: self typeName.
			self isByRef ifTrue: [aPuttableStream nextPut: $*].
			aPuttableStream
				nextPutAll: ': ';
				print: self value].
	aPuttableStream nextPut: $)! !
!OS.COM.VARIANT categoriesFor: #debugPrintOn:!printing!public! !
!OS.COM.VARIANT categoriesFor: #printIDLOn:!printing-IDL!public! !
!OS.COM.VARIANT categoriesFor: #printOn:!development!printing!public! !

!OS.COM.VARIANT class methodsFor!

example1
	"Example of setting up a by-reference variant pointing at a BSTR. Also shows how to replace the BSTR in such
	a by-ref. variant."

	| var bstr lpbstr |
	var := VARIANT new.
	bstr := 'Wibble' asBSTR.
	"Must use #basicYourAddress, because BSTRs are indirection objects"
	var dword: bstr basicYourAddress.
	var vt: VT_BSTR | VT_BYREF.

	"Extract the by-ref value."
	lpbstr := var value.

	"Update the by-ref value - the original BSTR is free'd"
	lpbstr value: 'Wobble'.

	"Note that the original BSTR has been updated, and the by-ref VARIANT"

	"Show the updated by-ref value"
	bstr.	"Ctrl+D"
	var.	"Ctrl+D"
	var value	"Ctrl+D"!

printMethodArgument: aString elemdesc: anELEMDESC indirections: anInteger on: aPuttableStream for: anAPIInfoAnalyzer
	"Private - Generate an output argument instantiation statement onto the <puttableStream> argument for the function parameter described by the <ELEMDESC> argument."

	anELEMDESC isIn
		ifTrue: 
			["If in or in-out then just pass a converted object"
			anInteger > 1
				ifTrue: 
					[Notification signal: 'Warning: Parameter ''' , aString , ''' of ' , anELEMDESC owner fullName
								, ' is input VARIANT**, may need hand coded wrapper.'].
			aPuttableStream
				nextPutAll: aString;
				space;
				display: #asVariant]
		ifFalse: 
			["If an output only argument, need an instance of the receiver to buffer the result"
			anAPIInfoAnalyzer printClass: self on: aPuttableStream.
			aPuttableStream
				space;
				display: (anInteger > 1 ifTrue: [#newPointer] ifFalse: [#new])]!

printOptionalParameter: anELEMDESC on: aPuttableStream for: anAPIInfoAnalyzer
	anELEMDESC hasDefaultValue
		ifTrue: 
			[| default |
			aPuttableStream nextPut: $(.
			default := anELEMDESC defaultValue.
			(VARIANT classForVT: default vartype) printDefaultValue: default on: aPuttableStream.
			aPuttableStream
				nextPut: $);
				space;
				display: #asVariant]
		ifFalse: 
			[anAPIInfoAnalyzer printClass: VARIANT on: aPuttableStream.
			aPuttableStream
				space;
				display: #unspecified]! !
!OS.COM.VARIANT class categoriesFor: #example1!examples!public! !
!OS.COM.VARIANT class categoriesFor: #printMethodArgument:elemdesc:indirections:on:for:!private! !
!OS.COM.VARIANT class categoriesFor: #printOptionalParameter:on:for:!helpers!private! !

!OS.COM.VARIANT_BOOL methodsFor!

printOn: aStream
	"Append a textual representation of the receiver to aStream."

	self isNull
		ifTrue: [super printOn: aStream]
		ifFalse: [
			aStream nextPutAll: (self value	
								ifTrue: ['VARIANT_TRUE']
								ifFalse: ['VARIANT_FALSE'])]! !
!OS.COM.VARIANT_BOOL categoriesFor: #printOn:!printing!public! !

!OS.COM.VARIANT_BOOL class methodsFor!

newInstanceAspect: aSymbol class: aspectClass 
	"Private - Answer a new <Aspect> of the class, aspectClass, and with name, aSymbol, 
	which is appropriate for representing aspects of the receiver's type."

	^aspectClass boolean: aSymbol! !
!OS.COM.VARIANT_BOOL class categoriesFor: #newInstanceAspect:class:!adapters!private! !

!OS.HRESULT class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SDWORDField! !
!OS.HRESULT class categoriesFor: #fieldType!constants!private! !

!OS.LARGE_INTEGER class methodsFor!

fieldType
	"Private - Answer the <ExternalField> type to be used to represent the receiver's field type in 
	other structures."

	^SQWORDField! !
!OS.LARGE_INTEGER class categoriesFor: #fieldType!constants!private! !

"End of package definition"!

