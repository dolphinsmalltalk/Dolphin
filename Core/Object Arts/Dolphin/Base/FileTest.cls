"Filed out from Dolphin Smalltalk 7"!

DolphinTest subclass: #FileTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'Win32Constants'
	classInstanceVariableNames: ''!
FileTest guid: (GUID fromString: '{26AE9922-21E2-489A-845C-3C1DC1C2A3CF}')!
FileTest comment: ''!
!FileTest categoriesForClass!Unclassified! !
!FileTest methodsFor!

createTestDirectories
	| dir |
	File createDirectoryPath: 'c:\FileTest1\EmptyLeaf'.

	dir := 'c:\FileTest1\LeafWithFile\'.
	File createDirectoryPath: dir.
	(FileStream write: dir, 'Blah.txt') nextPutAll: 'Blah'; close.

	dir := 'c:\FileTest1\LeafWithFiles\'.
	File createDirectoryPath: dir.
	(FileStream write: dir, 'Blah1.txt') nextPutAll: 'Blah'; close.
	(FileStream write: dir, 'Blah2.txt') nextPutAll: 'Blah blah'; close.

	File createDirectoryPath: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.

	dir := 'c:\FileTest1\BranchWithEmptyLeaves\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.

	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	File createDirectoryPath: dir, '\EmptyLeaf1'.
	(FileStream write: dir, 'blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	(FileStream write: dir, 'blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, 'blah2.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.
	(FileStream write: dir, 'blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.
	(FileStream write: dir, 'blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, 'blah2.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithLeafWithFile\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir, 'LeafWithFile'.
	(FileStream write: dir, '\LeafWithFile\blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithLeafWithFiles\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir, 'LeafWithFiles'.
	(FileStream write: dir, '\LeafWithFiles\blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, '\LeafWithFiles\blah2.txt') nextPutAll: 'Blah blah blah'; close.

!

deleteDirectory: aString 
	self assert: (File isDirectory: aString).
	File deleteDirectory: aString.
	self assert: (File exists: aString) not.!

deleteTestDirectories
	File deleteDirectory: 'c:\FileTest1\'!

relativePathOf: a to: b
	^File relativePathOf: a to: b!

removeDirectory: aString 
	"Private - This stub method was auto-generated by the Dolphin debugger and remains to be correctly implemented."

	self assert: (File isDirectory: aString).
	File removeDirectory: aString.
	self assert: (File exists: aString) not.
!

tearDown
	[self deleteTestDirectories] on: Win32Error do: [:e |]!

test64BitSeek
	"Tests #755"

	| f dist pointer |
	f := File temporary.
	0 to: 31
		do: 
			[:i | 
			dist := 2 raisedToInteger: i.
			pointer := f seek: dist sense: FILE_BEGIN.
			self assert: pointer = dist.
			pointer := f seek: -1 sense: FILE_CURRENT.
			self assert: pointer = (dist - 1).
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer = dist.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer = (dist + 1).
			pointer := f seek: dist negated sense: FILE_CURRENT.
			self assert: pointer = 1].
	32 to: 62
		do: 
			[:i | 
			dist := 2 raisedToInteger: i.
			pointer := f seek: dist sense: FILE_BEGIN.
			self assert: pointer = dist.
			pointer := f seek: -1 sense: FILE_CURRENT.
			self assert: pointer = (dist - 1).
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer = dist.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer = (dist + 1).
			pointer := f seek: dist negated sense: FILE_CURRENT.
			self assert: pointer = 1].
	pointer := f seek: -1 sense: FILE_CURRENT.
	self assert: pointer == 0.
	"As the 64-bit offset is signed, the maximum seek offset is 2^63-1"
	self 
		should: [f seek: 2 ** 63 sense: FILE_BEGIN]
		raise: FileException
		matching: [:ex | ex statusCode = 131	"ERROR_NEGATIVE_SEEK"].
	"Test the condition where the low-word of the return is 16rFFFFFFFF, so GetLastError() is needed to disambiguate from an error condition."
	dist := 2 ** 32 - 1.
	pointer := f seek: dist sense: FILE_BEGIN.
	"Now test maximum seek distance"
	dist := 2 ** 63 - 1.
	pointer := f seek: dist sense: FILE_BEGIN.
	self assert: pointer = dist.
	"Although not really a negative seek, it would cause a 64-bit signed file pointer to go negative"
	self 
		should: [f seek: 1 sense: FILE_CURRENT]
		raise: FileException
		matching: [:ex | ex statusCode = 131	"ERROR_NEGATIVE_SEEK"].
	pointer := f seek: dist negated sense: FILE_CURRENT.
	self assert: pointer = 0.
	f close.
	File delete: f name!

testClassAppendPathSeparator
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (File appendPathDelimiter: 'c:\') = 'c:\'.
	self assert: (File appendPathDelimiter: 'c:/') = 'c:/'.
	self assert: (File appendPathDelimiter: 'c:.') = 'c:.\'.
	self assert: (File appendPathDelimiter: '') = '\'.
	self assert: (File appendPathDelimiter: 'a') = 'a\'.
	self assert: (File appendPathDelimiter: 'a\') = 'a\'.
	self assert: (File appendPathDelimiter: 'a\\') = 'a\\'.
	self assert: (File appendPathDelimiter: '\') = '\'.
	self assert: (File appendPathDelimiter: '/') = '/'.
	self assert: (File appendPathDelimiter: 'a/') = 'a/'!

testClassRelativePathOfTo
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (self relativePathOf: '.' to: '.') = '.'.
	self assert: (self relativePathOf: '..' to: '.') = '..'.
	self assert: (self relativePathOf: '..\' to: '.') = '..\'.
	self assert: (self relativePathOf: '..' to: '.\') = '..'.
	self assert: (self relativePathOf: '.' to: '..') = '.'.
	self assert: (self relativePathOf: '.\' to: '..\') = ''.
	self assert: (self relativePathOf: '.\' to: '..') = ''.
	self assert: (self relativePathOf: '.' to: '..\') = '.'.
	self assert: (self relativePathOf: '.\' to: '..\') = ''.
	self assert: (self relativePathOf: 'c:\' to: 'd:\') = 'c:\'.
	self 
		assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\') = '1\blah.txt'.
	self 
		assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1\') = 'blah.txt'.
	self 
		assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1') = '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1.txt') 
				= '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2\') 
				= '..\1\blah.txt'.
	self 
		assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2') = '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2.txt') 
				= '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1') 
				= '1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1\') 
				= '11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21\') 
				= '..\..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21') 
				= '..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21.txt') 
				= '..\1\11\blah.txt'.

	"Example from MS IMoniker documentation"
	self 
		assert: (self relativePathOf: 'c:\projects\secret\art\pict1.bmp'
				to: 'c:\projects\secret\docs\chap1.txt') = '..\art\pict1.bmp'.
	self 
		assert: (self relativePathOf: 'c:\projects\secret\docs\chap1.txt'
				to: 'c:\projects\secret\art\pict1.bmp') = '..\docs\chap1.txt'.
	"A common type of useage in Dolphin (image relative path)"
	self 
		assert: (self 
				relativePathOf: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax.pac'
				to: 'd:\object arts\dev\dolphin5\') 
					= 'Packages\Dolphin\Database\Database Connection.pax.pac'.
	"Non-canonical path with redundant components - note result is not canonical either"
	self 
		assert: (File fullPathOf: (self 
						relativePathOf: 'd:\dummy\..\object arts\dev\dummy\..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
						to: 'd:\object arts\dev\dolphin5\')
				relativeTo: 'd:\object arts\dev\dolphin5\') 
					= 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax'.

	"Already a relative path (therefore fails and answers first argument)"
	self 
		assert: (self relativePathOf: 'Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\') 
					= 'Packages\Dolphin\Database\Database Connection.pax'.
	self 
		assert: (self relativePathOf: '.\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\') 
					= 'Packages\Dolphin\Database\Database Connection.pax'.
	self 
		assert: (self relativePathOf: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\') 
					= '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'


!

testDeleteDirectory
	self createTestDirectories.
	
	self deleteDirectory: 'c:\FileTest1\EmptyLeaf'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	self deleteDirectory: 'c:\FileTest1\LeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFiles\'.


!

testForDirectoriesIn
	| all windir |
	all := OrderedCollection new.
	windir := SessionManager current windowsDirectory.
	File forDirectoriesIn: windir do: [:each | all add: each fileName asLowercase].
	self assert: (all includes: 'system32').
	self assert: (all includes: 'system').
	self deny: (all includes: '.').
	self deny: (all includes: '..').
	all do: 
			[:each | 
			| dirPath |
			dirPath := File composePath: windir subPath: each.
			self assert: (File isDirectory: dirPath)]!

testRemoveDirectory
	self createTestDirectories.
	
	self removeDirectory: 'c:\FileTest1\EmptyLeaf'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf2'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	"Presense of sub-directories or files should prevent remove working"
	self should: [File removeDirectory: 'c:\FileTest1\LeafWithFile\'] raise: Win32Error.
	self should: [File removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'] raise: Win32Error.

!

testRemoveExtension
	#(#('a.exe' 'a') #('a.' 'a') #('.exe' '') #('.' '') #('' '') #('1234.1234.exe' '1234.1234') #('1234.1234.+' '1234.1234') #('a.b\c' 'a.b\c') #('a.b\' 'a.b\')) 
		do: [:eachPair | self assert: (File removeExtension: eachPair first) = eachPair last]!

testRemovePathDelimiter
	self assert: (File removePathDelimiter: '') = ''.
	self assert: (File removePathDelimiter: '/') = ''.
	self assert: (File removePathDelimiter: '//') = '/'.
	self assert: (File removePathDelimiter: '\') = ''.
	self assert: (File removePathDelimiter: '\/') = '\'.
	self assert: (File removePathDelimiter: '.') = '.'.
	self assert: (File removePathDelimiter: './') = '.'.
	self assert: (File removePathDelimiter: 'c:') = 'c:'.
	self assert: (File removePathDelimiter: 'c:\') = 'c:'.
	self assert: (File removePathDelimiter: 'c:\blah.txt') = 'c:\blah.txt'.
	self assert: (File removePathDelimiter: 'c:\blah') = 'c:\blah'.
	self assert: (File removePathDelimiter: 'c:\blah\') = 'c:\blah'.







! !
!FileTest categoriesFor: #createTestDirectories!helpers!private! !
!FileTest categoriesFor: #deleteDirectory:!helpers!public! !
!FileTest categoriesFor: #deleteTestDirectories!private!Running! !
!FileTest categoriesFor: #relativePathOf:to:!helpers!public! !
!FileTest categoriesFor: #removeDirectory:!helpers!private! !
!FileTest categoriesFor: #tearDown!private!Running! !
!FileTest categoriesFor: #test64BitSeek!public!unit tests! !
!FileTest categoriesFor: #testClassAppendPathSeparator!public!unit tests! !
!FileTest categoriesFor: #testClassRelativePathOfTo!public!unit tests! !
!FileTest categoriesFor: #testDeleteDirectory!public!unit tests! !
!FileTest categoriesFor: #testForDirectoriesIn!public!unit tests! !
!FileTest categoriesFor: #testRemoveDirectory!public!unit tests! !
!FileTest categoriesFor: #testRemoveExtension!public!unit tests! !
!FileTest categoriesFor: #testRemovePathDelimiter!public!unit tests! !

