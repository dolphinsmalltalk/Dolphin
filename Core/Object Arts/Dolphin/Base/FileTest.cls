"Filed out from Dolphin Smalltalk 7"!

DolphinTest subclass: #FileTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'Win32Constants'
	classInstanceVariableNames: ''!
FileTest guid: (GUID fromString: '{26ae9922-21e2-489a-845c-3c1dc1c2a3cf}')!
FileTest comment: ''!
!FileTest categoriesForClass!Unclassified! !
!FileTest methodsFor!

buildTestPathOfLength: anInteger
	| maxPath |
	maxPath := String writeStream.
	maxPath nextPutAll: 'c:\'.
	0 to: anInteger - 8 do: [:i | maxPath nextPut: ('abcdefghij\' at: i % 11 + 1)].
	maxPath := maxPath contents.
	maxPath last = $\ ifTrue: [maxPath := maxPath allButLast , 'a'].
	maxPath := maxPath , '.txt'.
	self assert: maxPath size equals: anInteger.
	^maxPath!

createTestDirectories
	| dir |
	File createDirectoryPath: 'c:\FileTest1\EmptyLeaf'.

	dir := 'c:\FileTest1\LeafWithFile\'.
	File createDirectoryPath: dir.
	(FileStream write: dir, 'Blah.txt') nextPutAll: 'Blah'; close.

	dir := 'c:\FileTest1\LeafWithFiles\'.
	File createDirectoryPath: dir.
	(FileStream write: dir, 'Blah1.txt') nextPutAll: 'Blah'; close.
	(FileStream write: dir, 'Blah2.txt') nextPutAll: 'Blah blah'; close.

	File createDirectoryPath: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.

	dir := 'c:\FileTest1\BranchWithEmptyLeaves\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.

	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	File createDirectoryPath: dir, '\EmptyLeaf1'.
	(FileStream write: dir, 'blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	(FileStream write: dir, 'blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, 'blah2.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.
	(FileStream write: dir, 'blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	File createDirectoryPath: dir, 'EmptyLeaf1'.
	File createDirectoryPath: dir, 'EmptyLeaf2'.
	(FileStream write: dir, 'blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, 'blah2.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithLeafWithFile\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir, 'LeafWithFile'.
	(FileStream write: dir, '\LeafWithFile\blah.txt') nextPutAll: 'Blah blah blah'; close.

	dir := 'c:\FileTest1\BranchWithLeafWithFiles🐬\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir, 'LeafWithFiles'.
	(FileStream write: dir, '\LeafWithFiles\blah1.txt') nextPutAll: 'Blah blah blah'; close.
	(FileStream write: dir, '\LeafWithFiles\blah2.txt') nextPutAll: 'Blah blah blah'; close.

!

deleteDirectory: aString 
	self assert: (File isDirectory: aString).
	File deleteDirectory: aString.
	self assert: (File exists: aString) not.!

deleteTestDirectories
	File deleteDirectory: 'c:\FileTest1\'!

printFilenameOfLength: anInteger on: path
	(1 to: anInteger) do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))].
	path nextPut: $..
	(1 to: CRTConstants._MAX_EXT - 1)
		do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))]!

relativePathOf: a to: b
	^File relativePathOf: a to: b!

removeDirectory: aString 
	"Private - This stub method was auto-generated by the Dolphin debugger and remains to be correctly implemented."

	self assert: (File isDirectory: aString).
	File removeDirectory: aString.
	self assert: (File exists: aString) not.
!

tearDown
	[self deleteTestDirectories] on: Win32Error do: [:e |]!

test64BitSeek
	"Tests #755"

	| f dist pointer |
	f := File temporary.
	0 to: 31
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := f seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := f seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := f seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	32 to: 62
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := f seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := f seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := f seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := f seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	pointer := f seek: -1 sense: FILE_CURRENT.
	self assert: pointer identicalTo: 0.
	"As the 64-bit offset is signed, the maximum seek offset is 2^63-1"
	self should: [f seek: 2 ** 63 sense: FILE_BEGIN] raise: Error.
	"Test the condition where the low-word of the return is 16rFFFFFFFF, so GetLastError() is needed to disambiguate from an error condition."
	dist := 2 ** 32 - 1.
	pointer := f seek: dist sense: FILE_BEGIN.
	"Now test maximum seek distance"
	dist := 2 ** 63 - 1.
	pointer := f seek: dist sense: FILE_BEGIN.
	self assert: pointer equals: dist.
	"Although not really a negative seek, it would cause a 64-bit signed file pointer to go negative"
	self
		should: [f seek: 1 sense: FILE_CURRENT]
		raise: FileException
		matching: [:ex | ex statusCode = 131	"ERROR_NEGATIVE_SEEK"].
	pointer := f seek: dist negated sense: FILE_CURRENT.
	self assert: pointer equals: 0.
	f close.
	File delete: f name!

testClassAppendPathSeparator
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	| unicode |
	self assert: (File appendPathDelimiter: 'c:\') equals: 'c:\'.
	self assert: (File appendPathDelimiter: 'c:/') equals: 'c:/'.
	self assert: (File appendPathDelimiter: 'c:.') equals: 'c:.\'.
	self assert: (File appendPathDelimiter: '') equals: '\'.
	unicode := 'a' , $\x1F595 asUtf8String.
	self assert: (File appendPathDelimiter: unicode) equals: unicode , '\'.
	self assert: (File appendPathDelimiter: 'a\') equals: 'a\'.
	self assert: (File appendPathDelimiter: 'a\\') equals: 'a\\'.
	self assert: (File appendPathDelimiter: '\') equals: '\'.
	self assert: (File appendPathDelimiter: '/') equals: '/'.
	self assert: (File appendPathDelimiter: 'a/') equals: 'a/'!

testClassRelativePathOfTo
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (self relativePathOf: '.' to: '.') equals: '.'.
	self assert: (self relativePathOf: '..' to: '.') equals: '..'.
	self assert: (self relativePathOf: '..\' to: '.') equals: '..\'.
	self assert: (self relativePathOf: '..' to: '.\') equals: '..'.
	self assert: (self relativePathOf: '.' to: '..') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: '.\' to: '..') equals: ''.
	self assert: (self relativePathOf: '.' to: '..\') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: 'c:\' to: 'd:\') equals: 'c:\'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1\') equals: 'blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1.txt') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2\') equals: '..\1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2.txt') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1') equals: '1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1\') equals: '11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21\') equals: '..\..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21') equals: '..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21.txt') equals: '..\1\11\blah.txt'.

	"Example from MS IMoniker documentation"
	self assert: (self relativePathOf: 'c:\projects\secret\art\pict1.bmp'
				to: 'c:\projects\secret\docs\chap1.txt')
		equals: '..\art\pict1.bmp'.
	self assert: (self relativePathOf: 'c:\projects\secret\docs\chap1.txt'
				to: 'c:\projects\secret\art\pict1.bmp')
		equals: '..\docs\chap1.txt'.
	"A common type of useage in Dolphin (image relative path)"
	self assert: (self
				relativePathOf: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax.pac'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax.pac'.
	"Non-canonical path with redundant components - note result is not canonical either"
	self
		assert: (File fullPathOf: (self
						relativePathOf: 'd:\dummy\..\object arts\dev\dummy\..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
						to: 'd:\object arts\dev\dolphin5\')
				relativeTo: 'd:\object arts\dev\dolphin5\')
		equals: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax'.

	"Already a relative path (therefore fails and answers first argument)"
	self assert: (self relativePathOf: 'Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '.\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'!

testCommonPrefixOfAnd
	self
		assert: ((File commonPrefixOf: KernelLibrary default moduleFileName
				and: UserLibrary default moduleFileName) sameAs: SessionManager current systemDirectory).
	self
		assert: (File commonPrefixOf: VMLibrary default moduleFileName
				and: UserLibrary default moduleFileName) isEmpty!

testDeleteDirectory
	self createTestDirectories.
	self deleteDirectory: 'c:\FileTest1\EmptyLeaf'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	self deleteDirectory: 'c:\FileTest1\LeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFiles🐬\'!

testForDirectoriesIn
	| all windir |
	all := OrderedCollection new.
	windir := SessionManager current windowsDirectory.
	File forDirectoriesIn: windir do: [:each | all add: each fileName asLowercase].
	self assert: (all includes: 'system32').
	self assert: (all includes: 'system').
	self deny: (all includes: '.').
	self deny: (all includes: '..').
	all do: 
			[:each | 
			| dirPath |
			dirPath := File composePath: windir subPath: each.
			self assert: (File isDirectory: dirPath)]!

testMakePath
	| filename split |
	self assert: (File makePath: #('c:' 'a/b 2/c/' 'a file' '.anextension'))
		equals: 'c:a/b 2/c/a file.anextension'.
	self assert: (File makePath: #('c' '\dir' 'file' 'txt')) equals: 'c:\dir\file.txt'.
	self assert: (File makePath: #(nil nil nil nil)) equals: ''.
	self assert: (File makePath: #('' '' '' '')) equals: ''.
	self assert: (File makePath: #('c' '' '' '')) equals: 'c:'.
	self assert: (File makePath: #('c' 'abc' '' '')) equals: 'c:abc\'.
	self assert: (File makePath: #('c' '' 'file' '')) equals: 'c:file'.
	self assert: (File makePath: #('c' '' '' 'txt')) equals: 'c:.txt'.
	self assert: (File makePath: #('c' '' 'a b c' 'txt')) equals: 'c:a b c.txt'.
	self assert: (File makePath: #('c' 'a/b' 'file' '')) equals: 'c:a/b\file'.
	self assert: (File makePath: #('c' '\' '' '')) equals: 'c:\'.
	self assert: (File makePath: #('' 'a\b' '' '')) equals: 'a\b\'.
	self assert: (File makePath: #('' '' 'file' '')) equals: 'file'.
	self assert: (File makePath: #('' '' '' 'txt')) equals: '.txt'.
	"Shouldn't matter if the filename is notionally too long"
	filename := String writeStream.
	self printFilenameOfLength: CRTConstants._MAX_FNAME * 2 on: filename.
	filename := filename contents.
	split := filename subStrings: $..
	self
		assert: (File makePath: (Array
						with: nil
						with: nil
						with: split first
						with: split second))
		equals: filename!

testRemoveDirectory
	self createTestDirectories.
	
	self removeDirectory: 'c:\FileTest1\EmptyLeaf'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf2'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	"Presense of sub-directories or files should prevent remove working"
	self should: [File removeDirectory: 'c:\FileTest1\LeafWithFile\'] raise: Win32Error.
	self should: [File removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'] raise: Win32Error.

!

testRemoveExtension
	| path |
	self should: [File removeExtension: nil] raise: Error.
	self assert: (File removeExtension: 'a.') equals: 'a'.
	self assert: (File removeExtension: '.exe') equals: ''.
	self assert: (File removeExtension: '.') equals: ''.
	self assert: (File removeExtension: '') equals: ''.
	self assert: (File removeExtension: '1234.1234.exe') equals: '1234.1234'.
	self assert: (File removeExtension: '1234.1234.+') equals: '1234.1234'.
	self assert: (File removeExtension: 'a.b\c') equals: 'a.b\c'.
	self assert: (File removeExtension: 'a.b\') equals: 'a.b\'.
	self assert: (File removeExtension: 'c:/a/b.txt') equals: 'c:/a/b'.
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: CRTConstants._MAX_FNAME on: path.
	path := path contents.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first.
	"Doesn't matter if the path is notionally too long"
	path := self buildTestPathOfLength: CRTConstants._MAX_PATH * 2.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first!

testRemovePathDelimiter
	| unicode |
	self assert: (File removePathDelimiter: '') equals: ''.
	self assert: (File removePathDelimiter: '/') equals: ''.
	self assert: (File removePathDelimiter: '//') equals: '/'.
	self assert: (File removePathDelimiter: '\') equals: ''.
	self assert: (File removePathDelimiter: '\/') equals: '\'.
	self assert: (File removePathDelimiter: '.') equals: '.'.
	self assert: (File removePathDelimiter: './') equals: '.'.
	self assert: (File removePathDelimiter: 'c:') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\blah.txt') equals: 'c:\blah.txt'.
	unicode := 'c:\blah' asUtf8String copyWith: $\x1F595.
	self assert: (File removePathDelimiter: unicode) equals: unicode.
	self assert: (File removePathDelimiter: unicode , '\') equals: unicode!

testShortPath
	| sysdir tmpDir tmpFile |
	sysdir := SessionManager current systemDirectory.
	self assert: (File shortPathOf: sysdir) asAnsiString equals: sysdir.
	tmpDir := File tempPath , GUID newUnique asString, Character dolphin asUtf8String.
	tmpFile := File composePath: tmpDir subPath: $\x1F595 asUtf8String , '.txt'.
	File createDirectory: tmpDir.
	
	[| short |
	(File open: tmpFile mode: #create) close.
	short := File shortPathOf: tmpFile.
	self deny: short equals: tmpFile.
	"This will fail if the short name still includes unicode"
	short := short asAnsiString.
	self assert: (File exists: short)]
			ensure: [File deleteDirectory: tmpDir]!

testSplitDriveFrom
	self should: [File splitDriveFrom: nil] raise: Error.
	self assert: (File splitDriveFrom: 'c:\a\a2/b.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'a\b.txt') equals: ''.
	self assert: (File splitDriveFrom: 'b.txt') equals: ''.
	self assert: (File splitDriveFrom: '.txt') equals: ''.
	self assert: (File splitDriveFrom: '.') equals: ''.
	self assert: (File splitDriveFrom: '') equals: ''.
	self assert: (File splitDriveFrom: 'c:/a b\c d.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'd:\') equals: 'd:'.
	self assert: (File splitDriveFrom: 'e:') equals: 'e:'.
	self assert: (File splitDriveFrom: 'cons:') equals: ''!

testSplitExtensionFrom
	| path ext unicode |
	self should: [File splitExtensionFrom: nil] raise: Error.
	unicode := $\x1F595 asUtf16String , '2'.
	self assert: (File splitExtensionFrom: 'c:\a\a2/b.' , unicode) equals: unicode.
	self assert: (File splitExtensionFrom: 'a\b.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: 'b.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: 'b.') equals: ''.
	self assert: (File splitExtensionFrom: '.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: '.') equals: ''.
	self assert: (File splitExtensionFrom: '') equals: ''.
	self assert: (File splitExtensionFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitExtensionFrom: 'c:/a b\c d.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: '1234.1234.exe') equals: 'exe'.
	self assert: (File splitExtensionFrom: 'a.b\c') equals: ''.
	self assert: (File splitExtensionFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: CRTConstants._MAX_PATH.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"The CRT functions works even if the path is too long because we ignore everything but the extension"
	path := path , 'x'.
	self assert: (File splitExtensionFrom: path) equals: 'txtx'.
	path := self buildTestPathOfLength: CRTConstants._MAX_PATH * 2.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"Try a very filename with very long extension (of max length)."
	path := String writeStream.
	self printFilenameOfLength: CRTConstants._MAX_FNAME * 2 on: path.
	path := path contents.
	ext := (path subStrings: $.) last.
	self assert: (File splitExtensionFrom: path) equals: ext.
	"Works even if extension is notionally too large"
	path := path , ext.
	self assert: (File splitExtensionFrom: path) equals: ext , ext!

testSplitFilenameFrom
	| path unicode |
	self should: [File splitFilenameFrom: nil] raise: Error.
	self assert: (File splitFilenameFrom: '.') equals: '.'.
	self assert: (File splitFilenameFrom: 'c:\a\a2/b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'a\b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'b.') equals: 'b.'.
	self assert: (File splitFilenameFrom: '.txt') equals: '.txt'.
	self assert: (File splitFilenameFrom: '') equals: ''.
	self assert: (File splitFilenameFrom: 'c:\a\b\') equals: ''.
	unicode := 'c ' , $\x1F595 asUtf16String , ' d.txt'.
	self assert: (File splitFilenameFrom: 'c:/a b\' , unicode) equals: unicode.
	self assert: (File splitFilenameFrom: '1234.1234.exe') equals: '1234.1234.exe'.
	self assert: (File splitFilenameFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitFilenameFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: CRTConstants._MAX_PATH.
	self assert: (File splitFilenameFrom: path) equals: (path subStrings: $\) last.
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: CRTConstants._MAX_FNAME * 2 on: path.
	path := path contents.
	self assert: (File splitFilenameFrom: path) equals: (path copyFrom: 4)!

testSplitStemFrom
	| path |
	self should: [File splitStemFrom: nil] raise: Error.
	self assert: (File splitStemFrom: '.') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\a2/b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'a\b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'b.') equals: 'b'.
	self assert: (File splitStemFrom: '.txt') equals: ''.
	self assert: (File splitStemFrom: '') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitStemFrom: 'c:/a b\c d.txt') equals: 'c d'.
	self assert: (File splitStemFrom: '1234.1234.exe') equals: '1234.1234'.
	self assert: (File splitStemFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitStemFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: CRTConstants._MAX_PATH.
	self assert: (File splitStemFrom: path) equals: ((path subStrings: $\) last upTo: $.).
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: CRTConstants._MAX_FNAME * 2 on: path.
	path := path contents.
	self assert: (File splitStemFrom: path) equals: ((path copyFrom: 4) upTo: $.)! !
!FileTest categoriesFor: #buildTestPathOfLength:!helpers!private! !
!FileTest categoriesFor: #createTestDirectories!helpers!private! !
!FileTest categoriesFor: #deleteDirectory:!helpers!public! !
!FileTest categoriesFor: #deleteTestDirectories!private!Running! !
!FileTest categoriesFor: #printFilenameOfLength:on:!helpers!private! !
!FileTest categoriesFor: #relativePathOf:to:!helpers!public! !
!FileTest categoriesFor: #removeDirectory:!helpers!private! !
!FileTest categoriesFor: #tearDown!private!Running! !
!FileTest categoriesFor: #test64BitSeek!public!unit tests! !
!FileTest categoriesFor: #testClassAppendPathSeparator!public!unit tests! !
!FileTest categoriesFor: #testClassRelativePathOfTo!public!unit tests! !
!FileTest categoriesFor: #testCommonPrefixOfAnd!public!unit tests! !
!FileTest categoriesFor: #testDeleteDirectory!public!unit tests! !
!FileTest categoriesFor: #testForDirectoriesIn!public!unit tests! !
!FileTest categoriesFor: #testMakePath!public!unit tests! !
!FileTest categoriesFor: #testRemoveDirectory!public!unit tests! !
!FileTest categoriesFor: #testRemoveExtension!public!unit tests! !
!FileTest categoriesFor: #testRemovePathDelimiter!public!unit tests! !
!FileTest categoriesFor: #testShortPath!public!unit tests! !
!FileTest categoriesFor: #testSplitDriveFrom!public!unit tests! !
!FileTest categoriesFor: #testSplitExtensionFrom!public!unit tests! !
!FileTest categoriesFor: #testSplitFilenameFrom!public!unit tests! !
!FileTest categoriesFor: #testSplitStemFrom!public!unit tests! !

