"Filed out from Dolphin Smalltalk"!

Core.Tests.DolphinTest
	subclass: #'Core.Tests.FileTest'
	instanceVariableNames: 'tempFile'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants} #{OS.CRTConstants})
	classInstanceVariableNames: ''
	classConstants: {}!

Core.Tests.FileTest guid: (Core.GUID fromString: '{26ae9922-21e2-489a-845c-3c1dc1c2a3cf}')!

Core.Tests.FileTest comment: ''!

!Core.Tests.FileTest methodsFor!

buildTestPathOfLength: anInteger
	| maxPath |
	maxPath := String writeStream.
	maxPath nextPutAll: 'c:\'.
	0 to: anInteger - 8 do: [:i | maxPath nextPut: ('a🍺cd£eghij\' at: i % 11 + 1)].
	maxPath := maxPath contents.
	maxPath last = $\ ifTrue: [maxPath := maxPath allButLast , 'a'].
	maxPath := maxPath , '.txt'.
	self assert: maxPath size equals: anInteger.
	^maxPath!

createTestDirectories
	| dir |
	File createDirectoryPath: 'c:\FileTest1\EmptyLeaf'.
	dir := 'c:\FileTest1\LeafWithFile\'.
	File createDirectoryPath: dir.
	(FileStream write: dir , 'Blah.txt')
		nextPutAll: 'Blah';
		close.
	dir := 'c:\FileTest1\LeafWithFiles\'.
	File createDirectoryPath: dir.
	(FileStream write: dir , 'Blah1.txt')
		nextPutAll: 'Blah';
		close.
	(FileStream write: dir , 'Blah2.txt')
		nextPutAll: 'Blah blah';
		close.
	File createDirectoryPath: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	dir := 'c:\FileTest1\BranchWithEmptyLeaves\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	File createDirectoryPath: dir , '\EmptyLeaf1'.
	(FileStream write: dir , 'blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	(FileStream write: dir , 'blah1.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , 'blah2.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	(FileStream write: dir , 'blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	(FileStream write: dir , 'blah1.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , 'blah2.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithLeafWithFile\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir , 'LeafWithFile'.
	(FileStream write: dir , '\LeafWithFile\blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithLeafWithFiles🐬\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir , 'LeafWithFiles'.
	(FileStream write: dir , '\LeafWithFiles\a🐬b.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , '\LeafWithFiles\a£b.txt')
		nextPutAll: 'Blah blah blah';
		close!

deleteDirectory: aString
	self assert: (File isDirectory: aString).
	File deleteDirectory: aString.
	self assert: (File exists: aString) not!

deleteTestDirectories
	File deleteDirectory: 'c:\FileTest1\'!

maxFname
	^_MAX_FNAME!

printFilenameOfLength: anInteger on: path
	(1 to: anInteger) do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))].
	path nextPut: $..
	(1 to: _MAX_EXT - 1) do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))]!

relativePathOf: a to: b
	^File relativePathOf: a to: b!

removeDirectory: aString
	"Private - This stub method was auto-generated by the Dolphin debugger and remains to be correctly implemented."

	self assert: (File isDirectory: aString).
	File removeDirectory: aString.
	self assert: (File exists: aString) not!

tearDown
	[self deleteTestDirectories] on: OS.Win32Error do: [:e | ].
	tempFile
		ifNotNil: [
			[tempFile close.
			File delete: tempFile name] on: OS.Win32Error do: [:e | ]].
	super tearDown!

test64BitSeek
	"Tests #755"

	| dist pointer |
	tempFile := File temporary.
	0 to: 31
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := tempFile seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := tempFile seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := tempFile seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	32 to: 62
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := tempFile seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := tempFile seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := tempFile seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	pointer := tempFile seek: -1 sense: FILE_CURRENT.
	self assert: pointer identicalTo: 0.
	"As the 64-bit offset is signed, the maximum seek offset is 2^63-1"
	self should: [tempFile seek: 2 ** 63 sense: FILE_BEGIN] raise: Error.
	"Test the condition where the low-word of the return is 16rFFFFFFFF, so GetLastError() is needed to disambiguate from an error condition."
	dist := 2 ** 32 - 1.
	pointer := tempFile seek: dist sense: FILE_BEGIN.
	"Now test maximum seek distance"
	dist := 2 ** 63 - 1.
	pointer := tempFile seek: dist sense: FILE_BEGIN.
	self assert: pointer equals: dist.
	"Although not really a negative seek, it would cause a 64-bit signed file pointer to go negative"
	self
		should: [tempFile seek: 1 sense: FILE_CURRENT]
		raise: FileException
		matching: [:ex | ex statusCode = 131	"ERROR_NEGATIVE_SEEK"].
	pointer := tempFile seek: dist negated sense: FILE_CURRENT.
	self assert: pointer equals: 0!

testCanonicalizePath
	"Test File class>>composePath:subPath:"

	"Mainstream case"

	self assert: (File canonicalizePath: 'd:\£oo\bar\a🐬b\baz.txt')
		equals: 'd:\£oo\bar\a🐬b\baz.txt'.
	"Unecessary long path prefix"
	self assert: (File canonicalizePath: '\\?\d:\£oo\bar\a🐬b\baz.txt')
		equals: 'd:\£oo\bar\a🐬b\baz.txt'.
	"Empty - inconsistent behaviour, although consistently inconsistent with PathCombine API"
	self assert: (File canonicalizePath: '') equals: '\'.
	self assert: (File canonicalizePath: 'c:') equals: 'c:'.

	".. and . components"
	self assert: (File canonicalizePath: 'C:\£oo\bar\a£\..\.\..\🐬.txt') equals: 'C:\£oo\🐬.txt'.
	self assert: (File canonicalizePath: '.\🐬-🐬.txt') equals: '🐬-🐬.txt'.

	"MAX_PATH"
	self assert: (File canonicalizePath: 'c:\' , (String new: MAX_PATH - 4 withAll: $a))
		equals: 'c:\' , (String new: MAX_PATH - 4 withAll: $a).

	"> MAX_PATH"
	self assert: (File canonicalizePath: 'c:\' , (String new: MAX_PATH - 3 withAll: $a))
		equals: '\\?\c:\' , (String new: MAX_PATH - 3 withAll: $a).
	self assert: (File canonicalizePath: '\\?\c:\' , (String new: MAX_PATH - 3 withAll: $a))
		equals: '\\?\c:\' , (String new: MAX_PATH - 3 withAll: $a)!

testClassAppendPathSeparator
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (File appendPathDelimiter: 'c:\') equals: 'c:\'.
	self assert: (File appendPathDelimiter: 'c:/') equals: 'c:/'.
	self assert: (File appendPathDelimiter: 'c:.') equals: 'c:.\'.
	self assert: (File appendPathDelimiter: '') equals: '\'.
	self assert: (File appendPathDelimiter: 'a🖕b') equals: 'a🖕b\'.
	self assert: (File appendPathDelimiter: 'a') equals: 'a\'.
	self assert: (File appendPathDelimiter: 'a\') equals: 'a\'.
	self assert: (File appendPathDelimiter: 'a\\') equals: 'a\\'.
	self assert: (File appendPathDelimiter: '\') equals: '\'.
	self assert: (File appendPathDelimiter: '/') equals: '/'.
	self assert: (File appendPathDelimiter: 'a/') equals: 'a/'!

testClassDefaultExtension
	| s s2 |
	#(#('' '' '') #('a.' '' 'a') #('a.' '.' 'a.') #('a' '' 'a') #('a' '.b' 'a.b') #('a.' 'b' 'a.b') #('a.' '.b' 'a.b') #('a.b' '.c' 'a.b') #('abc' 'txt' 'abc.txt') #('abc.def\xyz' '.txt' 'abc.def\xyz.txt') #('abc.d\xy' 'txt' 'abc.d\xy.txt') #('x\' '🐬' 'x\.🐬') #('文字化け\你🐬好' 'dll' '文字化け\你🐬好.dll') #('x\abc.a🐬' 'txt' 'x\abc.a🐬'))
		do: 
			[:each |
			| actual |
			actual := File default: each first extension: each second.
			self assert: actual equals: each last.
			actual := File default: each first asUtf16String extension: each second asUtf16String.
			self assert: actual equals: each last].
	"Long paths"
	s := String writeStream.
	s nextPutAll: 'c:'.
	10 timesRepeat: 
			[s
				nextPut: $\;
				nextPutAll: GUID newUnique idlString].
	s := s contents.
	self assert: s size > MAX_PATH.
	s2 := File default: s extension: 'txt'.
	self assert: s2 equals: s , '.txt'.
	s2 := File default: s extension: '.blah'.
	self assert: s2 equals: s , '.blah'!

testClassPathExtension
	| s s2 |
	#(#('' '' '') #('' 'a' '.a') #('' '.a' '.a') #('a' '' 'a') #('a.' '' 'a') #('a' 'b' 'a.b') #('a' '.b' 'a.b') #('a.b' 'c' 'a.c') #('a.exe' '.dll' 'a.dll') #('c:' 'bat' 'c:.bat') #('\' '.cmd' '\.cmd') #('ab\cd.exe' 'dll' 'ab\cd.dll') #('a\' 'b' 'a\.b') #('a.b' '' 'a') #('\a\b\.c' '' '\a\b\') #('a.longlonglonglongextension' '.evenlongerlonglonglonglongextension' 'a.evenlongerlonglonglonglongextension') #('c:\wibble\wobble' '.blah' 'c:\wibble\wobble.blah') #('文字化け.txt' '你🐬好' '文字化け.你🐬好') #('文字化け.你🐬好' '.txt' '文字化け.txt'))
		do: 
			[:each |
			| actual |
			actual := File path: each first extension: each second.
			self assert: actual equals: each last].
	"Long paths"
	s := String writeStream.
	s nextPutAll: 'c:'.
	10 timesRepeat: 
			[s
				nextPut: $\;
				nextPutAll: GUID newUnique idlString].
	s := s contents.
	self assert: s size > MAX_PATH.
	s2 := File path: s extension: 'txt'.
	self assert: s2 equals: s , '.txt'.
	s2 := File path: s extension: '.blah'.
	self assert: s2 equals: s , '.blah'!

testClassRelativePathOfTo
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (self relativePathOf: '.' to: '.') equals: '.'.
	self assert: (self relativePathOf: '..' to: '.') equals: '..'.
	self assert: (self relativePathOf: '..\' to: '.') equals: '..\'.
	self assert: (self relativePathOf: '..' to: '.\') equals: '..'.
	self assert: (self relativePathOf: '.' to: '..') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: '.\' to: '..') equals: ''.
	self assert: (self relativePathOf: '.' to: '..\') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: 'c:\' to: 'd:\') equals: 'c:\'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\') equals: '1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\1\') equals: 'a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\1') equals: '1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\1.txt') equals: '1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\2\') equals: '..\1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\2') equals: '1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\a🐬b.txt' to: 'c:\2.txt') equals: '1\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\11\a🐬b.txt' to: 'c:\1') equals: '1\11\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\11\a🐬b.txt' to: 'c:\1\') equals: '11\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\11\a🐬b.txt' to: 'c:\2\21\') equals: '..\..\1\11\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\11\a🐬b.txt' to: 'c:\2\21') equals: '..\1\11\a🐬b.txt'.
	self assert: (self relativePathOf: 'c:\1\11\a🐬b.txt' to: 'c:\2\21.txt') equals: '..\1\11\a🐬b.txt'.

	"Example from MS IMoniker documentation"
	self assert: (self relativePathOf: 'c:\projects\secret\art\pict1.bmp'
				to: 'c:\projects\secret\docs\chap1.txt')
		equals: '..\art\pict1.bmp'.
	self assert: (self relativePathOf: 'c:\projects\secret\docs\chap1.txt'
				to: 'c:\projects\secret\art\pict1.bmp')
		equals: '..\docs\chap1.txt'.
	"A common type of useage in Dolphin (image relative path)"
	self assert: (self
				relativePathOf: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax.pac'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax.pac'.
	"Non-canonical path with redundant components - note result is not canonical either"
	self
		assert: (File fullPathOf: (self
						relativePathOf: 'd:\dummy\..\object arts\dev\dummy\..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
						to: 'd:\object arts\dev\dolphin5\')
				relativeTo: 'd:\object arts\dev\dolphin5\')
		equals: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax'.

	"Already a relative path (therefore fails and answers first argument)"
	self assert: (self relativePathOf: 'Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '.\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'!

testCommonPrefixOfAnd
	self
		assert: ((File commonPrefixOf: OS.Kernel32 moduleFileName and: OS.User32 moduleFileName)
				sameAs: SessionManager current systemDirectory).
	self
		assert: (File commonPrefixOf: 'D:\dev\Dolphin\DolphinVM7.DLL' and: 'C:\dev\Dolphin\DolphinVM7.DLL')
				isEmpty!

testComposePath
	"Test File class>>composePath:subPath:"

	"Mainstream cases"

	self assert: (File composePath: 'd:\£oo\bar\' subPath: 'a🐬b\baz.txt')
		equals: 'd:\£oo\bar\a🐬b\baz.txt'.
	self assert: (File composePath: '\\?\d:\£oo\bar\' subPath: 'a🐬b\baz.txt')
		equals: 'd:\£oo\bar\a🐬b\baz.txt'.
	"Empty base path"
	self assert: (File composePath: '' subPath: '🐬.txt') equals: '🐬.txt'.
	"Empty sub path"
	self assert: (File composePath: 'c:\£oo\bar.txt' subPath: '') equals: 'c:\£oo\bar.txt'.
	"Both parts empty - the Windows PathCombine functions are documented to do this. Doesn't seem consistent with earlier empty base path case."
	self assert: (File composePath: '' subPath: '') equals: '\'.
	"Similar case that doesn't seem right either"
	self assert: (File composePath: '£oo🐬bar' subPath: '..') equals: '\'.

	".. and . components"
	self assert: (File composePath: 'C:\£oo\bar\a£\..\.' subPath: '..\🐬.txt')
		equals: 'C:\£oo\🐬.txt'.
	self assert: (File composePath: '.' subPath: '🐬-🐬.txt') equals: '🐬-🐬.txt'.
	self assert: (File composePath: '🐬-🐬.txt' subPath: '.') equals: '🐬-🐬.txt'.
	self assert: (File composePath: 'c:' subPath: '.') equals: 'c:\'.
	self assert: (File composePath: '.' subPath: 'e:') equals: 'e:\'.

	"Cases where the result is (one) longer than the sum of the lengths of the two parts"
	self assert: (File composePath: 'c:' subPath: '🐬-🐬.txt') equals: 'c:\🐬-🐬.txt'.
	"PathAllocCombine behaves differently here than the old PathCombine function - it doesn't append a backslash, which wasn't really correct anyway."
	self assert: (File composePath: 'd:' subPath: '') equals: 'd:'.

	"MAX_PATH"
	self assert: (File composePath: 'c:' subPath: (String new: MAX_PATH - 4 withAll: $a))
		equals: 'c:\' , (String new: MAX_PATH - 4 withAll: $a).

	"MAX_PATH+1 - Path*Combine prepends the long path prefix, \\?\"
	self assert: (File composePath: 'c:' subPath: (String new: MAX_PATH - 3 withAll: $a))
		equals: '\\?\c:\' , (String new: MAX_PATH - 3 withAll: $a).
	self assert: (File composePath: '\\?\c:' subPath: (String new: MAX_PATH - 3 withAll: $a))
		equals: '\\?\c:\' , (String new: MAX_PATH - 3 withAll: $a)!

testCreateDirectoryPath
	| tempDir |
	tempDir := File createTemporaryDirectory asUtf16String.
	
	[| path |
	path := File composePath: tempDir subPath: 'one'.
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: 'one\two\three'.
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: (String new: 248 - tempDir size - 1 withAll: $a).
	self assert: path size equals: 248.
	self deny: (path beginsWith: '\\?\').
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: (String new: 248 - tempDir size withAll: $b).
	self assert: path size equals: 249.
	self deny: (path beginsWith: '\\?\').
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: (String new: 255 - tempDir size - 1 withAll: $b).
	self assert: path size equals: 255.
	self deny: (path beginsWith: '\\?\').
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: (String new: MAX_PATH - tempDir size - 2 withAll: $c).
	self assert: path size equals: MAX_PATH - 1.
	self deny: (path beginsWith: '\\?\').
	File createDirectoryPath: path.
	self assert: (File isDirectory: path).
	path := File composePath: tempDir subPath: 'long\' , (String new: 250 withAll: $£).
	self assert: (path beginsWith: '\\?\').
	File createDirectoryPath: path.
	self assert: (File isDirectory: path)]
			ensure: [File deleteDirectory: tempDir]!

testCreateTemporaryDirectory
	| tempDir tempDir2 |
	tempDir := File createTemporaryDirectory.
	tempDir2 := File createTemporaryDirectory.
	self deny: tempDir equals: tempDir2.
	self deleteDirectory: tempDir.
	self deleteDirectory: tempDir2!

testDeleteDirectory
	self createTestDirectories.
	self deleteDirectory: 'c:\FileTest1\EmptyLeaf'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	self deleteDirectory: 'c:\FileTest1\LeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFiles🐬\'!

testFileNotFound
	| tmpFilePath |
	tmpFilePath := File composePath: File tempPath subPath: GUID newUnique idlString.
	self deny: (File exists: tmpFilePath).
	tempFile := [File open: tmpFilePath] on: OS.Win32Error
				do: 
					[:ex |
					self assert: (ex isResumable and: [ex statusCode = OS.Win32Errors.ERROR_FILE_NOT_FOUND]).
					(File open: tmpFilePath mode: #create) close.
					ex resume].
	self assert: (File canonicalizePath: tempFile pathName) equals: (File canonicalizePath: tmpFilePath)!

testFileTimes
	"Tests that file accesor exists and that #lastWriteTime works (for patch #1397)"

	| now file tempFileName |
	now := OS.FILETIME now.
	tempFileName := File temporaryFilename.
	file := File open: tempFileName.
	self assert: file lastWriteTime asInteger >= now asInteger.
	file close.
	File delete: tempFileName!

testFindFiles
	| found |
	found := Set new.
	File
		for: '*.' , SessionManager current imageExtension
		in: FileLocator imageRelative basePath
		do: [:data | found add: data path].
	self assert: (found includes: SessionManager current imageFileName).
	self
		should: 
			[File
				for: '*.*'
				in: GUID newUnique idlString
				do: [:each | self fail: 'Really?']]
		raise: OS.Win32Error
		matching: [:ex | ex statusCode = OS.Win32Errors.ERROR_PATH_NOT_FOUND]!

testForDirectoriesIn
	| all windir |
	all := OrderedCollection new.
	windir := SessionManager current windowsDirectory.
	File forDirectoriesIn: windir do: [:each | all add: each fileName asLowercase].
	self assert: (all includes: 'system32').
	self assert: (all includes: 'system').
	self deny: (all includes: '.').
	self deny: (all includes: '..').
	all do: 
			[:each |
			| dirPath |
			dirPath := File composePath: windir subPath: each.
			self assert: (File isDirectory: dirPath)].
	self
		should: [File forDirectoriesIn: GUID newUnique idlString do: [:each | self fail: 'Really?']]
		raise: OS.Win32Error
		matching: [:ex | ex statusCode = OS.Win32Errors.ERROR_PATH_NOT_FOUND]!

testFullPathOf
	| longPath longFilename |
	self assert: (File fullPathOf: 'Dolphin') equals: File workingDirectory , 'Dolphin'.
	"With extended characters"
	self assert: (File fullPathOf: 'a🐬.£b') equals: File workingDirectory , 'a🐬.£b'.
	"An odd case where the first call to GetFullPath (to request the buffer size) returns space for two extra chars, presumably the '.\', but returns the correct size when actually invoked with a buffer."
	self assert: (File fullPathOf: '.\Dolphin') equals: File workingDirectory , 'Dolphin'.
	"Exactly MAX_PATH"
	longFilename := String new: MAX_PATH - File workingDirectory size withAll: $x.
	longPath := File fullPathOf: longFilename.
	self assert: longPath size equals: MAX_PATH.
	self assert: longPath equals: File workingDirectory , longFilename.
	"MAX_PATH + 1"
	longFilename := String new: MAX_PATH - File workingDirectory size + 1 withAll: $y.
	longPath := File fullPathOf: longFilename.
	self assert: longPath size equals: MAX_PATH + 1.
	self assert: longPath equals: File workingDirectory , longFilename.
	"Very long absolute path in long format"
	longPath := String writeStream.
	longPath nextPutAll: '\\?'.
	20 timesRepeat: [longPath nextPutAll: '\abcdefghijklmnopqrstuvwxyz'].
	longPath := longPath contents.
	self assert: longPath size > MAX_PATH.
	self assert: (File fullPathOf: longPath) equals: longPath!

testIsRelativePath
	#('c:\' '\\?\c:\' 'c:\.' 'c:\foo\..' '\\?\c:\foo\..' '\' 'c:/' 'c:\blah.txt' 'c:\foo\..\bar.txt')
		do: [:each | self deny: (File isRelativePath: each)].
	#('.' '..' '.\' '..\' 'blah' 'blah.txt' 'foo\bar' 'foo\bar.txt' '.\foo' '.\foo\bar' '.\foo.txt' '.\foo\bar.txt' '..\foo' '..\foo\bar.txt' 'c:' '-' '-:\')
		do: [:each | self assert: (File isRelativePath: each)].
	"Some boundary cases"
	self assert: (File isRelativePath: ':').
	self assert: (File isRelativePath: nil).
	self assert: (File isRelativePath: '').
	"PathIsRelative API also doesn't recognise long path prefix, but just treats as if a root path. This appears consistent with the OpenFile API."
	self deny: (File isRelativePath: '\\?\foo.txt')!

testIsRelativePathForwardSlash
	self deny: (File isRelativePath: '/').
	self deny: (File isRelativePath: 'c:/').
	self deny: (File isRelativePath: 'D:/').
	self assert: (File isRelativePath: 'a/').
	self assert: (File isRelativePath: './').!

testIsRelativePathOnDrive
	"There is a current directory for every drive, so paths that start with a drive can still be relative, See [Fully Qualified vs. Relative Paths](https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#fully-qualified-vs-relative-paths)"

	self assert: (File isRelativePath: 'c:foo.txt').
	self assert: (File isRelativePath: 'c:foo\bar')!

testIsRootPath
	#('\' 'c:\' '\\?\c:\' '\\server\share' '\\server' '\\' '\\?\UNC\' '\\?\UNC\server\share' '\\?\UNC\server')
		do: [:each | self assert: (File isRootPath: each)].
	#(nil '' 'c:' 'c:\foo' '\foo' 'c:\foo\..' '\\server\' '\\server\share\' '\\server\share\file' '\\?\UNC\server\share\' '\\?\c:' '\\?\c:\foo' '\\?\c:\foo\..' '/' 'c:\blah.txt' '.\blah.txt' 'con:\')
		do: [:each | self deny: (File isRootPath: each)].
	"Note that the Unix directory separator is not accepted (a Windows API is used)"
	self deny: (File isRootPath: 'c:/').
	"This is really a root path, but uncanonicalized"
	self deny: (File isRootPath: 'c:\.').
	"Ditto"
	self deny: (File isRootPath: 'c:\foo\..')!

testLastWriteTime
	| expected actual |
	actual := File lastWriteTime: SourceManager default changesFileName.
	expected := SourceManager default changesStream file lastWriteTime.
	self assert: actual equals: expected.
	"Can also request last modification time of a directory"
	actual := File lastWriteTime: File tempPath.
	self assert: actual notNil.
	"Nil result for a File that does not exist"
	self assertIsNil: (File lastWriteTime: 'c:\' , GUID newUnique idlString)!

testMakePath
	| filename split |
	self assert: (File makePath: #('c:' 'a/b 2/c/' 'a file' '.anextension'))
		equals: 'c:a/b 2/c/a file.anextension'.
	self assert: (File makePath: #('c' '\dir' 'file' 'txt')) equals: 'c:\dir\file.txt'.
	self assert: (File makePath: #(nil nil nil nil)) equals: ''.
	self assert: (File makePath: #('' '' '' '')) equals: ''.
	self assert: (File makePath: #('c' '' '' '')) equals: 'c:'.
	self assert: (File makePath: #('c' 'abc' '' '')) equals: 'c:abc\'.
	self assert: (File makePath: #('c' '' 'file' '')) equals: 'c:file'.
	self assert: (File makePath: #('c' '' '' 'txt')) equals: 'c:.txt'.
	self assert: (File makePath: #('c' '' 'a 🐬 c' 'txt')) equals: 'c:a 🐬 c.txt'.
	self assert: (File makePath: #('c' 'a/b' 'file' '')) equals: 'c:a/b\file'.
	self assert: (File makePath: #('c' '\' '' '')) equals: 'c:\'.
	self assert: (File makePath: #('' 'a\b' '' '')) equals: 'a\b\'.
	self assert: (File makePath: #('' '' 'file' '')) equals: 'file'.
	self assert: (File makePath: #('' '' '' 'txt')) equals: '.txt'.
	"Shouldn't matter if the filename is notionally too long"
	filename := String writeStream.
	self printFilenameOfLength: self maxFname * 2 on: filename.
	filename := filename contents.
	split := filename subStrings: $..
	self assert: (File makePath: {nil. nil. split first. split second}) equals: filename!

testPathName
	| expected actual |
	"We'll get a long path name"
	expected := '\\?\' , (File change: SessionManager current imageFileName extension: 'chg').
	actual := SourceManager default changesStream file pathName.
	self assert: (actual compareOrdinals: expected ignoringCase: true) equals: 0!

testRemoveDirectory
	self createTestDirectories.
	self removeDirectory: 'c:\FileTest1\EmptyLeaf'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf2'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	"Presense of sub-directories or files should prevent remove working"
	self should: [File removeDirectory: 'c:\FileTest1\LeafWithFile\'] raise: OS.Win32Error.
	self should: [File removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'] raise: OS.Win32Error!

testRemoveExtension
	| path |
	self assert: (File removeExtension: 'a.') equals: 'a'.
	self assert: (File removeExtension: '.exe') equals: ''.
	self assert: (File removeExtension: '.') equals: ''.
	self assert: (File removeExtension: '') equals: ''.
	self assert: (File removeExtension: '1234.123🐬.exe') equals: '1234.123🐬'.
	self assert: (File removeExtension: '1234.1234.+') equals: '1234.1234'.
	self assert: (File removeExtension: 'a.b\c') equals: 'a.b\c'.
	self assert: (File removeExtension: 'a.b\') equals: 'a.b\'.
	self assert: (File removeExtension: 'c:/a/b.txt') equals: 'c:/a/b'.
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname on: path.
	path := path contents.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first.
	"Doesn't matter if the path is notionally too long"
	path := self buildTestPathOfLength: MAX_PATH * 2.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first!

testRemovePathDelimiter
	self assert: (File removePathDelimiter: '') equals: ''.
	self assert: (File removePathDelimiter: '/') equals: ''.
	self assert: (File removePathDelimiter: '//') equals: '/'.
	self assert: (File removePathDelimiter: '\') equals: ''.
	self assert: (File removePathDelimiter: '\/') equals: '\'.
	self assert: (File removePathDelimiter: '.') equals: '.'.
	self assert: (File removePathDelimiter: './') equals: '.'.
	self assert: (File removePathDelimiter: 'c:') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\blah.txt') equals: 'c:\blah.txt'.
	"Test with non-ASCII chars and characters outside the BMP"
	#('c:\a🐬' 'c:\a🐬b' 'c:\a£' 'c:\a£b') do: 
			[:each |
			self assert: (File removePathDelimiter: each) equals: each.
			self assert: (File removePathDelimiter: each , '\') equals: each]!

testSetReadOnly
	| tempDir temp |
	tempDir := File createTemporaryDirectory.
	
	[{Character dolphin asString , (String new: 255 - 2 withAll: $£).
		String new: MAX_PATH - tempDir asUtf16String size - 2 withAll: $b.
		String new: MAX_PATH - tempDir asUtf16String size - 1 withAll: $c} do: 
				[:each |
				temp := File composePath: tempDir subPath: each.
				(FileStream write: temp)
					nextPutAll: 'Hello world';
					close.
				self assert: (File isWriteable: temp).
				File isWriteable: temp set: false.
				self deny: (File isWriteable: temp).
				File isWriteable: temp set: true]]
			ensure: [File deleteDirectory: tempDir]!

testShortPath
	"This test will only work if short filenames are enabled for the volume on which temp files are stored, and we cannot guarantee this is the case on build machines, nor is there an API that provides a definite answer as to whether short filenames are enabled on a particular volume."

	<skipIf: #isCiBuild>
	| sysdir tmpDir tmpFile |
	sysdir := SessionManager current systemDirectory.
	self assert: (File shortPathOf: sysdir) asAnsiString equals: sysdir.
	tmpDir := File tempPath , GUID newUnique asString , Character dolphin asUtf8String.
	tmpFile := File composePath: tmpDir subPath: '🖕.txt'.
	File createDirectory: tmpDir.
	
	[| short |
	(File open: tmpFile mode: #create) close.
	short := File shortPathOf: tmpFile.
	self deny: short equals: tmpFile.
	"This will fail if the short name still includes unicode"
	short := short asAnsiString.
	self assert: (File exists: short)]
			ensure: [File deleteDirectory: tmpDir]!

testSniffEncodingAnsi
	tempFile := File temporary.
	{
		AnsiString fromByteArray: Utf16String.Bom , 'odd' asByteArray.
		'£' asAnsiString.
		' informações'.
		'süß«'.
		'€' asAnsiString
	} do: 
				[:each |
				tempFile
					size: 0;
					write: each asAnsiString asByteArray.
				self assert: tempFile sniffEncoding equals: String.EncodingAnsi.
				self assert: tempFile position equals: 0]!

testSniffEncodingUtf16
	tempFile := File temporary.
	{
		Utf16String.Bom.
		Utf16String.Bom , 'even' asAnsiString asByteArray.
		Utf16String.Bom , Character dolphin asUtf8String asByteArray.
		('a ' asAnsiString , Character dolphin asUtf16String) asByteArray.
		'a £' asUtf16String asByteArray
	} do: 
				[:each |
				tempFile
					size: 0;
					write: each.
				self assert: tempFile sniffEncoding equals: String.EncodingUtf16.
				self assert: tempFile position
					equals: ((each beginsWith: Utf16String.Bom) ifTrue: [Utf16String.Bom size] ifFalse: [0])]!

testSniffEncodingUtf8
	"The sniffing will regard short sequences as most likely to be UTF-8 if they can be decoded as UTF-8, even if they in fact ANSI text. If the content is pure ASCII, then it makes no difference anyway as both UTF-8 and ANSI encodings (with any code page) are the same for this case."

	tempFile := File temporary.
	{
		Utf8String.Bom.
		Utf8String.Bom , '£' asAnsiString asByteArray.
		'a b c ' asByteArray.
		$£ asUtf8String asByteArray.
		'a 🐬' asUtf8String asByteArray
	} do: 
				[:each |
				tempFile
					size: 0;
					write: each.
				self assert: tempFile sniffEncoding equals: String.EncodingUtf8.
				self assert: tempFile position
					equals: ((each beginsWith: Utf8String.Bom) ifTrue: [Utf8String.Bom size] ifFalse: [0])]!

testSplitDriveFrom
	self should: [File splitDriveFrom: nil] raise: Error.
	self assert: (File splitDriveFrom: 'c:\a\a2/b.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'a\🐬.txt') equals: ''.
	self assert: (File splitDriveFrom: 'b.txt') equals: ''.
	self assert: (File splitDriveFrom: '.txt') equals: ''.
	self assert: (File splitDriveFrom: '.') equals: ''.
	self assert: (File splitDriveFrom: '') equals: ''.
	self assert: (File splitDriveFrom: 'c:/a b\c d.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'd:\') equals: 'd:'.
	self assert: (File splitDriveFrom: 'e:') equals: 'e:'.
	self assert: (File splitDriveFrom: 'cons:') equals: ''!

testSplitExtensionFrom
	| path ext unicode |
	unicode := $\x1F595 asUtf16String , '2'.
	self assert: (File splitExtensionFrom: 'c:\a\a2/b.' , unicode) equals: unicode.
	self assert: (File splitExtensionFrom: 'a\b.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: 'b.a🐬£') equals: 'a🐬£'.
	self assert: (File splitExtensionFrom: 'b.') equals: ''.
	self assert: (File splitExtensionFrom: '.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: '.') equals: ''.
	self assert: (File splitExtensionFrom: '') equals: ''.
	self assert: (File splitExtensionFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitExtensionFrom: 'c:/a b\c d.a🐬b') equals: 'a🐬b'.
	self assert: (File splitExtensionFrom: '1234.1234.exe') equals: 'exe'.
	self assert: (File splitExtensionFrom: 'a.b\c') equals: ''.
	self assert: (File splitExtensionFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: MAX_PATH.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"The CRT functions works even if the path is too long because we ignore everything but the extension"
	path := path , 'x'.
	self assert: (File splitExtensionFrom: path) equals: 'txtx'.
	path := self buildTestPathOfLength: MAX_PATH * 2.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"Try a very filename with very long extension (of max length)."
	path := String writeStream.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	ext := (path subStrings: $.) last.
	self assert: (File splitExtensionFrom: path) equals: ext.
	"Works even if extension is notionally too large"
	path := path , ext.
	self assert: (File splitExtensionFrom: path) equals: ext , ext!

testSplitFilenameFrom
	| path unicode |
	self should: [File splitFilenameFrom: nil] raise: Error.
	self assert: (File splitFilenameFrom: '.') equals: '.'.
	self assert: (File splitFilenameFrom: 'c:\a\a2/b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'a£b\🐬.txt') equals: '🐬.txt'.
	self assert: (File splitFilenameFrom: 'b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'b.') equals: 'b.'.
	self assert: (File splitFilenameFrom: '.txt') equals: '.txt'.
	self assert: (File splitFilenameFrom: '') equals: ''.
	self assert: (File splitFilenameFrom: 'c:\a\b\') equals: ''.
	unicode := 'c ' , $\x1F595 asUtf16String , ' d.txt'.
	self assert: (File splitFilenameFrom: 'c:/a b\' , unicode) equals: unicode.
	self assert: (File splitFilenameFrom: '1234.1234.exe') equals: '1234.1234.exe'.
	self assert: (File splitFilenameFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitFilenameFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: MAX_PATH.
	self assert: (File splitFilenameFrom: path) equals: (path subStrings: $\) last.
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	self assert: (File splitFilenameFrom: path) equals: (path copyFrom: 4)!

testSplitPathFrom
	| path |
	self should: [File splitPathFrom: nil] raise: Error.
	self assert: (File splitPathFrom: '.') equals: ''.
	self assert: (File splitPathFrom: 'c:\a\a2/b.txt') equals: 'c:\a\a2/'.
	self assert: (File splitPathFrom: 'c:\a\b.txt') equals: 'c:\a\'.
	self assert: (File splitPathFrom: 'c:\a\b\') equals: 'c:\a\b\'.
	self assert: (File splitPathFrom: 'c:\b.txt') equals: 'c:\'.
	self assert: (File splitPathFrom: 'c:\') equals: 'c:\'.
	self assert: (File splitPathFrom: 'c:') equals: 'c:'.
	self assert: (File splitPathFrom: 'a\b.txt') equals: 'a\'.
	self assert: (File splitPathFrom: 'b.txt') equals: ''.
	self assert: (File splitPathFrom: 'b.') equals: ''.
	self assert: (File splitPathFrom: '.txt') equals: ''.
	self assert: (File splitPathFrom: '') equals: ''.
	self assert: (File splitPathFrom: 'c:\a\b\') equals: 'c:\a\b\'.
	self assert: (File splitPathFrom: 'c:/a b\c 🖕d.txt') equals: 'c:/a b\'.
	self assert: (File splitPathFrom: '1234.1234.exe') equals: ''.
	self assert: (File splitPathFrom: 'a.b\c') equals: 'a.b\'.
	self assert: (File splitPathFrom: 'a.b\') equals: 'a.b\'.
	path := self buildTestPathOfLength: MAX_PATH.
	self assert: (File splitPathFrom: path) equals: ($\ join: (path subStrings: $\) allButLast) , '\'.
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path nextPutAll: '/a.txt'.
	path := path contents.
	self assert: (File splitPathFrom: path) equals: (path upTo: $/) , '/'!

testSplitStemFrom
	| path |
	self assert: (File splitStemFrom: '.') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\a🐬/b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'a\b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'a🐬.txt') equals: 'a🐬'.
	self assert: (File splitStemFrom: 'b.') equals: 'b'.
	self assert: (File splitStemFrom: '.txt') equals: ''.
	self assert: (File splitStemFrom: '') equals: ''.
	self assert: (File splitStemFrom: '\') equals: ''.
	self assert: (File splitStemFrom: 'c:\') equals: ''.
	self assert: (File splitStemFrom: 'c:\.txt') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitStemFrom: 'c:/a b\c 🐬.txt') equals: 'c 🐬'.
	self assert: (File splitStemFrom: '1234.1234.exe') equals: '1234.1234'.
	self assert: (File splitStemFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitStemFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: MAX_PATH.
	self assert: (File splitStemFrom: path) equals: ((path subStrings: $\) last upTo: $.).
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	self assert: (File splitStemFrom: path) equals: ((path copyFrom: 4) upTo: $.)! !

!Core.Tests.FileTest categoriesForMethods!
buildTestPathOfLength:!helpers!private! !
createTestDirectories!helpers!private! !
deleteDirectory:!helpers!public! !
deleteTestDirectories!private!Running! !
maxFname!constants!private! !
printFilenameOfLength:on:!helpers!private! !
relativePathOf:to:!helpers!public! !
removeDirectory:!helpers!private! !
tearDown!private!Running! !
test64BitSeek!public!unit tests! !
testCanonicalizePath!public!unit tests! !
testClassAppendPathSeparator!public!unit tests! !
testClassDefaultExtension!public!unit tests! !
testClassPathExtension!public!unit tests! !
testClassRelativePathOfTo!public!unit tests! !
testCommonPrefixOfAnd!public!unit tests! !
testComposePath!public!unit tests! !
testCreateDirectoryPath!public!unit tests! !
testCreateTemporaryDirectory!public!unit tests! !
testDeleteDirectory!public!unit tests! !
testFileNotFound!public!unit tests! !
testFileTimes!public!unit tests! !
testFindFiles!public!unit tests! !
testForDirectoriesIn!public!unit tests! !
testFullPathOf!public!unit tests! !
testIsRelativePath!public!unit tests! !
testIsRelativePathForwardSlash!public!unit tests! !
testIsRelativePathOnDrive!public!unit tests! !
testIsRootPath!public!unit tests! !
testLastWriteTime!public!unit tests! !
testMakePath!public!unit tests! !
testPathName!public!unit tests! !
testRemoveDirectory!public!unit tests! !
testRemoveExtension!public!unit tests! !
testRemovePathDelimiter!public!unit tests! !
testSetReadOnly!public!unit tests! !
testShortPath!public!unit tests! !
testSniffEncodingAnsi!public!unit tests! !
testSniffEncodingUtf16!public!unit tests! !
testSniffEncodingUtf8!public!unit tests! !
testSplitDriveFrom!public!unit tests! !
testSplitExtensionFrom!public!unit tests! !
testSplitFilenameFrom!public!unit tests! !
testSplitPathFrom!public!unit tests! !
testSplitStemFrom!public!unit tests! !
!

