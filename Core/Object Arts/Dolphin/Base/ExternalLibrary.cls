"Filed out from Dolphin Smalltalk 7"!

Object subclass: #ExternalLibrary
	instanceVariableNames: 'handle'
	classVariableNames: ''
	poolDictionaries: 'Win32Constants Win32Errors'
	classInstanceVariableNames: 'default'!
ExternalLibrary guid: (GUID fromString: '{87b4c488-026e-11d3-9fd7-00a0cc3e4a32}')!
ExternalLibrary comment: 'ExternalLibrary is the class of objects which represent shared, external, function libraries (i.e. DLLs). Each DLL is represented by a separate subclass, with the methods of that subclass corresponding to functions exported from the DLL. The functions are a special form of primitive method (actually instances of <ExternalMethod>) containing the additional type information needed to interface to statically typed functions. The functions are invoked by sending Smalltalk messages int the normal way, with these being translated by the VM external call primitive to the actual function invocations. The VM coerces the Smalltalk objects passed as arguments to appropriate native types following certain rules (see below). The external call primitive will fail if a type mismatch occurs, and normally this will result in an InvalidExternalCall exception being raised (assuming the #invalidCall method has not been overridden).

External library classes are typically singletons, with the instances representing an "open" (usable) instance of the DLL. The singleton instances are accessible through the class #default method. The libraries are loaded lazily, on demand (but see <PermanentLibrary>).

The external call primitive supports the two most commonly used calling conventions:

	__declspec(cdecl)	- #stdcall
	__declspec(stdcall)	- #cdecl

The "fastcall" calling convention is not currently supported, but this is rarely (if ever) used for exported functions. The C++ "thiscall" calling convention (which passes the ''this'' pointer in the ECX register) is not supported either, but invoking virtual methods of C++ objects (and therefore COM interface methods) is possible - see IUnknown and its subclasses in the "OLE COM" package.

Apart from scalar types, the primitive also supports the passing and returning of structures by value, up to a maximum of 64Kb per structure (though passing such large structures by value is not recommended).

The argument/return types (and coercions) supported are:

	void 	Only valid as a return type - the method answers self
	lpvoid 	General pointer type, accepts byte objects e.g. Strings (pointer to contents 
		passed), nil (null pointer), integers (passes as address), or ExternalAddresses
		(the contained address is passed, not a pointer to the ExternalAddress object). 
		When used as a return type, the method answers an instance of ExternalAddress.
	lppvoid	Pointer to pointer. Used for functions which take a parameter into which they write
		an address. The corresponding argument must be an ExternalAddress (or other indirection
		object), or an object whose first instance variable is such (e.g. an ExternalStructure).
		The address of the ExternalAddress itself is passed, so that on return it contains the
		address written back by the external function. nil is not a valid argument value.
		As a return type answers a pointer instance of LPVOID (i.e. LPVOID* = void**).
	char	Signed character. Accepts Characters only.
	byte	Unsigned byte. Accepts SmallIntegers only. Passes a 32-bit value
		generated by zero extending the least significant byte. Fails if  not in the
		range 0..255. Zero extends into a positive SmallInteger when a return value.
	sbyte	Signed byte. Accepts SmallIntegers only. Passes a 32-bit value generated
		by sign extending the least significant byte. Fails if not in range -128..127.
		Sign extends into a positive or negative SmallInteger when a return value.
	word 	Unsigned word. As #byte, but 16-bit, acceptable range 0..65535.
		Also accepts a byte object of size 2, which is zero extended to 32-bits.
	sword 	Signed word. As #sbyte, but 16-bit, acceptable range -32768..32767.
		Also accepts a byte object of size 2, which is sign extended to 32-bits.
	dword	Unsigned double word (32-bits), accepts 32-bit Integers. Positive integers
		are passed as unsigned, and negative integers in their two''s complement
		representation.  The largest LargeNegativeInteger which can be passsed
		is -16r80000000 (or -2147483648) because this is the largest negative number 
		which can be represented in 32-bits in two''s complement notation.
		Also accepts byte objects of length 4, assumed to be in an unsigned bit representation.
		nil is passed as 0. As a return type, answers a SmallInteger, or a LargePositiveInteger if the
		result cannot be represented as a positive SmallInteger (i.e. in 30 bits).
	sdword	Signed double word, accepts any Integer in the range -16r80000000..16r7FFFFFFF
		(i.e. Integer''s with a 32-bit two''s complement representation - all SmallIntegers, 
		some 4-byte LargePositiveIntegers and LargeNegativeIntegers). May also be other
		byte objects of length 4, which are assumed to contain a 2''s complement 32-bit number.
		As a return type answers a SmallInteger, or if more than 31-bits are required 
		to represent the two''s complement result, a LargePositiveInteger or LargeNegativeInteger 
		depending on sign. Also accepts nil (passed as 0).
	qword	Unsigned quad word. Similar to dword, but 64-bit (i.e. the range is -16r8000000000000000,
		the largest 64-bit two''s complement negative integer, up to 16rFFFFFFFFFFFFFFF the largest positive 
		unsigned 64-bit integer). 8-byte objects are acceptable and assumed to contain the correct unsigned
		bit representation. nil is passed as 0.
	sqword	Signed quad word. Accepts any Integer in the range which can be represented as a
		two''s complement number in 64 bits (i.e. -16r8000000000000000 to 16r7FFFFFFFFFFFFFFF).
		Also accepts 8 byte objects, which are assumed to contain 64-bit two''s complement numbers. 
		nil is passed as 0. As a return type answers the smallest Integer form which can contain 
		the 64-bit two''s complement integer.
	bool	Boolean. As an argument type, accepts true (translated to 1) or false
		(translated to 0). Also accepts SmallInteger values, pushing their host
		machine representation. As a return type, if the result is 0 answers false,
		if the result is non-zero, answers true.
	handle	32-bit handle. Accepts 32-bit integers, nil, or a byte object of size 4. 
		As a return type, answers an ExternalHandle, unless the
		returned handle is NULL, in which case answers ''nil''.
	double	64-bit floating point. Accepts instances of class Float (which contains
		a host machine representation of a double precision floating point number). 
		SmallIntegers may also be passed (they are promoted to the double precision
		floating point representation of their integral value). As a return type,
		answers an instance of class Float.
	lpstr	Pointer to C (null-terminated) ASCII string type. Accepts null terminated byte 
		objects (e.g. Strings, Symbols) or nil (null pointer). When used as a return type, 
		answers a String containing the characters of the C string up to the null terminator. 
		Unlike lpvoid, does not accept integer values as pointers, or ExternalAddress 
		(indirection) objects. If the validation is too tight for your requirements, then 
		use lpvoid. Do not use this return type where an external function is called which 
		expects the caller to assume ownership of the returned string, and to delete it when 
		it is no longer required, as a memory leak will result (use lpvoid instead).
	oop	Object identifier. Any non-SmallInteger can be passed. The value should
		be treated as an opaque Handle, and should not be stored for later use (it
		may change during a GC). As a return type, answers the object whose Oop is 
		the result. At present it is recommended that you do not use this type.
	float	32-bit floating point. Accepts instances of class Float, or SmallIntegers
		(as #double). The conversion of Floats (64-bit double precision) to #float 
		(32-bit single precision) may result in silent loss of precision. As a return
		type answers an instance of class Float (i.e. promotes to double precision).
	hresult	32-bit signed integer value. Validation as #sdword. As a return type, if less than
		0 (i.e. severity is error), causes the external call primitives to fail with a negative 
		failure reason which is the HRESULT value. This is convenient because it means an
		exception is automatically generated when an external function returns an HRESULT error.
	<N>	Where N is the byte size of a pass-by-value structure of unspecified type. Accepts either
		byte objects (of the correct size) or ExternalStructure instances with the correct byteSize
		(or other classes with the same shape as ExternalStructures). ExternalStructures passed
		to such arguments can be reference instances (i.e. ones containing a pointer to the actual
		structure bytes, rather than the structure bytes themselves). As a return type, the result
		is a ByteArray of the specified size.
	<struct>	Where <struct> is an ExternalStructure class name. Structure passed by value. Accepts 
		only the exact matching structure class. Again, the ExternalStructure arguments may be
		reference/pointer instances. When used as a return value, an instance of the 
		ExternalStructure class is answered, with the bytes of the returned structure as its contents
		(copied into a ByteArray).
	<struct>*	Where <struct> is an ExternalStructure class name. When used as a return type, a pointer
		instance of the ExternalStructure is answered, with an ExternalAddress pointing at the
		externally stored value as its first instance variable.
	
Note that in general, the UndefinedObject, nil, is interchangeable with 0, or NULL, when interfacing with external library functions. Nullness can be tested with the #isNull message, with the UndefinedObject and SmallInteger zero answering true.'!
!ExternalLibrary categoriesForClass!External-Libraries! !
!ExternalLibrary methodsFor!

asParameter
	"Answer the receiver in a form appropriate for passing to an external
	library procedure."

	handle isNull ifTrue: [self open].
	^handle!

basicOpen: aString
	"Private - Open the external library with the external file name, aString,
	as the library referenced by the receiver. Answer the receiver.
	The library is NOT initialized."

	handle := nil.
	self handle: (self class load: aString flags: self loadFlags)!

close
	"Release the reference the receiver has to the External Library it represents. This may
	not cause the library to be unloaded, so it may still function. Answer whether the
	library was successfully closed."

	| success |
	success := handle notNull and: [KernelLibrary default freeLibrary: handle].
	handle := nil.
	^success!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^handle isNull
		ifTrue: [self class fileName]
		ifFalse: [self moduleFileName]!

formatMessage: anIntegerId with: arguments
	"Answer a message formatted from the Win32 format string with the specified
	id in the receiver, with substitutions from the collection, arguments."


	^String formatMessage: anIntegerId in: self asParameter withArguments: arguments!

getProcAddress: aStringOrWord
	"Private - Answer the address of the receiver's procedure identified by the <AnsiString> name or <integer> ordinal parameter."

	^self getProcAddress: aStringOrWord ifAbsent: [self systemError]!

getProcAddress: nameOrOrdinal ifAbsent: exceptionHandler
	"Private - Answer the address of the receiver's procedure named by the <AnsiString>
	or <integer> ordinal, nameOrOrdinal. If the receiver does not contain a matching
	procedure, then answer the result of evaluation the <niladicValuable> exceptionHandler.."

	| address |
	address := KernelLibrary default getProcAddress: self asParameter lpProcName: nameOrOrdinal.
	^address = 0
		ifTrue: [exceptionHandler value]
		ifFalse: [address]!

handle
	^handle!

handle: aHandle
	"Private - Set the handle of the external library which the receiver represents.
	Answer the receiver."

	handle := aHandle isNil ifFalse: [aHandle asExternalHandle]!

invalidArgErrorClass
	"Private - Answer the class of Error to be signalled when an invalid argument is passed to one of 
	the receiver external functions."

	^InvalidExternalCall!

invalidCall
	"An invalid external call was attempted through one of the receiver's methods.
	Generate an appropriate error from the following categories:
		-	Argument type error. At least one argument was either out of range or of invalid type.
			Only the first such error is reported. The primitive failure result will be >= 16
			if an argument is invalid, the invalid argument number (from 1) being (failure result - 16)+1.
`		-	Invalid receiver (failure result = 0)
		-	Procedure not found (failure result = 1)
		-	System error.
		-	Unknown primitive failure. An uncategorised primitive failure occurred. Seek assistance."

	| error failureCode proc frame descriptor |
	proc := Processor activeProcess.
	failureCode := proc primitiveFailureCode.
	failureCode < 0 ifTrue: [^HRESULTError signalWith: proc primitiveFailureData].
	frame := proc topFrame sender.
	descriptor := frame method descriptor.
	failureCode >= 16
		ifTrue: 
			["An invalid argument was passed"
			| arg i |
			i := descriptor argumentIndexFromOffset: failureCode - 16.
			arg := frame method isVirtualFunction ifTrue: [i - 1] ifFalse: [i].
			self invalidArgErrorClass
				invalidArgument: arg
				got: (frame arguments at: arg)
				expected: (descriptor argumentTypes at: i)]
		ifFalse: 
			[failureCode == 0 ifTrue: [^self error: 'invalid receiver'].
			failureCode == 1
				ifTrue: 
					["Function name not found in the DLL, i.e. failure of GetProcAddress().
					Often caused by omitting the A (for ASCII) or W (for Wide = Unicode) 
					function name suffix. Note that this may be required even if the function
					has no string arguments."
					^Win32Error signalWith: ERROR_PROC_NOT_FOUND].
			failureCode == 2
				ifTrue: 
					["VM has detected an attempt to return an ExternalStructure of an uninitialized class (i.e. basicByteSize is zero)"
					^self error: ('Returned ExternalStructure type not initialized: <1s>' expandMacrosWith: descriptor returnType)]].

	"All arguments were apparently valid (assuming the Smalltalk validation matches the VM's),
	it must have been some system or unknown error."
	error := KernelLibrary default getLastError.
	^error == 0 ifTrue: [self primitiveFailed] ifFalse: [self systemError: error]!

isOpen
	"Answer whether the external library represented by the receiver is open."

	^handle notNull!

loadFlags
	^0!

loadString: anIntegerId
	"Answer the string with the specified id from the receiver's resources."

	^String fromId: anIntegerId in: self!

moduleFileName
	"Private - Answer the file name of the receiver's loaded module."

	^self class moduleFileName: self!

open
	"Private - Open the external library referenced by the receiver. 
	Answer the receiver. The library is NOT initialized."

	self open: self fileName!

open: aString
	"Private - Open the external library with the external file name, aString,
	as the library referenced by the receiver. Answer the receiver.
	The library is initialized."

	(self basicOpen: aString) initialize!

printOn: aStream
	"Append a short textual description of the receiver to aStream."

	aStream 
		basicPrint: self; 
		nextPut: $(;
		nextPutAll: (handle isNil ifTrue: ['NULL'] ifFalse: [handle asInteger printStringRadix: 16]);
		nextPutAll: ' - ';
		print: self fileName;
		nextPut: $)!

stbSaveOn: anSTBOutFiler 
	"Save out a binary representation of the receiver to anSTBOutFiler."

	anSTBOutFiler writePreambleFor: self!

systemError
	"Generate an error based on the last recorded host system error"

	^Win32Error signal!

systemError: anInteger
	"Generate an error for the host system error, anInteger"

	^HRESULTError signalWith: anInteger!

versionFormatString
	"Private - Answer a String containing the version format used by the receiver.
	The arguments than can be inserted into the string are:
		1) Product name
		2) Product major high word
		3) Product major low word
		4) Product minor high word
		5) Product minor low word
	"

	^'%2!!d!!.%3!!d!! build %4!!d!!'!

versionInfo
	"Answer a <VersionInfo> containing the version details from the receiver."

	^VersionInfo forPath: self moduleFileName!

versionString
	"Answer a version number String in the format used by the receiver,
	(typically N.N Build N, but see #versionFormatString)."

	^self versionInfo formatVersionString: self versionFormatString! !
!ExternalLibrary categoriesFor: #asParameter!converting!public! !
!ExternalLibrary categoriesFor: #basicOpen:!private!realizing/unrealizing! !
!ExternalLibrary categoriesFor: #close!public!realizing/unrealizing! !
!ExternalLibrary categoriesFor: #fileName!accessing!public! !
!ExternalLibrary categoriesFor: #formatMessage:with:!accessing!public! !
!ExternalLibrary categoriesFor: #getProcAddress:!accessing!private! !
!ExternalLibrary categoriesFor: #getProcAddress:ifAbsent:!accessing!private! !
!ExternalLibrary categoriesFor: #handle!accessing!private! !
!ExternalLibrary categoriesFor: #handle:!accessing!private! !
!ExternalLibrary categoriesFor: #invalidArgErrorClass!constants!private! !
!ExternalLibrary categoriesFor: #invalidCall!exceptions!public! !
!ExternalLibrary categoriesFor: #isOpen!public!testing! !
!ExternalLibrary categoriesFor: #loadFlags!constants!private! !
!ExternalLibrary categoriesFor: #loadString:!accessing!public! !
!ExternalLibrary categoriesFor: #moduleFileName!accessing!private! !
!ExternalLibrary categoriesFor: #open!private!realizing/unrealizing! !
!ExternalLibrary categoriesFor: #open:!private!realizing/unrealizing! !
!ExternalLibrary categoriesFor: #printOn:!printing!public! !
!ExternalLibrary categoriesFor: #stbSaveOn:!binary filing!public! !
!ExternalLibrary categoriesFor: #systemError!exceptions!public! !
!ExternalLibrary categoriesFor: #systemError:!exceptions!public! !
!ExternalLibrary categoriesFor: #versionFormatString!constants!private! !
!ExternalLibrary categoriesFor: #versionInfo!accessing-version!public! !
!ExternalLibrary categoriesFor: #versionString!accessing-version!public! !

!ExternalLibrary class methodsFor!

clear
	"Private - Clear down cached external function addresses from previous runs. 
	The default instances will be lazily re-opened because their handles will be null
	on image re-start (ExternalHandles are automatically nulled by the VM on image load).
	Similary function addresses will be lazily requeried as required."

	default notNil ifTrue: [default handle: nil].
	self methodDictionary do: [:m | m clear]!

closeAllDefaults
	"Private - Close all open default libraries."

	self allSubclassesBreadthFirstDo: [:each | each closeDefault]!

closeDefault
	"Private - Close the default instance of the receiver (if there is one).
	Having closed it, clear down the default inst var so that any subsequent accesses
	will cause the library to be reopened."

	(default notNil and: [default handle notNull]) 
		ifTrue: 
			[default close.
			default := nil]!

default
	"Answer the default, opened, instance of the receiver."

	default isNil 
		ifTrue: [self openDefault]
		ifFalse: [default asParameter].
	^default!

default: anExternalLibrary
	"Set the default instance of the receiver."

	default := anExternalLibrary!

fileName
	"Answer the host system file name for the external library the 
	receiver represents."

	^self error: 'Cannot open anonymous library'!

fromHandle: aHandle
	"Answers an instance of ExternalLibrary attached to aHandle."

	^self new handle: aHandle!

initializeAfterBinaryLoad
	"Private - Perform any post-binary load initialisation for the class. "

	self clear!

load: aString flags: anInteger 
	"Private - Open the external library with the external file name, aString,
	and answer the handle."

	| hLibrary klib |
	klib := KernelLibrary default.
	hLibrary := klib 
				loadLibraryEx: aString
				hFile: nil
				dwFlags: anInteger.
	^hLibrary ifNil: [Win32Error signal: aString printString]!

moduleFileName: aLibOrHandle
	"Private - Answer the file name of the receiver's loaded module."

	| buf size |
	buf := File pathBuffer.
	size := KernelLibrary default
				getModuleFileName: aLibOrHandle asParameter
				lpFilename: buf
				nSize: buf size + 1.
	^buf resize: size!

onExit
	"Private - Perform shut down processing."

	self closeAllDefaults!

onPreStripImage
	"Private - The image is about to be stripped, close down defaults to allow unused
	subclasses to be stripped."

	self closeAllDefaults!

onStartup
	"Private - Perform session startup processing for the receiver and its subclasses."

	self allSubclassesBreadthFirstDo: [:each | each clear].
	"If we don't have a handle for the Kernel32.DLL then we can't open any other libraries"
	KernelLibrary openDefault.
	PermanentLibrary onStartup2.
	self onStartup2!

onStartup2
	"Private - Perform session startup processing for the receiver and its subclasses.
	We open the permanent libraries first to make the startup more robust in case of
	errors opening other libraries."

	self subclasses do: [:c | c == PermanentLibrary ifFalse: [c onStartup2]]!

open
	"Answer a new instance of the receiver to represent the receiver's ExternalLibrary. The 
	instance can be used to invoke the functions of the external library specified as instance
	methods"

	^self open: self fileName!

open: aString
	"Answer an instance of the receiver which references the external
	library with the external file name, aString. The library is
	initialized (most libraries don't need any initializing, but you
	get the option)."

	^self new open: aString!

openDefault
	"Private - Open and record the default instance of the receiver.
	Answer the new instance."

	^default := self open!

stbReadFrom: anSTBInFiler format: anSTBClassConversion 
	"Read an instance of the receiver from the binary filer, aSTBInFiler."

	| singleton |
	singleton := self default.
	anSTBInFiler register: singleton.
	^singleton!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self closeDefault!

uninitializeBeforeRemove
	"Perform any pre-removal uninitialisation for the class. This includes any specific #uninitialize
	implementation (but note that #uninitialize is only sent to classes which directly implement
	#uninitialize, otherwise we'd probably end up damaging superclasses which are not being
	removed).
	Implementation Note: This is one of those cases where we want subclasses to inherit the
	uninitialize, so override to always call it."

	self uninitialize!

versionInfo
	"Answer a <VersionInfo> containing the version details from the receiver."

	^VersionInfo forPath: self fileName! !
!ExternalLibrary class categoriesFor: #clear!initializing!private! !
!ExternalLibrary class categoriesFor: #closeAllDefaults!finalizing!private! !
!ExternalLibrary class categoriesFor: #closeDefault!private!realizing/unrealizing! !
!ExternalLibrary class categoriesFor: #default!accessing!instance creation!public! !
!ExternalLibrary class categoriesFor: #default:!accessing!public! !
!ExternalLibrary class categoriesFor: #fileName!constants!public! !
!ExternalLibrary class categoriesFor: #fromHandle:!instance creation!public! !
!ExternalLibrary class categoriesFor: #initializeAfterBinaryLoad!initializing!private! !
!ExternalLibrary class categoriesFor: #load:flags:!private!realizing/unrealizing! !
!ExternalLibrary class categoriesFor: #moduleFileName:!helpers!private! !
!ExternalLibrary class categoriesFor: #onExit!finalizing!private! !
!ExternalLibrary class categoriesFor: #onPreStripImage!class hierarchy-removing!private! !
!ExternalLibrary class categoriesFor: #onStartup!event handling!private! !
!ExternalLibrary class categoriesFor: #onStartup2!event handling!private! !
!ExternalLibrary class categoriesFor: #open!instance creation!public! !
!ExternalLibrary class categoriesFor: #open:!instance creation!public! !
!ExternalLibrary class categoriesFor: #openDefault!instance creation!private!realizing/unrealizing! !
!ExternalLibrary class categoriesFor: #stbReadFrom:format:!binary filing!public! !
!ExternalLibrary class categoriesFor: #uninitialize!class hierarchy-removing!private! !
!ExternalLibrary class categoriesFor: #uninitializeBeforeRemove!class hierarchy-removing!private! !
!ExternalLibrary class categoriesFor: #versionInfo!accessing-version!public! !

