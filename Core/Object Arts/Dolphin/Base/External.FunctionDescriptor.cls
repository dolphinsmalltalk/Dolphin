"Filed out from Dolphin Smalltalk 7"!

Core.Object variableSubclass: #'External.FunctionDescriptor'
	instanceVariableNames: 'descriptor'
	classVariableNames: 'CallingConventions ReferenceTypes TypeNames TypeSizes ValueTypes'
	imports: #(#{External.ExtCallArgTypes})
	classInstanceVariableNames: ''
	classConstants: {
		'RetClassIndex' -> 16r4.
		'RetTypeMask' -> 16r3F
	}!
External.FunctionDescriptor guid: (Core.GUID fromString: '{87b4c487-026e-11d3-9fd7-00a0cc3e4a32}')!
External.FunctionDescriptor comment: '`FunctionDescriptor` instances describe the return type, parameter types, and calling convention of native function calls for external interfacing purposes. They can be used to describe both outbound and inbound calls, represented by `ExternalMethod` and `ExternalCallback` instances respectively.

The argument/return types supported by the primitive DLL call function are:

	void 	Only valid as a return type - the method answers self
	lpvoid 	General pointer type, accepts byte objects e.g. Strings (pointer to contents 
		passed), nil (null pointer), integers (passes as address), or ExternalAddresses
		(the contained address is passed, not a pointer to the ExternalAddress object). 
		When used as a return type, the method answers an instance of ExternalAddress.
	lppvoid	Pointer to pointer. Used for functions which take a parameter into which they write
		an address. The corresponding argument must be an ExternalAddress (or other indirection
		object), or an object whose first instance variable is such (e.g. an ExternalStructure).
		The address of the ExternalAddress itself is passed, so that on return it contains the
		address written back by the external function. nil is not a valid argument value.
		As a return type answers a pointer instance of LPVOID (i.e. LPVOID* = void**).
	char	Signed character. Accepts Characters only.
	byte	Unsigned byte. Accepts SmallIntegers only. Passes a 32-bit value
		generated by zero extending the least significant byte. Fails if  not in the
		range 0..255. Zero extends into a positive SmallInteger when a return value.
	sbyte	Signed byte. Accepts SmallIntegers only. Passes a 32-bit value generated
		by sign extending the least significant byte. Fails if not in range -128..127.
		Sign extends into a positive or negative SmallInteger when a return value.
	word 	Unsigned word. As #byte, but 16-bit, acceptable range 0..65535.
		Also accepts a byte object of size 2, which is zero extended to 32-bits.
	sword 	Signed word. As #sbyte, but 16-bit, acceptable range -32768..32767.
		Also accepts a byte object of size 2, which is sign extended to 32-bits.
	dword	Unsigned double word (32-bits), accepts 32-bit Integers. Positive integers
		are passed as unsigned, and negative integers in their two''s complement
		representation.  The largest negative LargeInteger which can be passsed
		is -16r80000000 (or -2147483648) because this is the largest negative number 
		which can be represented in 32-bits in two''s complement notation.
		Also accepts byte objects of length 4, assumed to be in an unsigned bit representation.
		nil is passed as 0. As a return type, answers a SmallInteger, or a LargeInteger if the
		result cannot be represented as a positive SmallInteger (i.e. in 30 bits).
	sdword	Signed double word, accepts any Integer in the range -16r80000000..16r7FFFFFFF
		(i.e. Integer''s with a 32-bit two''s complement representation - all SmallIntegers and
		4-byte LargeIntegers). May also be other byte objects of length 4, which are 
		assumed to contain a 2''s complement 32-bit number.
		As a return type answers a SmallInteger, or, if more than 31-bits are required 
		to represent the two''s complement result, a LargeInteger. Also accepts nil (passed as 0).
	qword	Unsigned quad word. Similar to dword, but 64-bit (i.e. the range is -16r8000000000000000,
		the largest 64-bit two''s complement negative integer, up to 16rFFFFFFFFFFFFFFF the largest positive 
		unsigned 64-bit integer). 8-byte objects are acceptable and assumed to contain the correct unsigned
		bit representation. nil is passed as 0.
	sqword	Signed quad word. Accepts any Integer in the range which can be represented as a
		two''s complement number in 64 bits (i.e. -16r8000000000000000 to 16r7FFFFFFFFFFFFFFF).
		Also accepts 8 byte objects, which are assumed to contain 64-bit two''s complement numbers. 
		nil is passed as 0. As a return type answers the smallest Integer form which can contain 
		the 64-bit two''s complement integer.
	bool	Boolean. As an argument type, accepts true (translated to 1) or false
		(translated to 0). Also accepts SmallInteger values, pushing their host
		machine representation. As a return type, if the result is 0 answers false,
		if the result is non-zero, answers true.
	handle	32-bit handle. Accepts 32-bit integers, nil, or a byte object of size 4. 
		As a return type, answers an ExternalHandle, unless the
		returned handle is NULL, in which case answers ''nil''.
	double	64-bit floating point. Accepts instances of class Float (which contains
		a host machine representation of a double precision floating point number). 
		SmallIntegers may also be passed (they are promoted to the double precision
		floating point representation of their integral value). As a return type,
		answers an instance of class Float.
	lpstr	Pointer to C (null-terminated) ASCII string type. Accepts null terminated byte 
		objects (e.g. Strings, Symbols) or nil (null pointer). When used as a return type, 
		answers a String containing the characters of the C string up to the null terminator. 
		Unlike lpvoid, does not accept integer values as pointers, or ExternalAddress 
		(indirection) objects. If the validation is too tight for your requirements, then 
		use lpvoid. Do not use this return type where an external function is called which 
		expects the caller to assume ownership of the returned string, and to delete it when 
		it is no longer required, as a memory leak will result (use lpvoid instead).
	oop	Object identifier. Any non-SmallInteger can be passed. This parameter type
		is intended for use with the forthcoming User Primitive Kit. The value should
		be treated as an opaque Handle, and should not be stored for later use (it
		may change during a GC). As a return type, answers the object whose Oop is 
		the result. At present it is recommended that you do not use this type.
	float	32-bit floating point. Accepts instances of class Float, or SmallIntegers
		(as #double). The conversion of Floats (64-bit double precision) to #float 
		(32-bit single precision) may result in silent loss of precision. As a return
		type answers an instance of class Float (i.e. promotes to double precision).
	hresult	32-bit signed integer value. Validation as #sdword. As a return type, if less than
		0 (i.e. severity is error), causes the external call primitives to fail with a negative 
		failure reason which is the HRESULT value. This is convenient because it means an
		exception is automatically generated when an external function returns an HRESULT error.
	<struct>	Where <struct> is an ExternalStructure class name. Structure passed by value. Accepts 
		only the exact matching structure class. Again, the ExternalStructure arguments may be
		reference/pointer instances. When used as a return value, an instance of the 
		ExternalStructure class is answered, with the bytes of the returned structure as its contents
		(copied into a ByteArray).
	<struct>*	Where <struct> is an ExternalStructure class name. When used as a return type, a pointer
		instance of the ExternalStructure is answered, with an ExternalAddress pointing at the
		externally stored value as its first instance variable.
	<struct>**Equivalent to lppvoid.
	
Note that in general, the UndefinedObject, nil, is interchangeable with 0, or NULL, when interfacing with external library functions. Nullness can be tested with the #isNull message, with the UndefinedObject and SmallInteger zero answering true.'!
!External.FunctionDescriptor categoriesForClass!System-Support! !
!External.FunctionDescriptor methodsFor!

argumentCount
	"Private - Answer the argument count of the external function described by the receiver.
	N.B. This may be one less than the actual number of arguments if the receiver is describing
	a virtual function with implicit 'this' pointer."

	^descriptor at: 2!

argumentIndexFromOffset: anInteger 
	"Private - Convert a zero-based offset into the descriptor array (as used by the VM when marshalling
	the objects onto the stack for an external call) into the index of the corresponding argument. We have
	to take account of the literal indices that are embedded in the descriptor."

	| i offset stop |
	offset := RetClassIndex + 1.
	stop := offset + anInteger.
	i := 0.
	[offset > stop] whileFalse: 
			[| type |
			i := i + 1.
			type := descriptor at: offset.
			offset := offset + 1.
			(self class typeHasArgument: type) ifTrue: [offset := offset + 1]].
	^i!

argumentsDo: operation 
	"Private - Evaluate the dyadic valuable argument, operation, for each of the argument
	types of the receiver, passing the argument type and optional literal parameter#
	as the arguments."

	| i size |
	i := RetClassIndex + 1.
	size := descriptor size.
	[i > size] whileFalse: 
			[| type |
			type := descriptor at: i.
			i := i + 1.
			operation value: type
				value: ((self class typeHasArgument: type) 
						ifTrue: 
							[i := i + 1.
							self at: (descriptor at: i - 1) + 1])]!

argumentsSize
	"Private - Answer the total size, in bytes, that would be occupied by the arguments described 
	by the receiver when pushed onto the machine stack."

	| sum |
	sum := 0.
	self argumentsDo: [:type :class | sum := sum + (self class sizeOf: type type: class)].
	^sum!

argumentTypes
	"Private - Answer a sequenceable collection containing the argument type 
	descriptions for the receiver."

	| types |
	types := Array writeStream: self argumentCount.
	self argumentsDo: [:n :type | types nextPut: (self class nameOf: n type: type)].
	^types grabContents!

calleeCleans
	"Answer whether the receiver describes a function which pops its own arguments
	before returning (e.g. stdcall)."

	^self convention ~= 1	"cdecl is 1"!

callingConvention
	"Private - Answer the calling convention name of the external function described by the receiver.
	This is an integer enumeration."

	^self class nameOfConvention: self convention!

convention
	"Private - Answer the calling convention type (a small integer)."

	^descriptor first!

description
	"Private - Answer the descriptor string for the external function described by the receiver."

	| stream |
	stream := String smalltalkWriteStream: 60.
	self printDescriptionOn: stream.
	^stream contents!

descriptor: aCollectionOfBytes
	"Private - Set the descriptor byte array for the external function described by the receiver."

	descriptor := aCollectionOfBytes asByteArray!

literals: args
	"Set the literal argument parameters to those in the SequenceableCollection argument, args.
	Answer the receiver."

	args keysAndValuesDo: [:i :e | self at: i put: e]
	!

name
	"Answer the 'name' of the external function described by the receiver."

	^'_'
	!

name: aString 
	"Set the 'name' of the external function described by the receiver to the argument.
	At the moment we discard this."

	^self!

printDescriptionOn: stream
	"Private - Answer the descriptor string for the external function described by the receiver."

	| types |
	stream
		nextPutAll: self callingConvention;
		space;
		nextPutAll: self returnType.
	types := self argumentTypes.
	"types notEmpty ifTrue: [stream nextPut: $,]."
	types do: 
			[:each |
			stream
				space;
				nextPutAll: each]!

printOn: aStream
	"Append a debug description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self printDescriptionOn: aStream.
	aStream nextPut: $)!

retType
	"Private - Answer the return type as a value from the external type enumeration."

	^(descriptor at: 3) bitAnd: RetTypeMask!

returnType
	"Private - Answer the return type name of the external function described by the receiver.
	This is an integer enumeration."

	| type class |
	type := self retType.
	class := (self class typeHasArgument: type) ifTrue: [self at: (descriptor at: RetClassIndex) + 1].
	^self class nameOf: type type: class! !
!External.FunctionDescriptor categoriesFor: #argumentCount!accessing!private! !
!External.FunctionDescriptor categoriesFor: #argumentIndexFromOffset:!helpers!private! !
!External.FunctionDescriptor categoriesFor: #argumentsDo:!accessing!private! !
!External.FunctionDescriptor categoriesFor: #argumentsSize!accessing!private! !
!External.FunctionDescriptor categoriesFor: #argumentTypes!accessing!private! !
!External.FunctionDescriptor categoriesFor: #calleeCleans!public!testing! !
!External.FunctionDescriptor categoriesFor: #callingConvention!accessing!private! !
!External.FunctionDescriptor categoriesFor: #convention!accessing!private! !
!External.FunctionDescriptor categoriesFor: #description!accessing!private! !
!External.FunctionDescriptor categoriesFor: #descriptor:!accessing!private! !
!External.FunctionDescriptor categoriesFor: #literals:!accessing!public! !
!External.FunctionDescriptor categoriesFor: #name!accessing!public! !
!External.FunctionDescriptor categoriesFor: #name:!accessing!public! !
!External.FunctionDescriptor categoriesFor: #printDescriptionOn:!accessing!private! !
!External.FunctionDescriptor categoriesFor: #printOn:!printing!public! !
!External.FunctionDescriptor categoriesFor: #retType!accessing!private! !
!External.FunctionDescriptor categoriesFor: #returnType!accessing!private! !

!External.FunctionDescriptor class methodsFor!

argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which is a String
	specifying a list of argument types in the standard Dolphin format. The return type is
	defaulted to 'uintptr' (i.e. UINT_PTR) and the calling convention to 'stdcall:'."

	^self
		returnType: 'uintptr'
		argumentTypes: argString!

callingConvention: convString returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the arguments specifying, respectively, the calling convention, return type, and argument types as parseable strings.
	Any class names present in return type or argument types strings will be bound in the context of the Smalltalk namespace."

	^self callingConvention: convString returnType: retString argumentTypes: argString environment: Smalltalk!

callingConvention: convString returnType: retString argumentTypes: argString environment: aNamespace
	"Answer an instance of the receiver instantiated from the arguments specifying, respectively, the calling convention, return type, and argument types as parseable strings.
	Any class names present in return type or argument types strings will be bound in the context of the specified namespace (which can be in fact be any class)."

	^self fromString: convString, ' ', retString, ' ', argString environment: aNamespace!

conventionFromName: aString
	"Answer the type name for the specified integer type, or -1 if not recognised."

	^(CallingConventions indexOf: aString)-1!

descriptor: aByteArray literals: aSequenceableCollection
	"Private - Answer an instance of the receiver instantiated from the arguments."

	^(self new: aSequenceableCollection size)
		descriptor: aByteArray;
		literals: aSequenceableCollection;
		yourself!

fromString: aString
	^self fromString: aString environment: Smalltalk!

fromString: aString environment: aNamespace
	"Answer an instance of the receiver instantiated from the argument, which
	is a Dolphin format external function descriptor, e.g:

		External.FunctionDescriptor fromString: 'stdcall: hresult GUID* lppvoid'
	"

	| array |
	array := self parseDescriptor: aString environment: aNamespace.
	^self descriptor: array first literals: array second!

initialize
	"Private - Initialize the class variables of the receiver.
		self initialize
	"

	"Maximum arg type value is currently 63"

	self addClassConstant: 'RetTypeMask' value: ExtCallArgMax.
	self initializeExternalTypes.
	self initializeExternalRefTypes.

	"Remember that bytes and words are still pushed as 32-bit values"
	TypeSizes := #[0 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4 4 4 8 8 4 4 16 8 4 16 0 0 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 4 4 4 0 0 0 0 0 0 0 0].
	TypeSizes whileMutableDo: 
			[TypeSizes
				at: ExtCallArgINTPTR + 1 put: VMConstants.IntPtrSize;
				at: ExtCallArgUINTPTR + 1 put: VMConstants.IntPtrSize].
	self assert: [ValueTypes asSortedCollection last < TypeSizes size].
	self initializeCallingConventions.
	self addClassConstant: 'RetClassIndex' value: 4!

initializeCallingConventions
	"Private - All possible calling conventions (not all are supported)"

	CallingConventions := #('stdcall:' 'cdecl:' 'fastcall:' 'thiscall:')!

initializeExternalRefTypes
	"Private - Reference types are the types to be used for the value type with one level of indirection, where the name
	of a struct class appears, this is assumed to be associated with an ExtCallArgLP argument type."

	ReferenceTypes := Array new: ExtCallArgMax + 1.
	ReferenceTypes
		at: ExtCallArgVOID + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgLPPVOID + 1 put: nil;
		at: ExtCallArgCHAR + 1 put: ExtCallArgLPSTR;
		at: ExtCallArgBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgSBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgWORD + 1 put: #WORD;
		at: ExtCallArgSWORD + 1 put: #SWORD;
		at: ExtCallArgDWORD + 1 put: #DWORD;
		at: ExtCallArgSDWORD + 1 put: #SDWORD;
		at: ExtCallArgUINTPTR + 1 put: #UINT_PTR;
		at: ExtCallArgINTPTR + 1 put: #INT_PTR;
		at: ExtCallArgBOOL + 1 put: #DWORD;
		at: ExtCallArgHANDLE + 1 put: #DWORD;
		at: ExtCallArgDOUBLE + 1 put: #DOUBLE;
		at: ExtCallArgLPSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgOOP + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgFLOAT + 1 put: #FLOAT;
		at: ExtCallArgLPVOID + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgHRESULT + 1 put: #HRESULT;
		at: ExtCallArgLPWSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgQWORD + 1 put: #ULARGE_INTEGER;
		at: ExtCallArgSQWORD + 1 put: #LARGE_INTEGER;
		at: ExtCallArgOTE + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgBSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgVARIANT + 1 put: #VARIANT;
		at: ExtCallArgDATE + 1 put: #DATE;
		at: ExtCallArgVARBOOL + 1 put: #VARIANT_BOOL;
		at: ExtCallArgGUID + 1 put: #REFGUID;
		at: ExtCallArgSTRUCT + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT4 + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT8 + 1 put: ExtCallArgLP;
		at: ExtCallArgNTSTATUS + 1 put: #SDWORD;
		at: ExtCallArgErrno + 1 put: #SDWORD.
	ReferenceTypes isImmutable: true!

initializeExternalTypes
	ValueTypes := LookupTable new.
	ValueTypes
		at: 'sdword' put: ExtCallArgSDWORD;
		at: 'dword' put: ExtCallArgDWORD;
		at: 'uintptr' put: ExtCallArgUINTPTR;
		at: 'intptr' put: ExtCallArgINTPTR;
		at: 'lpvoid' put: ExtCallArgLPVOID;
		at: 'handle' put: ExtCallArgHANDLE;
		at: 'lppvoid' put: ExtCallArgLPPVOID;
		at: 'lpstr' put: ExtCallArgLPSTR;
		at: 'bool' put: ExtCallArgBOOL;
		at: 'double' put: ExtCallArgDOUBLE;
		at: 'float' put: ExtCallArgFLOAT;
		at: 'hresult' put: ExtCallArgHRESULT;
		at: 'char' put: ExtCallArgCHAR;
		at: 'byte' put: ExtCallArgBYTE;
		at: 'sbyte' put: ExtCallArgSBYTE;
		at: 'word' put: ExtCallArgWORD;
		at: 'sword' put: ExtCallArgSWORD;
		at: 'oop' put: ExtCallArgOOP;
		at: 'lpwstr' put: ExtCallArgLPWSTR;
		at: 'bstr' put: ExtCallArgBSTR;
		at: 'qword' put: ExtCallArgQWORD;
		at: 'sqword' put: ExtCallArgSQWORD;
		at: 'ote' put: ExtCallArgOTE;
		at: 'variant' put: ExtCallArgVARIANT;
		at: 'varbool' put: ExtCallArgVARBOOL;
		at: 'guid' put: ExtCallArgGUID;
		at: 'date' put: ExtCallArgDATE;
		at: 'ntstatus' put: ExtCallArgNTSTATUS;
		at: 'errno' put: ExtCallArgErrno.
	"void is only valid as a return type, not an argument type."
	ValueTypes at: 'void' put: ExtCallArgVOID.

	"Init the reverse mapping of the type enumeration to string names"
	TypeNames := Array new: ExtCallArgMax + 1.
	ValueTypes keysAndValuesDo: [:eachKey :eachValue | TypeNames at: eachValue + 1 put: eachKey].
	TypeNames isImmutable: true.

	"Convert a few class types to the special types to save space and time"
	ValueTypes
		at: 'ExternalAddress' put: ExtCallArgLPVOID;
		at: 'ExternalHandle' put: ExtCallArgHANDLE;
		at: 'BSTR' put: ExtCallArgBSTR;
		at: 'VARIANT' put: ExtCallArgVARIANT;
		at: 'SDWORD' put: ExtCallArgSDWORD;
		at: 'DWORD' put: ExtCallArgDWORD;
		at: 'INT_PTR' put: ExtCallArgINTPTR;
		at: 'UINT_PTR' put: ExtCallArgUINTPTR;
		at: 'LPVOID' put: ExtCallArgLPVOID;
		at: 'DOUBLE' put: ExtCallArgDOUBLE;
		at: 'FLOAT' put: ExtCallArgFLOAT;
		at: 'HRESULT' put: ExtCallArgHRESULT;
		at: 'BYTE' put: ExtCallArgBYTE;
		at: 'SBYTE' put: ExtCallArgSBYTE;
		at: 'WORD' put: ExtCallArgWORD;
		at: 'SWORD' put: ExtCallArgSWORD;
		at: 'LPWSTR' put: ExtCallArgLPWSTR;
		at: 'QWORD' put: ExtCallArgQWORD;
		at: 'ULARGE_INTEGER' put: ExtCallArgQWORD;
		at: 'SQWORD' put: ExtCallArgSQWORD;
		at: 'LARGE_INTEGER' put: ExtCallArgSQWORD;
		at: 'GUID' put: ExtCallArgGUID;
		at: 'IID' put: ExtCallArgGUID;
		at: 'CLSID' put: ExtCallArgGUID;
		at: 'VARIANT_BOOL' put: ExtCallArgVARBOOL;
		at: 'DATE' put: ExtCallArgDATE;
		shrink;
		isImmutable: true!

isPointerToStruct: anInteger 
	^anInteger == ExtCallArgLP or: [anInteger == ExtCallArgCOMPTR]!

nameOf: typeOrdinal type: aClass 
	"Answer the type name for the specified type."

	^(self typeHasArgument: typeOrdinal) 
		ifTrue: 
			[aClass fullName , (((self isPointerToStruct: typeOrdinal) and: [aClass isIndirection not]) 
						ifTrue: ['*']
						ifFalse: [''])]
		ifFalse: [TypeNames at: typeOrdinal + 1]!

nameOfConvention: anInteger
	"Answer the calling convention name for the specified convention type ordinal."

	^CallingConventions at: anInteger + 1!

oneStringArg
	"Answer a shared instance of the receiver describing a standard function
	with a single string argument."

	#deprecated.
	^self argumentTypes: 'lpstr'!

parseArgDesc: aString environment: aNamespace
	"Private - Parse the next argument type from the input stream argument, aStream, answering
	an association between the type number and an optional argument (a subclass of ExternalStructure)."

	| qualifier typeName assoc |
	typeName := aString upTo: $*.
	qualifier := aString copyFrom: typeName size + 1 to: aString size.

	"Get an association between a type code for the name and the associated indirection type code or class name"
	assoc := (self typeFromName: typeName ifAbsent: [])
				ifNil: 
					["Not a built-in type, so try as a class..."
					ExtCallArgSTRUCT -> typeName asSymbol]
				ifNotNil: [:code | code -> (self referenceTypeFor: code)].
	qualifier = '**'
		ifTrue: 
			[^self
				parseDoubleIndirection: assoc
				typeName: typeName
				environment: aNamespace].
	qualifier = '*' ifTrue: [^self parseSingleIndirection: assoc environment: aNamespace].
	^self parseValueType: assoc environment: aNamespace!

parseCallingConvention: aStream
	"Private - Answer the calling convention number specified by the input stream."

	^self conventionFromName: aStream nextWord!

parseDescriptor: aString environment: aNamespace
	"Private - Parse a literal string which describes an external function in the standard
	Dolphin format. This is very simplistic pending Smalltalk compiler support."

	| descriptor literals stream argCount returnType |
	stream := aString readStream.
	descriptor := ByteArray writeStream: 10.
	descriptor nextPut: (self parseCallingConvention: stream).
	descriptor nextPut: 0.	"Reserve slot for argument count"
	returnType := self parseArgDesc: stream nextWord environment: aNamespace.
	descriptor nextPut: returnType key.
	descriptor nextPut: 0.
	literals := Array writeStream.
	returnType value notNil ifTrue: [literals nextPut: returnType value].
	argCount := 0.
	stream skipSeparators.
	[stream atEnd] whileFalse: 
			[| argType |
			argType := self parseArgDesc: stream nextWord environment: aNamespace.
			argCount := argCount + 1.
			descriptor nextPut: argType key.
			argType value notNil
				ifTrue: 
					[descriptor nextPut: literals size.
					literals nextPut: argType value]].
	descriptor := descriptor contents.
	descriptor at: 2 put: argCount.
	^{descriptor. literals contents}!

parseDoubleIndirection: assoc typeName: typeName environment: aNamespace
	| pointerType |
	pointerType := assoc value.
	"If indirection type is #lppvoid or an indirection class, then cannot doubly indirect it"
	(pointerType == ExtCallArgLPPVOID or: 
			[pointerType isInteger not and: 
					[assoc key == ExtCallArgSTRUCT
						and: [(BindingReference pathString: pointerType home: aNamespace) value isIndirection]]])
		ifTrue: 
			[^self error: ('<1s>: Only one further level of indirection to an indirection type is possible'
						expandMacrosWith: typeName)].
	^ExtCallArgLPPVOID -> nil!

parsePointerToStruct: anAssociation environment: aNamespace
	| structClass |
	structClass := (BindingReference pathString: anAssociation value home: aNamespace) value.
	^(structClass isIndirection and: [anAssociation key == ExtCallArgSTRUCT])
		ifTrue: [ExtCallArgLPPVOID -> nil]
		ifFalse: 
			[(#{Smalltalk.IUnknown} valueOrNil
				ifNil: [ExtCallArgLP]
				ifNotNil: [:unkClass | (structClass includesBehavior: unkClass) ifTrue: [ExtCallArgCOMPTR] ifFalse: [ExtCallArgLP]])
					-> structClass]!

parseSingleIndirection: anAssociation environment: aNamespace
	| pointerType |
	pointerType := anAssociation value.
	pointerType isNil
		ifTrue: 
			[^self error: ('<1s> cannot be further indirected'
						expandMacrosWith: (self nameOf: anAssociation key type: anAssociation value))].
	^pointerType isInteger not
		ifTrue: [self parsePointerToStruct: anAssociation environment: aNamespace]
		ifFalse: [pointerType -> nil]!

parseStructArg: assoc environment: aNamespace
	| structClass |
	structClass := (BindingReference pathString: assoc value home: aNamespace) value.
	^(structClass isIndirection
		ifTrue: [ExtCallArgLP]
		ifFalse: 
			[| bytes |
			bytes := structClass byteSize.
			bytes <= 4
				ifTrue: [ExtCallArgSTRUCT4]
				ifFalse: [bytes <= 8 ifTrue: [ExtCallArgSTRUCT8] ifFalse: [ExtCallArgSTRUCT]]])
			-> structClass!

parseValueType: assoc environment: aNamespace
	assoc key == ExtCallArgSTRUCT ifTrue: [^self parseStructArg: assoc environment: aNamespace].
	^assoc key -> nil!

referenceTypeFor: valueType
	^ReferenceTypes at: valueType + 1!

returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which
	is a String specifying a list of argument types in the standard Dolphin
	format. The return type is defaulted to 'dword' and the calling convention
	to 'stdcall:'."

	^self
		callingConvention: 'stdcall:'
		returnType: retString
		argumentTypes: argString!

sizeOf: anInteger type: aClass 
	"Private - Answer the size of the specified type."

	^anInteger == ExtCallArgSTRUCT 
		ifTrue: [aClass byteSize]
		ifFalse: [TypeSizes at: anInteger + 1]!

structTypeForSize: anInteger
	"Private - Answer the structure type to use for structures of the specified byte size."

	anInteger <= 8
		ifTrue: 
			[anInteger <= 4 ifTrue: [anInteger > 0 ifTrue: [^ExtCallArgSTRUCT4]] ifFalse: [^ExtCallArgSTRUCT8]].
	^ExtCallArgSTRUCT!

typeFromName: typeName
	"Answer the type code for the specified <readableString> type name."

	^self typeFromName: typeName ifAbsent: [self errorNotFound: typeName]!

typeFromName: typeName ifAbsent: exceptionHandler
	"Answer the type code for the specified <readableString> type name, 
	or the result of executing the niladic valuable, exceptionHandler, if the
	type is not recognised."

	^ValueTypes at: typeName ifAbsent: [^exceptionHandler value]!

typeHasArgument: ordinalType
	"Private - Answer whether the specified type (identified by ordinal) has an argument
	accompanying it."

	^ordinalType >= ExtCallArgSTRUCT! !
!External.FunctionDescriptor class categoriesFor: #argumentTypes:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #callingConvention:returnType:argumentTypes:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #callingConvention:returnType:argumentTypes:environment:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #conventionFromName:!constants!public! !
!External.FunctionDescriptor class categoriesFor: #descriptor:literals:!instance creation!private! !
!External.FunctionDescriptor class categoriesFor: #fromString:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #fromString:environment:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #initialize!development!initializing!private! !
!External.FunctionDescriptor class categoriesFor: #initializeCallingConventions!development!initializing!private! !
!External.FunctionDescriptor class categoriesFor: #initializeExternalRefTypes!development!initializing!private! !
!External.FunctionDescriptor class categoriesFor: #initializeExternalTypes!development!initializing!private! !
!External.FunctionDescriptor class categoriesFor: #isPointerToStruct:!helpers!private! !
!External.FunctionDescriptor class categoriesFor: #nameOf:type:!constants!public! !
!External.FunctionDescriptor class categoriesFor: #nameOfConvention:!constants!public! !
!External.FunctionDescriptor class categoriesFor: #oneStringArg!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #parseArgDesc:environment:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #parseCallingConvention:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #parseDescriptor:environment:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #parseDoubleIndirection:typeName:environment:!helpers!private! !
!External.FunctionDescriptor class categoriesFor: #parsePointerToStruct:environment:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #parseSingleIndirection:environment:!helpers!private! !
!External.FunctionDescriptor class categoriesFor: #parseStructArg:environment:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #parseValueType:environment:!parsing!private! !
!External.FunctionDescriptor class categoriesFor: #referenceTypeFor:!parsing!public! !
!External.FunctionDescriptor class categoriesFor: #returnType:argumentTypes:!instance creation!public! !
!External.FunctionDescriptor class categoriesFor: #sizeOf:type:!constants!private! !
!External.FunctionDescriptor class categoriesFor: #structTypeForSize:!constants!private! !
!External.FunctionDescriptor class categoriesFor: #typeFromName:!constants!public! !
!External.FunctionDescriptor class categoriesFor: #typeFromName:ifAbsent:!constants!public! !
!External.FunctionDescriptor class categoriesFor: #typeHasArgument:!enquiries!private! !

