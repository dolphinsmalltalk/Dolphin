"Filed out from Dolphin Smalltalk 7"!

Win32Structure subclass: #EXCEPTION_RECORD
	instanceVariableNames: 'info'
	classVariableNames: '_OffsetOf_ExceptionAddress _OffsetOf_ExceptionCode _OffsetOf_ExceptionFlags _OffsetOf_ExceptionInformation _OffsetOf_ExceptionRecord _OffsetOf_NumberParameters'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
EXCEPTION_RECORD guid: (GUID fromString: '{87b4c5f0-026e-11d3-9fd7-00a0cc3e4a32}')!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_ExceptionAddress' value: 16rC!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_ExceptionCode' value: 16r0!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_ExceptionFlags' value: 16r4!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_ExceptionInformation' value: 16r14!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_ExceptionRecord' value: 16r8!
EXCEPTION_RECORD addClassConstant: '_OffsetOf_NumberParameters' value: 16r10!
EXCEPTION_RECORD comment: '<EXCEPTION_RECORD> is an <ExternalStructure> class to wrap the struct ''Win32.EXCEPTION_RECORD'' from type information in the ''Win32 API'' library.

The type library contains the following helpstring for this struct
	"Describes a Win32 exception; the parameter block passed to Win32 exception handlers."

** This comment was automatically generated from a type library. Delete this line to prevent any manual edits from being overwritten if the wrapper class is regenerated. **

IDL definition follows:

typedef [uuid(87b4c5f0-026e-11d3-9fd7-00a0cc3e4a32), helpstring("Describes a Win32 exception; the parameter block passed to Win32 exception handlers.")]
struct tagEXCEPTION_RECORD {
	[readonly, helpstring("The reason the exception occurred. This is the code generated by a hardware exception, or the code specified in the RaiseException function for a software-generated exception")] unsigned long ExceptionCode;
	[readonly, helpstring("The exception flags. This member can be either zero, indicating a continuable exception, or EXCEPTION_NONCONTINUABLE indicating a noncontinuable exception. ")] unsigned long ExceptionFlags;
	[readonly, helpstring("A pointer to an associated EXCEPTION_RECORD structure. Exception records can be chained together to provide additional information when nested exceptions occur.")] EXCEPTION_RECORD* ExceptionRecord;
	[readonly, helpstring("The address where the exception occurred.")] void* ExceptionAddress;
	[readonly, helpstring("The number of parameters associated with the exception. This is the number of defined elements in the ExceptionInformation array.")] unsigned long NumberParameters;
	[hidden, readonly, helpstring("An array of additional arguments that describe the exception. The RaiseException function can specify this array of arguments. For most exception codes, the array elements are undefined.")] ULONG_PTR ExceptionInformation[15];
} EXCEPTION_RECORD;
'!
!EXCEPTION_RECORD categoriesForClass!Win32-Structs! !
!EXCEPTION_RECORD methodsFor!

ExceptionAddress
	"Answer the <ExternalAddress> value of the receiver's 'ExceptionAddress' field."

	^(bytes uintPtrAtOffset: _OffsetOf_ExceptionAddress) asExternalAddress!

ExceptionCode
	"Answer the <Integer> value of the receiver's 'ExceptionCode' field."

	^bytes dwordAtOffset: _OffsetOf_ExceptionCode!

ExceptionFlags
	"Answer the <Integer> value of the receiver's 'ExceptionFlags' field."

	^bytes dwordAtOffset: _OffsetOf_ExceptionFlags!

ExceptionRecord
	"Answer the <EXCEPTION_RECORD> value of the receiver's 'ExceptionRecord' field."

	^EXCEPTION_RECORD fromAddress: (bytes intPtrAtOffset: _OffsetOf_ExceptionRecord)!

information
	"Answer the receiver's ExceptionInformation as an <Array> of <Integer>."

	info isNil
		ifTrue: 
			[| count |
			"Open coded to avoid a base system dependency on UINT_PTR and associated array type"
			count := self NumberParameters.
			info := Array new: count.
			1 to: count
				do: 
					[:i |
					info at: i
						put: (bytes uintPtrAtOffset: _OffsetOf_ExceptionInformation + ((i - 1) * VMConstants.IntPtrSize))]].
	^info!

moduleFileName
	"Answer the file name of the module within which the exception occurred."

	"Avoid dependency on MEMORY_BASIC_INFORMATION"

	| buf |
	buf := ByteArray new: ##(VMConstants.IntPtrSize * 2 + (4 * 5)).
	^(KernelLibrary default
		virtualQuery: self ExceptionAddress
		lpBuffer: buf
		dwLength: buf size) == 0
		ifFalse: [ExternalLibrary moduleFileName: (buf uintPtrAtOffset: VMConstants.IntPtrSize)]!

NumberParameters
	"Answer the <Integer> value of the receiver's 'NumberParameters' field."

	^bytes dwordAtOffset: _OffsetOf_NumberParameters! !
!EXCEPTION_RECORD categoriesFor: #ExceptionAddress!**compiled accessors**!public! !
!EXCEPTION_RECORD categoriesFor: #ExceptionCode!**compiled accessors**!public! !
!EXCEPTION_RECORD categoriesFor: #ExceptionFlags!**compiled accessors**!public! !
!EXCEPTION_RECORD categoriesFor: #ExceptionRecord!**compiled accessors**!public! !
!EXCEPTION_RECORD categoriesFor: #information!accessing!public! !
!EXCEPTION_RECORD categoriesFor: #moduleFileName!accessing!public! !
!EXCEPTION_RECORD categoriesFor: #NumberParameters!**compiled accessors**!public! !

!EXCEPTION_RECORD class methodsFor!

defineFields
	"Define the fields of the EXCEPTION_RECORD structure.

	EXCEPTION_RECORD  compileDefinition

		typedef [uuid(87b4c5f0-026e-11d3-9fd7-00a0cc3e4a32), helpstring('Describes a Win32 exception; the parameter block passed to Win32 exception handlers.')]
		struct tagEXCEPTION_RECORD {
			[readonly, helpstring('The reason the exception occurred. This is the code generated by a hardware exception, or the code specified in the RaiseException function for a software-generated exception')] unsigned long ExceptionCode;
			[readonly, helpstring('The exception flags. This member can be either zero, indicating a continuable exception, or EXCEPTION_NONCONTINUABLE indicating a noncontinuable exception. ')] unsigned long ExceptionFlags;
			[readonly, helpstring('A pointer to an associated EXCEPTION_RECORD structure. Exception records can be chained together to provide additional information when nested exceptions occur.')] EXCEPTION_RECORD* ExceptionRecord;
			[readonly, helpstring('The address where the exception occurred.')] void* ExceptionAddress;
			[readonly, helpstring('The number of parameters associated with the exception. This is the number of defined elements in the ExceptionInformation array.')] unsigned long NumberParameters;
			[hidden, readonly, helpstring('An array of additional arguments that describe the exception. The RaiseException function can specify this array of arguments. For most exception codes, the array elements are undefined.')] ULONG_PTR ExceptionInformation[15];
		} EXCEPTION_RECORD;
"

	self
		defineField: #ExceptionCode type: DWORDField new beReadOnly offset: 0;
		defineField: #ExceptionFlags type: DWORDField new beReadOnly offset: 4;
		defineField: #ExceptionRecord type: (PointerField type: EXCEPTION_RECORD) beReadOnly offset: 8;
		defineField: #ExceptionAddress type: LPVOIDField new beReadOnly offset: 12;
		defineField: #NumberParameters type: DWORDField new beReadOnly offset: 16;
		defineField: #ExceptionInformation type: (ArrayField type: UINT_PTRArray length: 15) beReadOnly beFiller offset: 20.
	self byteSize: 80!

getFieldNames
	^#(#ExceptionCode #ExceptionFlags #ExceptionRecord #ExceptionAddress #NumberParameters)! !
!EXCEPTION_RECORD class categoriesFor: #defineFields!**auto generated**!initializing!public! !
!EXCEPTION_RECORD class categoriesFor: #getFieldNames!**compiled accessors**!constants!private! !

