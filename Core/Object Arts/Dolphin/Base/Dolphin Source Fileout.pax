| package |
package := Package name: 'Dolphin Source Fileout'.
package paxVersion: 1;
	preDeclareClassesOnLoad: false;
	basicComment: ''.

package basicScriptAt: #postinstall put: '(MethodProtocol name: #sourceObject)
	addAllSelectors: #(#canFileOut #fileOut #fileOutName #isChanged #isChanged: #owningPackage);
	addClass: Class;
	addClass: Package;
	addClass: PoolDictionary;
	addClass: PoolConstantsDictionary'.

package methodNames
	add: #BootSessionManager -> #saveImageTo:;
	add: #ChunkSourceFiler -> #emitCategories:for:in:;
	add: #ChunkSourceFiler -> #emitCategoriesForMethods:of:;
	add: #ChunkSourceFiler -> #emitCategoriesOfClass:;
	add: #ChunkSourceFiler -> #emitCategoriesOfMethod:;
	add: #ChunkSourceFiler -> #emitComment:;
	add: #ChunkSourceFiler -> #emitCommentOfClass:;
	add: #ChunkSourceFiler -> #emitDeclarationForClass:variable:;
	add: #ChunkSourceFiler -> #emitMethod:;
	add: #ChunkSourceFiler -> #emitSetBehaviorFlag:forClass:;
	add: #ChunkSourceFiler -> #fileOutBasicDefinitionOfClass:;
	add: #ChunkSourceFiler -> #fileOutBinaryGlobal:;
	add: #ChunkSourceFiler -> #fileOutPoolDictionary:;
	add: #ChunkSourceFiler -> #fileOutProtocols:ofBehavior:;
	add: #ChunkSourceFiler -> #logEvaluation:;
	add: #ChunkSourceFiler -> #storeCommentString:forClass:;
	add: #ChunkSourceFiler -> #storeCommentString:forPackage:;
	add: #ChunkSourceFiler -> #storeSource:for:;
	add: #Class -> #canFileOut;
	add: #Class -> #definitionChunk;
	add: #Class -> #fileOut;
	add: #Class -> #fileOutOn:;
	add: #Class -> #storeClassCategories;
	add: #CompiledMethod -> #storeCategories;
	add: #Metaclass -> #storeClassCategories;
	add: #Package -> #allFileOutNames;
	add: #Package -> #beNotUsingPAX;
	add: #Package -> #beUsingPAX;
	add: #Package -> #canFileOut;
	add: #Package -> #checkTimestamps;
	add: #Package -> #createPackagePath;
	add: #Package -> #dotPacPath;
	add: #Package -> #fileModificationTime;
	add: #Package -> #fileOut;
	add: #Package -> #fileOutAll;
	add: #Package -> #fileOutAllChanged;
	add: #Package -> #fileOutAllOn:;
	add: #Package -> #fileOutBinaryGlobals;
	add: #Package -> #fileOutBinaryGlobalsOn:;
	add: #Package -> #fileOutBootDefinitions;
	add: #Package -> #fileOutClassDefinitionsOn:;
	add: #Package -> #fileOutClassesOn:;
	add: #Package -> #fileOutGlobalAliasesOn:;
	add: #Package -> #fileOutLooseMethodsOn:;
	add: #Package -> #fileOutMethodsOfClass:on:;
	add: #Package -> #fileOutNames;
	add: #Package -> #fileOutOn:;
	add: #Package -> #fileOutSourceGlobalsOn:;
	add: #Package -> #isRenegade;
	add: #Package -> #isUsingPAX;
	add: #Package -> #isUsingPAX:;
	add: #Package -> #save;
	add: #Package -> #saveAs:;
	add: #Package -> #saveChanges;
	add: #Package -> #savePAC;
	add: #Package -> #savePAX;
	add: #Package -> #savePAXAboutBlockOn:;
	add: #Package -> #savePAXChunkOn:;
	add: #Package -> #savePAXGlobalNamesOn:;
	add: #Package -> #savePAXManualPrerequisitesOn:;
	add: #Package -> #savePAXNames:on:;
	add: #Package -> #savePAXNamesOn:;
	add: #Package -> #savePAXPackageOn:;
	add: #Package -> #savePAXPackageVersionOn:;
	add: #Package -> #savePAXPrerequisiteNamesOn:;
	add: #Package -> #savePAXScriptsOn:;
	add: #Package -> #savePAXStripperBytesOn:;
	add: #Package -> #savePAXUntracedGlobalsOn:;
	add: #Package -> #saveSingleFilePackage;
	add: #Package -> #toggleUsingPAX;
	add: #Package -> #updateTimestamp;
	add: #PoolConstantsDictionary -> #canFileOut;
	add: #PoolConstantsDictionary -> #fileOut;
	add: #PoolConstantsDictionary -> #fileOutOn:;
	add: #PoolDictionary -> #canFileOut;
	add: #PoolDictionary -> #fileOut;
	add: #PoolDictionary -> #fileOutOn:;
	add: #SourceFiler -> #emitCategoriesForMethods:of:;
	add: #SourceFiler -> #emitCategoriesOfClass:;
	add: #SourceFiler -> #emitCategoriesOfMethod:;
	add: #SourceFiler -> #emitClassPoolOfClass:;
	add: #SourceFiler -> #emitComment:;
	add: #SourceFiler -> #emitCommentOfClass:;
	add: #SourceFiler -> #emitDeclarationForClass:variable:;
	add: #SourceFiler -> #emitMessages:ofBehavior:;
	add: #SourceFiler -> #emitMethod:;
	add: #SourceFiler -> #emitSetBehaviorFlag:forClass:;
	add: #SourceFiler -> #emitSpecialBehaviourAttributesOfClass:;
	add: #SourceFiler -> #fileOutAllMethodsOfBehavior:;
	add: #SourceFiler -> #fileOutAttributesOfClass:;
	add: #SourceFiler -> #fileOutBasicDefinitionOfClass:;
	add: #SourceFiler -> #fileOutBinaryGlobal:;
	add: #SourceFiler -> #fileOutClass:;
	add: #SourceFiler -> #fileOutDefinitionOfClass:;
	add: #SourceFiler -> #fileOutExpression:;
	add: #SourceFiler -> #fileOutMessages:ofBehavior:;
	add: #SourceFiler -> #fileOutMethods:;
	add: #SourceFiler -> #fileOutPoolDictionary:;
	add: #SourceFiler -> #fileOutProtocols:ofBehavior:;
	add: #SourceFiler -> #fileOutResource:;
	add: #SourceFiler -> #storeCommentString:forClass:;
	add: #SourceFiler -> #storeCommentString:forPackage:;
	add: #SourceManager -> #basicCompressSources:;
	add: #SourceManager -> #compressChangedMethodsOf:onto:;
	add: #SourceManager -> #compressChanges;
	add: #SourceManager -> #compressChangesOf:onto:;
	add: #SourceManager -> #compressChangesOnto:;
	add: #SourceManager -> #compressPackageCommentsOn:;
	add: #SourceManager -> #compressSources;
	add: #SourceManager -> #compressSourcesWith:;
	add: #SourceManager -> #copyAndReopenSources:;
	add: #SourceManager -> #createSources:;
	add: #SourceManager -> #createSourcesFile:;
	add: #SourceManager -> #emitFileOutHeaderOn:;
	add: #SourceManager -> #fileOut:;
	add: #SourceManager -> #fileOut:to:;
	add: #SourceManager -> #fileOutPackagedClass:;
	add: #SourceManager -> #fileOutPackagedClass:to:;
	add: #SourceManager -> #logChanged:;
	add: #SourceManager -> #logComment:;
	add: #SourceManager -> #logComment:to:;
	add: #SourceManager -> #newSourceFiler:;
	add: #SourceManager -> #storeCategoriesForClass:;
	add: #SourceManager -> #storeCategoriesForMethod:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'Dolphin'
	'..\System\Base64\Dolphin Base64'
	'Dolphin Message Box').

package setManualPrerequisites: #(
	'Dolphin Base64').

package!

"Loose Methods"!

!BootSessionManager methodsFor!

saveImageTo: aString 
	"Private - Snapshot to filePath.img, marking the log with a timestamp and copying sources
	files. N.B. Use the public entry point #saveImage: to save an image to a new path.

	Take a special interest if we do not currently have the source files available. This will be
	the case when we load from a .exe. In this case we generate some suitable empty source
	files. We also have to mark methods so that they know they have lost any reference to
	information in a .sml file."

	| oldImagePath oldSentry |
	oldImagePath := self imagePath.
	oldSentry := sentry.

	"Now save image and swap over sources. Take care to end up with a good sources and imagePath"
	
	[self imagePath: aString.
	self createSentinel 
		ifTrue: 
			[| mb |
			mb := MessageBox new.
			mb beTaskModal.
			mb 
				errorMsg: ('The image <1p> is open in another Dolphin instance.<n><n>Close that instance and try again should you still wish to save this image to that name.<n><n>The image has not been saved!!' 
						expandMacrosWith: self imageFileName).
			^self].
	self class sourceManager copyAndReopenSources: self imagePath.
	self
		snapshot: self imageFileName;
		logComment: ('Image saved to <1p>' expandMacrosWith: aString).
	KernelLibrary default closeHandle: oldSentry] 
			ifCurtailed: 
				["Attempt to return to the old state so sources & stuff are intact
				 before showing the user the problem."
				
				[KernelLibrary default closeHandle: sentry.
				sentry := oldSentry.
				self
					imagePath: oldImagePath;
					openSources] 
						on: Error
						do: [:anError | anError resignalAsWarning]]! !

!BootSessionManager categoriesForMethods!
saveImageTo:!operations-saving!private! !
!

!ChunkSourceFiler methodsFor!

emitCategories: aCollection for: aSymbol in: aClass 
	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesFor:;
		space.
	"#2144."
	self emitString: aSymbol printString.
	stream nextPut: $!!.
	aCollection asSortedCollection do: [:each | self nextChunkPut: each name].
	self endChunk!

emitCategoriesForMethods: aSequencableCollection of: aClass
	"Emit source that associates the <CompiledMethod>s in the <collection>, methods, with their current categories.
	Note that it is assumed that all the methods are of the same class."

	aSequencableCollection isEmpty ifTrue: [^self].
	stream
		cr;
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesForMethods;
		nextPut: $!!;
		cr.
	aSequencableCollection do: 
			[:method |
			self emitString: method selector.
			stream nextPut: $!!.
			method realCategories asSortedCollection do: [:each | self nextChunkPut: each name].
			self endChunk].
	stream
		nextPut: $!!;
		cr!

emitCategoriesOfClass: aClass
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	| categories |
	categories := aClass categories.
	categories notEmpty ifFalse: [^self].
	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesForClass;
		nextPut: $!!.
	categories asSortedCollection do: [:aCategory | self nextChunkPut: aCategory name].
	self endChunk.
	stream cr!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append a chunk to the <puttableStream>, aWriteStream,
	to reclassify the <CompiledMethod>, aCompiledMethod, in all its current 
	method categories."

	self 
		emitCategories: aCompiledMethod realCategories
		for: aCompiledMethod selector
		in: aCompiledMethod methodClass!

emitComment: aString
	"Private - Record aString to the chunk stream as a comment. All comments logged are prefixed
	with a timestamp. N.B. Logging requests should be directed through the SessionManager."

	stream nextPut: $".
	self emitString: aString.
	stream
		nextPut: $";
		nextPut: $!!;
		cr;
		flush!

emitCommentOfClass: aClass
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to the <puttableStream>
	aWriteStream."

	stream
		nextPutAll: aClass name;
		space;
		display: #comment:;
		space.
	self nextChunkPut: aClass comment printString.
	stream
		cr;
		cr!

emitDeclarationForClass: aClass variable: anAssociation
	| value |
	stream
		nextPutAll: aClass name;
		nextPutAll: (anAssociation isImmutable
					ifTrue: [' addClassConstant: ']
					ifFalse: [' addClassVariable: ']);
		print: anAssociation key;
		nextPutAll: ' value: '.
	value := anAssociation value.
	self
		nextChunkPut: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value storeString]).
	stream cr!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, 
	to the source stream, updating the method's source descriptor if configured with a 
	source file index."

	self storeSource: aCompiledMethod getSource for: aCompiledMethod!

emitSetBehaviorFlag: flagName forClass: aClass
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	stream
		print: aClass;
		space;
		nextPutAll: flagName;
		nextPutAll: ': true!!';
		cr;
		cr!

fileOutBasicDefinitionOfClass: aClass
	"Print a definition of the <Class>, aClass, onto the <puttableStream>, aWriteStream."

	aClass printDefinitionOn: stream.
	stream
		nextPut: $!!;
		cr;
		cr!

fileOutBinaryGlobal: anAssociation 
	"File out the text representation of the non-<sourceObject> which is the value of the
	<Association>, anAssociation, onto the receiver's source stream. The key of the association
	is the global name. If the global is just an alias to a class, then we don't need to binary
	file it at all."

	| glob |
	glob := anAssociation value.
	(glob class isMeta and: [anAssociation key ~= glob name]) 
		ifTrue: 
			[stream
				nextPutAll: anAssociation key;
				nextPutAll: ' := ';
				print: anAssociation value;
				nextPut: $!!;
				cr.
			^self].
	stream
		nextPutAll: anAssociation key;
		nextPutAll: ' := ';
		print: Object;
		space;
		display: #fromBinaryStoreBytes:;
		space;
		cr.
	glob binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutPoolDictionary: aPoolDictionary
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the <puttableStream>, aWriteStream. The definition should be sufficient to recreate a
	copy of the dictionary."

	| poolName env |
	env := aPoolDictionary environment.
	poolName := aPoolDictionary name.
	stream
		nextPutAll: (env keyAtValue: env);
		nextPutAll: ' at: ';
		print: poolName;
		nextPutAll: ' put: (';
		nextPutAll: aPoolDictionary class name;
		nextPutAll: ' named: ';
		print: poolName.
	self emitChunk: ')'.
	aPoolDictionary associations asSortedCollection do: 
			[:a |
			| value |
			stream
				nextPutAll: poolName;
				nextPutAll: ' at: ';
				print: a key;
				nextPutAll: ' put: '.
			value := a value.
			value isLiteral
				ifTrue: 
					[self emitChunk: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value printString])]
				ifFalse: 
					[stream
						nextPut: $(;
						print: Object;
						space;
						display: #fromBinaryStoreBytes:;
						space;
						cr.
					value binaryStoreBytes base64StoreOn: stream.
					self emitChunk: ')']].
	self emitChunk: poolName , ' shrink'!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to source stream,
	associating them with the <ClassDescription>, aClassDescription."

	aCollection isEmpty ifTrue: [^self].
	(aCollection asSortedCollection: [:a :b | (a name <==> b name) <= 0]) do: 
			[:p | 
			stream
				nextPutAll: aClassDescription name;
				nextPutAll: ' methodProtocol: ';
				print: p asSymbol;
				nextPutAll: ' attributes: ';
				print: p attributes asArray;
				nextPutAll: ' selectors: #('.
			"We must print the selectors individually as their may be very many and the default print truncates after
			 a certain number of characters."
			p selectors asSortedCollection do: [:s | stream print: s] separatedBy: [stream space].
			self
				nextChunkPut: ')';
				cr].
	self cr!

logEvaluation: aString
	"Private - Log an immediate expression evaluation to the the source stream."

	stream nextPutAll: '"Evaluate"'; cr.
	self fileOutExpression: aString!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	stream nextPutAll: aClass name; nextPutAll: ' comment:'; cr.
	self storeSource: aString printString for: aClass.
	stream cr!

storeCommentString: aString forPackage: aPackage 
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	stream
		nextPut: $(;
		print: aPackage class;
		space;
		nextPutAll: #manager;
		space;
		nextPutAll: #packageNamed:;
		space;
		print: aPackage name;
		nextPutAll: ') ';
		nextPutAll: #comment:;
		cr.
	self storeSource: aString printString for: aPackage.
	stream cr!

storeSource: aString for: aSourceObject 
	"Private - Store the <readableString>, aString, as the source text for the <sourceObject>,
	aSourceObject. If the receiver has been associated with a source file (i.e. the
	sourceFileIndex is set) then update aSourceObject's source descriptor so that in future it
	retrieves the source text from the receiver's source stream."

	| position |
	position := stream position.
	self nextChunkPut: aString.
	sourceFileIndex notNil 
		ifTrue: 
			[aSourceObject sourceDescriptor: (aString isEmpty ifFalse: [self sourceDescriptorForIndex: sourceFileIndex position: position])]! !

!ChunkSourceFiler categoriesForMethods!
emitCategories:for:in:!private!source filing-file out! !
emitCategoriesForMethods:of:!private!source filing! !
emitCategoriesOfClass:!private!source filing-file out! !
emitCategoriesOfMethod:!private!source filing-file out! !
emitComment:!private!source filing-file out! !
emitCommentOfClass:!private!source filing-file out! !
emitDeclarationForClass:variable:!private!source filing-file out! !
emitMethod:!private!source filing-file out! !
emitSetBehaviorFlag:forClass:!private!source filing-file out! !
fileOutBasicDefinitionOfClass:!public!source filing-file out! !
fileOutBinaryGlobal:!public!source filing-file out! !
fileOutPoolDictionary:!public!source filing-file out! !
fileOutProtocols:ofBehavior:!public!source filing-file out! !
logEvaluation:!private!source filing-file out! !
storeCommentString:forClass:!public!source filing-file out! !
storeCommentString:forPackage:!public!source filing-file out! !
storeSource:for:!private!source filing-file out! !
!

!Class methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

definitionChunk
	"Answer a chunk string for the definition of the receiver"

	| stream |
	stream := String writeStream: 256.
	(self sourceManager sourceFilerOn: stream) fileOutDefinitionOfClass: self.
	^stream contents!

fileOut
	"File out the receiver's definition to a class file in the receiver's
	package directory."

	self sourceManager fileOutPackagedClass: self!

fileOutOn: aSourceFiler
	aSourceFiler fileOutClass: self!

storeClassCategories
	"Private - Record the categories of the receiver to the change log.
	The job is simply delegated to the receiver's source manager (if available)."

	self sourceManager storeCategoriesForClass: self! !

!Class categoriesForMethods!
canFileOut!public!source filing! !
definitionChunk!public!source filing-class definition! !
fileOut!public!source filing! !
fileOutOn:!public!source filing! !
storeClassCategories!private!source filing-methods! !
!

!CompiledMethod methodsFor!

storeCategories
	"Private - Record the categories of the receiver.
	The job is simply delegated to the receiver's source manager."

	self class sourceManager storeCategoriesForMethod: self.! !

!CompiledMethod categoriesForMethods!
storeCategories!private!source filing-methods! !
!

!Metaclass methodsFor!

storeClassCategories
	"Private - Record the categories of the receiver to the change log.
	The job is simply delegated to the receiver's source manager (if available)."

	self instanceClass storeClassCategories! !

!Metaclass categoriesForMethods!
storeClassCategories!private!source filing-methods! !
!

!Package methodsFor!

allFileOutNames
	"Private - Answers an OrderedCollection of the source filenames for the receiver and all of its 
	contents when in PAX source mode. Note that the PAX filename is alway last in the collection."

	| answer |
	answer := OrderedCollection new.
	self allSourceObjectsDo: [:each | answer add: each fileOutName].
	^answer!

beNotUsingPAX
	"Place the receiver into a mode where it is not using PAX source files.
	This simply involves deleting any PAX source files that currently exist. Without the
	presence of a same named PAX file, the receiver assumes it is operating in
	non-PAX mode for all future save operations."

	| msg names |
	self isUsingPAX ifFalse: [^self].
	names := self allFileOutNames.
	msg := 'Placing this package into PAC mode will delete <2d> PAX source files in the<n>directory <3s>.<n><n>Are you sure that you wish to proceed?'
				expandMacrosWith: self name
				with: names size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAC mode...' expandMacrosWith: self name))
		ifTrue: [names do: [:each | (File exists: each) ifTrue: [File delete: each]]]!

beUsingPAX
	"Place the receiver into a mode where it is using PAX source files.
	This simply involves creating the PAX source files for the first time. With the
	presence of a same named PAX file, the receiver assumes it is operating in
	PAX mode for all future save operations."

	| msg |
	self isUsingPAX ifTrue: [^self].
	msg := 'Placing this package into PAX source mode will create <1d> source files<n>in the directory <2s>.<n><n>Are you sure that you wish to proceed?' 
				expandMacrosWith: self allSourceObjects size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAX mode...' expandMacrosWith: self name)) 
		ifTrue: [self fileOutAll]!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	all the file out names associated with the PAX file are writeable."

	^self fileOutNames allSatisfy: [:each | File isWriteable: each]!

checkTimestamps
	"Compare the timestamp cached when the package was installed against the timestamp of the
	package file. If the package file has been modified since the package was loaded, then warn
	the user to avoid inadvertent overwrites of later package versions causing loss of changes."

	(CheckTimestamps and: [self isRenegade]) ifFalse: [^self].
	Warning 
		signal: ('The package <1s> has been modified outside this image since it was loaded or last saved.

	Package timestamp:	<2s>
	File modification time:	<3s>

If you proceed and save it from this image then you may lose changes that have been made in another image. It is recommended that before proceeding you first take a backup copy of the current version on disk, or that you abort this operation.' 
				expandMacrosWith: self name
				with: self timestamp displayString
				with: (FILETIME fromInteger: self fileModificationTime) displayString)

!

createPackagePath
	"Private - Create the directory where the receiver resides on disk"

	File createDirectoryPath: (File splitPathFrom: self fileOutName)
!

dotPacPath
	^File path: self packageFileName extension: self class packageExtension!

fileModificationTime
	"Private - Answer the modification time of the receiver's package file on disk as the
	<integer> number of 100-nanosecond intervals since 12:00 A.M. January 1, 1601 UTC (i.e. a
	Win32 FILETIME), or 0 if it does not currently exist."

	| fileName |
	fileName := self isSystemPackage 
				ifTrue: [self classDefinitionsFileName]
				ifFalse: [self isUsingPAX ifTrue: [self fileOutName] ifFalse: [self packageFileName]].
	^(File lastWriteTime: fileName) ifNil: [0] ifNotNil: [:filetime | filetime asInteger]!

fileOut
	"Private - File out a definition of the receiver to source files. Normally this
	involves saving a PAX file except in the case where the receiver is a system package
	when separate class and resource definitions files are saved instead."

	self isSystemPackage 
		ifFalse: 
			[self
				savePAC;
				savePAX;
				versionIfRequired]
		ifTrue: [self fileOutBootDefinitions].
	self updateTimestamp.
	self isChanged: false!

fileOutAll
	"Fileout the receiver to a PAX file and all out it's associated source files.
	The .PAC file is also saved when the .PAX is created in order to ensure that
	the two remain in sync."

	self allSourceObjectsDo: [:each | each fileOut]!

fileOutAllChanged
	"Fileout the changed source objects in the receiver"

	self allSourceObjectsDo: [:each | each isChanged ifTrue: [each fileOut]]!

fileOutAllOn: aSourceFiler 
	self fileOutOn: aSourceFiler.
	self
		fileOutSourceGlobalsOn: aSourceFiler;
		fileOutClassesOn: aSourceFiler;
		fileOutBinaryGlobalsOn: aSourceFiler
!

fileOutBinaryGlobals
	"Private - File out binary globals to individual .STB files.
	This is used in the multi-file .PAX format to avoid binary merge conflicts in the
	main PAX."

	(self binaryGlobalVariables - self globalAliasVariables) do: [:var | | globalStream |
		globalStream := FileStream write: (self fileNameForBinaryGlobal: var key) text: false.
		var value binaryStoreOn: globalStream.
		globalStream close].

!

fileOutBinaryGlobalsOn: aSourceFiler 
	"Private - File out the binary representation of the receiver's non-<sourceObject> 
	globals onto the <SourceFiler> argument. Binary globals are saved as the literal 
	representation of their #binaryStoreBytes.  This is used in the single-file .PAC format."

	aSourceFiler 
		emitComment: 'Binary Globals';
		cr.
	(self binaryGlobalVariables asSortedCollection: self variableSortBlock) 
		do: [:var | aSourceFiler fileOutBinaryGlobal: var; cr]!

fileOutBootDefinitions
	"Private - If this is a system package then only write out .st files capable of defining
	the classes independently of the PAX. These are required by the Dolphin boot process.
	Note that the base system package cannot contain any resources."

	| filer |
	filer := ChunkSourceFiler 
				on: (FileStream write: self classDefinitionsFileName text: true).
	[self fileOutClassDefinitionsOn: filer] ensure: [filer close]!

fileOutClassDefinitionsOn: aSourceFiler
	"Private - Append the text definitions of the receivers owned classes to aFileStream.
	This should produce the minimal amount of information to create a new class when 
	loaded in (i.e. only the basic definitions are emitted)."

	| classes |
	classes := self classesInHierarchyOrder.
	classes isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Class Definitions';
		cr.
	classes do: [:aClass | aSourceFiler fileOutBasicDefinitionOfClass: aClass]!

fileOutClassesOn: aSourceFiler 
	"Private - Append definitions of all the classes owned by the
	receiver to the <SourceFiler>, aSourceFiler.
	Note that the classes are filed out in class hierarchy order to 
	avoid creating forward references and to create a consistently
	ordered source file that can be effectively diff'd."

	aSourceFiler
		emitComment: 'Classes';
		cr.
	self classesInHierarchyOrder do: 
			[:aClass | 
			aSourceFiler fileOutAttributesOfClass: aClass.
			self fileOutMethodsOfClass: aClass on: aSourceFiler.
			self fileOutMethodsOfClass: aClass class on: aSourceFiler]!

fileOutGlobalAliasesOn: aSourceFiler
	"Private - File out the text representation of the receiver's global aliases onto the
	<puttableStream>, stream."

	| globals |
	globals := self globalAliasVariables.
	globals isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Global Aliases';
		cr.
	(globals asSortedCollection: self variableSortBlock)
		do: [:var | aSourceFiler fileOutExpression: var key , ' := ' , var value name].
	aSourceFiler cr!

fileOutLooseMethodsOn: aSourceFiler
	"Private - File out the loose methods owned by the receiver to the <SourceFiler> argument."

	| loose |
	loose := self methods.
	loose isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Loose Methods';
		cr.
	aSourceFiler fileOutMethods: loose!

fileOutMethodsOfClass: aClass on: aSourceFiler 
	"Private - Append any definitions of the classes methods which
	are not owned by another package to the <puttableStream>, target."

	| methods |
	methods := self methodsOfClass: aClass.
	methods size = aClass methodDictionary size 
		ifTrue: 
			["The common case is that all methods of the class also belong to the this package..."

			aSourceFiler fileOutAllMethodsOfBehavior: aClass]
		ifFalse: 
			["...but if some methods are not owned by this package we have more work to do"

			| selectors prereqs addBlock |
			selectors := methods collect: [:m | m selector].
			aSourceFiler fileOutMessages: selectors ofBehavior: aClass.

			"File out the intersection of the immediate protocols of the class and those of this
			and prerequisite packages' methods"

			"First add all selectors in the superclass chain which are in this package or one of its
			pre-requisites into the set of available selectors."
			prereqs := self prerequisites.
			addBlock := 
					[:e :p | 
					selectors addAll: ((p methodsOfClass: e) collect: [:m | m selector])].
			prereqs do: [:p | addBlock value: aClass value: p].
			aClass allSuperclassesDo: 
					[:e | 
					addBlock value: e value: self.
					prereqs do: [:p | addBlock value: e value: p]].
			#todo.	"File out partial protocols, although tools should prevent protocols being split across packages really"
			aSourceFiler fileOutProtocols: (aClass protocols 
						select: [:p | (p selectors difference: selectors) isEmpty])
				ofBehavior: aClass]!

fileOutNames
	"Private - Answers a set of the source filenames for the receiver when in the multi-file
	(.PAX) source mode. This contains pathnames used to store the PAX file and each of the
	binary globals, etc. It does not include the source files for the	<sourceObject>s held by the 
	receiver."
	
	^self isSystemPackage 
		ifTrue: [Set with: self classDefinitionsFileName]
		ifFalse: [
			Set new 
				add: self fileOutName;
				addAll: (self binaryGlobalNames collect: [:each | self fileNameForBinaryGlobal: each]);
				yourself]!

fileOutOn: aSourceFiler
	"Append the definition of the receiver in PAX format onto the
	<SourceFiler> argument. This does not file out the source files of the 
	receiver's contents."

	self savePAXChunkOn: aSourceFiler.
	self fileOutClassDefinitionsOn: aSourceFiler.
	self fileOutGlobalAliasesOn: aSourceFiler.
	self fileOutLooseMethodsOn: aSourceFiler.
	aSourceFiler
		emitComment: 'End of package definition';
		cr!

fileOutSourceGlobalsOn: aSourceFiler 
	"Private - File out the text representation of the receiver's globals onto the
	<puttableStream>, stream. This is used in the single-file .PAC format."

	aSourceFiler
		emitComment: 'Source Globals';
		cr.
	(self sourceGlobalVariables asSortedCollection: self variableSortBlock) do: 
			[:var | 
			var value fileOutOn: aSourceFiler.
			aSourceFiler cr]!

isRenegade
	"Answer whether the receiver was loaded (or last saved) before its source representation in the file system.
	An example of where a package might be a renegade is if it has been modified and saved from another image."

	| lastWriteTime |
	lastWriteTime := self fileModificationTime.
	^lastWriteTime > timestamp!

isUsingPAX
	"Answer true if the receiver is using PAX mode. If a PAX file of the same name as the
	receiver exists on disk then both PAC and PAX files are saved simultaneously."

	^self isSystemPackage or: [File exists: self fileOutName]!

isUsingPAX: aBoolean
	"Place the receiver into a mode where it is using PAX source format according to aBoolean."

	self assert: [self isSystemPackage not].
	aBoolean 
		ifTrue: [ self beUsingPAX ]
		ifFalse: [ self beNotUsingPAX ]!

save
	"Save the receiver to a single PAC file. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the source files are also
	filed out, including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save' command."

	self isUsingPAX ifTrue: [self fileOutAll] ifFalse: [self saveSingleFilePackage].
	^true!

saveAs: aString 
	self manager renamePackage: self to: aString.
	self save!

saveChanges
	"Save the receiver, if changed. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the changed source files are
	also filed out. including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save Changes' command."

	self isChanged ifFalse: [^self].
	self isUsingPAX 
		ifTrue: 
			[self fileOutAllChanged.
			self isChanged: false]
		ifFalse: [self saveSingleFilePackage]!

savePAC
	"Private - File out a definition of the receiver and all the objects it owns to a single
	text .PAC file. Any binary objects (views, non-<sourceObject> globals) are saved as a
	printed representation of their STB'd binary store bytes."

	| filer |
	self okToSaveOrDeploy.
	self checkTimestamps.
	self createPackagePath.
	"This event can be hooked to backup the old package before it is overwritten, etc"
	self manager trigger: #aboutToSave: with: self.
	filer := self sourceManager sourceFilerOn: (FileStream write: self dotPacPath).
	[self fileOutAllOn: filer] ensure: [filer close]!

savePAX
	"Private - File out a definition of the receiver to a .PAX source file. This does not file
	out the source files of the receiver's contents."

	"Implementation Note: All fileouts use case sensitive collation in order to avoid problem of order
	switches for same named identifiers with different case, which can cause a line-based source
	management system to detect a change where there isn't one."

	| filer |
	self createPackagePath.
	filer := self sourceManager sourceFilerOn: (FileStream write: self fileOutName).
	[self fileOutOn: filer] ensure: [filer close].

	"We must also file out the binary globals at this stage, as they are not <sourceObject>s."
	self fileOutBinaryGlobals!

savePAXAboutBlockOn: stream 
	aboutBlock isNil ifTrue: [^self].
	stream nextPutAll: 'package aboutBlockBytes: '.
	aboutBlock binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXChunkOn: aSourceFiler 
	"Private - File out the receiver's package description stream in PAX source file format
	to the <puttableStream>, stream. This is in the form of a chunk which, when re-evaluated,
	creates an equivalent package description in a state which can be used for comparision
	or loading, etc. None of the code in the package, with the exception of the package scripts,
	is included. None of the code, including the package scripts, is evaluated."

	| stream |
	stream := String writeStream: 1024.
	self
		savePAXPackageOn: stream;
		savePAXPackageVersionOn: stream;
		savePAXAboutBlockOn: stream;
		savePAXStripperBytesOn: stream;
		savePAXScriptsOn: stream;
		savePAXNamesOn: stream;
		savePAXGlobalNamesOn: stream;
		savePAXPrerequisiteNamesOn: stream;
		savePAXManualPrerequisitesOn: stream;
		savePAXUntracedGlobalsOn: stream.

	"Finish off the stream by answering the package loaded"
	stream nextPutAll: 'package'.
	aSourceFiler fileOutExpression: stream contents!

savePAXGlobalNamesOn: target
	"Private - File out the PAX source file expressions to record the names of
	the non-source globals owned by the receiver."

	#(#binaryGlobalNames #globalAliases) do: 
			[:each | 
			target
				nextPutAll: 'package ';
				nextPutAll: each;
				nextPutAll: ': (Set new';
				cr.
			self savePAXNames: (self perform: each) on: target.
			target
				nextPutAll: ').';
				cr;
				cr]!

savePAXManualPrerequisitesOn: target 
	"Private - File out the names of any manually configured pre-requisite packages 
	of the receiver onto the <puttableStream>, target."

	| prereqs |
	prereqs := self manualPrerequisites.
	prereqs isEmpty ifTrue: [^self].
	target
		nextPutAll: 'package ';
		nextPutAll: #setManualPrerequisites:;
		nextPutAll: ' #('.
	manualPrerequisites do: 
			[:s | 
			target
				crtab;
				print: s].
	target
		nextPutAll: ').';
		cr;
		cr!

savePAXNames: names on: stream
	"Private - File out the PAX source file representation of the list of source object
	names, names, onto the <puttableStream>, stream, in ascending order of their
	printable representation."

	((names collect: [:each | each printString]) asSortedCollection: SortedCollection caseSensitiveSortBlock)
		do: [:eachName | stream tab; nextPutAll: 'add: '; nextPutAll: eachName; nextPut: $;; cr ].
	stream 
		tab; nextPutAll: 'yourself'!

savePAXNamesOn: target 
	"Private - File out the PAX source file representation of the class names, loose method 
	names, global names, resource names, onto the <puttableStream>, stream, in ascending 
	order of their printable representation."

	#(#classNames #methodNames #globalNames) do: 
			[:each | 
			| names |
			names := self perform: each.
			names notEmpty 
				ifTrue: 
					[target
						nextPutAll: 'package ';
						nextPutAll: each;
						cr.
					self savePAXNames: names on: target.
					target
						nextPut: $.;
						cr;
						cr]]!

savePAXPackageOn: aPuttableStream
	"Private - Save the basic details of the receiver in the PAX source file representation onto the <puttableStream> argument."

	"Create package and set some basic attributes"

	aPuttableStream
		nextPutAll: '| package |';
		cr;
		nextPutAll: 'package := ';
		print: self class;
		space;
		nextPutAll: #name:;
		space;
		print: self name;
		nextPut: $.;
		cr;
		nextPutAll: 'package ';
		nextPutAll: #paxVersion:;
		space;
		print: self paxVersion;
		nextPut: $;;
		crtab.
	preDeclareClassesOnLoad
		ifNotNil: 
			[aPuttableStream
				nextPutAll: #preDeclareClassesOnLoad:;
				space;
				print: preDeclareClassesOnLoad;
				nextPut: $;;
				crtab].
	aPuttableStream
		nextPutAll: #basicComment:;
		space;
		print: self comment;
		nextPut: $.;
		cr;
		cr!

savePAXPackageVersionOn: aStream 
	"Private - Save Package Version - this is the version of the package, not the file out format"

	packageVersion isNil ifTrue: [^self].
	aStream
		nextPutAll: 'package ';
		nextPutAll: #basicPackageVersion:;
		space;
		print: self packageVersion;
		nextPut: $.;
		cr;
		cr!

savePAXPrerequisiteNamesOn: target
	"Private - File out names of the pre-requisite packages of the receiver onto the onto 
	the <puttableStream>, target, in ascending order."

	| basePath |
	target
		nextPutAll: 'package ';
		nextPutAll: #setPrerequisites:;
		nextPutAll: ' #(';
		cr.
	basePath := self path.
	(self prerequisites asSortedCollection: [:a :b | (a name <==> b name) < 0]) do: 
			[:each |
			target
				tab;
				print: (File removeExtension: (File relativePathOf: each packageFileName to: basePath))]
		separatedBy: [target cr].
	target
		nextPutAll: ').';
		cr;
		cr!

savePAXScriptsOn: target
	"Private - File out the PAX source file representation of the receiver's scripts
	onto the <puttableStream>, target.
	Implementation Note: The scripts are installed using #basicScriptAt:put: to
	avoid the package being flagged as changed and the consequent transmission 
	of a change event."

	| scriptNames |
	scriptNames := self scripts keys.
	scriptNames isEmpty ifTrue: [^self].
	scriptNames asSortedCollection do: 
			[:each |
			target
				nextPutAll: 'package basicScriptAt: ';
				print: each;
				nextPutAll: ' put: ';
				print: (self scriptAt: each);
				nextPut: $.;
				cr].
	target cr!

savePAXStripperBytesOn: stream 
	"Private - File out the PAX source file representation of the receiver's 
	image stripper bytes (if any) onto the <puttableStream>, target."

	imageStripperBytes isNil ifTrue: [^self].
	stream nextPutAll: 'package imageStripperBytes: '.
	imageStripperBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXUntracedGlobalsOn: aWriteStream 
	| untraced |
	untraced := self untracedGlobals.
	untraced isEmpty ifTrue: [^self].
	aWriteStream
		nextPutAll: 'package ';
		display: #untracedGlobals:;
		nextPutAll: ' (Set new';
		cr.
	self savePAXNames: self untracedGlobals on: aWriteStream.
	aWriteStream
		nextPutAll: ').';
		cr;
		cr!

saveSingleFilePackage
	"Save the receiver and all owned objects to a single .PAC file.
	The complementary message to save a multi-file package is #fileOutAll."

	self savePAC.
	self updateTimestamp.
	self resetChangeFlags!

toggleUsingPAX
	"Toggles the use of PAX mode."

	^self isUsingPAX: self isUsingPAX not!

updateTimestamp
	"Private - Synchronise the receiver's timestamp with its source file."

	timestamp := self fileModificationTime! !

!Package categoriesForMethods!
allFileOutNames!accessing!private!source filing! !
beNotUsingPAX!modes!public! !
beUsingPAX!modes!public! !
canFileOut!public!source filing! !
checkTimestamps!helpers!private! !
createPackagePath!private!source filing! !
dotPacPath!helpers!private! !
fileModificationTime!helpers!private! !
fileOut!public!source filing! !
fileOutAll!public!source filing! !
fileOutAllChanged!public!source filing! !
fileOutAllOn:!public!source filing! !
fileOutBinaryGlobals!private!source filing! !
fileOutBinaryGlobalsOn:!private!source filing! !
fileOutBootDefinitions!development!private! !
fileOutClassDefinitionsOn:!private!source filing! !
fileOutClassesOn:!private!source filing! !
fileOutGlobalAliasesOn:!private!source filing! !
fileOutLooseMethodsOn:!private!source filing! !
fileOutMethodsOfClass:on:!private!source filing! !
fileOutNames!private!source filing! !
fileOutOn:!public!source filing! !
fileOutSourceGlobalsOn:!private!source filing! !
isRenegade!public!testing! !
isUsingPAX!public!testing! !
isUsingPAX:!public!testing! !
save!operations!public! !
saveAs:!commands!public! !
saveChanges!operations!public! !
savePAC!helpers!private! !
savePAX!private!source filing-pax! !
savePAXAboutBlockOn:!private!source filing-pax! !
savePAXChunkOn:!private!source filing-pax! !
savePAXGlobalNamesOn:!private!source filing-pax! !
savePAXManualPrerequisitesOn:!private!source filing-pax! !
savePAXNames:on:!private!source filing-pax! !
savePAXNamesOn:!private!source filing-pax! !
savePAXPackageOn:!private!source filing-pax! !
savePAXPackageVersionOn:!private!source filing-pax! !
savePAXPrerequisiteNamesOn:!private!source filing-pax! !
savePAXScriptsOn:!private!source filing-pax! !
savePAXStripperBytesOn:!private!source filing-pax! !
savePAXUntracedGlobalsOn:!public!source filing-pax! !
saveSingleFilePackage!public!source filing! !
toggleUsingPAX!commands!public! !
updateTimestamp!helpers!private! !
!

!PoolConstantsDictionary methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self! !

!PoolConstantsDictionary categoriesForMethods!
canFileOut!development!public!source filing! !
fileOut!development!public!source filing! !
fileOutOn:!development!public! !
!

!PoolDictionary methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self! !

!PoolDictionary categoriesForMethods!
canFileOut!development!public!source filing! !
fileOut!development!public!source filing! !
fileOutOn:!development!public! !
!

!SourceFiler methodsFor!

emitCategoriesForMethods: aSequenceableCollection of: aClass
	"Emit source that associates the <CompiledMethod>s in the <collection>, methods, with their current categories."
	
	
	aSequenceableCollection do: [:m | self emitCategoriesOfMethod: m]!

emitCategoriesOfClass: aClass 
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	^self subclassResponsibility!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append an entry to the source stream to reclassify the <CompiledMethod>, 
	aCompiledMethod, in all its current method categories."

	^self subclassResponsibility!

emitClassPoolOfClass: aClass
	"Private - Emit initialization expressions for each of the literal constants in the class pool of aClass."

	| literalConstants |
	literalConstants := aClass classPool associations
				select: [:each | each isImmutable and: [each value isLiteral]].
	literalConstants isEmpty ifTrue: [^self].
	literalConstants asSortedCollection
		do: [:each | self emitDeclarationForClass: aClass variable: each].
	self cr!

emitComment: aString 
	"Private - Record aString to the source stream.
	N.B. Logging requests should be directed through the SessionManager."

	^self subclassResponsibility!

emitCommentOfClass: aClass 
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to source stream."

	^self subclassResponsibility!

emitDeclarationForClass: aClass variable: each
	^self subclassResponsibility!

emitMessages: aClass ofBehavior: selectors 
	| methods sortedSelectors |
	sortedSelectors := selectors 
				asSortedCollection: SortedCollection caseSensitiveSortBlock.
	methods := sortedSelectors asArray collect: 
					[:selector | 
					| method |
					self
						cr;
						cr.
					method := aClass compiledMethodAt: selector.
					self emitMethod: method.
					method].
	^methods!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, to the source stream."

	^self subclassResponsibility!

emitSetBehaviorFlag: flagName forClass: aClass 
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	^self subclassResponsibility!

emitSpecialBehaviourAttributesOfClass: aClass
	"Private - Emit attributes for the <Class>, aClass, to define its special behaviour flags."

	#(#isIndirection #isNullTerminated)
		do: [:flagName | (aClass perform: flagName) ifTrue: [self emitSetBehaviorFlag: flagName forClass: aClass]].
	"We only emit the #isAbstract flag if the class has been explicitly marked non-instantiable, not just because it answers true to #isAbstract."
	aClass isNonInstantiable ifTrue: [self emitSetBehaviorFlag: #isAbstract forClass: aClass]!

fileOutAllMethodsOfBehavior: aClassDescription 
	"Emit definitions of all methods in the <ClassDescription> argument, aClassDescription,
	to the source stream."

	self fileOutMessages: aClassDescription selectors ofBehavior: aClassDescription.
	self isSourceOnly 
		ifFalse: [self fileOutProtocols: aClassDescription protocols ofBehavior: aClassDescription]!

fileOutAttributesOfClass: aClass
	"File-out any attributes of the aClass (e.g. the comment, GUID, etc) not included in the basic
	aClass definition, onto the source stream."

	self emitGUIDOfClass: aClass.
	self emitSpecialBehaviourAttributesOfClass: aClass.
	self emitClassPoolOfClass: aClass.
	self emitCommentOfClass: aClass.
	self emitCategoriesOfClass: aClass.
!

fileOutBasicDefinitionOfClass: aClass 
	"Print a definition of the <Class>, aClass, to the source stream."

	^self subclassResponsibility!

fileOutBinaryGlobal: anAssociation 
	"File out the text representation of the non-<sourceObject>
	which is the value of the <Association>, anAssociation, to the
	source stream. The key of the association is the global name."

	^self subclassResponsibility!

fileOutClass: aClass 
	"File out a full definition of the <ClassDescription>, aClass, to the source stream
	including all methods, categories and protocols. This includes all methods of the
	class, including any loose methods that may belong to packages other than the
	owning package of the class."

	self
		fileOutDefinitionOfClass: aClass;
		fileOutAllMethodsOfBehavior: aClass;
		fileOutAllMethodsOfBehavior: aClass class!

fileOutDefinitionOfClass: aClass 
	"File-out a definition of the <Class> to the source stream."

	self
		fileOutBasicDefinitionOfClass: aClass;
		fileOutAttributesOfClass: aClass!

fileOutExpression: aString
	"Append an immediate expression evaluation to the the source stream."

	^self subclassResponsibility!

fileOutMessages: selectors ofBehavior: aClass
	"Append the definitions of the methods of the <ClassDescription>, aClassDescription,
	whose names match the selectors in the <collection> of <Symbol>, aCollection, to the source 
	stream. Any method category settings are included."

	| methods |
	selectors isEmpty ifTrue: [^self].
	self emitHeaderForMethodsOf: aClass.
	methods := self emitMessages: aClass ofBehavior: selectors.
	self emitFooterForMethodsOf: aClass.
	self isSourceOnly ifFalse: [self emitCategoriesForMethods: methods of: aClass].
	self cr!

fileOutMethods: aCollection 
	"Append the definitions of the methods in the <collection> argument to the source stream,
	ordered by class. Any method category settings are included."

	| methodsByClass |
	methodsByClass := Dictionary new.
	aCollection do: 
			[:each | 
			"Note that the selectors will be filed out in sorted order, so we don't need to sort them"
			(methodsByClass at: each methodClass ifAbsentPut: [OrderedCollection new]) add: each selector].
	(methodsByClass associations 
		asSortedCollection: [:a :b | (a key name <==> b key name) <= 0]) 
			do: [:each | self fileOutMessages: each value ofBehavior: each key]!

fileOutPoolDictionary: aPoolDictionary 
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the source stream. The definition should be sufficient to recreate a copy  of the dictionary."

	^self subclassResponsibility!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to the source stream,
	associating them with the <ClassDescription>, aClassDescription."

	^self subclassResponsibility!

fileOutResource: aResourceIdentifier 
	"Append a definition of the resource identified by the <ResourceIdentifier>, aResourceIdentifer,
	to the source stream. The definition should be sufficient to recreate a copy  of the resource."

	^self subclassResponsibility!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	^self subclassResponsibility!

storeCommentString: aString forPackage: aPackage
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	^self subclassResponsibility! !

!SourceFiler categoriesForMethods!
emitCategoriesForMethods:of:!private!source filing! !
emitCategoriesOfClass:!private!source filing! !
emitCategoriesOfMethod:!private!source filing! !
emitClassPoolOfClass:!private!source filing! !
emitComment:!operations-logging!private! !
emitCommentOfClass:!private!source filing! !
emitDeclarationForClass:variable:!private!source filing! !
emitMessages:ofBehavior:!private!source filing! !
emitMethod:!private!source filing! !
emitSetBehaviorFlag:forClass:!private!source filing! !
emitSpecialBehaviourAttributesOfClass:!private!source filing! !
fileOutAllMethodsOfBehavior:!public!source filing! !
fileOutAttributesOfClass:!public!source filing! !
fileOutBasicDefinitionOfClass:!public!source filing! !
fileOutBinaryGlobal:!public!source filing! !
fileOutClass:!public!source filing! !
fileOutDefinitionOfClass:!public!source filing! !
fileOutExpression:!public!source filing! !
fileOutMessages:ofBehavior:!public!source filing! !
fileOutMethods:!public!source filing! !
fileOutPoolDictionary:!public!source filing! !
fileOutProtocols:ofBehavior:!public!source filing! !
fileOutResource:!public!source filing! !
storeCommentString:forClass:!public!source filing! !
storeCommentString:forPackage:!public!source filing! !
!

!SourceManager methodsFor!

basicCompressSources: progress 
	"Private - Compresses the sources file reporting the progress to
	<monadicValuable>, progress."

	| totalClasses index tmpPath smlFile filer classes |
	index := 0.
	classes := self class environment allClasses.
	totalClasses := classes size.

	"Create temporary stream file"
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	smlFile := self sourcesFileName.
	filer := self sourceFilerOn: (FileStream write: tmpPath).
	filer
		sourceFileIndex: SourcesIndex;
		isSourceOnly: true.
	self logComment: 'Compressing sources....' to: filer.
	index := 0.
	classes do: 
			[:class | 
			filer storeCommentString: class comment forClass: class.
			filer fileOutAllMethodsOfBehavior: class class.
			filer fileOutAllMethodsOfBehavior: class.
			progress value: (index := index + 1) * 100 / totalClasses].
	self compressPackageCommentsOn: filer.
	filer close.

	"Copy temporary file over to dolphin.sml"
	self closeSourcesFile.
	File
		delete: smlFile;
		rename: tmpPath to: smlFile.
	self openSourcesFile: smlFile.

	"Save image"
	SessionManager current saveImage.

	"Clear down change log"
	self truncateChanges.
	self logComment: 'Compressed sources'!

compressChangedMethodsOf: aBehavior onto: aSourceFiler 
	"Private - Emits the changed methods of aBehavior onto aSourceFiler."

	| changed |
	changed := aBehavior changedMethods collect: [:each | each selector].
	aSourceFiler fileOutMessages: changed ofBehavior: aBehavior!

compressChanges
	"Compresses the change log to remove duplicate entries, and save the image to keep it in sync."

	| tmpPath filer |
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	filer := self chunkFilerOn: (FileStream write: tmpPath).
	filer sourceFileIndex: ChangesIndex.
	mutex critical: 
			[self compressChangesOnto: filer.
			filer close.
			self openNewChangesFile: tmpPath].
	self logComment: 'Compressed changes'.

	"Save image"
	SessionManager current saveImage!

compressChangesOf: aClass onto: aSourceFiler 
	"Private - Compress any changes to the specified class onto the <SourceFiler>."

	"First the comment ..."

	(self sourceIndexFromDescriptor: aClass sourceDescriptor) = ChangesIndex 
		ifTrue: [aSourceFiler storeCommentString: aClass comment forClass: aClass].
	"...then the methods..."
	self
		compressChangedMethodsOf: aClass class onto: aSourceFiler;
		compressChangedMethodsOf: aClass onto: aSourceFiler.
	"Have to reset the changes index so that all changed methods are included since we have lost
	the save point"
	aClass isChanged 
		ifTrue: 
			["Note that it is necessary to remove the existing change index first since
			 attempts after the first to set it are ignored"
			aClass
				isChanged: false;
				changeIndexValue: [0]]!

compressChangesOnto: aSourceFiler 
	self class environment allClasses do: [:each | self compressChangesOf: each onto: aSourceFiler].
	Package manager packages do: 
			[:each | 
			(self sourceIndexFromDescriptor: each sourceDescriptor) = ChangesIndex 
				ifTrue: [aSourceFiler storeCommentString: each comment forPackage: each]]!

compressPackageCommentsOn: aSourceFiler 
	Package manager packages do: 
			[:each | 
			| comment |
			comment := each comment.
			comment isEmpty 
				ifTrue: [each sourceDescriptor: nil]
				ifFalse: [aSourceFiler storeCommentString: comment forPackage: each]]!

compressSources
	"Compresses the change log into the sources file. The result is a new empty changes log.
	The image must be saved to keep it in sync."

	self basicCompressSources: [:x | ]

!

compressSourcesWith: aProgressDialog
	"Compresses the change log into the sources file. The result is a new empty changes log.
	During the operation the progress is indicated by aProgressDialog."

	aProgressDialog operation: [:progress | self basicCompressSources: progress ].
	aProgressDialog showModal.
!

copyAndReopenSources: aString 
	"Private - Copy sources to the path and root file name (i.e. without extension) specified
	by the <readableString> argument, and then open the copies for any further perusal and 
	modification.

	Take a special interest if we do not currently have the source files available.
	This will be the case when we load from a .exe. In this case we generate some
	suitable empty source files. We also have to mark methods so that they know
	they have lost any reference to information in a .sml file."

	| hadSources |
	hadSources := self hasSources.

	"Copy and and swap over sources. Take care to end up with a good sources and imagePath"
	hadSources 
		ifTrue: 
			[self copySourceFilesTo: aString.
			self closeSources].
	hadSources 
		ifFalse: 
			[self createSources: aString.
			"We have permanently lost access to any source information so mark all methods"
			self class environment 
				allBehaviorsDo: [:aBehavior | aBehavior methodDictionary do: [:aMethod | aMethod loseSource]]].
	self openSources: aString!

createSources: filePath
	"Private - This will create a sources and changes file for the current image. Does not
	update the receiver to use these new files though."

	self createSourcesFile: filePath.
	(File open: (self changesFileNameFromPath: filePath) mode: #truncate check: false) close!

createSourcesFile: filePath 
	"Private - Create (or truncate) a source file with the specified path (and default extension)."

	(self newSourceFiler: (self sourcesFileNameFromPath: filePath)) close!

emitFileOutHeaderOn: aSourceFiler 
	"Private - Append the standard Dolphin file out header to the
	<puttableStream>, aWriteStream."

	aSourceFiler
		emitComment: 'Filed out from Dolphin Smalltalk';
		cr!

fileOut: anObject
	"File out anObject to its default file. If an error occurs during file out, the file
	will be closed by finalization."

	self fileOut: anObject to: anObject fileOutName.!

fileOut: anObject to: aFileName 
	"File out anObject to aFileName. If an error occurs during file out, the file
	will be closed by finalization."

	| filer |
	filer := self newSourceFiler: aFileName.
	anObject fileOutOn: filer.
	filer close!

fileOutPackagedClass: aClass
	"File out aClass via the package mechanism. The class is filed out to the same directory as the
	package which contains it. Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	self fileOutPackagedClass: aClass to: aClass fileOutName.
	!

fileOutPackagedClass: aClass to: aFileName 
	"File out aClass via the package mechanism. The class is filed out to aFileName.
	Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	| package filer |
	package := self packageManager packageOfClass: aClass.
	package isNil 
		ifTrue: 
			["Not in any package so just file out normally"
			^self fileOut: aClass to: aFileName].
	filer := self newSourceFiler: aFileName.
	filer fileOutDefinitionOfClass: aClass.
	package fileOutMethodsOfClass: aClass on: filer.
	package fileOutMethodsOfClass: aClass class on: filer.
	filer close.

	"Flag the class as being saved, i.e. no longer changed"
	aClass isChanged: false!

logChanged: aSourceObject
	"File out the changed <sourceObject>, aSourceObject, to the change log."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[aSourceObject fileOutOn: logger.
					logger flush]]!

logComment: aString
	"Record aString to the change log as a comment. All comments
	logged are prefixed with a timestamp.
	N.B. Logging requests should be directed through the SessionManager."

	self changesFiler 
		ifNotNil: [:logger | self logComment: aString to: logger]!

logComment: aString to: aSourceFiler
	"Private - Record aString to the specified source file as a comment. All comments
	logged are prefixed with a timestamp."

	| timestamp stampedComment |
	timestamp := DateAndTime now.
	stampedComment := String writeStream: 25 + aString size.
	#todo. "Use the standard form for a DateAndTime here - Ian's chunk browser relies on the original format, so that needs to be fixed."
	Locale invariant printDateTime: timestamp on: stampedComment format: 'HH:mm:ss, dd MMMM yyyy'.
	stampedComment nextPutAll: ': '; nextPutAll: aString.
	stampedComment := stampedComment contents.
	mutex critical: 
			[aSourceFiler
				emitComment: stampedComment;
				cr]!

newSourceFiler: path
	"Private - Answer a new <SourceFiler> on the specified path with the default
	format. Any existing file with at the specified path is truncated."

	| answer dir |
	dir := File splitPathFrom: path.
	(File isDirectory: dir) ifFalse: [File createDirectoryPath: dir].
	answer := self sourceFilerOn: (FileStream write: path).
	self emitFileOutHeaderOn: answer.
	^answer!

storeCategoriesForClass: class
	"Private - Store the categories of the <ClassDescription>, class, to
	the change log so that they may be reloaded later."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[logger
						emitCategoriesOfClass: class;
						flush]]!

storeCategoriesForMethod: method
	"Private - Store the categories of the <CompiledMethod>, method, to the change
	log so that they may be reloaded later."

	self changesFiler ifNotNil: 
			[:logger | 
			mutex critical: 
					[logger
						emitCategoriesOfMethod: method;
						cr;
						flush]]! !

!SourceManager categoriesForMethods!
basicCompressSources:!operations-source files!private! !
compressChangedMethodsOf:onto:!operations-source files!private! !
compressChanges!operations-source files!public! !
compressChangesOf:onto:!operations-source files!private! !
compressChangesOnto:!operations-source files!public! !
compressPackageCommentsOn:!operations-source files!private! !
compressSources!operations-source files!public! !
compressSourcesWith:!operations-source files!public! !
copyAndReopenSources:!operations-source files!private! !
createSources:!operations-source files!private! !
createSourcesFile:!operations-source files!private! !
emitFileOutHeaderOn:!private!source filing! !
fileOut:!public!source filing! !
fileOut:to:!public!source filing! !
fileOutPackagedClass:!public!source filing! !
fileOutPackagedClass:to:!public!source filing! !
logChanged:!public!source filing! !
logComment:!operations-logging!public! !
logComment:to:!operations-logging!private! !
newSourceFiler:!private!source filing! !
storeCategoriesForClass:!private!source filing! !
storeCategoriesForMethod:!private!source filing! !
!

"End of package definition"!

