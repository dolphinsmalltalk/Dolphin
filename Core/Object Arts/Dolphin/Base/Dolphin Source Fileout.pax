| package |
package := Package name: 'Dolphin Source Fileout'.
package paxVersion: 2;
	preDeclareClassesOnLoad: false;
	basicComment: ''.

package basicScriptAt: #postinstall put: '(MethodProtocol name: #sourceObject)
	addAllSelectors: #(#canFileOut #fileOut #fileOutName #isChanged #isChanged: #owningPackage);
	addClass: Class;
	addClass: Package;
	addClass: PoolDictionary;
	addClass: PoolConstantsDictionary'.

package setMethodNames: #(
	#(#{BootSessionManager} #saveImageTo:)
	#(#{ChunkSourceFiler} #emitCategories:for:in:)
	#(#{ChunkSourceFiler} #emitCategoriesOfClass:)
	#(#{ChunkSourceFiler} #emitCategoriesOfMethod:)
	#(#{ChunkSourceFiler} #emitComment:)
	#(#{ChunkSourceFiler} #emitCommentOfClass:)
	#(#{ChunkSourceFiler} #emitDeclarationForClass:variable:)
	#(#{ChunkSourceFiler} #emitMethod:)
	#(#{ChunkSourceFiler} #emitSetBehaviorFlag:forClass:)
	#(#{ChunkSourceFiler} #fileOutBasicDefinitionOfClass:)
	#(#{ChunkSourceFiler} #fileOutBinaryVariable:)
	#(#{ChunkSourceFiler} #fileOutPoolDictionary:)
	#(#{ChunkSourceFiler} #fileOutProtocols:ofBehavior:)
	#(#{ChunkSourceFiler} #logEvaluation:)
	#(#{ChunkSourceFiler} #storeCommentString:forClass:)
	#(#{ChunkSourceFiler} #storeCommentString:forPackage:)
	#(#{ChunkSourceFiler} #storeSource:for:)
	#(#{Class} #canFileOut)
	#(#{Class} #definitionChunk)
	#(#{Class} #fileOut)
	#(#{Class} #fileOutOn:)
	#(#{Class} #storeClassCategories)
	#(#{CompiledMethod} #storeCategories)
	#(#{Metaclass} #storeClassCategories)
	#(#{Package} #allFileOutNames)
	#(#{Package} #beNotUsingPAX)
	#(#{Package} #beUsingPAX)
	#(#{Package} #canFileOut)
	#(#{Package} #checkTimestamps)
	#(#{Package} #createPackagePath)
	#(#{Package} #dotPacPath)
	#(#{Package} #fileModificationTime)
	#(#{Package} #fileOut)
	#(#{Package} #fileOutAll)
	#(#{Package} #fileOutAllChanged)
	#(#{Package} #fileOutAllOn:)
	#(#{Package} #fileOutBinaryVariableNamesOn:)
	#(#{Package} #fileOutBinaryVariables)
	#(#{Package} #fileOutBootDefinitions)
	#(#{Package} #fileOutClassDefinitionsOn:)
	#(#{Package} #fileOutClassesOn:)
	#(#{Package} #fileOutLooseMethodsOn:)
	#(#{Package} #fileOutMethodsOfClass:on:)
	#(#{Package} #fileOutNames)
	#(#{Package} #fileOutOn:)
	#(#{Package} #fileOutSourceVariableNamesOn:)
	#(#{Package} #fileOutVariableAliasesOn:)
	#(#{Package} #isRenegade)
	#(#{Package} #isUsingPAX)
	#(#{Package} #isUsingPAX:)
	#(#{Package} #save)
	#(#{Package} #saveAs:)
	#(#{Package} #saveChanges)
	#(#{Package} #savePAC)
	#(#{Package} #savePAX)
	#(#{Package} #savePAXAboutBlockOn:)
	#(#{Package} #savePAXChunkOn:)
	#(#{Package} #savePAXCollection:initializer:on:)
	#(#{Package} #savePAXManualPrerequisitesOn:)
	#(#{Package} #savePAXNames:initializer:on:)
	#(#{Package} #savePAXNamesOn:)
	#(#{Package} #savePAXPackageOn:)
	#(#{Package} #savePAXPackageVersionOn:)
	#(#{Package} #savePAXPrerequisiteNamesOn:)
	#(#{Package} #savePAXScriptsOn:)
	#(#{Package} #savePAXStripperBytesOn:)
	#(#{Package} #savePAXUntracedVariablesOn:)
	#(#{Package} #savePAXVariableNamesOn:)
	#(#{Package} #saveSingleFilePackage)
	#(#{Package} #toggleUsingPAX)
	#(#{Package} #updateTimestamp)
	#(#{PoolConstantsDictionary} #canFileOut)
	#(#{PoolConstantsDictionary} #fileOut)
	#(#{PoolConstantsDictionary} #fileOutOn:)
	#(#{PoolDictionary} #canFileOut)
	#(#{PoolDictionary} #fileOut)
	#(#{PoolDictionary} #fileOutOn:)
	#(#{SourceFiler} #emitCategoriesOfClass:)
	#(#{SourceFiler} #emitCategoriesOfMethod:)
	#(#{SourceFiler} #emitCategoriesOfMethods:)
	#(#{SourceFiler} #emitClassPoolOfClass:)
	#(#{SourceFiler} #emitComment:)
	#(#{SourceFiler} #emitCommentOfClass:)
	#(#{SourceFiler} #emitDeclarationForClass:variable:)
	#(#{SourceFiler} #emitMessages:ofBehavior:)
	#(#{SourceFiler} #emitMethod:)
	#(#{SourceFiler} #emitSetBehaviorFlag:forClass:)
	#(#{SourceFiler} #emitSpecialBehaviourAttributesOfClass:)
	#(#{SourceFiler} #fileOutAllMethodsOfBehavior:)
	#(#{SourceFiler} #fileOutAttributesOfClass:)
	#(#{SourceFiler} #fileOutBasicDefinitionOfClass:)
	#(#{SourceFiler} #fileOutBinaryVariable:)
	#(#{SourceFiler} #fileOutClass:)
	#(#{SourceFiler} #fileOutDefinitionOfClass:)
	#(#{SourceFiler} #fileOutExpression:)
	#(#{SourceFiler} #fileOutMessages:ofBehavior:)
	#(#{SourceFiler} #fileOutMethods:)
	#(#{SourceFiler} #fileOutPoolDictionary:)
	#(#{SourceFiler} #fileOutProtocols:ofBehavior:)
	#(#{SourceFiler} #fileOutResource:)
	#(#{SourceFiler} #storeCommentString:forClass:)
	#(#{SourceFiler} #storeCommentString:forPackage:)
	#(#{SourceManager} #basicCompressSources:)
	#(#{SourceManager} #compressChangedMethodsOf:onto:)
	#(#{SourceManager} #compressChanges)
	#(#{SourceManager} #compressChangesOf:onto:)
	#(#{SourceManager} #compressChangesOnto:)
	#(#{SourceManager} #compressPackageCommentsOn:)
	#(#{SourceManager} #compressSources)
	#(#{SourceManager} #compressSourcesWith:)
	#(#{SourceManager} #copyAndReopenSources:)
	#(#{SourceManager} #createSources:)
	#(#{SourceManager} #createSourcesFile:)
	#(#{SourceManager} #emitFileOutHeaderOn:)
	#(#{SourceManager} #fileOut:)
	#(#{SourceManager} #fileOut:to:)
	#(#{SourceManager} #fileOutPackagedClass:)
	#(#{SourceManager} #fileOutPackagedClass:to:)
	#(#{SourceManager} #logChanged:)
	#(#{SourceManager} #logComment:)
	#(#{SourceManager} #logComment:to:)
	#(#{SourceManager} #newSourceFiler:)
	#(#{SourceManager} #storeCategoriesForClass:)
	#(#{SourceManager} #storeCategoriesForMethod:)
).

package setPrerequisites: #(
	'Dolphin'
	'..\System\Base64\Dolphin Base64'
	'Dolphin Message Box'
).

package setManualPrerequisites: #(
	'Dolphin Base64'
).

package!

"Loose Methods"!

!BootSessionManager methodsFor!

saveImageTo: aString 
	"Private - Snapshot to filePath.img, marking the log with a timestamp and copying sources
	files. N.B. Use the public entry point #saveImage: to save an image to a new path.

	Take a special interest if we do not currently have the source files available. This will be
	the case when we load from a .exe. In this case we generate some suitable empty source
	files. We also have to mark methods so that they know they have lost any reference to
	information in a .sml file."

	| oldImagePath oldSentry |
	oldImagePath := self imagePath.
	oldSentry := sentry.

	"Now save image and swap over sources. Take care to end up with a good sources and imagePath"
	
	[self imagePath: aString.
	self createSentinel 
		ifTrue: 
			[| mb |
			mb := MessageBox new.
			mb beTaskModal.
			mb 
				errorMsg: ('The image <1p> is open in another Dolphin instance.<n><n>Close that instance and try again should you still wish to save this image to that name.<n><n>The image has not been saved!!' 
						expandMacrosWith: self imageFileName).
			^self].
	self class sourceManager copyAndReopenSources: self imagePath.
	self
		snapshot: self imageFileName;
		logComment: ('Image saved to <1p>' expandMacrosWith: aString).
	KernelLibrary default closeHandle: oldSentry] 
			ifCurtailed: 
				["Attempt to return to the old state so sources & stuff are intact
				 before showing the user the problem."
				
				[KernelLibrary default closeHandle: sentry.
				sentry := oldSentry.
				self
					imagePath: oldImagePath;
					openSources] 
						on: Error
						do: [:anError | anError resignalAsWarning]]! !
!BootSessionManager categoriesFor: #saveImageTo:!operations-saving!private! !

!ChunkSourceFiler methodsFor!

emitCategories: aCollection for: aSymbol in: aClass 
	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesFor:;
		space.
	"#2144."
	self emitString: aSymbol printString.
	stream nextPut: $!!.
	aCollection asSortedCollection do: [:each | self nextChunkPut: each name].
	self endChunk!

emitCategoriesOfClass: aClass
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	| categories |
	categories := aClass categories.
	categories notEmpty ifFalse: [^self].
	stream
		nextPut: $!!;
		nextPutAll: aClass name;
		space;
		nextPutAll: #categoriesForClass;
		nextPut: $!!.
	categories asSortedCollection do: [:aCategory | self nextChunkPut: aCategory name].
	self endChunk!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append a chunk to the <puttableStream>, aWriteStream,
	to reclassify the <CompiledMethod>, aCompiledMethod, in all its current 
	method categories."

	self 
		emitCategories: aCompiledMethod realCategories
		for: aCompiledMethod selector
		in: aCompiledMethod methodClass!

emitComment: aString
	"Private - Record aString to the chunk stream as a comment. All comments logged are prefixed
	with a timestamp. N.B. Logging requests should be directed through the SessionManager."

	stream nextPut: $".
	self emitString: aString.
	stream
		nextPut: $";
		nextPut: $!!;
		cr;
		flush!

emitCommentOfClass: aClass
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to the <puttableStream>
	aWriteStream."

	stream
		nextPutAll: aClass name;
		space;
		display: #comment:;
		space.
	self
		nextChunkPut: aClass comment printString;
		cr!

emitDeclarationForClass: aClass variable: anAssociation
	| value |
	stream
		nextPutAll: aClass name;
		nextPutAll: (anAssociation isImmutable
					ifTrue: [' addClassConstant: ']
					ifFalse: [' addClassVariable: ']);
		print: anAssociation key;
		nextPutAll: ' value: '.
	value := anAssociation value.
	self
		nextChunkPut: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value storeString]).
	stream cr!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, 
	to the source stream, updating the method's source descriptor if configured with a 
	source file index."

	self storeSource: aCompiledMethod getSource for: aCompiledMethod!

emitSetBehaviorFlag: flagName forClass: aClass 
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	stream
		print: aClass;
		space;
		nextPutAll: flagName;
		nextPutAll: ': true!!';
		cr!

fileOutBasicDefinitionOfClass: aClass 
	"Print a definition of the <Class>, aClass, onto the <puttableStream>, aWriteStream."

	aClass printDefinitionOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutBinaryVariable: aBindingReference
	"File out the text representation of the non-<sourceObject> which is the target of the
	<BindingReference> argument onto the receiver's source stream."

	| value |
	value := aBindingReference value.
	(value class isMeta and: [aBindingReference pathString ~= value fullName])
		ifTrue: 
			[stream
				display: aBindingReference pathString;
				nextPutAll: ' := ';
				print: value;
				nextPut: $!!;
				cr.
			^self].
	stream
		display: aBindingReference;
		nextPutAll: ' := ';
		print: Object;
		space;
		display: #fromBinaryStoreBytes:;
		space;
		cr.
	value binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $!!;
		cr!

fileOutPoolDictionary: aPoolDictionary
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the <puttableStream>, aWriteStream. The definition should be sufficient to recreate a
	copy of the dictionary."

	| poolName |
	poolName := aPoolDictionary fullyQualifiedReference.
	stream
		print: poolName;
		space;
		display: #declare:;
		nextPutAll: ' (';
		nextPutAll: aPoolDictionary class name;
		nextPutAll: ' named: ';
		print: aPoolDictionary name.
	self emitChunk: ')'.
	aPoolDictionary associations asSortedCollection do: 
			[:a |
			| value |
			stream
				print: poolName;
				nextPutAll: ' at: ';
				print: a key;
				nextPutAll: ' put: '.
			value := a value.
			value isLiteral
				ifTrue: 
					[self emitChunk: (value isInteger ifTrue: [value printStringRadix: 16] ifFalse: [value printString])]
				ifFalse: 
					[stream
						nextPut: $(;
						print: Object;
						space;
						display: #fromBinaryStoreBytes:;
						space;
						cr.
					value binaryStoreBytes base64StoreOn: stream.
					self emitChunk: ')']].
	self emitChunk: poolName asString, ' shrink'!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to source stream,
	associating them with the <ClassDescription>, aClassDescription."

	aCollection isEmpty ifTrue: [^self].
	(aCollection asSortedCollection: [:a :b | (a name <==> b name) <= 0]) do: 
			[:p | 
			stream
				nextPutAll: aClassDescription name;
				nextPutAll: ' methodProtocol: ';
				print: p asSymbol;
				nextPutAll: ' attributes: ';
				print: p attributes asArray;
				nextPutAll: ' selectors: #('.
			"We must print the selectors individually as their may be very many and the default print truncates after
			 a certain number of characters."
			p selectors asSortedCollection do: [:s | stream print: s] separatedBy: [stream space].
			self
				nextChunkPut: ')';
				cr].
	self cr!

logEvaluation: aString
	"Private - Log an immediate expression evaluation to the the source stream."

	stream nextPutAll: '"Evaluate"'; cr.
	self fileOutExpression: aString!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	stream nextPutAll: aClass name; nextPutAll: ' comment:'; cr.
	self storeSource: aString printString for: aClass.
	stream cr!

storeCommentString: aString forPackage: aPackage 
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	stream
		nextPut: $(;
		print: aPackage class;
		space;
		nextPutAll: #manager;
		space;
		nextPutAll: #packageNamed:;
		space;
		print: aPackage name;
		nextPutAll: ') ';
		nextPutAll: #comment:;
		cr.
	self storeSource: aString printString for: aPackage.
	stream cr!

storeSource: aString for: aSourceObject 
	"Private - Store the <readableString>, aString, as the source text for the <sourceObject>,
	aSourceObject. If the receiver has been associated with a source file (i.e. the
	sourceFileIndex is set) then update aSourceObject's source descriptor so that in future it
	retrieves the source text from the receiver's source stream."

	| position |
	position := stream position.
	self nextChunkPut: aString.
	sourceFileIndex notNil 
		ifTrue: 
			[aSourceObject sourceDescriptor: (aString isEmpty ifFalse: [self sourceDescriptorForIndex: sourceFileIndex position: position])]! !
!ChunkSourceFiler categoriesFor: #emitCategories:for:in:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitCategoriesOfClass:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitCategoriesOfMethod:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitComment:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitCommentOfClass:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitDeclarationForClass:variable:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitMethod:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #emitSetBehaviorFlag:forClass:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #fileOutBasicDefinitionOfClass:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #fileOutBinaryVariable:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #fileOutPoolDictionary:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #fileOutProtocols:ofBehavior:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #logEvaluation:!private!source filing-file out! !
!ChunkSourceFiler categoriesFor: #storeCommentString:forClass:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #storeCommentString:forPackage:!public!source filing-file out! !
!ChunkSourceFiler categoriesFor: #storeSource:for:!private!source filing-file out! !

!Class methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

definitionChunk
	"Answer a chunk string for the definition of the receiver"

	| stream |
	stream := String writeStream: 256.
	(self sourceManager sourceFilerOn: stream) fileOutDefinitionOfClass: self.
	^stream contents!

fileOut
	"File out the receiver's definition to a class file in the receiver's
	package directory."

	self sourceManager fileOutPackagedClass: self!

fileOutOn: aSourceFiler
	aSourceFiler fileOutClass: self!

storeClassCategories
	"Private - Record the categories of the receiver to the change log.
	The job is simply delegated to the receiver's source manager (if available)."

	self sourceManager storeCategoriesForClass: self! !
!Class categoriesFor: #canFileOut!public!source filing! !
!Class categoriesFor: #definitionChunk!public!source filing-class definition! !
!Class categoriesFor: #fileOut!public!source filing! !
!Class categoriesFor: #fileOutOn:!public!source filing! !
!Class categoriesFor: #storeClassCategories!private!source filing-methods! !

!CompiledMethod methodsFor!

storeCategories
	"Private - Record the categories of the receiver.
	The job is simply delegated to the receiver's source manager."

	self class sourceManager storeCategoriesForMethod: self.! !
!CompiledMethod categoriesFor: #storeCategories!private!source filing-methods! !

!Metaclass methodsFor!

storeClassCategories
	"Private - Record the categories of the receiver to the change log.
	The job is simply delegated to the receiver's source manager (if available)."

	self instanceClass storeClassCategories! !
!Metaclass categoriesFor: #storeClassCategories!private!source filing-methods! !

!Package methodsFor!

allFileOutNames
	"Private - Answers an OrderedCollection of the source filenames for the receiver and all of its 
	contents when in PAX source mode. Note that the PAX filename is alway last in the collection."

	| answer |
	answer := OrderedCollection new.
	self allSourceObjectsDo: [:each | answer add: each fileOutName].
	^answer!

beNotUsingPAX
	"Place the receiver into a mode where it is not using PAX source files.
	This simply involves deleting any PAX source files that currently exist. Without the
	presence of a same named PAX file, the receiver assumes it is operating in
	non-PAX mode for all future save operations."

	| msg names |
	self isUsingPAX ifFalse: [^self].
	names := self allFileOutNames.
	msg := 'Placing this package into PAC mode will delete <2d> PAX source files in the<n>directory <3s>.<n><n>Are you sure that you wish to proceed?'
				expandMacrosWith: self name
				with: names size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAC mode...' expandMacrosWith: self name))
		ifTrue: [names do: [:each | (File exists: each) ifTrue: [File delete: each]]]!

beUsingPAX
	"Place the receiver into a mode where it is using PAX source files.
	This simply involves creating the PAX source files for the first time. With the
	presence of a same named PAX file, the receiver assumes it is operating in
	PAX mode for all future save operations."

	| msg |
	self isUsingPAX ifTrue: [^self].
	msg := 'Placing this package into PAX source mode will create <1d> source files<n>in the directory <2s>.<n><n>Are you sure that you wish to proceed?' 
				expandMacrosWith: self allSourceObjects size
				with: self path.
	(MessageBox confirm: msg caption: ('Convert <1p> to PAX mode...' expandMacrosWith: self name)) 
		ifTrue: [self fileOutAll]!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	all the file out names associated with the PAX file are writeable."

	^self fileOutNames allSatisfy: [:each | File isWriteable: each]!

checkTimestamps
	"Compare the timestamp cached when the package was installed against the timestamp of the
	package file. If the package file has been modified since the package was loaded, then warn
	the user to avoid inadvertent overwrites of later package versions causing loss of changes."

	| mb warning |
	(CheckTimestamps and: [self isRenegade]) ifFalse: [^self].
	mb := MessageBox new.
	mb
		uniqueId: [self] method displayString;
		isSuppressible: true.
	warning := ('The package <1s> has been modified outside this image since it was loaded or last saved.

	Package timestamp:	 <2s>
	File modification time: <3s>

If you proceed and save it from this image then you may lose changes that have been written from another session. If you are not sure it is recommended that you cancel this operation and check whether there are unstaged changes in your workspace with your preferred git tooling. 

Alternatively you can proceed and overwrite any changes on disk. You can also choose to suppress this warning so it is not shown again, however if you do so then in future modified files will be overwritten regardless of the choice that you make now.'
				expandMacrosWith: self name
				with: self timestamp displayString
				with: (FILETIME fromInteger: self fileModificationTime) displayString).
	mb okCancel.
	(mb warning: warning) == #cancel
		ifTrue: [OperationAborted signal]
!

createPackagePath
	"Private - Create the directory where the receiver resides on disk"

	File createDirectoryPath: (File splitPathFrom: self fileOutName)
!

dotPacPath
	^File path: self packageFileName extension: self class packageExtension!

fileModificationTime
	"Private - Answer the modification time of the receiver's package file on disk as the
	<integer> number of 100-nanosecond intervals since 12:00 A.M. January 1, 1601 UTC (i.e. a
	Win32 FILETIME), or 0 if it does not currently exist."

	| fileName |
	fileName := self isSystemPackage 
				ifTrue: [self classDefinitionsFileName]
				ifFalse: [self isUsingPAX ifTrue: [self fileOutName] ifFalse: [self packageFileName]].
	^(File lastWriteTime: fileName) ifNil: [0] ifNotNil: [:filetime | filetime asInteger]!

fileOut
	"Private - File out a definition of the receiver to source files. Normally this
	involves saving a PAX file except in the case where the receiver is a system package
	when separate class and resource definitions files are saved instead."

	self isSystemPackage 
		ifFalse: 
			[self
				savePAC;
				savePAX;
				versionIfRequired]
		ifTrue: [self fileOutBootDefinitions].
	self updateTimestamp.
	self isChanged: false!

fileOutAll
	"Fileout the receiver to a PAX file and all out it's associated source files.
	The .PAC file is also saved when the .PAX is created in order to ensure that
	the two remain in sync."

	self allSourceObjectsDo: [:each | each fileOut]!

fileOutAllChanged
	"Fileout the changed source objects in the receiver"

	self allSourceObjectsDo: [:each | each isChanged ifTrue: [each fileOut]]!

fileOutAllOn: aSourceFiler
	self fileOutOn: aSourceFiler.
	self
		fileOutSourceVariableNamesOn: aSourceFiler;
		fileOutClassesOn: aSourceFiler;
		fileOutBinaryVariableNamesOn: aSourceFiler!

fileOutBinaryVariableNamesOn: aSourceFiler
	"Private - File out the binary representation of the receiver's non-<sourceObject> variables onto the <SourceFiler> argument. Binary variables are saved as the literal representation of their #binaryStoreBytes.  This is used in the single-file .PAC format."

	aSourceFiler
		emitComment: 'Binary Variables';
		cr.
	self binaryVariableNames asSortedCollection do: 
			[:var |
			aSourceFiler
				fileOutBinaryVariable: var;
				cr]!

fileOutBinaryVariables
	"Private - File out binary variables to individual .STB files.
	This is used in the multi-file .PAX format to avoid binary merge conflicts in the
	main PAX."

	self binaryVariableNames - self aliasVariableNames do: 
			[:each |
			| stream |
			stream := FileStream write: (self fileNameForBinaryVariable: each) text: false.
			each value binaryStoreOn: stream.
			stream close]!

fileOutBootDefinitions
	"Private - If this is a system package then only write out .st files capable of defining
	the classes independently of the PAX. These are required by the Dolphin boot process.
	Note that the base system package cannot contain any resources."

	| filer |
	filer := ChunkSourceFiler 
				on: (FileStream write: self classDefinitionsFileName text: true).
	[self fileOutClassDefinitionsOn: filer] ensure: [filer close]!

fileOutClassDefinitionsOn: aSourceFiler
	"Private - Append the text definitions of the receivers owned classes to aFileStream.
	This should produce the minimal amount of information to create a new class when 
	loaded in (i.e. only the basic definitions are emitted)."

	| classes |
	classes := self classesInHierarchyOrder.
	classes isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Class Definitions';
		cr.
	classes do: [:aClass | aSourceFiler fileOutBasicDefinitionOfClass: aClass].
	aSourceFiler cr!

fileOutClassesOn: aSourceFiler
	"Private - Append definitions of all the classes owned by the receiver to the <SourceFiler>, aSourceFiler.
	Note that the classes are filed out in class hierarchy order to avoid creating forward references and to create a consistently ordered source file that can be effectively diff'd."

	| classes |
	classes := self classesInHierarchyOrder.
	classes isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Classes';
		cr.
	classes do: 
			[:aClass |
			aSourceFiler fileOutAttributesOfClass: aClass.
			self fileOutMethodsOfClass: aClass on: aSourceFiler.
			self fileOutMethodsOfClass: aClass class on: aSourceFiler]!

fileOutLooseMethodsOn: aSourceFiler
	"Private - File out the loose methods owned by the receiver to the <SourceFiler> argument."

	| loose |
	loose := self methods.
	loose isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Loose Methods';
		cr.
	aSourceFiler fileOutMethods: loose!

fileOutMethodsOfClass: aClass on: aSourceFiler 
	"Private - Append any definitions of the classes methods which
	are not owned by another package to the <puttableStream>, target."

	| methods |
	methods := self methodsOfClass: aClass.
	methods size = aClass methodDictionary size 
		ifTrue: 
			["The common case is that all methods of the class also belong to the this package..."

			aSourceFiler fileOutAllMethodsOfBehavior: aClass]
		ifFalse: 
			["...but if some methods are not owned by this package we have more work to do"

			| selectors prereqs addBlock |
			selectors := methods collect: [:m | m selector].
			aSourceFiler fileOutMessages: selectors ofBehavior: aClass.

			"File out the intersection of the immediate protocols of the class and those of this
			and prerequisite packages' methods"

			"First add all selectors in the superclass chain which are in this package or one of its
			pre-requisites into the set of available selectors."
			prereqs := self prerequisites.
			addBlock := 
					[:e :p | 
					selectors addAll: ((p methodsOfClass: e) collect: [:m | m selector])].
			prereqs do: [:p | addBlock value: aClass value: p].
			aClass allSuperclassesDo: 
					[:e | 
					addBlock value: e value: self.
					prereqs do: [:p | addBlock value: e value: p]].
			#todo.	"File out partial protocols, although tools should prevent protocols being split across packages really"
			aSourceFiler fileOutProtocols: (aClass protocols 
						select: [:p | (p selectors difference: selectors) isEmpty])
				ofBehavior: aClass]!

fileOutNames
	"Private - Answers a set of the source filenames for the receiver when in the multi-file
	(.PAX) source mode. This contains pathnames used to store the PAX file and each of the
	binary globals, etc. It does not include the source files for the	<sourceObject>s held by the 
	receiver."

	^self isSystemPackage
		ifTrue: [Set with: self classDefinitionsFileName]
		ifFalse: 
			[Set new
				add: self fileOutName;
				addAll: (self binaryVariableNames collect: [:each | self fileNameForBinaryVariable: each]);
				yourself]!

fileOutOn: aSourceFiler
	"Append the definition of the receiver in PAX format onto the
	<SourceFiler> argument. This does not file out the source files of the 
	receiver's contents."

	self savePAXChunkOn: aSourceFiler.
	self fileOutClassDefinitionsOn: aSourceFiler.
	self fileOutVariableAliasesOn: aSourceFiler.
	self fileOutLooseMethodsOn: aSourceFiler.
	aSourceFiler
		emitComment: 'End of package definition';
		cr!

fileOutSourceVariableNamesOn: aSourceFiler
	"Private - File out the text representation of the receiver's globals onto the
	<puttableStream>, stream. This is used in the single-file .PAC format."

	| names |
	names := self sourceVariableNames.
	names isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Source Variables';
		cr.
	names asSortedCollection do: 
			[:var |
			var value fileOutOn: aSourceFiler.
			aSourceFiler cr]!

fileOutVariableAliasesOn: aSourceFiler
	"Private - File out the text representation of the receiver's global aliases onto the
	<puttableStream>, stream."

	| names |
	names := self aliasVariableNames.
	names isEmpty ifTrue: [^self].
	aSourceFiler
		emitComment: 'Variable Aliases';
		cr.
	names asSortedCollection
		do: [:var | aSourceFiler fileOutExpression: var asString , ' := ' , var value fullName].
	aSourceFiler cr!

isRenegade
	"Answer whether the receiver was loaded (or last saved) before its source representation in the file system.
	An example of where a package might be a renegade is if it has been modified and saved from another image."

	| lastWriteTime |
	lastWriteTime := self fileModificationTime.
	^lastWriteTime > timestamp!

isUsingPAX
	"Answer true if the receiver is using PAX mode. If a PAX file of the same name as the
	receiver exists on disk then both PAC and PAX files are saved simultaneously."

	^self isSystemPackage or: [File exists: self fileOutName]!

isUsingPAX: aBoolean
	"Place the receiver into a mode where it is using PAX source format according to aBoolean."

	self assert: [self isSystemPackage not].
	aBoolean 
		ifTrue: [ self beUsingPAX ]
		ifFalse: [ self beNotUsingPAX ]!

save
	"Save the receiver to a single PAC file. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the source files are also
	filed out, including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save' command."

	self isUsingPAX ifTrue: [self fileOutAll] ifFalse: [self saveSingleFilePackage].
	^true!

saveAs: aString 
	self manager renamePackage: self to: aString.
	self save!

saveChanges
	"Save the receiver, if changed. This includes all of the source for the receiver's contents.
	If the receiver is operating in PAX source mode then all of the changed source files are
	also filed out. including a .PAX definition. Answer whether the package was actually saved.
	This is the implementation behind the Package Browser's 'Save Changes' command."

	self isChanged ifFalse: [^self].
	self isUsingPAX 
		ifTrue: 
			[self fileOutAllChanged.
			self isChanged: false]
		ifFalse: [self saveSingleFilePackage]!

savePAC
	"Private - File out a definition of the receiver and all the objects it owns to a single
	text .PAC file. Any binary objects (views, non-<sourceObject> globals) are saved as a
	printed representation of their STB'd binary store bytes."

	| filer |
	self okToSaveOrDeploy.
	self checkTimestamps.
	self createPackagePath.
	"This event can be hooked to backup the old package before it is overwritten, etc"
	self manager trigger: #aboutToSave: with: self.
	filer := self sourceManager sourceFilerOn: (FileStream write: self dotPacPath).
	[self fileOutAllOn: filer] ensure: [filer close]!

savePAX
	"Private - File out a definition of the receiver to a .PAX source file. This does not file
	out the source files of the receiver's contents."

	"Implementation Note: All fileouts use case sensitive collation in order to avoid problem of order
	switches for same named identifiers with different case, which can cause a line-based source
	management system to detect a change where there isn't one."

	| filer |
	self createPackagePath.
	filer := self sourceManager sourceFilerOn: (FileStream write: self fileOutName).
	[self fileOutOn: filer] ensure: [filer close].

	"We must also file out the binary globals at this stage, as they are not <sourceObject>s."
	self fileOutBinaryVariables!

savePAXAboutBlockOn: stream 
	aboutBlock isNil ifTrue: [^self].
	stream nextPutAll: 'package aboutBlockBytes: '.
	aboutBlock binaryStoreBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXChunkOn: aSourceFiler
	"Private - File out the receiver's package description stream in PAX source file format
	to the <puttableStream>, stream. This is in the form of a chunk which, when re-evaluated,
	creates an equivalent package description in a state which can be used for comparision
	or loading, etc. None of the code in the package, with the exception of the package scripts,
	is included. None of the code, including the package scripts, is evaluated."

	| stream |
	stream := String writeStream: 1024.
	self
		savePAXPackageOn: stream;
		savePAXPackageVersionOn: stream;
		savePAXAboutBlockOn: stream;
		savePAXStripperBytesOn: stream;
		savePAXScriptsOn: stream;
		savePAXNamesOn: stream;
		savePAXVariableNamesOn: stream;
		savePAXPrerequisiteNamesOn: stream;
		savePAXManualPrerequisitesOn: stream;
		savePAXUntracedVariablesOn: stream.

	"Finish off the stream by answering the package loaded"
	stream nextPutAll: 'package'.
	aSourceFiler fileOutExpression: stream contents!

savePAXCollection: aSequencedReadableCollection initializer: aSymbol on: aPuttableStream
	aSequencedReadableCollection isEmpty ifTrue: [^self].
	aPuttableStream
		nextPutAll: 'package ';
		display: aSymbol;
		nextPutAll: ' #(';
		cr.
	aSequencedReadableCollection do: 
			[:each |
			aPuttableStream
				tab;
				print: each;
				cr].
	aPuttableStream
		nextPutAll: ').';
		cr;
		cr!

savePAXManualPrerequisitesOn: aPuttableStream
	"Private - File out the names of any manually configured pre-requisite packages of the receiver onto the <puttableStream> argument."

	self
		savePAXCollection: self manualPrerequisites
		initializer: #setManualPrerequisites:
		on: aPuttableStream!

savePAXNames: aCollectionOfBindingReferences initializer: aSymbol on: aPuttableStream
	self
		savePAXCollection: aCollectionOfBindingReferences asSortedCollection
		initializer: aSymbol
		on: aPuttableStream!

savePAXNamesOn: aPuttableStream
	"Private - File out the PAX source file representation of the class names, loose method  names, and variable names, onto the <puttableStream> argument, in ascending order of their printable representation."

	self
		savePAXNames: self classNames
		initializer: #setClassNames:
		on: aPuttableStream.
	self
		savePAXCollection: (self methodNames asSortedCollection collect: [:each | {each className. each selector}])
		initializer: #setMethodNames:
		on: aPuttableStream.
	self
		savePAXNames: self variableNames
		initializer: #setVariableNames:
		on: aPuttableStream!

savePAXPackageOn: aPuttableStream
	"Private - Save the basic details of the receiver in the PAX source file representation onto the <puttableStream> argument."

	"Create package and set some basic attributes"

	aPuttableStream
		nextPutAll: '| package |';
		cr;
		nextPutAll: 'package := ';
		print: self class;
		space;
		nextPutAll: #name:;
		space;
		print: self name;
		nextPut: $.;
		cr;
		nextPutAll: 'package ';
		nextPutAll: #paxVersion:;
		space;
		print: self paxVersion;
		nextPut: $;;
		crtab.
	preDeclareClassesOnLoad
		ifNotNil: 
			[aPuttableStream
				nextPutAll: #preDeclareClassesOnLoad:;
				space;
				print: preDeclareClassesOnLoad;
				nextPut: $;;
				crtab].
	aPuttableStream
		nextPutAll: #basicComment:;
		space;
		print: self comment;
		nextPut: $.;
		cr;
		cr!

savePAXPackageVersionOn: aStream 
	"Private - Save Package Version - this is the version of the package, not the file out format"

	packageVersion isNil ifTrue: [^self].
	aStream
		nextPutAll: 'package ';
		nextPutAll: #basicPackageVersion:;
		space;
		print: self packageVersion;
		nextPut: $.;
		cr;
		cr!

savePAXPrerequisiteNamesOn: aPuttableStream
	"Private - File out names of the pre-requisite packages of the receiver onto the onto the <puttableStream> argument in ascending order."

	| basePath |
	basePath := self path.
	self
		savePAXCollection: ((self prerequisites asSortedCollection: [:a :b | a name <==> b name < 0])
				collect: [:each | File removeExtension: (File relativePathOf: each packageFileName to: basePath)])
		initializer: #setPrerequisites:
		on: aPuttableStream!

savePAXScriptsOn: target 
	"Private - File out the PAX source file representation of the receiver's scripts
	onto the <puttableStream>, target.
	Implementation Note: The scripts are installed using #basicScriptAt:put: to
	avoid the package being flagged as changed and the consequent transmission 
	of a change event."

	self scripts keys asSortedCollection do: 
			[:each | 
			target
				nextPutAll: 'package basicScriptAt: ';
				print: each;
				nextPutAll: ' put: ';
				print: (self scriptAt: each);
				nextPut: $.;
				cr].
	target cr!

savePAXStripperBytesOn: stream 
	"Private - File out the PAX source file representation of the receiver's 
	image stripper bytes (if any) onto the <puttableStream>, target."

	imageStripperBytes isNil ifTrue: [^self].
	stream nextPutAll: 'package imageStripperBytes: '.
	imageStripperBytes base64StoreOn: stream.
	stream
		nextPut: $.;
		cr!

savePAXUntracedVariablesOn: aWriteStream
	self
		savePAXNames: self untracedVariables asSortedCollection
		initializer: #setUntracedVariables:
		on: aWriteStream!

savePAXVariableNamesOn: aPuttableStream
	"Private - File out the PAX source file expressions to record the names of the non-source globals owned by the receiver."

	self
		savePAXNames: self binaryVariableNames
			initializer: #setBinaryVariableNames:
			on: aPuttableStream;
		savePAXNames: self aliasVariableNames
			initializer: #setAliasVariableNames:
			on: aPuttableStream!

saveSingleFilePackage
	"Save the receiver and all owned objects to a single .PAC file.
	The complementary message to save a multi-file package is #fileOutAll."

	self savePAC.
	self updateTimestamp.
	self resetChangeFlags!

toggleUsingPAX
	"Toggles the use of PAX mode."

	^self isUsingPAX: self isUsingPAX not!

updateTimestamp
	"Private - Synchronise the receiver's timestamp with its source file."

	timestamp := self fileModificationTime! !
!Package categoriesFor: #allFileOutNames!accessing!private!source filing! !
!Package categoriesFor: #beNotUsingPAX!modes!public! !
!Package categoriesFor: #beUsingPAX!modes!public! !
!Package categoriesFor: #canFileOut!public!source filing! !
!Package categoriesFor: #checkTimestamps!helpers!private! !
!Package categoriesFor: #createPackagePath!private!source filing! !
!Package categoriesFor: #dotPacPath!helpers!private! !
!Package categoriesFor: #fileModificationTime!helpers!private! !
!Package categoriesFor: #fileOut!public!source filing! !
!Package categoriesFor: #fileOutAll!public!source filing! !
!Package categoriesFor: #fileOutAllChanged!public!source filing! !
!Package categoriesFor: #fileOutAllOn:!public!source filing! !
!Package categoriesFor: #fileOutBinaryVariableNamesOn:!private!source filing! !
!Package categoriesFor: #fileOutBinaryVariables!private!source filing! !
!Package categoriesFor: #fileOutBootDefinitions!private!source filing! !
!Package categoriesFor: #fileOutClassDefinitionsOn:!private!source filing! !
!Package categoriesFor: #fileOutClassesOn:!private!source filing! !
!Package categoriesFor: #fileOutLooseMethodsOn:!private!source filing! !
!Package categoriesFor: #fileOutMethodsOfClass:on:!private!source filing! !
!Package categoriesFor: #fileOutNames!private!source filing! !
!Package categoriesFor: #fileOutOn:!public!source filing! !
!Package categoriesFor: #fileOutSourceVariableNamesOn:!private!source filing! !
!Package categoriesFor: #fileOutVariableAliasesOn:!private!source filing! !
!Package categoriesFor: #isRenegade!public!testing! !
!Package categoriesFor: #isUsingPAX!public!testing! !
!Package categoriesFor: #isUsingPAX:!accessing!public! !
!Package categoriesFor: #save!commands!public! !
!Package categoriesFor: #saveAs:!commands!public! !
!Package categoriesFor: #saveChanges!operations!public! !
!Package categoriesFor: #savePAC!helpers!private! !
!Package categoriesFor: #savePAX!private!source filing-pax! !
!Package categoriesFor: #savePAXAboutBlockOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXChunkOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXCollection:initializer:on:!private!source filing-pax! !
!Package categoriesFor: #savePAXManualPrerequisitesOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXNames:initializer:on:!private!source filing-pax! !
!Package categoriesFor: #savePAXNamesOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXPackageOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXPackageVersionOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXPrerequisiteNamesOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXScriptsOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXStripperBytesOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXUntracedVariablesOn:!private!source filing-pax! !
!Package categoriesFor: #savePAXVariableNamesOn:!private!source filing-pax! !
!Package categoriesFor: #saveSingleFilePackage!public!source filing! !
!Package categoriesFor: #toggleUsingPAX!commands!public! !
!Package categoriesFor: #updateTimestamp!helpers!private! !

!PoolConstantsDictionary methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self! !
!PoolConstantsDictionary categoriesFor: #canFileOut!development!public!source filing! !
!PoolConstantsDictionary categoriesFor: #fileOut!development!public!source filing! !
!PoolConstantsDictionary categoriesFor: #fileOutOn:!development!public! !

!PoolDictionary methodsFor!

canFileOut
	"Answer true if the receiver can be filed out. At this stage we just check to ensure that
	the file out file is writeable"

	^File isWriteable: self  fileOutName!

fileOut
	"File out the receiver to <name>.st"

	self class sourceManager fileOut: self.
	self isChanged: false!

fileOutOn: aSourceFiler
	aSourceFiler fileOutPoolDictionary: self! !
!PoolDictionary categoriesFor: #canFileOut!development!public!source filing! !
!PoolDictionary categoriesFor: #fileOut!development!public!source filing! !
!PoolDictionary categoriesFor: #fileOutOn:!development!public! !

!SourceFiler methodsFor!

emitCategoriesOfClass: aClass 
	"Private - Emit a chunk to source stream to reclassify the <Class>, aClass, in all its existing 
	categories."

	^self subclassResponsibility!

emitCategoriesOfMethod: aCompiledMethod 
	"Private - Append an entry to the source stream to reclassify the <CompiledMethod>, 
	aCompiledMethod, in all its current method categories."

	^self subclassResponsibility!

emitCategoriesOfMethods: methods 
	"Emit source that associates the <CompiledMethod>s in the <collection>, methods, with their
	current categories."

	methods do: [:m | self emitCategoriesOfMethod: m]!

emitClassPoolOfClass: aClass
	"Private - Emit initialization expressions for each of the literal constants in the class pool of aClass."

	| literalConstants |
	literalConstants := aClass classPool associations
				select: [:each | each isImmutable and: [each value isLiteral]].
	literalConstants asSortedCollection
		do: [:each | self emitDeclarationForClass: aClass variable: each]!

emitComment: aString 
	"Private - Record aString to the source stream.
	N.B. Logging requests should be directed through the SessionManager."

	^self subclassResponsibility!

emitCommentOfClass: aClass 
	"Private - Emit a chunk which defines the comment for the <Class>, aClass, to source stream."

	^self subclassResponsibility!

emitDeclarationForClass: aClass variable: each
	^self subclassResponsibility!

emitMessages: aClass ofBehavior: selectors 
	| methods sortedSelectors |
	sortedSelectors := selectors 
				asSortedCollection: SortedCollection caseSensitiveSortBlock.
	methods := sortedSelectors asArray collect: 
					[:selector | 
					| method |
					self
						cr;
						cr.
					method := aClass compiledMethodAt: selector.
					self emitMethod: method.
					method].
	^methods!

emitMethod: aCompiledMethod 
	"Private - File out the source of the single <CompiledMethod>, aCompiledMethod, to the source stream."

	^self subclassResponsibility!

emitSetBehaviorFlag: flagName forClass: aClass 
	"Private - Emit an attribute for the <Class>, aClass, to define its special behaviour flag named by
	the <Symbol>, flagName."

	^self subclassResponsibility!

emitSpecialBehaviourAttributesOfClass: aClass
	"Private - Emit attributes for the <Class>, aClass, to define its special behaviour flags."

	#(#isIndirection #isNullTerminated)
		do: [:flagName | (aClass perform: flagName) ifTrue: [self emitSetBehaviorFlag: flagName forClass: aClass]].
	"We only emit the #isAbstract flag if the class has been explicitly marked non-instantiable, not just because it answers true to #isAbstract."
	aClass isNonInstantiable ifTrue: [self emitSetBehaviorFlag: #isAbstract forClass: aClass]!

fileOutAllMethodsOfBehavior: aClassDescription 
	"Emit definitions of all methods in the <ClassDescription> argument, aClassDescription,
	to the source stream."

	self fileOutMessages: aClassDescription selectors ofBehavior: aClassDescription.
	self isSourceOnly 
		ifFalse: [self fileOutProtocols: aClassDescription protocols ofBehavior: aClassDescription]!

fileOutAttributesOfClass: aClass
	"File-out any attributes of the aClass (e.g. the comment, GUID, etc) not included in the basic
	aClass definition, onto the source stream."

	self emitGUIDOfClass: aClass.
	self emitSpecialBehaviourAttributesOfClass: aClass.
	self emitClassPoolOfClass: aClass.
	self emitCommentOfClass: aClass.
	self emitCategoriesOfClass: aClass.
!

fileOutBasicDefinitionOfClass: aClass 
	"Print a definition of the <Class>, aClass, to the source stream."

	^self subclassResponsibility!

fileOutBinaryVariable: aBindingReference
	"File out the text representation of the non-<sourceObject> which is the value of the <VariableBinding> referred to by the argument onto the receiver's source stream."

	^self subclassResponsibility!

fileOutClass: aClass 
	"File out a full definition of the <ClassDescription>, aClass, to the source stream
	including all methods, categories and protocols. This includes all methods of the
	class, including any loose methods that may belong to packages other than the
	owning package of the class."

	self
		fileOutDefinitionOfClass: aClass;
		fileOutAllMethodsOfBehavior: aClass;
		fileOutAllMethodsOfBehavior: aClass class!

fileOutDefinitionOfClass: aClass 
	"File-out a definition of the <Class> to the source stream."

	self
		fileOutBasicDefinitionOfClass: aClass;
		fileOutAttributesOfClass: aClass!

fileOutExpression: aString
	"Append an immediate expression evaluation to the the source stream."

	^self subclassResponsibility!

fileOutMessages: selectors ofBehavior: aClass 
	"Append the definitions of the methods of the <ClassDescription>, aClassDescription,
	whose names match the selectors in the <collection> of <Symbol>, aCollection, to the source 
	stream. Any method category settings are included."

	| methods |
	selectors isEmpty ifTrue: [^self].
	self emitHeaderForMethodsOf: aClass.
	methods := self emitMessages: aClass ofBehavior: selectors.
	self emitFooterForMethodsOf: aClass.
	self isSourceOnly ifFalse: [self emitCategoriesOfMethods: methods].
	self cr!

fileOutMethods: aCollection 
	"Append the definitions of the methods in the <collection> argument to the source stream,
	ordered by class. Any method category settings are included."

	| methodsByClass |
	methodsByClass := Dictionary new.
	aCollection do: 
			[:each | 
			"Note that the selectors will be filed out in sorted order, so we don't need to sort them"
			(methodsByClass at: each methodClass ifAbsentPut: [OrderedCollection new]) add: each selector].
	(methodsByClass associations 
		asSortedCollection: [:a :b | (a key fullName <==> b key fullName) <= 0]) 
			do: [:each | self fileOutMessages: each value ofBehavior: each key]!

fileOutPoolDictionary: aPoolDictionary 
	"Append a definition of the <PoolDictionary> (or <PoolConstantsDictionary>, aPoolDictionary,
	to the source stream. The definition should be sufficient to recreate a copy  of the dictionary."

	^self subclassResponsibility!

fileOutProtocols: aCollection ofBehavior: aClassDescription 
	"File out the <MethodProtocol>s in the <collection>, aCollection, to the source stream,
	associating them with the <ClassDescription>, aClassDescription."

	^self subclassResponsibility!

fileOutResource: aResourceIdentifier 
	"Append a definition of the resource identified by the <ResourceIdentifier>, aResourceIdentifer,
	to the source stream. The definition should be sufficient to recreate a copy  of the resource."

	^self subclassResponsibility!

storeCommentString: aString forClass: aClass
	"Save the <readableString>, aString, as the comment text for the 
	<Class>, aClass, to the receiver's source stream encoding the position and 
	index into the class' source descriptor so that the comment may be retrieved later."

	^self subclassResponsibility!

storeCommentString: aString forPackage: aPackage
	"Save the <readableString>, aString, as the comment text for the <Package>, aPackage, to the
	receiver's source stream encoding the position and index into the package's source
	descriptor so that the comment may be retrieved later."

	^self subclassResponsibility! !
!SourceFiler categoriesFor: #emitCategoriesOfClass:!private!source filing! !
!SourceFiler categoriesFor: #emitCategoriesOfMethod:!private!source filing! !
!SourceFiler categoriesFor: #emitCategoriesOfMethods:!private!source filing! !
!SourceFiler categoriesFor: #emitClassPoolOfClass:!private!source filing! !
!SourceFiler categoriesFor: #emitComment:!operations-logging!private! !
!SourceFiler categoriesFor: #emitCommentOfClass:!private!source filing! !
!SourceFiler categoriesFor: #emitDeclarationForClass:variable:!private!source filing! !
!SourceFiler categoriesFor: #emitMessages:ofBehavior:!private!source filing! !
!SourceFiler categoriesFor: #emitMethod:!private!source filing! !
!SourceFiler categoriesFor: #emitSetBehaviorFlag:forClass:!private!source filing! !
!SourceFiler categoriesFor: #emitSpecialBehaviourAttributesOfClass:!private!source filing! !
!SourceFiler categoriesFor: #fileOutAllMethodsOfBehavior:!public!source filing! !
!SourceFiler categoriesFor: #fileOutAttributesOfClass:!public!source filing! !
!SourceFiler categoriesFor: #fileOutBasicDefinitionOfClass:!public!source filing! !
!SourceFiler categoriesFor: #fileOutBinaryVariable:!public!source filing! !
!SourceFiler categoriesFor: #fileOutClass:!public!source filing! !
!SourceFiler categoriesFor: #fileOutDefinitionOfClass:!public!source filing! !
!SourceFiler categoriesFor: #fileOutExpression:!public!source filing! !
!SourceFiler categoriesFor: #fileOutMessages:ofBehavior:!public!source filing! !
!SourceFiler categoriesFor: #fileOutMethods:!public!source filing! !
!SourceFiler categoriesFor: #fileOutPoolDictionary:!public!source filing! !
!SourceFiler categoriesFor: #fileOutProtocols:ofBehavior:!public!source filing! !
!SourceFiler categoriesFor: #fileOutResource:!public!source filing! !
!SourceFiler categoriesFor: #storeCommentString:forClass:!public!source filing! !
!SourceFiler categoriesFor: #storeCommentString:forPackage:!public!source filing! !

!SourceManager methodsFor!

basicCompressSources: progress 
	"Private - Compresses the sources file reporting the progress to
	<monadicValuable>, progress."

	| totalClasses index tmpPath smlFile filer classes |
	index := 0.
	classes := self class environment allClasses.
	totalClasses := classes size.

	"Create temporary stream file"
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	smlFile := self sourcesFileName.
	filer := self sourceFilerOn: (FileStream write: tmpPath).
	filer
		sourceFileIndex: SourcesIndex;
		isSourceOnly: true.
	self logComment: 'Compressing sources....' to: filer.
	index := 0.
	classes do: 
			[:class | 
			filer storeCommentString: class comment forClass: class.
			filer fileOutAllMethodsOfBehavior: class class.
			filer fileOutAllMethodsOfBehavior: class.
			progress value: (index := index + 1) * 100 / totalClasses].
	self compressPackageCommentsOn: filer.
	filer close.

	"Copy temporary file over to dolphin.sml"
	self closeSourcesFile.
	File
		delete: smlFile;
		rename: tmpPath to: smlFile.
	self openSourcesFile: smlFile.

	"Save image"
	SessionManager current saveImage.

	"Clear down change log"
	self truncateChanges.
	self logComment: 'Compressed sources'!

compressChangedMethodsOf: aBehavior onto: aSourceFiler 
	"Private - Emits the changed methods of aBehavior onto aSourceFiler."

	| changed |
	changed := aBehavior changedMethods collect: [:each | each selector].
	aSourceFiler fileOutMessages: changed ofBehavior: aBehavior!

compressChanges
	"Compresses the change log to remove duplicate entries, and save the image to keep it in sync."

	| tmpPath filer |
	tmpPath := File temporaryFilenameWithPrefix: self changesExtension.
	filer := self chunkFilerOn: (FileStream write: tmpPath).
	filer sourceFileIndex: ChangesIndex.
	mutex critical: 
			[self compressChangesOnto: filer.
			filer close.
			self openNewChangesFile: tmpPath].
	self logComment: 'Compressed changes'.

	"Save image"
	SessionManager current saveImage!

compressChangesOf: aClass onto: aSourceFiler 
	"Private - Compress any changes to the specified class onto the <SourceFiler>."

	"First the comment ..."

	(self sourceIndexFromDescriptor: aClass sourceDescriptor) = ChangesIndex 
		ifTrue: [aSourceFiler storeCommentString: aClass comment forClass: aClass].
	"...then the methods..."
	self
		compressChangedMethodsOf: aClass class onto: aSourceFiler;
		compressChangedMethodsOf: aClass onto: aSourceFiler.
	"Have to reset the changes index so that all changed methods are included since we have lost
	the save point"
	aClass isChanged 
		ifTrue: 
			["Note that it is necessary to remove the existing change index first since
			 attempts after the first to set it are ignored"
			aClass
				isChanged: false;
				changeIndexValue: [0]]!

compressChangesOnto: aSourceFiler 
	self class environment allClasses do: [:each | self compressChangesOf: each onto: aSourceFiler].
	Package manager packages do: 
			[:each | 
			(self sourceIndexFromDescriptor: each sourceDescriptor) = ChangesIndex 
				ifTrue: [aSourceFiler storeCommentString: each comment forPackage: each]]!

compressPackageCommentsOn: aSourceFiler 
	Package manager packages do: 
			[:each | 
			| comment |
			comment := each comment.
			comment isEmpty 
				ifTrue: [each sourceDescriptor: nil]
				ifFalse: [aSourceFiler storeCommentString: comment forPackage: each]]!

compressSources
	"Compresses the change log into the sources file. The result is a new empty changes log.
	The image must be saved to keep it in sync."

	self basicCompressSources: [:x | ]

!

compressSourcesWith: aProgressDialog
	"Compresses the change log into the sources file. The result is a new empty changes log.
	During the operation the progress is indicated by aProgressDialog."

	aProgressDialog operation: [:progress | self basicCompressSources: progress ].
	aProgressDialog showModal.
!

copyAndReopenSources: aString 
	"Private - Copy sources to the path and root file name (i.e. without extension) specified
	by the <readableString> argument, and then open the copies for any further perusal and 
	modification.

	Take a special interest if we do not currently have the source files available.
	This will be the case when we load from a .exe. In this case we generate some
	suitable empty source files. We also have to mark methods so that they know
	they have lost any reference to information in a .sml file."

	| hadSources |
	hadSources := self hasSources.

	"Copy and and swap over sources. Take care to end up with a good sources and imagePath"
	hadSources 
		ifTrue: 
			[self copySourceFilesTo: aString.
			self closeSources].
	hadSources 
		ifFalse: 
			[self createSources: aString.
			"We have permanently lost access to any source information so mark all methods"
			self class environment 
				allBehaviorsDo: [:aBehavior | aBehavior methodDictionary do: [:aMethod | aMethod loseSource]]].
	self openSources: aString!

createSources: filePath
	"Private - This will create a sources and changes file for the current image. Does not
	update the receiver to use these new files though."

	self createSourcesFile: filePath.
	(File open: (self changesFileNameFromPath: filePath) mode: #truncate check: false) close!

createSourcesFile: filePath 
	"Private - Create (or truncate) a source file with the specified path (and default extension)."

	(self newSourceFiler: (self sourcesFileNameFromPath: filePath)) close!

emitFileOutHeaderOn: aSourceFiler 
	"Private - Append the standard Dolphin file out header to the
	<puttableStream>, aWriteStream."

	aSourceFiler
		emitComment: 'Filed out from ' , VMLibrary default productName;
		cr!

fileOut: anObject
	"File out anObject to its default file. If an error occurs during file out, the file
	will be closed by finalization."

	self fileOut: anObject to: anObject fileOutName.!

fileOut: anObject to: aFileName 
	"File out anObject to aFileName. If an error occurs during file out, the file
	will be closed by finalization."

	| filer |
	filer := self newSourceFiler: aFileName.
	anObject fileOutOn: filer.
	filer close!

fileOutPackagedClass: aClass
	"File out aClass via the package mechanism. The class is filed out to the same directory as the
	package which contains it. Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	self fileOutPackagedClass: aClass to: aClass fileOutName.
	!

fileOutPackagedClass: aClass to: aFileName 
	"File out aClass via the package mechanism. The class is filed out to aFileName.
	Only the methods contained in this package are included in the 
	generated file and following this call the class and its methods are marked as unchanged."

	| package filer |
	package := self packageManager packageOfClass: aClass.
	package isNil 
		ifTrue: 
			["Not in any package so just file out normally"
			^self fileOut: aClass to: aFileName].
	filer := self newSourceFiler: aFileName.
	filer fileOutDefinitionOfClass: aClass.
	package fileOutMethodsOfClass: aClass on: filer.
	package fileOutMethodsOfClass: aClass class on: filer.
	filer close.

	"Flag the class as being saved, i.e. no longer changed"
	aClass isChanged: false!

logChanged: aSourceObject
	"File out the changed <sourceObject>, aSourceObject, to the change log."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[aSourceObject fileOutOn: logger.
					logger flush]]!

logComment: aString
	"Record aString to the change log as a comment. All comments
	logged are prefixed with a timestamp.
	N.B. Logging requests should be directed through the SessionManager."

	self changesFiler 
		ifNotNil: [:logger | self logComment: aString to: logger]!

logComment: aString to: aSourceFiler
	"Private - Record aString to the specified source file as a comment. All comments
	logged are prefixed with a timestamp."

	| timestamp stampedComment |
	timestamp := DateAndTime now.
	stampedComment := String writeStream: 25 + aString size.
	#todo. "Use the standard form for a DateAndTime here - Ian's chunk browser relies on the original format, so that needs to be fixed."
	Locale invariant printDateTime: timestamp on: stampedComment format: 'HH:mm:ss, dd MMMM yyyy'.
	stampedComment nextPutAll: ': '; nextPutAll: aString.
	stampedComment := stampedComment contents.
	mutex critical: 
			[aSourceFiler
				emitComment: stampedComment;
				cr]!

newSourceFiler: path
	"Private - Answer a new <SourceFiler> on the specified path with the default
	format. Any existing file with at the specified path is truncated."

	| answer dir |
	dir := File splitPathFrom: path.
	(File isDirectory: dir) ifFalse: [File createDirectoryPath: dir].
	answer := self sourceFilerOn: (FileStream write: path).
	self emitFileOutHeaderOn: answer.
	^answer!

storeCategoriesForClass: class
	"Private - Store the categories of the <ClassDescription>, class, to
	the change log so that they may be reloaded later."

	self changesFiler 
		ifNotNil: [:logger | mutex critical: 
					[logger
						emitCategoriesOfClass: class;
						flush]]!

storeCategoriesForMethod: method
	"Private - Store the categories of the <CompiledMethod>, method, to the change
	log so that they may be reloaded later."

	self changesFiler ifNotNil: 
			[:logger | 
			mutex critical: 
					[logger
						emitCategoriesOfMethod: method;
						cr;
						flush]]! !
!SourceManager categoriesFor: #basicCompressSources:!operations-source files!private! !
!SourceManager categoriesFor: #compressChangedMethodsOf:onto:!operations-source files!private! !
!SourceManager categoriesFor: #compressChanges!operations-source files!public! !
!SourceManager categoriesFor: #compressChangesOf:onto:!operations-source files!private! !
!SourceManager categoriesFor: #compressChangesOnto:!operations-source files!public! !
!SourceManager categoriesFor: #compressPackageCommentsOn:!operations-source files!private! !
!SourceManager categoriesFor: #compressSources!operations-source files!public! !
!SourceManager categoriesFor: #compressSourcesWith:!operations-source files!public! !
!SourceManager categoriesFor: #copyAndReopenSources:!operations-source files!private! !
!SourceManager categoriesFor: #createSources:!operations-source files!private! !
!SourceManager categoriesFor: #createSourcesFile:!operations-source files!private! !
!SourceManager categoriesFor: #emitFileOutHeaderOn:!private!source filing! !
!SourceManager categoriesFor: #fileOut:!public!source filing! !
!SourceManager categoriesFor: #fileOut:to:!public!source filing! !
!SourceManager categoriesFor: #fileOutPackagedClass:!public!source filing! !
!SourceManager categoriesFor: #fileOutPackagedClass:to:!public!source filing! !
!SourceManager categoriesFor: #logChanged:!public!source filing! !
!SourceManager categoriesFor: #logComment:!operations-logging!public! !
!SourceManager categoriesFor: #logComment:to:!operations-logging!private! !
!SourceManager categoriesFor: #newSourceFiler:!private!source filing! !
!SourceManager categoriesFor: #storeCategoriesForClass:!private!source filing! !
!SourceManager categoriesFor: #storeCategoriesForMethod:!private!source filing! !

"End of package definition"!

