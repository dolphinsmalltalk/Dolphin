| package |
package := Package name: 'Dolphin Legacy Date & Time'.
package paxVersion: 1;
	preDeclareClassesOnLoad: false;
	basicComment: 'Dolphin Smalltalk legacy Date and Time.
Copyright (c) Object Arts Ltd. 1997-2019

Traditional Smalltalk-80 style `Date` and `Time` classes. These are largely superceded by ANSI compliant `DateAndTime` and `Duration`.'.

package classNames
	add: #Date;
	add: #Time;
	add: #TimeStamp;
	yourself.

package methodNames
	add: #BlockClosure -> #millisecondsToRepeat:;
	add: #DateAndTime -> #asDate;
	add: #DateAndTime -> #asTime;
	add: #DateAndTime -> #asTimeStamp;
	add: #SYSTEMTIME -> #asDate;
	add: #SYSTEMTIME -> #asTimeStamp;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'Dolphin').

package!

"Class Definitions"!

Magnitude subclass: #Date
	instanceVariableNames: 'days'
	classVariableNames: 'DaysInMonth DaysUntilMonth DefaultLongPicture YearPivot'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Magnitude subclass: #Time
	instanceVariableNames: 'seconds'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Magnitude subclass: #TimeStamp
	instanceVariableNames: 'date time'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Loose Methods"!

!BlockClosure methodsFor!

millisecondsToRepeat: anInteger
	"Answer the time taken to execute the receiver anInteger times"

	^Time millisecondsToRun: [ anInteger timesRepeat: [self value]]! !

!BlockClosure categoriesForMethods!
millisecondsToRepeat:!development!public! !
!

!DateAndTime methodsFor!

asDate
	"Answer a <Date> representing the date of the receiver. <Date>s are not timezone aware, but we follow the convention that they are assumed to represent a local time. Thefore we first convert the receiver to a local DateAndTime, and then extract the date from that."

	^self asLocal dayMonthYearDo: 
			[:d :m :y |
			Date
				newDay: d
				monthIndex: m
				year: y]!

asTime
	"Answer a <Time> representing the local time of the receiver."

	^Time fromSeconds: self asLocal seconds
!

asTimeStamp
	"Answer a <TimeStamp> representing the local date and time of the receiver. The <TimeStamp> will be that at the receiver's offset, so:
		- if a date/time in the local timezone is needed, send #asLocal first (i.e. `dateAndTime asLocal asTimeStamp`)
		- if a UTC date/time is needed, send #asUTC first (i.e. `dateAndTime asUTC asTimeStamp`)."

	^TimeStamp date: self asDate time: self asTime! !

!DateAndTime categoriesForMethods!
asDate!converting!public! !
asTime!converting!public! !
asTimeStamp!converting!public! !
!

!SYSTEMTIME methodsFor!

asDate
	"Answer a <Date> corresponding to the receiver's date."

	^Date fromSYSTEMTIME: self!

asTimeStamp
	"Answer a <TimeStamp> corresponding to the receiver's point in time."

	^self asDateAndTime asTimeStamp! !

!SYSTEMTIME categoriesForMethods!
asDate!converting!public! !
asTimeStamp!converting!public! !
!

"End of package definition"!

