"Filed out from Dolphin Smalltalk 7"!

Object subclass: #PackageManager
	instanceVariableNames: 'packages processEvents packagedGlobals looseMethods events defaultPackage basePackages'
	classVariableNames: 'Current DuplicatePackageSignal PackageNotFoundSignal PrerequisiteNotFoundSignal SystemPackage'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
PackageManager guid: (GUID fromString: '{87b4c4a7-026e-11d3-9fd7-00a0cc3e4a32}')!
PackageManager comment: 'The PackageManager class contains a collection of all the Packages currently loaded into
the system. The class obeys the Singleton pattern.

All the Packages known by a PackageManager must have unique names.

One of the packages is known as the system package. This Packages owns all of the system classes,
methods and globals which define the base Smalltalk system. It is not possible to remove or load in
a replacement for this package.

When Packages are loaded or removed from the CategoryManager we strive to leave the manager in a fully
working state. This is to ensure that the development tools will keep on working even if objects are
left unowned by a Package. It is possible to clear these up by using the PackageBrowser.

instance variables
	packages		Collection of loaded packages
	processEvents	Count of whether update events generated by the packages should be passed
			onto the rest of the system. Switched off during package install/uninstall for
			performance reasons.
	packagedGlobals	<IdentityDictionary> mapping package format global names to the owning
			package. Globals may be Classes or general global variables. This is a cache.
	looseMethods	<Collection> of all loose methods in the package system (i.e. methods owned
			by a package other that that of their class). This is a cache.

class variables
	Current		Singleton instance of PackageManager
	SystemPackage	Single package which owns all the system classes/globals

triggers generated
	loadedChanged	The collection of loaded packages has changed
	ownedChanged	The owned objects of a package have been changed, ie added to/removed.
	resetPrerequisites	The lazily generated prerequisites data for each of  the packages has been
			invalidated. This will happen quite often, for example compiling a method.
			The next time you request the prerequisites of a package it will calculate them.'!
!PackageManager categoriesForClass!Development! !
!PackageManager methodsFor!

addClass: aClass to: aPackageOrNil
	"Add the <Class>, aClass, to the <Package>, destination, after first 
	removing it from any existing package. If aPackage is nil, then the
	class becomes uncommitted (i.e. not owned by any package)."

	| source destination |
	source := self packageOfClass: aClass.
	destination := aPackageOrNil == Package uncommitted ifFalse: [aPackageOrNil].
	source == destination ifTrue: [^self].
	self forgetLooseMethods.	"Could be more discriminating, but rebuild is pretty quick"
	source notNil 
		ifTrue: 
			[packagedGlobals removeKey: aClass name.
			source basicRemoveClass: aClass].
	destination notNil 
		ifTrue: 
			[destination basicAddClass: aClass.
			packagedGlobals at: aClass name put: aPackageOrNil].
	self 
		classRepackaged: aClass
		from: source
		to: destination!

addGlobalNamed: globalName to: aPackageOrNil
	"Add the global variable named, globalName, to the <Package>, destination,
	after first removing it from any existing package."

	| source destination |
	source := self packageOfGlobalNamed: globalName.
	destination := aPackageOrNil == Package uncommitted ifFalse: [aPackageOrNil].
	source == destination ifTrue: [^self].
	source notNil 
		ifTrue: 
			[packagedGlobals removeKey: globalName.
			source basicRemoveGlobalNamed: globalName].
	destination notNil 
		ifTrue: 
			[aPackageOrNil basicAddGlobalNamed: globalName.
			packagedGlobals at: globalName put: aPackageOrNil].
	self 
		globalRepackaged: globalName
		from: source
		to: destination!

addLooseMethod: aCompiledMethod to: aPackage
	"Private - The loose <CompiledMethod> argument has been (or is about to
	be) added to the <Package> argument. Maintain the loose method cache."

	looseMethods notNil ifTrue: [looseMethods at: aCompiledMethod name put: aPackage].
	aPackage addLooseMethod: aCompiledMethod!

addManagedPackage: aPackage
	"Private - Add the <Package> argument to the collection of packages held by the receiver. 
	Each package must have a unique name. Answer the argument, or raise an error if either
	a package with the same name already exists or there is some clash between the
	contents of the package and existing installed packages."

	self addPackage: aPackage; observePackage: aPackage!

addMethod: aCompiledMethod to: aPackageOrNil 
	"Add the <CompiledMethod>, method, to the <Package>, destination,
	after first removing it from any existing package. Note that this is a
	composite operation with 4 possible cases:
		1) packaged -> loose
		2) loose -> packaged
		3) loose -> loose
		4) packaged -> packaged (not possible)
	Moving a packaged method (one owned by the same package as the class in
	which it implements a message) to become a loose method in a foreign package
	is different to the others in that we can't actually 'remove' a packaged method 
	from its package since it is not listed separately. In order that the state of the
	packages is consistent in that case we all cases we therefore first add the method to its package in 
	which it becomes a loose method before 'removing' it from its home package."

	| source destination classPackage moved indexValue |
	classPackage := self packageOfClass: aCompiledMethod methodClass.
	destination := (aPackageOrNil isNil or: [aPackageOrNil == Package uncommitted]) 
				ifTrue: [classPackage]
				ifFalse: [aPackageOrNil].
	source := self packageOfMethod: aCompiledMethod.
	source == destination ifTrue: [^self].
	moved := source isNil 
				ifTrue: 
					[self 
						moveMethod: aCompiledMethod
						from: classPackage
						to: destination]
				ifFalse: 
					[self 
						moveLooseMethod: aCompiledMethod
						from: source
						to: destination].

	"Only after the move is complete do we publish events to observers"
	moved ifFalse: [^self].
	"If the method is moving or returning to its home package, then that package is marked as
	changed, but the objects it lists as owned has not changed. Where a method is/was loose in a
	package, then the owning package has changed its owned contents."
	indexValue := [aCompiledMethod changePosition].
	source isNil 
		ifTrue: 
			[source := classPackage.
			self memberOf: classPackage updatedAt: indexValue]
		ifFalse: [source membershipChangedAt: indexValue].
	aPackageOrNil isNil 
		ifTrue: [self memberOf: destination updatedAt: indexValue]
		ifFalse: [self membershipChanged: destination at: indexValue].
	self 
		methodRepackaged: aCompiledMethod
		from: source
		to: destination!

addPackage: aPackage 
	"Private - Add the <Package> argument to the collection of packages held by the receiver. 
	Each package must have a unique name. Answer the argument, or raise an error if either
	a package with the same name already exists or there is some clash between the
	contents of the package and existing installed packages. Note that at this point we don't
	subscribe to any of the package's events."

	| name |
	name := aPackage name.
	(self includesPackageNamed: name) ifTrue: [^self errorNameIsNotUnique: name].
	(self loadCompatibilityCheck: aPackage) do: [:each | each owningPackage: Package uncommitted].
	self basicAddPackage: aPackage.
	^aPackage!

addPackagedMethod: aCompiledMethod to: aPackageOrNil 
	"Private - The <CompiledMethod> argument has been (or is about to
	be) added back to the same <Package> (as specified by the argument) to 
	which its method class belongs. Note that the target might be nil if the 
	method class is uncomitted."

	aPackageOrNil isNil 
		ifTrue: [aCompiledMethod methodClass methodChanged: aCompiledMethod]
		ifFalse: [aPackageOrNil addPackagedMethod: aCompiledMethod]!

addResourceIdentifier: aResourceIdentifier to: aPackageOrNil 
	"Add the <ResourceIdentifier>, aResourceIdentifier, to the <Package>, destination,
	after first removing it from any existing package."

	| source destination |
	destination := aPackageOrNil isNil ifTrue: [Package uncommitted] ifFalse: [aPackageOrNil].
	source := self packageOfResourceIdentifierOrItsClass: aResourceIdentifier.
	source == destination ifTrue: [^self].
	self addMethod: aResourceIdentifier compiledMethod to: aPackageOrNil.
	self 
		resourceRepackaged: aResourceIdentifier
		from: source
		to: destination!

allDependentPackagesOf: aPackage visited: visitedPackages 
	"Private - Add dependent packages of the <Package> argument, package, which
	are not already members of the <Set>, visitedPackages, to that set, and visit
	them. Answer the combined dependents."

	(self dependentPackagesOf: aPackage) do: 
			[:each | 
			(visitedPackages includes: each) 
				ifFalse: 
					[visitedPackages add: each.
					self allDependentPackagesOf: each visited: visitedPackages]].
	^visitedPackages!

allGlobalAliases
	^self packages inject: IdentitySet new
		into: 
			[:all :each | 
			all addAll: each globalAliases.
			all]
!

allPackagedClasses
	"Answer a <collection> of all the packaged classes in the system."

	| answer |
	answer := OrderedCollection new: 2000.
	self packages do: [:eachPackage | eachPackage classesDo: [:eachClass | answer addLast: eachClass]].
	^answer!

allPackagedGlobalNames
	"Private - Answer a <Set> of <Symbol>, being the names of all the 
	packaged globals in the system. Note that this does not include the
	names of packaged classes."

	| answer |
	answer := IdentitySet new: 50.
	self packages do: [:p | answer addAll: p globalNames].
	^answer!

allSourceObjects
	"Answer a <collection> of all the source objects known to the receiver"

	| answer |
	answer := OrderedCollection new: 2000.
	self packages 
		do: [:eachPackage | eachPackage allSourceObjectsDo: [:each | answer addLast: each]].
	^answer!

basePackages
	^basePackages ifNil: [basePackages := IdentitySet new].
!

basicAddPackage: aPackage
	self packages at: aPackage name put: aPackage!

basicInstall: aPackage 
	aPackage load!

basicRemovePackage: aPackage
	"Private - Remove the <Package> argument from the receiver's
	collection of loaded packages. All the packages owned objects are 
	assumed to have already been removed from the system.
	Answer the Package."

	self packages removeKey: aPackage name.
	defaultPackage == aPackage ifTrue: [defaultPackage := nil].
	aPackage removeEventsTriggeredFor: self.
	^aPackage!

basicUninstall: aPackage
	"Private - Remove aPackage from the receivers loaded packages.
	All the packages owned objects are removed from the system.
	Answer aPackage."

	self noEventsDo: 
			[aPackage removeEventsTriggeredFor: self.
			[aPackage privateUninstall] ensure: [self basicRemovePackage: aPackage]]!

beNotProcessingEvents
	"Private - Temporarily suspend the processing of system events or
	triggering of our own. This is not a binary mode but a count, so the same
	number of beProcessingEvents must be sent to the reeciever as
	beNotProcessingEvents before events are again processed. Ignored
	events are NOT cached by the receiver for processing later.

	N.B. Note that processing of events should only be suspending when
	installing or uninstalling a package, as it can leave the receiver and the
	Packages it holds in an inconsistent state. The reason for suspending
	events is to prevent the package from receiving events while it is
	in a partially loaded or unloaded state, and also to avoid an unecessary
	flurry of knock-on events."

	self changeProcessEventsBy: 1.
	self forgetLooseMethods!

beProcessingEvents
	"Private - Recommence processing system events and sending our own
	only if an equal number of beProcessingEvents as beNotProcessingEvents
	have been sent to the receiver."

	(self changeProcessEventsBy: -1) == 0
		ifTrue: [self clearCachedInformation]!

buildGlobalsMap
	"Private - Answer an <IdentityDictionary> which maps the symbolic names of all packaged
	globals to the owning package. This is used during the tracing of package prerequisites.
	"

	packagedGlobals := IdentityDictionary new: self class environment size.
	self packages do: [:package |
		package globalNames do: [:globalName |
			packagedGlobals at: globalName put: package].
		package classNames do: [:className |
			packagedGlobals at: className asSymbol put: package]].
	^packagedGlobals 
!

changedPackages
	"Answer a <collection> of all the packages that have been changed."

	^self packages select: [:each | each isChanged]!

changeProcessEventsBy: countChange
	"Private - Change the receivers count of the processEvents by countChange.
	A value of zero indicates that no one has a lock on the triggers and that they 
	should be processed as they are received from the rest of the system or generated 
	by the receiver. A value greater than 0 indicates that processing is temporarily suspend 
	until it is reduced back to 0. Any events received while suspended ar NOT cached for later
	processing."

	processEvents := processEvents + countChange.
	processEvents < 0
		ifTrue: 
			[Notification signal: 'PackageManager processEvents became corrupt and has been reset.'.
			processEvents := 0].
	^processEvents!

classRepackaged: aClass from: source to: destination
	"Private - Trigger class repackaging notifications."

	"When a class is repackaged (or removed), we reset all pre-reqs as it may affect not just
	 the source and destination packages (e.g. packages with loose methods in the repackaged
	 class are affected). This could probably be done more intelligently though."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		resetPrerequisites;
		trigger: #classRepackaged:from:to: withArguments: {aClass. source. destination}!

clearCachedInformation
	"Private - Clear down all cached information such as prerequisites."

	packagedGlobals notNil ifTrue: [self buildGlobalsMap].
	self forgetLooseMethods; resetPrerequisites!

defaultPackage
	^defaultPackage!

defaultPackage: aPackage 
	defaultPackage := aPackage!

dependentPackagesOf: aPackage 
	"Private - Answer a <collection> of the packages which have the <Package> argument,
	as a prerequisite."

	^self packages select: [:each | each prerequisites includes: aPackage]!

duplicatePackageSignal
	"Private - Answer the Signal raised when an attempt is made to install a package
	with the same name as one already present in the image."

	^DuplicatePackageSignal!

errorFileInCompatibilityCheck: aPackage overlap: overlappingObjects 
	"Private - Raise an error that the receiver can not be filed in
	because some objects which it expects to own are already owned
	by existing Packages."

	Notification signal: aPackage name , ': ' , overlappingObjects asArray printString.
	Package clashSignal 
		signal: ('The package <1p> contains objects that are already installed in the image.' 
				expandMacrosWith: aPackage name)
		with: overlappingObjects asArray!

errorNameIsNotUnique: aString 
	^DuplicatePackageSignal signal: aString!

errorPackageNotFound: aString 
	"Private - Raise an <Error> to the effect that the named package could
	not be located. This is trapped in install:."

	^PackageNotFoundSignal signal: aString!

errorPrerequisiteNotFound: aString 
	"Private - Raise a resumable error to the effect that the named package cannot be found.
	Answer a <readableString> being a revised the path for the package, or nil if no suggestions
	are available (e.g. this is not an interactive session and so user input is not available)."

	^PrerequisiteNotFoundSignal signal: aString!

errorRemovingSystemPackage
	^self error: 'The system package must not be uninstalled.'!

forgetLooseMethods
	"Forget the cached <LookupTable> of all the <CompiledMethod>s which are owned by
	packages which do not own the corresponding method class (i.e. those methods
	added by a package to classes in other packages)."

	looseMethods := nil!

getEvents
	"Private - Answer the <EventsCollection> belonging to the receiver, or nil if the receiver
	has no events registered for it"

	^events!

getLooseMethods
	"Private - Answer a <LookupTable> of all the <CompiledMethod>s which are owned by
	packages which do not own the corresponding method class (i.e. those methods
	added by a package to classes in other packages). The table maps loose methods
	by name to their owning package."

	| loose |
	loose := PluggableLookupTable new: 3072 searchPolicy: AssociationSearchPolicy current.
	self packages do: [:each | loose atAll: each methodNames put: each].
	^loose!

globalRepackaged: globalName from: source to: destination
	"Private - The global variable named by the <Symbol>, globalName, 
	has been repackaged. The operation is now complete and the package
	system in a consistent state so this is an appropriate point to pdate change 
	flags for all objects affected by the move and to trigger various notifications."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		resetPrerequisites;
		trigger: #globalRepackaged:from:to: withArguments: {globalName. source. destination}!

includesPackage: aPackage 
	"Answer whether the receiver manages the specified <Package>."

	^self packages includes: aPackage!

includesPackageNamed: aString 
	"Answer whether the receiver holds a <Package> whose name matches 
	that specified."

	^(self packageNamed: aString ifNone: []) notNil!

initialize
	"Private - Initialize the receivers instance variables and connect to a number of system
	triggers to ensure that the receivers packages remove references to any system objects which
	are removed."

	packages := PluggableLookupTable searchPolicy: SearchPolicy caseInsensitive.
	processEvents := 0.
	packagedGlobals := IdentityDictionary new.
!

install: aString 
	"Install the package file at the specified <readableString> path, and any pre-requisite
	packages, and any of the their pre-requisites, and so on. Answer a
	<sequencedReadableCollection> of packages in the installation order (i.e. the target package
	will be last in the list). If the package cannot be loaded, answer an empty collection."

	"Note that 'installation' loads the Package object and all the objects it owns too, i.e. all
	classes, methods, resources and globals are loaded into the system and the packages' install
	scripts are run. The receiver attempts to load any prerequsite packages from the same path
	location as that of the requested package, but if a suitable package then the 'prerequisite
	not found' exception is signalled. The caller can trap this exception (the
	<exceptionSelector> can be accessed using the #prerequisiteNotFoundSignal message), prompt
	the user to locate the path (for example), and resume the exception with the prerequisite
	package path as the argument. The receiver's #loadedChanged event is triggered on completion
	of installation of the network of packages."

	| newPackages startPackage |
	startPackage := self loadPackage: aString.
	(self includesPackageNamed: startPackage name) 
		ifTrue: [^self errorNameIsNotUnique: startPackage name].
	
	[| filename |
	filename := startPackage packageFileName.
	newPackages := self 
				loadPrereqsForPackage: startPackage
				relativeTo: startPackage path
				extension: (File splitExtensionFrom: filename)
				loaded: (PluggableSet searchPolicy: SearchPolicy caseInsensitive)
				trail: OrderedCollection new] 
			on: PackageNotFoundSignal
			do: 
				[:ex | 
				"Installation aborted"
				^#()].
	self assert: [newPackages last == startPackage].
	self beNotProcessingEvents.
	
	[newPackages do: 
			[:each | 
			self addPackage: each.
			[
				self basicInstall: each.
				self trigger: #packageInstalled: with: each.
			] ifCurtailed: [self basicUninstall: each].
			self observePackage: each]] 
			ensure: 
				[self beProcessingEvents.
				self loadedChanged].
	^newPackages!

installHere: aString 
	"Same as #install: except that aString is seen as being relative to the current directory
	rather than the image base."

	^self install: (File fullPathOf: aString)!

isLooseMethod: aCompiledMethod
	"Answer whether the argument is a loose method (i.e. one owned by a package other
	than that of its class)."

	^self looseMethods includesKey: aCompiledMethod name!

isLooseResource: aResourceIdentifier
	"Answer whether the argument is a loose resource (i.e. one owned by a package other
	than that of its associated class)."

	^self looseResourceIdentifiers includes: aResourceIdentifier!

isProcessingEvents
	"Private - Answer whether the receiver will act on triggers from the rest of the system that
	it is interested in."

	^processEvents == 0!

loadCompatibilityCheck: aPackage
	"Private - The <Package> argument is about to be filed in. Ensure that no existing package
	managed by the receiver owns any of the objects which the package thinks it owns. This must
	be executed before the package can be taken under the receiver's wing as a managed package.

	All the package's owned object names which overlap with any existing packages are stored in
	the overlappingObjects collection which is raised with the error. Refer to its contents if
	you have any problems."

	| overlappingObjects |
	overlappingObjects := Set new.
	aPackage classNames
		do: [:each | Smalltalk at: each ifPresent: [:class | overlappingObjects add: class]].
	(aPackage globalNames intersection: self packagedGlobals keys)
		do: [:each | Smalltalk associationAt: each ifPresent: [:global | overlappingObjects add: global]].
	"The methods accessor answers a collection of those methods named in the package that can
	be found in the image, since the package is not yet loaded, this will only include the clashing methods"
	overlappingObjects addAll: aPackage methods.
	overlappingObjects notEmpty
		ifTrue: [self errorFileInCompatibilityCheck: aPackage overlap: overlappingObjects].
	^overlappingObjects!

loadedChanged
	"Private - The set of installed packages has changed. Clear down all cached information
	that might be invalidated, and trigger an event for observers."

	self isProcessingEvents ifTrue: [
		self trigger: #loadedChanged]!

loadPackage: aString 
	"Private - Answer the Package object stored in the package file at the specified path. Note that the
	loaded package's contents are NOT loaded and the package is NOT inserted into the receiver's
	collection of packages at this stage."

	^Package fromFile: aString!

loadPrereq: prereqPathString relativeTo: basePathString extension: extensionString loaded: loadedCollection trail: trailCollection 
	"Private - Answer a Collection of Packages which have had to be loaded in for the
	pre-requisite package at the <readableString> path, prereqPath, which is relative to the
	<readableString> path, pathString. The collection also includes the contents of
	loadedCollection."

	| package expectedPathname actualPathname prereqName |
	prereqName := File splitFilenameFrom: prereqPathString.
	"Already installed or already visited?"
	((self includesPackageNamed: prereqName) or: [loadedCollection includes: prereqName]) 
		ifTrue: [^trailCollection].
	"First look using relative path from base"
	expectedPathname := File default: (File fullPathOf: prereqPathString relativeTo: basePathString)
				extension: extensionString.
	actualPathname := (File exists: expectedPathname) 
				ifTrue: [expectedPathname]
				ifFalse: 
					["Try directly in the base folder"
					| localPathname |
					localPathname := File 
								composePath: basePathString
								stem: prereqName
								extension: extensionString.
					(File exists: localPathname) 
						ifTrue: [localPathname]
						ifFalse: [self errorPrerequisiteNotFound: expectedPathname]].
	actualPathname notNil 
		ifTrue: [package := self loadPackage: actualPathname]
		ifFalse: [self errorPackageNotFound: prereqPathString].
	^self 
		loadPrereqsForPackage: package
		relativeTo: package path
		extension: extensionString
		loaded: loadedCollection
		trail: trailCollection!

loadPrereqsForPackage: aPackage relativeTo: pathString extension: extensionString loaded: loadedCollection trail: trailCollection 
	"Private - Load and append pre-requisites of the <Package>, aPackage, to the
	<OrderedCollection>, trailCollection, before appending aPackage to the trail. Answer the
	resulting trail. A package's pre-requisites always appear before itself, and each package
	only appears once in the trail. The <PluggableSet>, loaded, records the names of those
	packages that have previously been loaded while walking the pre-requisites tree, but which
	may not necessarily be in the trail yet, since that is constructed by a post-order
	traversal. The <readableString>, pathString, specifies the original package path, and the
	<readableString>, extensionString, specifies the original package extension (be it PAC or
	PAX, since we try and load the same type of pre-requisite package if we can). This method is
	mutually recursive with #loadPrereq:path:extension:loaded:trail:"

	loadedCollection add: aPackage name.
	aPackage prerequisiteNames do: 
			[:each | 
			self 
				loadPrereq: each
				relativeTo: pathString
				extension: extensionString
				loaded: loadedCollection
				trail: trailCollection].
	trailCollection addLast: aPackage.
	^trailCollection!

looseMethodRemoved: aCompiledMethod 
	"Private - The loose <CompiledMethod> argument has been (or is about to be) removed from the
	system or is no longer loose. Maintain the loose method cache."

	looseMethods notNil ifTrue: [looseMethods removeKey: aCompiledMethod name ifAbsent: []]!

looseMethods
	"Answer an <LookupTable> of all the <CompiledMethod>s which are owned by packages which do
	not own the corresponding method class (i.e. those methods added by a package to classes in
	other packages). This information is cached to speed up the tracing of pre-requisites,
	particular where the whole dependency tree must be calculated (as when uninstalling
	packages). Note that the information may be outdated if requested when event processing is
	disabled, but as this only applies during installation and uninstallation this is not
	material since the cache is then bypassed and is regenerated when event processing is again
	enabled."

	^looseMethods ifNil: [looseMethods := self getLooseMethods]!

looseMethodUpdated: aCompilationResult 
	"There is nothing to do because the loose method cache now holds method 'names' which are
	indirect and remain valid as long as the class name and selector are unchanged, which they
	must be for a #methodUpdated: event"

	!

looseResourceIdentifiers
	"Private - Answer a <Set> of all <ResourceIdentifier>s owned by a package other than that of
	their associated class (by default a rid is owned by the package of its owning class)."

	| answer |
	answer := Set new: 25.
	self packages do: [:p | answer addAll: p looseResourceIdentifiers].
	^answer!

markAllPackagesAsBase
	"Marks all the currently loaded packages as part of the base system. This should normally
	only be called at the end of the image boot."

	self basePackages addAll: self packages!

memberOf: aPackage updatedAt: aNiladicValuable 
	"Private - Inform the <Package> argument that it has been changed and needs to reset its
	prerequisites, but not that its membership has changed. The <niladicValuable> argunment is
	evaluated (if needed) to determine the position in the change log from which the package
	should be considered to have changed. This is used to distinguish between owned objects that
	were modified since the last package save from those which were modified before it."

	aPackage isNil 
		ifTrue: [Package uncommitted resetPrerequisites]
		ifFalse: [aPackage memberUpdatedAt: aNiladicValuable]!

membershipChanged: aPackage 
	"Private - Trigger an ownership notification off the <Package> argument."

	self membershipChanged: aPackage at: [Package sourceManager changesFileSize]!

membershipChanged: aPackage at: aNiladicValuable 
	aPackage isNil 
		ifTrue: [Package uncommitted resetPrerequisites]
		ifFalse: [aPackage membershipChangedAt: aNiladicValuable]!

memberUpdatedIn: aPackage 
	self memberOf: aPackage updatedAt: [Package sourceManager changesFileSize]!

methodRepackaged: aCompiledMethod from: sourcePackage to: destinationPackage
	self assert: [sourcePackage ~~ destinationPackage].
	self trigger: #methodRepackaged:from:to:
		withArguments: {aCompiledMethod. sourcePackage. destinationPackage}!

moveLooseMethod: aCompiledMethod from: sourcePackage to: destinationPackage 
	"Private - Move the loose <CompiledMethod> argument from the <Package>,
	sourcePackage, to the <Package>, destinationPackage."

	sourcePackage == destinationPackage 
		ifTrue: 
			["No-op"
			^false].
	sourcePackage removeLooseMethod: aCompiledMethod.
	self looseMethodRemoved: aCompiledMethod.
	destinationPackage == (self packageOfClass: aCompiledMethod methodClass) 
		ifTrue: [self addPackagedMethod: aCompiledMethod to: destinationPackage]
		ifFalse: [self addLooseMethod: aCompiledMethod to: destinationPackage].
	^true!

moveMethod: method from: source to: destination 
	"Private - Move the packaged (not loose) <CompiledMethod>, method, from the package of its
	method class to the foreign <Package>, destination. Answer whether the method was moved."

	"Note that the destination cannot be nil (i.e. it is not possible to have uncommitted loose
	methods), however the source could be nil if the method's class is currently uncommitted."

	self assert: [destination notNil].
	source == destination 
		ifTrue: 
			["No-op: Add packaged method to its own package"
			^false].
	self addLooseMethod: method to: destination.
	source notNil ifTrue: [source removePackagedMethod: method].
	^true!

newPackage: aString 
	"Private - Add a new <Package> to the collection of packages held by the receiver,
	with the specified <readableString> package filename. Answer the new package."

	| pkg |
	pkg := Package name: aString.
	self addManagedPackage: pkg.
	self loadedChanged.
	^pkg!

noEventsDo: aNiladicBlock
	self beNotProcessingEvents.
	aNiladicBlock ensure: [self beProcessingEvents]!

observePackage: aPackage 
	"Private - Subscribe to certain events from the specified managed <Package>."

	aPackage
		when: #changed
			send: #onPackageChanged:
			to: self
			with: aPackage;
		when: #ownedChanged
			send: #onOwnedChanged:
			to: self
			with: aPackage;
		when: #prerequisitesReset
			send: #onPrerequisitesReset:
			to: self
			with: aPackage!

onClassAdded: aClass
	"The <Class> argument has been newly added to the system. Associate
	it with the default package, if set."

	#todo.	"This event needs an additional parameter which should be the desired package, or nil for default"
	self isProcessingEvents ifTrue: [self addClass: aClass to: self defaultPackage]!

onClassRemoved: aClass 
	"Private - React to aClass being removed from the Smalltalk system. Ensure that none of the
	packages held by the receiver refer to aClass or its methods now it has departed."

	| changed |
	self isProcessingEvents ifFalse: [^self].
	packagedGlobals removeKey: aClass name ifAbsent: [].
	"We must inform all packages, not just the package owning the class, in case any other
	packages include loose methods of the class. In case they do we empty our loose method
	cache."
	self forgetLooseMethods.
	changed := self packages select: [:aPackage | aPackage onClassRemoved: aClass].
	changed do: [:aPackage | aPackage membershipChanged].
	self resetPrerequisites!

onClassRenamed: aClass from: oldSymbol to: newSymbol 
	| changed indexValue changePoint |
	changed := self packages select: 
					[:each | 
					each 
						onClassRenamed: aClass
						from: oldSymbol
						to: newSymbol].
	changed isEmpty ifTrue: [^self].
	"Only trigger events once all packages updated"
	self forgetLooseMethods.
	changePoint := aClass sourceManager changePositionOf: aClass.
	indexValue := [changePoint].
	changed do: [:each | each memberUpdatedAt: indexValue]!

onClassUpdated: aClass 
	"Private - React to aClass being updated. This could be in response to
	its pool dictionaries changing, super class changing, etc. Note that this
	shouldn't changed the packaged status of the class, but may well change
	the prerequisites."

	self isProcessingEvents ifFalse: [^self].
	self memberOf: (self packageOfClass: aClass)
		updatedAt: [self sourceManager changePositionOf: aClass]!

onGlobalRemoved: anAssociation 
	"Private - React to globalName being removed from the Dolphin
	system. Ensure that none of the packages held by the receiver refer
	to globalObject now it has departed."

	| package |
	self isProcessingEvents ifFalse: [^self].
	package := packagedGlobals removeKey: anAssociation key ifAbsent: [].
	package isNil ifFalse: [package basicRemoveGlobalNamed: anAssociation key].
	self membershipChanged: package.
	"Removing a global resets all pre-rereqs"
	self resetPrerequisites!

onGlobalRenamed: anAssociation from: aSymbol
	"Private - A global has been renamed. Ensure that all the receivers packages
	are aware of this change. Note that pre-requisites should be unaffected."

	| global pkg newName |
	pkg := packagedGlobals lookup: aSymbol.
	newName := anAssociation key.
	pkg notNil ifTrue: [packagedGlobals changeKey: aSymbol to: newName].
	self isProcessingEvents ifFalse: [^self].

	"Unfortunately we get the same event for classes as other globals, so we must test,
	also we must be careful not to act on the rename of global aliases."
	global := anAssociation value.
	(global class isMeta and: [global name == newName])
		ifTrue: 
			[self
				onClassRenamed: global
				from: aSymbol
				to: newName]
		ifFalse: [pkg notNil ifTrue: [pkg onGlobalRenamed: anAssociation from: aSymbol]]!

onMethodAdded: aCompilationResult 
	"Private - A new method has been added to the system. Establish
	its package as either the suggestion in the CompilationResult (which
	was passed as a parameter with the original compilation request), or
	the default package if set, or the package of the method's class if
	both are nil."

	| owner default method package |
	self isProcessingEvents ifFalse: [^self].
	method := aCompilationResult method.
	package := aCompilationResult package.
	self assert: [method isLoose not].
	default := self defaultPackage ?? package.
	owner := self packageOfClass: method methodClass.
	(default isNil or: [default == owner]) 
		ifTrue: [self addPackagedMethod: method to: owner]
		ifFalse: 
			[self addLooseMethod: method to: default.
			owner := default].
	aCompilationResult package: owner.
	self memberOf: owner updatedAt: [method changePosition]!

onMethodCategorized: aCompiledMethod 
	"Private - React to aMethod being recategorized in the Dolphin system.
	We may need to maintain change flags, but that should be it."

	| package |
	self isProcessingEvents ifFalse: [^self].
	package := self packageOfMethod: aCompiledMethod.
	package isNil 
		ifTrue: 
			["If not a loose method, then the class has changed (marking its package as changed)"
			aCompiledMethod methodClass isChanged: true]
		ifFalse: 
			["If a loose method, then only the package has changed"
			package isChanged: true]!

onMethodRemoved: aCompiledMethod 
	"Private - The <CompiledMethod> argument is being removed from the Dolphin
	system. Ensure that any package which might own the method is informed."

	| package |
	self isProcessingEvents 
		ifFalse: 
			[self looseMethodRemoved: aCompiledMethod.
			^self].
	package := self packageOfMethod: aCompiledMethod.
	package isNil 
		ifTrue: 
			[package := self packageOfClass: aCompiledMethod methodClass.
			package notNil ifTrue: [package removePackagedMethod: aCompiledMethod].
			"Remove a normal (not loose) method does not change package ownership"
			self memberUpdatedIn: package]
		ifFalse: 
			[self looseMethodRemoved: aCompiledMethod.
			package removeLooseMethod: aCompiledMethod.
			"Removing a loose method does change package ownership"
			self membershipChanged: package]!

onMethodUpdated: aCompilationResult 
	"Private - A pre-existing method has been updated. React by informing the 
	owning package (if any).
	Note that this event is only triggered when an existing method is modified, and 
	as it may previously have been loose we may need to replace the old instance
	in the loose method cache. If it was not loose before, it cannot be now (by
	this action)."

	| package method |
	self isProcessingEvents 
		ifFalse: 
			[self looseMethodUpdated: aCompilationResult.
			^self].
	package := self packageOfMethod: aCompilationResult oldMethod.
	method := aCompilationResult method.
	package isNil 
		ifTrue: 
			[package := self packageOfClass: method methodClass.
			self addPackagedMethod: method to: package]
		ifFalse: [self looseMethodUpdated: aCompilationResult].

	"We don't ask the package to trigger an #ownedChanged event for the addition
	 of new methods, this must be tracked by watching the normal system #methodAdded:
	 event."
	self memberOf: package updatedAt: [method changePosition]!

onOwnedChanged: aPackage 
	"Private - The contents of aPackage have been changed"

	self isProcessingEvents ifTrue: [self trigger: #ownedChanged: with: aPackage]!

onPackageChanged: aPackage
	"Private - Inform any interested parties that the <Package> argument 
	has been marked as changed. Note that this is only fired when a
	change mark is added or removed, not every time a package is changed."

	self isProcessingEvents ifTrue: [
		self trigger: #packageChanged: with: aPackage]!

onPrerequisitesReset: aPackage
	"Private - The <Package> argument has reset its prerequisites. Fire off
	an event to our own observers with that package as an argument."

	self trigger: #prerequisitesReset: with: aPackage!

onPreStripImage
	"Private - Image stripping is in progress. Set up the receiver so as not to interfere."

	packagedGlobals := nil.
	self release.
	self beNotProcessingEvents.
	self forgetLooseMethods.
	"Allow the search policy used for the loose methods cache to be stripped if not used elsewhere"
	AssociationSearchPolicy uninitialize!

packagedGlobals
	"Private - Answer an <IdentityDictionary> which maps the symbolic names of all packaged
	globals to the owning package. This is used during the tracing of package prerequisites."

	^packagedGlobals!

packageNamed: packageName
	"Answer the <Package> held by the receiver whose name matches
	the <readableString>, packageName, or raise an error if there is
	no match."

	^self packageNamed: packageName ifNone: [self errorNotFound: packageName]!

packageNamed: packageName ifNone: absentBlock
	"Answer the <Package> held by the receiver whose name matches
	<readableString>, packageName, or, if there is no such package,
	the result of evaluating the <niladicValuable>, absentBlock.
	Implementation Note: Use a case-insensitive comparison of the package
	names."

	^self packages at: packageName ifAbsent: absentBlock!

packageNames
	"Answer a <collection> of <readableString>s, being the names of all <Package>s
	installed in the system (and managed the receiver)."

	^self packages keys!

packageOfClass: aBehavior
	"Answer the Package held by the receiver which owns aBehavior, or nil if the class is unpackaged."

	^(packagedGlobals lookup: aBehavior instanceClass name)
		ifNil: 
			["Fall back on enumerating the packages."
			self packages detect: [:p | p includesClass: aBehavior] ifNone: []]!

packageOfGlobalNamed: globalName 
	"Answer the package held by the receiver which owns globalName (excluding
	classes) or nil if there isn't one."

	| package |
	package := packagedGlobals at: globalName
				ifAbsentPut: 
					["Fall back on enumerating the packages."
					self packages detect: [:each | each includesGlobalNamed: globalName] ifNone: [^nil]].
	self assert: [package includesGlobalNamed: globalName].
	^package!

packageOfMethod: aCompiledMethod
	"Answer the Package held by the receiver which directly owns the 
	<CompiledMethod> argument as a loose method or nil if it is
	associated with the package of its class (i.e. it is not a loose method).
	Implementation Note: Use the loose method cache if available, otherwise
	do the slower search through each package in turn."

	^looseMethods isNil
		ifTrue: [self packages detect: [:pkg | pkg includesMethod: aCompiledMethod] ifNone: []]
		ifFalse: [looseMethods lookup: aCompiledMethod name]!

packageOfMethodOrItsClass: aMethod
	"Answer the <Package> which owns the <CompiledMethod>, method,
	either directly as a loose method, or indirectly by ownership of its
	class."

	| package |
	package := self packageOfMethod: aMethod.
	^package notNil
		ifTrue: [package]
		ifFalse: [self packageOfClass: aMethod methodClass]!

packageOfResourceIdentifier: aResourceIdentifier 
	"Answer the Package held by the receiver which directly owns aResourceIdentifier as a loose
	resource, or nil if there isn't one."

	^aResourceIdentifier owningPackage!

packageOfResourceIdentifierOrItsClass: aResourceIdentifier 
	"Answer the <Package> managed by the receiver which owns either
	the <ResourceIdentifier> argument, or its class, or nil if resource is
	uncommitted."

	^aResourceIdentifier owningPackage!

packages
	"Answer the <collection> of <Package>s held by the receiver, note that this excluded the
	<Unpackaged> package which is the hypothetical owner of any unpackaged source objects."

	^packages!

prerequisiteNotFoundSignal
	^PrerequisiteNotFoundSignal!

rebaseBasePackagesTo: basePathname
	"Rebase the base image packages so they are relative to basePathname. This may be used
	when an image has been saved to a new directory and one wishes to continue to reference the
	old core packages (usually held under the installatin directory). Note that basePathname
	(if not an absolute path) is treated as being relative to the installation directory NOT the
	image directory or working directory). Hence, a typical rebase can be performed using '.' as
	basePathname"

	self basePackages do: [:each | each  rebaseTo: basePathname ].
	self resetPrerequisites!

release
	"Private - Remove any event registrations the receiver has made 
	(this is not strictly necessary as the registrations are weak, but it hastens 
	the receiver's demise)."

	self class environment removeEventsTriggeredFor: self!

removePackage: aPackage
	"Remove aPackage from the receivers loaded packages. All the packages
	owned objects are removed from the system. This is only possible if no
	other packages require it for their continued operation. Answer aPackage
	or an error if other loaded packages have aPackage as a prerequisite.

	It is important with this method that we do not leave the receiver in a
	corrupt state. As a result once the removal process has started if we
	come across an error knowledge of aPackage is simply dropped which might
	result in classes/methods/globals not owned by any package.

	If aPackage is corrupt, leading to the canRemove: test raising an error
	then you can evaluate basicRemove: directly to remove aPackage."

	aPackage == self systemPackage
		ifTrue: [^self errorRemovingSystemPackage].
	self basicRemovePackage: aPackage.
	self loadedChanged.
	^aPackage.!

renamePackage: aPackage to: aStringPathname 
	"Attempts to rename aPackage held by the receiver to aStringName."

	| existing newName |
	newName := File splitStemFrom: aStringPathname.
	existing := self packageNamed: newName ifNone: [].
	(existing isNil or: [existing == aPackage]) ifFalse: [^self error: 'Package already exists'].
	(self packages)
		removeKey: aPackage name ifAbsent: [];
		at: newName put: aPackage.
	aPackage packageFileName: aStringPathname.
	self
		resetPrerequisites;
		loadedChanged!

resetPrerequisites
	"Private - Inform all packages that their prerequisites may have
	changed, and trigger the generic event announcing that to the world."

	self packages do: [:aPackage | aPackage resetPrerequisites].
	self isProcessingEvents ifTrue: [
		self trigger: #prerequisitesReset]!

resourceRepackaged: aResourceIdentifier from: source to: destination
	"Private - Trigger resource repackaging notifications."

	self assert: [source ~~ destination].
	self
		membershipChanged: source;
		membershipChanged: destination;
		trigger: #resourceRepackaged:from:to: withArguments: {aResourceIdentifier. source. destination}!

setEvents: anEventsCollectionOrNil
	"Private - Set the EventsCollection of the receiver to be anEventsCollectionOrNil.
	Answer the receiver."

	events := anEventsCollectionOrNil!

sortedPackages
	"Answer a SortedCollection of the packages held by the receiver,
	ordered by name."

	^self packages asSortedCollection: Package defaultSortBlock!

sourceManager
	"Answer the receiver's source manager."

	^self class sourceManager!

systemPackage
	"Private - Answer the system package held by the receiver."

	^self class systemPackage!

uninstall: aPackage 
	"Uninstall aPackage and (recursively) any packages dependent upon it, with no questions 	
	asked, deleting all its owned objects from the system.  Run its preuninstall and postuninstall 
	scripts as well."

	aPackage isInstalled ifFalse: [^self].
	aPackage okToUninstall.
	self beNotProcessingEvents.
	
	["First forcibly uninstall all the dependents - if you get a stack overflow here, it's
			probably because two or more packages are cyclically dependent."
	aPackage dependentPackages do: [:each | self uninstall: each].
	Notification signal: ('Uninstalling package <1p>' expandMacrosWith: aPackage name).
	aPackage fileInScript: #preuninstall.
	self basicUninstall: aPackage] 
			ensure: 
				[self
					beProcessingEvents;
					loadedChanged].
	aPackage fileInScript: #postuninstall!

unpackagedClasses
	^self class environment allClasses asIdentitySet difference: self allPackagedClasses asIdentitySet!

versionPackageIfRequired: aPackage 
	"If we are connected to a repository and aPackage is included in the repository then prompt to version it"

	^self!

youShouldBeProcessingEvents
	"Private - The development system is informing us that the user-interface is active, and hence we
	should expect to be responding to events as otherwise change flags, and pre-requisites, etc
	will not be operating correctly."

	self isProcessingEvents ifTrue: [^self].
	Warning
		signal: 'The package system is not currently monitoring change events. This means that changes may not be detected and flagged, caches are not maintained, and pre-requisites may be incorrect. Change monitoring should normally only be suppressed during lengthy install/uninstall operations. A previous error or debugging session may have left the package manager in an inconsistent state. 

	Change monitoring will be enabled if you ignore this warning (recommended)'.
	[self isProcessingEvents] whileFalse: [self beProcessingEvents].
	self clearCachedInformation! !
!PackageManager categoriesFor: #addClass:to:!adding!public! !
!PackageManager categoriesFor: #addGlobalNamed:to:!adding!public! !
!PackageManager categoriesFor: #addLooseMethod:to:!helpers!private! !
!PackageManager categoriesFor: #addManagedPackage:!adding!private! !
!PackageManager categoriesFor: #addMethod:to:!adding!public! !
!PackageManager categoriesFor: #addPackage:!adding!private! !
!PackageManager categoriesFor: #addPackagedMethod:to:!helpers!private! !
!PackageManager categoriesFor: #addResourceIdentifier:to:!adding!public! !
!PackageManager categoriesFor: #allDependentPackagesOf:visited:!accessing!private! !
!PackageManager categoriesFor: #allGlobalAliases!enquiries!public! !
!PackageManager categoriesFor: #allPackagedClasses!accessing!public! !
!PackageManager categoriesFor: #allPackagedGlobalNames!accessing!private! !
!PackageManager categoriesFor: #allSourceObjects!public!source filing! !
!PackageManager categoriesFor: #basePackages!accessing!public! !
!PackageManager categoriesFor: #basicAddPackage:!adding!private! !
!PackageManager categoriesFor: #basicInstall:!operations!private! !
!PackageManager categoriesFor: #basicRemovePackage:!private!removing! !
!PackageManager categoriesFor: #basicUninstall:!private!removing! !
!PackageManager categoriesFor: #beNotProcessingEvents!modes!private! !
!PackageManager categoriesFor: #beProcessingEvents!modes!private! !
!PackageManager categoriesFor: #buildGlobalsMap!helpers!private! !
!PackageManager categoriesFor: #changedPackages!accessing!public! !
!PackageManager categoriesFor: #changeProcessEventsBy:!operations!private! !
!PackageManager categoriesFor: #classRepackaged:from:to:!events!private! !
!PackageManager categoriesFor: #clearCachedInformation!helpers!private! !
!PackageManager categoriesFor: #defaultPackage!accessing!public! !
!PackageManager categoriesFor: #defaultPackage:!accessing!public! !
!PackageManager categoriesFor: #dependentPackagesOf:!private!testing! !
!PackageManager categoriesFor: #duplicatePackageSignal!accessing!private! !
!PackageManager categoriesFor: #errorFileInCompatibilityCheck:overlap:!exceptions!private! !
!PackageManager categoriesFor: #errorNameIsNotUnique:!exceptions!private! !
!PackageManager categoriesFor: #errorPackageNotFound:!exceptions!private! !
!PackageManager categoriesFor: #errorPrerequisiteNotFound:!exceptions!private! !
!PackageManager categoriesFor: #errorRemovingSystemPackage!exceptions!private! !
!PackageManager categoriesFor: #forgetLooseMethods!operations!public! !
!PackageManager categoriesFor: #getEvents!events!private! !
!PackageManager categoriesFor: #getLooseMethods!helpers!private! !
!PackageManager categoriesFor: #globalRepackaged:from:to:!events!private! !
!PackageManager categoriesFor: #includesPackage:!public!searching! !
!PackageManager categoriesFor: #includesPackageNamed:!public!searching! !
!PackageManager categoriesFor: #initialize!initializing!private! !
!PackageManager categoriesFor: #install:!operations!public! !
!PackageManager categoriesFor: #installHere:!operations!public! !
!PackageManager categoriesFor: #isLooseMethod:!public!testing! !
!PackageManager categoriesFor: #isLooseResource:!public!testing! !
!PackageManager categoriesFor: #isProcessingEvents!private!testing! !
!PackageManager categoriesFor: #loadCompatibilityCheck:!helpers!private! !
!PackageManager categoriesFor: #loadedChanged!private!updating! !
!PackageManager categoriesFor: #loadPackage:!binary filing!private! !
!PackageManager categoriesFor: #loadPrereq:relativeTo:extension:loaded:trail:!helpers!private! !
!PackageManager categoriesFor: #loadPrereqsForPackage:relativeTo:extension:loaded:trail:!helpers!private! !
!PackageManager categoriesFor: #looseMethodRemoved:!helpers!private! !
!PackageManager categoriesFor: #looseMethods!accessing!public! !
!PackageManager categoriesFor: #looseMethodUpdated:!helpers!private! !
!PackageManager categoriesFor: #looseResourceIdentifiers!accessing!private! !
!PackageManager categoriesFor: #markAllPackagesAsBase!operations!public! !
!PackageManager categoriesFor: #memberOf:updatedAt:!events!private! !
!PackageManager categoriesFor: #membershipChanged:!events!private! !
!PackageManager categoriesFor: #membershipChanged:at:!events!private! !
!PackageManager categoriesFor: #memberUpdatedIn:!event handling!private! !
!PackageManager categoriesFor: #methodRepackaged:from:to:!events!private! !
!PackageManager categoriesFor: #moveLooseMethod:from:to:!helpers!private! !
!PackageManager categoriesFor: #moveMethod:from:to:!helpers!private! !
!PackageManager categoriesFor: #newPackage:!adding!private! !
!PackageManager categoriesFor: #noEventsDo:!helpers!private! !
!PackageManager categoriesFor: #observePackage:!private!updating! !
!PackageManager categoriesFor: #onClassAdded:!event handling!private! !
!PackageManager categoriesFor: #onClassRemoved:!event handling!private! !
!PackageManager categoriesFor: #onClassRenamed:from:to:!event handling!private! !
!PackageManager categoriesFor: #onClassUpdated:!event handling!private! !
!PackageManager categoriesFor: #onGlobalRemoved:!event handling!private! !
!PackageManager categoriesFor: #onGlobalRenamed:from:!event handling!private! !
!PackageManager categoriesFor: #onMethodAdded:!event handling!private! !
!PackageManager categoriesFor: #onMethodCategorized:!event handling!private! !
!PackageManager categoriesFor: #onMethodRemoved:!event handling!private! !
!PackageManager categoriesFor: #onMethodUpdated:!event handling!private! !
!PackageManager categoriesFor: #onOwnedChanged:!event handling!private! !
!PackageManager categoriesFor: #onPackageChanged:!event handling!private! !
!PackageManager categoriesFor: #onPrerequisitesReset:!event handling!private! !
!PackageManager categoriesFor: #onPreStripImage!class hierarchy-removing!private! !
!PackageManager categoriesFor: #packagedGlobals!accessing!private! !
!PackageManager categoriesFor: #packageNamed:!accessing!public! !
!PackageManager categoriesFor: #packageNamed:ifNone:!accessing!public! !
!PackageManager categoriesFor: #packageNames!accessing!public! !
!PackageManager categoriesFor: #packageOfClass:!public!searching! !
!PackageManager categoriesFor: #packageOfGlobalNamed:!public!searching! !
!PackageManager categoriesFor: #packageOfMethod:!public!searching! !
!PackageManager categoriesFor: #packageOfMethodOrItsClass:!public!searching! !
!PackageManager categoriesFor: #packageOfResourceIdentifier:!public!searching! !
!PackageManager categoriesFor: #packageOfResourceIdentifierOrItsClass:!public!searching! !
!PackageManager categoriesFor: #packages!accessing!public! !
!PackageManager categoriesFor: #prerequisiteNotFoundSignal!constants!public! !
!PackageManager categoriesFor: #rebaseBasePackagesTo:!public!removing! !
!PackageManager categoriesFor: #release!initializing!private! !
!PackageManager categoriesFor: #removePackage:!public!removing! !
!PackageManager categoriesFor: #renamePackage:to:!public!removing! !
!PackageManager categoriesFor: #resetPrerequisites!private!updating! !
!PackageManager categoriesFor: #resourceRepackaged:from:to:!events!private! !
!PackageManager categoriesFor: #setEvents:!events!private! !
!PackageManager categoriesFor: #sortedPackages!accessing!public! !
!PackageManager categoriesFor: #sourceManager!accessing!public! !
!PackageManager categoriesFor: #systemPackage!constants!private! !
!PackageManager categoriesFor: #uninstall:!public!removing! !
!PackageManager categoriesFor: #unpackagedClasses!enquiries!private! !
!PackageManager categoriesFor: #versionPackageIfRequired:!public! !
!PackageManager categoriesFor: #youShouldBeProcessingEvents!helpers!private! !

!PackageManager class methodsFor!

buildSingletonInstance
	| dolphin |
	Notification signal: 'Creating new PackageManager'.
	Current := self basicNew initialize.
	dolphin := self systemPackage.
	Current
		basicAddPackage: dolphin;
		observePackage: dolphin;
		buildGlobalsMap!

current
	"Answer the singleton instance of the receiver."

	Current isNil ifTrue: [self buildSingletonInstance].
	^Current!

initialize
	"Private - Initialize the receiver's class variables.
		self initialize.
	"

	DuplicatePackageSignal := Signal 
				description: 'Package ''%1'' already installed'.
	PackageNotFoundSignal := Signal 
				description: 'Failed to locate Package ''%1'''.
	PrerequisiteNotFoundSignal := NotificationSignal 
				description: 'Package ''%1'' cannot be found'!

new
	"The receiver is a singleton class"

	^self shouldNotImplement!

newSystemPackage
	"Private - Set up and answer the system Package. All existing Classes and Globals are
	assigned to the package. It is assumed that there are no other packages currently defined.
	N.B. This should only ever be used during the boot process."

	| dolphin globalNames all inst |
	Notification signal: 'Creating new system package'.
	inst := self current.
	self assert: [inst packages isEmpty].
	(dolphin := Package name: self systemPackageName)
		basicComment: 'Dolphin Smalltalk Base System.
Copyright (c) Object Arts Ltd. 1997-2016';
		basicScriptAt: #preinstall put: 'Error signal: ''Cannot replace the system package'''.
	all := self environment allClasses.
	all do: [:aClass | dolphin addClass: aClass].
	globalNames := Smalltalk keys.
	globalNames removeAll: (all collect: [:aClass | aClass name]).
	globalNames do: [:globalName | inst addGlobalNamed: globalName to: dolphin].
	dolphin untracedGlobals: {#Transcript}.
	dolphin timestamp: ((File lastWriteTime: dolphin classDefinitionsFileName)
				ifNil: [0]
				ifNotNil: [:filetime | filetime asInteger]).
	dolphin isChanged: false.
	^dolphin!

reset
	"Reset the receivers singleton current instance and SystemPackage."

	Current notNil ifTrue: [Current release].
	Current := nil.
	SystemPackage := nil.!

systemPackage
	"Answer the Package which contains all the base objects of the system."

	SystemPackage isNil ifTrue: [SystemPackage := self newSystemPackage].
	^SystemPackage!

systemPackageName
	"Private - Answer the String name of the Package which owns all
	the system objects."

	^'Core\Object Arts\Dolphin\Base\Dolphin'!

uninitialize
	"Private - Uninitialize the receiver as it is about to be removed from the system."

	self reset.! !
!PackageManager class categoriesFor: #buildSingletonInstance!instance creation!private! !
!PackageManager class categoriesFor: #current!instance creation!public! !
!PackageManager class categoriesFor: #initialize!initializing!private! !
!PackageManager class categoriesFor: #new!instance creation!public! !
!PackageManager class categoriesFor: #newSystemPackage!operations!private! !
!PackageManager class categoriesFor: #reset!operations!public! !
!PackageManager class categoriesFor: #systemPackage!instance creation!public! !
!PackageManager class categoriesFor: #systemPackageName!constants!private! !
!PackageManager class categoriesFor: #uninitialize!class hierarchy-removing!private! !

