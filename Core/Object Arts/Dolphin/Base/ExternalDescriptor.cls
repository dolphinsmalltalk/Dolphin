"Filed out from Dolphin Smalltalk 7"!

Object variableSubclass: #ExternalDescriptor
	instanceVariableNames: 'descriptor'
	classVariableNames: 'CallingConventions ExternalReferenceTypes ExternalValueTypes RetClassIndex RetTypeMask Shared TypeNames TypeSizes'
	poolDictionaries: 'ExtCallArgTypes'
	classInstanceVariableNames: ''!
ExternalDescriptor guid: (GUID fromString: '{87b4c487-026e-11d3-9fd7-00a0cc3e4a32}')!
ExternalDescriptor addClassConstant: 'RetClassIndex' value: 16r4!
ExternalDescriptor addClassConstant: 'RetTypeMask' value: 16r3F!
ExternalDescriptor comment: 'The argument/return types supported by the primitive DLL call function are:

	void 	Only valid as a return type - the method answers self
	lpvoid 	General pointer type, accepts byte objects e.g. Strings (pointer to contents 
		passed), nil (null pointer), integers (passes as address), or ExternalAddresses
		(the contained address is passed, not a pointer to the ExternalAddress object). 
		When used as a return type, the method answers an instance of ExternalAddress.
	lppvoid	Pointer to pointer. Used for functions which take a parameter into which they write
		an address. The corresponding argument must be an ExternalAddress (or other indirection
		object), or an object whose first instance variable is such (e.g. an ExternalStructure).
		The address of the ExternalAddress itself is passed, so that on return it contains the
		address written back by the external function. nil is not a valid argument value.
		As a return type answers a pointer instance of LPVOID (i.e. LPVOID* = void**).
	char	Signed character. Accepts Characters only.
	byte	Unsigned byte. Accepts SmallIntegers only. Passes a 32-bit value
		generated by zero extending the least significant byte. Fails if  not in the
		range 0..255. Zero extends into a positive SmallInteger when a return value.
	sbyte	Signed byte. Accepts SmallIntegers only. Passes a 32-bit value generated
		by sign extending the least significant byte. Fails if not in range -128..127.
		Sign extends into a positive or negative SmallInteger when a return value.
	word 	Unsigned word. As #byte, but 16-bit, acceptable range 0..65535.
		Also accepts a byte object of size 2, which is zero extended to 32-bits.
	sword 	Signed word. As #sbyte, but 16-bit, acceptable range -32768..32767.
		Also accepts a byte object of size 2, which is sign extended to 32-bits.
	dword	Unsigned double word (32-bits), accepts 32-bit Integers. Positive integers
		are passed as unsigned, and negative integers in their two''s complement
		representation.  The largest negative LargeInteger which can be passsed
		is -16r80000000 (or -2147483648) because this is the largest negative number 
		which can be represented in 32-bits in two''s complement notation.
		Also accepts byte objects of length 4, assumed to be in an unsigned bit representation.
		nil is passed as 0. As a return type, answers a SmallInteger, or a LargeInteger if the
		result cannot be represented as a positive SmallInteger (i.e. in 30 bits).
	sdword	Signed double word, accepts any Integer in the range -16r80000000..16r7FFFFFFF
		(i.e. Integer''s with a 32-bit two''s complement representation - all SmallIntegers and
		4-byte LargeIntegers). May also be other byte objects of length 4, which are 
		assumed to contain a 2''s complement 32-bit number.
		As a return type answers a SmallInteger, or, if more than 31-bits are required 
		to represent the two''s complement result, a LargeInteger. Also accepts nil (passed as 0).
	qword	Unsigned quad word. Similar to dword, but 64-bit (i.e. the range is -16r8000000000000000,
		the largest 64-bit two''s complement negative integer, up to 16rFFFFFFFFFFFFFFF the largest positive 
		unsigned 64-bit integer). 8-byte objects are acceptable and assumed to contain the correct unsigned
		bit representation. nil is passed as 0.
	sqword	Signed quad word. Accepts any Integer in the range which can be represented as a
		two''s complement number in 64 bits (i.e. -16r8000000000000000 to 16r7FFFFFFFFFFFFFFF).
		Also accepts 8 byte objects, which are assumed to contain 64-bit two''s complement numbers. 
		nil is passed as 0. As a return type answers the smallest Integer form which can contain 
		the 64-bit two''s complement integer.
	bool	Boolean. As an argument type, accepts true (translated to 1) or false
		(translated to 0). Also accepts SmallInteger values, pushing their host
		machine representation. As a return type, if the result is 0 answers false,
		if the result is non-zero, answers true.
	handle	32-bit handle. Accepts 32-bit integers, nil, or a byte object of size 4. 
		As a return type, answers an ExternalHandle, unless the
		returned handle is NULL, in which case answers ''nil''.
	double	64-bit floating point. Accepts instances of class Float (which contains
		a host machine representation of a double precision floating point number). 
		SmallIntegers may also be passed (they are promoted to the double precision
		floating point representation of their integral value). As a return type,
		answers an instance of class Float.
	lpstr	Pointer to C (null-terminated) ASCII string type. Accepts null terminated byte 
		objects (e.g. Strings, Symbols) or nil (null pointer). When used as a return type, 
		answers a String containing the characters of the C string up to the null terminator. 
		Unlike lpvoid, does not accept integer values as pointers, or ExternalAddress 
		(indirection) objects. If the validation is too tight for your requirements, then 
		use lpvoid. Do not use this return type where an external function is called which 
		expects the caller to assume ownership of the returned string, and to delete it when 
		it is no longer required, as a memory leak will result (use lpvoid instead).
	oop	Object identifier. Any non-SmallInteger can be passed. This parameter type
		is intended for use with the forthcoming User Primitive Kit. The value should
		be treated as an opaque Handle, and should not be stored for later use (it
		may change during a GC). As a return type, answers the object whose Oop is 
		the result. At present it is recommended that you do not use this type.
	float	32-bit floating point. Accepts instances of class Float, or SmallIntegers
		(as #double). The conversion of Floats (64-bit double precision) to #float 
		(32-bit single precision) may result in silent loss of precision. As a return
		type answers an instance of class Float (i.e. promotes to double precision).
	hresult	32-bit signed integer value. Validation as #sdword. As a return type, if less than
		0 (i.e. severity is error), causes the external call primitives to fail with a negative 
		failure reason which is the HRESULT value. This is convenient because it means an
		exception is automatically generated when an external function returns an HRESULT error.
	<struct>	Where <struct> is an ExternalStructure class name. Structure passed by value. Accepts 
		only the exact matching structure class. Again, the ExternalStructure arguments may be
		reference/pointer instances. When used as a return value, an instance of the 
		ExternalStructure class is answered, with the bytes of the returned structure as its contents
		(copied into a ByteArray).
	<struct>*	Where <struct> is an ExternalStructure class name. When used as a return type, a pointer
		instance of the ExternalStructure is answered, with an ExternalAddress pointing at the
		externally stored value as its first instance variable.
	<struct>**Equivalent to lppvoid.
	
Note that in general, the UndefinedObject, nil, is interchangeable with 0, or NULL, when interfacing with external library functions. Nullness can be tested with the #isNull message, with the UndefinedObject and SmallInteger zero answering true.'!
!ExternalDescriptor categoriesForClass!System-Support! !
!ExternalDescriptor methodsFor!

argumentCount
	"Private - Answer the argument count of the external function described by the receiver.
	N.B. This may be one less than the actual number of arguments if the receiver is describing
	a virtual function with implicit 'this' pointer."

	^descriptor at: 2!

argumentIndexFromOffset: anInteger 
	"Private - Convert a zero-based offset into the descriptor array (as used by the VM when marshalling
	the objects onto the stack for an external call) into the index of the corresponding argument. We have
	to take account of the literal indices that are embedded in the descriptor."

	| i offset stop |
	offset := RetClassIndex + 1.
	stop := offset + anInteger.
	i := 0.
	[offset > stop] whileFalse: 
			[| type |
			i := i + 1.
			type := descriptor at: offset.
			offset := offset + 1.
			(self class typeHasArgument: type) ifTrue: [offset := offset + 1]].
	^i!

argumentsDo: operation 
	"Private - Evaluate the dyadic valuable argument, operation, for each of the argument
	types of the receiver, passing the argument type and optional literal parameter#
	as the arguments."

	| i size |
	i := RetClassIndex + 1.
	size := descriptor size.
	[i > size] whileFalse: 
			[| type |
			type := descriptor at: i.
			i := i + 1.
			operation value: type
				value: ((self class typeHasArgument: type) 
						ifTrue: 
							[i := i + 1.
							self at: (descriptor at: i - 1) + 1])]!

argumentsSize
	"Private - Answer the total size, in bytes, that would be occupied by the arguments described 
	by the receiver when pushed onto the machine stack."

	| sum |
	sum := 0.
	self argumentsDo: [:type :class | sum := sum + (self class sizeOf: type type: class)].
	^sum!

argumentTypes
	"Private - Answer a sequenceable collection containing the argument type 
	descriptions for the receiver."

	| types |
	types := Array writeStream: self argumentCount.
	self argumentsDo: [:n :type | types nextPut: (self class nameOf: n type: type)].
	^types contents!

calleeCleans
	"Answer whether the receiver describes a function which pops its own arguments
	before returning (e.g. stdcall)."

	^self convention ~= 1	"cdecl is 1"!

callingConvention
	"Private - Answer the calling convention name of the external function described by the receiver.
	This is an integer enumeration."

	^self class nameOfConvention: self convention!

convention
	"Private - Answer the calling convention type (a small integer)."

	^descriptor first!

description
	"Private - Answer the descriptor string for the external function described by the receiver."

	| stream |
	stream := String writeStream: 60.
	self printDescriptionOn: stream.
	^stream contents!

descriptor: aCollectionOfBytes
	"Private - Set the descriptor byte array for the external function described by the receiver."

	descriptor := aCollectionOfBytes asByteArray!

literals: args
	"Set the literal argument parameters to those in the SequenceableCollection argument, args.
	Answer the receiver."

	args keysAndValuesDo: [:i :e | self at: i put: e]
	!

name
	"Answer the 'name' of the external function described by the receiver."

	^'_'
	!

name: aString 
	"Set the 'name' of the external function described by the receiver to the argument.
	At the moment we discard this."

	^self!

printDescriptionOn: stream
	"Private - Answer the descriptor string for the external function described by the receiver."

	| types |
	stream
		nextPutAll: self callingConvention;
		space;
		nextPutAll: self returnType.
	types := self argumentTypes.
	"types notEmpty ifTrue: [stream nextPut: $,]."
	types do: 
			[:each |
			stream
				space;
				nextPutAll: each]!

printOn: aStream
	"Append a debug description of the receiver to aStream."

	aStream
		basicPrint: self;
		nextPut: $(.
	self printDescriptionOn: aStream.
	aStream nextPut: $)!

retType
	"Private - Answer the return type as a value from the external type enumeration."

	^(descriptor at: 3) bitAnd: RetTypeMask!

returnType
	"Private - Answer the return type name of the external function described by the receiver.
	This is an integer enumeration."

	| type class |
	type := self retType.
	class := (self class typeHasArgument: type) ifTrue: [self at: (descriptor at: RetClassIndex) + 1].
	^self class nameOf: type type: class! !
!ExternalDescriptor categoriesFor: #argumentCount!accessing!private! !
!ExternalDescriptor categoriesFor: #argumentIndexFromOffset:!helpers!private! !
!ExternalDescriptor categoriesFor: #argumentsDo:!accessing!private! !
!ExternalDescriptor categoriesFor: #argumentsSize!accessing!private! !
!ExternalDescriptor categoriesFor: #argumentTypes!accessing!private! !
!ExternalDescriptor categoriesFor: #calleeCleans!public!testing! !
!ExternalDescriptor categoriesFor: #callingConvention!accessing!private! !
!ExternalDescriptor categoriesFor: #convention!accessing!private! !
!ExternalDescriptor categoriesFor: #description!accessing!private! !
!ExternalDescriptor categoriesFor: #descriptor:!accessing!private! !
!ExternalDescriptor categoriesFor: #literals:!accessing!public! !
!ExternalDescriptor categoriesFor: #name!accessing!public! !
!ExternalDescriptor categoriesFor: #name:!accessing!public! !
!ExternalDescriptor categoriesFor: #printDescriptionOn:!accessing!private! !
!ExternalDescriptor categoriesFor: #printOn:!printing!public! !
!ExternalDescriptor categoriesFor: #retType!accessing!private! !
!ExternalDescriptor categoriesFor: #returnType!accessing!private! !

!ExternalDescriptor class methodsFor!

argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which is a String
	specifying a list of argument types in the standard Dolphin format. The return type is
	defaulted to 'uintptr' (i.e. UINT_PTR) and the calling convention to 'stdcall:'."

	^self
		returnType: 'uintptr'
		argumentTypes: argString!

callingConvention: convString returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the arguments
	specifying, respectively, the calling convention, return type, and argument
	types as parseable strings."

	^self fromString: convString, ' ', retString, ' ', argString!

conventionFromName: aString
	"Answer the type name for the specified integer type, or -1 if not recognised."

	^(CallingConventions indexOf: aString)-1!

descriptor: aByteArray literals: aSequenceableCollection
	"Private - Answer an instance of the receiver instantiated from the arguments."

	^(self new: aSequenceableCollection size)
		descriptor: aByteArray;
		literals: aSequenceableCollection;
		yourself!

fromString: aString
	"Answer an instance of the receiver instantiated from the argument, which
	is a Dolphin format external function descriptor, e.g:

		ExternalDescriptor fromString: 'stdcall: hresult Blah GUID* lppvoid'

	Implementation Note: As ExternalDescriptors are immutable, they can be shared
	in order to save space. This facility can be turned off by setting the Shared
	lookup table (which is weak by default) to nil. Bear in mind, however, that
	quite a lot of space might otherwise be occupied by descriptors if there
	are a large number of callback functions in the image."

	Shared isNil ifTrue: [^self newFromString: aString].	
	^Shared at: aString 
		ifAbsentPut: [self newFromString: aString]!

initialize
	"Private - Initialize the class variables of the receiver.
		self initialize
	"

	"Maximum arg type value is currently 63"

	self addClassConstant: 'RetTypeMask' value: ExtCallArgMax.
	self initializeExternalTypes.
	self initializeExternalRefTypes.

	"Remember that bytes and words are still pushed as 32-bit values"
	TypeSizes := #[0 4 4 4 4 4 4 4 4 4 4 8 4 4 4 4 4 4 8 8 4 4 16 8 4 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 8 4 4 4 0 0 0 0 0 0 0 0].
	TypeSizes whileMutableDo: 
			[TypeSizes
				at: ExtCallArgINTPTR + 1 put: VMConstants.IntPtrSize;
				at: ExtCallArgUINTPTR + 1 put: VMConstants.IntPtrSize].
	self assert: [ExternalValueTypes asSortedCollection last < TypeSizes size].
	self initializeCallingConventions.
	self addClassConstant: 'RetClassIndex' value: 4.
	Shared isNil ifTrue: [Shared := WeakLookupTable new]!

initializeCallingConventions
	"Private - All possible calling conventions (not all are supported)"

	CallingConventions := #('stdcall:' 'cdecl:' 'fastcall:' 'thiscall:')!

initializeExternalRefTypes
	"Private - Reference types are the types to be used for the value type with one level of indirection, where the name
	of a struct class appears, this is assumed to be associated with an ExtCallArgLP argument type."

	ExternalReferenceTypes := Array new: ExtCallArgMax + 1.
	ExternalReferenceTypes
		at: ExtCallArgVOID + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgLPPVOID + 1 put: nil;
		at: ExtCallArgCHAR + 1 put: ExtCallArgLPSTR;
		at: ExtCallArgBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgSBYTE + 1 put: ExtCallArgLPVOID;
		at: ExtCallArgWORD + 1 put: #WORD;
		at: ExtCallArgSWORD + 1 put: #SWORD;
		at: ExtCallArgDWORD + 1 put: #DWORD;
		at: ExtCallArgSDWORD + 1 put: #SDWORD;
		at: ExtCallArgUINTPTR + 1 put: #UINT_PTR;
		at: ExtCallArgINTPTR + 1 put: #INT_PTR;
		at: ExtCallArgBOOL + 1 put: #DWORD;
		at: ExtCallArgHANDLE + 1 put: #DWORD;
		at: ExtCallArgDOUBLE + 1 put: #DOUBLE;
		at: ExtCallArgLPSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgOOP + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgFLOAT + 1 put: #FLOAT;
		at: ExtCallArgLPVOID + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgHRESULT + 1 put: #HRESULT;
		at: ExtCallArgLPWSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgQWORD + 1 put: #ULARGE_INTEGER;
		at: ExtCallArgSQWORD + 1 put: #LARGE_INTEGER;
		at: ExtCallArgOTE + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgBSTR + 1 put: ExtCallArgLPPVOID;
		at: ExtCallArgVARIANT + 1 put: #VARIANT;
		at: ExtCallArgDATE + 1 put: #DATE;
		at: ExtCallArgVARBOOL + 1 put: #VARIANT_BOOL;
		at: ExtCallArgGUID + 1 put: #REFGUID;
		at: ExtCallArgSTRUCT + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT4 + 1 put: ExtCallArgLP;
		at: ExtCallArgSTRUCT8 + 1 put: ExtCallArgLP.
	ExternalReferenceTypes isImmutable: true!

initializeExternalTypes
	ExternalValueTypes := LookupTable new.
	ExternalValueTypes
		at: 'sdword' put: ExtCallArgSDWORD;
		at: 'dword' put: ExtCallArgDWORD;
		at: 'uintptr' put: ExtCallArgUINTPTR;
		at: 'intptr' put: ExtCallArgINTPTR;
		at: 'lpvoid' put: ExtCallArgLPVOID;
		at: 'handle' put: ExtCallArgHANDLE;
		at: 'lppvoid' put: ExtCallArgLPPVOID;
		at: 'lpstr' put: ExtCallArgLPSTR;
		at: 'bool' put: ExtCallArgBOOL;
		at: 'double' put: ExtCallArgDOUBLE;
		at: 'float' put: ExtCallArgFLOAT;
		at: 'hresult' put: ExtCallArgHRESULT;
		at: 'char' put: ExtCallArgCHAR;
		at: 'byte' put: ExtCallArgBYTE;
		at: 'sbyte' put: ExtCallArgSBYTE;
		at: 'word' put: ExtCallArgWORD;
		at: 'sword' put: ExtCallArgSWORD;
		at: 'oop' put: ExtCallArgOOP;
		at: 'lpwstr' put: ExtCallArgLPWSTR;
		at: 'bstr' put: ExtCallArgBSTR;
		at: 'qword' put: ExtCallArgQWORD;
		at: 'sqword' put: ExtCallArgSQWORD;
		at: 'ote' put: ExtCallArgOTE;
		at: 'variant' put: ExtCallArgVARIANT;
		at: 'varbool' put: ExtCallArgVARBOOL;
		at: 'guid' put: ExtCallArgGUID;
		at: 'date' put: ExtCallArgDATE.
	"void is only valid as a return type, not an argument type."
	ExternalValueTypes at: 'void' put: ExtCallArgVOID.

	"Init the reverse mapping of the type enumeration to string names"
	TypeNames := Array new: ExtCallArgMax + 1.
	ExternalValueTypes 
		keysAndValuesDo: [:eachKey :eachValue | TypeNames at: eachValue + 1 put: eachKey].
	TypeNames isImmutable: true.

	"Convert a few class types to the special types to save space and time"
	ExternalValueTypes
		at: 'ExternalAddress' put: ExtCallArgLPVOID;
		at: 'ExternalHandle' put: ExtCallArgHANDLE;
		at: 'BSTR' put: ExtCallArgBSTR;
		at: 'VARIANT' put: ExtCallArgVARIANT;
		at: 'SDWORD' put: ExtCallArgSDWORD;
		at: 'DWORD' put: ExtCallArgDWORD;
		at: 'INT_PTR' put: ExtCallArgINTPTR;
		at: 'UINT_PTR' put: ExtCallArgUINTPTR;
		at: 'LPVOID' put: ExtCallArgLPVOID;
		at: 'DOUBLE' put: ExtCallArgDOUBLE;
		at: 'FLOAT' put: ExtCallArgFLOAT;
		at: 'HRESULT' put: ExtCallArgHRESULT;
		at: 'BYTE' put: ExtCallArgBYTE;
		at: 'SBYTE' put: ExtCallArgSBYTE;
		at: 'WORD' put: ExtCallArgWORD;
		at: 'SWORD' put: ExtCallArgSWORD;
		at: 'LPWSTR' put: ExtCallArgLPWSTR;
		at: 'QWORD' put: ExtCallArgQWORD;
		at: 'ULARGE_INTEGER' put: ExtCallArgQWORD;
		at: 'SQWORD' put: ExtCallArgSQWORD;
		at: 'LARGE_INTEGER' put: ExtCallArgSQWORD;
		at: 'GUID' put: ExtCallArgGUID;
		at: 'IID' put: ExtCallArgGUID;
		at: 'CLSID' put: ExtCallArgGUID;
		at: 'VARIANT_BOOL' put: ExtCallArgVARBOOL;
		at: 'DATE' put: ExtCallArgDATE;
		shrink;
		isImmutable: true!

isPointerToStruct: anInteger 
	^anInteger == ExtCallArgLP or: [anInteger == ExtCallArgCOMPTR]!

nameOf: typeOrdinal type: aClass 
	"Answer the type name for the specified type."

	^(self typeHasArgument: typeOrdinal) 
		ifTrue: 
			[aClass name , (((self isPointerToStruct: typeOrdinal) and: [aClass isIndirection not]) 
						ifTrue: ['*']
						ifFalse: [''])]
		ifFalse: [TypeNames at: typeOrdinal + 1]!

nameOfConvention: anInteger
	"Answer the calling convention name for the specified convention type ordinal."

	^CallingConventions at: anInteger + 1!

newFromString: aString 
	"Private - Answer a new, unshared, instance of the receiver instantiated from 
	the argument, which is a Dolphin format external function descriptor, e.g:

		ExternalDescriptor fromString: 'stdcall: hresult GUID* lppvoid'
	"

	| array |
	array := self parseDescriptor: aString.
	^self descriptor: array first literals: array second!

parseArgDesc: aString 
	"Private - Parse the next argument type from the input stream argument, aStream, answering
	an association between the type number and an optional argument (a subclass of ExternalStructure)."

	| qualifier typeName assoc |
	typeName := aString upTo: $*.
	qualifier := aString copyFrom: typeName size + 1 to: aString size.

	"Get an association between a type code for the name and the associated indirection type code or class name"
	assoc := (self typeFromName: typeName ifAbsent: []) 
				ifNil: 
					["Not a built-in type, so try as a class..."
					ExtCallArgSTRUCT -> typeName asSymbol]
				ifNotNil: [:code | code -> (self referenceTypeFor: code)].
	qualifier = '**' ifTrue: [^self parseDoubleIndirection: assoc typeName: typeName].
	qualifier = '*' ifTrue: [^self parseSingleIndirection: assoc].
	^self parseValueType: assoc!

parseCallingConvention: aStream
	"Private - Answer the calling convention number specified by the input stream."

	^self conventionFromName: aStream nextWord!

parseDescriptor: aString
	"Parse a literal string which describes an external function in the standard
	Dolphin format. This is very simplistic pending Smalltalk compiler support."

	| descriptor literals stream argCount returnType |
	stream := aString readStream.
	descriptor := OrderedCollection new: 10.
	descriptor addLast: (self parseCallingConvention: stream).
	descriptor addLast: nil.	"Reserve slot for argument count"
	returnType := self parseArgDesc: stream nextWord.
	descriptor addLast: returnType key.
	descriptor addLast: 0.
	literals := OrderedCollection new.
	returnType value notNil ifTrue: [literals addLast: returnType value].
	argCount := 0.
	stream skipSeparators.
	[stream atEnd] whileFalse: 
			[| argType |
			argType := self parseArgDesc: stream nextWord.
			argCount := argCount + 1.
			descriptor addLast: argType key.
			argType value notNil
				ifTrue: 
					[descriptor addLast: literals size.
					literals addLast: argType value]].
	descriptor at: 2 put: argCount.
	^{descriptor. literals}!

parseDoubleIndirection: assoc typeName: typeName
	| pointerType |
	pointerType := assoc value.
	"If indirection type is #lppvoid or an indirection class, then cannot doubly indirect it"
	(pointerType = ExtCallArgLPPVOID or: 
			[pointerType isInteger not
				and: [assoc key == ExtCallArgSTRUCT and: [(self class environment at: pointerType) isIndirection]]])
		ifTrue: 
			[^self error: ('<1s>: Only one further level of indirection to an indirection type is possible'
						expandMacrosWith: typeName)].
	^ExtCallArgLPPVOID -> nil!

parsePointerToStruct: anAssociation
	| structClass |
	structClass := self class environment at: anAssociation value.
	^(structClass isIndirection and: [anAssociation key == ExtCallArgSTRUCT])
		ifTrue: [ExtCallArgLPPVOID -> nil]
		ifFalse: 
			[((self class environment lookup: #IUnknown)
				ifNil: [ExtCallArgLP]
				ifNotNil: [:unkClass | (structClass includesBehavior: unkClass) ifTrue: [ExtCallArgCOMPTR] ifFalse: [ExtCallArgLP]])
					-> structClass]!

parseSingleIndirection: anAssociation
	| pointerType |
	pointerType := anAssociation value.
	pointerType isNil
		ifTrue: 
			[^self error: ('<1s> cannot be further indirected'
						expandMacrosWith: (self nameOf: anAssociation key type: anAssociation value))].
	^pointerType isInteger not
		ifTrue: [self parsePointerToStruct: anAssociation]
		ifFalse: [pointerType -> nil]!

parseStructArg: assoc 
	| structClass |
	structClass := self environment at: assoc value.
	^(structClass isIndirection 
		ifTrue: [ExtCallArgLP]
		ifFalse: 
			[| bytes |
			bytes := structClass byteSize.
			bytes <= 4 
				ifTrue: [ExtCallArgSTRUCT4]
				ifFalse: [bytes <= 8 ifTrue: [ExtCallArgSTRUCT8] ifFalse: [ExtCallArgSTRUCT]]]) 
			-> structClass!

parseValueType: assoc 
	assoc key == ExtCallArgSTRUCT ifTrue: [^self parseStructArg: assoc].
	^assoc key -> nil!

referenceTypeFor: valueType 
	^ExternalReferenceTypes at: valueType + 1!

returnType: retString argumentTypes: argString
	"Answer an instance of the receiver instantiated from the argument, which
	is a String specifying a list of argument types in the standard Dolphin
	format. The return type is defaulted to 'dword' and the calling convention
	to 'stdcall:'."

	^self
		callingConvention: 'stdcall:'
		returnType: retString
		argumentTypes: argString!

sizeOf: anInteger type: aClass 
	"Private - Answer the size of the specified type."

	^anInteger == ExtCallArgSTRUCT 
		ifTrue: [aClass byteSize]
		ifFalse: [TypeSizes at: anInteger + 1]!

structTypeForSize: anInteger
	"Private - Answer the structure type to use for structures of the specified byte size."

	anInteger <= 8
		ifTrue: 
			[anInteger <= 4 ifTrue: [anInteger > 0 ifTrue: [^ExtCallArgSTRUCT4]] ifFalse: [^ExtCallArgSTRUCT8]].
	^ExtCallArgSTRUCT!

typeFromName: typeName
	"Answer the type code for the specified <readableString> type name."

	^self typeFromName: typeName ifAbsent: [self errorNotFound: typeName]!

typeFromName: typeName ifAbsent: exceptionHandler 
	"Answer the type code for the specified <readableString> type name, 
	or the result of executing the niladic valuable, exceptionHandler, if the
	type is not recognised."

	^ExternalValueTypes at: typeName ifAbsent: [^exceptionHandler value]!

typeHasArgument: ordinalType
	"Private - Answer whether the specified type (identified by ordinal) has an argument
	accompanying it."

	^ordinalType >= ExtCallArgSTRUCT! !
!ExternalDescriptor class categoriesFor: #argumentTypes:!instance creation!public! !
!ExternalDescriptor class categoriesFor: #callingConvention:returnType:argumentTypes:!instance creation!public! !
!ExternalDescriptor class categoriesFor: #conventionFromName:!constants!public! !
!ExternalDescriptor class categoriesFor: #descriptor:literals:!instance creation!private! !
!ExternalDescriptor class categoriesFor: #fromString:!instance creation!public! !
!ExternalDescriptor class categoriesFor: #initialize!development!initializing!private! !
!ExternalDescriptor class categoriesFor: #initializeCallingConventions!development!initializing!private! !
!ExternalDescriptor class categoriesFor: #initializeExternalRefTypes!development!initializing!private! !
!ExternalDescriptor class categoriesFor: #initializeExternalTypes!development!initializing!private! !
!ExternalDescriptor class categoriesFor: #isPointerToStruct:!helpers!private! !
!ExternalDescriptor class categoriesFor: #nameOf:type:!constants!public! !
!ExternalDescriptor class categoriesFor: #nameOfConvention:!constants!public! !
!ExternalDescriptor class categoriesFor: #newFromString:!instance creation!private! !
!ExternalDescriptor class categoriesFor: #parseArgDesc:!parsing!private! !
!ExternalDescriptor class categoriesFor: #parseCallingConvention:!parsing!private! !
!ExternalDescriptor class categoriesFor: #parseDescriptor:!parsing!public! !
!ExternalDescriptor class categoriesFor: #parseDoubleIndirection:typeName:!helpers!private! !
!ExternalDescriptor class categoriesFor: #parsePointerToStruct:!parsing!private! !
!ExternalDescriptor class categoriesFor: #parseSingleIndirection:!helpers!private! !
!ExternalDescriptor class categoriesFor: #parseStructArg:!parsing!private! !
!ExternalDescriptor class categoriesFor: #parseValueType:!parsing!private! !
!ExternalDescriptor class categoriesFor: #referenceTypeFor:!parsing!public! !
!ExternalDescriptor class categoriesFor: #returnType:argumentTypes:!instance creation!public! !
!ExternalDescriptor class categoriesFor: #sizeOf:type:!constants!private! !
!ExternalDescriptor class categoriesFor: #structTypeForSize:!constants!private! !
!ExternalDescriptor class categoriesFor: #typeFromName:!constants!public! !
!ExternalDescriptor class categoriesFor: #typeFromName:ifAbsent:!constants!public! !
!ExternalDescriptor class categoriesFor: #typeHasArgument:!enquiries!private! !

