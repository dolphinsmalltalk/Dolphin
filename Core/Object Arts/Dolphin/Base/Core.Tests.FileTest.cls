"Filed out from Dolphin Smalltalk 7"!

Core.Tests.DolphinTest subclass: #'Core.Tests.FileTest'
	instanceVariableNames: 'tempFile'
	classVariableNames: ''
	imports: #(#{OS.Win32Constants} #{OS.CRTConstants})
	classInstanceVariableNames: ''
	classConstants: {}!
Core.Tests.FileTest guid: (Core.GUID fromString: '{26ae9922-21e2-489a-845c-3c1dc1c2a3cf}')!
Core.Tests.FileTest comment: ''!
!Core.Tests.FileTest categoriesForClass!Unclassified! !
!Core.Tests.FileTest methodsFor!

buildTestPathOfLength: anInteger
	| maxPath |
	maxPath := String writeStream.
	maxPath nextPutAll: 'c:\'.
	0 to: anInteger - 8 do: [:i | maxPath nextPut: ('abcdefghij\' at: i % 11 + 1)].
	maxPath := maxPath contents.
	maxPath last = $\ ifTrue: [maxPath := maxPath allButLast , 'a'].
	maxPath := maxPath , '.txt'.
	self assert: maxPath size equals: anInteger.
	^maxPath!

createTestDirectories
	| dir |
	File createDirectoryPath: 'c:\FileTest1\EmptyLeaf'.
	dir := 'c:\FileTest1\LeafWithFile\'.
	File createDirectoryPath: dir.
	(FileStream write: dir , 'Blah.txt')
		nextPutAll: 'Blah';
		close.
	dir := 'c:\FileTest1\LeafWithFiles\'.
	File createDirectoryPath: dir.
	(FileStream write: dir , 'Blah1.txt')
		nextPutAll: 'Blah';
		close.
	(FileStream write: dir , 'Blah2.txt')
		nextPutAll: 'Blah blah';
		close.
	File createDirectoryPath: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	dir := 'c:\FileTest1\BranchWithEmptyLeaves\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	File createDirectoryPath: dir , '\EmptyLeaf1'.
	(FileStream write: dir , 'blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	(FileStream write: dir , 'blah1.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , 'blah2.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	(FileStream write: dir , 'blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	File createDirectoryPath: dir , 'EmptyLeaf1'.
	File createDirectoryPath: dir , 'EmptyLeaf2'.
	(FileStream write: dir , 'blah1.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , 'blah2.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithLeafWithFile\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir , 'LeafWithFile'.
	(FileStream write: dir , '\LeafWithFile\blah.txt')
		nextPutAll: 'Blah blah blah';
		close.
	dir := 'c:\FileTest1\BranchWithLeafWithFiles🐬\'.
	File createDirectoryPath: dir.
	File createDirectoryPath: dir , 'LeafWithFiles'.
	(FileStream write: dir , '\LeafWithFiles\blah1.txt')
		nextPutAll: 'Blah blah blah';
		close.
	(FileStream write: dir , '\LeafWithFiles\blah2.txt')
		nextPutAll: 'Blah blah blah';
		close!

deleteDirectory: aString
	self assert: (File isDirectory: aString).
	File deleteDirectory: aString.
	self assert: (File exists: aString) not!

deleteTestDirectories
	File deleteDirectory: 'c:\FileTest1\'!

maxFname
	^_MAX_FNAME!

maxPath
	^File maxPath!

printFilenameOfLength: anInteger on: path
	(1 to: anInteger) do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))].
	path nextPut: $..
	(1 to: _MAX_EXT - 1) do: [:i | path nextPut: (Character codePoint: $a codePoint + (i % 10))]!

relativePathOf: a to: b
	^File relativePathOf: a to: b!

removeDirectory: aString
	"Private - This stub method was auto-generated by the Dolphin debugger and remains to be correctly implemented."

	self assert: (File isDirectory: aString).
	File removeDirectory: aString.
	self assert: (File exists: aString) not!

tearDown
	[self deleteTestDirectories] on: OS.Win32Error do: [:e | ].
	tempFile
		ifNotNil: [
			[tempFile close.
			File delete: tempFile name] on: OS.Win32Error do: [:e | ]]!

test64BitSeek
	"Tests #755"

	| dist pointer |
	tempFile := File temporary.
	0 to: 31
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := tempFile seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := tempFile seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := tempFile seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	32 to: 62
		do: 
			[:i |
			dist := 2 raisedToInteger: i.
			pointer := tempFile seek: dist sense: FILE_BEGIN.
			self assert: pointer equals: dist.
			pointer := tempFile seek: -1 sense: FILE_CURRENT.
			self assert: pointer equals: dist - 1.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist.
			pointer := tempFile seek: 1 sense: FILE_CURRENT.
			self assert: pointer equals: dist + 1.
			pointer := tempFile seek: dist negated sense: FILE_CURRENT.
			self assert: pointer equals: 1].
	pointer := tempFile seek: -1 sense: FILE_CURRENT.
	self assert: pointer identicalTo: 0.
	"As the 64-bit offset is signed, the maximum seek offset is 2^63-1"
	self should: [tempFile seek: 2 ** 63 sense: FILE_BEGIN] raise: Error.
	"Test the condition where the low-word of the return is 16rFFFFFFFF, so GetLastError() is needed to disambiguate from an error condition."
	dist := 2 ** 32 - 1.
	pointer := tempFile seek: dist sense: FILE_BEGIN.
	"Now test maximum seek distance"
	dist := 2 ** 63 - 1.
	pointer := tempFile seek: dist sense: FILE_BEGIN.
	self assert: pointer equals: dist.
	"Although not really a negative seek, it would cause a 64-bit signed file pointer to go negative"
	self
		should: [tempFile seek: 1 sense: FILE_CURRENT]
		raise: FileException
		matching: [:ex | ex statusCode = 131	"ERROR_NEGATIVE_SEEK"].
	pointer := tempFile seek: dist negated sense: FILE_CURRENT.
	self assert: pointer equals: 0!

testClassAppendPathSeparator
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	| unicode |
	self assert: (File appendPathDelimiter: 'c:\') equals: 'c:\'.
	self assert: (File appendPathDelimiter: 'c:/') equals: 'c:/'.
	self assert: (File appendPathDelimiter: 'c:.') equals: 'c:.\'.
	self assert: (File appendPathDelimiter: '') equals: '\'.
	unicode := 'a' , $\x1F595 asUtf8String.
	self assert: (File appendPathDelimiter: unicode) equals: unicode , '\'.
	self assert: (File appendPathDelimiter: 'a\') equals: 'a\'.
	self assert: (File appendPathDelimiter: 'a\\') equals: 'a\\'.
	self assert: (File appendPathDelimiter: '\') equals: '\'.
	self assert: (File appendPathDelimiter: '/') equals: '/'.
	self assert: (File appendPathDelimiter: 'a/') equals: 'a/'!

testClassDefaultExtension
	| s s2 |
	#(#('' '' '') #('a.' '' 'a') #('a.' '.' 'a.') #('a' '' 'a') #('a' '.b' 'a.b') #('a.' 'b' 'a.b') #('a.' '.b' 'a.b') #('a.b' '.c' 'a.b') #('abc' 'txt' 'abc.txt') #('abc.def\xyz' '.txt' 'abc.def\xyz.txt') #('abc.d\xy' 'txt' 'abc.d\xy.txt') #('x\' '🐬' 'x\.🐬') #('文字化け\你🐬好' 'dll' '文字化け\你🐬好.dll') #('x\abc.a🐬' 'txt' 'x\abc.a🐬'))
		do: 
			[:each |
			| actual |
			actual := File default: each first extension: each second.
			self assert: actual equals: each last.
			actual := File default: each first asUtf16String extension: each second asUtf16String.
			self assert: actual equals: each last].
	"Long paths"
	s := String writeStream.
	s nextPutAll: 'c:'.
	10 timesRepeat: 
			[s
				nextPut: $\;
				nextPutAll: GUID newUnique idlString].
	s := s contents.
	self assert: s size > File maxPath.
	s2 := File default: s extension: 'txt'.
	self assert: s2 equals: s , '.txt'.
	s2 := File default: s extension: '.blah'.
	self assert: s2 equals: s , '.blah'!

testClassPathExtension
	| s s2 |
	#(#('' '' '') #('' 'a' '.a') #('' '.a' '.a') #('a' '' 'a') #('a.' '' 'a') #('a' 'b' 'a.b') #('a' '.b' 'a.b') #('a.b' 'c' 'a.c') #('a.exe' '.dll' 'a.dll') #('c:' 'bat' 'c:.bat') #('\' '.cmd' '\.cmd') #('ab\cd.exe' 'dll' 'ab\cd.dll') #('a\' 'b' 'a\.b') #('a.b' '' 'a') #('\a\b\.c' '' '\a\b\') #('a.longlonglonglongextension' '.evenlongerlonglonglonglongextension' 'a.evenlongerlonglonglonglongextension') #('c:\wibble\wobble' '.blah' 'c:\wibble\wobble.blah') #('文字化け.txt' '你🐬好' '文字化け.你🐬好') #('文字化け.你🐬好' '.txt' '文字化け.txt'))
		do: 
			[:each |
			| actual |
			actual := File path: each first extension: each second.
			self assert: actual equals: each last].
	"Long paths"
	s := String writeStream.
	s nextPutAll: 'c:'.
	10 timesRepeat: 
			[s
				nextPut: $\;
				nextPutAll: GUID newUnique idlString].
	s := s contents.
	self assert: s size > File maxPath.
	s2 := File path: s extension: 'txt'.
	self assert: s2 equals: s , '.txt'.
	s2 := File path: s extension: '.blah'.
	self assert: s2 equals: s , '.blah'!

testClassRelativePathOfTo
	"N.B. To path is assumed to be a directory only if it has a trailing slash, *otherwise the last portion is ignored*"

	self assert: (self relativePathOf: '.' to: '.') equals: '.'.
	self assert: (self relativePathOf: '..' to: '.') equals: '..'.
	self assert: (self relativePathOf: '..\' to: '.') equals: '..\'.
	self assert: (self relativePathOf: '..' to: '.\') equals: '..'.
	self assert: (self relativePathOf: '.' to: '..') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: '.\' to: '..') equals: ''.
	self assert: (self relativePathOf: '.' to: '..\') equals: '.'.
	self assert: (self relativePathOf: '.\' to: '..\') equals: ''.
	self assert: (self relativePathOf: 'c:\' to: 'd:\') equals: 'c:\'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1\') equals: 'blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\1.txt') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2\') equals: '..\1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\blah.txt' to: 'c:\2.txt') equals: '1\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1') equals: '1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\1\') equals: '11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21\') equals: '..\..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21') equals: '..\1\11\blah.txt'.
	self assert: (self relativePathOf: 'c:\1\11\blah.txt' to: 'c:\2\21.txt') equals: '..\1\11\blah.txt'.

	"Example from MS IMoniker documentation"
	self assert: (self relativePathOf: 'c:\projects\secret\art\pict1.bmp'
				to: 'c:\projects\secret\docs\chap1.txt')
		equals: '..\art\pict1.bmp'.
	self assert: (self relativePathOf: 'c:\projects\secret\docs\chap1.txt'
				to: 'c:\projects\secret\art\pict1.bmp')
		equals: '..\docs\chap1.txt'.
	"A common type of useage in Dolphin (image relative path)"
	self assert: (self
				relativePathOf: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax.pac'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax.pac'.
	"Non-canonical path with redundant components - note result is not canonical either"
	self
		assert: (File fullPathOf: (self
						relativePathOf: 'd:\dummy\..\object arts\dev\dummy\..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
						to: 'd:\object arts\dev\dolphin5\')
				relativeTo: 'd:\object arts\dev\dolphin5\')
		equals: 'd:\object arts\dev\dolphin5\Packages\Dolphin\Database\Database Connection.pax'.

	"Already a relative path (therefore fails and answers first argument)"
	self assert: (self relativePathOf: 'Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '.\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: 'Packages\Dolphin\Database\Database Connection.pax'.
	self assert: (self relativePathOf: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'
				to: 'd:\object arts\dev\dolphin5\')
		equals: '..\dolphin5\Packages\Dolphin\Database\Database Connection.pax'!

testCommonPrefixOfAnd
	self
		assert: ((File commonPrefixOf: OS.KernelLibrary default moduleFileName
				and: OS.UserLibrary default moduleFileName) sameAs: SessionManager current systemDirectory).
	self
		assert: (File commonPrefixOf: 'D:\dev\Dolphin\DolphinVM7.DLL' and: 'C:\dev\Dolphin\DolphinVM7.DLL')
				isEmpty!

testDeleteDirectory
	self createTestDirectories.
	self deleteDirectory: 'c:\FileTest1\EmptyLeaf'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	self deleteDirectory: 'c:\FileTest1\LeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeafAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithEmptyLeavesAndFiles\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFile\'.
	self deleteDirectory: 'c:\FileTest1\BranchWithLeafWithFiles🐬\'!

testForDirectoriesIn
	| all windir |
	all := OrderedCollection new.
	windir := SessionManager current windowsDirectory.
	File forDirectoriesIn: windir do: [:each | all add: each fileName asLowercase].
	self assert: (all includes: 'system32').
	self assert: (all includes: 'system').
	self deny: (all includes: '.').
	self deny: (all includes: '..').
	all do: 
			[:each |
			| dirPath |
			dirPath := File composePath: windir subPath: each.
			self assert: (File isDirectory: dirPath)]!

testMakePath
	| filename split |
	self assert: (File makePath: #('c:' 'a/b 2/c/' 'a file' '.anextension'))
		equals: 'c:a/b 2/c/a file.anextension'.
	self assert: (File makePath: #('c' '\dir' 'file' 'txt')) equals: 'c:\dir\file.txt'.
	self assert: (File makePath: #(nil nil nil nil)) equals: ''.
	self assert: (File makePath: #('' '' '' '')) equals: ''.
	self assert: (File makePath: #('c' '' '' '')) equals: 'c:'.
	self assert: (File makePath: #('c' 'abc' '' '')) equals: 'c:abc\'.
	self assert: (File makePath: #('c' '' 'file' '')) equals: 'c:file'.
	self assert: (File makePath: #('c' '' '' 'txt')) equals: 'c:.txt'.
	self assert: (File makePath: #('c' '' 'a b c' 'txt')) equals: 'c:a b c.txt'.
	self assert: (File makePath: #('c' 'a/b' 'file' '')) equals: 'c:a/b\file'.
	self assert: (File makePath: #('c' '\' '' '')) equals: 'c:\'.
	self assert: (File makePath: #('' 'a\b' '' '')) equals: 'a\b\'.
	self assert: (File makePath: #('' '' 'file' '')) equals: 'file'.
	self assert: (File makePath: #('' '' '' 'txt')) equals: '.txt'.
	"Shouldn't matter if the filename is notionally too long"
	filename := String writeStream.
	self printFilenameOfLength: self maxFname * 2 on: filename.
	filename := filename contents.
	split := filename subStrings: $..
	self assert: (File makePath: {nil. nil. split first. split second}) equals: filename!

testPathName
	| expected actual |
	"We'll get a long path name"
	expected := '\\?\' , (File change: SessionManager current imageFileName extension: 'chg').
	actual := SourceManager default changesStream file pathName.
	self assert: actual equals: expected!

testRemoveDirectory
	self createTestDirectories.
	self removeDirectory: 'c:\FileTest1\EmptyLeaf'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaf\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf1'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\EmptyLeaf2'.
	self removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'.
	"Presense of sub-directories or files should prevent remove working"
	self should: [File removeDirectory: 'c:\FileTest1\LeafWithFile\'] raise: OS.Win32Error.
	self should: [File removeDirectory: 'c:\FileTest1\BranchWithEmptyLeaves\'] raise: OS.Win32Error!

testRemoveExtension
	| path |
	self should: [File removeExtension: nil] raise: Error.
	self assert: (File removeExtension: 'a.') equals: 'a'.
	self assert: (File removeExtension: '.exe') equals: ''.
	self assert: (File removeExtension: '.') equals: ''.
	self assert: (File removeExtension: '') equals: ''.
	self assert: (File removeExtension: '1234.1234.exe') equals: '1234.1234'.
	self assert: (File removeExtension: '1234.1234.+') equals: '1234.1234'.
	self assert: (File removeExtension: 'a.b\c') equals: 'a.b\c'.
	self assert: (File removeExtension: 'a.b\') equals: 'a.b\'.
	self assert: (File removeExtension: 'c:/a/b.txt') equals: 'c:/a/b'.
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname on: path.
	path := path contents.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first.
	"Doesn't matter if the path is notionally too long"
	path := self buildTestPathOfLength: self maxPath * 2.
	self assert: (File removeExtension: path) equals: (path subStrings: $.) first!

testRemovePathDelimiter
	self assert: (File removePathDelimiter: '') equals: ''.
	self assert: (File removePathDelimiter: '/') equals: ''.
	self assert: (File removePathDelimiter: '//') equals: '/'.
	self assert: (File removePathDelimiter: '\') equals: ''.
	self assert: (File removePathDelimiter: '\/') equals: '\'.
	self assert: (File removePathDelimiter: '.') equals: '.'.
	self assert: (File removePathDelimiter: './') equals: '.'.
	self assert: (File removePathDelimiter: 'c:') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\') equals: 'c:'.
	self assert: (File removePathDelimiter: 'c:\blah.txt') equals: 'c:\blah.txt'.
	"Test with non-ASCII chars and characters outside the BMP"
	#('c:\a🐬' 'c:\a🐬b' 'c:\a£' 'c:\a£b') do: 
			[:each |
			self assert: (File removePathDelimiter: each) equals: each.
			self assert: (File removePathDelimiter: each , '\') equals: each]!

testShortPath
	| sysdir tmpDir tmpFile |
	"This test will only work if short filenames are enabled for the volume on which temp files are stored, and we cannot guarantee this is the case on build machines, nor is there an API that provides a definite answer as to whether short filenames are enabled on a particular volume."
	self skipIfCiBuild.
	sysdir := SessionManager current systemDirectory.
	self assert: (File shortPathOf: sysdir) asAnsiString equals: sysdir.
	tmpDir := File tempPath , GUID newUnique asString , Character dolphin asUtf8String.
	tmpFile := File composePath: tmpDir subPath: $\x1F595 asUtf8String , '.txt'.
	File createDirectory: tmpDir.
	
	[| short |
	(File open: tmpFile mode: #create) close.
	short := File shortPathOf: tmpFile.
	self deny: short equals: tmpFile.
	"This will fail if the short name still includes unicode"
	short := short asAnsiString.
	self assert: (File exists: short)]
			ensure: [File deleteDirectory: tmpDir]!

testSniffEncoding
	tempFile := File temporary.
	{Utf16String.Bom.
		Utf16String.Bom , 'even' asAnsiString asByteArray.
		Utf16String.Bom , Character dolphin asUtf8String asByteArray.
		('a ' asAnsiString , Character dolphin asUtf16String) asByteArray.
		'a £' asUtf16String asByteArray} do: 
				[:each |
				tempFile
					size: 0;
					write: each.
				self assert: tempFile sniffEncoding equals: String.EncodingUtf16.
				self assert: tempFile position
					equals: ((each beginsWith: Utf16String.Bom) ifTrue: [Utf16String.Bom size] ifFalse: [0])].
	{Utf8String.Bom.
		Utf8String.Bom , $£ asAnsiString asByteArray.
		'a b c ' asByteArray.
		$£ asUtf8String asByteArray.
		('a ' , Character dolphin asUtf8String) asByteArray} do: 
				[:each |
				tempFile
					size: 0;
					write: each.
				self assert: tempFile sniffEncoding equals: String.EncodingUtf8.
				self assert: tempFile position
					equals: ((each beginsWith: Utf8String.Bom) ifTrue: [Utf8String.Bom size] ifFalse: [0])].
	{Utf16String.Bom , 'odd' asAnsiString asByteArray. $£ asAnsiString asByteArray} do: 
			[:each |
			tempFile
				size: 0;
				write: each.
			self assert: tempFile sniffEncoding equals: String.EncodingAnsi.
			self assert: tempFile position equals: 0]!

testSplitDriveFrom
	self should: [File splitDriveFrom: nil] raise: Error.
	self assert: (File splitDriveFrom: 'c:\a\a2/b.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'a\b.txt') equals: ''.
	self assert: (File splitDriveFrom: 'b.txt') equals: ''.
	self assert: (File splitDriveFrom: '.txt') equals: ''.
	self assert: (File splitDriveFrom: '.') equals: ''.
	self assert: (File splitDriveFrom: '') equals: ''.
	self assert: (File splitDriveFrom: 'c:/a b\c d.txt') equals: 'c:'.
	self assert: (File splitDriveFrom: 'd:\') equals: 'd:'.
	self assert: (File splitDriveFrom: 'e:') equals: 'e:'.
	self assert: (File splitDriveFrom: 'cons:') equals: ''!

testSplitExtensionFrom
	| path ext unicode |
	self should: [File splitExtensionFrom: nil] raise: Error.
	unicode := $\x1F595 asUtf16String , '2'.
	self assert: (File splitExtensionFrom: 'c:\a\a2/b.' , unicode) equals: unicode.
	self assert: (File splitExtensionFrom: 'a\b.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: 'b.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: 'b.') equals: ''.
	self assert: (File splitExtensionFrom: '.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: '.') equals: ''.
	self assert: (File splitExtensionFrom: '') equals: ''.
	self assert: (File splitExtensionFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitExtensionFrom: 'c:/a b\c d.txt') equals: 'txt'.
	self assert: (File splitExtensionFrom: '1234.1234.exe') equals: 'exe'.
	self assert: (File splitExtensionFrom: 'a.b\c') equals: ''.
	self assert: (File splitExtensionFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: self maxPath.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"The CRT functions works even if the path is too long because we ignore everything but the extension"
	path := path , 'x'.
	self assert: (File splitExtensionFrom: path) equals: 'txtx'.
	path := self buildTestPathOfLength: self maxPath * 2.
	self assert: (File splitExtensionFrom: path) equals: 'txt'.
	"Try a very filename with very long extension (of max length)."
	path := String writeStream.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	ext := (path subStrings: $.) last.
	self assert: (File splitExtensionFrom: path) equals: ext.
	"Works even if extension is notionally too large"
	path := path , ext.
	self assert: (File splitExtensionFrom: path) equals: ext , ext!

testSplitFilenameFrom
	| path unicode |
	self should: [File splitFilenameFrom: nil] raise: Error.
	self assert: (File splitFilenameFrom: '.') equals: '.'.
	self assert: (File splitFilenameFrom: 'c:\a\a2/b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'a\b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'b.txt') equals: 'b.txt'.
	self assert: (File splitFilenameFrom: 'b.') equals: 'b.'.
	self assert: (File splitFilenameFrom: '.txt') equals: '.txt'.
	self assert: (File splitFilenameFrom: '') equals: ''.
	self assert: (File splitFilenameFrom: 'c:\a\b\') equals: ''.
	unicode := 'c ' , $\x1F595 asUtf16String , ' d.txt'.
	self assert: (File splitFilenameFrom: 'c:/a b\' , unicode) equals: unicode.
	self assert: (File splitFilenameFrom: '1234.1234.exe') equals: '1234.1234.exe'.
	self assert: (File splitFilenameFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitFilenameFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: self maxPath.
	self assert: (File splitFilenameFrom: path) equals: (path subStrings: $\) last.
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	self assert: (File splitFilenameFrom: path) equals: (path copyFrom: 4)!

testSplitStemFrom
	| path |
	self should: [File splitStemFrom: nil] raise: Error.
	self assert: (File splitStemFrom: '.') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\a2/b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'a\b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'b.txt') equals: 'b'.
	self assert: (File splitStemFrom: 'b.') equals: 'b'.
	self assert: (File splitStemFrom: '.txt') equals: ''.
	self assert: (File splitStemFrom: '') equals: ''.
	self assert: (File splitStemFrom: 'c:\a\b\') equals: ''.
	self assert: (File splitStemFrom: 'c:/a b\c d.txt') equals: 'c d'.
	self assert: (File splitStemFrom: '1234.1234.exe') equals: '1234.1234'.
	self assert: (File splitStemFrom: 'a.b\c') equals: 'c'.
	self assert: (File splitStemFrom: 'a.b\') equals: ''.
	path := self buildTestPathOfLength: self maxPath.
	self assert: (File splitStemFrom: path) equals: ((path subStrings: $\) last upTo: $.).
	"Try a very long filename (> max length), this will still work."
	path := String writeStream.
	path nextPutAll: 'c:\'.
	self printFilenameOfLength: self maxFname * 2 on: path.
	path := path contents.
	self assert: (File splitStemFrom: path) equals: ((path copyFrom: 4) upTo: $.)! !
!Core.Tests.FileTest categoriesFor: #buildTestPathOfLength:!helpers!private! !
!Core.Tests.FileTest categoriesFor: #createTestDirectories!helpers!private! !
!Core.Tests.FileTest categoriesFor: #deleteDirectory:!helpers!public! !
!Core.Tests.FileTest categoriesFor: #deleteTestDirectories!private!Running! !
!Core.Tests.FileTest categoriesFor: #maxFname!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #maxPath!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #printFilenameOfLength:on:!helpers!private! !
!Core.Tests.FileTest categoriesFor: #relativePathOf:to:!helpers!public! !
!Core.Tests.FileTest categoriesFor: #removeDirectory:!helpers!private! !
!Core.Tests.FileTest categoriesFor: #tearDown!private!Running! !
!Core.Tests.FileTest categoriesFor: #test64BitSeek!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testClassAppendPathSeparator!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testClassDefaultExtension!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testClassPathExtension!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testClassRelativePathOfTo!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testCommonPrefixOfAnd!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testDeleteDirectory!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testForDirectoriesIn!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testMakePath!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testPathName!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testRemoveDirectory!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testRemoveExtension!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testRemovePathDelimiter!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testShortPath!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testSniffEncoding!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testSplitDriveFrom!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testSplitExtensionFrom!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testSplitFilenameFrom!public!unit tests! !
!Core.Tests.FileTest categoriesFor: #testSplitStemFrom!public!unit tests! !

