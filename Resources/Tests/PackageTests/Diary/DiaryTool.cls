"Filed out from Intuitive Smalltalk"!

Tool subclass: #DiaryTool
	instanceVariableNames: 'diary filteredDiaryEventsModel '
	classVariableNames: ''
	poolDictionaries: ''!

DiaryTool class instanceVariableNames: ''!

!DiaryTool categoriesForClass!No category! !

!DiaryTool methodsFor!

addDiaryEvent
	"A command handler to create a new DiaryEvent, edit it, and add it to the diary associated with
	the receiver. In general such a command will originate from one or more command sources such as
	menus, toolbar buttons, push buttons etc."

	| diaryEventModel |

	"We'll use a DiaryEventEditor tool to edit a newly created DiaryEvent. This tool requires
	that the event first be wrapped in a ValueModel"
	diaryEventModel := DiaryEvent new asValue.

	"Create the event editor and show it in a dialog"
	(DiaryEventEditor on: diaryEventModel) inDialog notNil ifTrue: [
		"Ok was pressed so add the newly edited event into our diary"
		self diary addDiaryEvent: diaryEventModel value ]!

buildShellWithView: aView
	"Private - Builds and answers a default shell wrapping aView. The shell is not
	yet connected to the receiver. This method is for demonstration purposes only
	and will be replaced by one automatically generated by the Dolphin ViewComposer
	when this becomes available. 
	For now, you probably don't need to understand what follows"

	| view toolbarView shell |

	toolbarView := CompositeToolbarView new.

	view := BarDecoratorView new
		bar: toolbarView;
		subView: aView;
		yourself.

	shell := Shell new
		subView: view;
		yourself.

	toolbarView
		addSeparator;
		addItem: (ToolbarSystemButton standardImage: 'StdFileNew' command: #addDiaryEvent description: 'New Event');
		addItem: (ToolbarSystemButton standardImage: 'StdDelete' command: #removeDiaryEvent description: 'Delete Event');
		stopWaiting.

	^shell

!

buildView
	"Private - Builds and answers a default view for receiver that is not
	yet connected to it. This method is for demonstration purposes only
	and will be replaced by one automatically generated by the Dolphin ViewComposer
	when this becomes available. 
	For now, you probably don't need to understand what follows"
	
	| view eventsListView newView editView deleteView buttonsView |

	view := ColumnView new.
	newView := PushButtonView new label: 'New'; command: #addDiaryEvent; yourself.
	editView := PushButtonView new label: 'Edit'; command: #editDiaryEvent; yourself.
	deleteView := PushButtonView new label: 'Delete'; command: #removeDiaryEvent; yourself.
	buttonsView := RowView new.

	buttonsView
		addSubView: newView;
		addSubView: editView;
		addSubView: deleteView;
		sizeSubViews: #(1 1 1).

	eventsListView := EnhancedListView new
		reportStyle;
		getImageBlock: [ :aDiaryEvent | aDiaryEvent icon imageIndex-1 ];
		columnAt: 1 put: (ListViewColumn new
			title: 'Description';
			objectBlock: [ :aDiaryEvent | aDiaryEvent description ];
			width: 200;
			yourself);
		addColumn: (ListViewColumn new
			title: 'Time';
			objectBlock: [ :aDiaryEvent | aDiaryEvent triggerTime ];
			width: 250;
			yourself);
		yourself.
	
	view
		addSubView: eventsListView;
		addSubView: buttonsView;
		sizeSubViews: #(10 1).

	view	addConnectionFor: eventsListView toAspect: #filteredDiaryEventsModel.
	^view
!

defaultShellMenu
	"Private - Builds and answers a default menu bar for a Shell displaying the receiver
	This method is for demonstration purposes only and will be replaced by one automatically 
	generated by the Dolphin ViewComposer when this becomes available. 
	For now, you probably don't need to understand what follows"

	| eventMenu |
	eventMenu := (Menu fromStrings: #('&Event'
		'&New.../Ctrl+N/addDiaryEvent'
		'&Edit//editDiaryEvent'
		'-' 
		'&Delete//removeDiaryEvent')).

	^(super defaultShellMenu) add: eventMenu; yourself
!

diary
	"Private - Answers the Diary associated with the receiver"

	^diary!

diary: aDiary
	"Private - Initialize the receiver to access aDiary"

	"The receiver also maintains a ListSelectorModel that holds a list
	of pending DiaryEvents filtered from those in the associated Diary.
	Filters can be #eventsToday, #eventsThisWeek etc."
	filteredDiaryEventsModel := ListSelectorModel new.

	"Connect to aDiary. The diary will trigger a #diaryEvents event whenever
	this aspect of it is changed (as events are added, removed etc). We 
	register with this event and ask to be sent a #diaryEventsChanged message
	whenever its list of current events changes. We can use this to refresh 
	the filtered list of events held by our filteredDiaryEventsModel"
	diary := aDiary.
	aDiary when: #diaryEvents send: #diaryEventsChanged to: self.

	"Pretend that the diary's events have changed and force a refresh"
	self diaryEventsChanged.
!

diaryEventsChanged
	"Private - The list of diary events held by our assciated diary has been changed.
	We need to refresh the filtered list of events held by the receiver"

	self filterDiaryEventsFrom: self diary diaryEvents!

editDiaryEvent
	"A command handler to edit the currently selected DiaryEvent in the receiver. 
	In general such a command will originate from one or more command sources such as
	menus, toolbar buttons, push buttons etc."

	| currentDiaryEvent diaryEventCopyModel |

	"We'll use a DiaryEventEditor tool to edit a copy of the currently selected DiaryEvent. 
	This tool requires that the event be deep copied and the result wrapped in a ValueModel. We
	need to edit a copy to avoid modifying the original event in place and making unwanted
	changes in the case where the DiaryEventEditor is cancelled"
	currentDiaryEvent := self filteredDiaryEventsModel selection.
	diaryEventCopyModel := currentDiaryEvent deepCopy asValue.

	"Create the event editor and show it in a dialog"
	(DiaryEventEditor on: diaryEventCopyModel) inDialog notNil ifTrue: [
		"Ok was pressed so replace the original event in the diary with the new one"
		self diary replaceDiaryEvent: currentDiaryEvent with: diaryEventCopyModel value ]!

filterDiaryEventsFrom: aDiaryEventsCollection
	"Private - Our associated diary has been changed and now holds diary events
	as supplied here in aDiaryEventsCollection. We alter the list of diary events
	held by our filteredDiaryEventsModel to be a subset of this collection based
	on the current filtering criteria (#eventsToday, #eventsThisWeek etc)."

	"NOTE - FILTERING NOT YET IMPLEMENTED- We just pass the entire collection through.
	We can use a #todo marker to remember this. Such markers can be browsed for using
	Method/Browse References"

	#todo "Implement filters".

	self filteredDiaryEvents: aDiaryEventsCollection!

filteredDiaryEvents
	"Private - Answers the list of filtered diary events held by the receiver.
	We use this accessor method to hide the fact that this list is actually being held by 
	a ListSelectorModel in filteredDiaryEventsModel. This is implementation specific detail 
	that is not relevant to users of the DiaryTool"

	^self filteredDiaryEventsModel list!

filteredDiaryEvents: aDiaryEventsCollection
	"Private - Sets the list of filtered diary events held by the receiver to be
	aDiaryEventsCollection. We use this accessor method to hide the fact that
	this list is actually being held by a ListSelectorModel in filteredDiaryEventsModel.
	This is implementation specific detail that is not relevant to users of the DiaryTool"

	self filteredDiaryEventsModel list: aDiaryEventsCollection!

filteredDiaryEventsModel
	"Private - Answer the ListSelectorModel that is used to hold the filtered
	list of diary events from the receiver's diary. A Model must be used
	here since it will be a connection point to which one or more Views can attach.
	Any View that converses using ListSelectorModel protocol can therefore be used
	to display the contents of our filtered diary events list"

	^filteredDiaryEventsModel
!

hasSelectedDiaryEvent
	"Private - Answers true if there is an event selected in our filtered list of 
	pending events"

	^self filteredDiaryEventsModel hasSelection!

queryCommand: aCommandQuery
	"Enters details about a potential command into aCommandQuery. This message is
	sent as part of the command routing process implemented by the application framework. 
	The requirement here is to indicate whether the command supplied in aCommandQuery
	can actually be performed successfully by the receiver in its present state."

	"Most commands can be performed if the receiver responds to the command's
	selector. This is handled in Model>>queryCommand:"
	super queryCommand: aCommandQuery.

	"Our special case is for the #editDiaryEvent and #removeDiaryEvent commands.
	It is only legal to receive these if we actually have selected diary event.
	Enable/disable the supplied command query to reflect this"
	(#(editDiaryEvent removeDiaryEvent) includes: aCommandQuery command) ifTrue: [ 
		aCommandQuery enabled: self hasSelectedDiaryEvent ].
!

removeDiaryEvent
	"A command handler to remove the currently selected DiaryEvent in the receiver from
	the associated diary. In general such a command will originate from one or more 
	command sources such as menus, toolbar buttons, push buttons etc."

	| currentDiaryEvent |
	currentDiaryEvent := self filteredDiaryEventsModel selection.
	self diary removeDiaryEvent: currentDiaryEvent
! !

!DiaryTool categoriesFor: #addDiaryEvent!accessing!commands! !
!DiaryTool categoriesFor: #buildShellWithView:!views! !
!DiaryTool categoriesFor: #buildView!views! !
!DiaryTool categoriesFor: #defaultShellMenu!menus! !
!DiaryTool categoriesFor: #diary!accessing! !
!DiaryTool categoriesFor: #diary:!accessing! !
!DiaryTool categoriesFor: #diaryEventsChanged!updating! !
!DiaryTool categoriesFor: #editDiaryEvent!commands! !
!DiaryTool categoriesFor: #filterDiaryEventsFrom:!accessing! !
!DiaryTool categoriesFor: #filteredDiaryEvents!accessing! !
!DiaryTool categoriesFor: #filteredDiaryEvents:!accessing! !
!DiaryTool categoriesFor: #filteredDiaryEventsModel!models! !
!DiaryTool categoriesFor: #hasSelectedDiaryEvent!commands!testing! !
!DiaryTool categoriesFor: #queryCommand:!commands! !
!DiaryTool categoriesFor: #removeDiaryEvent!commands! !

!DiaryTool class methodsFor!

new
	"Private - An instance of DiaryTool can only be created when
	connected to a Diary. Use #on: to do this.
	Here we prevent #new from exhibiting unwanted behaviour"

	self shouldNotImplement!

on: aDiary
	"Answer an instance of the receiver on aDiary. 
	The new tool will not yet be displayed in any view. A default Shell
	view may be displayed by sending inShell to the new instance"

	^super new diary: aDiary; yourself
! !

!DiaryTool class categoriesFor: #new!ANSI protocols-object class!instance creation! !
!DiaryTool class categoriesFor: #on:!instance creation! !

